<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浏览器中的进程与线程 - Lifetime_yo</title>
<link>http://www.cnblogs.com/quanshubli/p/8552626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanshubli/p/8552626.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文以Chrome浏览器为例，简单整理了浏览器中进程与线程的相关知识。&lt;/li&gt;
&lt;li&gt;以学习为目的，参考了网上的一些相关文章，结合了自己的理解，若表述有误烦请指出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先简单理解一下进程与线程。&lt;/p&gt;
&lt;p&gt;1、进程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程是计算机中程序的一次运行活动，是系统进行资源分配的基本单位。通常我们启动一个程序，CPU便会开启一个进程，并给这个进程分配内存资源。&lt;/li&gt;
&lt;li&gt;任一时刻，一个CPU核心只能运行一个进程，其他进程处于挂起状态。（关于多进程，只是多个进程轮流占用CPU，且每次占用很短时间，这就是并发）&lt;/li&gt;
&lt;li&gt;进程之间相互独立，互不影响，一个进程不能直接访问其他进程中的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程是程序执行的最小单元。通常一个进程中包含了一个或多个线程。&lt;/li&gt;
&lt;li&gt;同一进程中的线程共享资源，且可以并行执行。&lt;/li&gt;
&lt;li&gt;某些线程之间存在相互制约的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　有一个很形象的比喻。如果把CPU比作一个工厂，那么进程就是工厂中的一个个车间，不同车间相互独立。由于工厂资源有限，同一时间只能运作一个车间。而线程就好比是车间里的工人，多个工人共享一个车间，一起工作。&lt;/p&gt;
&lt;p&gt;　　进程与线程简单介绍到这里。&lt;/p&gt;

&lt;p&gt;浏览器有多进程和多线程之分。&lt;/p&gt;
&lt;p&gt;Chrome是多进程浏览器，一个标签页就可以看作一个进程，有时候多个标签页（如空白页）会合并到一个进程。除了管理标签页的Renderer进程外，还有Browser进程、GPU进程等其他多个进程。&lt;/p&gt;
&lt;p&gt;通过浏览器中的 更多工具-任务管理器 可以看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223432/201803/1223432-20180313000050110-163146273.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、为什么采用多进程架构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果所有标签页在同一个进程中，那么某个标签页的崩溃会影响整个浏览器。而多个进程间独占资源，相互隔离，便可避免这个问题&lt;/li&gt;
&lt;li&gt;同样避免第三方插件崩溃而影响整个浏览器&lt;/li&gt;
&lt;li&gt;多进程充分利用多核优势&lt;/li&gt;
&lt;li&gt;由一个主进程来管理和控制其他进程对操作系统资源的访问，具有一定的安全性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、浏览器中的多进程&lt;/p&gt;
&lt;p&gt;　　1、Browser进程（主进程）&lt;/p&gt;
&lt;p&gt;　　　　浏览器主界面显示，处理用户交互，如前进后退&lt;/p&gt;
&lt;p&gt;　　　　管理其他进程，如创建和销毁其他进程，给其他进程分配资源&lt;/p&gt;
&lt;p&gt;　　　　将Renderer进程得到的内存中的Bitmap，绘制到用户界面中&lt;/p&gt;
&lt;p&gt;　　　　管理网络资源，如下载&lt;/p&gt;
&lt;p&gt;　　2、第三方插件进程&lt;/p&gt;
&lt;p&gt;　　　　通常一个插件对应一个进程，仅当使用该插件时才创建&lt;/p&gt;
&lt;p&gt;　　3、GPU进程&lt;/p&gt;
&lt;p&gt;　　　　最多一个，用于图形处理，3D绘制等&lt;/p&gt;
&lt;p&gt;　　4、Renderer进程（渲染进程、渲染引擎、浏览器内核）&lt;/p&gt;
&lt;p&gt;　　　　通常一个标签页对应一个Renderer进程&lt;/p&gt;
&lt;p&gt;　　　　从主进程中获取页面资源&lt;/p&gt;
&lt;p&gt;　　　　解析并渲染页面&lt;/p&gt;
&lt;p&gt;　　　　处理JavaScript脚本等&lt;/p&gt;

&lt;p&gt;3、浏览器中的多线程&lt;/p&gt;
&lt;p&gt;　　例如Browser进程、Renderer进程等，内部有那么多任务，为了保证运行速度，进程中会有多个线程并行工作。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Browser进程中的线程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;UI线程&lt;/strong&gt;：该线程是程序运行的主线程，是程序的入口点，用来处理用户交互，如监听用户输入、前进后退等。同时，会分发任务给其他相应线程去执行。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;IO线程&lt;/strong&gt;：处理Browser进程与其他进程进行进程间通信，下载Renderer进程所需的资源文件等&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;File线程&lt;/strong&gt;：读取磁盘文件、下载文件到磁盘等&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;数据库线程&lt;/strong&gt;：进行一些数据库操作，如保存Cookie到数据库&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;历史记录线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;http服务代理线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　......&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Renderer进程中的线程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;GUI渲染线程&lt;/strong&gt;：解析html、css等文件，渲染页面，处理页面的重绘与回流&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;JavaScript引擎线程&lt;/strong&gt;：处理JavaScript脚本（注意，该线程与渲染线程是互斥的，当该线程执行时，渲染线程会被挂起，等到该线程空闲时再执行）&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;事件触发线程&lt;/strong&gt;：当一个事件被触发时，将其添加到事件队列尾部，由于JavaScript引擎是单线程，所以必须等待其空闲时才会事件队列中的事件&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;定时器线程&lt;/strong&gt;：由于JavaScript引擎是单个线程，存在阻塞，会影响计时的准确性，所以计时由单独的线程控制&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;异步http请求线程&lt;/strong&gt;：在XMLHttpRequest连接后，新开一个线程请求。检测到状态变更时，如果设有回调函数，异步线程就产生状态变更事件，放到事件队列等待处理&lt;/p&gt;

&lt;p&gt;4、Browser进程与Renderer进程如何通信（以开启一个新页面为例）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Browser进程中的UI线程处理用户交互，接收到用户请求，转交给IO线程&lt;/li&gt;
&lt;li&gt;Browser进程中的IO线程获取页面内容（如通过网络请求），随后将该任务通过RendererHost接口传递给Renderer进程&lt;/li&gt;
&lt;li&gt;Renderer进程的Renderer接口收到消息，简单解释后交给渲染线程，进行html、css解析，渲染页面，js执行等任务&lt;/li&gt;
&lt;li&gt;Renderer进程将得到的结果传递给Browser进程&lt;/li&gt;
&lt;li&gt;Browser进程接收到结果并在界面上绘制出图像&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;参考资料：&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 15:21:00 +0000</pubDate>
<dc:creator>Lifetime_yo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanshubli/p/8552626.html</dc:identifier>
</item>
<item>
<title>前端综合学习笔记---异步、ES6/7、Module、Promise同步 vs 异步 - 叶落偏执</title>
<link>http://www.cnblogs.com/yuanziwen/p/8533590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanziwen/p/8533590.html</guid>
<description>&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-17&quot;&gt;同步 vs 异步&lt;/h3&gt;
&lt;p&gt;先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印&lt;span&gt;&lt;code&gt;100&lt;/code&gt;&lt;/span&gt;，1秒钟之后打印&lt;span&gt;&lt;code&gt;200&lt;/code&gt;&lt;/span&gt;，最后打印&lt;span&gt;&lt;code&gt;300&lt;/code&gt;&lt;/span&gt;。但是实际运行根本不是那么回事&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(100&lt;span&gt;)
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;200&lt;span&gt;)
}, &lt;/span&gt;1000&lt;span&gt;)
console.log(&lt;/span&gt;300)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再对比以下程序。先打印&lt;code&gt;100&lt;/code&gt;，再弹出&lt;code&gt;200&lt;/code&gt;（等待用户确认），最后打印&lt;code&gt;300&lt;/code&gt;。这个运行效果就符合预期要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(100&lt;span&gt;)
alert(&lt;/span&gt;200)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1秒钟之后点击确认&lt;/span&gt;
console.log(300)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 异步（后面这个叫做 同步 ），即不会阻塞后面程序的运行。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-18&quot;&gt;异步和单线程&lt;/h3&gt;
&lt;p&gt;JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。&lt;/p&gt;
&lt;p&gt;一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。&lt;/p&gt;
&lt;p&gt;讲到单线程，我们再来看个真题：&lt;/p&gt;
&lt;p&gt;第一问：下面代码的执行过程和结果&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    a &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}, &lt;/span&gt;100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(a){
    console.log(&lt;/span&gt;'while执行了'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个很有迷惑性的题目，不少候选人认为&lt;span&gt;&lt;code&gt;100ms&lt;/code&gt;&lt;/span&gt;之后，由于&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;变成了&lt;span&gt;&lt;code&gt;false&lt;/code&gt;&lt;/span&gt;，所以&lt;span&gt;&lt;code&gt;while&lt;/code&gt;&lt;/span&gt;就中止了，实际不是这样，因为&lt;span&gt;JS&lt;/span&gt;是单线程的，所以进入&lt;code&gt;while&lt;/code&gt;循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-19&quot;&gt;前端异步的场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定时 &lt;span&gt;&lt;code&gt;setTimeout &lt;/code&gt;&lt;code&gt;setInverval&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;网络请求，如 &lt;span&gt;&lt;code&gt;Ajax&lt;/code&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/span&gt;加载&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ajax 代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
console.log('start'&lt;span&gt;)
$.get(&lt;/span&gt;'./data1.json', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data1) {
    console.log(data1)
})
console.log(&lt;/span&gt;'end')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;img 代码示例（常用于打点统计）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log('start'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img = document.createElement('img'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者 img = new Image()&lt;/span&gt;
img.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(&lt;/span&gt;'loaded'&lt;span&gt;)
    img.onload &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
}
img.src &lt;/span&gt;= '/xxx.png'&lt;span&gt;
console.log(&lt;/span&gt;'end'&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-20&quot;&gt;ES6/7 新标准的考查&lt;/h2&gt;
&lt;p&gt;第二问：ES6 箭头函数中的&lt;code&gt;this&lt;/code&gt;和普通函数中的有什么不同&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-21&quot;&gt;箭头函数&lt;/h3&gt;
&lt;p&gt;箭头函数是 ES6 中新的函数定义形式，&lt;code&gt;function name(arg1, arg2) {...}&lt;/code&gt;可以使用&lt;code&gt;(arg1, arg2) =&amp;gt; {...}&lt;/code&gt;来定义。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JS 普通函数&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; arr = [1, 2, 3&lt;span&gt;]
arr.map(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
    console.log(index)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ES6 箭头函数&lt;/span&gt;
const arr = [1, 2, 3&lt;span&gt;]
arr.map((item, index) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(index)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中&lt;code&gt;this&lt;/code&gt;是全局变量的问题，看如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    console.log(&lt;/span&gt;'real', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a: 100} ，该作用域下的 this 的真实的值&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; arr = [1, 2, 3&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 普通 JS&lt;/span&gt;
    arr.map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
        console.log(&lt;/span&gt;'js', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window 。普通函数，这里打印出来的是全局变量，令人费解&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
    })
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 箭头函数&lt;/span&gt;
    arr.map(item =&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'es6', &lt;span&gt;this&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a: 100} 。箭头函数，这里打印的就是父作用域的 this&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; item + 1&lt;span&gt;
    })
}
fn.call({a: &lt;/span&gt;100})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三问：ES6 模块化如何使用？&lt;/p&gt;
&lt;p&gt;ES6 中模块化语法更加简洁，直接看示例。&lt;/p&gt;
&lt;p&gt;如果只是输出一个唯一的对象，使用&lt;span&gt;&lt;code&gt;export default&lt;/code&gt;&lt;/span&gt;即可，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 util1.js 文件，内容如&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    a: &lt;/span&gt;100&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 index.js 文件，内容如&lt;/span&gt;
import obj from './util1.js'&lt;span&gt;
console.log(obj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要输出许多个对象，就不能用&lt;span&gt;&lt;code&gt;default&lt;/code&gt;&lt;/span&gt;了，且&lt;span&gt;&lt;code&gt;import&lt;/code&gt;&lt;/span&gt;时候要加&lt;span&gt;&lt;code&gt;{...}&lt;/code&gt;&lt;/span&gt;，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 util2.js 文件，内容如&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn1() {
    alert(&lt;/span&gt;'fn1'&lt;span&gt;)
}
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn2() {
    alert(&lt;/span&gt;'fn2'&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 index.js 文件，内容如&lt;/span&gt;
import { fn1, fn2 } from './util2.js'&lt;span&gt;
fn1()
fn2()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四问：ES6 class 和普通构造函数的区别&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-23&quot;&gt;class&lt;/h3&gt;
&lt;p&gt;class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如：&lt;/p&gt;
&lt;p&gt;JS 构造函数的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MathHandle(x, y) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
}&lt;br/&gt;MathHandle.prototype.add &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.x + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt; MathHandle(1, 2&lt;span&gt;);
console.log(m.add())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 ES6 class 的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class MathHandle {
  constructor(x, y) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
  }

  add() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.x + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y;
  }
}
const m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MathHandle(1, 2&lt;span&gt;);
console.log(m.add())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意以下几点，全都是关于 class 语法的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;class&lt;/span&gt; 是一种新的语法形式，是&lt;span&gt;class Name {...}&lt;/span&gt;这种形式，和函数的写法完全不一样&lt;/li&gt;
&lt;li&gt;两者对比，构造函数函数体的内容要放在 &lt;span&gt;class&lt;/span&gt; 中的&lt;span&gt;constructor&lt;/span&gt;函数中，&lt;span&gt;constructor&lt;/span&gt;即构造器，初始化实例时默认执行&lt;/li&gt;
&lt;li&gt;class 中函数的写法是&lt;span&gt;add() {...}&lt;/span&gt;这种形式，并没有&lt;span&gt;function&lt;/span&gt;关键字&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子&lt;/p&gt;
&lt;p&gt;JS 构造函数实现继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动物&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Animal() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;'animal eat'&lt;span&gt;)
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 狗&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Dog() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bark = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;'dog bark'&lt;span&gt;)
    }
}
Dog.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈士奇&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; hashiqi = &lt;span&gt;new&lt;/span&gt; Dog()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ES6 class 实现继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Animal {
    constructor(name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    }
    eat() {
        console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name} eat`)
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name) //调用父对象的构造函数
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    }
    say() {
        console.log(`${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name} say`)
    }
}
const dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dog('哈士奇'&lt;span&gt;)
dog.say()
dog.eat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;span&gt;&lt;code&gt;extends&lt;/code&gt;&lt;/span&gt;即可实现继承，更加符合经典面向对象语言的写法，如 &lt;span&gt;Java&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;子类的&lt;span&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/span&gt;一定要执行&lt;span&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/span&gt;，以调用父类的&lt;span&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第五问：ES6 中新增的数据类型有哪些？&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-24&quot;&gt;Set 和 Map&lt;/h3&gt;
&lt;p&gt;Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Set&lt;/span&gt; 类似于数组，但数组可以允许元素重复，&lt;span&gt;Set&lt;/span&gt; 不允许元素重复&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Map&lt;/span&gt; 类似于对象，但普通对象的 &lt;span&gt;key&lt;/span&gt; 必须是字符串或者数字，而 &lt;span&gt;Map&lt;/span&gt; 的 &lt;span&gt;key&lt;/span&gt; 可以是任何数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;Set&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例1&lt;/span&gt;
const set = &lt;span&gt;new&lt;/span&gt; Set([1, 2, 3, 4, 4&lt;span&gt;]);
console.log(set) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set(4) {1, 2, 3, 4}&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 例2&lt;/span&gt;
const set = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
[&lt;/span&gt;2, 3, 5, 4, 5, 8, 8].forEach(item =&amp;gt;&lt;span&gt; set.add(item));
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 3 5 4 8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Set&lt;/span&gt; 实例的属性和方法有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;size&lt;/span&gt;：获取元素数量。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;add(value)&lt;/span&gt;：添加元素，返回 Set 实例本身。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;delete(value)&lt;/span&gt;：删除元素，返回一个布尔值，表示删除是否成功。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;has(value)&lt;/span&gt;：返回一个布尔值，表示该值是否是 Set 实例的元素。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;clear()&lt;/span&gt;：清除所有元素，没有返回值。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Set();
s.add(&lt;/span&gt;1).add(2).add(2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加元素&lt;/span&gt;
&lt;span&gt;
s.size &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;
s.has(&lt;/span&gt;1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
s.has(2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
s.has(3) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
s.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;(2&lt;span&gt;);
s.has(&lt;/span&gt;2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
s.clear();
console.log(s);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set(0) {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Set&lt;/span&gt; 实例的遍历，可使用如下方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;keys()&lt;/span&gt;：返回键名的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;values()&lt;/span&gt;：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以&lt;span&gt;keys()&lt;/span&gt;和&lt;span&gt;values()&lt;/span&gt;返回结果一致。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;entries()&lt;/span&gt;：返回键值对的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;forEach()&lt;/span&gt;：使用回调函数遍历每个成员。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
let set = &lt;span&gt;new&lt;/span&gt; Set(['aaa', 'bbb', 'ccc'&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.keys()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.values()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of set.entries()) {
  console.log(item);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;aaa&quot;, &quot;aaa&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; [&quot;bbb&quot;, &quot;bbb&quot;]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; [&quot;ccc&quot;, &quot;ccc&quot;]&lt;/span&gt;
&lt;span&gt;
set.forEach((value, key) &lt;/span&gt;=&amp;gt; console.log(key + ' : ' +&lt;span&gt; value))
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa : aaa&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb : bbb&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ccc : ccc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Map&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Map&lt;/span&gt; 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 &lt;span&gt;key&lt;/span&gt; 的特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
const obj &lt;/span&gt;= {p: 'Hello World'&lt;span&gt;};

map.set(obj, &lt;/span&gt;'OK'&lt;span&gt;)
map.get(obj) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;OK&quot;&lt;/span&gt;
&lt;span&gt;
map.has(obj) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
map.&lt;span&gt;delete&lt;/span&gt;(obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
map.has(obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要使用&lt;span&gt;new Map()&lt;/span&gt;初始化一个实例，下面代码中&lt;span&gt;set get has delete&lt;/span&gt;顾名即可思义（下文也会演示）。其中，&lt;span&gt;map.set(obj, 'OK')&lt;/span&gt;就是用对象作为的 &lt;span&gt;key&lt;/span&gt; （不光可以是对象，任何数据类型都可以），并且后面通过&lt;span&gt;map.get(obj)&lt;/span&gt;正确获取了。 &lt;span&gt;Map&lt;/span&gt; 实例的属性和方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;size&lt;/code&gt;&lt;/span&gt;：获取成员的数量&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;set&lt;/code&gt;&lt;/span&gt;：设置成员 key 和 value&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;get&lt;/code&gt;&lt;/span&gt;：获取成员属性值&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;has&lt;/code&gt;&lt;/span&gt;：判断成员是否存在&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/span&gt;：删除成员&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/span&gt;：清空所有&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'aaa', 100&lt;span&gt;);
map.set(&lt;/span&gt;'bbb', 200&lt;span&gt;);

map.size &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;
map.get(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;
&lt;span&gt;
map.has(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;
map.&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;('aaa'&lt;span&gt;)
map.has(&lt;/span&gt;'aaa') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;
map.clear()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Map 实例的遍历方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/span&gt;：返回键名的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/span&gt;：返回键值的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;entries()&lt;/code&gt;&lt;/span&gt;：返回所有成员的遍历器。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/span&gt;：遍历 Map 的所有成员。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'aaa', 100&lt;span&gt;);
map.set(&lt;/span&gt;'bbb', 200&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let key of map.keys()) {
  console.log(key);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;aaa&quot;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; &quot;bbb&quot;&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let value of map.values()) {
  console.log(value);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of map.entries()) {
  console.log(item[&lt;/span&gt;0], item[1&lt;span&gt;]);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb 200&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let [key, value] of map.entries()) {
  console.log(key, value);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa 100&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; bbb 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-25&quot;&gt;Promise&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/span&gt;是 &lt;span&gt;CommonJS&lt;/span&gt; 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 &lt;span&gt;Promise&lt;/span&gt; 对象，非 ES6 环境可以用类似 &lt;span&gt;Bluebird&lt;/span&gt;、&lt;span&gt;Q&lt;/span&gt; 这类库来支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt; 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。&lt;/p&gt;
&lt;p&gt;简单归纳下 &lt;span&gt;Promise&lt;/span&gt;：&lt;span&gt;三个状态&lt;/span&gt;、&lt;span&gt;两个过程&lt;/span&gt;、&lt;span&gt;一个方法&lt;/span&gt;，快速记忆方法：&lt;span&gt;3-2-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三个状态：&lt;span&gt;&lt;code&gt;pending&lt;/code&gt;&lt;/span&gt;、&lt;span&gt;&lt;code&gt;fulfilled&lt;/code&gt;&lt;/span&gt;、&lt;span&gt;&lt;code&gt;rejected&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;pending→fulfilled（resolve）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;pending→rejected（reject）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个方法：&lt;span&gt;&lt;code&gt;then&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然还有其他概念，如&lt;span&gt;&lt;code&gt;catch&lt;/code&gt;&lt;/span&gt;、 &lt;code&gt;&lt;span&gt;Promise.all&lt;/span&gt;/&lt;span&gt;race&lt;/span&gt;&lt;/code&gt;，这里就不展开了。&lt;/p&gt;
&lt;p&gt;关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;ES6入门&lt;/a&gt;》。&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 15:02:00 +0000</pubDate>
<dc:creator>叶落偏执</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanziwen/p/8533590.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（六）WPF带标题的内容控件简单介绍 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8563417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8563417.html</guid>
<description>&lt;p&gt;      在WPF自学入门（二）WPF-XAML布局控件的文章中分别介绍StackPanel,WarpPanel,DockPanel,Grid,Canvas五种布局容器的使用，可以让我们大致了解容器可以使用在什么地方。今天我们就来简单了解一下WPF中的三个带标题的内容控件，分别是GroupBox,TabControl和Expander&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、GroupBox控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       这个控件可以叫做分组控件，可以把已经用布局控件包装好的一系列的控件放到里面分为一个组，例如，我们可以放入RadioButton进去，那么就不用设置GroupName也能对单选按钮进行分组了。这个GroupBox是带有圆角的和一个标签和内容的控件，大概是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224340911-372327011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       创建一个GroupBox就是这么简单。好了，这就是GroupBox的使用。当然，Header可以使用更复杂的逻辑，这就要发挥了。控件使用注意事项：我刚开始使用WPF时在使用GroupBox做登录框的布局，发现放一个标签后无法再次放标签。后面想了想在GroupBox控件上放布局控件StackPanel，在放多个控件就没有问题了。所以请大家注意放多个控件时，需要放布局控件在放需要常规控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、TabControl控件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       TabItem是代表TabControl中的一页，在一个TabControl中需要多少页就要靠自己添加。默认的页签是字符串,例如：页签一，看一下TabControl长什么样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224350582-1714185499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      页签可以是字符串，也可以是图片。接下来，我们可以将页签一的文字更改为图片。看看实际效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224400431-357834983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       只添加图片无法满足实际设计需要，WPF中的TabControl也可以弄成图文形式的组合。看看效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224408990-125255748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      这是默认模式的，选择栏是顶部，可以设置为侧边显示，可以通过设置TabStripPlacement属性有四种模式：Left,Right,Bottom,Top(默认)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224417672-686691170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Expander控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        Expander控件是可扩展的控件，它内容默认开始是隐藏好的，很像帮助界面那样，不会在界面给出全部的信息，全部隐藏好，如果你想知道哪个方面的东西，就扩展哪一个Expander，系统默认的样式个人觉得不是很好的，我们可以通过自定义模板来改进样式，首先，一起来看一下Expander控件的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224425928-279573663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        我定义了4个Expender，展开内容使用了4种不同颜色标注。分别是不同方向的展开方式,注意展开方向的使用ExpandDirection控制着在，然后内容各自镶嵌的自己的东西，就是这么简单，最后，看一下程序结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180313224439346-1464128252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     到这里已经简单介绍了三个控件的基本使用，大家应该都知道了三个带标题的内容控件的使用，其实操作一遍后会感觉很简单。WPF是编写程序的核心回到了数据驱动程序的模式上面。下一篇我们进入数据驱动的学习，初识Binding。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 14:43:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8563417.html</dc:identifier>
</item>
<item>
<title>mongodb分布式集群搭建手记 - zale.tang</title>
<link>http://www.cnblogs.com/littleatp/p/8563273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/8563273.html</guid>
<description>&lt;h2 id=&quot;一架构简介&quot;&gt;一、架构简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;br/&gt;单机搭建mongodb分布式集群(副本集 + 分片集群)，演示mongodb分布式集群的安装部署、简单操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/242916/201803/242916-20180313222747434-1293437958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;在同一个vm启动由两个分片组成的分布式集群，每个分片都是一个PSS(Primary-Secondary-Secondary)模式的数据副本集；&lt;br/&gt;Config副本集采用PSS(Primary-Secondary-Secondary)模式。&lt;/p&gt;
&lt;h2 id=&quot;二配置说明&quot;&gt;二、配置说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;端口通讯&lt;br/&gt;当前集群中存在shard、config、mongos共12个进程节点，端口矩阵编排如下：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;mongos&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;shard1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;shard2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内部鉴权&lt;br/&gt;节点间鉴权采用keyfile方式实现鉴权，mongos与分片之间、副本集节点之间共享同一套keyfile文件。 &lt;a href=&quot;http://www.cnblogs.com/littleatp/p/8563273.html&quot;&gt;官方说明&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;账户设置&lt;br/&gt;管理员账户：&lt;a href=&quot;mailto:admin/Admin@01&quot;&gt;admin/Admin@01&lt;/a&gt;，具有集群及所有库的管理权限&lt;br/&gt;应用账号：&lt;a href=&quot;mailto:appuser/AppUser@01&quot;&gt;appuser/AppUser@01&lt;/a&gt;，具有appdb的owner权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关于初始化权限&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;keyfile方式默认会开启鉴权，而针对初始化安装的场景，Mongodb提供了&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-users/#localhost-exception&quot;&gt;localhost-exception机制&lt;/a&gt;，&lt;br/&gt;可以在首次安装时通过本机创建用户、角色，以及副本集初始操作。&lt;/p&gt;
&lt;h2 id=&quot;三准备工作&quot;&gt;三、准备工作&lt;/h2&gt;
&lt;h3 id=&quot;下载安装包&quot;&gt;1. 下载安装包&lt;/h3&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;https://www.mongodb.com/download-center&quot; class=&quot;uri&quot;&gt;https://www.mongodb.com/download-center&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.3.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署目录&quot;&gt;2. 部署目录&lt;/h3&gt;
&lt;p&gt;解压压缩文件，将bin目录拷贝到目标路径&lt;strong&gt;/opt/local/mongo-cluster&lt;/strong&gt;，参考以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xzvf mongodb-linux-x86_64-rhel70-3.6.3.tgz
mkdir -p  /opt/local/mongo-cluster
cp -r mongodb-linux-x86_64-rhel70-3.6.3/bin  /opt/local/mongo-cluster&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建配置文件&quot;&gt;3. 创建配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/local/mongo-cluster
mkdir conf &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;A. &lt;strong&gt;mongod 配置文件 mongo_node.conf&lt;/strong&gt;&lt;br/&gt;mongo_node.conf 作为mongod实例共享的配置文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;storage:
    engine: wiredTiger
    directoryPerDB: true
    journal:
        enabled: true
systemLog:
    destination: file
    logAppend: true
operationProfiling:
  slowOpThresholdMs: 10000
replication:
    oplogSizeMB: 10240
processManagement:
    fork: true
net:
    http:
      enabled: false
security:
    authorization: &quot;enabled&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选项说明可&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/index.html&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;B. &lt;strong&gt;mongos 配置文件 mongos.conf&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemLog:
    destination: file
    logAppend: true
processManagement:
    fork: true
net:
    http:
      enabled: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建keyfile文件&quot;&gt;4. 创建keyfile文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/local/mongo-cluster
mkdir keyfile
openssl rand -base64 756 &amp;gt; mongo.key
chmod 400 mongo.key
mv mongo.key keyfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mongo.key 采用随机算法生成，用作节点内部通讯的密钥文件&lt;/p&gt;
&lt;h3 id=&quot;创建节点目录&quot;&gt;5. 创建节点目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
mkdir -p $WORK_DIR/nodes/config/n1/data
mkdir -p $WORK_DIR/nodes/config/n2/data
mkdir -p $WORK_DIR/nodes/config/n3/data

mkdir -p $WORK_DIR/nodes/shard1/n1/data
mkdir -p $WORK_DIR/nodes/shard1/n2/data
mkdir -p $WORK_DIR/nodes/shard1/n3/data

mkdir -p $WORK_DIR/nodes/shard2/n1/data
mkdir -p $WORK_DIR/nodes/shard2/n2/data
mkdir -p $WORK_DIR/nodes/shard2/n3/data

mkdir -p $WORK_DIR/nodes/mongos/n1
mkdir -p $WORK_DIR/nodes/mongos/n2
mkdir -p $WORK_DIR/nodes/mongos/n3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以config 节点1 为例，nodes/config/n1/data是数据目录，而pid文件、日志文件都存放于n1目录&lt;br/&gt;以mongos 节点1 为例，nodes/mongos/n1 存放了pid文件和日志文件&lt;/p&gt;
&lt;h2 id=&quot;四搭建集群&quot;&gt;四、搭建集群&lt;/h2&gt;
&lt;h3 id=&quot;config副本集&quot;&gt;1. Config副本集&lt;/h3&gt;
&lt;p&gt;按以下脚本启动3个Config实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongo_node.conf
MONGOD=$WORK_DIR/bin/mongod

$MONGOD --port 26001 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n1/data --pidfilepath $WORK_DIR/nodes/config/n1/db.pid --logpath $WORK_DIR/nodes/config/n1/db.log --config $CONFFILE

$MONGOD --port 26002 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n2/data --pidfilepath $WORK_DIR/nodes/config/n2/db.pid --logpath $WORK_DIR/nodes/config/n2/db.log --config $CONFFILE

$MONGOD --port 26003 --configsvr --replSet configReplSet --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/config/n3/data --pidfilepath $WORK_DIR/nodes/config/n3/db.pid --logpath $WORK_DIR/nodes/config/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;about to fork child process, waiting until server is ready for connections.
forked process: 4976
child process started successfully, parent exiting&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时通过ps 命令也可以看到3个启动的进程实例。&lt;/p&gt;
&lt;p&gt;连接其中一个Config进程，执行副本集初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 26001 --host 127.0.0.1
&amp;gt; MongoDB server version: 3.4.7
&amp;gt; cfg={
    _id:&quot;configReplSet&quot;, 
    configsvr: true,
    members:[
        {_id:0, host:'127.0.0.1:26001'},
        {_id:1, host:'127.0.0.1:26002'}, 
        {_id:2, host:'127.0.0.1:26003'}
    ]};
rs.initiate(cfg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;strong&gt;configsvr:true&lt;/strong&gt;指明这是一个用于分片集群的Config副本集。&lt;br/&gt;关于副本集配置可&lt;a href=&quot;https://docs.mongodb.com/manual/reference/replica-configuration/&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建分片&quot;&gt;2. 创建分片&lt;/h3&gt;
&lt;p&gt;按以下脚本启动Shard1的3个实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongo_node.conf
MONGOD=$WORK_DIR/bin/mongod

echo &quot;start shard1 replicaset&quot;

$MONGOD --port 27001 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n1/data --pidfilepath $WORK_DIR/nodes/shard1/n1/db.pid --logpath $WORK_DIR/nodes/shard1/n1/db.log --config $CONFFILE
$MONGOD --port 27002 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n2/data --pidfilepath $WORK_DIR/nodes/shard1/n2/db.pid --logpath $WORK_DIR/nodes/shard1/n2/db.log --config $CONFFILE
$MONGOD --port 27003 --shardsvr --replSet shard1 --keyFile $KEYFILE --dbpath $WORK_DIR/nodes/shard1/n3/data --pidfilepath $WORK_DIR/nodes/shard1/n3/db.pid --logpath $WORK_DIR/nodes/shard1/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;about to fork child process, waiting until server is ready for connections.
forked process: 5976
child process started successfully, parent exiting&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时通过ps 命令也可以看到3个启动的Shard进程实例。&lt;/p&gt;
&lt;p&gt;连接其中一个Shard进程，执行副本集初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 27001 --host 127.0.0.1
&amp;gt; MongoDB server version: 3.4.7
&amp;gt; cfg={
    _id:&quot;shard1&quot;, 
    members:[
        {_id:0, host:'127.0.0.1:27001'},
        {_id:1, host:'127.0.0.1:27002'}, 
        {_id:2, host:'127.0.0.1:27003'}
    ]};
rs.initiate(cfg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考以上步骤，启动Shard2的3个实例进程，并初始化副本集。&lt;/p&gt;
&lt;h3 id=&quot;启动mongos路由&quot;&gt;3. 启动mongos路由&lt;/h3&gt;
&lt;p&gt;执行以下脚本启动3个mongos进程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WORK_DIR=/opt/local/mongo-cluster
KEYFILE=$WORK_DIR/keyfile/mongo.key
CONFFILE=$WORK_DIR/conf/mongos.conf
MONGOS=$WORK_DIR/bin/mongos

echo &quot;start mongos instances&quot;
$MONGOS --port=25001 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n1/db.pid --logpath $WORK_DIR/nodes/mongos/n1/db.log --config $CONFFILE
$MONGOS --port 25002 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n2/db.pid --logpath $WORK_DIR/nodes/mongos/n2/db.log --config $CONFFILE
$MONGOS --port 25003 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile $KEYFILE --pidfilepath $WORK_DIR/nodes/mongos/n3/db.pid --logpath $WORK_DIR/nodes/mongos/n3/db.log --config $CONFFILE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;待成功启动后，通过ps命令看到mongos进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dbuser      7903    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port=25001 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n1/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n1/db.log --config /opt/local/mongo-cluster/conf/mongos.conf
dbuser      7928    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port 25002 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n2/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n2/db.log --config /opt/local/mongo-cluster/conf/mongos.conf
dbuser      7954    1  0 17:49 ?        00:00:00 /opt/local/mongo-cluster/bin/mongos --port 25003 --configdb configReplSet/127.0.0.1:26001,127.0.0.1:26002,127.0.0.1:26003 --keyFile /opt/local/mongo-cluster/keyfile/mongo.key --pidfilepath /opt/local/mongo-cluster/nodes/mongos/n3/db.pid --logpath /opt/local/mongo-cluster/nodes/mongos/n3/db.log --config /opt/local/mongo-cluster/conf/mongos.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接入其中一个mongos实例，执行添加分片操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mongo --port 25001 --host 127.0.0.1
mongos&amp;gt; MongoDB server version: 3.4.7
mongos&amp;gt; sh.addShard(&quot;shard1/127.0.0.1:27001&quot;)
{ &quot;shardAdded&quot; : &quot;shard1&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard(&quot;shard2/127.0.0.1:27004&quot;)
{ &quot;shardAdded&quot; : &quot;shard2&quot;, &quot;ok&quot; : 1 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，分布式集群架构启动完毕，但进一步操作需要先添加用户。&lt;/p&gt;
&lt;h3 id=&quot;初始化用户&quot;&gt;4. 初始化用户&lt;/h3&gt;
&lt;p&gt;接入其中一个mongos实例，添加管理员用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use admin
db.createUser({
    user:'admin',pwd:'Admin@01',
    roles:[
        {role:'clusterAdmin',db:'admin'},
        {role:'userAdminAnyDatabase',db:'admin'},
        {role:'dbAdminAnyDatabase',db:'admin'},
        {role:'readWriteAnyDatabase',db:'admin'}
]})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前admin用户具有集群管理权限、所有数据库的操作权限。&lt;br/&gt;需要注意的是，在第一次创建用户之后，localexception不再有效，接下来的所有操作要求先通过鉴权。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use admin
db.auth('admin','Admin@01')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;检查集群状态&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
    &quot;_id&quot; : 1,
    &quot;minCompatibleVersion&quot; : 5,
    &quot;currentVersion&quot; : 6,
    &quot;clusterId&quot; : ObjectId(&quot;5aa39c3e915210dc501a1dc8&quot;)
}
  shards:
    {  &quot;_id&quot; : &quot;shard1&quot;,  &quot;host&quot; : &quot;shard1/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003&quot;,  &quot;state&quot; : 1 }
    {  &quot;_id&quot; : &quot;shard2&quot;,  &quot;host&quot; : &quot;shard2/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006&quot;,  &quot;state&quot; : 1 }
  active mongoses:
    &quot;3.4.7&quot; : 3
autosplit:
    Currently enabled: yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;集群用户&lt;/strong&gt;&lt;br/&gt;分片集群中的访问都会通过mongos入口，而鉴权数据是存储在config副本集中的，即config实例中system.users数据库存储了集群用户及角色权限配置。mongos与shard实例则通过内部鉴权(keyfile机制)完成，因此shard实例上可以通过添加本地用户以方便操作管理。在一个副本集上，只需要在Primary节点上添加用户及权限，相关数据会自动同步到Secondary节点。&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-users/#sharded-cluster-users&quot;&gt;关于集群鉴权&lt;/a&gt;&lt;br/&gt;在本案例中，我们为两个分片副本集都添加了本地admin用户。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&quot;https://docs.mongodb.com/manual/reference/program/mongostat/&quot;&gt;mongostat工具&lt;/a&gt;可以显示集群所有角色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;          host insert query update delete getmore command dirty used flushes mapped vsize  res faults qrw arw net_in net_out conn    set repl                time
127.0.0.1:27001    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.49G 44.0M    n/a 0|0 0|0  429b  56.1k  25 shard1  PRI Mar 10 19:05:13.928
127.0.0.1:27002    *0    *0    *0    *0      0    7|0  0.1% 0.1%      0        1.43G 43.0M    n/a 0|0 0|0  605b  55.9k  15 shard1  SEC Mar 10 19:05:13.942
127.0.0.1:27003    *0    *0    *0    *0      0    7|0  0.1% 0.1%      0        1.43G 43.0M    n/a 0|0 0|0  605b  55.9k  15 shard1  SEC Mar 10 19:05:13.946
127.0.0.1:27004    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.48G 43.0M    n/a 0|0 0|0  546b  55.8k  18 shard2  PRI Mar 10 19:05:13.939
127.0.0.1:27005    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.43G 42.0M    n/a 0|0 0|0  540b  54.9k  15 shard2  SEC Mar 10 19:05:13.944
127.0.0.1:27006    *0    *0    *0    *0      0    6|0  0.1% 0.1%      0        1.46G 44.0M    n/a 0|0 0|0  540b  54.9k  17 shard2  SEC Mar 10 19:05:13.936&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五数据操作&quot;&gt;五、数据操作&lt;/h2&gt;
&lt;p&gt;在案例中，创建appuser用户、为数据库实例appdb启动分片。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
db.createUser({user:'appuser',pwd:'AppUser@01',roles:[{role:'dbOwner',db:'appdb'}]})
sh.enableSharding(&quot;appdb&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建集合book，为其执行分片初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
db.createCollection(&quot;book&quot;)
db.device.ensureIndex({createTime:1})
sh.shardCollection(&quot;appdb.book&quot;, {bookId:&quot;hashed&quot;}, false, { numInitialChunks: 4} )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续往device集合写入1000W条记录，观察chunks的分布情况&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use appdb
var cnt = 0;
for(var i=0; i&amp;lt;1000; i++){
    var dl = [];
    for(var j=0; j&amp;lt;100; j++){
        dl.push({
                &quot;bookId&quot; : &quot;BBK-&quot; + i + &quot;-&quot; + j,
                &quot;type&quot; : &quot;Revision&quot;,
                &quot;version&quot; : &quot;IricSoneVB0001&quot;,
                &quot;title&quot; : &quot;Jackson's Life&quot;,
                &quot;subCount&quot; : 10,
                &quot;location&quot; : &quot;China CN Shenzhen Futian District&quot;,
                &quot;author&quot; : {
                      &quot;name&quot; : 50,
                      &quot;email&quot; : &quot;RichardFoo@yahoo.com&quot;,
                      &quot;gender&quot; : &quot;female&quot;
                },
                &quot;createTime&quot; : new Date()
            });
      }
      cnt += dl.length;
      db.book.insertMany(dl);
      print(&quot;insert &quot;, cnt);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;strong&gt;db.book.getShardDistribution()&lt;/strong&gt;,输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Shard shard1 at shard1/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003
data : 13.41MiB docs : 49905 chunks : 2
estimated data per chunk : 6.7MiB
estimated docs per chunk : 24952

Shard shard2 at shard2/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006
data : 13.46MiB docs : 50095 chunks : 2
estimated data per chunk : 6.73MiB
estimated docs per chunk : 25047

Totals
data : 26.87MiB docs : 100000 chunks : 4
Shard shard1 contains 49.9% data, 49.9% docs in cluster, avg obj size on shard : 281B
Shard shard2 contains 50.09% data, 50.09% docs in cluster, avg obj size on shard : 281B&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Mongodb集群架构由Mongos、Config副本集和多个分片组成；&lt;br/&gt;安装过程中先初始化Config副本集、分片副本集，最后通过Mongos添加分片&lt;/li&gt;
&lt;li&gt;Config副本集存储了集群访问的用户及角色权限，为了方便管理，可以给分片副本集添加本地用户&lt;/li&gt;
&lt;li&gt;Mongodb提供了LocalException机制，首次安装数据库时可以在本机直接添加用户&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 13 Mar 2018 14:29:00 +0000</pubDate>
<dc:creator>zale.tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/8563273.html</dc:identifier>
</item>
<item>
<title>麻省理工18年春软件构造课程阅读05“版本控制” - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8563078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8563078.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/&quot;&gt;MIT_6.031_sp18: Software Construction&lt;/a&gt;课程的Readings部分，采用&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;协议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们学校（哈工大）大二软件构造课程的大部分素材取自此，也是推荐的阅读材料之一，于是打算做一些翻译工作，自己学习的同时也能帮到一些懒得看英文的朋友。另外，该课程的阅读资料中有许多练习题，但是没有标准答案，所给出的答案均为译者所写，有错误的地方还请指出。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;审校：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0 Mon Mar 12 22:44:59 CST 2018&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;译者注：我觉得网上的这篇教程&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/&quot;&gt;Git教程 - 廖雪峰&lt;/a&gt; 更清楚详细的表达出了版本控制的缘由及对应操作，同时也非常简练，推荐大家看这个。所以这篇阅读资料只翻译了一个&lt;code&gt;git show&lt;/code&gt;命令，完整的版本请参考&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/classes/05-version-control/&quot;&gt;05: Version Control&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;......（省略）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;为什么提交commits看起来像-diffs&quot;&gt;&lt;span&gt;为什么提交（commits）看起来像 &lt;code&gt;diffs&lt;/code&gt;?&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们之前将一次提交定义为对整个工程的一次快照，但是如果你问Git，它返回的结果好像不是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; show 1255f4e
&lt;span class=&quot;kw&quot;&gt;commit&lt;/span&gt; 1255f4e4a5836501c022deb337fda3f8800b02e4
&lt;span class=&quot;kw&quot;&gt;Author&lt;/span&gt;: Max Goldman &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;maxg@mit.edu&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Date&lt;/span&gt;:   Mon Sep 14 14:58:40 2015 -0400

    &lt;span class=&quot;kw&quot;&gt;Change&lt;/span&gt; the greeting

&lt;span class=&quot;kw&quot;&gt;diff&lt;/span&gt; --git a/hello.txt b/hello.txt
&lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; c1106ab..3462165 100644
&lt;span class=&quot;kw&quot;&gt;---&lt;/span&gt; a/hello.txt
&lt;span class=&quot;kw&quot;&gt;+++&lt;/span&gt; b/hello.txt
&lt;span class=&quot;kw&quot;&gt;@@&lt;/span&gt; -1 +1 @@
&lt;span class=&quot;kw&quot;&gt;-Hello&lt;/span&gt;, version control!
&lt;span class=&quot;kw&quot;&gt;+Hello&lt;/span&gt; again, version control!&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Git觉得我们提交的项目中大多数内容是没变的，于是它只会显示出改变的内容。实际上，这也和Git的存储方式相同——它只会存储改变后的文件，每次提交中没变的文件都会指向之前提交中的文件：（还记得之前提到过的值不能改变的对象(immutable object)吗？）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180313221133440-1107930497.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我们可以要求Git显示出指定提交中所有的文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; show 3e62e60:
&lt;span class=&quot;kw&quot;&gt;tree&lt;/span&gt; 3e62e60:

&lt;span class=&quot;kw&quot;&gt;hello.rb&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;hello.scm&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;hello.txt&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看，仅仅一个分号就改变了整个输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们更可以指定一个特定提交中的特定文件的内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; show 3e62e60:hello.scm
&lt;span class=&quot;kw&quot;&gt;(display&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Hello, version control!&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这也是恢复文件的一种方法：使用 &lt;code&gt;git show&lt;/code&gt; 显示出你上次提交的时候文件的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;译者注：&lt;code&gt;diff&lt;/code&gt;命令的操作和阅读可以参考&lt;a href=&quot;http://www.cnblogs.com/wangqiguo/p/5793448.html&quot;&gt;diff详解,读懂diff结果&lt;/a&gt; 和 &lt;a href=&quot;http://man.linuxde.net/diff&quot;&gt;diff命令&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;......（省略）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 14:16:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8563078.html</dc:identifier>
</item>
<item>
<title>函数与函数式编程 - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/8562719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/8562719.html</guid>
<description>&lt;p&gt;纵观JavaScript中所有必须需要掌握的重点知识中，函数是我们在初学的时候最容易忽视的一个知识点。在学习的过程中，可能会有很多人、很多文章告诉你面向对象很重要，原型很重要，可是却很少有人告诉你，面向对象中所有的重点难点，几乎都与函数息息相关。&lt;/p&gt;
&lt;h5 data-id=&quot;heading-0&quot;&gt;一、函数声明、函数表达式、匿名函数与自执行函数&lt;/h5&gt;
&lt;p&gt;关于函数在实际开发中的应用，大体可以总结为函数声明、函数表达式、匿名函数、自执行函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道，JavaScript中，有两种声明方式，一个是使用&lt;code&gt;var&lt;/code&gt;的变量声明，另一个是使用&lt;code&gt;function&lt;/code&gt;的函数声明。&lt;/p&gt;
&lt;p&gt;变量对象的创建过程中，函数声明比变量声明具有更为优先的执行顺序，即我们常常提到的函数声明提前。因此我们在执行上下文中，无论在什么位置声明了函数，我们都可以在同一个执行上下文中直接使用该函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fn();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; function&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    console.log(&lt;/span&gt;'function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数表达式 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与函数声明不同，函数表达式使用了var进行声明，那么我们在确认他是否可以正确使用的时候就必须依照var的规则进行判断，即变量声明（我们知道使用var进行变量声明，其实是进行了两步操作。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际执行顺序&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = undefined;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明，初始值undefined，变量提升，提升顺序次于function声明&lt;/span&gt;
a = 20;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量赋值，该操作不会提升&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量声明过程+变量执行过程　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的道理，当我们使用变量声明的方式来声明函数时，就是我们常常说的函数表达式。函数表达的提升方式与变量声明一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fn(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例子的执行顺序为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fn = undefined;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变量声明提升&lt;/span&gt;
fn();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行报错&lt;/span&gt;
fn = &lt;span&gt;function&lt;/span&gt;() {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值操作，此时将后边函数的引用赋值给fn&lt;/span&gt;
    console.log('function'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;变量声明过程+变量执行过程+赋值操作过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此，由于声明方式的不同，导致了函数声明与函数表达式在使用上的一些差异需要我们注意，除此之外，这两种形式的函数在使用上并无不同。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于上面例子中，函数表达式中的赋值操作，在其他一些地方也会被经常使用，我们清楚其中的关系即可。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;在构造函数中添加方法
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在构造函数内部中添加方法&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.getAge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给原型添加方法&lt;/span&gt;
Person.prototype.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在对象中添加方法&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; {
    m: &lt;/span&gt;20&lt;span&gt;,
    getM: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.m;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在上面我们大概讲述了函数表达式中的赋值操作。而匿名函数，顾名思义，就是指的没有被显示进行赋值操作的函数。它的使用场景，多作为一个参数传入另一个函数中。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(bar, num) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bar() +&lt;span&gt; num;
}

fn(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}, &lt;/span&gt;20)        //30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，fn的第一个参数传入了一个匿名函数。虽然该匿名函数没有显示的进行赋值操作，我们没有办法在外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了变量bar，保存在了fn变量对象的arguments对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数自执行与块级作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。&lt;/p&gt;
&lt;p&gt;根据作用域链的单向访问，外面可能很容易知道在这个独立的模块中，外部执行环境是无法访问内部的任何变量与方法的，因此我们可以很容易的创建属于这个模块的私有变量与私有方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有变量&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'Tom'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `your name is ` +&lt;span&gt; name;
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是共有方法和变量应该怎么办？大家还记得我们前面讲到过的&lt;strong&gt;闭包&lt;/strong&gt;的特性吗？没错，利用闭包，我们可以访问到执行上下文内部的变量和方法，因此，我们只需要根据闭包的定义，创建一个闭包，将你认为需要公开的变量和方法开放出来即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有变量&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'Tom'&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; `your name is ` +&lt;span&gt; name;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 共有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收&lt;/span&gt;
    window.getAge =&lt;span&gt; getAge;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了帮助大家进一步理解闭包，我们来看看jQuery中，是如何利用我们模块与闭包的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用函数自执行的方式创建模块&lt;/span&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(window, undefined) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明jQuery构造函数&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; jQuery = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主动在构造函数中，返回一个jQuery实例&lt;/span&gt;
         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; jQuery.fn.init(name);
     }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加原型方法&lt;/span&gt;
     jQuery.prototype = jQuery.fn =&lt;span&gt; {
         constructor: jQuery,
         init:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... },
         css: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... }
     }
     jQuery.fn.init.prototype &lt;/span&gt;=&lt;span&gt; jQuery.fn;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了&lt;/span&gt;
     window.jQuery = window.$ =&lt;span&gt; jQuery;
 })(window);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了&lt;/span&gt;
$('#div1');
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 data-id=&quot;heading-1&quot;&gt;二、函数参数传递方式：按值传递&lt;/h5&gt;
&lt;p&gt;还记得基本数据类型与引用数据类型在复制上的差异吗？基本数据类型复制，是直接值发生了复制，因此改变后，各自相互不影响。但是引用数据类型的复制，是保存在变量对象中的引用发生了复制，因此复制之后的这两个引用实际访问的实际是同一个堆内存中的值。当改变其中一个时，另外一个自然也被改变。如下例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a;
b &lt;/span&gt;= 10&lt;span&gt;;
console.log(a);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; m = { a: 1, b: 2&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; m;
n.a &lt;/span&gt;= 5&lt;span&gt;;
console.log(m.a) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当值作为函数的参数传递进入函数内部时，也有同样的差异。我们知道，函数的参数在进入函数后，实际是被保存在了函数的变量对象中，因此，这个时候相当于发生了一次复制。如下例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a) {
    a &lt;/span&gt;= a + 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}

console.log(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = { m: 10, n: 20&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(a) {
    a.m &lt;/span&gt;= 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
}

fn(a);
console.log(a);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { m: 20, n: 20 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正是由于这样的不同，导致了许多人在理解函数参数的传递方式时，就有许多困惑。到底是按值传递还是按引用传递？实际上结论仍然是按值传递，只不过当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已。为了说明这个问题，我们看看下面这个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {
    name: &lt;/span&gt;'Nicholas'&lt;span&gt;,
    age: &lt;/span&gt;20&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; setName(obj) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入一个引用&lt;/span&gt;
    obj = {};   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将传入的引用指向另外的值&lt;/span&gt;
    obj.name = 'Greg';  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改引用的name属性&lt;/span&gt;
&lt;span&gt;}

setName(person);
console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas 未被改变&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，如果person是按引用传递，那么person就会自动被修改为指向其name属性值为Gerg的新对象。但是我们从结果中看到，person对象并未发生任何改变，因此只是在函数内部引用被修改而已。&lt;/p&gt;
&lt;h5 data-id=&quot;heading-2&quot;&gt;四、函数式编程&lt;/h5&gt;
&lt;p&gt;虽然JavaScript并不是一门纯函数式编程的语言，但是它使用了许多函数式编程的特性。因此了解这些特性可以让我们更加了解自己写的代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数是第一等公民&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。这些场景，我们应该见过很多&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;function&lt;/span&gt; foo() {}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; fn(&lt;span&gt;function&lt;/span&gt;() {}, num) {}   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数作为参数&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数作为返回值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        ... ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 13:42:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/8562719.html</dc:identifier>
</item>
<item>
<title>Java集合中的HashMap类 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8558983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8558983.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;jdk1.8.0_144&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         HashMap作为最常用集合之一，继承自AbstractMap。JDK8的HashMap实现与JDK7不同，新增了红黑树作为底层数据结构，结构变得复杂，效率变得更高。为满足自身需要，也重新实现了很多AbstractMap中的方法。本文会围绕HashMap，详细探讨HashMap的底层数据结构、扩容机制、并发环境下的死循环问题等。&lt;/p&gt;
&lt;p&gt;         JDK8同JDK7一样对Map.Entry进行了重新实现，改了个名字叫——Node，我想这是因为在红黑树中更方便理解，方法和JDK7大体相同只是取消了几个方法。并且此时的Node节点（也就是Entry）结构更加完善：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点hash值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; K key;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     V value;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;value值&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     Node&amp;lt;K,V&amp;gt; next;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向的下一个节点
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略，由于JDK8的Map接口新增了几个compare比较的方法，Node直接就继承了&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Node作为HashMap维护key-value的内部数据结构比较简单，下面是HashMap重新实现Map的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public int size()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         HashMap并没有继承AbstractMap的size方法，而是重写了此方法。HashMap在类中定义了一个size变量，再此处直接返回size变量而不用调用entrySet方法返回集合再计算。可以猜测这个size变量是当插入一个key-value键值对的时候自增。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public boolean isEmpty()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         判断size变量是否0即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public boolean containsKey(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         AbstractMap通过遍历Entry节点的方式实现了这个方法，显然HashMap觉得效率太低并没有复用而是重写了这个方法。&lt;/p&gt;
&lt;p&gt;         JDK8的HashMap底层数据结构引入了红黑树，它的实现要比JDK7略微复杂，我们先来看JDK7关于这个方法的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7，HashMap#containsKey&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getEntry(key) != &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getEntry方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　getEntry实现的思路也比较简单，由于JDK7的HashMap是数组+链表的数据结构，当key的hash值冲突的时候使用链地址法直接加到冲突地址Entry的next指针行程链表即可。所以getEntry方法的思路也是先计算key的hash值，计算后再找到它在散列表的下标，找到过再遍历这个位置的链表返回结果即可。&lt;/p&gt;
&lt;p&gt;　　JDK8加入了红黑树，在链表的个数达到阈值8时会将链表转换为红黑树，如果此时是红黑树，则不能通过遍历链表的方式寻找key值，所以JDK8对该方法进行了改进主要是需要遍历红黑树，有关&lt;strong&gt;红黑树&lt;/strong&gt;的具体算法在此不多介绍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8，HashMap#containsKey&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(Object key) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; getNode(hash(key), key) != &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8中新增了一个getNode方法，且将key的hash值计算好后作为参数传递。&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HashMap#getNode&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此方法相比较于JDK7中的getEntry基本相同，唯一不同的是发现key值冲突过后会通过“first instanceof TreeNode”检查此时是否是红黑树结构。如果是红黑树则会调用getTreeNode方法在红黑树上进行查询。如果不是红黑树则是链表结构，遍历链表即可。&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;public boolean containsValue(Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　遍历散列表中的元素&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public V get(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 在JDK8中get方法调用了containsKey的方法getNode，这点和JDk7的get方法中调用getEntry方法类似。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将参数key的hash值和key作为参数，调用getNode方法；&lt;/li&gt;
&lt;li&gt;根据(n - 1) &amp;amp; hash(key)计算key值所在散列桶的下标；&lt;/li&gt;
&lt;li&gt;取出散列桶中的key与参数key进行比较：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;         3.1 如果相等则直接返回Node节点；&lt;/p&gt;
&lt;p&gt;         3.2 如果不相等则判断当前节点是否有后继节点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                   3.2.1&lt;/strong&gt; &lt;strong&gt;判断是否是红黑树结构，是则调用getTreeNode&lt;/strong&gt;&lt;strong&gt;查询键值为key&lt;/strong&gt;&lt;strong&gt;的Node  &lt;/strong&gt; &lt;strong&gt;节点；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                   3.2.2 如果是链表结构，则遍历整个链表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public V put(K key, V value)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法最为关键，插入key-value到Map中，在这个方法中需要计算key的hash值，然后通过hash值计算所在散列桶的位置，判断散列桶的位置是否有冲突，冲突过后需要使用链地址法解决冲突，使之形成一个链表，从JDK8开始如果链表的元素达到8个过后还会转换为红黑树。在插入时还需要判断是否需要扩容，扩容机制的设计，以及在并发环境下扩容所带来的死循环问题。&lt;/p&gt;
&lt;p&gt;　　由于JDK7比较简单，我们先来查看JDK7中的put方法源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK7&lt;/strong&gt;&lt;strong&gt;——HashMap#put&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7, HashMap#put&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 首先判断是否是第一次插入，即散列表是否指向空的数组，如果是，则调用inflateTable方法对HashMap进行初始化。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; EMPTY_TABLE) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        inflateTable(threshold);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 判断key是否等于null，等于空则调用putForNullKey方法存入key为null的key-value，HashMap支持key=null。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; putForNullKey(value);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 调用hash方法计算key的hash值，调用indexFor根据hash值和散列表的长度计算key值所在散列表的下标i。&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; indexFor(hash, table.length);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4. 这一步通过循环遍历的方式判断插入的key-value是否已经在HashMap中存在，判断条件则是key的hash值相等，且value要么引用相等要么equals相等，如果满足则直接返回value。&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != &lt;span&gt;null&lt;/span&gt;; e = e.next) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果插入位置没有散列冲突，即这个位置没有Entry元素，则不进入循环。有散列冲突则需要遍历链表进行判断。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        Object k;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key ||&lt;span&gt; key.equals(k))) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             e.recordAccess(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     modCount++；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录修改次数，在并发环境下通过迭代器遍历时会抛出ConcurrentModificationException异常（Fail-Fast机制），就是通过这个变量来实现的。在迭代器初始化过程会将modCount赋给迭代器的ExpectedModCount，是否会抛出ConcurrentModificationException异常的实现就是在迭代过程中判断modCount是否与ExpectedModCount相等。
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入key-value键值对，传入key的hash值、key、value、散列表的插入位置i&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    addEntry(hash, key, value, i);    
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }                
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK7，HashMap#addEntry，这个方法是put方法的实现核心，在其中会判断是否冲突，是否扩容。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucketIndex) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步判断就是是否扩容，需要扩容的条件需要满足以下两个：1、Map中的key-value的个数大于等于Map的容量threshold（threshold=散列表容量（数组大小）*负载因子）。2、key值所对应的散列表位置不为null。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; table[bucketIndex])) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         resize(2 * table.length);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键的扩容机制，扩容后的大小是之前的两倍&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         hash = (&lt;span&gt;null&lt;/span&gt; != key) ? hash(key) : 0;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算key的hash值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         bucketIndex = indexFor(hash, table.length);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新计算key所在散列表的下标&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Entry节点并插入，每次插入都会插在链表的第一个位置。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    createEntry(hash, key, value, bucketIndex);    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来看看HashMap是如何扩容的。JDK7HashMap扩容的大小是前一次散列表大小的两倍2 * table.length&lt;/p&gt;
&lt;p&gt;void resize(int newCapacity)&lt;/p&gt;
&lt;p&gt;　　在这个方法中最核心的是transfer(Entry[], boolean)方法，第一个参数表示扩容后新的散列表引用，第二参数表示是否初始化hash种子。&lt;/p&gt;
&lt;p&gt;　　结合源码我们用图例来说明HashMap在JDK7中是如何进行扩容的。&lt;/p&gt;
&lt;p&gt;　　假设现在有如下HashMap，初始容量initialCapacity=4，负载因子loadFactor=0.5。初始化时阈值threshold=4*0.5=2。也就是说在插入第三个元素时，HashMap中的size=3大于阈值threshold=2，此时就会进行扩容。我们从来两种情况来对扩容机制进行分析，一种是两个key-value未产生散列冲突，第二种是两个key-value产生了散列冲突。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;扩容时，当前HashMap&lt;/strong&gt;&lt;strong&gt;的key-value&lt;/strong&gt;&lt;strong&gt;未产生散列冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164741963-1506245727.png&quot; alt=&quot;&quot; width=&quot;93&quot; height=&quot;155&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;此时当插入第三个key-value时，HashMap会进行扩容，容量大小为之前的两倍，并且在扩容时会对之前的元素进行转移，未产生冲突的HashMap转移较为简单，直接遍历散列表对key重新计算出新散列表的数组下标即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164841516-1916010981.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;　　2. &lt;/strong&gt;&lt;strong&gt;扩容时，当前HashMap&lt;/strong&gt;&lt;strong&gt;的key-value&lt;/strong&gt;&lt;strong&gt;产生散列冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164911829-1292587354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在对散列冲突了的元素进行扩容转移时，需要遍历当前位置的链表，链表的转移若新散列表还是冲突则采用头插法的方式进行插入，此处需要了解链表的头插法。同样通过for (Entry&amp;lt;K,V&amp;gt; e : table)遍历散列表中的元素，判断当前元素e是否为null。由例可知，当遍历到第2个位置的时候元素e不为null。此时创建临时变量next=e.next。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164931235-707507507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　重新根据新的散列表计算e的新位置i，后面则开始通过头插法把元素插入进入新的散列表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313164948743-1963087153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　通过头插法将A插入进了新散列表的i位置，此时指针通过e=next继续移动，待插入元素变成了B，如下所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165006669-268407373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　此时会对B元素的key值进行hash运算，计算出它在新散列表中的位置，无论在哪个位置，均是头插法，假设还是在位置A上产生了冲突，头插法后则变成了如下所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165020288-1089878541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　可知，在扩容过程中，链表的转移是关键，链表的转移通过头插法进行插入，所以正是因为头插法的原因，新散列表冲突的元素位置和旧散列表冲突的元素位置相反。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　关于HashMap的扩容机制还有一个需要注意的地方，在并发条件下，HashMap不仅仅是会造成数据错误，致命的是可能会造成CPU100%被占用，原因就是并发条件下，由于HashMap的扩容机制可能会导致&lt;strong&gt;死循环&lt;/strong&gt;。下面将结合图例说明，为什么HashMap在并发环境下会造成死循环。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　假设在并发环境下，有两个线程现在都在对同一个HashMap进行扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165041650-565489199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　此时线程T1对扩容前的HashMap元素已经完成了转移，但由于Java内存模型的缘故线程T2此时看到的还是它自己线程中HashMap之前的变量副本。此时T2对数据进行转移，如下图所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165101297-1166619103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　进一步地，在T2中的新散列表中newTable[i]指向了元素A，此时待插入节点变成了B，如下图所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165118985-1540878734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　原本在正常情况下，next会指向null，但由于T1已经对A-&amp;gt;B链表进行了转置B-&amp;gt;A，即next又指回了A，并且B会插入到T2的newTable[i]中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165132974-1110044729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　由于此时next不为空，下一步又会将next赋值给e，即e = next，反反复复A、B造成闭环形成死循环。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165146875-1793743642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　所以，千万不要使用在并发环境下使用HashMap，一旦出现死循环CPU100%，这个问题不容易复现及排查。并发环境一定需要使用ConcurrentHashMap线程安全类。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　探讨了JDK7中的put方法，接下来看看JDK8新增了红黑树HashMap是如何进行put，如何进行扩容，以及如何将链表转换为红黑树的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK8&lt;/strong&gt;&lt;strong&gt;——HashMap#put&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8, HashMap#put&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在JDK8中，put方法直接调用了putVal方法，该方法有5个参数：key哈希值，key，value，onlyIfAbsent（如果为ture则Map中已经存在该值的时候将不会把value值替换），evict在HashMap中无意义&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　所以关键的方法还是putVal。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JDK8中putVal方法和JDK7中put方法中的插入步骤大致相同，同样需要判断是否是第一次插入，插入的位置是否产生冲突，不同的是会判断插入的节点是“链表节点”还是“红黑色”节点。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 是否是第一次插入，是第一次插入则复用resize算法，对散列表进行初始化&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 　　&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 　　　　n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 通过i = (n - 1) &amp;amp; hash计算key值所在散列表的下标，判断tab[i]是否已经有元素存在，即有无冲突，没有则直接插入即可，注意如果插入的key=null，此处和JDK7的策略略有不同，JDK7是遍历散列表只要为null就直接插入，而JDK8则是始终会插入第一个位置，即使有元素也会形成链表&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 　　&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. tab[i]已经有了元素即产生了冲突，如果是JDK7则直接使用头插法即可，但在JDK8中HashMap增加了红黑树数据结构，此时有可能已经是红黑树结构，或者处在链表转红黑树的临界点，所以此时需要有几个判断条件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 　　&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.1 这是一个特殊判断，如果tab[i]的元素hash和key都和带插入的元素相等，则直接覆盖value值即可&lt;/span&gt;
&lt;span&gt;12　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;13　　　　　　&lt;/span&gt;e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.2 待插入节点是一个红黑树节点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 　　　　&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;16　　　　　　&lt;/span&gt;e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;17　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.3 插入后可能继续是一个链表，也有可能转换为红黑树。在元素个数超过8个时则会将链表转换为红黑树，所以第一个则需要一个计数器来遍历计算此时tab[i]上的元素个数&lt;/span&gt;
&lt;span&gt;18　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19　　　　　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;20　　　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21　　　　　　　　　　&lt;/span&gt;p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历到当前元素的next指向null，则通过尾插法插入，这也是和JDK7采用头插法略微不同的地方&lt;/span&gt;
&lt;span&gt;22　　　　　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tab[i]的数量超过了临界值8，此时将会进行链表转红黑树的操作，并跳出循环&lt;/span&gt;
&lt;span&gt;23　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 　　　　　　　　   &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.equals(k))))        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种情况同3.1，出现了和插入key相同的元素，直接跳出循环，覆盖value值即可，无需插入操作&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;               　　&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;              p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;29　　　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种情况表示带插入元素的key在Map中已经存在，此时没有插入操作，直接覆盖value值即可&lt;/span&gt;
&lt;span&gt;32　　　　　　&lt;/span&gt;V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;33　　　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34　　　　　　　　&lt;/span&gt;e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;35　　　　　　&lt;/span&gt;&lt;span&gt;afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;36　　　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;37　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39　　&lt;/span&gt;++modCount;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改计数，在使用Iterator迭代器时会和这个变量比较，如果不相等，则会抛出ConcurrentModificationException异常&lt;/span&gt;
&lt;span&gt;40　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++size &amp;gt; threshold)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否需要扩容&lt;/span&gt;
&lt;span&gt;41　　　　&lt;/span&gt;&lt;span&gt;resize();
&lt;/span&gt;&lt;span&gt;42　　&lt;/span&gt;afterNodeInsertion(evict);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并无意义&lt;/span&gt;
&lt;span&gt;43　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;　　从上面的JDK7和JDK8的put插入方法源码分析来看，JDK8确实复杂了不少，在没有耐心的情况下，这个“干货”确实显得比较干，我试着用下列图解的方式回顾JDK7和JDK8的插入过程，在对比过后接着对JDK8中的红黑树插入、链表转红黑树以及扩容作分析。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313165818146-448391420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/630246/201803/630246-20180313170007447-1369876724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　综上JDK7和JDK8的put插入方法大体上相同，其核心均是计算key的hash并通过hash计算散列表的下标，再判断是否产生冲突。只是在实现细节上略有区别，例如JDK7会对key=null做特殊处理，而JDK8则始终会放置在第0个位置；而JDK7在产生冲突时会使用头插法进行插入，而JDK8在链表结构时会采用尾插法进行插入；当然最大的不同还是JDK8对节点的判断分为了：链表节点、红黑树节点、链表转换红黑树临界节点。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　对于红黑树的插入暂时不做分析，接下来是对JDK8扩容方法的分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JDK8，HashMap#resize扩容，HashMap扩容的大小仍然是前一次散列表大小的两倍 &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
&lt;/span&gt;&lt;span&gt; 3　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 由于JDK8初始化散列表时复用了resize方法，所以前面是对oldTab的判断，是否为0（表示是初始化），是否已经大于等于了最大容量。判断结束后newTab会扩大为oldTab的两倍，同样newThr（阈值）也是以前的两倍。源码略。
&lt;/span&gt;&lt;span&gt; 4　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 确定好newTab的大小后接下来就是初始化newTab散列表数组&lt;/span&gt;
&lt;span&gt; 5　　&lt;/span&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt; 6　　&lt;/span&gt;table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt; 7　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 如果是初始化（即oldTab==null），则直接返回新的散列表数组，不是则进行转移
&lt;/span&gt;&lt;span&gt; 8　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4. 首先还是遍历散列表&lt;/span&gt;
&lt;span&gt; 9　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;10　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5. e = oldCap[i] != null，则继续判断
&lt;/span&gt;&lt;span&gt;11　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.1 当前位置i，是否有冲突，没有则直接转移&lt;/span&gt;
&lt;span&gt;12　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13　　　　　　&lt;/span&gt;newTab[e.hash &amp;amp; (newCap - 1)] = e;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里并没有对要转移的元素重新计算hash，对于JDK7来会通过hash(e.getKey()) ^ newCap重新计算e在newTab中的位置，此处则是e.hash &amp;amp; (newCap - 1)，减少了重新计算hash的过程。扩容后的位置要么在原来的位置上，要么在原索引 + oldCap位置 
&lt;/span&gt;&lt;span&gt;14　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.2 判断是否是红黑树节点&lt;/span&gt;
&lt;span&gt;15　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;16　　　　　　&lt;/span&gt;((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;17　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.3 判断是否是链表节点&lt;/span&gt;
&lt;span&gt;18　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 　　　　&lt;span&gt;…
&lt;/span&gt;&lt;span&gt;20　　　　&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;　　JDK8的扩容机制相比较于JDK7除了增加对节点是否为红黑树的判断，其余大致相同，只是做了一些微小的优化。特别在于在JDK8中并不会重新计算key的hash值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;public V remove(Object key)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如果已经非常清楚put过程，我相信对于HashMap中的其他方法也基本能知道套路。remove删除也不例外，计算hash(key)以及所在散列表的位置i，判断i是否有元素，元素是否是红黑树还是链表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这个方法容易陷入的陷阱是key值是一个自定义的pojo类，且并没有重写equals和hashCode方法，此时用pojo作为key值进行删除，很有可能出现“删不掉”的情况。这需要重写equals和hashCode才能使得两个pojo对象“相等”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　剩下的方法思路大同小异，基本均是计算hash、计算散列表下标i、遍历、判断节点类型等等。本文在弄清put和resize方法后，一切方法基本上都能举一反三。所以在看完本文后，你应该试着问自己以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HashMap的底层数据结构是什么？&lt;/li&gt;
&lt;li&gt;HashMap的put过程？&lt;/li&gt;
&lt;li&gt;HashMap的扩容机制？&lt;/li&gt;
&lt;li&gt;并发环境下HashMap会带来什么致命问题？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Mar 2018 13:32:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8558983.html</dc:identifier>
</item>
<item>
<title>使用asyncio实现redis客户端 - walkabc</title>
<link>http://www.cnblogs.com/hitfire/p/8562560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hitfire/p/8562560.html</guid>
<description>&lt;p&gt;redis协议格式请参考，http://doc.redisfans.com/topic/protocol.html&lt;/p&gt;
&lt;p&gt;这里简单介绍下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
*&amp;lt;参数数量&amp;gt;&lt;span&gt; \r\n
$&lt;/span&gt;&amp;lt;参数 &lt;span&gt;1&lt;/span&gt; 的字节数量&amp;gt;&lt;span&gt; \r\n
&lt;/span&gt;&amp;lt;参数 &lt;span&gt;1&lt;/span&gt; 的数据&amp;gt;&lt;span&gt; \r\n
$&lt;/span&gt;&amp;lt;参数 N 的字节数量&amp;gt;&lt;span&gt; \r\n
&lt;/span&gt;&amp;lt;参数 N 的数据&amp;gt; \r\n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送给redis服务器时的数据要按照redis要求的协议格式发送，只有这样redis服务器才能成功解析。&lt;/p&gt;
&lt;p&gt;首先根据协议格式写一个封包方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; format_command(self, commands):
        length &lt;/span&gt;=&lt;span&gt; len(commands)
        command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(length)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; commands:
            bytes &lt;/span&gt;= v.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            bytes_length &lt;/span&gt;=&lt;span&gt; len(bytes)
            sub_command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(bytes_length) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(v)
            command &lt;/span&gt;+=&lt;span&gt; sub_command
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; command
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到format_command函数中的“*”和“$”符号了么。其实就是根据commands列表中的数据然后按照redis协议格式封装起来的。&lt;/p&gt;
&lt;p&gt;弄懂了如何安装redis协议封装数据之后，就可以把数据发送到redis服务器了。&lt;/p&gt;
&lt;p&gt;asyncio的官方demo可参考：&lt;/p&gt;
&lt;p&gt;https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams&lt;/p&gt;
&lt;p&gt;下面就是完整的代码，无其他依赖，顺利执行之后，可以通过redis-cli命令行查看是否设置成功。&lt;/p&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncRedis:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, port, loop):
        self.host &lt;/span&gt;=&lt;span&gt; host
        self.port &lt;/span&gt;=&lt;span&gt; port
        self.loop &lt;/span&gt;=&lt;span&gt; loop
        self.separator &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.encode()

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
        reader, writer &lt;/span&gt;= await asyncio.open_connection(self.host, self.port, loop=&lt;span&gt;self.loop)
        self.reader &lt;/span&gt;=&lt;span&gt; reader
        self.writer &lt;/span&gt;=&lt;span&gt; writer

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; format_command(self, commands):
        length &lt;/span&gt;=&lt;span&gt; len(commands)
        command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(length)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; commands:
            bytes &lt;/span&gt;= v.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            bytes_length &lt;/span&gt;=&lt;span&gt; len(bytes)
            sub_command &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(bytes_length) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(v)
            command &lt;/span&gt;+=&lt;span&gt; sub_command
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(command)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; command

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; execute_command(self, command):
        self.writer.write(command.encode(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set(self, key, value):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key, value])
        self.execute_command(command)
        ret, error &lt;/span&gt;=&lt;span&gt; await self.wait_ret()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hset(self, hash_key, key, value):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HSET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hash_key, key, value])
        self.execute_command(command)

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, key):
        command &lt;/span&gt;= self.format_command([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key])
        self.execute_command(command)
        ret &lt;/span&gt;=&lt;span&gt; await self.wait_ret()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wait_ret(self):
        ret &lt;/span&gt;=&lt;span&gt; await self.reader.readuntil(self.separator)
        ret &lt;/span&gt;=&lt;span&gt; ret.decode()
        mark &lt;/span&gt;= ret[0:1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            ret &lt;/span&gt;=&lt;span&gt; await self.reader.read(int(ret))
            ret &lt;/span&gt;=&lt;span&gt; ret.decode()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, True
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, True
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; mark == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            pos &lt;/span&gt;= ret.index(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            ret &lt;/span&gt;= ret[1&lt;span&gt;:pos]
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret, False

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; close(self):
        self.writer.close()

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; asyncio

async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; NewRedis(loop):
    redis &lt;/span&gt;= AsyncRedis(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 6379&lt;span&gt;, loop)
    await redis.connect()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; await redis.get(&quot;name&quot;)&lt;/span&gt;
    await redis.set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;云想衣裳花想容，春风拂槛露华浓。\r\n 若非群玉山头见，会向瑶台月下逢。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
loop &lt;/span&gt;=&lt;span&gt; asyncio.get_event_loop()
loop.run_until_complete(NewRedis(loop))
loop.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 13 Mar 2018 13:32:00 +0000</pubDate>
<dc:creator>walkabc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hitfire/p/8562560.html</dc:identifier>
</item>
<item>
<title>------ Tor（洋葱路由器）匿名网络源码分析——主程序入口点（一）------ - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8562454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8562454.html</guid>
<description>
&lt;p&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《概览》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tor 的源码包可以从官网下载，可能需要预先利用其它=*翻^=*墙*软件才能访问该站点。分析 tor 源码有助于我们理解当代最强大之一的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;互联网匿名、隐身、审查规避软件&lt;/span&gt;的运作原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了从整体上把握住程序的逻辑与功能，本系列会将源码重要部分通过函数调用流程图总结，以便站在设计思想的高度来考察 tor。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;《约定》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当引用函数/结构体/宏/定义/声明时，我会在圆括号内给出它所在源文件的完整路径，必要时还会给出代码行号，例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;tor_main()（\tor-0.3.1.8\src\or\main.c）——3682&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间的路径省略掉解压至磁盘上的驱动器号，假定存放于&lt;span&gt;根目录下 &lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源码的版本为&lt;/span&gt; &lt;span&gt;&lt;span&gt;0.3.1.8&lt;/span&gt;&lt;/span&gt;&lt;span&gt;（引用代码片段的截图中也会在右下角给出完整路径，以及代码行号）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;《要求》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tor 以 C 编程语言开发，故需要各位具备关于 C 的基本知识和开发经验，才能有较佳的源码分析体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，tor 为了实现跨 OS 平台兼容性，源码中经常出现 OS 相关的“条件编译”代码块，因此也要求各位对主流操作系统的&lt;/span&gt;&lt;span&gt;&lt;span&gt;用户态编程接口&lt;/span&gt;有一定程度的了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;《反馈》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于本人知识水平有限，加上工作的关系，本系列内容可能存在谬误之处，且会不定期更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎反馈任何勘误，或者加入行列提高分析进展，&lt;span&gt;可在评论处提交自己感兴趣分析的模块和自己的分析博文 URL&lt;/span&gt;！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;tor 主程序的入口点从 tor_main()（\tor-0.3.1.8\src\or\main.c）开始，实际上它是被 &lt;/span&gt;&lt;span&gt;main()（\tor-0.3.1.8\src\or\tor_main.c）所调用的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;把 main() 从 main.c 中分离的原因在于——其它实现单元测试的源文件（test_*.c）中的 main() 函数，就可以链接 main.c ，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为后者中不存在同名的 main() 函数，不会产生名称冲突。&lt;/span&gt;&lt;span&gt;三者的关系请参考下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313210217909-1666167753.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先来看 main()，它把调用 tor_main() 返回的整型值保存到局部变量 r 中，然后根据 r 的值来作出相应处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果 0 &amp;lt;= r &amp;lt;= 255 ，则返回 r 的具体值到 main() 的调用者（通常会是负责初始化 Tor 进程运行环境的 CRT 启动例程），&lt;/span&gt;&lt;span&gt;否则返回 1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进一步而言，tor_main() 的开头部分就定义了一个整型变量 result，并初始化为 0， tor_main() 的内部逻辑会根据不同场景把&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;result 设定为相应的值然后返回给 main()。&lt;/span&gt;&lt;span&gt;相关的代码片段如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313210411801-1986307514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313210424352-1841164484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上两张图可知，main() 把自己收到的两个参数：argc（执行 tor 命令时的参数数量）和 argv（包含具体参数的列表/数组）原封不动的传递给&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tor_main()，后者会在特定情况下用到这两个参数，比如调用 tor_init() 时传递过去，而 tor_init() 的主要任务之一，就是&lt;/span&gt;&lt;span&gt;通过解析 argv 中携带的命令行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数信息，来按照用户的意图初始化 tor 系统。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于 Tor 命令行参数字串与个数的传递部分流程，请参考下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313210549500-1355954429.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;tor_main() 初始化自身的返回值后，我们遇到了第一个&lt;span&gt;代码条件编译块&lt;/span&gt;，它是与 Windows 平台相关的。块中的内容仅在满足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特定条件时才被构建为可执行代码。相关的代码片段如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313210630177-1582174912.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于 32 位 windows 平台，且没有定义“当堆数据损坏时，终止进程的功能（HeapEnableTerminationOnCorruption）”，则按照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSDN 文档的描述，将其枚举常量的值定义为 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（HeapEnableTerminationOnCorruption 的作用是，假设 OS 的堆管理器检测到由进程使用的任意堆中有错误，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;堆管理器会调用 WER 服务[Windows 错误报告]，然后终止进程，该功能打开后，无法由进程关闭）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;若已定义该功能，则调用 HeapSetInformation() ，为它的第二个参数传入 HeapEnableTerminationOnCorruption，来打开该功能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HeapSetInformation() 的第一个参数是到要设置的堆句柄，通常由 HeapCreate() 或 GetProcessHeap() 返回;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于在此之前，tor_main() 并没有创建堆，所以堆句柄为 NULL；从 Windows Vista 开始，默认就启用了“低碎片堆”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（low-fragmenation heap，LFH），所以应用程序会使用或创建 LFH；关于 LFH，请参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366750(v=vs.85).aspx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，即便 HeapSetInformation() 调用失败， OS 也会让应用程序继续运行，所以应该对 HeapSetInformation() 的返回值进行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;检测：&lt;span&gt;如果无法打开该功能，则 Tor 进程应该返回失败并退出&lt;/span&gt;——这正是源码中所遗漏的逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，在 Windows 平台，更健壮的代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;BOOL bResult;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  bResult =&lt;span&gt; HeapSetInformation(NULL,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                                 HeapEnableTerminationOnCorruption,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                                 NULL,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                                  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bResult !=&lt;span&gt; FALSE) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         _tprintf(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Heap terminate-on-corruption has been enabled.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         _tprintf(TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failed to enable heap terminate-on-corruption with LastError %d.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                 GetLastError());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;上图关键之处在于调用 SetProcessDEPPolicy()，永久打开 Tor 主进程的数据执行保护（DEP）功能，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为 Tor 是一个网络应用程序，需要通过网络频繁收发数据，程序中的任何编码缺陷，都可能导致远程代码执行，所以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加此一调用可以缓解缓冲区溢出/堆栈溢出攻击造成的危害。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SetProcessDEPPolicy() 是位于 Kernel32.dll 中的 API 函数（参见相关 MSDN 文档中的“系统要求”），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 Kernel32.dll 采用“&lt;span&gt;加载时&lt;/span&gt;动态连接”到 Tor 进程的内存映射中，所以首先要以 GetModuleHandleA() 取得该模块的句柄，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（采用“&lt;span&gt;运行时&lt;/span&gt;动态链接”的应用程序会调用 LoadLibrary/Ex()）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在成功获取的前提下，以 GetProcAddress() 取得 SetProcessDEPPolicy() 函数的地址，将其赋给以“typedef”类型定义和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明的函数指针“setdeppolicy”，如能解析到该函数的地址，就可以直接通过调用 setdeppolicy 来“尝试”打开 DEP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为啥我要强调“尝试”呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在较早版本的 Windows 中，通过 GetProcAddress() 来获取 SetProcessDEPPolicy() 的地址会解析失败，所以需要对返回的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指针进行检查，如果为空，就不该，也无法对 Tor 主进程启动数据执行保护（DEP）；另外，假使系统能够解析到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SetProcessDEPPolicy() 的地址，而对它的调用失败却不会导致危险，所以无需错误处理，只管调用即可——就算无法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启 DEP，Tor 也要继续运行下去，这就完全依赖于安全的编码意识了。。。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而根据 MSDN 文档的描述，为 SetProcessDEPPolicy() 的 DWORD 型参数 dwFlags 传入 0x3　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表明 &lt;span&gt;PROCESS_DEP_ENABLE（0x00000001）&lt;/span&gt;与 &lt;span&gt;PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION（0x00000002）&lt;/span&gt;特性被同时打开，这与&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源码中的注解相符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，PROCESS_DEP_ENABLE（0x00000001）标志的设定，意味着&lt;span&gt;在整个 Tor 进程的生命周期内，都无法关闭 DEP（如果成功启用）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个条件编译块到此结束，其充分利用了 Windows 平台为应用程序提供的额外安全机制。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;经过平台特定的代码块后，为了让 Tor 进程在崩溃时转储栈信息，以便后续的调试分析？调用了 configure_backtrace_handler()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数（\tor-0.3.1.8\src\common\backtrace.c），来配置回溯处理程序。相关的代码片段如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313211057733-566729418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;configure_backtrace_handler() 接受一个指向字符常量的指针，这可以通过 get_version() 辅助例程获取到 Tor 应用程序的版本信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;configure_backtrace_handler() 首先调用宏 tor_free()（\tor-0.3.1.8\src\common\util.h——83），来释放由 backtrace.c 静态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分配的全局变量 bt_version，它是一个 NULL 指针，而 tor_free() 可以安全地释放 NULL 指针，而且把它引用的内存位置也设为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NULL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据是否获取到版本信息，它调用 tor_asprintf() 向控制台/shell 输出相应的程序启动信息，然后调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;install_bt_handler() （&lt;span&gt;在同一份源文件内&lt;/span&gt;），并将其返回值传递给 tor_main()。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果注册崩溃回调函数失败，install_bt_handler() 返回 -1；否则返回 0，最终通知 tor_main() 成功“挂钩”！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;阅读 backtrace.c 我们可以了解到：如果没有在编译时指定 USE_BACKTRACE 选项，则 install_bt_handler() 仅仅只是返回 0 到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用者——不会实际注册回溯处理程序。否则，install_bt_handler() 将针对包含崩溃在内的一些信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（SIGSEGV, SIGILL, SIGFPE, SIGBUS, SIGSYS, SIGIO），安装一致的回溯处理程序 crash_handler()，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后者调用 backtrace() ，最终成生栈回溯信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们要明确一点，当程序启动并正常运行时，只会调用 configure_backtrace_handler() 与 install_bt_handler()；当程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;崩溃或收到上述六种信号之一，crash_handler() 与 backtrace() 就会被调用（因此&lt;span&gt;后两者才是 CallBack&lt;/span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以从 crash_handler() 内部最后的 abort() 调用逻辑得证——只有在崩溃时才需要中止继续运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关的代码片段如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313211253857-1887953181.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313211312475-942713240.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313211344932-1660218125.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;上面的长篇大论用下面一张图清晰地总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201803/1318637-20180313211436383-1258386676.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;至此，我们解剖了 tor 程序入口点 tor_main() 中，到 configure_backtrace_handler() 为止的代码意图，但这仅仅只是开场白&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;而已，在后面的博文我将继续分析与 tor 业务逻辑相关的代码，这才是“干货”所在！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（未完待续。。。。。。）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Mar 2018 13:26:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8562454.html</dc:identifier>
</item>
<item>
<title>IDE-IntelliJ IDEA 主题、字体、编辑区主题、文件编码修改、乱码问题 - 赵小叔</title>
<link>http://www.cnblogs.com/mm15732621582/p/8561942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mm15732621582/p/8561942.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;same-origin&quot;/&gt;&lt;title&gt;IDE-IntelliJ IDEA 主题、字体、编辑区主题、文件编码修改、乱码问题 - 赵小叔 - 博客园&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=-hy83QNg62d4qYibixJzxMJkbf1P9fTBlqv7SK5zVL01&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/darkgreentrip/bundle-darkgreentrip.css?v=xPXJVC4GCITs1yYYgSeLkcicCxapqseaPVQLFGMO1wc1&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/blog/customcss/305167.css?v=vYbvNcQ9UMRg8MrPo2Utg42E3Sc%3d&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/darkgreentrip/bundle-darkgreentrip-mobile.css?v=6NcJHqsIyaE4w19VtgFvCFahrnr2rYCTRRTdxlMDhhQ1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;http://www.cnblogs.com/mm15732621582/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;http://www.cnblogs.com/mm15732621582/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;http://www.cnblogs.com/mm15732621582/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-a-theme-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-a-theme-setting-1.jpg&quot; alt=&quot;主题修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 所示为 IntelliJ IDEA 修改主题的地方，可以通过打开左上角的File -&amp;gt; Setting。在 Windows 系统上 IntelliJ IDEA 默认提供的主题有四套：&lt;code&gt;Darcula&lt;/code&gt;、&lt;code&gt;IntelliJ&lt;/code&gt;、&lt;code&gt;Windows&lt;/code&gt;、&lt;code&gt;Alloy. IDEA Theme&lt;/code&gt;。除了 &lt;code&gt;Darcula&lt;/code&gt; 是黑色主题，其他三套都是以白色为背景的。&lt;/li&gt;
&lt;li&gt;其他操作系统上不一定会也有四套主题的，主题的选择上大家根据自己喜好即可。改变主题需要重启 IntelliJ IDEA 方可看到效果。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2&gt;字体修改&lt;/h2&gt;
&lt;h3&gt;主题字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-1.jpg&quot; alt=&quot;主题字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图标注 1 所示，IntelliJ IDEA 主题字体的修改要先勾选 &lt;code&gt;Override default fonts by&lt;/code&gt; 。默认 IntelliJ IDEA 是不推荐修改的，但是由于字体是有分包含中文和不包含中文之分的，一般使用英文的国家是不需要额外担心乱码问题的，而我们需要。&lt;/li&gt;
&lt;li&gt;字体的审美上每个人不一样，但是如上一段说的，这里的字体修改是需要知道一个前提的，那就是你选择的那个字体必须含有中文，比如微软雅黑和宋体这类是包含中文的，而 &lt;code&gt;Courier New&lt;/code&gt; 和 &lt;code&gt;Monaco&lt;/code&gt; 这类只是单纯的英文字体。&lt;/li&gt;
&lt;li&gt;如果你选择的字体不包含中文，那可能会在很多位置上出现类似 &lt;code&gt;口口口口口&lt;/code&gt; 这样的乱码问题，比如文件名含有中文、字体是中文名字的都会变成 &lt;code&gt;口口口口口&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在修改 IntelliJ IDEA 的主题字体的时候，不建议把字体调成很大，因为很多人遇到这样一种情况：显示器分辨率低，主题字体又大，在 IntelliJ IDEA 的某些操作的工具菜单、右键菜单选项中部分选项超出了分辨率显示范围，没办法被选中。当然了，如果你一定要把字体改大，又不用大分辨率显示器，那可以通过 IntelliJ IDEA 的 &lt;code&gt;Menus and Toolbars&lt;/code&gt; 删除部分你认为用不到的菜单，但是一般不建议这样做。&lt;/li&gt;
&lt;li&gt;还需要特别注意的时候，如果你是开着 IntelliJ IDEA 的时候，新装了一个字体的话，那必须重启IntelliJ IDEA 之后才能在下拉列表找到新装的字体。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;代码编辑字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-2.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-2.jpg&quot; alt=&quot;代码编辑字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图标注 1 所示，默认 IntelliJ IDEA 是不能直接在默认的代码模板上修改字体的，需要先 &lt;code&gt;Save As&lt;/code&gt; 一份出来，然后才可以修改。这种设计在 IntelliJ IDEA 其他很多设置也是如此的，所以如果你还看到类似有 &lt;code&gt;Copy&lt;/code&gt;、&lt;code&gt;Save As&lt;/code&gt; 这类选项的按钮就要想到是此设计思想。&lt;/li&gt;
&lt;li&gt;如上图标注 2 所示，勾选的 &lt;code&gt;Show only monospaced fonts&lt;/code&gt; 表示筛选显示系统上的等宽字体。由于 Windows 系统上等宽字体并不多，勾选此选项出现的下拉字体可选择就很少。取消勾选之后，就可以显示系统上所有已安装的字体。&lt;/li&gt;
&lt;li&gt;如上图标注 3 所示，其中编码字体有第一字体（&lt;code&gt;Primary font&lt;/code&gt;） 和 第二字体（&lt;code&gt;Secondary font&lt;/code&gt;）之分。当有些字符在第一字体支持不了的时候，会去使用第二字体进行支持。&lt;/li&gt;
&lt;li&gt;我个人习惯上：英文字体使用 &lt;code&gt;Monaco&lt;/code&gt;，由于此字体不支持中文，所以我把这个设置为第一字体，第二字体使用 &lt;code&gt;Yahei Consolas Hybrid&lt;/code&gt; 进行支持，该字体含有中文。这两个字体都不是系统自带的，需要自行下载安装。&lt;/li&gt;
&lt;li&gt;如果你的第一字体不包含中文的话，第二字体包含中文，那在有些地方也还是会出现 &lt;code&gt;口口口口口&lt;/code&gt; 这类问题，比如 &lt;code&gt;Ctrl + Shift + N&lt;/code&gt; 进行查找文件的时候，如果你输入中文也会变成 &lt;code&gt;口口口口口&lt;/code&gt; ，我个人文件名为中文的不多，所以就容忍了这种情况。如果你不愿意容忍这种情况，那还是回到最开始的要求：第一字体包含中文。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;控制台输出字体修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-b-font-setting-3.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-3.jpg&quot; alt=&quot;控制台输出字体修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图为控制台输出内容字体修改，有很多 IntelliJ IDEA 新人在做输出的时候出现乱码原因就是因为没有在这里进行设置。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;控制台输出字体&lt;/em&gt; 修改的原理跟 &lt;em&gt;代码编辑字体修改&lt;/em&gt; 是一样的，所以这里不进行讲解。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2&gt;编辑区主题修改&lt;/h2&gt;
&lt;h3&gt;编辑区主题介绍&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-c-code-theme-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-c-code-theme-setting-1.jpg&quot; alt=&quot;编辑区主题介绍&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;编辑区主题，也就是代码书写区的主题修改。基本上大家在 &lt;code&gt;General&lt;/code&gt; 上都有对此进行小修小改，我下面也主要介绍下我个人在 &lt;code&gt;General&lt;/code&gt; 上常修改的一些地方，其他特性的颜色修改我一般默认，但是修改方法原理一样。&lt;/li&gt;
&lt;li&gt;如上图红圈下拉所示，展示的是我当前电脑可以选择的编辑区主题。&lt;/li&gt;
&lt;li&gt;对于编辑区的主题，也有人制作成模板在网络上提供下载。这里主要介绍两个站点：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3&gt;编辑区主题细节修改&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-c-code-theme-setting-2.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-c-code-theme-setting-2.jpg&quot; alt=&quot;编辑区主题细节修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 为可修改的通用细节内容&lt;/li&gt;
&lt;li&gt;上图标注 2 为可修改属性，其中并不是每个细节都可以修改所有属性的。比如细节：&lt;code&gt;Default text&lt;/code&gt; 是可以勾选 &lt;code&gt;Bold&lt;/code&gt;，而 &lt;code&gt;Caret row&lt;/code&gt; 则是无法勾选 &lt;code&gt;Bold&lt;/code&gt;，因为只有文本才有加粗的属性需求。&lt;/li&gt;
&lt;li&gt;上图标注 3 为修改后的预览区，预览区是实时动态展示的。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;General&lt;/code&gt; 区，我常修改的有：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Default text&lt;/code&gt;，指的是默认代码文本，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caret row&lt;/code&gt;，指的是光标所在行，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vertical indent guide&lt;/code&gt;，指的是垂直缩进线，我一般会修改其 &lt;code&gt;Foreground&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Identifier under caret&lt;/code&gt;，指的是光标所在位置的相同标识符呈现什么效果，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Text search result&lt;/code&gt;，指的是在查找模式下，匹配字符的样式，我一般会修改其 &lt;code&gt;Background&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;文件编码修改&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-d-encoding-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-d-encoding-setting-1.jpg&quot; alt=&quot;文件编码修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;上图标注 1 所示，IDE 的编码默认是 &lt;code&gt;UTF-8&lt;/code&gt;，&lt;code&gt;Project Encoding&lt;/code&gt; 虽然默认是 &lt;code&gt;GBK&lt;/code&gt;，但是一般我都建议修改为 &lt;code&gt;UTF-8&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;上图标注 2 所示，IntelliJ IDEA 可以对 &lt;code&gt;Properties&lt;/code&gt; 文件进行专门的编码设置，一般也建议改为 &lt;code&gt;UTF-8&lt;/code&gt;，其中有一个重点就是属性 &lt;code&gt;Transparent native-to-ascii conversion&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;上图标注 3 所示，对于 &lt;code&gt;Properties&lt;/code&gt; 文件，重要属性 &lt;code&gt;Transparent native-to-ascii conversion&lt;/code&gt; 主要用于转换 &lt;code&gt;ascii&lt;/code&gt;，一般都要勾选，不然 &lt;code&gt;Properties&lt;/code&gt; 文件中的注释显示的都不会是中文。&lt;/li&gt;
&lt;li&gt;上图标注 4 所示，IntelliJ IDEA 除了支持对整个 Project 设置编码之外，还支持对目录、文件进行编码设置。如果你要对目录进行编码设置的话，可能会出现需要 &lt;code&gt;Convert&lt;/code&gt; 编码的弹出操作选择，强烈建议 在转换之前做好文件备份，不然可能出现转换过程变成乱码，无法还原。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-d-encoding-setting-2.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-d-encoding-setting-2.gif&quot; alt=&quot;文件编码修改&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如上图演示，对单独文件的编码修改还可以点击右下角的编码设置区。如果代码内容中包含中文，则会弹出演示中的操作选择。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Reload&lt;/code&gt; 表示使用新编码重新加载，新编码不会保存到文件中，重新打开此文件，旧编码是什么依旧还是什么。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Convert&lt;/code&gt; 表示使用新编码进行转换，新编码会保存到文件中，重新打开此文件，新编码是什么则是什么。&lt;/li&gt;
&lt;li&gt;含有中文的代码文件，&lt;code&gt;Convert&lt;/code&gt; 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;由于编码问题引起的编译错误&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;编译报错：&lt;code&gt;找不到符号&lt;/code&gt;、&lt;code&gt;未结束的字符串文字&lt;/code&gt; 等的解决办法：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;由于 UTF-8 编码文件有分 &lt;code&gt;有BOM&lt;/code&gt; 和 &lt;code&gt;无BOM&lt;/code&gt; 之分，默认情况下 IntelliJ IDEA 使用的编译器是 &lt;code&gt;javac&lt;/code&gt;，而此编译只能编译 &lt;code&gt;无BOM&lt;/code&gt; 的文件，有很多 Eclipse 用户在使用 IntelliJ IDEA 开发 Eclipse 项目的时候常常会遇到此问题。主要是因为 Eclipse 的编译器是 &lt;code&gt;Eclipse&lt;/code&gt;，此编译器支持 &lt;code&gt;有BOM&lt;/code&gt; 的文件编译。故，解决办法是对于此文件进行 BOM 去除。&lt;/li&gt;
&lt;li&gt;批量去除 BOM，你可以 Google：&lt;code&gt;批量去除 BOM&lt;/code&gt;、&lt;code&gt;批量转换无 BOM&lt;/code&gt; 等关键字，网络上已有提供各种方案。&lt;/li&gt;
&lt;li&gt;除了通过去除 BOM 还有设置 IntelliJ IDEA 的编译器为 &lt;code&gt;Eclipse&lt;/code&gt;，但是一般不建议这样做。&lt;/li&gt;
&lt;li&gt;如果上述问题都无法解决，而且你也确认 IntelliJ IDEA 各个配置编码的地方都是 &lt;code&gt;UTF-8&lt;/code&gt;，报错文件编码也是是&lt;code&gt;UTF-8 无 BOM&lt;/code&gt; 的话，那还有一种可能也会出现这种情况：项目配置文件有问题。项目编码的配置文件在：&lt;code&gt;/项目目录/.idea/encodings.xml&lt;/code&gt;。如果你会修改此文件可以进行修改，如果不会，那就删除掉 &lt;code&gt;.idea&lt;/code&gt; 整个目录，重启 IntelliJ IDEA 重新配置这个项目即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Tomcat 控制台输出乱码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/images/x-e-encoding-setting-1.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-e-encoding-setting-1.jpg&quot; alt=&quot;Tomcat 控制台输出乱码&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你的 Tomcat 控制台输出乱码，并且你已经保证了本文上面的控制台字体设置你设置的字体包含中文，那你还可以尝试下在 Tomcat 的 VM 参数上加上：&lt;code&gt;-Dfile.encoding=UTF-8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;更多资料：https://github.com/judasn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-03-13 20:54&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/mm15732621582/&quot;&gt;赵小叔&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=8561942&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/mm15732621582/p/8561942.html#&quot; onclick=&quot;AddToWz(8561942);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Tue, 13 Mar 2018 12:54:00 +0000</pubDate>
<dc:creator>赵小叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mm15732621582/p/8561942.html</dc:identifier>
</item>
</channel>
</rss>