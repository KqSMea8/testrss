<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式(五)_工厂方法模式 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9236539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9236539.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天主要讲解的是工厂方法模式。内容参考自java_my_life 博主的博客。但是拒绝粘贴复制，全部手打&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂方法模式是类的创建模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作，推迟到子类中。&lt;/p&gt;
&lt;h4 id=&quot;案例说明&quot;&gt;案例说明&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大家很多时候都做过导出功能，比如一个系统，需要导出的格式包括html、pdf等。但是财务系统导出的格式和其他普通的格式又不一样，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时如果用我们上篇学到的简单工厂模式，势必会让工厂类很繁琐，各种if判断。日后增加导出的格式，又会对工厂类进行增加逻辑编写。 此时我们采用 工厂方法模式进行实现。核心的工厂类不再负责所有对象的创建，它只是声明看一个工厂接口，具体的对象创建交给了子类。&lt;/p&gt;
&lt;p&gt;下面针对这个程序，我画的uml图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180627225739.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，一共有4个角色&lt;/p&gt;
&lt;p&gt;1.抽象导出角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ExportFile {

    public boolean export(String data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.具体导出角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ExportFinancialHtmlFile implements ExportFile {
    @Override
    public boolean export(String data) {

        System.out.println(&quot;导出财务版HTML文件&quot;);
        return true;
    }
}

public class ExportFinancialPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出财务版PDF文件&quot;);
        return true;
    }
}

public class ExportStandardHtmlFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出标准版HTML文件&quot;);
        return true;
    }
}

public class ExportStandardPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出财务版PDF文件&quot;);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.抽象工厂角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ExportFactory {

    public ExportFile factory(String type);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;具体工厂角色&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class ExportHtmlFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if(&quot;standard&quot;.equals(type)){

            return new ExportStandardHtmlFile();
        }else if(&quot;financial&quot;.equals(type)){

            return new ExportFinancialHtmlFile();
        }else{
            throw new RuntimeException(&quot;没有找到对象&quot;);
        }
    }
}

public class ExportPdfFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if(&quot;standard&quot;.equals(type)){

            return new ExportStandardPdfFile();
        }else if(&quot;financial&quot;.equals(type)){

            return new ExportFinancialPdfFile();
        }else{
            throw new RuntimeException(&quot;没有找到对象&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        String data = &quot;&quot;;

        ExportFactory exportFactory = new ExportHtmlFactory();

        ExportFile exportFile = exportFactory.factory(&quot;financial&quot;);

        exportFile.export(data);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;导出财务版HTML文件&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;工厂方法模式和简单工厂模式明显的不同在结构上，工厂方法的核心是抽象工厂类，简单工厂模式的核心是一个具体的类&lt;/li&gt;
&lt;li&gt;如果系统新增一个导出类型，此时只需要增加一个导出类和对应的工厂类，客户端不需要改动，更符合开闭原则。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意一点，设计模式是一种设计思想，并不是一成不变的 ，不要为了套设计思想让代码变得复杂，反而是一种画蛇添足的做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有设计模式的代码已经放到&lt;a href=&quot;https://github.com/runzhenghengbin/DesignPattern.git&quot;&gt;github&lt;/a&gt;上。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 15:20:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9236539.html</dc:identifier>
</item>
<item>
<title>【Java】MyBatis与Spring框架整合（二） - 小铁Winner</title>
<link>http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</guid>
<description>&lt;p&gt;本文讲解 Spring 注入映射器及事务功能的实现。&lt;/p&gt;
&lt;h2&gt;注入映射器实现&lt;/h2&gt;
&lt;p&gt;MyBatis 可以使用 SqlSession 的 getMapper ( Class&amp;lt;T&amp;gt; type ) 方法，根据指定的映射器和映射文件直接生成实现类。这样不必自行编写映射器的实现类，就可以调用映射器的方法进行功能实现。&lt;/p&gt;
&lt;p&gt;SqlSessionTemplate 也有对应的 getMapper（）方法，利用 MyBatis-Spring 提供的组件，可以不必每次调用 getMapper（）方法，而是通过配置的方式直接为业务对象注入映射器实现。对于不包含其他非 MyBatis 的工作的数据访问操作，这是首选的做法。&lt;/p&gt;
&lt;h3&gt;使用 MapperScannerConfigurer 注入映射器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SQL 映射文件中须遵循以下命名原则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）映射的命名空间和映射器接口的名称相同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）映射元素的 id 和映射器接口的方法相同。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，有关 DAO 接口的实现类可以删除了。&lt;/p&gt;
&lt;p&gt;配置注入映射器的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置 DAO &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basePackage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;cn.xxxx.mapper&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;basePackage 属性指定了扫描的基准包，MapperScannerConfigurer 将递归扫描基准包下所有接口。如果它们在 SQL 映射文件中定义过，则将它们动态注册为 MapperFactoryBean 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）basePackage 属性中可以包含多个包名。多个包名之间使用逗号或分号隔开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）MapperScannerConfigurer 创建的所有映射器实现都会被自动注入 SqlSessionFactory 实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）若环境中配置了多个 SqlSessionFactory 实例，自动装载将无法进行。此时应显式指定所依赖的 SqlSessionFactory 实例。下面是示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 &amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactoryBeanName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactory&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basePackage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;cn.bdqn.mapper&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;映射器被注册到 Spring 的容器时，Spring 会根据其接口名称为其命名，默认规则是首字母小写的非完全限定类名。如 UserMapper 类型组件会被默认命名为 userMapper。&lt;/p&gt;
&lt;p&gt;在业务逻辑实现类中使用 @Resource 或 @AutoWried 注解实现对业务组件的依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring 配置文件中需要引入 context 命名空间，并添加一行配置代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置扫描注解定义的业务 Bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;cn.xxxx.service&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;声明式事务&lt;/h2&gt;
&lt;p&gt;首先了解一下事务相关的理论知识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性（Atomicity）：&lt;/strong&gt;事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency）：&lt;/strong&gt;事务在完成时，必须是所有的数据都保持一致状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性（Isolation）：&lt;/strong&gt;并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性（Durability）：&lt;/strong&gt;一旦事务完成，数据库的改变必须是持久化的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;事务并发所可能存在的问题： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;脏读：&lt;/strong&gt;一个事务读到另一个事务未提交的更新数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;不可重复读：&lt;/strong&gt;一个事务两次读同一行数据，可是这两次读到的数据不一样。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;幻读：&lt;/strong&gt;一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;丢失更新：&lt;/strong&gt;撤消一个事务时，把其它事务已提交的更新的数据覆盖了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;JDBC定制了五种事务隔离级别处理事务并发：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRANSACTION_NONE JDBC ：驱动不支持事务&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_READ_UNCOMMITTED： 允许脏读、不可重复读和幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_READ_COMMITTED： 禁止脏读，但允许不可重复读和幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_REPEATABLE_READ： 禁止脏读和不可重复读，单运行幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_SERIALIZABLE： 禁止脏读、不可重复读和幻读。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隔离级别越高，意味着数据库事务并发执行性能越差，能处理的操作就越少。&lt;/p&gt;
&lt;p&gt;JDBC规范虽然定义了事务的以上支持行为，但是各个JDBC驱动，数据库厂商对事务的支持程度可能各不相同。&lt;br/&gt;出于性能的考虑我们一般设置 &lt;strong&gt;TRANSACTION_READ_COMMITTED&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过Spring，我们无需处理获得连接、关闭连接、事务提交和回滚等这些操作，使得我们把更多的精力放在处理业务上。&lt;/p&gt;
&lt;p&gt;事实上Spring并不直接管理事务，而是提供了多种事务管理器。它们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。&lt;/p&gt;
&lt;p&gt;本文主要讲解 Spring 提供的声明式事务处理机制，它基于 AOP 实现，无须编写任何事务管理代码，所有的工作全在配置文件中完成。&lt;/p&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需要用到 tx 和 aop 两个命名空间，所以首先要导入这两个命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt; xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     &lt;strong&gt;http://www.springframework.org/schema/tx
     http://www.springframework.org/schema/tx/spring-tx.xsd
     http://www.springframework.org/schema/aop 
     http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
&lt;/strong&gt;     http://www.springframework.org/schema/context
     http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置一个事务管理器组件，这里使用 Spring 提供的事务管理器类 DataSourceTransactionManager&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义事务管理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的 dataSource 是上文中配置的数据源组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过 &amp;lt;tx ：advice&amp;gt; 标签配置事务增强，设定事务的属性，为不同的业务方法指定具体的事务规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 为指定事务管理器设置事务属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:advice &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义属性，声明事务规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;add*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;del*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;update*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;NEVER&quot;&lt;/span&gt;&lt;span&gt; read-only&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;get*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;NEVER&quot;&lt;/span&gt;&lt;span&gt; read-only&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:advice&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;transaction-manager 属性引用一个事务管理器 Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;tx：attributes&amp;gt; 子标签用来定制事务属性。事务属性通过 &amp;lt;tx：method&amp;gt; 标签进行设置。&lt;/p&gt;
&lt;p&gt;&amp;lt;tx：method&amp;gt; 标签中 name 属性是必须的，用于指定匹配的方法，可以使用通配符（ * ）。其他属性均为可选，用于指定具体的事务规则。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Spring 事务的传播属性&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_REQUIRED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是Spring默认的事务的传播。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_SUPPORTS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_MANDATORY&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就抛出异常。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_REQUIRES_NEW&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 3&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　新建事务，如果当前存在事务，把当前事务挂起。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NOT_SUPPORTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NEVER&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 5&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NESTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;Spring 事务的隔离级别&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_DEFAULT&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_READ_UNCOMMITTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_READ_COMMITTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_REPEATABLE_READ&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_SERIALIZABLE&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;最后是定义切面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义切面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义切入点 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* cn.xxxx.service..*.*(..))&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;pointcutTransaction&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 将事务增强与切入点组合 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:advisor &lt;/span&gt;&lt;span&gt;advice-ref&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt; pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;pointcutTransaction&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用注解实现声明式事务处理&lt;/h2&gt;
&lt;p&gt; Spring 支持使用注解配置声明式事务，所使用的注解是 &lt;strong&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先需要在 Spring 配置文件中添加对注解配置的事务的支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:annotation-driven &lt;/span&gt;&lt;span&gt;transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在 Service 业务逻辑实现类中添加注解&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;@Transactional&lt;/strong&gt;&lt;/span&gt;
@Service(&lt;/span&gt;&quot;userSerivce&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IUserService{
    
    @Autowired
    @Qualifier(&lt;/span&gt;&quot;userMapper&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserMapper userMapper;

    @Override
    &lt;span&gt;&lt;strong&gt;@Transactional(propagation&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;=Propagation.SUPPORTS)
    &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;USER&amp;gt;&lt;span&gt; queryUsers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userMapper.queryUsers();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）在类上添加 @Transactional 注解可为该类的所有业务方法统一添加事务处理。如果某一业务方法需要采用不同的事务规则，可以在该业务方法上添加 @Transactional 注解单独进行设置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）不建议在查询方法上使用事务，会影响查询的性能。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用注解配置事务时，所使用的属性与在 Spring 配置文件中使用的属性一致。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 27 Jun 2018 14:59:00 +0000</pubDate>
<dc:creator>小铁Winner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</dc:identifier>
</item>
<item>
<title>山寨版计算器 - Roy-T</title>
<link>http://www.cnblogs.com/roy-t/p/calc01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roy-t/p/calc01.html</guid>
<description>&lt;p&gt;今天小酌一杯，起了点点飞智，想用HTML/CSS/JS来山寨一个mac系统自带的计算器。先给自己立两个flag：&lt;/p&gt;
&lt;p&gt;【像众泰学习】外观、功能像素级拷贝为主，兼顾山寨气质。&lt;/p&gt;
&lt;p&gt;【像泽野螳螂学习】原曲不使用。（努力做到不借鉴任何现成的方案）&lt;/p&gt;
&lt;p&gt;废话不多说，现在开始。&lt;/p&gt;
&lt;p&gt;首先，以下是原软件的截图。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627220258391-604829482.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来分析一下颜色：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标题栏的三个按钮目前暂无用处，暂时先不考虑。&lt;/li&gt;
&lt;li&gt;不考虑毛玻璃效果，我无意中截到的单色背景是#292929，字符颜色#ffffff。姑且先用这个。&lt;/li&gt;
&lt;li&gt;功能键区（AC、+/-、%）背景色#d6d6d6，字符颜色#000000。&lt;/li&gt;
&lt;li&gt;数字键区（0-9和小数点）背景色#e0e0e0。字符颜色#000000。&lt;/li&gt;
&lt;li&gt;运算符（+、-、*、/、=）背景色#f5923e，字符颜色#ffffff。&lt;/li&gt;
&lt;li&gt;全界面框线颜色#181818。&lt;/li&gt;
&lt;li&gt;按键区框线颜色#8e8e8e。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以及动画效果：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于数字显示区是毛玻璃的，因此背景是随时变化的，这里放弃了。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，功能键区背景色颜色变为#a9a9a9，字符不变色。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，数字键区背景色颜色变为#b2b2b2，字符不变色。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，运算符区背景色颜色变为#c2732f，字符颜色变为#555555。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后测量一下界面的大小：（我这个屏幕是Retina屏，计算出的像素数应用到实际界面要除以2。）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整个界面（含框线）宽466像素，高642像素。&lt;/li&gt;
&lt;li&gt;整个界面的边框宽度均为1像素，表格四个圆角半径10像素。&lt;/li&gt;
&lt;li&gt;按键分割线宽度2像素。&lt;/li&gt;
&lt;li&gt;数字显示区和按键区之间分割线宽度为0。&lt;/li&gt;
&lt;li&gt;按键区4列不等宽，不含分割线的宽度分别为112、114、114、118像素，是不是有点诡异。&lt;/li&gt;
&lt;li&gt;按键区5行也不等高，不含分割线前4行的高度为94像素，最后一行高96像素。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来是界面字体。（字体我很难做到像素级匹配）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体采用了San Francisco字体。&lt;/li&gt;
&lt;li&gt;数字显示区字体是细字体，按钮区是常规字体。&lt;/li&gt;
&lt;li&gt;字号大小：功能键区&amp;lt;数字键区&amp;lt;运算符区。&lt;/li&gt;
&lt;li&gt;数字键区的字符太长放不下时会自动压缩大小。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面操练起来吧。&lt;/p&gt;
&lt;p&gt;首先，不考虑任何格式因素，先画一个结构相符的表格。在这个表格里实现这个计算器就可以。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;display&quot;&lt;/span&gt;&lt;span&gt; colspan&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;+/-&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;➗&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
…
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;=&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以得到以下的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221049516-406699385.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是颜色匹配。在分析时我们已经按颜色把按键区分成了功能键区、运算符区和数字键区，所以这里就可以为每个按钮添加一个class来指定它所对应的按键区域。字符显示区与按键不同，单独提。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; .digit &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color=#e0e0e0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
…
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;digit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加动画：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; .digit:active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #a9a9a9&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时界面就上好色了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221328467-1790818527.png&quot; alt=&quot;&quot; width=&quot;216&quot; height=&quot;320&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下面考虑边框问题，如果简单处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;table &lt;/span&gt;{&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 0.5px solid #181818&lt;/span&gt;;
}&lt;span&gt;
td &lt;/span&gt;{&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的结果肯定不是所希望的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221552933-1919903683.png&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为HTML管理元素的“margin-border-padding”机制，也就是盒子模型，使得单线表格的实现方式并不是那么直接，尝试一下&lt;span&gt;border:collapse: collapse&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221732240-1750712973.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;圆角被顶没了？很遗憾，&lt;span&gt;collapse&lt;/span&gt;与&lt;span&gt;border-radius&lt;/span&gt;是不能同时使用的。我又尝试了几种方案，找到了一条可行的思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为按键区域设置&lt;span&gt;border-spacing: 0&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;为左上和上部的按钮单独绘制所有边框；&lt;/li&gt;
&lt;li&gt;为其它按钮绘制右侧和底部的边框。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这乍看上去有点愚蠢，但似乎是唯一的思路。情况统一的按钮可以合并处理从而减少一定的工作量。比如按键区中间的按键（8、9、5、6、2、3）可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.center &lt;/span&gt;{&lt;span&gt;
    border-right&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
    border-bottom&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627222015927-339047922.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;接下来设置界面的大小，需要注意的是，table中td的width包含内容的宽度和两次边框的宽度（高度也是），而我们在测量原版软件时的宽度值是除两侧边框之外的宽度，因此这里设置width时要减去边框的宽度，比如最左侧一列按钮，有左侧0.5像素和右侧1像素的边框，因此原宽度56要减去1.5。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.left &lt;/span&gt;{&lt;span&gt;
   border-left&lt;/span&gt;:&lt;span&gt; 0.5px solid #181818&lt;/span&gt;;&lt;span&gt;  
   border-right&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
   border-bottom&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
   width&lt;/span&gt;:&lt;span&gt; 54.5px&lt;/span&gt;;&lt;span&gt;
   height&lt;/span&gt;:&lt;span&gt; 46px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627230811667-1968234812.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就快成功了，字体只说一点：用之前一定看看它是否免费许可。鉴于我只是写来玩玩出于对苹果的崇敬才用的这个字体，苹果大大是不会打我屁屁的，但是你要在你的网站里未经许可使用了付费字体，你会很受伤。还有界面里的字体我没有做到像素对齐，是懒了。（逃&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627223424567-1860819861.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众泰Z700既视感有没有。就问你像不像〇〇〇〇 ？&lt;/p&gt;
&lt;p&gt;to be continued&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 14:44:00 +0000</pubDate>
<dc:creator>Roy-T</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roy-t/p/calc01.html</dc:identifier>
</item>
<item>
<title>spark知识体系2-运行架构 - molyeo</title>
<link>http://www.cnblogs.com/molyeo/p/9236299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/molyeo/p/9236299.html</guid>
<description>&lt;p&gt;本篇主要讲解spark运行架构，包含如下内容：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627220737428-1549597418.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;ul readability=&quot;7.859512195122&quot;&gt;&lt;li&gt;Application&lt;br/&gt;Spark的应用程序，包含一个Driver program和若干Executor&lt;/li&gt;
&lt;li&gt;SparkContext&lt;br/&gt;Spark应用程序的入口，负责调度各个运算资源，协调各个Worker Node的Executor&lt;/li&gt;
&lt;li&gt;Driver Program&lt;br/&gt;运行Application的main()函数并且创建SparkContext&lt;/li&gt;
&lt;li&gt;Executor&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;为Application运行在Worker node上的一个进程，该进程负责运行Task,并且负责将数据存在内存或者磁盘上，每个Application都会申请各自的Executor来处理任务&lt;/li&gt;
&lt;li&gt;Cluster Manager&lt;br/&gt;在集群上获取资源的外部服务(例如Standalone,Mesos,Yarn)&lt;/li&gt;
&lt;li&gt;Worker Node&lt;br/&gt;集群中任何可以运行Application代码的节点，运行一个或者多个Executor进程&lt;/li&gt;
&lt;li&gt;Task&lt;br/&gt;运行在Executor上的工作单元&lt;/li&gt;
&lt;li&gt;Job&lt;br/&gt;SparkContext提交的具体Action操作，常和Action对应&lt;/li&gt;
&lt;li&gt;Stage&lt;br/&gt;每个Job会被拆分很多组task,每组任务被称为Stage,也称TaskSet&lt;/li&gt;
&lt;li&gt;RDD&lt;br/&gt;是Resilient distributed datasets的简称，中文为弹性分布式数据集，是Spark最核心的模块和类&lt;/li&gt;
&lt;li&gt;DAGScheduler&lt;br/&gt;根据Job构建基本Stage的DAG,并提交Stage给TaskScheduler&lt;/li&gt;
&lt;li&gt;TaskScheduler&lt;br/&gt;将TaskSet提交给Worker node集群运行并返回结果&lt;/li&gt;
&lt;li&gt;Transformations&lt;br/&gt;是Spark API的一种类型，Transformation返回值还是一个RDD,所有的Transformation采用的都是懒策略，如果只是将Transformation的提交时不会执行计算的&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Action&lt;br/&gt;是Spark API的一种类型，Action返回值不是一个RDD,而是一个scala集合，计算只有在Action被提交的时候计算才被触发&lt;/p&gt;
&lt;h2 id=&quot;架构设计&quot;&gt;架构设计&lt;/h2&gt;
&lt;h3 id=&quot;standalone模式&quot;&gt;Standalone模式&lt;/h3&gt;
&lt;p&gt;Spark Standalone模式的集群由Master与Worker节点组成，程序通过与Master节点交互申请资源，Worker节点启动Executor运行&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627220933317-301457344.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Driver部分&lt;br/&gt;Driver部分主要是对SparkContext进行配置、初始化以及关闭。初始化SparkContext是为了构建Spark应用程序的运行环境，在初始化SparkContext，要先导入一些Spark的类和隐式转换；在Executor部分运行完毕后，需要将SparkContext关闭。&lt;/li&gt;
&lt;li readability=&quot;6.0825242718447&quot;&gt;
&lt;p&gt;Executor部分&lt;br/&gt;Spark应用程序的Executor部分是对数据的处理,包含原生数据，RDD，以及共享变量&lt;/p&gt;
&lt;h3 id=&quot;spark-on-mesos模式&quot;&gt;spark on Mesos模式&lt;/h3&gt;
&lt;p&gt;Mesos是Apache下的开源分布式资源管理框架。由于血缘关系，Spark官方推荐这种模式，很多公司也采用该模式。Spark On Mesos模式参考：&lt;a href=&quot;http://dongxicheng.org/apache-mesos/meso-architecture/&quot; class=&quot;uri&quot;&gt;http://dongxicheng.org/apache-mesos/meso-architecture/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;spark-on-yarn模式&quot;&gt;Spark on YARN模式&lt;/h3&gt;
&lt;p&gt;Spark on YARN框架解析：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;基于YARN的Spark作业首先由Spark客户端生成作业信息，提交给ResourceManager，ResourceManager在某一个NodeManager汇报时把AppMaster分配给该NodeManager；&lt;/li&gt;
&lt;li&gt;该NodeManager启动Spark AppMaster，Spark AppMaster 启动后初始化作业，然后向ResourceManager申请资源；&lt;/li&gt;
&lt;li&gt;申请到相应资源后，Spark AppMaster通过RPC让对应若干个NodeManager启动相应的 Spark Executor，Spark Executor向Spark AppMaster汇报完成相应的任务。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Spark客户端会通过Spark AppMaster获取作业运行状态。&lt;/p&gt;
&lt;h3 id=&quot;client模式&quot;&gt;Client模式&lt;/h3&gt;
&lt;p&gt;在Spark on YARN/Mesos模式中，根据Spark Application的Driver是否在集群中运行，Spark on YARN/Mesos运行模式又可以分为Client模式和Cluster模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627222254030-1217282677.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cluster模式&quot;&gt;Cluster模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627222302646-65607342.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spark运行基本流程&quot;&gt;Spark运行基本流程&lt;/h2&gt;
&lt;p&gt;Spark集群由若干节点构成，而每个节点都是可以接受和发送消息的RPC服务端点(Endpoint),根据责任的不同可以分为三类端点：Client、Master、Worker，三端调用关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221328318-1773615206.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client:Spark任务节点，负责发布、查询，以及终止任务的相关进程的统称，Client是运行时有效进程，如果任务处理完成，对应的进程结束&lt;/li&gt;
&lt;li&gt;Master：Spark管理节点，负责Worker进程，协调调度Client发布的任务处理，Master节点可以为多个，有且仅有一个为Active状态，其他为Standby状态&lt;/li&gt;
&lt;li&gt;Worker节点：Spark工作节点，负责具体任务的执行工作&lt;br/&gt;基于三端模型，用户通过spark-submit提交或者运行spark-shell REPL,集群创建Driver,Driver加载Application，最后Application根据用户代码转化成RDD,RDD分解为Tasks,Executor执行Task等，整体交互蓝图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221344071-1617374466.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.Client运行时向Master发送启动驱动请求(ResquestSubmitDriver指令)&lt;br/&gt;2.Master调度可用Worker资源进行驱动安装(发送LaunchDriver指令)&lt;br/&gt;3.Worker运行DriverRunner进行驱动加载，并向Master发送应用注册请求(发送RegisterApplication指令)&lt;br/&gt;4.Master调度可用Worker资源进行应用的Executor安装(发送LaunchExecutor指令)&lt;br/&gt;5.Executor安装完毕后向Driver注册驱动可用的Executor资源(发送RegisterExecutor指令)&lt;br/&gt;6.运行用户代码时，通过DAGScheduler,TaskScheduler封装成可以执行的TaskSetManager对象&lt;br/&gt;7.TaskSetManager对象与Driver中的Executor资源进行匹配，在队形的Executor中发布任务(发送LaunchTask指令)&lt;br/&gt;8.TaskRunner执行完毕后，调用DriverRunner提交给DAGScheduler，循环7，执行任务完成&lt;/p&gt;
&lt;h2 id=&quot;spark核心概念&quot;&gt;Spark核心概念&lt;/h2&gt;
&lt;h3 id=&quot;rdd&quot;&gt;RDD&lt;/h3&gt;
&lt;p&gt;弹性分布式数据集(Resilient Distributed Data,RDD)作为Spark的编程模型，相对于MapReduce模型有更好的扩展和延伸：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了抽象层次更高的API&lt;/li&gt;
&lt;li&gt;高效的数据共享&lt;/li&gt;
&lt;li&gt;高效的容错性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;rdd的操作类型&quot;&gt;RDD的操作类型&lt;/h4&gt;
&lt;p&gt;RDD大致可以包括如下四种操作类型：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;创建操作(Creation):从内存集合和外部存储系统创建RDD，或者通过转换操作生成RDD&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;转换操作(Transformation)：转换操作是惰性操作，只是定义一个RDD并记录依赖关系，没有立即执行&lt;/li&gt;
&lt;li&gt;控制操作(Control):进行RDD的持久化，通过设定不同级别对RDD进行缓存&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;行动操作(Action):触发任务提交、Spark运行的操作，操作的结果是获取到结果集或者保存到外部存储系统&lt;/p&gt;
&lt;h4 id=&quot;rdd的实现&quot;&gt;RDD的实现&lt;/h4&gt;
&lt;h5 id=&quot;rdd-的分区&quot;&gt;RDD 的分区&lt;/h5&gt;
&lt;p&gt;RDD的分区是一个逻辑概念，转换操作前后的分区在物理上可能是同一块内存或者存储。在RDD操作中用户可以设定和获取分区数目，默认分区数目为该程序所分配到的cpu核数，如果是从HDFS文件创建，默认为文件的&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221534787-1136633622.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分片数。&lt;/p&gt;
&lt;h5 id=&quot;rdd-的血统和依赖关系&quot;&gt;RDD 的“血统”和依赖关系&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221440940-1914281989.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“血统”和依赖关系：RDD 的容错机制是通过记录更新来实现的，且记录的是粗粒度的转换操作。我们将记录的信息称为血统（Lineage）关系，而到了源码级别，Apache Spark 记录的则是 RDD 之间的依赖（Dependency）关系。如上所示，每次转换操作产生一个新的RDD（子RDD），子RDD会记录其父RDD的信息以及相关的依赖关系。&lt;/p&gt;
&lt;h5 id=&quot;依赖关系&quot;&gt;依赖关系&lt;/h5&gt;
&lt;p&gt;依赖关系划分为两种：窄依赖（Narrow Dependency）和 宽依赖（源码中为Shuffle Dependency）。&lt;/p&gt;
&lt;p&gt;窄依赖指的是父 RDD 中的一个分区最多只会被子 RDD 中的一个分区使用，意味着父RDD的一个分区内的数据是不能被分割的，子RDD的任务可以跟父RDD在同一个Executor一起执行，不需要经过 Shuffle 阶段去重组数据。&lt;br/&gt;窄依赖包括两种：一对一依赖（OneToOneDependency）和范围依赖（RangeDependency）&lt;br/&gt;一对一依赖：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221633490-564569429.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;范围依赖（仅union方法）：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221645062-2135878175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;宽依赖指的是父 RDD 中的分区可能会被多个子 RDD 分区使用。因为父 RDD 中一个分区内的数据会被分割，发送给子 RDD 的所有分区，因此宽依赖也意味着父 RDD 与子 RDD 之间存在着 Shuffle 过程。&lt;br/&gt;宽依赖只有一种：Shuffle依赖（ShuffleDependency）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221702608-1971866514.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;transformations-actions&quot;&gt;Transformations / Actions&lt;/h3&gt;
&lt;p&gt;RDDs support 两种类型的操作: transformations（转换）, 它会在一个已存在的 dataset 上创建一个新的 dataset, 和 actions（动作）, 将在 dataset 上运行的计算后返回到 driver 程序. 例如, map 是一个通过让每个数据集元素都执行一个函数，并返回的新 RDD 结果的 transformation, reduce reduce 通过执行一些函数，聚合 RDD 中所有元素，并将最终结果给返回驱动程序（虽然也有一个并行 reduceByKey 返回一个分布式数据集）的 action.&lt;/p&gt;
&lt;p&gt;Spark 中所有的 transformations 都是 lazy（懒加载的）, 因此它不会立刻计算出结果. 相反, 他们只记得应用于一些基本数据集的转换 (例如. 文件). 只有当需要返回结果给驱动程序时，transformations 才开始计算. 这种设计使 Spark 的运行更高效. 例如, 我们可以了解到，map 所创建的数据集将被用在 reduce 中，并且只有 reduce 的计算结果返回给驱动程序，而不是映射一个更大的数据集.&lt;/p&gt;
&lt;p&gt;默认情况下，每次你在 RDD 运行一个 action 的时， 每个 transformed RDD 都会被重新计算。但是，您也可用 persist (或 cache) 方法将 RDD persist（持久化）到内存中；在这种情况下，Spark 为了下次查询时可以更快地访问，会把数据保存在集群上。此外，还支持持续持久化 RDDs 到磁盘，或复制到多个结点。&lt;/p&gt;
&lt;h3 id=&quot;jobs-stage&quot;&gt;Jobs / Stage&lt;/h3&gt;
&lt;p&gt;作业执行原理&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221812266-1822998362.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作业（Job）：RDD每一个行动操作都会生成一个或者多个调度阶段。&lt;br/&gt;调度阶段（Stage）：每个Job都会根据依赖关系，以Shuffle过程作为划分，分为Shuffle Map Stage和Result Stage。每个Stage包含多个任务集（TaskSet），TaskSet的数量与分区数相同。&lt;br/&gt;任务（Task）：分发到Executor上的工作任务，是Spark的最小执行单元。&lt;br/&gt;DAGScheduler：DAGScheduler是面向调度阶段的任务调度器，负责划分调度阶段并提交给TaskScheduler。&lt;br/&gt;TaskScheduler：TaskScheduler是面向任务的调度器，它负责将任务分发到Woker节点，由Executor进行执行。&lt;/p&gt;
&lt;h4 id=&quot;作业提交和作业调度策略&quot;&gt;作业提交和作业调度策略&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627221944673-1390609489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一次行动操作都会触发SparkContext的runJob方法进行作业的提交。&lt;br/&gt;这些作业之间可以没有任何依赖关系，对于多个作业之间的调度，共有两种：一种是默认的FIFO模式，另一种则是FAIR模式，该模式的调度可以通过设定minShare（最小任务数）和weight（任务的权重）来决定Job执行的优先级。&lt;br/&gt;FIFO调度策略：优先比较作业优先级（作业编号越小优先级越高），再比较调度阶段优先级（调度阶段编号越小优先级越高）。&lt;br/&gt;FAIR调度策略：先获取两个调度的饥饿程度，是否处于饥饿状态由当前正在运行的任务是否小于最小任务决定，获取后进行如下比较：&lt;/p&gt;
&lt;p&gt;DAG的构建：主要是通过对最后一个RDD进行递归，使用广度优先遍历每个RDD跟父RDD的依赖关系（前面提到子RDD会记录依赖关系），碰到ShuffleDependency的则进行切割。切割后形成TaskSet传递给TaskScheduler进行执行。&lt;br/&gt;DAG的作用：让窄依赖的RDD操作合并为同一个TaskSet，将多个任务进行合并，有利于任务执行效率的提高。&lt;br/&gt;TaskSet结构图：假设数据有两个Partition时，TaskSet是一组关联的，但相互之间没有Shuffle依赖关系的Task集合，TaskSet的ShuffleMapStage数量跟Partition个数相关，主要包含task的集合，stage中的rdd信息等等。Task会被序列化和压缩　&lt;/p&gt;
&lt;h3 id=&quot;shuffle&quot;&gt;Shuffle&lt;/h3&gt;
&lt;h4 id=&quot;概念&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;Spark里的某些操作会触发shuffle。shuffle是Spark重新分配数据的一种机制，使得这些数据可以跨不同的区域进行分组，通常涉及在executors和机器之间拷贝数据，使得shuffle成为一个复杂的、代价高的操作。&lt;/p&gt;
&lt;h4 id=&quot;实例说明&quot;&gt;实例说明&lt;/h4&gt;
&lt;p&gt;为了明白 reduceByKey 操作的过程，我们以 reduceByKey 为例。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/719892/201806/719892-20180627222104555-427654195.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据处理：文件在hdfs中以多个切片形式存储，读取时每一个切片会被分配给一个Excutor进行处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;map端操作：map端对文件数据进行处理，格式化为(key,value)键值对，每个map都可能包含a,b,c,d等多个字母，如果在map端使用了combiner，则数据会被压缩，value值会被合并；（注意：这个过程的使用需要保证对最终结果没有影响，有利于减少shuffle过程的数据传输）；&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;reduce端操作：reduce过程中，假设a和b，c和d在同一个reduce端，需要将map端被分配在同一个reduce端的数据进行洗牌合并，这个过程被称之为shuffle。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;reduceByKey(func, [numTasks]) ：在 (K, V) pairs 的 dataset 上调用时, 返回 dataset of (K, V) pairs 的 dataset, 其中的 values 是针对每个 key 使用给定的函数 func 来进行聚合的, 它必须是 type (V,V) =&amp;gt; V 的类型. 像 groupByKey 一样, reduce tasks 的数量是可以通过第二个可选的参数来配置的。&lt;br/&gt;reduceBykey 操作产生一个新的 RDD，其中 key 所有相同的的值组合成为一个 tuple - key 以及与 key 相关联的所有值在 reduce 函数上的执行结果。面临的挑战是，一个 key 的所有值不一定都在一个同一个 paritition 分区里，甚至是不一定在同一台机器里，但是它们必须共同被计算。&lt;br/&gt;在 spark 里，特定的操作需要数据不跨分区分布。在计算期间，一个任务在一个分区上执行，为了所有数据都在单个 reduceByKey 的 reduce 任务上运行，我们需要执行一个 all-to-all 操作。它必须从所有分区读取所有的 key 和 key对应的所有的值，并且跨分区聚集去计算每个 key 的结果 - 这个过程就叫做 shuffle。&lt;br/&gt;尽管每个分区新 shuffle 的数据集将是确定的，分区本身的顺序也是这样，但是这些数据的顺序是不确定的。如果希望 shuffle 后的数据是有序的，可以使用:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mapPartitions 对每个 partition 分区进行排序，例如sorted&lt;/li&gt;
&lt;li&gt;repartitionAndSortWithinPartitions 在分区的同时对分区进行高效的排序.&lt;/li&gt;
&lt;li&gt;sortBy 对 RDD 进行全局的排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发的 shuffle 操作包括 repartition 操作，如 repartition 和 coalesce, ‘ByKey 操作 (除了 counting 之外) 像 groupByKey 和 reduceByKey, 和 join 操作, 像 cogroup 和 join.&lt;/p&gt;
&lt;h4 id=&quot;性能影响&quot;&gt;性能影响&lt;/h4&gt;
&lt;p&gt;shuffle 是一个代价比较高的操作，它涉及磁盘 I/O、数据序列化、网络 I/O。为了准备 shuffle 操作的数据，Spark 启动了一系列的任务，map 任务组织数据，reduce 完成数据的聚合。&lt;br/&gt;在内部，一个 map 任务的所有结果数据会保存在内存，直到内存不能全部存储为止。然后，这些数据将基于目标分区进行排序并写入一个单独的文件中。在 reduce 时，任务将读取相关的已排序的数据块。&lt;br/&gt;某些 shuffle 操作会大量消耗堆内存空间，因为 shuffle 操作在数据转换前后，需要在使用内存中的数据结构对数据进行组织。需要特别说明的是，reduceByKey 和 aggregateByKey 在 map 时会创建这些数据结构，'ByKey 操作在 reduce 时创建这些数据结构。当内存满的时候，Spark 会把溢出的数据存到磁盘上，这将导致额外的磁盘 I/O 开销和垃圾回收开销的增加。&lt;br/&gt;shuffle 操作还会在磁盘上生成大量的中间文件。在 Spark 1.3 中，这些文件将会保留至对应的 RDD 不在使用并被垃圾回收为止。这么做的好处是，如果在 Spark 重新计算 RDD 的血统关系（lineage）时，shuffle 操作产生的这些中间文件不需要重新创建。如果 Spark 应用长期保持对 RDD 的引用，或者垃圾回收不频繁，这将导致垃圾回收的周期比较长。这意味着，长期运行 Spark 任务可能会消耗大量的磁盘空间。临时数据存储路径可以通过 SparkContext 中设置参数 spark.local.dir 进行配置。&lt;/p&gt;
&lt;h3 id=&quot;cache&quot;&gt;Cache&lt;/h3&gt;
&lt;p&gt;Spark 中一个很重要的能力是将数据 persisting 持久化（或称为 caching 缓存），在多个操作间都可以访问这些持久化的数据。当持久化一个 RDD 时，每个节点的其它分区都可以使用 RDD 在内存中进行计算，在该数据上的其他 action 操作将直接使用内存中的数据。这样会让以后的 action 操作计算速度加快（通常运行速度会加速 10 倍）。缓存是迭代算法和快速的交互式使用的重要工具。&lt;/p&gt;
&lt;p&gt;RDD 可以使用 persist() 方法或 cache() 方法进行持久化。数据将会在第一次 action 操作时进行计算，并缓存在节点的内存中。Spark 的缓存具有容错机制，如果一个缓存的 RDD 的某个分区丢失了，Spark 将按照原来的计算过程，自动重新计算并进行缓存。&lt;/p&gt;
&lt;p&gt;另外，每个持久化的 RDD 可以使用不同的 storage level 存储级别进行缓存，例如，持久化到磁盘、已序列化的 Java 对象形式持久化到内存（可以节省空间）、跨节点间复制、以 off-heap 的方式存储在 Tachyon。这些存储级别通过传递一个 StorageLevel 对象 (Scala, Java, Python) 给 persist() 方法进行设置。cache() 方法是使用默认存储级别的快捷设置方法，默认的存储级别是 StorageLevel.MEMORY_ONLY（将反序列化的对象存储到内存中）。详细的存储级别介绍如下:&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/xZWlHNS.png&quot;/&gt;&lt;br/&gt;在 shuffle 操作中（例如 reduceByKey），即便是用户没有调用 persist 方法，Spark 也会自动缓存部分中间数据.这么做的目的是，在 shuffle 的过程中某个节点运行失败时，不需要重新计算所有的输入数据。如果用户想多次使用某个 RDD，强烈推荐在该 RDD 上调用 persist 方法.&lt;/p&gt;
&lt;h4 id=&quot;存储级别选择&quot;&gt;存储级别选择&lt;/h4&gt;
&lt;p&gt;Spark 的存储级别的选择，核心问题是在 memory 内存使用率和 CPU 效率之间进行权衡。建议按下面的过程进行存储级别的选择:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果您的 RDD 适合于默认存储级别 (MEMORY_ONLY),那就这样. 这是CPU效率最高的选项，允许RDD上的操作尽可能快地运行.&lt;/li&gt;
&lt;li&gt;如果不是, 试着使用 MEMORY_ONLY_SER 和选择快速的序列化库以使对象更加节省空间，但仍然能够快速访问。 (Java和Scala)&lt;/li&gt;
&lt;li&gt;不要溢出到磁盘，除非计算您的数据集的函数是昂贵的, 或者它们过滤大量的数据. 否则, 重新计算分区可能与从磁盘读取分区一样快.&lt;/li&gt;
&lt;li&gt;如果需要快速故障恢复，请使用复制的存储级别 (e.g. 如果使用Spark来服务 来自网络应用程序的请求). All存储级别通过重新计算丢失的数据来提供完整的容错能力，但复制的数据可让您继续在 RDD 上运行任务，而无需等待重新计算一个丢失的分区.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 27 Jun 2018 14:26:00 +0000</pubDate>
<dc:creator>molyeo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/molyeo/p/9236299.html</dc:identifier>
</item>
<item>
<title>Docker01 centos系统安装、centos安装docker、docker安装mongoDB - CRUD_Architect</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/9236211.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/9236211.html</guid>
<description>
&lt;h2&gt;1 centos系统安装&lt;/h2&gt;
&lt;p&gt;　　本博文是基于 centos6.5 的，利用 &lt;a href=&quot;https://pan.baidu.com/s/1NaCiFEQ1z5fmL-m_HXhJtQ&quot; target=&quot;_blank&quot;&gt;VMware&lt;/a&gt; 虚拟机搭建 centos6.5 系统&lt;/p&gt;
&lt;h3&gt;　　1.1 &lt;a href=&quot;https://pan.baidu.com/s/1yfqScBXory5k5FZtgIQcnw&quot; target=&quot;_blank&quot;&gt;centos6.5&lt;/a&gt; 资源获取&lt;/h3&gt;
&lt;h3&gt;　　1.2 安装&lt;/h3&gt;
&lt;h4&gt;　　　　1.2.1 新建虚拟机&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627220533793-1631713544.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;502&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.2 类型配置&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627220703051-364665662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3 系统资源来源&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627220806662-1425607768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.4 操作系统和系统版本选择&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧：需要根据镜像资源来选择，本博文使用的镜像资源是 centos6.5 64位&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627220943509-1716992111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.5 虚拟机名称与存放位置&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221024125-1712384089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.6 磁盘容量和分区选择&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221324891-506680481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.7 硬件配置&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221527346-968311675.png&quot; alt=&quot;&quot;/&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221500443-738175316.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 　　　　1.2.8 开启新创建的虚拟机进行引导安装&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221707965-1544318670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.9 选择安装什么&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221819078-1287175459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.10 跳过媒体测试&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221906123-1255339303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.11 硬件不支持提示信息&lt;/h4&gt;
&lt;p&gt;　　　　　　选择OK即可&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627221952490-391694187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.12 主机名&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627222158184-97177582.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.13 密码设定&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627222321890-1737053790.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.2.14 自动安装依赖&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧01：安装完后选择重新引导来重启系统&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627223121222-1019422519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　1.3 登陆系统&lt;/h3&gt;
&lt;p&gt;　　　　录入登陆名回车 -&amp;gt; 录入密码&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627223459953-1277057861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　1.4 查看IP地址&lt;/h3&gt;
&lt;p&gt;　　　　技巧：新安装的系统默认没有开启网关，所以IP地址是回环&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627223605458-1905736662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.4.1 手动开启网关&lt;/h4&gt;

&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627223846834-1842143197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.4.2 查看IP&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627223923833-1989417555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　1.5 远程登陆&lt;/h3&gt;
&lt;p&gt;　　　　技巧：先关闭系统的防火墙&lt;/p&gt;
&lt;h4&gt;　　　　1.5.1 查看防火墙状态&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627224046757-1896617556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.5.2 关闭防火墙&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627224142894-483339422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.5.3 利用&lt;a href=&quot;https://pan.baidu.com/s/1EVgSTBjlIzNY0UYnxJok_g&quot; target=&quot;_blank&quot;&gt;SecureCRT&lt;/a&gt;远程登陆&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627224406663-1283186434.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627224450023-952233960.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2 centos6.5 安装kocker&lt;/h2&gt;
&lt;h3&gt;　　2.1 命令&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo yum install -y http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.yun-idc.com/epel/6/i386/epel-release-6-8.noarch.rpm&lt;/span&gt;
&lt;span&gt;
sudo yum install &lt;/span&gt;-y docker-io
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.2 docker 简单命令&lt;/h3&gt;
&lt;p&gt;　　　　service docker status -&amp;gt; 查看docker状态&lt;/p&gt;
&lt;p&gt;　　　　service docker start -&amp;gt; 启动docker&lt;/p&gt;
&lt;p&gt;　　　　service docker restart -&amp;gt; 重启docker&lt;/p&gt;
&lt;p&gt;　　　　坑01：docker启动失败，启动后查看状态时的错误信息如下&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627225350484-2102838298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　解决01：&lt;a href=&quot;https://www.2cto.com/net/201612/573947.html&quot; target=&quot;_blank&quot;&gt;安装一个依赖&lt;/a&gt;，安装成功后重启docker即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install device-mapper-&lt;span&gt;event&lt;/span&gt;-libs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627225614079-1895239333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3 docker&lt;a href=&quot;http://www.runoob.com/docker/docker-install-mongodb.html&quot; target=&quot;_blank&quot;&gt;安装&lt;/a&gt;mongoDB&lt;/h2&gt;
&lt;h3&gt;　　3.1 查找mongoDB镜像&lt;/h3&gt;
&lt;p&gt;　　　　查找Docker Hub上的mongo镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker search mongo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627230142520-1690237641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3.2 拉取官方的镜像&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker pull mongo
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.3 启动mongoDB容器&lt;/h3&gt;
&lt;h4&gt;　　　　3.3.1 前提准备&lt;/h4&gt;
&lt;p&gt;　　　　　　在 centos 系统的根目录创建两个文件夹 mongo_data_db 、mongo_data_configdb&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627230739086-1576075773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.3.2 启动mongoDB容器&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d --name mongo -v /mongo_data_configdb:/data/configdb -v /mongo_data_db:/data/db -p &lt;span&gt;27017&lt;/span&gt;:&lt;span&gt;27017&lt;/span&gt;  mongo --auth
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　启动成功后可以查看容器信息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627234053793-584213182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　3.3.3 初始化管理员账号&lt;/h4&gt;
&lt;p&gt;　　　　　　进入容器 -&amp;gt; 进行账号操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker exec -it mongo     mongo              admin
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.createUser({ user: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pwd: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, roles: [ { role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; } ] });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627234147117-1343862145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057762/201806/1057762-20180627234216637-538330472.png&quot; alt=&quot;&quot; width=&quot;1043&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3.4 参考文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d4087ed8-a056-478c-8a4d-500dbbf9f2b9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d4087ed8-a056-478c-8a4d-500dbbf9f2b9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d4087ed8-a056-478c-8a4d-500dbbf9f2b9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2&lt;/span&gt;&lt;span&gt; docker
    https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.jianshu.com/p/f272726db9c5        docker安装与操作&lt;/span&gt;
    https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.2cto.com/net/201612/573947.html     docker启动报错&lt;/span&gt;
    
&lt;span&gt;3&lt;/span&gt;&lt;span&gt; mongodb
    http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.runoob.com/docker/docker-install-mongodb.html    拉取mongodb -&amp;gt; 方法二&lt;/span&gt;
    https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.jianshu.com/p/3a8c1904e807     安装与使用&lt;/span&gt;
&lt;span&gt;    
    docker run &lt;/span&gt;-d --name mongo -v /mongo_data_configdb:/data/configdb -v /mongo_data_db:/data/db -p &lt;span&gt;27017&lt;/span&gt;:&lt;span&gt;27017&lt;/span&gt;  mongo --&lt;span&gt;auth   创建
    docker exec &lt;/span&gt;-&lt;span&gt;it mongo     mongo              admin            进入
    db.createUser({ user: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pwd: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, roles: [ { role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; } ] });    创建角色
    docker run &lt;/span&gt;-it --rm --link mongo:mongo mongo mongo -u admin -p admin --authenticationDatabase admin mongo/&lt;span&gt;admin        测试连通性

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt; docker 书籍
    https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;legacy.gitbook.com/book/yeasy/docker_practice/details&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;











</description>
<pubDate>Wed, 27 Jun 2018 14:07:00 +0000</pubDate>
<dc:creator>CRUD_Architect</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/9236211.html</dc:identifier>
</item>
<item>
<title>ASP.NET的底层体系1 - 小王子的博客</title>
<link>http://www.cnblogs.com/xiaowangzi1987/p/9232789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowangzi1987/p/9232789.html</guid>
<description>&lt;h3&gt;引言：&lt;/h3&gt;
&lt;p&gt;                学习ASP.NET，要想做的更好，不了解ASP.NET是不行的。一个有理想的程序员都会像挤压海绵一样，努力的去学习和获取宝贵的知识。&lt;/p&gt;
&lt;p&gt;                本篇文档内容，转自小皓园的博文---&amp;gt;&lt;a href=&quot;http://www.cnblogs.com/rijing2004/archive/2007/09/14/howaspnetwork.html&quot;&gt;（翻译）从底层了解ASP.NET体系结构&lt;/a&gt;，以此来尊重原创精神，并对其进行提炼，去掉一些无关的内容。&lt;/p&gt;
&lt;h3&gt;一.ASP.NET是什么&lt;/h3&gt;
&lt;p&gt;                ASP.NET是一个请求处理引擎，它获取客户端的请求，然后通过内置的管道，把请求传递到终点，在这个终点，开发者可以添加处理这个请求的逻辑代码。&lt;/p&gt;
&lt;p&gt;                整个ASP.NET引擎构建在托管代码里，所有的扩展功能都是通过托管代码的扩展提供。&lt;/p&gt;
&lt;p&gt;                使用ASP.NET可以完成一些任务，之前这些任务是使用IIS的ISAPI扩展和过滤来完成的，尽管还有一些限制，但与ASP相比，已经有了很大的进步。ISAPI是底层Win32样式的API，它的接口就有1M，这样对于大型程序开发是非常困难的，由于ISAPI是底层的接口，因此它的速度也是很快的。&lt;/p&gt;
&lt;p&gt;                微软的ASP.NET和IIS的接口是通过宿主在.NET里的ISAPI扩展来通信的，ISAPI提供了与WebServer通信的核心接口，然后ASP.NET使用非托管代码获取请求发出响应。&lt;/p&gt;
&lt;h3&gt;二.HTTP&lt;/h3&gt;
&lt;p&gt;                HTTP运行时提供了一套复杂的机制，在处理请求的每一个层面都牵涉许多对象，但大多数对象都可以通过派生或事件接口来扩展。通过HTTP，可以进入较低层次的接口如：缓存、身份验证、授权等信息。可以在处理请求之前或之后过滤内容等等。&lt;/p&gt;
&lt;h3&gt;三.从浏览器到ASP.NET&lt;/h3&gt;
&lt;p&gt;                我们从一个典型的ASP.NET Web请求的生命周期开始说起。用户通过在浏览器输入一个URL，点击链接，提交一个HTML表单（一个POST请求），或者一个客户端程序调用基于ASP.NET的Web Services。在服务端，IIS收到这个请求。&lt;/p&gt;
&lt;p&gt;                ASP.NET的底层通过ISAPI扩展与IIS通信，然后，通过ASP.NET这个请求通常被路由到一个带.aspx扩展名的页面，但是这个处理过程如何工作，则完全依赖于HTTP处理器（handler）的执行。在IIS中，.aspx经由“应用程序扩展”被映射到ASP.NET ISAPI的dll文件：aspnet_isapi.dll，每一个触发ASP.NET的请求，都必须由一个已经注册的，并且指向aspnet_isapi.dll的扩展名来标识。&lt;/p&gt;
&lt;p&gt;                依靠扩展名，ASP.NET把一个请求路由到一个恰当的处理器，该处理器则负责处理这个请求。&lt;/p&gt;
&lt;p&gt;                     &lt;strong&gt;例子&lt;/strong&gt;：Web Service的扩展名.asmx不会把一个请求路由到磁盘的某一个页面，而是会路由到定义中附加了指定特性的类，此特性会把它标记为一个Web Services的实现。&lt;/p&gt;
&lt;h3&gt;四.ISAPI&lt;/h3&gt;
&lt;p&gt;                ISAPI是底层非托管的Win32 API，它定义的接口非常的单一且性能最优。用这些接口处理原始指针（raw pointer）,而函数指针列表（function pointer）则用于回调。ISAPI提供了最底层的、高性能的接口。&lt;/p&gt;
&lt;p&gt;                ISAPI趋向于被当做桥接口使用，用于给高层级的工具提供应用服务类型的功能。&lt;/p&gt;
&lt;p&gt;                     &lt;strong&gt;例子&lt;/strong&gt;：ASP.NET就是构建在ISAPI之上，ISAPI给高层次的应用程序提供了高性能垂直访问接口，使得高层次的应用程序需要的信息可以从ISAPI提供的信息中提炼，引擎可以提炼ISAPI接口提供的表单里的对象有:Request Response。&lt;/p&gt;
&lt;p&gt;                作为约定，ISAPI支持ISAPI扩展（extensions）和ISAPI过滤（filters），扩展是请求处理接口，提供了跟Web Server输入和输出相关的逻辑处理。从本质来说，它是一个事务接口。&lt;/p&gt;
&lt;p&gt;                ISAPI是钩子接口，它允许你查看进入IIS的每一个请求并可以修改请求的内容。&lt;/p&gt;
&lt;p&gt;                 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180627224105269-834057897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                IIS把不同的扩展名如.aspx映射到ASP.NET的ISAPI扩展，通过这种机制，在WEB SERVER里，请求就可以被路由到ASP.NET的处理管道里。&lt;/p&gt;
&lt;h3&gt;五.IIS5   IIS6&lt;/h3&gt;
&lt;p&gt;                当一个请求进来的时候，IIS会检查脚本映射，然后把请求路由到aspnet_isapi.dll。IIS 6总会保持一个单独的工作进程：应用程序池，所有的处理都发生在这个进程里。对于IIS 6来说，应用程序池是一个重大的改进，因为他们允许以更小的粒度控制一个指定进程的执行。你可以为每一个虚拟目录或者整个web站点配置应用程序池，这样它可以与运行在同一台机器的其他程序完全隔离。&lt;/p&gt;
&lt;p&gt;                应用程序池是高度可配置的，通过设置应用程序池的执行许可，可以配置他们的执行环境。对于ASP.NET而言，IIS 6最大的改进是使用应用程序池代替了machine.config里的ProcessModel实体的大部分功能。在IIS 5里，这个实体是很难管理的，因为它的设置是全局的，而且不能够在指定WEB程序的wen.config里覆盖这些设置。当IIS 6运行的时候，ProcessModel里的大部分配置将被忽略，取而代之的是读取应用程序池的配置。另外一些配置，像线程池的大小和IO线程数目等仍然还是要通过这个节点的配置。&lt;/p&gt;
&lt;p&gt;              IIS 6应用程序池也包含了ASP.NET固有的东西，ASP.NET可以和新的底层API通信，这些API允许直接访问HTTP缓冲存储器的API，而HTTP缓冲存储器的API可以直接进入Web SERVER的缓冲存储器，卸载ASP.NET级别的缓存。&lt;/p&gt;
&lt;p&gt;              在IIS 6里，ISAPI扩展运行在应用程序池的工作进程里，而.NET运行时也在这个进程里，所以ISAPI扩展和.NET运行时通信是发生在进程内。&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180627224255260-1483220808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;  六.进入.NET运行时&lt;/h3&gt;
&lt;p&gt;              进入.NET运行时真正登录点发生在一些没有正式文档的类和接口之间。工作进程w3wp.exe宿主在.NET运行里。ISAPI dll通过底层的COM调用一小撮非托管类型的接口，其实最终调用的是ISAPIRuntime派生类的实例。进入运行时的第一个登录点是未归档的ISAPIRuntime类，它通过COM把接口IISAPIRuntime暴露给调用者，这些COM接口是底层的IUnknown。基于这些接口，就意味着ISAPI到ASP.NET之间的调用属于内部调用。&lt;/p&gt;
&lt;p&gt;              IISAPIRuntime接口担当着来自ISAPI扩展的非托管代码和托管代码之间的桥梁&lt;/p&gt;
&lt;p&gt;                            [return:MarshallAs(UnmanagerType.I4)]&lt;/p&gt;
&lt;p&gt;                            int ProcessRequest(IntPtr ecb,[In,MarshallAs(UnmanagerType.I4)] int useProcessMode)&lt;/p&gt;
&lt;p&gt;              ecb参数是ISAPI扩展控制块，它作为非托管资源传递给ProcessRequest方法，此方法将获取ECB，然后作为基本的输入和输出接口，用于Request和Response对象。ISAPI ECB包含着所有底层的请求信息，这其中包括服务器变量、用于表单变量的输入流和写数据并把数据发送到客户端的输出流中。一个单独的ECB引用基本提供了一个ISAPI请求可以访问的所有功能。&lt;/p&gt;
&lt;p&gt;              ISAPI扩展以异步的方式处理请求，所以当ISAPI扩展调用了工作进程或者IIS的线程后，会立即返回，但会为当前的请求保留ECB，因此，ECB需要包含这样的机制，当请求结束的时候通知ISAPI,然后ISAPI扩展释放ECB资源。接着以异步的方式立即释放ISAPI的工作线程和卸载由ASP.NET托管的那个隔离的处理线程。&lt;/p&gt;
&lt;p&gt;              ASP.NET得到ECB引用后，会在内部使用它来获取当前请求的相关信息。如服务器变量。ECB将就存活直到这个请求结束或者IIS超时，在这之前，ASP.NET将会与ecb继续保持通信，当请求结束的时候，输出的内容会写进ISAPI的输出流中。然后ISAPI扩展会被通知请求已经结束，让它知道ECB可以被释放了，这个执行过程是非常高效的。&lt;/p&gt;
&lt;h3&gt;七.ProcessRequest&lt;/h3&gt;
&lt;p&gt;              ISAPI是多线程的，因此请求可以以多线程的方式穿过AppDomainFactory.Create()返回的对象引用。&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180627224341588-836536858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ProcessRequest(IntPtr ecb,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; iWRType)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ISAPIWorkerRequest从HttpWorkRequest继承，这里创建的是一个ISAPIWorkerRequest派生类的一个实例&lt;/span&gt;
    HttpWorkerRequest request=&lt;span&gt;ISAPIWorkerRequest.CreateWorkerRequest(ecb,iWRType);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到请求的物理路径&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; str=&lt;span&gt;request.GetAppPathTranslated();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到AppDomain的物理路径&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; str2=&lt;span&gt;HttpRuntime.AppDomainAppPathInternal;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( str2==&lt;span&gt;null&lt;/span&gt; || str.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) || &lt;span&gt;string&lt;/span&gt;.Compare(str,str2,&lt;span&gt;true&lt;/span&gt;,CultureInfo.InvariantCulture)==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
         HttpRuntime.ProcessRequest(request);
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果外部请求的AppDomain物理路径和原来的AppDomain的路径不同，说明ISAPI维持的AppDomain已经失效，所以需要把原来的城西关闭&lt;/span&gt;
     HttpRuntime.ShutDownAppDomain(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str+&lt;span&gt;str2);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;              上述代码ProcessRequest接收一个ISAPI ecb对象和一个服务器类型参数，这个线程是安全的，因此多个ISAPI线程可以同时安全的调用单个返回对象的实例。&lt;/p&gt;
&lt;p&gt;              System.Web.Hosting.ISAPIWorkerRequest继承抽象类HttpWorkerRequest，它的职责是创建一个抽象的输入和输出视图，为Web程序的输入提供服务。上面的代码中有一个方法CreateWorkerRequest，这个方法的第二个参数用于指定创建什么样的工作请求对象，即ISAPIWorkerRequest的派生类，这里有三个不同的版本：ISAPIWorkerRequestInProc,ISAPIWorkerRequestInProcForIIS6,ISAPIWorkerRequestOutOfProc。当这个请求到来时，这个ISAPIWorkerRequest将被创建，用于给Request和Response对象提供基础服务，而这两个对象将从数据的提供者WorkerRequest接收数据流。&lt;/p&gt;
&lt;p&gt;              抽象类HttpWworkerRequest围绕着底层的接口提供了高层的抽象，这样就不用考虑数据的来源，无论他是一个CGI Web Server,Web浏览器还是自定义的机制（用于把数据流入HTTP运行），ASP.NET都可以以同样的方式从中获取数据。&lt;/p&gt;
&lt;p&gt;              有关IIS的抽象主要集中在ISAPI ECB块，在我们的请求处理当中，ISAPIWorkerRequest依赖于ISAPI ECB块。&lt;/p&gt;
&lt;p&gt;              ISAPIWorkerRequest实现了一个高层次包装器方法，它调用了低层次的核心方法，而这些方法负责实际调用非托管API或者是“服务层的实现”，核心的方法在ISAPIWorkerRequest的派生类中得以实现，这样可以针对它宿主的环境提供特定的实现，为以后增加一个额外环境的实现类作为新的Web Server接口提供了便利。&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;          说句实话，上面的内容讲了这么多，头都被绕晕了。讲来讲去总结就是以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                            1.用户在浏览器输入一个URL，提交一个HTML表单。服务端的IIS接收到请求，ASP.NET的底层ISAPI与IIS通信，路由到指定的页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                            2.ISAPI是底层非托管的win32 API，ASP.NET都是构建在ISAPI之上，它给高层次的应用程序提供了高性能垂直访问接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                            3.在ISAPI扩展里，当第一个请求命中一个ASP.NET的映射扩展时，工作线程就会引导.NET运行时启动。一旦运行时存在了，非托管代码就可以为指定的虚拟目录请求一个ISAPRuntime的实例，当然这个前提是这个实例还不存在，每个虚拟目录都会拥有一个AppDomain，ISAPIRuntime存在于AppDomain中，它引导一个单独的程序启动。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 13:52:00 +0000</pubDate>
<dc:creator>小王子的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaowangzi1987/p/9232789.html</dc:identifier>
</item>
<item>
<title>设计模式漫谈之迭代器模式 - Wang_Charle</title>
<link>http://www.cnblogs.com/wang-charle/p/9236127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-charle/p/9236127.html</guid>
<description>&lt;p&gt;谈恋爱是两个人的事，结婚是两个家庭的事。最近事也挺多的。我也挺烦的，有时候，我也为自己的将来担忧，我自认为自己的技术过硬，但是千里马只有遇到伯乐才能发挥作用。&lt;/p&gt;
&lt;p&gt;技术上让我高兴的事是，有个技术问题终于突破了，花了我1个多月时间惦记这事，终于我又花一天时间，不停的尝试，坚持，最后终于搞定了。主要是用IL语言操作实体取值赋值方法，完全个人独立所完成。使用这种方法，我的开源底层框架效率会提升数倍。也是我开源框架的亮点。目前我的开源应用程序底层框架在码云托管平台上托管着，github上只留有最原始的操作数据库版本。至于这个项目什么时候公开，待以后再决定。目前还属于建设完善阶段。&lt;/p&gt;
&lt;p&gt;重要是事多说几遍，对象是具有空间的，空间是可以放东西的，如果这个东西是另一个对象，那么放的是这个对象的引用。这样，两个对象就发生关系了，即可以访问的关系。&lt;/p&gt;
&lt;p&gt;迭代器模式就是操作集合的一个对象，既然能操作集合，肯定存了集合的引用。集合的基类接口已经约束了，迭代集合对象。&lt;/p&gt;
&lt;p&gt;迭代器即一个对象操作另一个对象。&lt;/p&gt;
&lt;p&gt;直接上例子，我来解释&lt;/p&gt;
&lt;p&gt;//抽象的描述了关系，将来的Aggregate存了Iterator 对象的引用，可以访问到Iterator 对象。&lt;/p&gt;
&lt;p&gt;abstract class Aggregate&lt;br/&gt;{&lt;br/&gt;public abstract Iterator CreateIterator();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//具体对象&lt;/p&gt;
&lt;p&gt;class ConcreteAggregate : Aggregate&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;//对象空间中的集合&lt;br/&gt;private IList&amp;lt;object&amp;gt; items = new List&amp;lt;object&amp;gt;();&lt;br/&gt;public override Iterator CreateIterator()&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;//同样，生成的对象也存了宿主对象，即在ConcreteIterator这个对象中也可以访问到宿主对象&lt;br/&gt;return new ConcreteIterator(this);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public int Count&lt;br/&gt;{&lt;br/&gt;get { return items.Count; }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//索引的方式操作对象中的集合&lt;/p&gt;
&lt;p&gt;public object this[int index]&lt;br/&gt;{&lt;br/&gt;get { return items[index]; }&lt;br/&gt;set { items.Insert(index, value); }&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//迭代器抽象对象的约束&lt;/p&gt;
&lt;p&gt;abstract class Iterator&lt;br/&gt;{&lt;br/&gt;public abstract object First();&lt;br/&gt;public abstract object Next();&lt;br/&gt;public abstract bool IsDone();&lt;br/&gt;public abstract object CurrentItem();&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;//具体的迭代器对象&lt;/p&gt;
&lt;p&gt;class ConcreteIterator : Iterator&lt;br/&gt;{&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;private ConcreteAggregate aggregate;&lt;br/&gt;private int current = 0;&lt;/p&gt;
&lt;p&gt;//存了宿主对象的引用，可以访问到宿主对象&lt;/p&gt;
&lt;p&gt;public ConcreteIterator(ConcreteAggregate aggregate)&lt;br/&gt;{&lt;br/&gt;this.aggregate = aggregate;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//都是访问宿主对象&lt;/p&gt;
&lt;p&gt;public override object First()&lt;br/&gt;{&lt;br/&gt;return aggregate[0];&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public override object Next()&lt;br/&gt;{&lt;br/&gt;object ret = null;&lt;br/&gt;current++;&lt;/p&gt;
&lt;p&gt;if (current &amp;lt; aggregate.Count)&lt;br/&gt;{&lt;br/&gt;ret = aggregate[current];&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;return ret;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public override object CurrentItem()&lt;br/&gt;{&lt;br/&gt;return aggregate[current];&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;public override bool IsDone()&lt;br/&gt;{&lt;br/&gt;return current &amp;gt;= aggregate.Count ? true : false;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;//集合对象，还可以这样写&lt;/p&gt;
&lt;p&gt;//Aggregate a = new ConcreteAggregate();&lt;/p&gt;

&lt;p&gt;ConcreteAggregate a = new ConcreteAggregate();&lt;/p&gt;
&lt;p&gt;a[0] = &quot;大鸟&quot;;&lt;br/&gt;a[1] = &quot;小菜&quot;;&lt;br/&gt;a[2] = &quot;行李&quot;;&lt;br/&gt;a[3] = &quot;老外&quot;;&lt;br/&gt;a[4] = &quot;公交内部员工&quot;;&lt;br/&gt;a[5] = &quot;小偷&quot;;&lt;/p&gt;
&lt;p&gt;//这个地方也可以这样写&lt;/p&gt;
&lt;p&gt;//Iterator i = a.CreateIterator();&lt;/p&gt;
&lt;p&gt;Iterator i = new ConcreteIterator(a);&lt;/p&gt;&lt;p&gt;object item = i.First();&lt;br/&gt;while (!i.IsDone())&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;{0} 请买车票!&quot;, i.CurrentItem());&lt;br/&gt;i.Next();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;总结：不要看设计模式，要看思想，这个迭代器模式的思想就是宿主可以访问其中对象，其中对象也可以访问宿主。&lt;/p&gt;
&lt;p&gt;最近比较忙，这篇写了好几天，程序员最重要的就是工作态度，工作习惯，工作经验，编程思想。&lt;/p&gt;
&lt;p&gt;玩面向对象都是在玩引用的，因为通过引用可以让所关联的对象互相访问。&lt;/p&gt;
&lt;p&gt;不说了，大家努力吧，我后天订婚。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 13:51:00 +0000</pubDate>
<dc:creator>Wang_Charle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-charle/p/9236127.html</dc:identifier>
</item>
<item>
<title>Node.js 开发 Alfred workflow 初体验 - 韩子迟</title>
<link>http://www.cnblogs.com/zichi/p/9234866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/9234866.html</guid>
<description>&lt;p&gt;本文简单记录下如何用 Node.js 开发一个 Alfred workflow 的过程。&lt;/p&gt;
&lt;p&gt;之前开发过自己用的小工具，这次打算开发 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;CDNSearcher&lt;/a&gt;，用了半天才回忆起来开发流程，我在想如果之前简单记录了下，或许这次就不用花那么长时间回顾了，遂写此文。&lt;/p&gt;
&lt;p&gt;该 workflow 使用方式如下：（使用请点击 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;这里&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170816949-1253305290.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 Alfred 以及 Alfred workflow 的使用，这里不赘述，推荐看下这篇 &lt;a href=&quot;http://louiszhai.github.io/2018/05/31/alfred/&quot;&gt;Alfred 神器使用手册&lt;/a&gt;，很详细，里面涉及了一些我常用的功能。&lt;/p&gt;
&lt;p&gt;个人理解，workflow 是一种简单的 in-out 的形式，简化了中间过程重复的操作，能极大提高效率。&lt;strong&gt;许多 chrome 扩展以及命令行工具都可以做成 Alfred workflow 的形式&lt;/strong&gt;，使之更加通用（很常见的比如 chrome 翻译扩展，图床工具 等等，可以自己脑洞大开）。&lt;/p&gt;
&lt;p&gt;接着我们一步步来开发 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;CDNSearcher&lt;/a&gt; 这个 workflow。&lt;/p&gt;
&lt;p&gt;首先打开 [Alfred Preferences]，在左上角选择 [Workflows] 这个 tab。然后点击左下角的 [+]，选择 [Blank Workflow]，会出现如下一个弹窗，填写一些关于这个 workflow 的信息。这里注意下 [Bundle Id] 这个 key，这是代表 workflow 的唯一指定 id，需要填写一个唯一的字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627165820225-1497275242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着左侧的列表便会出现这个新建的 workflow，右键 -&amp;gt; Open In Finder，便可以看到这个 workflow 文件。此时只有一个 info.plist 文件，暂时不用关注它，&lt;strong&gt;也无需编辑它&lt;/strong&gt;，之后在 Alfred 中每一次图形化操作的过程中都会自动更新这个文件。&lt;/p&gt;
&lt;p&gt;我们直接看这个编辑好的流程图，操作非常简单，直接右键添加，并且可以自己拖拽，形象地演示了这个 workflow 的步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627203155624-2049854308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看最左上角的这个，这是一个 [Script Filter]。常见的 workflow，需要自己输入关键字，脚本执行后出现列表，基本都是 [Script Filter] 了。双击打开它，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170134324-1928494735.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾一下使用这个 workflow 的步骤，比如要搜索 vue 相关的 cdn，呼出 Alfred 后键入 &lt;code&gt;cdn vue&lt;/code&gt;，然后会出现列表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170226448-1937052419.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入的 &lt;code&gt;vue&lt;/code&gt;，其实就是 &lt;code&gt;{query}&lt;/code&gt;，然后会自动执行这行命令 &lt;code&gt;/usr/local/bin/node index.js &quot;{query}&quot;&lt;/code&gt;，&lt;code&gt;{query}&lt;/code&gt; 会自动被自己输入的字符串代替，这里就很熟悉了吧，执行一个 node 脚本，这个脚本非常简单，无非就是做一个 HTTP 请求，分析并得到一些数据。&lt;/p&gt;
&lt;p&gt;如何展示这些数据？如果用的是 js，&lt;strong&gt;代码中 &lt;code&gt;console.log()&lt;/code&gt; 的数据便会展示在 Alfred 前台&lt;/strong&gt;。具体看 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher/blob/master/index.js&quot;&gt;这个文件&lt;/a&gt;（&lt;strong&gt;所以用 js 开发的时候，debug 不能用 console.log，可以用 console.warn 等代替&lt;/strong&gt;）。最终的展示是一个数组，每个元素是一个对象，可以包括如下几个 key：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;title&lt;/li&gt;
&lt;li&gt;subtitle&lt;/li&gt;
&lt;li&gt;icon&lt;/li&gt;
&lt;li&gt;arg&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意一下 arg，按回车后，Alfred 会把这个变量传递给下一个步骤（比如进入粘贴板，或者在浏览器打开，或者继续传入下一个脚本去执行，等等）&lt;/p&gt;
&lt;p&gt;我们试了几次，可能会发现 query 的内容还没输入完，就已经显示结果了（即内容还没输入完，脚本就在执行了），我们希望 query 输入完整后再执行脚本，有点类似 js 中的函数节流去抖的意思。单击 [Run Behaviour] 进行调整即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170258432-1780321871.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们已经完成了第一步，我们需要完成第二步。还是以上面的 &lt;code&gt;cdn vue&lt;/code&gt; 为例，这个列表中，我选择了 vuex，是如何得到以下结果的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627171407144-688313078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这还是一个 [Script Filter]，只不过它的 &lt;code&gt;{query}&lt;/code&gt; 就是上个步骤的执行结果，而且不需要 [Keyword] 了。&lt;/p&gt;
&lt;p&gt;大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627205304537-850993307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分代码 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher/blob/master/detail.js&quot;&gt;在这里&lt;/a&gt;。最后在流程图上加上 [Copy to Clipboard]，enter 后便会复制到粘贴板。&lt;/p&gt;
&lt;p&gt;在实际开发的过程中，我希望 enter 后复制 CDN 的链接，cmd+enter 能够在浏览器中打开该 CDN 文件。因为这两步的内容是不一样的，所以需要分两步走。在第二个 [Script Filter] 中，我们可以得到 CDN 的链接，但是如果要引用，我希望能加上 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签，这里我又用了一个 [Run Script]，继续拼接字符串，因为这个代码比较简单，所以直接用了 Alfred 提供的选项 &lt;code&gt;/usr/bin/osascript(JS)&lt;/code&gt;：（提醒下，我先用了 ES6 的模版字符串，报错了 ...）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627204251775-42665136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又出现了问题，[Run Script] 后返回的字符串，会自动多加一个回车，搜索引擎是个好东西，[Utilities → Transform → Trim Whitespace] 完美解决，详见 &lt;a href=&quot;https://www.alfredforum.com/topic/10098-newline-n-added-when-var-will-be-set/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外一条流程主要是为了删除文件缓存，就不需要 [Script Filter] 了，直接在命令行执行就 ok 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170338947-489223117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170347709-1203455930.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这个简单的 workflow 算是完工了。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 13:34:00 +0000</pubDate>
<dc:creator>韩子迟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/9234866.html</dc:identifier>
</item>
<item>
<title>翻译 | 浅析算法复杂度分析 - 信号君</title>
<link>http://www.cnblogs.com/ncdxlxk/p/9235971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ncdxlxk/p/9235971.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205426409-584841445.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;322&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原文：A Gentle Introduction to Algorithm Complexity Analysis—— By Dionyziz.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如今，很多编程人员都在制作一些最酷、最实用的软件，比如我们在互联网上看到的或者每天使用的很多东西。尽管他们很多都没有计算机科学理论的背景，他们仍然是非常棒的、有创意的程序员，感谢他们所做的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管如此，计算机科学理论依然有它的用途和应用，且被证明是相当实用的。在本文中，针对那些了解编程艺术但是没有任何计算机科学理论背景的程序员，我将介绍计算机科学最实用的工具之一——大写O符号和算法复杂度分析。作为在计算机科学学术界工作过，并在工业界搭建产品级软件的人，这是我在实践中发现的真正有用的工具之一，所以我希望在阅读本文后，您可以将其应用于自己的代码中，以使其更好。读完本文，您可以理解计算机科学家使用的所有常见术语，如“大写O”、“渐近行为”和“最坏情况分析”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——略去部分——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;许多行业程序员和初级学生都难以理解大写O符号和算法复杂度分析，他们为此感到恐惧并且尽量避免接触。但是，这些并不像看起来那么难以理解或理论化。算法复杂度只是一种正式测量程序或算法运行速度的方法，它确实非常实用。我们来简单介绍一下这个话题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，有一些称为分析器（profiler）的程序，以毫秒为单位来测量运行时间，协助我们发现运行瓶颈来优化代码。虽然这是一个有用的工具，但它与算法复杂度无关。&lt;span&gt;算法复杂度是为了在理念层面上比较两种算法而设计的——忽略低级细节&lt;/span&gt;（如实现所用编程语言、运行算法的硬件或者给定的CPU指令集）。我们想仅依据算法本身的内容来比较算法：关于某物如何计算的理念，而统计毫秒数对此没有帮助。使用低级编程语言（如汇编）编写的差算法很可能比使用高级编程语言（如Python或Ruby）编写的好算法快得多。所以，现在是时候确定一个“更好的算法”是什么了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;算法是只执行计算的程序，而不是计算机经常执行的其它任务如网络任务或用户输入和输出。&lt;/span&gt;复杂度分析使得我们能够衡量程序在计算时到底有多快。纯粹计算的例子有包括数值浮点运算（如加法和乘法）；在一个数据库内搜索一个给定值；确定人工智能角色在视频游戏中将要经历的路径，以便他们只需要在虚拟世界内走一小段距离（见图1）；或者在字符串上运行正则表达式进行模式匹配。显然，计算在计算机程序中无处不在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205511853-985840684.jpg&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;330&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1 视频游戏中人工智能使用算法来躲避虚拟世界的障碍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;复杂度分析也是一个工具，可以让我们了解一个算法如何随着输入变大而变化。如果我们给它一个不同的输入，算法将如何表现？&lt;/span&gt;如果我们的算法需要1秒钟能运行1000个输入，那么如果我将输入大小加倍，它将会如何工作？它的运行速度是快一倍，还是慢四倍？在实际编程中，这非常重要，因为它使我们能够预测当输入数据变大时我们的算法将如何表现。例如，如果我们做了一个适用于1000个用户的Web应用程序，并测量其运行时间，使用算法复杂度分析，我们就可以很好地了解一旦拥有2000个用户，程序会发生什么。对于算法竞赛，复杂度分析让我们了解运行测试程序正确性的最大测试用例时，我们的代码将运行多长时间。所以如果我们测试了程序在小输入量时的行为，就可以很好地了解它是如何处理更大的输入的。我们从一个简单的例子开始：查找数组中的最大元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;统计指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这篇文章中，我将使用各种编程语言来举例。如果您不知道某种特定的编程语言，请不要失望，因为既然你懂编程，即使是你不熟悉的编程语言，你也应该可以毫无问题地阅读这些例子，因为它们很简单，我不会使用任何深奥的语言特性。如果你是一个参加算法比赛的学生，你很可能使用C++，所以你应该没有问题。对于这个例子，我建议使用C++进行练习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组中的最大元素可以用一段简单的代码来查找，比如这段JavaScript代码。给定一个大小为n的输入数组A：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;var M = A[ 0 ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( var i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( A[ i ] &amp;gt;= M ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;现在，要做的第一件事是计算这段代码执行多少个基本指令，这对进一步解释我们的理论并没有太大必要，这里只做一次，所以在我分析时请多一点耐心。分析这段代码时，我们想把它分解成简单的指令，那些CPU可以直接执行或者是接近底层的东西。假设处理器可以执行下面的操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设分支（在if条件被判定后if...else之间的代码部分）立即发生并且不计入这些指令。在上面的代码中，第一行代码是：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;var M = A[ 0 ];&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这需要2条指令：一条用于读取A[0]；一条用于给M赋值（假定n至少为1），无论n的值如何，这两条指令都是算法需要的。for循环初始化代码也必须始终运行，这带来了两条指令：一条赋值指令和一条比较指令：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;i = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i &amp;lt; n;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这些将在for循环第一次迭代前运行，开始循环迭代后，我们需要运行另两条指令：i自增1和一条比较指令，用于检查是否保持循环：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;++i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i &amp;lt; n;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;所以，如果忽略循环体，这个算法需要的指令数是4 + 2n。也就是说，for循环开始处有4条指令，在n次迭代中，每次迭代结束时有2条指令。我们现在可以定义一个数学函数f（n），给定一个n时，就能知道算法需要的指令数量。对于一个空循环体，有f（n）= 4 + 2n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最坏情况分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，来看循环体：数组查找和比较必不可少：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;if ( A[ i ] &amp;gt;= M ) { ...&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里有两条指令。但是if代码体可能运行，也可能不运行，这取决于数组的值究竟是什么。如果恰好是A [i]&amp;gt; = M，那么将运行这两条额外的指令——一条数组读取和一条赋值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;但是现在要定义f（n）并不容易，因为指令数量并不仅仅依赖于n，而且还取决于我们的输入。例如，对于A = [1,2,3,4]，算法将比A = [4,3,2,1]需要更多的指令。在分析算法时，我们经常考虑最坏的情况：什么是算法可能发生的最糟糕的情况？算法在什么情况下需要最多的指令来完成？在这个例子中，最坏情况就是当我们有一个按升序排列的数组时，例如A = [1,2,3,4]。在这种情况下，M需要每一次都被替换，因此产生最多的指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机科学家为此赋予一个奇特的名字，他们称之为最坏情况分析，无论如何情况都不会比这更坏的了！因此，在最坏的情况下，我们有4条指令在for循环体内运行，所以我们有f（n）= 4 + 2n + 4n = 6n + 4。函数f在给定一个问题的大小n时，能指示我们最坏情况下需要多少条指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;渐近行为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定f这样一个函数，使我们对算法运行有多快有了很好的概念。但是，正如我前面所说，我们不需要经历繁琐的计算指令的过程。此外，每个编程语言语句所需的实际CPU指令的数量取决于编译器和可用的CPU指令集（例如，您的PC上的处理器是AMD还是Intel Pentium，或者您的PS2上是MIPS处理器），我们希望忽略这些因素。现在通过一个“过滤器”来简化“f”函数，这将帮助我们摆脱那些计算机科学家们不愿意忽略的细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在函数6n + 4中，有两个因素项：6n和4。在复杂度分析中，我们只关心随着程序输入（n）的增长，指令计数函数将发生了什么。&lt;span&gt;这同上面“最坏情况分析”的思想一致：我们感兴趣的是算法如何面对坏的情况，它何时会遇到具有挑战性的艰难任务。&lt;/span&gt;请注意，这对比较算法非常有用！如果一个算法在大量输入上击败另一个算法，那么当给定一个更简单，更小的输入时，它也很可能是更快的。从正在考虑的条件来看，我们将丢弃所有增长缓慢的因素，只保留随着n变大而快速增长的因素。显然，随着n的增大，4仍然是4，但6n越来越大，它对于更大的输入问题越来越重要。因此，我们要做的第一件事就是丢弃4，并使函数f（n）= 6n。试想，4只是一个“初始化常量”， 不同的编程语言可能需要不同的时间来设置（例如，Java需要一些时间来初始化其虚拟机），忽略这个值使得我们不用考虑编程语言的差异，这是有意义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将忽略的第二件事是n前面的常系数，如此一来函数将变成f（n）= n。正如你所看到的，这可以使事情变得非常简单。同样，&lt;span&gt;如果考虑到不同语言是如何被编译的，那么放弃这个乘法常量是有意义的。&lt;/span&gt;“数组访问”语句会在不同的编程语言下被编译成不同的指令，例如，在C中，做A[i]不包括检查i是否符合数组大小，而在Pascal中却需要这么做。下面是Pascal代码：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;M := A[ i ]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;其等价于C中的&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;if ( i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; n ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;因此，我们需要考虑到对于不同的编程语言来说，在统计指令时将会有不一样的结果。 在上面的例子中，Pascal使用了一个更“笨”的编译器，它忽略了可能的优化。Pascal需要3条指令来访问每个数组元素，而C只需要一条。&lt;span&gt;忽略常系数是忽略特定的编程语言和编译器之间的差异，将分析重点放在算法本身的思想上来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上所述的“忽略常系数”和“保留关键影响因子”的过滤器就是我们所说的渐近行为。所以f（n）= 2n + 8的渐近行为由函数f（n）= n描述。从数学上讲，渐进行为所说的是n趋于无穷大时，我们对函数f的极限感兴趣。但是如果你不明白这个词的正式含义，别担心，因为这些就是你所需要知道的（在严谨的数学问题中，我们不能将常量从极限内移除，但出于计算机科学的目的，我们需要这样做）。看几个例子来熟悉这个概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们通过忽略常系数和保留增长最快的因素项来找到以下示例函数的渐近行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. f(n) = 5n + 12 得到 f(n) = n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于以上分析的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. f(n) = 109 得到 f(n) = 1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;忽略乘数109 * 1，但依然需要放置1在这里，以表明函数不是一个非零值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. f(n) = n^2 + 3n + 112 得到 f(n) = n2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里, n^2 比 3n 随n增长的快，因此保留它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. f(n) = n^3 + 1999n + 1337 得到 f(n) = n^3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然前面有一个很大的常系数，但我们依然可以找到一个n使得 n^3 比 1999n大。由于我们只关心n为非常大的数时候后的情况，因此只保留n^3(如图 2)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. f(n) = n + sqrt(n) 得到 f(n) = n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于n增长的比sqrt(n)快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205637603-854302283.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 蓝色绘制的n^3函数在n = 45之后比红色绘制的1999n函数大，之后一直保持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这告诉我们的是，通过忽略所有这些修饰的常量，很容易就判断出程序的指令计数函数的渐近行为。实际上，没有任何循环的程序都会有f（n）= 1，因为它需要的指令数量只是一个常量（除非它使用递归；见下文）。任何具有从1到n的单循环程序都将有f（n）= n，因为它在循环之前执行恒定数量的指令，在循环之后执行恒定数量的指令，并在n次循环中每次运行恒定数量指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在应该比计算独立的指令容易得多，也不那么繁琐，让我们来看几个例子来熟悉它。下面的PHP程序检查一个大小为n的数组A中是否存在一个特定的值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;?php&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$exists = false;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( $i = 0; $i &amp;lt; n; ++$i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( $A[ $i ] == $value ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        $exists = true;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这种在数组内搜索值的方法称为线性搜索，因为这个程序的f（n）= n，所以这么说很合理（我们将在下一节中准确定义“线性”的含义）。您可能会注意到，这里有一个“break”语句，即使只迭代了一次，程序也可能会突然终止。但是请记住，我们对最坏的情况感兴趣，对于这个程序来说，最坏情况就是数组A不包含这个值。所以我们仍然有f（n）= n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下的C++程序检查一个大小为n的向量A是否包含相同的两个值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;bool duplicate = false;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( int i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for ( int j = 0; j &amp;lt; n; ++j ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if ( i != j &amp;amp;&amp;amp; A[ i ] == A[ j ] )  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            duplicate = true;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( duplicate )  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;因为这里有两个嵌套的循环，我们将其渐进行为描述为为f（n）= n^2。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：简单的程序可以通过计算程序的嵌套循环来分析。n次的单层循环得到f（n）= n。双层嵌套循环得到f（n）= n^2。三层嵌套循环得到f（n）= n^3。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果我们有一个在循环中调用函数的程序，并且知道被调用函数执行的指令的数量，则很容易确定整个程序的指令数量。我们来看看这个C例子：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;int i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    f( n );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果我们知道f（n）是一个正好执行n个指令的函数，那么我们就可以知道整个程序的指令数量是渐近n^2的，因为这个函数正好被调用n次。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：给定一系列顺序执行的for循环，其中最慢的循环决定程序的渐近行为。两个嵌套循环后跟一个单层循环，其渐进行为与仅有嵌套循环时相同，因为嵌套循环支配简单循环。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;现在，让我们切换到计算机科学家使用的奇特符号。当找出了这样的渐进函数f，我们可以说程序是Θ（f（n））的,Θ（n）读作“theta of n”。有时候我们说包含常量的指令计数原始函数f（n）是Θ（某物）,例如，可以说f（n）= 2n是Θ（n），也可以写成2n∈Θ（n）。这里没有什么新的东西，不要对这个表示法感到困惑，所有的意思是：如果我们已经计算出一个程序需要的指令的数量为2n，通过忽略常量，那么这个算法的渐近行为就用n来描述。 解释了这种表示法，下面是一些真正的数学表述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n^6 + 3n ∈ Θ( n^6 )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2n + 12 ∈ Θ( 2n )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3n + 2n ∈ Θ( 3n )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n^n + n ∈ Θ( n^n )&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：具有较大Θ的程序比具有较小Θ的程序运行得慢。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大O符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别是对于更复杂的例子，有时候我们很难正确地指出算法的行为，但是，我们可以知道算法的行为将永远不会超过一定的界限。这将使生活变得更加简单，因为不需要确切地指出算法的运行速度，我们所要做的就是找到一定的界限。这个例子很容易解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序问题是计算机科学家用于算法教学的著名问题。在排序问题中，给出一个大小为n的数组A（听起来很熟悉？），要求编写程序对这个数组排序。这个问题很有趣，因为这是现实系统中的一个实际问题。例如，文件资源管理器需要按名称对其显示的文件进行排序，以便用户可以轻松地导航它们。或者另一个例子，视频游戏可能需要根据玩家眼睛在虚拟世界中的距离，来分类显示虚拟世界中的3D对象，以便确定哪些是可见的，哪些是不可见的，称为可见性问题（见图3）。最接近玩家的物体是那些可见的，而那些更远的物体可能被它们前面的物体隐藏起来。排序也很有趣，因为有很多算法可以解决这个问题，且有优劣之分，它同时也是易于定义和解释的简单问题。就让我们来编写一个排序数组的代码吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205724100-987557997.jpg&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;378&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 位于黄点的玩家不会看到阴影区域。 把世界分成小片段，按距离排列，是解决可见性问题的一种方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个在Ruby中实现数组排序的低效方法（当然，Ruby支持使用你使用恰当的内置函数对数组进行排序，而这些函数肯定比我们在这里看到的要快，但这里仅仅是为了说明目的而设）。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;b = []&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n.times do&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    m = a[ 0 ]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    mi = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a.each_with_index do |element, i|&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if element &amp;lt; m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            m = element&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            mi = i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a.delete_at( mi )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b &amp;lt;&amp;lt; m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这种方法被称为选择排序。它找出数组的最小值（数组表示为a，而最小值表示为m，mi是它的索引），将它放在新数组的末尾（例中的b），并将其从原始数组删除。然后接着找到原始数组剩余值之间的最小值，将其添加到新数组中，并将其从原始数组中删除，现在新数组已经有两个元素。它继续这个过程，直到所有的元素都被从原始数组中删除，并且被插入到新的数组中，这意味着数组已经被排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个例子中，我们可以看到我们有两个嵌套循环。外循环运行n次，内循环为数组a的每个元素运行一次。虽然数组a最初有n个元素，但在每次迭代中删除一个数组元素。因此，内循环在外循环的第一次迭代期间重复n次，然后是n-1次，然后是n-2次……，直到外循环的最后一次迭代为止，在该迭代期间它只运行一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;评估这个程序的复杂度有点困难，因为必须计算1 + 2 + ... +（n-1）+ n的总和，但我们一定能确定一个“上限”。因此，我们可以改变程序（你可以用你的想法代替实际写代码来这么做），使它变得更糟，然后找到新程序的复杂度。如果能够找到构建的更糟糕的程序的复杂度，就能知道原来的程序是最坏的，或者是更好的。 如果我们发现改造的程序复杂度很好，但却比我们原来的程序更糟糕，那么可以知道原来的程序也具有相当不错的复杂度——与改造的程序一样好或是更好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在让我们想想编辑这个示例程序的方法，以便更容易地找出它的复杂度。但请记住，只能让它变得更糟，也即多消耗一些指令，使得估计对我们原来的计划是有意义的。显然，我们可以使程序的内部循环总是重复n次，而不是可变的次数。其中一些重复将是无用的，但它将帮助我们分析所得算法的复杂度。如果这样做，新构造的算法复杂度显然是Θ（n^2），因为有两个嵌套的循环，每个循环重复n次。像这样，我们说原来的算法复杂度是O（n^2）。O（n^2）意思是我们的程序渐近地不比n^2差,甚至可能比这更好，也可能一样好。顺便说一下，如果程序确实是Θ（n^2），我们仍然可以说它是O（n^2）。为了帮助你认识到这一点，设想改变并没有使原来程序的方式有太大变化，但是还是会使程序变得更糟，比如在程序开始的时候增加一个无意义的指令。这样做会为指令的统计结果引来一个常量，并在描述渐近行为时将它忽略。&lt;span&gt;所以一个Θ（n^2）的程序也是O（n^2）的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是一个O（n^2）的程序可能不是Θ（n^2）。&lt;/span&gt;例如，除了可以为O（n）之外，任何Θ（n）的程序也是O（n^2）的。我们试想一个Θ（n）程序是一个重复n次的简单循环，我们可以通过将它装进另一个重复n次的循环中而使其变得更糟，从而产生具有f（n）=n^2的程序。概括来说，当b比a更差时，任何Θ（a）的程序都是O（b）的。请注意，我们对程序的修改并不需要具有实际上的意义或是等同于我们原来的程序。对于给定的n，它只需要比原始程序具有更多的指令，我们仅用它来影响指令的统计，而不是解决实际的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，说程序是O（n^2）是没问题的：我们已经分析了我们的算法，发现它永远不会比n^2差，但实际上可能达到n^2，这让我们可以很好的估计程序运行速度。让我们通过几个例子来帮助你熟悉这个新的符号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——略去练习题部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Cormen, Leiserson, Rivest, Stein. Introduction to Algorithms, MIT Press.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Dasgupta, Papadimitriou, Vazirani. Algorithms, McGraw-Hill Press.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Fotakis. Course of Discrete Mathematics at the National Technical University of Athens.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Fotakis. Course of Algorithms and Complexity at the National Technical University of Athens.&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想进一步跟踪本博客动态，欢迎关注我的个人微信订阅号：&lt;strong&gt;信号君&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;信号君：寻求简单之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术成长 | 读书笔记 | 认知升级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180624104439302-493786623.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫描二维码关注信号君&lt;/p&gt;


</description>
<pubDate>Wed, 27 Jun 2018 13:03:00 +0000</pubDate>
<dc:creator>信号君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ncdxlxk/p/9235971.html</dc:identifier>
</item>
<item>
<title>记录一次批量插入的优化历程 - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9233427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9233427.html</guid>
<description>&lt;pre&gt;
String sql = &quot;INSERT INTO &quot; +
        &quot; yy_marketing_coupon(uuid,no,name,type,money,status,instruction,astrict,total_number,&quot; +
        &quot;remain_number,send_mode,get_mode,use_mode,user_rank_lower,send_start_time,send_end_time,&quot; +
        &quot;use_start_time,use_end_time,use_expire_time,discount,user_mobiles,create_time,creater,&quot; +
        &quot;update_time,updater,appid,use_car_type,highest_money,term_type,coupon_template_uuid,gift_uuid,&quot; +
        &quot;city_uuids,city_names) &quot; +
        &quot; values (?,(select FN_CREATE_COUPON_NO(1)),?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;&lt;span&gt;;
List&lt;/span&gt;&amp;lt;Object[]&amp;gt; batchArgs = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; marketingCouponListDo.size();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;) {
    MarketingCouponDto dto &lt;/span&gt;=&lt;span&gt; marketingCouponListDo.get(i);
    Object[] objects &lt;/span&gt;=&lt;span&gt; {
            dto.getUuid(),
            dto.getName(),
            dto.getType(),
            dto.getMoney(),
            dto.getStatus(),
            dto.getInstruction(),
            dto.getAstrict(),
            dto.getTotalNumber(),
            dto.getRemainNumber(),
            dto.getSendMode(),
            dto.getGetMode(),
            dto.getUseMode(),
            dto.getUserRankLower(),
            dto.getSendStartTime(),
            dto.getSendEndTime(),
            dto.getUseStartTime(),
            dto.getUseEndTime(),
            dto.getUseExpireTime(),
            dto.getDiscount(),
            dto.getUserMobiles(),
            dto.getCreateTime(),
            dto.getCreater(),
            dto.getUpdateTime(),
            dto.getUpdater(),
            dto.getAppid(),
            dto.getUseCarType(),
            dto.getHighestMoney(),
            dto.getTermType(),
            dto.getCouponTemplateUuid(),
            dto.getGiftUuid(),
            dto.getCityUuids(),
            dto.getCityNames()
    };
    batchArgs.add(objects);
}
jdbcTemplate.batchUpdate(sql, batchArgs);&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Jun 2018 12:16:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9233427.html</dc:identifier>
</item>
</channel>
</rss>