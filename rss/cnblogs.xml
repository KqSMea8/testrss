<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DirectX11 With Windows SDK--23 立方体映射：动态天空盒的实现 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9900694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9900694.html</guid>
<description>&lt;p&gt;上一章的静态天空盒已经可以满足绝大部分日常使用了。但对于自带反射/折射属性的物体来说，它需要依赖天空盒进行绘制，但静态天空盒并不会记录周边的物体，更不用说正在其周围运动的物体了。因此我们需要在运行期间构建动态天空盒，将周边物体绘制入当前的动态天空盒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没了解过静态天空盒的读者请先移步到下面的链接&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在如果我们要让拥有反射/折射属性的物体映射其周围的物体和天空盒的话，就需要在每一帧重建动态天空盒，具体做法为：在每一帧将摄像机放置在待反射/折射物体中心，然后沿着各个坐标轴渲染除了自己以外的所有物体及静态天空盒共六次，一次对应纹理立方体的一个面。这样绘制好的动态天空盒就会记录下当前帧各物体所在的位置了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201811/1172605-20181103143339900-94512119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这样做会带来非常大的性能开销，加上动态天空盒后，现在一个场景就要渲染七次，对应七个不同的渲染目标！如果要使用的话，尽可能减少所需要用到的动态天空盒数目。对于多个物体来说，你可以只对比较重要，关注度较高的反射/折射物体使用动态天空盒，其余的仍使用静态天空盒，甚至不用。毕竟动态天空盒也不是用在场景绘制，而是在物体上，可以不需要跟静态天空盒那样大的分辨率，通常情况下设置到256x256即可.&lt;/p&gt;
&lt;h2 id=&quot;资源视图resource-views回顾&quot;&gt;资源视图(Resource Views)回顾&lt;/h2&gt;
&lt;p&gt;由于动态天空盒的实现同时要用到&lt;strong&gt;渲染目标视图(Render Target View)&lt;/strong&gt;、&lt;strong&gt;深度模板视图(Depth Stencil View)&lt;/strong&gt;和&lt;strong&gt;着色器资源视图(Shader Resource View)&lt;/strong&gt;，这里再进行一次回顾。&lt;/p&gt;
&lt;p&gt;由于资源(&lt;code&gt;ID3D11Resource&lt;/code&gt;)本身的类型十分复杂，比如一个&lt;code&gt;ID3D11Texture2D&lt;/code&gt;本身既可以是一个纹理，也可以是一个纹理数组，但纹理数组在元素个数为6时有可能会被用作立方体纹理，就这样直接绑定到渲染管线上是无法确定它本身究竟要被用作什么样的类型的。比如说作为着色器资源，它可以是&lt;code&gt;Texture2D&lt;/code&gt;, &lt;code&gt;Texture2DArray&lt;/code&gt;, &lt;code&gt;TextureCube&lt;/code&gt;的任意一种。&lt;/p&gt;
&lt;p&gt;因此，我们需要用到一种叫资源视图(Resource Views)的类型，它主要有下面4种功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;绑定要使用的资源&lt;/li&gt;
&lt;li&gt;解释该资源具体会被用作什么类型&lt;/li&gt;
&lt;li&gt;指定该资源的元素范围，以及纹理的子资源范围&lt;/li&gt;
&lt;li&gt;说明该资源最终在渲染管线上的用途&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;渲染目标视图&lt;/strong&gt;用于将渲染管线的运行结果输出给其绑定的资源，即仅能设置给输出合并阶段。这意味着该资源主要用于写入，但是在进行混合操作时还需要读取该资源。通常渲染目标是一个二维的纹理，但它依旧可能会绑定其余类型的资源。这里不做讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度/模板视图&lt;/strong&gt;同样用于设置给输出合并阶段，但是它用于深度测试和模板测试，决定了当前像素是通过还是会被抛弃，并更新深度/模板值。它允许一个资源同时绑定到深度模板视图和着色器资源视图，但是两个资源视图此时都是只读的，深度/模板视图也无法对其进行修改，这样该纹理就还可以绑定到任意允许的可编程着色器阶段上。如果要允许深度/模板缓冲区进行写入，则应该取消绑定在着色器的资源视图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;着色器资源视图&lt;/strong&gt;提供了资源的读取权限，可以用于渲染管线的所有可编程着色器阶段中。通常该视图多用于像素着色器阶段，但要注意无法通过着色器写入该资源。&lt;/p&gt;
&lt;h2 id=&quot;dynamicskyrender类&quot;&gt;DynamicSkyRender类&lt;/h2&gt;
&lt;p&gt;该类继承自上一章的SkyRender类，用以支持动态天空盒的相关操作。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
class DynamicSkyRender : public SkyRender
{
public:
    DynamicSkyRender(ComPtr&amp;lt;ID3D11Device&amp;gt; device,
        ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext,
        const std::wstring&amp;amp; cubemapFilename,
        float skySphereRadius,      // 天空球半径
        int dynamicCubeSize,        // 立方体棱长
        bool generateMips = false); // 默认不为静态天空盒生成mipmaps
                                    // 动态天空盒必然生成mipmaps

    DynamicSkyRender(ComPtr&amp;lt;ID3D11Device&amp;gt; device,
        ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext,
        const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; cubemapFilenames,
        float skySphereRadius,      // 天空球半径
        int dynamicCubeSize,        // 立方体棱长
        bool generateMips = false); // 默认不为静态天空盒生成mipmaps
                                    // 动态天空盒必然生成mipmaps


    // 缓存当前渲染目标视图
    void Cache(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect);

    // 指定天空盒某一面开始绘制，需要先调用Cache方法
    void BeginCapture(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect, D3D11_TEXTURECUBE_FACE face,
        const DirectX::XMFLOAT3&amp;amp; pos, float nearZ = 1e-3f, float farZ = 1e3f);

    // 恢复渲染目标视图及摄像机，并绑定当前动态天空盒
    void Restore(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect, const Camera&amp;amp; camera);

    // 获取动态天空盒
    // 注意：该方法只能在
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; GetDynamicTextureCube();

    // 获取当前用于捕获的天空盒
    const Camera&amp;amp; GetCamera() const;

private:
    void InitResource(ComPtr&amp;lt;ID3D11Device&amp;gt; device, int dynamicCubeSize);

private:
    ComPtr&amp;lt;ID3D11RenderTargetView&amp;gt;      mCacheRTV;      // 临时缓存的后备缓冲区
    ComPtr&amp;lt;ID3D11DepthStencilView&amp;gt;      mCacheDSV;      // 临时缓存的深度/模板缓冲区
    
    FirstPersonCamera                   mCamera;                // 捕获当前天空盒其中一面的摄像机
    ComPtr&amp;lt;ID3D11DepthStencilView&amp;gt;      mDynamicCubeMapDSV;     // 动态天空盒渲染对应的深度/模板视图
    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt;    mDynamicCubeMapSRV;     // 动态天空盒对应的着色器资源视图
    ComPtr&amp;lt;ID3D11RenderTargetView&amp;gt;      mDynamicCubeMapRTVs[6]; // 动态天空盒每个面对应的渲染目标视图
    
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造函数在完成静态天空盒的初始化后，就会调用&lt;code&gt;DynamicSkyRender::InitResource&lt;/code&gt;方法来初始化动态天空盒。&lt;/p&gt;
&lt;h2 id=&quot;render-to-texture-技术&quot;&gt;Render-To-Texture 技术&lt;/h2&gt;
&lt;p&gt;因为之前的个人教程把计算着色器给跳过了，&lt;code&gt;Render-To-Texture&lt;/code&gt;刚好又在龙书里的这章，只好把它带到这里来讲了。&lt;/p&gt;
&lt;p&gt;在我们之前的程序中，我们都是渲染到后备缓冲区里。经过了这么多的章节，应该可以知道它的类型是&lt;code&gt;ID3D11Texture2D&lt;/code&gt;，仅仅是一个2D纹理罢了。在&lt;code&gt;d3dApp&lt;/code&gt;类里可以看到这部分的代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 重设交换链并且重新创建渲染目标视图
ComPtr&amp;lt;ID3D11Texture2D&amp;gt; backBuffer;
HR(mSwapChain-&amp;gt;ResizeBuffers(1, mClientWidth, mClientHeight, DXGI_FORMAT_R8G8B8A8_UNORM, 0));   // 使用了Direcr2D交互时则为DXGI_FORMAT_B8G8R8A8_UNORM
HR(mSwapChain-&amp;gt;GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast&amp;lt;void**&amp;gt;(backBuffer.GetAddressOf())));
HR(md3dDevice-&amp;gt;CreateRenderTargetView(backBuffer.Get(), 0, mRenderTargetView.GetAddressOf()));
backBuffer.Reset();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里渲染目标视图绑定的是重新调整过大小的后备缓冲区。然后把该视图交给输出合并阶段：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 将渲染目标视图和深度/模板缓冲区结合到管线
md3dImmediateContext-&amp;gt;OMSetRenderTargets(1, mRenderTargetView.GetAddressOf(), mDepthStencilView.Get());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样经过一次绘制指令后就会将管线的运行结果输出到该视图绑定的后备缓冲区上，待所有绘制完成后，再调用&lt;code&gt;IDXGISwapChain::Present&lt;/code&gt;方法来交换前/后台以达到画面更新的效果。&lt;/p&gt;
&lt;p&gt;如果渲染目标视图绑定的是新建的2D纹理，而非后备缓冲区的话，那么渲染结果将会输出到该纹理上，并且不会直接在屏幕上显示出来。然后我们就可以使用该纹理做一些别的事情，比如绑定到着色器资源视图供可编程着色器使用，又或者将结果保存到文件等等。&lt;/p&gt;
&lt;p&gt;虽然这个技术并不高深，但它的应用非常广泛：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;小地图的实现&lt;/li&gt;
&lt;li&gt;阴影映射(Shadow mapping)&lt;/li&gt;
&lt;li&gt;屏幕空间环境光遮蔽(Screen Space Ambient Occlusion)&lt;/li&gt;
&lt;li&gt;利用天空盒实现动态反射/折射(Dynamic reflections/refractions with cube maps)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;dynamicskyrenderinitresource方法--初始化动态纹理立方体资源&quot;&gt;DynamicSkyRender::InitResource方法--初始化动态纹理立方体资源&lt;/h2&gt;
&lt;h3 id=&quot;创建动态纹理立方体和对应渲染目标视图着色器资源视图&quot;&gt;创建动态纹理立方体和对应渲染目标视图、着色器资源视图&lt;/h3&gt;
&lt;p&gt;在更新动态天空盒的时候，该纹理将会被用做渲染目标；而完成渲染后，它将用作着色器资源视图用于球体反射/折射的渲染。因此它需要在&lt;code&gt;BindFlag&lt;/code&gt;设置&lt;code&gt;D3D11_BIND_RENDER_TARGET&lt;/code&gt;和&lt;code&gt;D3D11_BIND_SHADER_RESOURCE&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
void DynamicSkyRender::InitResource(ComPtr&amp;lt;ID3D11Device&amp;gt; device, int dynamicCubeSize)
{
    //
    // 1. 创建纹理数组
    //

    ComPtr&amp;lt;ID3D11Texture2D&amp;gt; texCube;
    D3D11_TEXTURE2D_DESC texDesc;

    texDesc.Width = dynamicCubeSize;
    texDesc.Height = dynamicCubeSize;
    texDesc.MipLevels = 0;
    texDesc.ArraySize = 6;
    texDesc.SampleDesc.Count = 1;
    texDesc.SampleDesc.Quality = 0;
    texDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    texDesc.Usage = D3D11_USAGE_DEFAULT;
    texDesc.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;
    texDesc.CPUAccessFlags = 0;
    texDesc.MiscFlags = D3D11_RESOURCE_MISC_GENERATE_MIPS | D3D11_RESOURCE_MISC_TEXTURECUBE;
    
    // 现在texCube用于新建纹理
    HR(device-&amp;gt;CreateTexture2D(&amp;amp;texDesc, nullptr, texCube.ReleaseAndGetAddressOf()));

    // ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把&lt;code&gt;MipLevels&lt;/code&gt;设置为0是要说明该纹理将会在后面生成完整的mipmap链，但不代表创建纹理后立即就会生成，需要在后续通过&lt;code&gt;GenerateMips&lt;/code&gt;方法才会生成出来。为此，还需要在&lt;code&gt;MiscFlags&lt;/code&gt;设置&lt;code&gt;D3D11_RESOURCE_MISC_GENERATE_MIPS&lt;/code&gt;。当然，把该纹理用作天空盒的&lt;code&gt;D3D11_RESOURCE_MISC_TEXTURECUBE&lt;/code&gt;标签也不能漏掉。&lt;/p&gt;
&lt;p&gt;接下来就是创建渲染目标视图的部分，纹理数组中的每个纹理都需要绑定一个渲染目标视图:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    //
    // 2. 创建渲染目标视图
    //

    D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
    rtvDesc.Format = texDesc.Format;
    rtvDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DARRAY;
    rtvDesc.Texture2DArray.MipSlice = 0;
    // 一个视图只对应一个纹理数组元素
    rtvDesc.Texture2DArray.ArraySize = 1;

    // 每个元素创建一个渲染目标视图
    for (int i = 0; i &amp;lt; 6; ++i)
    {
        rtvDesc.Texture2DArray.FirstArraySlice = i;
        HR(device-&amp;gt;CreateRenderTargetView(
            texCube.Get(),
            &amp;amp;rtvDesc,
            mDynamicCubeMapRTVs[i].GetAddressOf()));
    }
    
    // ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是为整个纹理数组以天空盒的形式创建着色器资源视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    //
    // 3. 创建着色器目标视图
    //

    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    srvDesc.Format = texDesc.Format;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBE;
    srvDesc.TextureCube.MostDetailedMip = 0;
    srvDesc.TextureCube.MipLevels = -1;     // 使用所有的mip等级

    HR(device-&amp;gt;CreateShaderResourceView(
        texCube.Get(),
        &amp;amp;srvDesc,
        mDynamicCubeMapSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里还没有结束。&lt;/p&gt;
&lt;h3 id=&quot;为动态天空盒创建深度缓冲区和视口&quot;&gt;为动态天空盒创建深度缓冲区和视口&lt;/h3&gt;
&lt;p&gt;通常天空盒的面分辨率和后备缓冲区的分辨率不一致，这意味着我们还需要创建一个和天空盒表面分辨率一致的深度缓冲区(无模板测试)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    //
    // 4. 创建深度/模板缓冲区与对应的视图
    //

    texDesc.Width = dynamicCubeSize;
    texDesc.Height = dynamicCubeSize;
    texDesc.MipLevels = 0;
    texDesc.ArraySize = 1;
    texDesc.SampleDesc.Count = 1;
    texDesc.SampleDesc.Quality = 0;
    texDesc.Format = DXGI_FORMAT_D32_FLOAT;
    texDesc.Usage = D3D11_USAGE_DEFAULT;
    texDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
    texDesc.CPUAccessFlags = 0;
    texDesc.MiscFlags = 0;

    ComPtr&amp;lt;ID3D11Texture2D&amp;gt; depthTex;
    device-&amp;gt;CreateTexture2D(&amp;amp;texDesc, nullptr, depthTex.GetAddressOf());

    D3D11_DEPTH_STENCIL_VIEW_DESC dsvDesc;
    dsvDesc.Format = texDesc.Format;
    dsvDesc.Flags = 0;
    dsvDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
    dsvDesc.Texture2D.MipSlice = 0;

    HR(device-&amp;gt;CreateDepthStencilView(
        depthTex.Get(),
        &amp;amp;dsvDesc,
        mDynamicCubeMapDSV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，视口也需要经过适配。不过之前的摄像机类可以帮我们简化一下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    //
    // 5. 初始化视口
    //

    mCamera.SetViewPort(0.0f, 0.0f, static_cast&amp;lt;float&amp;gt;(dynamicCubeSize), static_cast&amp;lt;float&amp;gt;(dynamicCubeSize));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态天空盒的绘制&quot;&gt;动态天空盒的绘制&lt;/h2&gt;
&lt;p&gt;讲完了初始化的事，就要开始留意帧与帧之间的动态天空盒渲染操作了。除了绘制部分以外的操作都交给了&lt;code&gt;DynamicSkyRender&lt;/code&gt;类来完成。总结如下(粗体部分为该方法完成的任务)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存设备上下文绑定的后备缓冲区、深度/模板缓冲区&lt;/li&gt;
&lt;li&gt;清空设置在像素着色器的着色器资源视图(绑定了动态天空盒资源)&lt;/li&gt;
&lt;li&gt;对准某一个坐标轴，以90度垂直视野(FOV)，1.0f的宽高比架设摄像机，并调整视口&lt;/li&gt;
&lt;li&gt;清理当前天空盒面对应的纹理和深度缓冲区，并绑定到设备上下文&lt;/li&gt;
&lt;li&gt;和往常一样绘制物体和静态天空盒&lt;/li&gt;
&lt;li&gt;回到步骤3，继续下一个面的绘制，直到6个面都完成渲染&lt;/li&gt;
&lt;li&gt;为设备上下文恢复后备缓冲区、深度/模板缓冲区并释放内部缓存(防止交换链&lt;code&gt;ResizeBuffer&lt;/code&gt;时因为引用的遗留出现问题)&lt;/li&gt;
&lt;li&gt;让动态天空盒生成mipmap链，并将其绑定到着色器&lt;/li&gt;
&lt;li&gt;利用动态天空盒绘制反射/折射物体，绘制剩余物体，并用静态天空盒绘制天空&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;dynamicskyrendercache方法--缓存渲染目标视图&quot;&gt;DynamicSkyRender::Cache方法--缓存渲染目标视图&lt;/h3&gt;
&lt;p&gt;该方法对应上面所说的第1,2步：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void DynamicSkyRender::Cache(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect)
{
    deviceContext-&amp;gt;OMGetRenderTargets(1, mCacheRTV.GetAddressOf(), mCacheDSV.GetAddressOf());

    // 清掉绑定在着色器的动态天空盒，需要立即生效
    effect.SetTextureCube(nullptr);
    effect.Apply(deviceContext);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dynamicskyrenderbegincapture方法--指定天空盒某一面开始绘制&quot;&gt;DynamicSkyRender::BeginCapture方法--指定天空盒某一面开始绘制&lt;/h3&gt;
&lt;p&gt;该方法对应上面所说的第3,4步：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void DynamicSkyRender::BeginCapture(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect, D3D11_TEXTURECUBE_FACE face,
    const XMFLOAT3&amp;amp; pos, float nearZ, float farZ)
{
    static XMVECTORF32 ups[6] = {
        {{ 0.0f, 1.0f, 0.0f, 0.0f }},   // +X
        {{ 0.0f, 1.0f, 0.0f, 0.0f }},   // -X
        {{ 0.0f, 0.0f, -1.0f, 0.0f }},  // +Y
        {{ 0.0f, 0.0f, 1.0f, 0.0f }},   // -Y
        {{ 0.0f, 1.0f, 0.0f, 0.0f }},   // +Z
        {{ 0.0f, 1.0f, 0.0f, 0.0f }}    // -Z
    };

    static XMVECTORF32 looks[6] = {
        {{ 1.0f, 0.0f, 0.0f, 0.0f }},   // +X
        {{ -1.0f, 0.0f, 0.0f, 0.0f }},  // -X
        {{ 0.0f, 1.0f, 0.0f, 0.0f }},   // +Y
        {{ 0.0f, -1.0f, 0.0f, 0.0f }},  // -Y
        {{ 0.0f, 0.0f, 1.0f, 0.0f }},   // +Z
        {{ 0.0f, 0.0f, -1.0f, 0.0f }},  // -Z
    };
    
    // 设置天空盒摄像机
    mCamera.LookTo(XMLoadFloat3(&amp;amp;pos) , looks[face].v, ups[face].v);
    mCamera.UpdateViewMatrix();
    // 这里尽可能捕获近距离物体
    mCamera.SetFrustum(XM_PIDIV2, 1.0f, nearZ, farZ);

    // 应用观察矩阵、投影矩阵
    effect.SetViewMatrix(mCamera.GetViewXM());
    effect.SetProjMatrix(mCamera.GetProjXM());

    // 清空缓冲区
    deviceContext-&amp;gt;ClearRenderTargetView(mDynamicCubeMapRTVs[face].Get(), reinterpret_cast&amp;lt;const float*&amp;gt;(&amp;amp;Colors::Black));
    deviceContext-&amp;gt;ClearDepthStencilView(mDynamicCubeMapDSV.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
    // 设置渲染目标和深度模板视图
    deviceContext-&amp;gt;OMSetRenderTargets(1, mDynamicCubeMapRTVs[face].GetAddressOf(), mDynamicCubeMapDSV.Get());
    // 设置视口
    deviceContext-&amp;gt;RSSetViewports(1, &amp;amp;mCamera.GetViewPort());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用该方法后，就可以开始绘制到天空盒的指定面了，直到下一次&lt;code&gt;DynamicSkyRender::BeginCapture&lt;/code&gt;或&lt;code&gt;DynamicSkyRender::Restore&lt;/code&gt;被调用。&lt;/p&gt;
&lt;h3 id=&quot;dynamicskyrenderrestore方法--恢复之前绑定的资源并清空缓存&quot;&gt;DynamicSkyRender::Restore方法--恢复之前绑定的资源并清空缓存&lt;/h3&gt;
&lt;p&gt;该方法对应上面所说的第7,8步:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void DynamicSkyRender::Restore(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicEffect&amp;amp; effect, const Camera &amp;amp; camera)
{
    // 恢复默认设定
    deviceContext-&amp;gt;RSSetViewports(1, &amp;amp;camera.GetViewPort());
    deviceContext-&amp;gt;OMSetRenderTargets(1, mCacheRTV.GetAddressOf(), mCacheDSV.Get());

    // 生成动态天空盒后必须要生成mipmap链
    deviceContext-&amp;gt;GenerateMips(mDynamicCubeMapSRV.Get());

    effect.SetViewMatrix(camera.GetViewXM());
    effect.SetProjMatrix(camera.GetProjXM());
    // 恢复绑定的动态天空盒
    effect.SetTextureCube(mDynamicCubeMapSRV);

    // 清空临时缓存的渲染目标视图和深度模板视图
    mCacheDSV.Reset();
    mCacheRTV.Reset();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameappdrawscene方法&quot;&gt;GameApp::DrawScene方法&lt;/h2&gt;
&lt;p&gt;在GameApp类多了这样一个重载的成员函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::DrawScene(bool drawCenterSphere);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法额外添加了一个参数，仅用于控制中心球是否要绘制，而其余的物体不管怎样都是要绘制出来的。使用该重载方法有利于减少代码重复，这里面的大部分物体都需要绘制7次。&lt;/p&gt;
&lt;p&gt;假如只考虑&lt;code&gt;Daylight&lt;/code&gt;天空盒的话，无形参的&lt;code&gt;GameApp::DrawScene&lt;/code&gt;方法关于3D场景的绘制可以简化成这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
void GameApp::DrawScene()
{
    // ******************
    // 生成动态天空盒
    //
    
    // 保留当前绘制的渲染目标视图和深度模板视图
    mDaylight-&amp;gt;Cache(md3dImmediateContext, mBasicEffect);
    
    // 绘制动态天空盒的每个面（以球体为中心）
    for (int i = 0; i &amp;lt; 6; ++i)
    {
        mDaylight-&amp;gt;BeginCapture(md3dImmediateContext, mBasicEffect, 
            XMFLOAT3(), static_cast&amp;lt;D3D11_TEXTURECUBE_FACE&amp;gt;(i));

        // 不绘制中心球
        DrawScene(false);
    }
    
    // 恢复之前的绘制设定
    mDaylight-&amp;gt;Restore(md3dImmediateContext, mBasicEffect, *mCamera);
    
    // ******************
    // 绘制场景
    //

    // 预先清空
    md3dImmediateContext-&amp;gt;ClearRenderTargetView(mRenderTargetView.Get(), reinterpret_cast&amp;lt;const float*&amp;gt;(&amp;amp;Colors::Black));
    md3dImmediateContext-&amp;gt;ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
    
    // 绘制中心球
    DrawScene(true);
    
    // 省略文字绘制部分...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于有形参的&lt;code&gt;GameApp::DrawScene&lt;/code&gt;方法就不在这里给出，可以在项目源码看到。&lt;/p&gt;

&lt;p&gt;这部分内容并没有融入到项目中，因此只是简单地提及一下。&lt;/p&gt;
&lt;p&gt;在上面的内容中，我们对一个场景绘制了6次，从而生成动态天空盒。为了减少绘制调用，这里可以使用几何着色器来使得只需要进行1次绘制调用就可以生成整个动态天空盒。&lt;/p&gt;
&lt;p&gt;首先，创建一个渲染目标视图绑定整个纹理数组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_RENDER_TARGET_VIEW_DESC rtvDesc;
rtvDesc.Format = texDesc.Format;
rtvDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2DARRAY;
rtvDesc.Texture2DArray.FirstArraySlice = 0;
rtvDesc.Texture2DArray.ArraySize = 6;
rtvDesc.Texture2DArray.MipSlice = 0;
HR(device-&amp;gt;CreateRenderTargetView(
    texCube.Get(),
    &amp;amp;rtvDesc,
    mDynamicCubeMapRTV.GetAddressOf()));

rtvDesc.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;紧接着，就是要创建一个深度缓冲区数组(一个对应立方体面，元素个数为6)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_DEPTH_STENCIL_VIEW_DESC dsvDesc;
dsvDesc.Format = DXGI_FORMAT_D32_FLOAT;
dsvDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2DARRAY;
dsvDesc.Texture2DArray.FirstArraySlice = 0;
dsvDesc.Texture2DArray.ArraySize = 6;
dsvDesc.Texture2DArray.MipSlice = 0;
HR(device-&amp;gt;CreateDepthStencilView(
    depthTexArray.Get(),
    &amp;amp;dsvDesc,
    mDynamicCubeMapDSV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在输出合并阶段这样绑定到渲染管线:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deviceContext-&amp;gt;OMSetRenderTargets(1, 
    mDynamicCubeMapRTV.Get(),
    mDynamicCubeMapDSV.Get());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做会使得一次调用绘制可以同时向该渲染目标视图对应的六个纹理进行渲染。&lt;/p&gt;
&lt;p&gt;在HLSL，现在需要同时在常量缓冲区提供6个观察矩阵。顶点着色阶段将顶点直接传递给几何着色器，然后几何着色器重复传递一个顶点六次，但区别在于每次将会传递给不同的渲染目标。这需要依赖系统值&lt;code&gt;SV_RenderTargetArrayIndex&lt;/code&gt;来实现，它是一个整型索引值，并且只能由几何着色器写入来指定当前需要往渲染目标视图所绑定的纹理数组中的哪一个纹理。该系统值只能用于绑定了纹理数组的视图。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosTex
{
    float3 PosL : POSITION;
    float2 Tex : TEXCOORD;
};

struct VertexPosHTexRT
{
    float3 PosH : SV_POSITION;
    float2 Tex : TEXCOORD;
    uint RTIndex : SV_RenderTargetArrayIndex;
};


[maxvertexcount(18)]
void GS(trangle VertexPosTex input[3],
    inout TriangleStream&amp;lt;VertexPosTexRT&amp;gt; output)
{
     
    for (int i = 0; i &amp;lt; 6; ++i)
    {
        VertexPosTexRT vertex;
        // 指定该三角形到第i个渲染目标
        vertex.RTIndex = i;
        
        for (int j = 0; j &amp;lt; 3; ++j)
        {
            vertex.PosH = mul(input[j].PosL, mul(gViews[i], gProj));
            vertex.Tex = input[j].Tex;
            
            output.Append(vertex);
        }
        output.RestartStrip();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是经过魔改的，至于与它相关的示例项目&lt;code&gt;CubeMapGS&lt;/code&gt;只能在旧版的Microsoft DirectX SDK的Samples中看到了。&lt;/p&gt;
&lt;p&gt;这种方法有两点不那么吸引人的原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它使用几何着色器来输出大量的数据。不过放眼现在的显卡应该不会损失多大的性能。&lt;/li&gt;
&lt;li&gt;在一个典型的场景中，一个三角形不会出现在两个或以上的立方体表面，不管怎样，这5次绘制都没法通过裁剪，显得十分浪费。虽然在我们的项目中，一开始的做法也是将整个场景绘制到天空盒的一面，但是我们还可以使用视锥体裁剪技术来剔除掉那些不在视锥体的物体。使用几何着色器的方法不能进行提前的裁剪。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但还有一种情况它的表现还算不俗。假如你现在有一个动态天空系统，这些云层会移动，并且颜色随着时间变化。因为天空正在实时变化，我们不能使用预先烘焙的天空盒纹理来进行反射/折射。使用几何着色器绘制天空盒的方法在性能上不会损失太大。&lt;/p&gt;

&lt;p&gt;dielectric(绝缘体？)是指能够折射光线的透明材料，如下图。当光束射到绝缘体表面时，一部分光会被反射，还有一部分光会基于&lt;strong&gt;斯涅尔定律&lt;/strong&gt;进行折射。公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[n_{1}sinθ_{1} = n_{2}sinθ_{2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201811/1172605-20181103143452915-1889468001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中n1和n2分半是两个介质的折射率，θ1和θ2分别是入射光、折射光与界面法线的夹角，叫做入射角和折射角。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;n1 = n2&lt;/code&gt;时，&lt;code&gt;θ1 = θ2&lt;/code&gt;（无折射）&lt;br/&gt;当&lt;code&gt;n2 &amp;gt; n1&lt;/code&gt;时，&lt;code&gt;θ2 &amp;lt; θ1&lt;/code&gt;（光线向内弯折）&lt;br/&gt;当&lt;code&gt;n1 &amp;gt; n2&lt;/code&gt;时，&lt;code&gt;θ2 &amp;gt; θ1&lt;/code&gt;（光线向外弯折）&lt;/p&gt;
&lt;p&gt;在物理上，光线在从绝缘体出来后还会进行一次弯折。但是在实时渲染中，通常只考虑第一次折射的情况。&lt;/p&gt;
&lt;p&gt;HLSL提供了固有函数&lt;code&gt;refract&lt;/code&gt;来帮助我们计算折射向量：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;float3 refract(float3 incident, float3 normal, float eta);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;incident&lt;/code&gt;指的是入射光向量&lt;br/&gt;&lt;code&gt;normal&lt;/code&gt;指的是交界面处的法向量（与入射光点乘的结果为负值）&lt;br/&gt;&lt;code&gt;eta&lt;/code&gt;指的是&lt;code&gt;n1/n2&lt;/code&gt;，即介质之间的折射比&lt;/p&gt;
&lt;p&gt;通常，空气的折射率为&lt;code&gt;1.0&lt;/code&gt;，水的折射率为&lt;code&gt;1.33&lt;/code&gt;，玻璃的折射率为&lt;code&gt;1.51&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;之前的项目中&lt;code&gt;Material::Reflect&lt;/code&gt;来调整反射颜色，现在你可以拿它来调整折射颜色。&lt;/p&gt;
&lt;p&gt;在HLSL里，你只需要在像素着色器中加上这部分代码，就可以实现折射效果了（&lt;code&gt;gEta&lt;/code&gt;出现在常量缓冲区中）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 折射
if (gRefractionEnabled)
{
    float3 incident = -toEyeW;
    float3 refractionVector = refract(incident, pIn.NormalW, gEta);
    float4 refractionColor = texCube.Sample(sam, refractionVector);

    litColor += gMaterial.Reflect * refractionColor;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;该项目实现了反射和折射&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4frL9.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4fuPf.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 07:27:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 上一章的静态天空盒已经可以满足绝大部分日常使用了。但对于自带反射/折射属性的物体来说，它需要依赖天空盒进行绘制，但静态天空盒并不会记录周边的物体，更不用说正在其周围运动的物体了。因此我们需要在运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9900694.html</dc:identifier>
</item>
<item>
<title>通过Jenkins定期清除为None的镜像 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9900539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9900539.html</guid>
<description>&lt;p&gt;　　在代码持续交付过程中，依靠Jenkins生产Docker镜像时，会生成许多的名为None的中间镜像，这些镜像在整个项目生产过程完毕后意义不大，还占着空间，需要定期清理，通过手动方式实在是繁琐，也就有了定期清理。 &lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 通过Jenkins定期清除为None的镜像&quot; href=&quot;https://www.cnblogs.com/CKExp/p/9900539.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9900539.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、手动方式清理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;比较简便的清理方式，适合有单个none镜像产生时手动执行命令清理镜像，执行如下命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker rmi $(docker images &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dangling=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -q)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于我本地已经没有了none的镜像，因此执行就只能看到如下效果　　 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103135154492-1741040193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、项目生产结束后清理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　在Jenkins中建立一个满足CI的项目时，生产过程完毕结束后清理可以在构建执行脚本内设置，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103135655075-1056409512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中的脚本为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
echo ---------------Clear-Images...------------------&lt;span&gt;
clearImagesList&lt;/span&gt;=$(docker images &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dangling=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&lt;span&gt;q)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ ! -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$clearImagesList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]; then
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no images need  clean up.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
docker rmi &lt;/span&gt;$(docker images &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dangling=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&lt;span&gt;q)
echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clear success.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当项目构建完毕后，执行这个，将本身构建过程中生成的None镜像清楚，做到自己清除自己的中间产物。&lt;/p&gt;
&lt;p&gt;　　但是有一个严重问题会产生，当两个或多个项目在同时构建时，先构建完毕后执行清除的脚本将会影响正在构建过程中的项目，删除正在构建过程中所产生的none，但是删除失败进而引发错误，导致先构建的项目构建失败，在多个项目的情况下不推荐这种方式，如果在Jenkins中只有单个任务在跑，那没得问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、定时任务清理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　比较喜欢这种方式，新建一个Jenkins定时任务，比如我设置为晚上十二点清理为none的镜像，步骤如下：&lt;/p&gt;
&lt;p&gt;　　1、Jenkins中新建一个项目，名字随意，如我的为ClearImage。&lt;/p&gt;
&lt;p&gt;　　2、构建触发器，选择Poll SCM，设置定时时间，如我设置的是凌晨时分清理，也可设置其他时间，具体设置规则参见右边问号。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103140419895-992022158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、执行构建脚本，脚本内容在之前已经给出，保存完毕即可，&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103140443880-461960172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　手动执行立即构建，验证是否有效：&lt;/p&gt;
&lt;p&gt;　　查看控制台输出：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103140700624-576943017.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　输出完毕：构建有效。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181103140708714-1186821379.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;175&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 通过Jenkins定期清除为None的镜像&quot; href=&quot;https://www.cnblogs.com/CKExp/p/9900539.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9900539.html&lt;/a&gt; &lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-11-03,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 03 Nov 2018 06:09:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>在代码持续交付过程中，依靠Jenkins生产Docker镜像时，会生成许多的名为None的中间镜像，这些镜像在整个项目生产过程完毕后意义不大，还占着空间，需要定期清理，通过手动方式实在是繁琐，也就有了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9900539.html</dc:identifier>
</item>
<item>
<title>HAAR与DLib的实时人脸检测之实现与对比 - Ray Liang</title>
<link>http://www.cnblogs.com/Ray-liang/p/9900473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ray-liang/p/9900473.html</guid>
<description>&lt;p&gt;人脸检测方法有许多，比如opencv自带的人脸Haar特征分类器和dlib人脸检测方法等。&lt;/p&gt;
&lt;p&gt;对于opencv的人脸检测方法，优点是简单，快速；存在的问题是人脸检测效果不好。正面/垂直/光线较好的人脸，该方法可以检测出来，而侧面/歪斜/光线不好的人脸，无法检测。因此，该方法不适合现场应用。而对于dlib人脸检测方法采用64个特征点检测，效果会好于opencv的方法识别率会更高，本文会分别采用这几种方法来实现人脸识别。那个算法更好，跑跑代码就知道。&lt;/p&gt;
&lt;h2 id=&quot;实时图像捕获&quot;&gt;实时图像捕获&lt;/h2&gt;
&lt;p&gt;首先在进行人脸识别之前需要先来学点OpenCV的基础，起码知道如何从摄像头获取当前拍到的图像吧。OpenCV其实很简单，接下来的代码就是最基本的起步点。&lt;/p&gt;
&lt;p&gt;第一步：打开本机上的摄像头,实例化&lt;code&gt;VideoCapture&lt;/code&gt;类&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;camera = cv2.VideoCapture(0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始第一帧图像的捕获，这个方法用来测试当前的摄像头是否可用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;success, frame = camera.read()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;success&lt;/code&gt;返回真时表示开始捕捉图像，反则表示摄像头打开失败,接下来就用最少的代码来打开摄像头并将当前的图像直接显示到一个窗口上，具体代码结构如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
# ~/learn_face/cv_base.py
from __future__ import print_function

import cv2

cameraCapture = cv2.VideoCapture(0)
success, frame = cameraCapture.read()

while success and cv2.waitKey(1) == -1:
    success, frame = cameraCapture.read()
    #TODO:在此处可放置各种对当前每一帧图像的处理
    cv2.imshow(&quot;Camera&quot;, frame)

cameraCapture.release()
cv2.destroyAllWindows()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上述代码存为&lt;code&gt;opencv_base.py&lt;/code&gt;然后在命令行直接运行查看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python opencv_base.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/645016/201811/645016-20181103130947005-1430809083.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;haar-分类器&quot;&gt;HAAR 分类器&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;基于Haar特征的cascade分类器(classifiers) 是Paul Viola和 Michael Jone在2001年，论文”Rapid Object Detection using a Boosted Cascade of Simple Features”中提出的一种有效的物品检测(object detect)方法。它是一种机器学习方法，通过许多正负样例中训练得到cascade方程，然后将其应用于其他图片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在OpenCV3的源码的&lt;code&gt;data&lt;/code&gt;目录中就可以找到已训练好的HAAR算法模型，至HAAR算法的各种细节与理论有兴趣的直接去Google或者百度吧，一搜一大堆。花时间看一堆理论不如直接上代码，由代码直接理解这些复杂理论的应用更适合开发人员，毕竟我们不是数学家。&lt;/p&gt;
&lt;p&gt;使用HAAR模型识别图像中的人脸其实只要三步走，即使你对深度网络一点不懂也没关系，再复杂的理论到最终不过是一个方法调用罢了，了解清楚其中的原理就好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：初始化分类器并载入已训练好的HARR模型：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;face_cascade = cv2.CascadeClassifier(r'haarcascade_frontalface_default.xml')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;： 通过&lt;code&gt;cv2.cvtColor&lt;/code&gt;方法将当前的图像进行灰度化处理，简化图像的信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：然后将灰度化后的图像输入到分类器进行预判：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;faces = face_cascade.detectMultiScale(gray, 1.3, 5) #识别人脸&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要&lt;code&gt;faces&lt;/code&gt;数组的长度大于一就表示检测到当前画面中检测到人脸，反之亦然。简单来说其实人脸检测已经完成，&lt;/p&gt;
&lt;p&gt;最后，为了我们可以知道识别出来的结果，我们可以将脸用方框给圈出来，这里写个方法来圈脸：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def mark_face(img,x,y,w,h):
    return cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下为本例的全部代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
# ~/learn_face/cv_haar.py
from __future__ import print_function
import cv2

def mark_face(img, x, y, w, h):
    return cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)

cameraCapture = cv2.VideoCapture(0)
success, frame = cameraCapture.read()
face_cascade = cv2.CascadeClassifier(r'haarcascade_frontalface_default.xml') # 1.载入模型

while success and cv2.waitKey(1) == -1:
    success, frame = cameraCapture.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) #  2.生成灰度图
    faces = face_cascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5
    ) # 3.进行识别
    [mark_face(frame, *args) for args in faces] #画出识别的结果
    cv2.imshow(&quot;Camera&quot;, frame)
cameraCapture.release()
cv2.destroyAllWindows()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/645016/201811/645016-20181103131015479-1995584494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行起来就会觉得HAAR的识别效果不怎么样，稍微动一下就很会识别不了。&lt;/p&gt;
&lt;h2 id=&quot;dlib&quot;&gt;Dlib&lt;/h2&gt;
&lt;p&gt;接下来我们试试用&lt;a href=&quot;http://dlib.net/&quot;&gt;DLib&lt;/a&gt;这个老牌的专做人脸识别起家的C++库来试试，Dlib是一个跨平台的C++公共库，除了线程支持，网络支持，提供测试以及大量工具等等优点，Dlib还是一个强大的机器学习的C++库，包含了许多机器学习常用的算法。同时支持大量的数值算法如矩阵、大整数、随机数运算等等。Dlib同时还包含了大量的图形模型算法。最重要的是Dlib的文档和例子都非常详细。&lt;/p&gt;
&lt;p&gt;与HAAR分类器的检测方法相比dLib就简单得多了，只需要用dlib自带的人脸检测器&lt;code&gt;detector&lt;/code&gt;就够了，连模型都省了！之前的代码两步就能完成&lt;/p&gt;
&lt;p&gt;第一步：实例化 &lt;code&gt;detector&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;detector = dlib.get_frontal_face_detector()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：进行人脸检测&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;faces = detector(frame, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;That's all! 是不是很简单？&lt;/p&gt;
&lt;p&gt;以下是本例的全部代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
# ~/learn_face/cv_dlib.py
from __future__ import print_function
import cv2
import dlib

cameraCapture = cv2.VideoCapture(0)
success, frame = cameraCapture.read()
detector = dlib.get_frontal_face_detector()

while success and cv2.waitKey(1) == -1:
    success, frame = cameraCapture.read()
    faces = detector(frame, 1)
    for k, d in enumerate(faces):
        frame = cv2.rectangle(frame, (d.left(), d.top()),
                              (d.right(), d.bottom()), (255, 0, 0), 2)

    cv2.imshow(&quot;Camera&quot;, frame)

cameraCapture.release()
cv2.destroyAllWindows()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上述代码后会发现dlib的效果真的比HAAR的检测效果要好很多！不管头怎么转都能瞬间识别到，画出来的矩形框都不带闪的！&lt;/p&gt;
&lt;h3 id=&quot;特征点检测&quot;&gt;特征点检测&lt;/h3&gt;
&lt;p&gt;接下来我们用DLib的特征点提取器&lt;code&gt;detector&lt;/code&gt;所识别出来的人脸轮廓点给标记出来。关键点（landmarks）提取需要一个特征提取器&lt;code&gt;predictor&lt;/code&gt;，为了构建特征提取器，预训练模型必不可少。除了自行进行训练外，可以使用官方提供的一个模型。该模型可从&lt;a href=&quot;http://sourceforge.net/projects/dclib/files/dlib/v18.10/shape_predictor_68_face_landmarks.dat.bz2&quot;&gt;dlib sourceforge&lt;/a&gt; 库下载，此模型是从人脸中提出64个特征点进行检测，其准确度相当高。&lt;/p&gt;
&lt;p&gt;具体实现思路如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：生成灰度图&lt;/li&gt;
&lt;li&gt;第二步：生成直方图&lt;/li&gt;
&lt;li&gt;第三步：进行检测&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下为全部代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
# ~/learn_face/landmark.py
import cv2
import dlib

cameraCapture = cv2.VideoCapture(0)
success, frame = cameraCapture.read()
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor(
    &quot;shape_predictor_68_face_landmarks.dat&quot;)  

while success and cv2.waitKey(1) == -1:
    success, frame = cameraCapture.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)            #生成灰度图
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))  #生成直方图
    clahe_image = clahe.apply(gray)
    detections = detector(clahe_image, 1)

    for k, d in enumerate(detections): 
        shape = predictor(clahe_image, d)  # 获取坐标
        for i in range(1, 68):  # 每张脸都有68个识别点
            cv2.circle(frame, (shape.part(i).x, shape.part(i).y), 1, (0, 0, 255),
                       thickness=2)

    cv2.imshow(&quot;Camera&quot;, frame)

cameraCapture.release()
cv2.destroyAllWindows()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/645016/201811/645016-20181103131052767-1482891902.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;我在macBookPro上跑以上的代码在速度是上没有什么很大区别的，至少不会产生卡顿。但如果换将代码植到树莓3和树莓Zero上区别就明显了，HAAR分类器在树梅Zero上的运行时间平均在1.2s左右，而dlib则需要8s。至于准确率Dlib又明显会优于HAAR。&lt;/p&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31427728&quot;&gt;HAAR分类器&lt;/a&gt; - 这篇知乎上的文章对HAAR分类器的原理分析得很详尽，有兴趣可以读一读&lt;/li&gt;
&lt;li&gt;本文代码可到我的&lt;a href=&quot;https://gitee.com/ray_liang/learn_face&quot;&gt;码云&lt;/a&gt;上下载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 03 Nov 2018 05:40:00 +0000</pubDate>
<dc:creator>Ray Liang</dc:creator>
<og:description>人脸检测方法有许多，比如opencv自带的人脸Haar特征分类器和dlib人脸检测方法等。 对于opencv的人脸检测方法，优点是简单，快速；存在的问题是人脸检测效果不好。正面/垂直/光线较好的人脸，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ray-liang/p/9900473.html</dc:identifier>
</item>
<item>
<title>设计模式——装饰者模式 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/9900519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/9900519.html</guid>
<description>&lt;h3&gt;1. 情景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/408927/201811/408927-20181103124309669-850468599.png&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面馆开张了，主营2种面：酸菜面、牛肉面；外加2种配料：鸡蛋、豆皮&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;装饰者模式&lt;/strong&gt;来设计这一订单系统：&lt;/p&gt;
&lt;p&gt;满足要求：可以返回点的名称、计算总价格&lt;/p&gt;
&lt;h3&gt;2. 设计&lt;/h3&gt;
&lt;p&gt;大体思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/408927/201811/408927-20181103125819163-1814742172.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;336&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要说的是鸡蛋、豆皮是装饰者，为了让他可以任意的加配料，返回仍是面条类。&lt;/p&gt;
&lt;p&gt;类设计图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/408927/201811/408927-20181103130238865-722659475.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. 实现&lt;/h3&gt;
&lt;p&gt;面条抽象类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Noodle {
    String description &lt;/span&gt;= &quot;Unknown Name&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cost();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;装饰者抽象类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CondimentDecorator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Noodle {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDescription();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;面条具体类--酸菜面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SuancaiNoodle &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Noodle{
    SuancaiNoodle() {
        description &lt;/span&gt;= &quot;Suancai Noodle&quot;&lt;span&gt;;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cost() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 10&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;面条具体类--牛肉面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Noodle {
    String description &lt;/span&gt;= &quot;Unknown Name&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cost();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配料具体类--鸡蛋&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Egg &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CondimentDecorator{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Noodle noodle;
    Egg(Noodle noodle) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.noodle =&lt;span&gt; noodle;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; noodle.getDescription() + &quot; + Egg&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cost() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; noodle.cost() + 2&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配料具体类--豆皮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SkinOfTofu &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CondimentDecorator{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Noodle noodle;

    SkinOfTofu(Noodle noodle) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.noodle =&lt;span&gt; noodle;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; noodle.getDescription() + &quot; + SkinOfTofu&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cost() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; noodle.cost() + 1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NoodleTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Noodle suancai &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuancaiNoodle();
        Noodle addEgg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Egg(suancai);
        Noodle addEggSkin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkinOfTofu(addEgg);
        System.out.println(addEggSkin.getDescription());
        System.out.println(addEggSkin.cost());

        System.out.println(&lt;/span&gt;&quot;-----&quot;&lt;span&gt;);

        Noodle beef &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeefNoodle();
        Noodle addEgg2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Egg(beef);
        System.out.println(addEgg2.getDescription());
        System.out.println(addEgg2.cost());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
Suancai Noodle + Egg + SkinOfTofu
13.0
-----
Beef Noodle + Egg
14.0
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.java  I/O&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/408927/201811/408927-20181103130828949-1242150599.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中InputStream是抽象组件&lt;/p&gt;
&lt;p&gt;其下一列如FileInputStream是抽象装饰者,BufferedInputStream是具体装饰者&lt;/p&gt;
&lt;p&gt;用法举例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadFileTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            FileInputStream fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;jihite/test.json&quot;&lt;span&gt;);
            BufferedInputStream bis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(fis);
            BufferedInputStream bis2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(bis);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[bis2.available()];
            bis2.read(b);

            System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(b));
            bis2.close();
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6. 归纳&lt;/h3&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;
&lt;p&gt;设计原则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多组合、少继承&lt;/li&gt;
&lt;li&gt;对扩展开放、对修改关闭&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;para&quot;&gt;Decorator模式与继承关系的都是要扩展对象，但是Decorator可以提供比继承更多的灵活性&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的&lt;strong&gt;组合&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;
&lt;ul&gt;&lt;li class=&quot;para&quot;&gt;比继承更加灵活也同时意味着更加多的复杂性&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;导致设计中出现许多小类，如果过度使用，会使程序变得很复杂&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 03 Nov 2018 05:33:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<og:description>1. 情景 面馆开张了，主营2种面：酸菜面、牛肉面；外加2种配料：鸡蛋、豆皮 用装饰者模式来设计这一订单系统： 满足要求：可以返回点的名称、计算总价格 2. 设计 大体思路： 这里要说的是鸡蛋、豆皮是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/9900519.html</dc:identifier>
</item>
<item>
<title>3.1依赖注入「深入浅出ASP.NET Core系列」 - 张飞洪</title>
<link>http://www.cnblogs.com/alligator/p/9900449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alligator/p/9900449.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1.1什么是依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先看下图&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/d7a6b53f049c4ac99e7db1e4c3a3f2e0&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;可以简单理解，一个HomeController类使用到了DBContext类，而这种关系是有偶然性，临时性，弱关系的，但是DBContext的变化会影响到HomeController&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2显示依赖和隐式依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看显示依赖代码：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/9da598dada504d849ea7e971e7a53f4c&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;显示依赖通过构造函数，很清楚的描述了HomeController类都依赖了哪些对象，这样就可以很好的管理这些依赖。而隐式依赖的缺点刚好就是显示依赖的优点。我们看下面的隐式依赖：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/52caab9ecff741e9bde1e7caf46af26f&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果一个类有上千行代码，到处都充斥着该类型的代码，这些代码就像隐藏的病毒一样，无处不在，可以想象后续的变化和修改是多么的恐怖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3依赖倒置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依赖倒置的概念其实很简单，一句话就讲完了：我们要依赖抽象，而不依赖具体实现。什么是抽象？比如接口，抽象类就是。&lt;/p&gt;
&lt;p&gt;依赖抽象的目的是什么？封装变化！因为所有实现接口的实现都可以互相替换。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/346a6fc25b6b41b9a263ebd1c5a167af&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如上图所示，当数据库DapperUserRepository切换到EfUserRepository，对HomeController类可以无需任何修改，就可以平滑切换过去。反之，则更改的面就会非常大。&lt;/p&gt;
&lt;p&gt;再看下面的代码，OrderController依赖接口IUserRepository就是依赖倒置的表现。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/687064b2d181419a8b6c6dc35c6ba666&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;也许你会说，我的变化没有那么频繁，不需要那么麻烦。那么你是否考虑过，有可能自己的代码需要进行单元测试？如果存在这种可能，那么依赖注入是你必须要做的事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1控制反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再看下面这个代码的问题&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/08810c16173a4cbf8d65063d2f375e95&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虽然OrderController依赖的是接口IUserRepository，满足依赖倒置原则，但是构造函数却依赖的是具体实现类UserRepository，这种做法属于硬编码，仍然无法满足未来变化带来的修改，怎么办？接下来我们来讲控制反转这个相对难以理解的概念。&lt;/p&gt;
&lt;p&gt;先说反转，到底反转的是什么？我们知道OrderController依赖的对象UserRepository是在构造函数内的生成的。如何能够把该对象的生成交给外部去决定生成呢？可以的！这种转移对象生成的方式就是控制反转。&lt;/p&gt;
&lt;p&gt;简而言之，反转的是控制权，即依赖对象生成的控制权。是自己决定生成还是交由别人去决定生成。&lt;/p&gt;
&lt;p&gt;所以上面的代码，修改如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/e128a6e7a3dd4a47b1238bb6241323a4&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以上的代码才达到真正的控制反转，UserRepository对象的生成完全交由外部进行控制，交给变化去控制。&lt;/p&gt;
&lt;p&gt;这样有什么好处呢？交给外部生成的最大好处是想要生成什么对象可以自由控制，这样还是为了将来对象生成的可替换，比如数据库访问对象的变更；单元测试的实现类替换等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了上面的控制反转，我们的单元测试就方面很多了。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/e64d6572a08741ffb23e91fddaa224bc&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，在数据库无法连接的时候，我们可以使用MemoryUserRepository进行替换单元测试，非常方便。&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;我是.NET架构师张飞洪，入行10年有余，人不堪其忧，吾不改其乐，谢谢您关注我的&lt;a href=&quot;http://mp.toutiao.com/preview_article/?pgc_id=6619473817842483716&quot; target=&quot;_blank&quot;&gt;头条号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 03 Nov 2018 05:05:00 +0000</pubDate>
<dc:creator>张飞洪</dc:creator>
<og:description>希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。 从UML来理解依赖 1.1什么是依赖 我们先看下图 可以简单理解，一个HomeController类使用到了DBC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alligator/p/9900449.html</dc:identifier>
</item>
<item>
<title>周记6——css实现类似朋友圈九宫格缩略图完美展示 - 辛月</title>
<link>http://www.cnblogs.com/chenwenhao/p/9900372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenwenhao/p/9900372.html</guid>
<description>&lt;p&gt;公司有在做一个类似qq空间的开发，发表说说避免不了的要有图片展示。&lt;br/&gt;产品提出的空间缩略图的展示类似*信朋友圈那种效果——图片不变形、能看到中间部分。&lt;br/&gt;这里给出3种解决方案(jsbin地址失效时可复制代码到jsbin.com看效果）：&lt;/p&gt;
&lt;p&gt;1、 img + position + translate&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&amp;gt;
  &amp;lt;title&amp;gt;JS Bin&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
  .img_thum,.img_thum2,.img_thum3{
    position:relative;
    width:500px;
    height:500px;
    overflow:hidden;
    border:1px solid red;
  }
  .img_thum img,
  .img_thum2 img,
  .img_thum3 img{
    position:absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
    min-width: 100%;  /* 针对小图标 */
    min-height: 100%;  /* 针对小图标 */
    max-width: 200%; /* 针对太宽的图 -可能变形 */
    max-height: 200%; /* 针对太高的图 -可能变形 */
  }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;img_thum&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.88tph.com/subject/20181010/1258053ed87b46ef9341d3b72a2da682.jpg!/fw/300&quot; alt=&quot;&quot;&amp;gt; /* 300*235 */  
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum2&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.88tph.com/homepage/20181029/4a856635a175482f9cc068d2c1e8b585.jpg!fw1200&quot; alt=&quot;&quot;&amp;gt; /* 1200*320 */ 
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum3&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.taopic.com/uploads/allimg/140724/235063-140H410412090.jpg&quot; alt=&quot;&quot;&amp;gt;  /* 1000*1000 */
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jsbin地址：&lt;a href=&quot;https://jsbin.com/dakenupoqu/edit?html,output&quot; class=&quot;uri&quot;&gt;https://jsbin.com/dakenupoqu/edit?html,output&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出，img和img_out大小差不多时显示符合要求，但img像素过大时，看到的缩略图就有点“管中窥豹”了...所以这种方案慎用！&lt;/p&gt;
&lt;p&gt;2、background-imae + background-size + background-center&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&amp;gt;
  &amp;lt;title&amp;gt;background-imae+background-size+background-center&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    .img_thum,.img_thum2,.img_thum3{
      position:relative;
      width:500px;
      height:500px;
      overflow:hidden;
      border:1px solid red;
      background-size: cover;
      background-position: center;
    }
    .img_thum{
      background-image: url('http://img.88tph.com/subject/20181010/1258053ed87b46ef9341d3b72a2da682.jpg!/fw/300');
    }
    .img_thum2{
      background-image: url('http://img.88tph.com/homepage/20181029/4a856635a175482f9cc068d2c1e8b585.jpg!fw1200');
    }
    .img_thum3{
      background-image: url('http://img.taopic.com/uploads/allimg/140724/235063-140H410412090.jpg');
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;img_thum&quot;&amp;gt;
  /* 300*235 */
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum2&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
    /* 1200*320 */
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum3&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
   /* 1000*1000 */
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jsbin地址：&lt;a href=&quot;https://jsbin.com/xamowokaki/edit?html,output&quot; class=&quot;uri&quot;&gt;https://jsbin.com/xamowokaki/edit?html,output&lt;/a&gt;&lt;br/&gt;对比第一种方案，img和img_out只要比例差不多时显示就符合要求，不要求图片大小和显示区域大小差不多。但img像素过大，同时比例差太多时，看到的缩略图也会出现“管中窥豹”的现象。&lt;/p&gt;
&lt;p&gt;这种方案算是最完美的实现了，但如果你有语义化强迫症，觉得缩略图属于内容，一定要用img标签，那就推荐第三种实现方式：&lt;/p&gt;
&lt;p&gt;3、object-fit&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&amp;gt;
  &amp;lt;title&amp;gt;JS Bin&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
  .img_thum,.img_thum2,.img_thum3{
    position:relative;
    width:500px;
    height:500px;
    overflow:hidden;
    border:1px solid red;
  }
  .img_thum img,
  .img_thum2 img,
  .img_thum3 img{
    width:100%; /* 必须  */
    height:100%; /* 必须  */
    object-fit: cover;
  }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div class=&quot;img_thum&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.88tph.com/subject/20181010/1258053ed87b46ef9341d3b72a2da682.jpg!/fw/300&quot; alt=&quot;&quot;&amp;gt;  /* 300*235 */
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum2&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.88tph.com/homepage/20181029/4a856635a175482f9cc068d2c1e8b585.jpg!fw1200&quot; alt=&quot;&quot;&amp;gt;   /* 1200*320 */
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;img_thum3&quot; style=&quot;margin-top:20px;&quot;&amp;gt;
  &amp;lt;img src=&quot;http://img.taopic.com/uploads/allimg/140724/235063-140H410412090.jpg&quot; alt=&quot;&quot;&amp;gt;  /* 1000*1000 */
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jsbin地址：&lt;a href=&quot;https://jsbin.com/vulumexabo/edit?html,output&quot; class=&quot;uri&quot;&gt;https://jsbin.com/vulumexabo/edit?html,output&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种方案兼容性不是很好，效果类似第二种方案。&lt;/p&gt;
&lt;p&gt;不知道object-fit是啥？链接送上：&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/2015/03/css3-object-position-object-fit/&quot; class=&quot;uri&quot;&gt;https://www.zhangxinxu.com/wordpress/2015/03/css3-object-position-object-fit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;兼容参考：&lt;a href=&quot;https://blog.csdn.net/bigbear00007/article/details/80103109&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/bigbear00007/article/details/80103109&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后补充一点，当图片的比例和规范相差很大时，是没有办法实现这2点需求的。所以，在作图时要注意了！&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 04:36:00 +0000</pubDate>
<dc:creator>辛月</dc:creator>
<og:description>公司有在做一个类似qq空间的开发，发表说说避免不了的要有图片展示。 产品提出的空间缩略图的展示类似 信朋友圈那种效果——图片不变形、能看到中间部分。 这里给出3种解决方案(jsbin地址失效时可复制代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenwenhao/p/9900372.html</dc:identifier>
</item>
<item>
<title>电商门户网站商品品类多级联动SpringBoot+Thymeleaf实现 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/9900355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/9900355.html</guid>
<description>&lt;p&gt;在淘宝、京东等电商网站，其门户网站都有一个商品品类的多级联动，鼠标移动，就显示，因为前端不是我做的，所以不说明前端实现，只介绍后端实现。&lt;/p&gt;
&lt;p&gt;搭建部署SpringBoot环境&lt;br/&gt;配置文件配置：&lt;br/&gt;开启了对Thymeleaf模块引擎的支持&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8081
#logging:
#  config: classpath:logback_spring.xml
#  level:
#    com.muses.taoshop: debug
#  path: /data/logs

spring:
  datasource:

    # 主数据源
    shop:
      url: jdbc:mysql://127.0.0.1:3306/taoshop?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;characterSetResults=utf8&amp;amp;useSSL=false
      username: root
      password: root

    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    # 连接池设置
    druid:
      initial-size: 5
      min-idle: 5
      max-active: 20
      # 配置获取连接等待超时的时间
      max-wait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      min-evictable-idle-time-millis: 300000
      # Oracle请使用select 1 from dual
      validation-query: SELECT 'x'
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      # 打开PSCache，并且指定每个连接上PSCache的大小
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall,slf4j
      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
      connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
      # 合并多个DruidDataSource的监控数据
      use-global-data-source-stat: true

#  jpa:
#    database: mysql
#    hibernate:
#      show_sql: true
#      format_sql: true
#      ddl-auto: none
#      naming:
#        physical-strategy: org.hibernate.boot.entity.naming.PhysicalNamingStrategyStandardImpl

#  mvc:
#    view:
#      prefix: /WEB-INF/jsp/
#      suffix: .jsp

  #添加Thymeleaf配置
  thymeleaf:
    cache: false
    prefix: classpath:/templates/
    suffix: .html
    mode: HTML5
    encoding: UTF-8
    content-type: text/html

  #Jedis配置
#  jedis :
#    pool :
#      host : 127.0.0.1
#      port : 6379
#      password : redispassword
#      timeout : 0
#      config :
#        maxTotal : 100
#        maxIdle : 10
#        maxWaitMillis : 100000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringBoot启动类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.muses.taoshop;



import org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration;
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.web.servlet.ServletComponentScan;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.stereotype.*;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.bind.annotation.*;
/**
 *
 * &amp;lt;pre&amp;gt;
 *  SpringBoot启动配置类
 * &amp;lt;/pre&amp;gt;
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期:     修改内容:
 * &amp;lt;/pre&amp;gt;
 */
@Controller
@EnableScheduling//开启对计划任务的支持
@EnableTransactionManagement//开启对事务管理配置的支持
@EnableCaching
@EnableAsync//开启对异步方法的支持
@EnableAutoConfiguration
@ServletComponentScan
@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,
        MybatisAutoConfiguration.class,
        DataSourceTransactionManagerAutoConfiguration.class})
public class PortalApplication {

    @RequestMapping(&quot;/&quot;)
    @ResponseBody
    String home() {
        return &quot;portal web!&quot;;
    }

    @RequestMapping(&quot;/doTest&quot;)
    @ResponseBody
    String doTest(){
        System.out.println(Thread.currentThread().getName());
        String threadName = Thread.currentThread().getName();
        return threadName;
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(PortalApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写个Controller类跳转到门户网站：&lt;br/&gt;ps：品类多级联动思路其实就是先构建一个树，我这里的做法就是先查询处理，然后通过工具类，进行递归遍历，待会给出工具类代码，仅供参考。listCategory方法其实就是获取所有的品类信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.muses.taoshop.web.controller.portal;

import com.alibaba.fastjson.JSON;
import com.muses.taoshop.item.entity.ItemBrand;
import com.muses.taoshop.item.entity.ItemCategory;
import com.muses.taoshop.item.entity.ItemPortal;
import com.muses.taoshop.item.service.IItemBrankService;
import com.muses.taoshop.item.service.IItemCategoryService;
import com.muses.taoshop.item.service.IItemService;
import com.muses.taoshop.util.CategoryTreeUtils;
import com.muses.taoshop.web.controller.BaseController;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.CollectionUtils;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import java.util.Date;
import java.util.List;

/**
 * &amp;lt;pre&amp;gt;
 *  门户网站控制类
 * &amp;lt;/pre&amp;gt;
 *
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期:     修改内容:
 * &amp;lt;/pre&amp;gt;
 */
@Controller
@RequestMapping(&quot;/portal&quot;)
public class IndexController extends BaseController{

    @Autowired
    IItemService iItemService;
    @Autowired
    IItemBrankService iItemBrankService;
    @Autowired
    IItemCategoryService iItemCategoryService;

    /**
     * 跳转到门户网站
     * @return
     */
    @GetMapping(value = &quot;/toIndex.do&quot;)
    public ModelAndView toIndex(){
        info(&quot;跳转到门户网站&quot;);
        ModelAndView mv = this.getModelAndView();
        mv.setViewName(&quot;index&quot;);
        List&amp;lt;ItemPortal&amp;gt; items = iItemService.listItemPortal();
        CategoryTreeUtils treeUtil = new CategoryTreeUtils();
        List&amp;lt;ItemCategory&amp;gt; list = iItemCategoryService.listCategory();
        List&amp;lt;ItemCategory&amp;gt; categories = treeUtil.buildCategoryTree(list);
        mv.addObject(&quot;items&quot; , items);
        mv.addObject(&quot;categories&quot; , categories);
        return mv;
    }

    @GetMapping(value = &quot;/doTest&quot;)
    @ResponseBody
    public  String doTest(){
        List&amp;lt;ItemBrand&amp;gt; itemBrands = iItemBrankService.listItemBrand();
        String str = JSON.toJSON(itemBrands).toString();
        return str;
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;业务接口类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; package com.muses.taoshop.item.service;

import com.muses.taoshop.item.entity.ItemCategory;
import com.muses.taoshop.item.entity.ItemList;

import java.util.List;

/**
 * &amp;lt;pre&amp;gt;
 *  商品品类信息接口
 * &amp;lt;/pre&amp;gt;
 *
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2018.06.17 10:59    修改内容:
 * &amp;lt;/pre&amp;gt;
 */
public interface IItemCategoryService {
  
    /**
     * 查询所有商品品类信息
     * @return
     */
    List&amp;lt;ItemCategory&amp;gt; listCategory();

    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;业务服务实现类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  package com.muses.taoshop.item.service;

import com.muses.taoshop.item.entity.ItemCategory;
import com.muses.taoshop.item.entity.ItemList;
import com.muses.taoshop.item.mapper.ItemCategoryMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * &amp;lt;pre&amp;gt;
 *  商品品类信息服务实现类
 * &amp;lt;/pre&amp;gt;
 *
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2018.06.17 11:01    修改内容:
 * &amp;lt;/pre&amp;gt;
 */
@Service
public class ItemCategoryServiceImpl implements IItemCategoryService{

    @Autowired
    ItemCategoryMapper itemCategoryMapper;


    /**
     * 查询所有的商品品类信息
     * @return
     */
    @Override
    public List&amp;lt;ItemCategory&amp;gt; listCategory() {
        return itemCategoryMapper.listCategory();
    }

 


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mybatis相关代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;com.muses.taoshop.item.mapper.ItemCategoryMapper&quot; &amp;gt;
  &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.muses.taoshop.item.entity.ItemCategory&quot; &amp;gt;
    &amp;lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt;
    &amp;lt;result column=&quot;category_name&quot; property=&quot;categoryName&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
    &amp;lt;result column=&quot;sjid&quot; property=&quot;sjid&quot; jdbcType=&quot;BIGINT&quot; /&amp;gt;
    &amp;lt;result column=&quot;last_modify_time&quot; property=&quot;lastModifyTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&amp;gt;
    &amp;lt;result column=&quot;create_time&quot; property=&quot;createTime&quot; jdbcType=&quot;TIMESTAMP&quot; /&amp;gt;
  &amp;lt;/resultMap&amp;gt;

  &amp;lt;sql id=&quot;BaseColumnList&quot; &amp;gt;
    id,
        category_name as categoryName,
        sjid,
        last_modify_time as lastModifyTime,
        create_time as createTime
  &amp;lt;/sql&amp;gt;
  
    &amp;lt;!-- 获取所有的商品品类信息--&amp;gt;
    &amp;lt;select id=&quot;listCategory&quot; resultType=&quot;ItemCategory&quot;&amp;gt;
        SELECT 
        &amp;lt;include refid=&quot;BaseColumnList&quot; /&amp;gt;
        FROM item_category t
    &amp;lt;/select&amp;gt;
    
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mapper接口类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.muses.taoshop.item.mapper;

import com.muses.taoshop.item.entity.ItemCategory;
import com.muses.taoshop.item.entity.ItemList;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
@Mapper
public interface ItemCategoryMapper {

    List&amp;lt;ItemCategory&amp;gt; listCategory();

   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实体类：&lt;br/&gt;这里用了lombok的jar来实现，所有不用set和get方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.muses.taoshop.item.entity;


import com.alibaba.fastjson.annotation.JSONField;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import lombok.Data;
import org.springframework.format.annotation.DateTimeFormat;

import javax.validation.constraints.NotNull;
import java.util.Date;
import java.util.List;

/**
 * &amp;lt;pre&amp;gt;
 *  商品品类
 * &amp;lt;/pre&amp;gt;
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2018.06.09 21:49    修改内容:
 * &amp;lt;/pre&amp;gt;
 */
@Data
public class ItemCategory {
    /**
     * 商品品类id
     */
    private Long id;

    /**
     * 商品品类名称
     */
    private String categoryName;

    /**
     * 上级id
     */
    private Long sjid;

    /**
     * 上次修改时间
     */
    @JSONField(format =&quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date lastModifyTime;

    /**
     * 创建时间
     */
    @JSONField(format =&quot;yyyy-MM-dd HH:mm:ss&quot;)
    private Date createTime;

    /**
     * 子菜单
     */
    private List&amp;lt;ItemCategory&amp;gt; subCategorys;


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建品类树的工具类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.muses.taoshop.util;

import com.muses.taoshop.item.entity.ItemCategory;

import javax.mail.FetchProfile;
import java.util.ArrayList;
import java.util.List;

/**
 * &amp;lt;pre&amp;gt;
 *  构造一棵品类树
 * &amp;lt;/pre&amp;gt;
 *
 * @author nicky
 * @version 1.00.00
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2018.06.24 17:12    修改内容:
 * &amp;lt;/pre&amp;gt;
 */
public class CategoryTreeUtils {


    public List&amp;lt;ItemCategory&amp;gt; commonCategorys;

    public List&amp;lt;ItemCategory&amp;gt; list = new ArrayList&amp;lt;ItemCategory&amp;gt;();

    public List&amp;lt;ItemCategory&amp;gt; buildCategoryTree(List&amp;lt;ItemCategory&amp;gt; categories ) {
        this.commonCategorys = categories;
        for (ItemCategory c : categories){
            ItemCategory category = new ItemCategory();
            if(c.getSjid() == 0){
                category.setSjid(c.getSjid());
                category.setId(c.getId());
                category.setCategoryName(c.getCategoryName());
                category.setSubCategorys(treeChild(c.getId()));
                list.add(category);
            }
        }
        return list;
    }

    public List&amp;lt;ItemCategory&amp;gt; treeChild(long id){
        List&amp;lt;ItemCategory&amp;gt; list = new ArrayList&amp;lt;ItemCategory&amp;gt;();
        for(ItemCategory c : commonCategorys){
            ItemCategory category = new ItemCategory();
            if(c.getSjid() == id){
                category.setSjid(c.getSjid());
                category.setId(c.getId());
                category.setCategoryName(c.getCategoryName());
                category.setSubCategorys(treeChild(c.getId()));//递归循环
                list.add(category);
            }
        }
        return list;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;headerNav&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
    &amp;lt;div class=&quot;layout&quot;&amp;gt;
        &amp;lt;dl class=&quot;all-brands&quot;&amp;gt;
            &amp;lt;dt class=&quot;all-brands-head&quot;&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;全部商品分类&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt;
            &amp;lt;dd class=&quot;all-brands-list&quot;&amp;gt;
                &amp;lt;div class=&quot;wrap&quot; th:each=&quot;c : ${categories}&quot;&amp;gt;
                    &amp;lt;div class=&quot;all-sort-list&quot;&amp;gt;
                        &amp;lt;div class=&quot;item bo&quot;&amp;gt;
                            &amp;lt;h3&amp;gt;
                                &amp;lt;a href=&quot;&quot; th:text=&quot;${c.categoryName}&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
                            &amp;lt;div class=&quot;item-list clearfix&quot;&amp;gt;
                                &amp;lt;div class=&quot;close&quot;&amp;gt;x&amp;lt;/div&amp;gt;
                                &amp;lt;div class=&quot;subitem&quot; th:each=&quot;s: ${c.subCategorys}&quot;&amp;gt;
                                    &amp;lt;dl class=&quot;fore1&quot;&amp;gt;
                                        &amp;lt;dt th:text=&quot;${s.categoryName}&quot;&amp;gt;&amp;lt;a th:href=&quot;@{'/portal/category/toCategoryList/'+${s.id}}&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/dt&amp;gt;
                                        &amp;lt;dd&amp;gt;
                                            &amp;lt;em th:each=&quot;ss : ${s.subCategorys} &quot;&amp;gt;&amp;lt;a th:href=&quot;@{'/portal/category/toCategoryList/'+${ss.id}}&quot; th:text=&quot;${ss.categoryName}&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt;
                                        &amp;lt;/dd&amp;gt;
                                    &amp;lt;/dl&amp;gt;
                                &amp;lt;/div&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/dd&amp;gt;
            
        &amp;lt;/dl&amp;gt;
      
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现的效果如图：可以说是3级联动&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181103114210294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在开发中的开源项目的一个小功能，源码已经开源，&lt;a href=&quot;https://github.com/u014427391/taoshop&quot;&gt;github链接&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 04:30:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>在淘宝、京东等电商网站，其门户网站都有一个商品品类的多级联动，鼠标移动，就显示，因为前端不是我做的，所以不说明前端实现，只介绍后端实现。 搭建部署SpringBoot环境 配置文件配置： 开启了对Th</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/9900355.html</dc:identifier>
</item>
<item>
<title>职场：提升情商 - Vincent83</title>
<link>http://www.cnblogs.com/yingyingja/p/9897662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingyingja/p/9897662.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、关于情商&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201811/1451355-20181102170331957-2003128720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　情商（EQ=Emotional Quotient）又称情绪智力（Emotional Intelligence），是近年来心理学家们提出的与智力和智商相对应的 概念。它主要是指人在情绪、情感、意志、耐受挫折等方面的品质。&lt;/p&gt;
&lt;p&gt;        实际上情商这个概念属于比较新兴的理念，由上边这位大佬研究并提出。《情商:它为什么比智商更重要》这本书一经问世，很快引起了人们的强烈反响。&lt;/p&gt;
&lt;p&gt;　　以往认为，一个人能否在一生中取得成就，智力水平是第一重要的，即智商越高，取得成就的可能性就越大。但现在心理学家们普遍认为，情商水平的高低对一个人能否取得成功也有着重大的影响作用，有时其作用甚至要超过智力水平。&lt;/p&gt;
&lt;p&gt; 　　情商这个理念传递到中国以后，也引起广大人群的共鸣，我们纷纷联想到了生活当中遇到的各种奇葩人士，以及自己在生活中遭遇到的待人接物上的挫折。一时间，心灵鸡汤，厚黑学，人脉学种种被归于情商研学范畴的理念、书籍和文章红遍大江南北。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;然而，我们真的理解了情商吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;其实，情商：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;情商不只是待人接物，更是如何对待自己&lt;/li&gt;
&lt;li&gt;　　情商不是独立存在的人物特性&lt;/li&gt;
&lt;li&gt;　　情商和智商其实是相关的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、当我谈论情商，我们到底在谈论什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在戈尔曼的理论中，情商的维度分为以下五个：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;情绪认知 self emotion awareness&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　- 发觉并理解自身情绪、也在积累人生经验的过程中，总结出自己情绪体验和情绪波动规律。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;情绪管理 emotion management&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　-在强烈的情绪体验中也可以保持注意力和头脑清醒，并做出合理应对&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;情绪驱动 self motivation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　-用自己最深层最强烈的情绪给予自己完成目标的动力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;情绪理解 empathy&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　-察觉、理解、也回应身边人的情绪&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;社交能力 social skills&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　-适当影响和管控他人情绪&lt;/p&gt;
&lt;p&gt;　　可以看出来，情商最初的概念核心其实是&lt;span&gt;&lt;strong&gt;情绪管理&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　在说到怎么应对情绪之前，我们首先去分析一下，情绪到底是什么，他是怎么产生的，又有可能带来哪些后果？&lt;/p&gt;
&lt;p&gt;　　在心理学上，情绪（emotion）指的是人们对某个刺激因素（stimulus）产生的生理和心理反应（physiological and psychological response），而这种反应会进一步决定我们处理这种刺激的行为方式。这些生理和心理反应中，有一些是人类与生俱来的本能，而另一些则不是。&lt;/p&gt;
&lt;p&gt;　　一个情绪产生和消亡的过程中，我们会经历：&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;ask-title&quot;&gt;●&lt;/span&gt;生理反应 &lt;span class=&quot;ask-title&quot;&gt;●&lt;/span&gt;心理反应 &lt;span class=&quot;ask-title&quot;&gt;●&lt;/span&gt;行为反应&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;比如，当我们去陌生环境进行一场面试时，我们本能的会产生紧张情绪（&lt;strong&gt;心理反应&lt;/strong&gt;）；我们会肾上腺素上升，心跳加速，手心冒汗（&lt;strong&gt;生理反应&lt;/strong&gt;）；在面试的过程中，我们无法回答出本来很简单的问题，甚至在某些问题上采取了不恰当的态度（&lt;strong&gt;行为反应&lt;/strong&gt;）---- 这就是一次典型的完整情绪反应过程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、认知情绪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　要管理情绪，第一个层次，首先是管理自己的情绪。首要步骤则是情绪的认知。&lt;/p&gt;
&lt;p&gt;　　自我情绪的觉察相对而言是不那么难的事情，如果一个人连自己正处在情绪当中都无法知晓，那么恐怕已经到了心理疾病的程度。不过我们要更有意识的去注意自身情绪的产生，对他监控，更重要的是正视自己的情绪。你会感到愤怒、愉悦、哀伤、沮丧、兴奋，这些不论来自于生理还是理智，他都是人类与生俱来的特性。&lt;/p&gt;
&lt;p&gt;　　关于认知：&lt;/p&gt;
&lt;p&gt;　　1. 及时的意识到自身情绪的产生。在一个情绪最终导向行为反应之前，对他进行管理和控制。&lt;/p&gt;
&lt;p&gt;　　2. 要承认情绪的客观存在，肯定情绪的正面作用，因为这是我们的内心通过情绪向我们传递某种信息。&lt;/p&gt;
&lt;p&gt;　　3. 避免暴力式地压抑情绪，否定自己情绪的合理性，就等于在否定自身。正视他。&lt;/p&gt;

&lt;p&gt;　　实际中我们还可能遇到这样的情况，我发现了自己处在情绪当中，但是却无法对他进行一个准确的描述，不知道自己为什么会有这样的一种感受。&lt;/p&gt;
&lt;p&gt;　　这里有一些方法可以借鉴，帮助我们更好的了解自己的情绪究竟身为何物：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;叫出名字&lt;/strong&gt; - 用更多的词汇去描述你的情绪&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;说出特点&lt;/strong&gt; - 当前的情绪有什么特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;聆听讯息&lt;/strong&gt; - 这样的情绪，是我的内心在向我传递什么信息&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　比如当我刚去到我的上家单位时，工作了一段时间，我开始觉得缺乏动力，提不起工作的兴趣，但我并不能第一时间明白我的情绪到底是什么。于是我开始探究自己的心态：我感到工作没有趣，没有激情，我在应付了事。做为一个在职场打拼多年的人，这不是我应有的状态。最终我明白了，这种情绪叫做‘&lt;strong&gt;沮丧（depressed）&lt;/strong&gt;’和‘&lt;strong&gt;失望(disappointed)&lt;/strong&gt;’。而他产生的原因，是出于自己在当前所从事工作的不满，他没有满足我的兴趣所在，也没有给我提供更多的发展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;最终，这次情绪分析和一些其他的事情，促使了我后来的工作转型。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;四、管理情绪&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当我们认知到了情绪，下一个层级就是管理自我的情绪。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;首当其冲的，我们要去理清对于引起我们情绪的事务的正确理解和看法。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　传统意义上，我们认为，人们对于一个事务的应对是一种反射式机制，即由&lt;strong&gt;外界事物A -&amp;gt; 引发内心情绪C&lt;/strong&gt;。但是在心理学实践中，著名心理学家阿尔伯特·艾利斯 [Albert Ellis 1913.09.27]提出了另一种观点，认为引起人们情绪困扰的并不是外界发生的事件，而是&lt;span&gt;&lt;strong&gt;人们对事件的态度、看法、评价等认知内容。&lt;/strong&gt;&lt;span&gt;即&lt;strong&gt;外界事物A -&amp;gt; 个人认知B -&amp;gt; 内心情绪C&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;因此要改变情绪困扰不是致力于改变外界事件，而是应该&lt;span&gt;&lt;strong&gt;改变认知&lt;/strong&gt;&lt;/span&gt;，通过建立和厘清对于外界事物的正确认知，消除误解，消除过度解读，进而改变情绪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201811/1451355-20181102175643102-1128293159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;以前在工作中，我遇到过这样一位同事：她刚刚加入我们的工作组，由我负责对她进行一个工作指引。然而这个过程中，很快她的一个动作就激怒了我 ---- 在向我咨询问题的时候，她用自己的手指反复敲击我的电脑屏幕。想象一下这个场景，我相信你也会体会到被冒犯的感觉，这样的肢体动作一般只有在上级批评下级时才会做出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果是更年轻时的我，我可能压抑不住自己的怒气，我可能会秉承我一贯以来的作风：直言不讳的指出她的做法有问题。但是，那个时候的我，经历了一个更深的思考，我得出了这样的结论：&lt;strong&gt;她其实并不是在有意的想要冒犯我，而是出于她对于社交礼仪的无知&lt;/strong&gt;。这样去思考以后，虽然我仍然对她不满（出于她社交礼仪的匮乏），但我很快能平息自己的怒气，并且对于她的行为付诸一笑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这也是我掌握到的一条原则：&lt;strong&gt;当你可以将别人冒犯到你的行为/语言归结于‘愚蠢’的时候，其实就大可不必将他归结于‘动机’。&lt;/strong&gt;这样清醒的思考有助于管理我们的情绪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个例子就是理清对事务正确的看法，从而管控自己情绪的一个例子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　除了更多的思考，去厘清对事物的正确认知，还有以下的角度可以帮助我们管控情绪：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　冷静，思考情绪发泄可能带来的后果&lt;/li&gt;
&lt;li&gt;　　使用方法来缓解恶性情绪&lt;/li&gt;
&lt;li&gt;　　为情绪寻找出口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　科学实验证明，当人被急切情绪占据的时候，血液会迅速离开大脑皮层，理智的控制力下降，于是我们会更容易行为失常。这个时候一个简单的做法就是，冷静，克制，也许只需要10秒钟，血液就会流回大脑，我们可能发现原本想要爆发的情绪已经不那么强烈。因为我们的大脑已经开始重新取回控制权，那些本能的动物性被社会性的人格所压制，你又能正常表达了。&lt;/p&gt;
&lt;p&gt;　　同样我们说，情绪反应会伴随着生理反应，而生理调整同样可以反过来引导情绪。比如当我去到一个演讲舞台，发现自己紧张不能自已时，我会知道，深呼吸，挺直腰板，用一个强势的姿态走向演讲台；这些生理调整和肢体动作会很有效的将情绪引导向我想要的方向。&lt;/p&gt;

&lt;p&gt;　　当然，一味的压抑情绪，并不总是好的做法。如果被某种情绪长时间的占据，那么他会导致不健康的心理状态，甚至严重至心理疾病的产生。所以我们更应该为情绪寻找合适的出口。&lt;/p&gt;
&lt;p&gt;　　比如，当你感到愤怒又无从宣泄的时候，也许可以去听一段饶舌，听rapper宣泄他的怒气你会感到心情舒畅许多。&lt;/p&gt;
&lt;p&gt;　　又比如，去健身，去打球，去跑步，用大汗淋漓的方式去驱散心中负面的情绪。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;而更多的时候，&lt;span&gt;情绪是需要表达的&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　中国的传统教育总是倾向于压抑式教育，我们不可以哭泣，不可以软弱，不可以胆怯。。。过度的压制情绪并不会带给我们健康的心态。&lt;/p&gt;
&lt;p&gt;　　我们更应鼓励情绪的适当表达。&lt;/p&gt;
&lt;p&gt;　　表达你的情绪，而不是带着情绪去表达。让当事人知道自己的情绪，是人际交往中有效的方式。&lt;/p&gt;
&lt;p&gt;　　注意表达方式，在这种情形下，有一种很好的表达句式我们可以运用 ---- XYZ句式：“当你在X的情况下做Y这件事我感到Z”。&lt;/p&gt;
&lt;p&gt;　　比如：“昨天晚饭时你说的那些话，让我感到不安”。&lt;/p&gt;
&lt;p&gt;　　注意到了吗，这样的表达方式更不容易引起反感，究其原因是因为这句话的最终放在了自己身上，而不是强调别人的行为和问题；并且表达出情绪，却不至于让情绪去破坏一次对话。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;五、理解和应对情绪&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　情商的下一个层级，我们搞定了自己以后，还要去理解别人，理解别人的情绪。工作，生活中，我们经常会遇见那种‘搞不清状况’的人，甚至很多人会在完全不自知的情况下冒犯和伤害到别人，我们说情商，当然要避免自己成为这样的人。&lt;/p&gt;
&lt;p&gt;　　怎么才能理解别人的情绪呢？记住，谁也不是别人肚子里的蛔虫，人与人的相互理解是很困难的，这个过程需要我们付出巨大的努力，切忌想当然。&lt;/p&gt;
&lt;p&gt;　　好在放在情绪理解的程度而言，比起了解一个人的内心深处还是要容易一些的，我们有一些方法可以运用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;　　注意观察&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　换位思考&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　询问感受&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　注意观察，即所谓的察言观色，需要我们在人际交往中付出额外的努力，留意别人话语中的潜台词，注意肢体动作和表情变化。当然察言观色在一定程度上是一种天生的能力，如果做不好却强行实践，收效不好的同时可能同时会让你活的很累。&lt;/p&gt;
&lt;p&gt;　　现在我们经常讲换位思考，设身处地的想，如果我是ta，在这样的场景下，我会有怎样的情绪？勤作换位思考就不至于对氛围，对别人的情绪完全没有感知。&lt;/p&gt;
&lt;p&gt;　　其实很多情况下，当你无法确定对方是否有或者是否会有怎样的情绪产生，如果场景合适的话，我们也可以完全直接去开口询问。比如当我们与他人进行了一次交流，然后我们突然意识到自己刚才的有一些言论是不是有可能冒犯了他人？与其在内心纠结，我们完全可以去询问对方：“不知我刚才的话有没有冒犯到你？”这样不但可以确定对方的情绪和感受，同样也表示出你对于对方的感受是关心的这样一种态度，这当然是一种积极的讯号。&lt;/p&gt;

&lt;p&gt;　　当今也有一种非常主流的声音存在，即‘勇敢的做自己，不要太关注他人评价’。注意不要对这样的观点产生误解，认为自己只需要遵从本能，不用过多的关注他人，这是一种误读。上述观点的核心其实在于应对自己，而不是他人，属于本文情绪管理第一、二个层次的范畴。&lt;/p&gt;

&lt;p&gt;　　社交是人类本能驱使的一种行为。实际的人际关系和社交中，不但要求我们理解和觉察情绪，很多场景我们还需要对他人的情绪做出应对。&lt;/p&gt;
&lt;p&gt;　　应对他人的情绪，首先我们要把握住两个人交互的目的所在。当交互的双方产生情绪的时候，我们容易走进两个误区：&lt;strong&gt;争对错&lt;/strong&gt;和&lt;strong&gt;一味忍让。&lt;/strong&gt;其实不管是非要和人争一个高低对错，还是说常态式的忍让和做好人，都不能解决实际的问题。我们还要回到人际交往的原点，也就是他的目的所在，比如你想在交互获得的到底是：愉悦的交谈经历？实际事务的探讨？工作问题的解决？&lt;/p&gt;
&lt;p&gt;　　关注于交互最核心的目的，进一步去挖掘对方的真实需求：他的情绪是怎么产生的？如何才能让他平复情绪？他的真正诉求是什么？当你明确了对方的真正需求之后，就需要思考如何与对方达成共赢，或者你怎么可以帮助对方实现他的需求。&lt;/p&gt;
&lt;p&gt;　　注意把握人际交往的界限。很多人类个体的冲突，其实都是由于界限感稀薄所造成的。注意探知你与对方交往的界限所在，不要盲目越界，刺激到对方的防御心理和自我价值区域被侵入所产生的排斥感。同样也要明确自己的界限，当他人越界时，礼貌的提示。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;六、引导情绪&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;如果我们做为管理者，做为团队/家庭中的重要角色存在。一定程度的引导个体和群体的情绪走向，是我们在情商这个话题最后也是最高一个层次的诉求。一个优秀的团队核心，一个成熟的家庭成员，我们常常会看到他的高情商和人性闪光。&lt;/p&gt;
&lt;p&gt;　　有一些处事的态度和方法能帮助我们成为这样的人：　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　探究他人行事的动机
&lt;ul&gt;&lt;li&gt;前文已经提到过，我们可以剥开事务的表层，尝试去探寻他人的真实需求，从而对他进行协助。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;　　做正能量的传递者
&lt;ul&gt;&lt;li&gt;人们都喜欢充满正能量，乐观，积极的人。哪怕我们的内心深处有些忧郁，有些荒凉，都不妨碍你传递给别人的东西是正面积极向上。人都是会受其他个体影响的，当你传递出去积极阳光的信息，也会在正方向上推动你周围的人。实际行动上也要乐于去为他人提供帮助。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;　　做成熟主动的聆听者
&lt;ul&gt;&lt;li&gt;我们也许要学会疏导他人的情绪，在用教条主义去指导他人之前，首先做一个聆听者。用聆听表达出你的关心和关注，并为他人的情绪出口提供一个温暖的出口通道。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;　　强调感受而非结论
&lt;ul&gt;&lt;li&gt;当你在接受他人表述的时候，注意不要对‘换位思考’过度依赖。换位思考并不是一定能帮我们接近他人的内心深处，世界上没有两颗一样的沙粒，站在他人的角度上不代表你一定能完全体会他人的感受。在这个结论之上，要求我们强调自己在付出努力尝试理解对方的感受，而不是着急的得出结论或是执着的套用‘道理’。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Reference：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;丹尼尔.戈尔曼：《情商:它为什么比智商更重要》&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;阿尔伯特·艾利斯：《心理治疗的理性与情感》&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;壹心理&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 04:03:00 +0000</pubDate>
<dc:creator>Vincent83</dc:creator>
<og:description>一、关于情商 情商（EQ=Emotional Quotient）又称情绪智力（Emotional Intelligence），是近年来心理学家们提出的与智力和智商相对应的 概念。它主要是指人在情绪、情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingyingja/p/9897662.html</dc:identifier>
</item>
<item>
<title>mysql协议分析2---认证包 - zhanyd</title>
<link>http://www.cnblogs.com/zhanyd/p/9895241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanyd/p/9895241.html</guid>
<description>&lt;p&gt;主人看到navicat和mysql在那嘻嘻哈哈，眉来眼去的，好不快乐，忽然也想自己写个程序，直接去访问Mysql，虽然现在已经有很多现成的中间件可以直接拿来用了，程序只要负责写sql语句就行了，但是主人想要自己通过mysql协议直接和mysql通讯，一窥究竟。于是主人找到Mysql说：亲爱的mysql，我以前和你交流总要通过第三方的驱动在中间传话，总感觉我们之间还有一个隔阂，有些话也不方便说，我现在有些心里话想直接和你交流。。。你说行吗？&lt;/p&gt;

&lt;p&gt;mysql说：当然行啊，mysql受宠若惊，要和我打交道有多种方法比如：TCP/IP，TLS/SSL，Unix Sockets，Shared Memory，Named pipes等，那我们就用TCP/IP的方吧。用tcp协议就绕不开三次握手连接和四次握手断开，所以呢你和我连接的第一件事就是三次握手连接。&lt;/p&gt;

&lt;p&gt;主人尴尬的笑了笑，tcp的三次握手听到听说过很多次，但是从没有真正的理解。。。&lt;/p&gt;

&lt;p&gt;mysql从身后丢过来一个便签：这里有篇文章可以参考下：&lt;a href=&quot;https://www.cnblogs.com/zhanyd/p/9877762.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhanyd/p/9877762.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/zhan%20yd/p/9877762.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主人谢道，还是你体贴，刚开始navicat和你连接的时候，我是输入了主机地址，用户名，密码的，你们之间是怎么验证的呢？&lt;/p&gt;

&lt;p&gt;mysql说：好问题，所有的客户端和我连接首先都要先经过我的认证，我和客户端一次正常的交互过程如下：&lt;/p&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
1. 三次握手建立 TCP 连接。

2. 建立 MySQL 连接，也就是认证阶段。
    服务端 -&amp;gt; 客户端：发送握手初始化包 (Handshake Initialization Packet)。
    客户端 -&amp;gt; 服务端：发送验证包 (Client Authentication Packet)。
    服务端 -&amp;gt; 客户端：认证结果消息。

3. 认证通过之后，客户端开始与服务端之间交互，也就是命令执行阶段。
    客户端 -&amp;gt; 服务端：发送命令包 (Command Packet)。
    服务端 -&amp;gt; 客户端：发送回应包 (OK Packet, or Error Packet, or Result Set Packet)。

4. 断开 MySQL 连接。
    客户端 -&amp;gt; 服务器：发送退出命令包。

5. 四次握手断开 TCP 连接。
&lt;/pre&gt;

&lt;p&gt;我专门搞了个认证报文格式，我会按照以下的格式给客户端发送数据，然后客户端要根据这里面的内容给我返回验证包，然后我判断是否有权限登录：&lt;/p&gt;

&lt;p&gt;官方的文档是这样子滴：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tGpK1ia6v4cDnv6yc186mrtIAnnrzbwJYy7qUvGtnS9bibxic82kZKryibg/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;286&quot; data-ratio=&quot;0.4631268436578171&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;

&lt;p&gt;感觉不直观，在网上找到一个更直观的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tZlt4ecaOH56gqgV0jcricKiaZMzUbokiaheMXjwkMBWC65MoDXeHa6rlA/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;624&quot; data-ratio=&quot;1.0462130937098844&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体解释如下：&lt;/p&gt;
&lt;ul class=&quot;itemizedlist list-paddingleft-2&quot; type=&quot;disc&quot; readability=&quot;19.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;protocol_version&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;1&lt;/em&gt;) -- &lt;code class=&quot;literal&quot;&gt;0x0a&lt;/code&gt; protocol_version&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一个字节表示协议版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;server_version&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.NUL&lt;/em&gt;) -- human-readable server version&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务器版本号，字符串遇到Null结束&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;connection_id&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;4&lt;/em&gt;) -- connection id&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 服务器线程id&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;auth_plugin_data_part_1&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.fix_len&lt;/em&gt;) -- [len=8] first 8 bytes of the auth-plugin data&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一部分8个字节的挑战随机数，后面还有第二部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;filler_1&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;1&lt;/em&gt;) -- &lt;code class=&quot;literal&quot;&gt;0x00&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;填充位&lt;code class=&quot;literal&quot;&gt;0x00&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;capability_flag_1&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;2&lt;/em&gt;) -- lower 2 bytes of the &lt;code class=&quot;literal&quot;&gt;Protocol::CapabilityFlags&lt;/code&gt; (optional)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务器权能标志（低位2个字节）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;character_set&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;1&lt;/em&gt;) -- default server character-set, only the lower 8-bits &lt;code class=&quot;literal&quot;&gt;Protocol::CharacterSet&lt;/code&gt; (optional)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This &lt;span class=&quot;quote&quot;&gt;“&lt;span class=&quot;quote&quot;&gt;character set” value is really a collation ID but implies the character set; see the &lt;code class=&quot;literal&quot;&gt;Protocol::CharacterSet&lt;/code&gt; description.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;字符编码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;status_flags&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;2&lt;/em&gt;) -- &lt;code class=&quot;literal&quot;&gt;Protocol::StatusFlags&lt;/code&gt; (optional)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务器状态&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;capability_flags_2&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;2&lt;/em&gt;) -- upper 2 bytes of the &lt;code class=&quot;literal&quot;&gt;Protocol::CapabilityFlags&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;服务器权能标志（高位2个字节）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;auth_plugin_data_len&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;1&lt;/em&gt;) -- length of the combined auth_plugin_data, if auth_plugin_data_len is &amp;gt; 0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;挑战随机数的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;string[10]     reserved (all [00])&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;10个字节的保留位，都是00&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;auth_plugin_data_part_2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;挑战随机数的第二部分，通常是12字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;挑战随机数结束标志00&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;auth_plugin_name&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.NUL&lt;/em&gt;) -- name of the auth_method that the auth_plugin_data belongs to&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;            认证插件的名称，null结尾（这部分上面的图表里没有加进去）&lt;/p&gt;



&lt;p&gt;主人听完后，跃跃欲试，很想验证下Mysql说的是不是真的，于是他找到了密友Wiresshark，让他监听下navicat和mysql之间的认证包，Wiresshark很快就完成了任务，把结果呈上来了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tt72UjDENZicag9g4N1dSKcX1IsElwPsehNZjK0x1b76DXfud0PvxSEg/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;123&quot; data-ratio=&quot;0.19693396226415094&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体先看服务器发送过来的第一个包：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tVDItbZOgLasibvfoRqwOjjjoCxyQKekylmVJpZH2WRUQPP9lkjyHPJg/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;339&quot; data-ratio=&quot;0.5566556655665567&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;909&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主人一看，居然和mysql说的一模一样，好神奇。。。&lt;/p&gt;
&lt;p&gt;mysql笑道：那当然，我还能骗你不成。我发给客户端收到后，客户端就要返回认证包给我验证啦，是驴是马我一眼就能认出来了哦，客户端返回给我要遵循以下的格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tsyDAKLibQ5HDW7tU8tic4lGBgUbK2RdmX1jqzbWcxq3Wb8icDVq9XmyAQ/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;403&quot; data-ratio=&quot;0.55119825708061&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1377&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;Fields&lt;/h4&gt;
&lt;ul class=&quot;itemizedlist list-paddingleft-2&quot; type=&quot;disc&quot; readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;capability_flags&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;4&lt;/em&gt;) -- capability flags of the client as defined in &lt;code class=&quot;literal&quot;&gt;Protocol::CapabilityFlags&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;客户端权能标志&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;max_packet_size&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;4&lt;/em&gt;) -- max size of a command packet that the client wants to send to the server&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;报文的最大字节数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;character_set&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;1&lt;/em&gt;) -- connection's default character set as defined in &lt;code class=&quot;literal&quot;&gt;Protocol::CharacterSet&lt;/code&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;字符集编码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;username&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.fix_len&lt;/em&gt;) -- name of the SQL account which client wants to log in -- this string should be interpreted using the character set indicated by &lt;code class=&quot;literal&quot;&gt;character set&lt;/code&gt; field.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;auth-response&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.NUL&lt;/em&gt;) -- opaque authentication response data generated by &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;Authentication Method&lt;/em&gt; indicated by the &lt;code class=&quot;literal&quot;&gt;plugin name&lt;/code&gt; field&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户认证信息，即密码明文和挑战随机数加密后的token&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;database&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.NUL&lt;/em&gt;) -- initail database for the connection -- this string should be interpreted using the character set indicated by &lt;code class=&quot;literal&quot;&gt;character set&lt;/code&gt; field.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据库名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;strong&quot;&gt;&lt;strong&gt;auth plugin name&lt;/strong&gt; (&lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;string.NUL&lt;/em&gt;) -- the &lt;span class=&quot;emphasis&quot;&gt;&lt;em&gt;Authentication Method&lt;/em&gt; used by the client to generate &lt;code class=&quot;literal&quot;&gt;auth-response&lt;/code&gt; value in this packet. This is an UTF-8 string.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;认证方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主人抓包的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tKI66tVfkvs5ficQKebtClZ3GNFoEicODKPHEAMbqGLsCjMjCrDkbib2Tg/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;390&quot; data-ratio=&quot;0.6275303643724697&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/p&gt;

&lt;p&gt;mysql收到了主人发过来的认证包：主人，经过验证用户名密码都是正确的，可以登录了，我要返回一个ok报文，告诉你操作成功了哦，报文结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/360288/201811/360288-20181103130210258-358950102.png&quot; alt=&quot;&quot; width=&quot;634&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;


&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;header：&lt;/p&gt;
&lt;p&gt;OK: &lt;code class=&quot;literal&quot;&gt;header&lt;/code&gt; = 0 and length of packet &amp;gt; 7&lt;/p&gt;
&lt;p&gt;header=0并且报文长度&amp;gt;7表示当前是ok报文&lt;/p&gt;
&lt;p&gt;EOF: &lt;code class=&quot;literal&quot;&gt;header&lt;/code&gt; = 0xfe and length of packet &amp;lt; 9&lt;/p&gt;
&lt;p&gt; header=0xfe并且报文长度&amp;lt;9表示当前是eof报文&lt;/p&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主人抓包的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5t0rRL64X6kLAwsj9UIvJXT2JpraBNicgBoy0ugKgKiaP54zItfEP1aYAw/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;284&quot; data-ratio=&quot;0.5350404312668463&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;header = 0，表示这个是个ok报文，status_flags（server status）= 02表名设置自动提交成功。&lt;/p&gt;
&lt;p&gt;&lt;em class=&quot;structfield&quot;&gt;&lt;code&gt; &lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tswEX9grWvJAHGgtibyLiaymibmQLH1yVzmYPmQ4KibPcxOpQcInicLpGKWA/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;237&quot; data-ratio=&quot;0.3919939577039275&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1324&quot;/&gt;&lt;/p&gt;

&lt;p&gt;主人很高兴：这是不是说明，我和你的连接成功了呀？&lt;/p&gt;
&lt;p&gt;mysql：恭喜你连接成功了，我们走出了第一步，接下来你就可以发送命令让我执行了哟。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/EvyAfa0Ws5r0SCxhEkRTicic5fINNJWW5tkGyXogtYVIS2TsZU08XAibibcIra1zjySZ0iaeoJsLOwibYByHwuvC19UQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 03:53:00 +0000</pubDate>
<dc:creator>zhanyd</dc:creator>
<og:description>主人看到navicat和mysql在那嘻嘻哈哈，眉来眼去的，好不快乐，忽然也想自己写个程序，直接去访问Mysql，虽然现在已经有很多现成的中间件可以直接拿来用了，程序只要负责写sql语句就行了，但是主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanyd/p/9895241.html</dc:identifier>
</item>
<item>
<title>Spring Boot（十一）Redis集成从Docker安装到分布式Session共享 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/9900257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/9900257.html</guid>
<description>&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API，Redis也是技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」首字母缩写，也就是「远程字典服务」。&lt;/p&gt;
&lt;p&gt;Redis相比Memcached提供更多的数据类型支持和数据持久化操作。&lt;/p&gt;

&lt;h2 id=&quot;下载镜像&quot;&gt;2.1 下载镜像&lt;/h2&gt;
&lt;p&gt;访问官网：https://hub.docker.com/r/library/redis/ 选择下载版本，本文选择最新Stable 4.0.11&lt;/p&gt;
&lt;p&gt;使用命令拉取镜像：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker pull redis:4.0.11&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;启动容器&quot;&gt;2.2 启动容器&lt;/h2&gt;
&lt;p&gt;启动Redis命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;docker run --name myredis -p 6379:6379 -d redis:4.0.11 redis-server --appendonly yes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--name 设置别名&lt;/li&gt;
&lt;li&gt;-p 映射宿主端口到容器端口&lt;/li&gt;
&lt;li&gt;-d 后台运行&lt;/li&gt;
&lt;li&gt;redis-server --appendonly yes 在容器启动执行redis-server启动命令，打开redis持久化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动成功之后使用命令：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker ps&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看redis运行请求，如下图为运行成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/blog/springboot-redis-1.png?imageView2/0/w/800/h/400&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用客户端连接&quot;&gt;2.3 使用客户端连接&lt;/h2&gt;
&lt;p&gt;连接Redis不错的GUI工具应该是Redis Desktop Manager了，不过现在只有Linux版可以免费下载，我上传了一个Windows版本在百度云，版本号为：0.9.5（发布于2018.08.24）也是比较新的，链接: https://pan.baidu.com/s/16npZtnGa3-p2PAafiPEAkA 密码: 9uqg，还是免安装的，很好用。&lt;/p&gt;
&lt;p&gt;Redis Desktop Manager客户端预览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/blog/springboot-redis-4.png?imageView2/0/w/700/h/500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;开发环境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot 2.0.4 RELEASE&lt;/li&gt;
&lt;li&gt;Manven&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;添加依赖&quot;&gt;3.1 添加依赖&lt;/h2&gt;
&lt;p&gt;在pom.xml添加如下依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意不要依赖“spring-boot-starter-redis”它是旧版本，新版已经迁移到“spring-boot-starter-data-redis”了。&lt;/p&gt;
&lt;h2 id=&quot;配置redis&quot;&gt;3.2 配置Redis&lt;/h2&gt;
&lt;p&gt;在application.properties进行如下设置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;# Redis 配置
# Redis服务器地址
spring.redis.host=127.0.0.1
# Redis服务器连接密码（默认为空）
spring.redis.password=
# Redis服务器连接端口
spring.redis.port=6379  
# Redis分片（默认为0）Redis默认有16个分片
spring.redis.database=0
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8  
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1  
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8  
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0  
# 连接超时时间（毫秒）
spring.redis.timeout=10000
# 指定spring的缓存为redis
spring.cache.type=redis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：spring.redis.timeout不要设置为0，设置为0查询Redis时会报错，因为查询连接时间太短了。&lt;/p&gt;
&lt;h2 id=&quot;redis使用&quot;&gt;3.3 Redis使用&lt;/h2&gt;
&lt;p&gt;完成以上配置之后就可以写代码操作Redis了，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
private StringRedisTemplate stringRedisTemplate;

@RequestMapping(&quot;/&quot;)
public String doTest() {
    String _key = &quot;time&quot;; //缓存key
    stringRedisTemplate.opsForValue().set(_key, String.valueOf(new Date().getTime())); //redis存值
    return stringRedisTemplate.opsForValue().get(_key); //redis取值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stringRedisTemplate.opsForValue().set(&quot;test&quot;, &quot;100&quot;,60*10,TimeUnit.SECONDS); 向redis里存入数据和设置缓存时间；&lt;/li&gt;
&lt;li&gt;stringRedisTemplate.hasKey(&quot;keyName&quot;); 检查key是否存在，返回boolean；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了简化缓存可以直接使用声名式缓存，可以省去设置缓存和读取缓存的代码，使用起来会方便很多。&lt;/p&gt;
&lt;p&gt;声明式缓存使用步骤如下：&lt;/p&gt;
&lt;h2 id=&quot;设置redis缓存&quot;&gt;4.1 设置Redis缓存&lt;/h2&gt;
&lt;p&gt;在pom.xml文件设置缓存为Redis，代码如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spring.cache.type=redis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开启全局缓存&quot;&gt;4.2 开启全局缓存&lt;/h2&gt;
&lt;p&gt;在启动文件Application.java设置开启缓存，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用注解&quot;&gt;4.3 使用注解&lt;/h2&gt;
&lt;p&gt;注解如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Cacheable 设置并读取缓存（第一次设置以后直接读取）；&lt;/li&gt;
&lt;li&gt;@CachePut 更新缓存（每次删除并更新缓存结果）；&lt;/li&gt;
&lt;li&gt;@CacheEvict 删除缓存（只删除缓存）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通用属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value 缓存名称；&lt;/li&gt;
&lt;li&gt;key 使用SpEL表达式自定义的缓存Key，比如：#name是以参数name为key的缓存，#resule.name是以返回结果的name作为key的缓存；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cacheable-使用&quot;&gt;4.3.1 @Cacheable 使用&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 缓存key
private final String _CacheKey = &quot;userCacheKeyTime&quot;;
    
@RequestMapping(&quot;/&quot;)
@Cacheable(value = _CacheKey)
public String index() {
    System.out.println(&quot;set cache&quot;);
    return &quot;cache:&quot; + new Date().getTime();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有首次访问的时候会在控制台打印“set cache”信息，之后直接返回Redis结果了，不会在有添加的打印信息出现。&lt;/p&gt;
&lt;h3 id=&quot;cacheput-使用&quot;&gt;4.3.2 @CachePut 使用&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 缓存key
private final String _CacheKey = &quot;userCacheKeyTime&quot;;

@RequestMapping(&quot;/put&quot;)
@CachePut(value = _CacheKey)
public String putCache() {
    System.out.println(&quot;update cache&quot;);
    return &quot;update cache:&quot; + new Date().getTime();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问http://xxx/put 每次会把最新的数据存储缓存起来。&lt;/p&gt;
&lt;h3 id=&quot;cacheevict-使用&quot;&gt;4.3.3 @CacheEvict 使用&lt;/h3&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 缓存key
private final String _CacheKey = &quot;userCacheKeyTime&quot;;

@RequestMapping(&quot;/del&quot;)
@CacheEvict(value = _CacheKey)
public String delCache() {
    System.out.println(&quot;缓存删除&quot;);
    return &quot;delete cache:&quot; + new Date().getTime();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问http://xxx/del 只会删除缓存，除此之后不会进行任何操作。&lt;/p&gt;

&lt;p&gt;在分布式系统中Session共享有很多种方案，而把Session托管在缓存中是最常用的方案之一，下面来看Session在Redis中的托管步骤。&lt;/p&gt;
&lt;h2 id=&quot;添加依赖-1&quot;&gt;5.1 添加依赖&lt;/h2&gt;
&lt;p&gt;在pom.xml中添加如下引用：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开启session功能&quot;&gt;5.2 开启Session功能&lt;/h2&gt;
&lt;p&gt;在启动类Application.java的类注解添加开启Session，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableCaching
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)
public class RedisApplication {
    public static void main(String[] args) {
        SpringApplication.run(RedisApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中maxInactiveIntervalInSeconds为Session过期时间，默认30分钟，设置单位为秒。&lt;/p&gt;
&lt;h2 id=&quot;session使用&quot;&gt;5.3 Session使用&lt;/h2&gt;
&lt;p&gt;接下来编写一段代码来测试一下Session，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/uid&quot;)
public String testSession(HttpSession session) {
    UUID uid = (UUID) session.getAttribute(&quot;uid&quot;);
    if (uid == null) {
        uid = UUID.randomUUID();
    }
    session.setAttribute(&quot;uid&quot;, uid);
    
    return session.getId();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连续访问两次请求之后，查看控制台信息如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/springboot-redis-7.png?imageView2/0/w/500/h/300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，两次访问的SessionId是一样的，这个时候在查看Redis 客户端，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/springboot-redis-5.png?imageView2/0/w/700/h/500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现Redis里存储的Session过期时间也是对的，符合我们的设置。&lt;/p&gt;
&lt;h2 id=&quot;分布式系统共享session&quot;&gt;5.4 分布式系统共享Session&lt;/h2&gt;
&lt;p&gt;因为把Session托管给同一台Redis服务器了，所以Session在Spring Boot中按照如上方式在配置多台服务器，得到的Session是一样的。&lt;/p&gt;
&lt;p&gt;示例源码下载：https://github.com/vipstone/springboot-example/tree/master/springboot-redis&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring boot中Redis的使用：http://www.ityouknow.com/springboot/2016/03/06/spring-boot-redis.html&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 03:52:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<og:description>一、简介 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key Value数据库，并提供多种语言的API，Redis也是技术领域使用最为广泛的存储中间件，它是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/9900257.html</dc:identifier>
</item>
</channel>
</rss>