<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Javascript实现表达式查询数组 - 飞权</title>
<link>http://www.cnblogs.com/qq870841070/p/9329657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq870841070/p/9329657.html</guid>
<description>&lt;p&gt;由于每次在查找数组的时候都是用的for循环遍历查找，很烦 , 要是能像C#那样用一个表达式查询就好了， 就在这个特别纠结的时候，&lt;/p&gt;
&lt;p&gt;头脑中突然灵光一闪，是不是该去上个WC了，果然回来之后我想到的eval这个函数，对，一定行的，思路很特别,&lt;/p&gt;
&lt;p&gt;这样的话就可以跳过那复杂的语法解析了，哈哈，太简单了，每个变量在作用域内使用eval这个函数是能够访问到这个变量的，&lt;/p&gt;
&lt;p&gt;下面是几行简单的代码&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             { name: &quot;张三&quot;, age: 18, isOut: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             { name: &quot;李四&quot;, age: 20, isOut: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             { name: &quot;老五&quot;, age: 20, isOut: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             { name: &quot;老六&quot;, age: 21, isOut: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; where(array, express) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (arguments.length &amp;gt; 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合成express&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; c = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 2; i &amp;lt; arguments.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     express = express.replace(&quot;{&quot; + c + &quot;}&quot;&lt;span&gt;, arguments[i].toString());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     c++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析表达式&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; array.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; p =&lt;span&gt; array[i];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; resu =&lt;span&gt; eval(express);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resu) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    result.push(p);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list1 = where(list, &quot;p.name=='张三' &amp;amp;&amp;amp; p.age &amp;gt; 10 &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list2 = where(list, &quot;p.name.indexOf('老') &amp;gt; -1 &amp;amp;&amp;amp; p.age&amp;gt;=20 &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; list3 = where(list, &quot;p.name == '{0}' &amp;amp;&amp;amp; p.age == {1}&quot;, &quot;张三&quot;, 18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        console.log(list1);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        console.log(list2);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 18 Jul 2018 08:00:00 +0000</pubDate>
<dc:creator>飞权</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq870841070/p/9329657.html</dc:identifier>
</item>
<item>
<title>KVO的使用一 - 翾燚</title>
<link>http://www.cnblogs.com/xuanyishare/p/9295309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuanyishare/p/9295309.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;KVO&lt;span lang=&quot;zh-CN&quot;&gt;即&lt;span lang=&quot;zh-CN&quot;&gt;Key&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;Value &lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;Observing&lt;span lang=&quot;zh-CN&quot;&gt;，它允许一个对象被另一个对象在改变指定的属性值后进行通知。iOS中的应用场景很多，比如model的值发生变化，controller里对model进行监听从而改变view。便于对KVO有更好地理解，可以先理解KVC：&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;苹果官方KVC文档&lt;/span&gt;&lt;/a&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。最直接有效的学习方法是官方文档：&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;KVO官方文档&lt;/span&gt;&lt;/a&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，这个文档还有日文版，很是诧异！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;系统为被观察者生成一个子类，命名方式NSKVONotyfing_类名，当监听的键值发生改变时，系统调用重写的子类set方法对该键进行赋值，并在内部加一个消息传递，让观察者去接受值的变化并可以进行相应地操作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实际运用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KVO&lt;span&gt;的实现采用了观察者模式，使用大致流程是先注册观察者被观察者等，然后改变要观察的键值，最后在观察者的消息接收方法中根据改变后的键值进行相应的处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iOS&lt;span&gt;在NSObject、NSArray、NSOrderSet、NSSet中都加入了实现KVO的分类，而我们平时使用的大部分对象都是这些类的子类，所以系统KVO能够满足大部分需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li value=&quot;1&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;使用&lt;span lang=&quot;en-US&quot;&gt;KVO&lt;span lang=&quot;zh-CN&quot;&gt;要先进行注册，确定观察者、被观察者及要监听的值对象。使用分类&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueObserverRegistration的方法进行注册。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;- (&lt;span&gt;void&lt;span&gt;)addObserver:(&lt;span&gt;NSObject &lt;span&gt;*)observer forKeyPath:(&lt;span&gt;NSString &lt;span&gt;*)keyPath options:(&lt;span&gt;NSKeyValueObservingOptions&lt;span&gt;)options context:(&lt;span&gt;nullable &lt;span&gt;&lt;span&gt;void &lt;span&gt;*)context;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span lang=&quot;en-US&quot;&gt;observer&lt;span lang=&quot;zh-CN&quot;&gt;参数是接收消息的对象&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;en-US&quot;&gt;keyPath&lt;span lang=&quot;zh-CN&quot;&gt;是要观察的键名&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;options是一个枚举，包含四个枚举值：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;NSKeyValueObservingOptionNew&lt;span&gt;：接收消息方法的change字典中有新改变的值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NSKeyValueObservingOptionOld&lt;span&gt;：接收消息方法的change字典中有改变前一次的值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NSKeyValueObservingOptionInitial&lt;span&gt;：立即向接收消息方法发送通知，简言之就是你的注册方法可能还没执行完，已经接收到消息了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NSKeyValueObservingOptionPrior&lt;span&gt;：键值改变前后都会发送消息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;context是用来区分相同被观察者的不同键值或者不同被观察者同一或不同键值的标识，防止混淆。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;知晓了注册方法，我们先声明一个Person类，添加两个属性name和age。在ViewController里的类扩展中添加一个Person类型的属性person，viewDidLoad方法里添加注册方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;- (&lt;span&gt;void&lt;span&gt;)viewDidLoad {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    [&lt;span&gt;super &lt;span&gt;&lt;span&gt;viewDidLoad&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;self&lt;span&gt;.&lt;span&gt;person &lt;span&gt;= [[&lt;span&gt;Person &lt;span&gt;&lt;span&gt;alloc&lt;span&gt;] &lt;span&gt;init&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    [&lt;span&gt;self&lt;span&gt;.&lt;span&gt;person &lt;span&gt;&lt;span&gt;addObserver&lt;span&gt;:&lt;span&gt;self &lt;span&gt;&lt;span&gt;forKeyPath&lt;span&gt;:&lt;span&gt;@&quot;name&quot; &lt;span&gt;&lt;span&gt;options&lt;span&gt;:&lt;span&gt;NSKeyValueObservingOptionNewcontext&lt;span&gt;:&lt;span&gt;nil&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;NSLog&lt;span&gt;(&lt;span&gt;@&quot;&lt;span&gt;观察者注册完毕&lt;span&gt;&quot;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;接下来改变监听的键值，触发系统动态添加的子类的setName方法，改变键值后通知观察者接收消息。添加一个触摸屏幕事件，在里面改变name的值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;- (&lt;span&gt;void&lt;span&gt;)touchesBegan:(&lt;span&gt;NSSet&lt;span&gt;&amp;lt;&lt;span&gt;UITouch &lt;span&gt;*&amp;gt; *)touches withEvent:(&lt;span&gt;UIEvent &lt;span&gt;*)event {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;self&lt;span&gt;.&lt;span&gt;person&lt;span&gt;.&lt;span&gt;name &lt;span&gt;= &lt;span&gt;@&quot;&lt;span&gt;小明&lt;span&gt;&quot;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li value=&quot;3&quot;&gt;&lt;span&gt;  现在使用观察者的接收消息方法，处理键值变化后的情况。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;- (&lt;span&gt;void&lt;span&gt;)observeValueForKeyPath:(&lt;span&gt;nullable &lt;span&gt;&lt;span&gt;NSString &lt;span&gt;*)keyPath ofObject:(&lt;span&gt;nullable &lt;span&gt;&lt;span&gt;id&lt;span&gt;)object change:(&lt;span&gt;nullable &lt;span&gt;&lt;span&gt;NSDictionary&lt;span&gt;&amp;lt;&lt;span&gt;NSKeyValueChangeKey&lt;span&gt;, &lt;span&gt;id&lt;span&gt;&amp;gt; *)change context:(&lt;span&gt;nullable &lt;span&gt;&lt;span&gt;void &lt;span&gt;*)context;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;keyPath&lt;span&gt;是观察的键的名称。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;object是被观察对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;change是一个变化前后值的字典，包括改变前后的值等，和注册方法的options有关。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;context是在注册时用来区分判定键的标识。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们在该方法中实现一个NSLog方法，打印上述内容信息。&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeKey&lt;span lang=&quot;zh-CN&quot;&gt;是一个封装的const&lt;span lang=&quot;en-US&quot;&gt;,&lt;span lang=&quot;zh-CN&quot;&gt;包括&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeKindKey&lt;span lang=&quot;zh-CN&quot;&gt;、&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeNewKey&lt;span lang=&quot;zh-CN&quot;&gt;、&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeOldKey&lt;span lang=&quot;zh-CN&quot;&gt;、&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeIndexesKey&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;zh-CN&quot;&gt;NSKeyValueChangeNotificationIsPriorKey&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;- (&lt;span&gt;void&lt;span&gt;)observeValueForKeyPath:(&lt;span&gt;NSString &lt;span&gt;*)keyPath ofObject:(&lt;span&gt;id&lt;span&gt;)object change:(&lt;span&gt;NSDictionary&lt;span&gt;&amp;lt;&lt;span&gt;NSKeyValueChangeKey&lt;span&gt;,&lt;span&gt;id&lt;span&gt;&amp;gt; *)change context:(&lt;span&gt;void &lt;span&gt;*)context{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;NSLog&lt;span&gt;(&lt;span&gt;@&quot;&lt;span&gt;监听到&lt;span&gt;%@&lt;span&gt;对象的&lt;span&gt;%@&lt;span&gt;属性的改变为&lt;span&gt;%@&quot;&lt;span&gt;,[object class],keyPath,[&lt;span&gt;change &lt;span&gt;objectForKey:&lt;span&gt;NSKeyValueChangeNewKey&lt;span&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打印结果：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/821649/201807/821649-20180718154442055-1034226870.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;68&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果看出来，消息接收方法收到Person的name变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上就是KVO的简单实现过程。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 07:51:00 +0000</pubDate>
<dc:creator>翾燚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuanyishare/p/9295309.html</dc:identifier>
</item>
<item>
<title>2.ASP.NET全栈开发之在MVC种使用服务端验证 - Gxqsd</title>
<link>http://www.cnblogs.com/Gxqsd/p/9329505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gxqsd/p/9329505.html</guid>
<description>&lt;p&gt;上一章我们在控制台中基本的了解了FluentValidation是如何简洁，优雅的完成了对实体的验证工作，今天我们将在实战项目中去应用它。&lt;/p&gt;
&lt;p&gt;首先我们创建一个ASP.NET MVC项目，本人环境是VS2017，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718143655961-1993568417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功后通过在Nuget中使用 Install-Package FluentValidation -Version 7.6.104 安装FluentValidation&lt;/p&gt;
&lt;p&gt;在Model文件夹中添加两个实体Address 和 Person&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Address
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Home { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 姓名
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 年龄
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 性别
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Sex { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Address Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着创建实体的验证器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddressValidator : AbstractValidator&amp;lt;Address&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AddressValidator()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(m =&amp;gt;&lt;span&gt; m.Home)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;家庭住址不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(m =&amp;gt;&lt;span&gt; m.Phone)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手机号码不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonValidator : AbstractValidator&amp;lt;Person&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PersonValidator()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Name)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Age)
                .NotEmpty()
                .WithMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RuleFor(p =&amp;gt;&lt;span&gt; p.Address)
                .SetValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddressValidator());

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了更好的管理验证器，我建议将使用一个Manager者来管理所有验证器的实例。如ValidatorHub&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidatorHub
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AddressValidator AddressValidator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddressValidator();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PersonValidator PersonValidator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonValidator();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要创建一个页面，在默认的HomeController 控制器下添加2个Action:ValidatorTest，他们一个用于展示页面，另一个则用于提交。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 　　　　[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为 ValidatorTest 添加视图，选择Create模板，实体为Person&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718144444095-2137009324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将默认的@Html全部删掉，因为在我们本次介绍中不需要，我们的目标是搭建一个前后端分离的项目，而不要过多的依赖于MVC。&lt;/p&gt;
&lt;p&gt;最终我们将表单改写成了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using (Html.BeginForm())
{
    @Html.AntiForgeryToken()

    &lt;/span&gt;&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-horizontal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;h4&amp;gt;Person&amp;lt;/h4&amp;gt;
        &amp;lt;hr /&amp;gt;&lt;span&gt;
        @Html.ValidationSummary(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { @class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
        &lt;/span&gt;&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;姓名&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;年龄&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;住址&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;电话&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;性别&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-offset-2 col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，由于我们的实体Person中存在复杂类型Address，我们都知道，表单提交默认是Key:Value形式，而在传统表单的key:value中，我们无法实现让key为Address的情况下Value为一个复杂对象，因为input一次只能承载一个值，且必须是字符串。实际上MVC中存在模型绑定，此处不作过多介绍（因为我也忘记了-_-||）。&lt;/p&gt;
&lt;p&gt;简单的说就是他能根据你所需要类型帮我们自动尽可能的转换，我们目前只要知道如何正确使用，在Address中存在Home属性和Phone属性，我们可以将表单的name设置为Address.Home，MVC的模型绑定会将Address.Home解析到对象Address上的Home属性去。&lt;/p&gt;
&lt;p&gt;简单的校验方式我也不过多介绍了。再上一章我们已经了解到通过创建一个实体的验证器来对实体进行验证，然后通过IsValid属性判断是否验证成功。对，没错，对于大家来说这太简单了。但我们每次校验都创建一个验证器是否显得有点麻烦呢？不要忘了我们刚刚创建了一个ValidatorHub，我们知道控制器默认继承自Controller，如果我们想为控制器扩展一些能力呢？现在我要创建一个ControllerEx了，并继承自Controller。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerEx : Controller
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; DicError { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ValidatorHub ValidatorHub { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValidatorHub();

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuted(ActionExecutedContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuted(filterContext);
            ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; DicError;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ValidatorErrorHandler(ValidationResult result)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; failure &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result.Errors)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DicError.ContainsKey(failure.PropertyName))
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DicError.Add(failure.PropertyName, failure.ErrorMessage);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ControllerEx里我创建了一个ValidatorHub属性，正如其名，他内部存放着各种验证器实体呢。有了它，我们可以在需要验证的Action中通过this.ValidatorHub.具体验证器就能完成具体验证工作了，而不需要再去每次new 一个验证器。&lt;/p&gt;
&lt;p&gt;同样我定义了一个DicError的键值对集合，他的键和值类型都是string。key是验证失败的属性名，而value则是验证失败后的错误消息，它是用来存在验证的结果的。&lt;/p&gt;
&lt;p&gt;在这里我还定义了一个ValidatorErrorHandler的方法，他有一个参数是验证结果，通过名称我们大致已经猜到功能了，验证错误的处理，对验证结果的错误信息进行遍历，并将错误信息添加至DicError集合。&lt;/p&gt;
&lt;p&gt;最终我需要将这个DicError传递给View，简单的办法是ViewData[&quot;Error&quot;] 但我不想在每个页面都去这么干，因为这使我要重复多次写这行代码，我会厌倦它的。很棒的是MVC框架为我们提供了Filter（有的地方也称函数钩子，切面编程，过滤器），能够方便我们在生命周期的不同阶段进行控制，很显然，我的需求是在每次执行完Action后要在末尾添加一句ViewData[&quot;Error&quot;]=DicError。于是我重写了&lt;span&gt;OnActionExecuted方法，仅添加了&lt;/span&gt;&lt;span&gt; ViewData[&quot;Error&quot;] =&lt;/span&gt; &lt;span&gt;DicError;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在基本工作基本都完成了，但我们还忽略了一个问题，我错误是存在了ViewData[&quot;Error&quot;]里传递给View，只不过难道我们在验证错误的时候在页面显示一个错误列表？像li一样？这显然不是我们想要的。我们还需要一个帮助我们合理的显示错误信息的函数。在Razor里我们可以对HtmlHelper进行扩展。于是我为HtmlHelper扩展了一个方法ValidatorMessageFor&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidatorHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString ValidatorMessageFor(&lt;span&gt;this&lt;/span&gt; HtmlHelper htmlHelper, &lt;span&gt;string&lt;/span&gt; property, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; error)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dicError = error &lt;span&gt;as&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dicError == &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有错误&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  不会等于空&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dicError.ContainsKey(property))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MvcHtmlString(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;{0}&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dicError[property]));
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MvcHtmlString(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ValidatorMessaegFor里需要2个参数property 和 error&lt;/p&gt;
&lt;p&gt;前者是需要显示的错误属性名，后者则是错误对象即ViewData[&quot;Error&quot;]，功能很简单，在发现错误对象里存在key未错误属性名的时候返回将value生成一个p标签返回，value即为错误属性所对应的错误提示消息。&lt;/p&gt;
&lt;p&gt;现在我们还需要在View每一个input下添加一句如： @Html.ValidatorMessageFor(&quot;Name&quot;, ViewData[&quot;Error&quot;])即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using (Html.BeginForm())
{
    @Html.AntiForgeryToken()

    &lt;/span&gt;&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-horizontal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;h4&amp;gt;Person&amp;lt;/h4&amp;gt;
        &amp;lt;hr /&amp;gt;&lt;span&gt;
        @Html.ValidationSummary(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { @class = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
        &lt;/span&gt;&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;姓名&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
                @Html.ValidatorMessageFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;年龄&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
                @Html.ValidatorMessageFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;住址&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
                @Html.ValidatorMessageFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;电话&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
                @Html.ValidatorMessageFor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
            &lt;/span&gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;control-label col-md-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;性别&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-offset-2 col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此我们的所有基本工作都已完成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValidatorHub.PersonValidator.Validate(model);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValidatorErrorHandler(result);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过我们在ControllerEx种的ValidatorHub来对实体Person进行校验，如果校验成功了....这里没啥可干的就当跳转一下表示咯，否则的话调用Ex中的ValidatorErrorHandler 将错误消息绑定到ViewData[&quot;Error&quot;]中去，这样就能在前端View渲染的时候将错误消息显示出来了。&lt;/p&gt;
&lt;p&gt;接下来我们将程序跑起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718153108566-2113429133.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718153149993-43953096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718153303808-830400678.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718153323914-1454941948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如大家所看到的，当我点击提交的时候 虽然只有电话没输入但其他三个表单被清空了，也许我们会觉得不爽，当然如果你需要那相信你在看完上述的错误信息绑定后一定也能解决这个问题的，但事实上，我们并不需要它，\(^o^)/~&lt;/p&gt;
&lt;p&gt;为什么呢？因为我们还要前端验证啊，当前端验证没通过的时候根本无法发送到后端来，所以不用担心用户在一部分验证失败时已填写的表单数据被清空掉。&lt;/p&gt;
&lt;p&gt;这里提到在表单提交时需要前端校验，既然有前端校验了为何还要我们做后台校验呢？不是脱了裤子放屁吗？事实上，前端校验的作用在于优化用户体验，减轻服务器压力，也可以防住君子，但绝不能防止小人，由于Web客户端的不确定性，任何东西都可以模拟的。如果不做服务端验证，假如你的系统涉及金钱，也许那天你醒来就发现自己破产了。&lt;/p&gt;

&lt;p&gt; 来一个通过验证的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718154332932-340279504.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180718154351933-1047787290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 07:44:00 +0000</pubDate>
<dc:creator>Gxqsd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gxqsd/p/9329505.html</dc:identifier>
</item>
<item>
<title>【安富莱】【RL-TCPnet网络教程】第7章  RL-TCPnet网络协议栈移植（裸机） - 席萌0209</title>
<link>http://www.cnblogs.com/armfly/p/9329508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/9329508.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章教程为大家讲解RL-TCPnet网络协议栈的裸机移植方式，学习了上个章节讲解的底层驱动接口函数之后，移植就比较容易了，主要是添加库文件、配置文件和驱动文件即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章教程含STM32F407开发板和STM32F429开发板的移植。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.1  移植前准备工作说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.2  STM32F407移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.3  STM32F429移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.4  总结&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;7.1  移植前准备工作说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、学习本章节前，务必要优先学习第6章的底层驱动讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、RL-TCPnet只有库，没有源码。库分为两个版本，一个用于调试的版本TCPD_CM3.lib和一个正式版本TCP_CM3.lib，当前的例子统一使用调试版本。另外注意，虽然是CM3版本的，但可同时用于CM3和CM4内核的MCU，因为官方没有专门的CM4内核库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、测试时，请将网线接到路由器或者交换机上面测试，因为已经使能了DHCP，可以自动获取IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      而且使能了NetBIOS局域网域名，用户只需在电脑端ping armfly，就可以获得板子的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果要使用固定IP进行测试，请看第57章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、网口使用的是DM9161/9162（紧挨着9帧串口座的网口），而不是DM9000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、找一个简单的工程，最好是跑马灯之类的，越简单越好，我们就在这个简单的工程上面移植即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;7.2   STM32F407移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;7.2.1      RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的裸机工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153900929-850294361.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分三步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们裸机模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153915740-991648317.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153921229-845343114.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加完毕后的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153932497-755525991.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：也是最后一步，添加相应的头文件路径。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在原来工程模板的基础上面新添加的三个路径：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153940736-707441063.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.2.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153952233-1190564126.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718153958611-1625570506.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154004808-1896768130.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154014062-1178683029.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154020786-824745091.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154026364-2012084289.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.2.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154041844-1153564556.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的。每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154047994-1935393101.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.2.4     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V5-1000_RL-TCPnet实验_工程移植模板（裸机）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154058809-145128996.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主函数初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在main.c文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{   

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化外设 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进入RL-TCPnet测试函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     TCPnetTest();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

 

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量（必须在 bsp_InitTimer() 之前调用） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitTimer();   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化滴答定时器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcpnet_poll

*    功能说明: 使用TCPnet必须要一直调用的函数

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; tcpnet_poll(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsp_CheckTimer(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 此函数坚决不可以放在中断里面跑 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

     }

    

     main_TcpNet ();

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t ulCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     uint8_t ucKeyCode;

    

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化网络协议栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER | TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

          res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建一个周期是100ms的软定时器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    bsp_StartAutoTimer(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; TCP轮询 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcpnet_poll();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键消息的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ucKeyCode != KEY_NONE)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:            

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:     

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                     

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:            

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，裸机方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.2.5     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F407开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154129289-1855310169.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154139705-499449931.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154144520-1014881537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154150252-832939999.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;7.3  STM32F429移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;7.3.1     RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的裸机工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154204964-1717010151.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分三步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们裸机模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154211550-842220195.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154218329-179765699.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加完毕后的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154226098-839992265.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：也是最后一步，添加相应的头文件路径。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在原来工程模板的基础上面新添加的三个路径：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154231974-1090292925.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.3.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154238849-1320338247.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154245082-1977578778.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154252275-1547779099.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154259932-520727422.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154308352-871485229.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154314940-1355485620.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.3.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154322383-1333388180.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154328482-729013834.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.3.4     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V6-1000_RL-TCPnet实验_工程移植模板（裸机）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154335143-204261368.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主函数初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{   

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化外设 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进入RL-TCPnet测试函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     TCPnetTest();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

    

     SystemCoreClockUpdate();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 根据PLL配置更新系统时钟频率变量 SystemCoreClock &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量（必须在 bsp_InitTimer() 之前调用） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_InitTimer();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化滴答定时器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitExtIO();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; FMC总线上扩展了32位输出IO, 操作LED等外设必须初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcpnet_poll

*    功能说明: 使用TCPnet必须要一直调用的函数

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; tcpnet_poll(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bsp_CheckTimer(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 此函数坚决不可以放在中断里面跑 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

     }

    

     main_TcpNet ();

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t ulCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     uint8_t ucKeyCode;

    

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化网络协议栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER | TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

 

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建一个周期是100ms的软定时器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    bsp_StartAutoTimer(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; TCP轮询 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcpnet_poll();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键消息的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ucKeyCode != KEY_NONE)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:            

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:     

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                     

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:            

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       ulCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            tcpnet_poll();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 ulCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ulCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= ulCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                               

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ulCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，裸机方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7.3.5     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F429开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154351697-695704425.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154357348-1601851271.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154402783-1145908498.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180718154408268-383813522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;7.4  总结&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本章节为大家讲解了RL-TCPnet网络协议栈的裸机移植方法，移植相对比较简单。另一个重要内容是Net_Config.c配置向导文件的说明，这个比较重要，初学者要好好熟悉下。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 07:44:00 +0000</pubDate>
<dc:creator>席萌0209</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/9329508.html</dc:identifier>
</item>
<item>
<title>在 Windows 上可以用 Docker 吗？ - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9327386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9327386.html</guid>
<description>&lt;blockquote readability=&quot;2.0238095238095&quot;&gt;
&lt;p&gt;作者：陈计节&lt;br/&gt;个人博客：&lt;a href=&quot;https://blog.jijiechen.com/post/docker-on-windows/&quot; class=&quot;uri&quot;&gt;https://blog.jijiechen.com/post/docker-on-windows/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt;，或者准确一点说，容器技术，在近几年里几乎成为了应用分发和集群部署的默认技术了。背景部分，如果感兴趣，请参考&lt;a href=&quot;https://segmentfault.com/a/1190000002882567&quot;&gt;闲谈集群管理模式&lt;/a&gt;一文。Docker 生态的成熟还有赖于其周边工具和实践模式的兴起。比如，曾经雨后春笋般出现的编排技术，以及基于容器技术的 DevOps 实践大规模地开展。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_docker.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这么好的技术，在 Windows 上能用吗？在各种场合，都有人与我讨论这个的话题。每次听到这样的疑问，我也是很无奈的。毕竟，只要稍微搜索一下，就不难回答：是可以的。不过，深入想一下，人们有这样的疑问也是有道理的：毕竟 Docker 是起源于 Linux 上的技术。&lt;/p&gt;
&lt;p&gt;Docker 是基于 Linux 内置的 Namespace 和 CGroup 等系统内隔离机制而抽象出来的一种轻虚拟化技术。与虚拟机相比，它以一种轻量级的方式实现了运行空间的隔离。&lt;strong&gt;如果物理机是一幢住宅楼，虚拟机就是大楼中的一个个套间，而容器技术就是套间里的一个个隔断&lt;/strong&gt;。不难理解，Docker 作为一种隔断，它并不能基于一种内核（Linux）提供另一种内核（Windows）的虚拟化运行环境。所以，基于 Linux 的 Docker 是不支持运行 Windows 应用的。&lt;/p&gt;
&lt;p&gt;早在 Docker 之前，Linux 就已经提供了今天的 Docker 所使用的那些基础技术。当年 Docker 仿佛一夜之间突然火爆全球的背后，技术上的积累并不是瞬间完成的。这一切在 Windows 上显得有些滞后。在 Docker 已经众所周知的时候，Windows 系统却根本没有类似的机制，更别提 Windows 独有的工具链和实践方法了。所以，我们看到，早期 Windows 与 Docker 的交集只是为其提供应用开发环境。&lt;/p&gt;
&lt;h2 id=&quot;boot2docker-与-docker-for-windows&quot;&gt;boot2docker 与 Docker for Windows&lt;/h2&gt;
&lt;p&gt;可以在 Windows 开发面向 Docker 部署的应用程序——Windows 的桌面体验比 Linux 好太多，所以很早就出现了在异构操作系统上以虚拟机的形式运行 Docker 的项目出现，也就是 boot2docker。它既支持 Windows，也支持 macOS。&lt;/p&gt;
&lt;p&gt;后来，Docker 公司开始推出自己的 &lt;a href=&quot;https://docs.docker.com/docker-for-windows/&quot;&gt;Docker for Windows&lt;/a&gt; 工具包，它旨在为开发人员在 Windows 上开发面向 Docker 的应用程序提供完整的工具链，其中包括运行环境、客户端，&lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm&lt;/a&gt; 编排工具和其他工具。Docker for Windows 中负责运行环境配置的工具是 &lt;a href=&quot;https://docs.docker.com/machine/overview/&quot;&gt;Docker Machine&lt;/a&gt;。与 boot2docker 类似，Docker Machine 也会在 Windows 上创建一个 Linux 虚拟机，用于运行 Docker 引擎。也就是说，&lt;strong&gt;这个环境也只支持 Linux 的应用程序格式的，并不支持 Windows 应用程序的运行。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_docker-running.png&quot; alt=&quot;在 Windows 上运行的 Docker for Windows（图片来自 Docker 文档）&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-容器技术&quot;&gt;Windows 容器技术&lt;/h2&gt;
&lt;p&gt;正当 Linux 世界的容器技术借着 Docker 的东风刮遍世界的时候，Windows 系统也发现了容器粒度的重要性。 微软与 Docker 在 2014 年&lt;a href=&quot;https://www.docker.com/microsoft&quot;&gt;宣布了合作&lt;/a&gt;，以期将容器技术带到 Windows Server 操作系统，并为传统的 Windows 应用程序的容器化改造提供更直接的支持。不久之后，微软在 &lt;a href=&quot;https://channel9.msdn.com/Events/Ignite/2015/BRK2461&quot;&gt;Ignite 2015&lt;/a&gt; 上宣布将推出为容器优化的 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/get-started/getting-started-with-nano-server&quot;&gt;Windows Nano Server&lt;/a&gt;；第一次 Windows 容器真正与与开发者见面是在 Windows 10 的年度更新（2016.8）上，它正式提供 Windows 容器的开发环境。在 2017 年 10 月发布的 Windows Server 1709 版本包含了 Windows 容器，意味着这项技术可以用于生产环境了。&lt;strong&gt;Windows 容器是真正能够运行 Windows 应用程序的容器技术&lt;/strong&gt;，包括依赖 IIS、注册表等大量 Windows 特性的应用程序都可以在 Windows 容器中运行。&lt;/p&gt;
&lt;p&gt;虽然 Windows 对容器的支持有些姗姗来迟，但社区对 Windows 容器的关注和运用却是异常活跃。这主要得益于容器技术本身生态的成熟，一来人们对这项技术已经有了充分的认知，同时周边工具和实践都已经日趋完善。另一方面，在与 Docker 公司一同打造这项技术的过程中，也注意了与已有技术的兼容性。人们发现，在电脑上启用 Windows Container 功能之后，接下来的操作步骤仍然是基于 Docker 客户端完成的，命令行参数与 Linux 上的 Docker 也没有区别。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_iis-on-docker%20%281%29.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;几乎与 Windows 容器技术本身日趋成熟过程的同时，周边工具对 Windows 容器的支持也在同步完善。Docker for Windows 在新的版本中添加了一个贴心的菜单，可以一键切换 Linux 容器和 Windows 容器；&lt;a href=&quot;https://kubernetes.io/docs/getting-started-guides/windows/&quot;&gt;Kubernetes&lt;/a&gt; 从 1.5 版本开始增加对 Windows 容器的支持；云环境方面，包括 Azure 和 AWS 在内的众多云环境都第一时间提供了 Windows 容器的支持……&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_switch-platform.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-容器架构&quot;&gt;Windows 容器架构&lt;/h2&gt;
&lt;p&gt;Windows 是如何既提供自有容器技术，又提供与 Docker 兼容的操作接口的呢？ 下面的左图是 Linux 容器的架构，右侧则是 Windows 容器的。可以发现两者结构很类似。与 Linux 类似，Windows 也新新抽象出来了 CGroup 和 Namespace 的概念，并提供出一个新的抽象层次 &lt;a href=&quot;https://blogs.technet.microsoft.com/virtualization/2017/01/27/introducing-the-host-compute-service-hcs/&quot;&gt;Compute Service&lt;/a&gt;，即宿主机运算服务（Host Compute Service，hcs）。相较于底层可能经常重构的实现细节，hcs 旨在为外部（比如 Docker 引擎）提供较稳定的操作接口。hcs 的操作接口目前有 &lt;a href=&quot;https://github.com/Microsoft/hcsshim&quot;&gt;Go 语言版本&lt;/a&gt;，以及 &lt;a href=&quot;https://github.com/microsoft/dotnet-computevirtualization&quot;&gt;C# 语言版本&lt;/a&gt;，前者目前在 Docker 客户端中用来操作 Windows 容器。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_arch-linux.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1255906/o_arch-win.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;容器镜像方面，微软自己提供了 Server Core 和 Nano Server 两种服务器版本。Server Core 可以理解为 Windows Server 去掉了 GUI 的部分，因此功能更完整（比如包括文件服务器、DNS 服务器等功能），同时镜像大小也更大（2GB~5GB）；而 Nono Server 则是专为容器优化的迷你型系统，只包含有核心的 Windows 服务器功能，镜像大小为（130MB~400MB）。基于基础镜像来构建自己镜像的方法与 Linux 镜像是一样的，所以 DockerFile 文件的格式和语法并没有不同。 授权方面，只要用户已经取得宿主机的授权，微软并&lt;a href=&quot;https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/images-eula&quot;&gt;不会单独向用户收取容器镜像的授权费&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;容器技术本身以及围绕它的一系列工具和实践让应用程序的打包和发布变得标准化，很大程度上可以消除应用程序对特定环境的依赖，进而为高效的集群化部署和运维提供有力保障。作为容器技术的代表，Docker 可以以两种形式运行在 Windows 上：以 Hyper-V 虚拟机的形式运行 Linux 格式的容器，或者运行原生的 Windows 容器。其中前者运行 Linux 格式的应用程序，后者能运行 Windows 应用程序。如果稍微用一点技巧，还可以让这两者&lt;a href=&quot;https://blogs.msdn.microsoft.com/premier_developer/2018/04/20/running-docker-windows-and-linux-containers-simultaneously/&quot;&gt;同时运行在 Windows 电脑上&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Windows 10 和 Windows Server 都提供了对 Windows 容器的支持，各种容器化工具对 Windows 容器的支持也在日趋完善当中。基于 Windows 开发新的应用时一方面可以优先考虑跨平台容器化部署的能力，另一方面也可以与存量应用程序一样考虑借助 Windows 容器技术实现容器化、云原生的特性。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:26:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9327386.html</dc:identifier>
</item>
<item>
<title>idea快速搭建spring cloud-注册中心与注册 - IT高飞</title>
<link>http://www.cnblogs.com/itgaofei/p/9329375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itgaofei/p/9329375.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Spring Cloud是一个微服务框架，它基于spring boot, Spring Cloud提供的全套的分布式系统解决方案&lt;/strong&gt;。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　首先我们使用gradle来创建：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718110720824-896285392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择JDK以及勾选Java，然后下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718111338556-1698011461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;起包名已经项目名，下一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718112050849-759148283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择我们本地的gradle包，一直下一步，点击build.gradle并添加我们的依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
group 'com.gaofei'&lt;span&gt;
version &lt;/span&gt;'1.0-SNAPSHOT'

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gradle使用的插件&lt;/span&gt;
apply plugin: 'java'
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gradle使用spring-boot打包更方便&lt;/span&gt;
apply plugin: 'spring-boot'


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdk的版本号&lt;/span&gt;
sourceCompatibility = 1.8


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本项目的&lt;/span&gt;
&lt;span&gt;dependencies {
    testCompile group: &lt;/span&gt;'junit', name: 'junit', version: '4.12'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于本次创建gradle未出现src,由以下代码来解决&lt;/span&gt;
task &quot;create-dirs&quot; &amp;lt;&amp;lt;&lt;span&gt; {
    sourceSets&lt;/span&gt;*.java.srcDirs*&lt;span&gt;.each {
        it.mkdirs()
    }
    sourcScts&lt;/span&gt;*.resources.srcDirs*&lt;span&gt;.each{
        it.midirs()
    }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译构建时的配置&lt;/span&gt;
&lt;span&gt;buildscript {
    ext{
        springBootVersion&lt;/span&gt;='1.5.10.RELEASE' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;springBootVersion是自己定义的变量 里面写的是springboot插件的版本&lt;/span&gt;
&lt;span&gt;    }
    repositories {
        maven{ url &lt;/span&gt;'http://maven.aliyun.com/nexus/content/groups/public/'&lt;span&gt;}
        jcenter()
        mavenCentral()
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/snapshot&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/milestone&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/release&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;'http://repo.spring.io/plugins-snapshot'&lt;span&gt; }
    }
    dependencies{
        classpath(&lt;/span&gt;&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指的是springboot的一个插件&lt;/span&gt;
&lt;span&gt;    }
}



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统一所有项目的配置 就是对所有的模块进行统一配置 所有以后的模块都不用再配置&lt;/span&gt;
&lt;span&gt;allprojects {

    group &lt;/span&gt;'com.gaofei' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分组&lt;/span&gt;
    version '1.0-SNAPSHOT' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;
&lt;span&gt;
    ext{
        springCloudVersion&lt;/span&gt;='Edgware.SR2'&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有项目都会引用的阿里云里的maven&lt;/span&gt;
&lt;span&gt;    repositories {
        maven{ url &lt;/span&gt;'http://maven.aliyun.com/nexus/content/groups/public/'&lt;span&gt;}
        jcenter()
        mavenCentral()
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/snapshot&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/milestone&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;&quot;http://repo.spring.io/release&quot;&lt;span&gt; }
        maven{ url &lt;/span&gt;'http://repo.spring.io/plugins-snapshot'&lt;span&gt; }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统一所有子项目的配置&lt;/span&gt;
&lt;span&gt;subprojects {
    apply plugin: &lt;/span&gt;'java'&lt;span&gt;
    apply plugin: &lt;/span&gt;'idea'&lt;span&gt;
    apply plugin: &lt;/span&gt;'spring-boot'&lt;span&gt;

    dependencies {
        compile(&lt;/span&gt;'org.springframework.boot:spring-boot-starter-web'&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用undertow来代替tomacat&lt;/span&gt;
            exclude module:&quot;spring-boot-starter-tomcat&quot;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替代tomcat&lt;/span&gt;
        compile 'org.springframework.boot:spring-boot-starter-undertow'
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;健康检查&lt;/span&gt;
        compile 'org.springframework.boot:spring-boot-starter-actuator'&lt;span&gt;
        dependencies {
            testCompile group: &lt;/span&gt;'junit', name: 'junit', version: '4.12'&lt;span&gt;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本控制插件&lt;/span&gt;
&lt;span&gt;    dependencyManagement{
        imports{
            mavenBom &lt;/span&gt;&quot;org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}&quot;&lt;span&gt;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过注释可以看到各个代码块的作用，这里我们是用阿里云的仓库&lt;/p&gt;
&lt;p&gt;接下来我们开始建eureka注册中心，通过new-&amp;gt;Module再建gradle项目来创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718141458878-1482042654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在build中添加eureka-server依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示自己是一个服务器&lt;/span&gt;
    compile 'org.springframework.cloud:spring-cloud-starter-eureka-server'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在application.yml中配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8000&lt;span&gt;
spring:
  application:
    name: register&lt;/span&gt;-&lt;span&gt;center #起个名字
eureka:
  client:
    register&lt;/span&gt;-with-eureka: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; #启动时不注册表明自己是一个注册中心
    fetch&lt;/span&gt;-registry: &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableEurekaServer&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表明自己是注册中心&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegisterCenterProvider {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        SpringApplication.run(RegisterCenterProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718142519707-1475322201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就表示注册中心启动成功&lt;/p&gt;
&lt;p&gt;下面创建服务注册到服务中心&lt;/p&gt;
&lt;p&gt;创建一个gradle module 项目 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718145134661-1281127576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在build.gradle中添加thymeleaf组件，eureka客户端组件的依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;thymeleaf组件&lt;/span&gt;
    compile  'org.springframework.boot:spring-boot-starter-thymeleaf'
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;eureka客户端组件&lt;/span&gt;
    compile 'org.springframework.cloud:spring-cloud-starter-eureka'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.yml中配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8001&lt;span&gt; 
spring:
  application:
    name: project&lt;/span&gt;-shopping-&lt;span&gt;mall #注册在注册中心的名字，它会进行键值对映射url
  thymeleaf:
    cache: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; #关闭缓存
eureka:
  client:
    service&lt;/span&gt;-&lt;span&gt;url:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000/eureka/ #注册到注册中心&lt;/span&gt;
&lt;span&gt;  instance:
    prefer&lt;/span&gt;-ip-address: &lt;span&gt;true&lt;/span&gt; #用两种方式进行注册，一种是使用主机名注册，一种是使用ip地址进行注册，这里使用ip地址进行注册
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示eureka客户端&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShoppingMallProvider {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ShoppingMallProvider.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428154/201807/1428154-20180718151949878-1292869636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功！&lt;/p&gt;
&lt;p&gt;下几篇会说一下spring cloud中使用的组件&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:24:00 +0000</pubDate>
<dc:creator>IT高飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itgaofei/p/9329375.html</dc:identifier>
</item>
<item>
<title>JAVA NIO原理剖析 - tspeking</title>
<link>http://www.cnblogs.com/tspeking/p/9329243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tspeking/p/9329243.html</guid>
<description>&lt;p&gt;本文不打算讲解BIO怎么用？NIO如何用？本文重点是NIO底层原理。&lt;/p&gt;
&lt;p&gt;本文打算从以下几个方面讲解：&lt;/p&gt;
&lt;p&gt;1、BIO通讯模型（网络方面）是什么？&lt;/p&gt;
&lt;p&gt;2、NIO通讯模型（网络方面）是什么？解决了什么问题？&lt;/p&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;1. BIO通讯模型&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362074/201807/1362074-20180718150443078-649992550.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;模型解释：&lt;/p&gt;
&lt;p&gt;BIO场景下，客户端（Client）发起连接请求，服务端接收到请求后，会分配一个业务线程处理这次访问，执行业务处理，写入响应流。&lt;/p&gt;
&lt;p&gt;无论是服务端还是客户端，数据的读写都是阻塞的。比如，服务端收到客户端的请求，想要获取客户端传过来的请求参数，就会执行读操作，此时，如果由于网络原因导致客户端写入数据慢或者服务端接收数据慢，这个过程会非常耗时，此时应用线程就只能阻塞等待数据可读，这个过程会很浪费CPU资源的。并且，随着用户请求的增多，阻塞队列满了，而应用线程没有释放，就会导致后来的请求被抛弃，得不到处理。&lt;/p&gt;
&lt;p&gt;为什么会出现这种情况？究其原因，服务端执行读数据的操作，本质上是CPU向操作系统内核发出一条指令，让操作系统通过TCP/IP协议，从网络读取数据到内核，再从内核到内存中。CPU执行指令速度非常快，而操作系统执行IO的速度远远赶不上CPU执行指令的速度，就会导致CPU时间的浪费。&lt;/p&gt;

&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;2.NIO通讯模型&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362074/201807/1362074-20180718150519465-451180329.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;p&gt;模型解释：&lt;/p&gt;
&lt;p&gt;NIO场景下，客户端（Client）发起请求，服务端接收请求后，并不是直接分配业务线程处理这次请求，而是交给专门的IO线程（JAVA 中的Selector）读取请求流，当数据准备好以后，才会交给业务线程执行业务逻辑，最后交给IO线程写入响应流。&lt;/p&gt;
&lt;p&gt;到这里，读者可能会有两个疑问？NIO模型下，IO线程会成为瓶颈？NIO解决了什么问题（与BIO相比）？&lt;/p&gt;
&lt;p&gt;IO线程会成为瓶颈吗？这个问题得从IO线程的底层实现说起，NIO之所以是同步非阻塞，就是因为底层操作系统支持同步非阻塞，JVM只是通过系统调用本地方法实现同步非阻塞的（本质上是操作系统实现同步非阻塞，而JVM只是通过本地方法执行系统调用而已）。linux系统提供了epoll系统调用，epoll是基于事件驱动方式来实现的（也就是说，底层操作系统准备好了数据，以事件驱动的机制回调通知），而NIO中的Selector的select（）方法调用，是通过本地方调用epoll系统调用来实现非阻塞的，最大限度利CPU时间片，所以IO线程的瓶颈也就是硬件瓶颈。&lt;/p&gt;
&lt;p&gt;NIO解决了什么问题？&lt;/p&gt;
&lt;p&gt;通过单独的IO线程，当有可读、可写的事件发生的时候再去做读写操作，这个时候就不用像BIO那样一直阻塞等待在那，业务线程就可以被释放出来做更多的事情。说白了，提高了CPU利用率，让更少的线程做更多的事。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:07:00 +0000</pubDate>
<dc:creator>tspeking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tspeking/p/9329243.html</dc:identifier>
</item>
<item>
<title>Xamarin 学习笔记 - Layout（布局） - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/9329222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/9329222.html</guid>
<description>&lt;blockquote readability=&quot;8.4621513944223&quot;&gt;
&lt;p&gt;本文翻译自CodeProject文章：https://www.codeproject.com/Articles/1227733/Xamarin-Notes-Xamarin-Forms-Layouts&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在本篇教程中，我们将了解Xamarin.Forms中几个常用的Layout类型并介绍使用这几种布局类似进行跨平台移动开发时的示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718142903082-2006904129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 align=&quot;left&quot;&gt;StackLayout（栈布局）&lt;/h2&gt;
&lt;p&gt;StackLayout允许您将视图以垂直方向堆叠或以水平方向堆叠，这是最常用的布局。&lt;a href=&quot;https://developer.xamarin.com/guides/xamarin-forms/user-interface/layouts/stack-layout/&quot;&gt;查看文档&lt;/a&gt;以获取更多详细信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;MainLable&quot;&lt;/span&gt;&lt;span&gt;
               HorizontalOptions&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;
               FontSize&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;
               TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Orientation&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;设置 Horizontal 或者 Vertical。默认值是Vertical。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; or &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;LayoutOptions&lt;/strong&gt;&lt;strong&gt;定位&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;视图可以根据相对于布局的视图位置设置为 &lt;strong&gt;VerticalOptions&lt;/strong&gt; 或者 &lt;strong&gt;HorizontalOptions &lt;/strong&gt;，在这一部分我们中，我们将描述如何使用StackLayout面板将视图组装到水平或垂直堆叠中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Aqua&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Aqua&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;在我们的示例中，我们将两个按钮组合成一个水平堆叠效果（如第一张图片所示）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143001747-1404982221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;VerticalOptions&lt;/strong&gt; 以及 &lt;strong&gt;HorizontalOptions&lt;/strong&gt; 使用以下值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Start：该选项将View放置在布局的起始位置。&lt;/li&gt;
&lt;li&gt;End：该选项和Start刚好相反，将View放置在布局的结束位置。&lt;/li&gt;
&lt;li&gt;Fill：该选项将View撑满布局，不留白。&lt;/li&gt;
&lt;li&gt;Center：该选项将视图放置在布局的正中。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;视图是如何在父视图中对齐的？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143023487-126149398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HorizontalOptions&lt;/span&gt;&lt;span&gt;=&quot;Start&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Start&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HorizontalOptions&lt;/span&gt;&lt;span&gt;=&quot;End&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;End&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HorizontalOptions&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HorizontalOptions&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Green&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用C#代码设置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; stack = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StackLayout();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelStart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
        {
            HorizontalOptions &lt;/span&gt;=&lt;span&gt; LayoutOptions.Start,
            BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Blue,
            Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelEnd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
        {
          HorizontalOptions &lt;/span&gt;=&lt;span&gt; LayoutOptions.End,
          BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Red,
          Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelCenter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
       {
        HorizontalOptions &lt;/span&gt;=&lt;span&gt; LayoutOptions.Center,
        BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Yellow,
        Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Center&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelFill = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
      {

    HorizontalOptions &lt;/span&gt;=&lt;span&gt; LayoutOptions.Fill,

    BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Green,

    Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

};

stack.Children.Add(labelStart);

stack.Children.Add(labelEnd);

stack.Children.Add(labelCenter);

        stack.Children.Add(labelFill);

Content &lt;/span&gt;= stack;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143108473-1823367913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;One&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;50&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Two&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Three&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; stack = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StackLayout()
    {
        Orientation &lt;/span&gt;=&lt;span&gt; StackOrientation.Vertical
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelOne = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
    {
        HeightRequest &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
        BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Blue,
        Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;One&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelTwo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
    {
        HeightRequest &lt;/span&gt;= &lt;span&gt;50&lt;/span&gt;&lt;span&gt;,
        BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Red,
        Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Two&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; labelThree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label()
    {
        HeightRequest &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;,
        BackgroundColor &lt;/span&gt;=&lt;span&gt; Color.Yellow,
        Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };

    stack.Children.Add(labelOne);
    stack.Children.Add(labelTwo);
    stack.Children.Add(labelThree);
    Content &lt;/span&gt;= stack;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;可以设置为整数或者小数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143430643-110972530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Gray&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label  &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Start&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;End&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;DarkBlue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Aqua&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们在第一个StackLayout设置了Spacing：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Spacing&lt;/span&gt;&lt;span&gt;=&quot;-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; or 

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Spacing&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143503134-1432718101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Padding 和 Margin&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143559865-2000060232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是一个示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718143615919-1589840409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Gray&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Spacing&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;50,20,100,150&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label  &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Start&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;End&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;DarkBlue&quot;&lt;/span&gt;&lt;span&gt; Spacing&lt;/span&gt;&lt;span&gt;=&quot;50&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Aqua&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;AbsoluteLayout（绝对布局）&lt;/h2&gt;
&lt;p&gt;AbsoluteLayou允许你在指定的绝对位置放置子元素。&lt;/p&gt;
&lt;p&gt;有时，你可能希望更多地控制屏幕上某个对象的位置，比如说，你希望将它们锚定到屏幕的边缘，或者希望覆盖住多个元素。&lt;/p&gt;
&lt;p&gt;在AbsoluteLayou中，我们会使用最重要的四个值以及八个设置选项。&lt;/p&gt;
&lt;p&gt;四个值是由X、Y、Width、Height组成，通过这四个值可以为你的布局进行定位，它们中的每一个都可以被设置为比例值或绝对值。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;可以是绝对值（以像素为单位）或者比例值（从0到1）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;位置：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;　　X：视图锚定位置的水平位置。&lt;/li&gt;
&lt;li&gt;　　Y：视图锚定位置的垂直位置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尺寸：&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;　　Width：定义当前视图的宽度。&lt;/li&gt;
&lt;li&gt;　　Height：定义当前视图的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值被指定为边界和一个标志的组合。LayoutBounds是由四个值组成的矩形：x，y，宽度和高度。&lt;/p&gt;
&lt;h3&gt;设置选项&lt;/h3&gt;
&lt;p&gt;可以是绝对值Absolute标志（以像素为单位）或者比例值Proportional标志（从0到1）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;None：全部的数值是绝对值（数值以像素为单位）。&lt;/li&gt;
&lt;li&gt;All：表示布局边界的全部数值均表示一个比例值（数值从0到1）。&lt;/li&gt;
&lt;li&gt;WidthProportional：表示宽度是比例值，而其它的数值以绝对值表示。&lt;/li&gt;
&lt;li&gt;HeightProportional：表示高度是比例值，而其它的数值以绝对值表示。&lt;/li&gt;
&lt;li&gt;XProportional：表示X坐标值是比例值，而将其它的数值作为绝对值对待。&lt;/li&gt;
&lt;li&gt;YProportional：表示Y坐标值是比例值，而将其它的数值作为绝对值对待。&lt;/li&gt;
&lt;li&gt;PositionProportional：表示X和Y的坐标值是比例值，而将表示尺寸的数值作为绝对值表示。&lt;/li&gt;
&lt;li&gt;SizeProportional：表示Width和Height的值是比例值，而表示位置的数值是绝对值。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;更多详细内容请参见&lt;a href=&quot;https://www.youtube.com/watch?v=FwzoDS3zL_4&quot; target=&quot;_blank&quot;&gt;本链接&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;结构：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AbsoluteLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Olive&quot;&lt;/span&gt;&lt;span&gt;

               AbsoluteLayout.LayoutBounds&lt;/span&gt;&lt;span&gt;=&quot;X, Y, Width, Height&quot;&lt;/span&gt;&lt;span&gt;

               AbsoluteLayout.LayoutFlags&lt;/span&gt;&lt;span&gt;=&quot;FlagsValue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;AbsoluteLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Proportional&lt;/strong&gt; &lt;strong&gt;比例示例&lt;/strong&gt; &lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt;

                 AbsoluteLayout.LayoutBounds&lt;/span&gt;&lt;span&gt;=&quot;0, 0, 0.1, 0.5&quot;&lt;/span&gt;&lt;span&gt;

                 AbsoluteLayout.LayoutFlags&lt;/span&gt;&lt;span&gt;=&quot;All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Proportional&lt;/strong&gt; &lt;strong&gt;比例示例&lt;/strong&gt; &lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt;

               AbsoluteLayout.LayoutBounds&lt;/span&gt;&lt;span&gt;=&quot;0, 0, 1, 0.5&quot;&lt;/span&gt;&lt;span&gt;

               AbsoluteLayout.LayoutFlags&lt;/span&gt;&lt;span&gt;=&quot;All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Absolute&lt;/strong&gt; &lt;strong&gt;绝对值示例&lt;/strong&gt; &lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt;

                   AbsoluteLayout.LayoutBounds&lt;/span&gt;&lt;span&gt;=&quot;0, 75, 250, 410&quot;&lt;/span&gt;&lt;span&gt;

                   AbsoluteLayout.LayoutFlags&lt;/span&gt;&lt;span&gt;=&quot;None&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145132462-1564147353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145141137-913770279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;RelativeLayout（相对布局）&lt;/h2&gt;

&lt;p&gt;RelativeLayout使用约束来对子视图进行布局。更多详细信息请参见&lt;a href=&quot;https://developer.xamarin.com/guides/android/user_interface/layouts/relative-layout/&quot; target=&quot;_blank&quot;&gt;此链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;与AbsoluteLayout类似，在使用RelativeLayout时，我们可以将元素叠加在一起，但是它比AbsoluteLayout更加强大，因为你可以将相对于另一个元素的位置或大小的约束应用于一个元素。它提供了与元素位置和大小相关的更多控制。&lt;/p&gt;
&lt;p&gt;以下是一个示例：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;约束&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Type：它定义了约束是相对于父还是另一个视图，我们可以使用以下值：RelativeToParent或Constant或RelativeToView。&lt;/li&gt;
&lt;li&gt;Property：它定义了我们需要使用哪个属性作为约束的基础。它的值可以是Width或Height或者X再或者Y。&lt;/li&gt;
&lt;li&gt;Factor：被用来应用属性的值，该值是一个小数，介于0和1之间，可以写成0.5e5的格式。&lt;/li&gt;
&lt;li&gt;Constant：可以被用作指示一个偏移量的值。&lt;/li&gt;
&lt;li&gt;ElementName：该约束相对于的视图的名称，如果我们使用关联到某个视图的约束关系的话。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Gray&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt; 

                    RelativeLayout.WidthConstraint&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ConstraintExpression 
                    Type=RelativeToParent,
                    Property=Width,
                    Factor=1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;35&quot;&lt;/span&gt;&lt;span&gt; 

                        x:Name&lt;/span&gt;&lt;span&gt;=&quot;ImageCircleBack&quot;&lt;/span&gt;&lt;span&gt; 

                        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; 

                        HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;70&quot;&lt;/span&gt;&lt;span&gt; WidthRequest&lt;/span&gt;&lt;span&gt;=&quot;70&quot;&lt;/span&gt;&lt;span&gt; 

                        RelativeLayout.XConstraint&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=.5, Constant = -35}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 

                        RelativeLayout.YConstraint&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ConstraintExpression Type=RelativeToParent, Factor=0, Property=Y, Constant=70}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Hamida REBAÏ&quot;&lt;/span&gt;&lt;span&gt; FontAttributes&lt;/span&gt;&lt;span&gt;=&quot;Bold&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;26&quot;&lt;/span&gt;&lt;span&gt; HorizontalTextAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; 

                       RelativeLayout.YConstraint&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ConstraintExpression Type=RelativeToParent, Property=Y, Factor=0, Constant=140}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 

                       RelativeLayout.WidthConstraint&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ConstraintExpression Type=RelativeToParent, Property=Width, Factor=1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ScrollView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以得到以下结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145451080-1376442066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145457090-801742969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Grid（网格布局）&lt;/h2&gt;
&lt;p&gt;Grid和一个表格一样。它比StackLayout更加通用，提供列和行两个维度以供辅助定位。在不同行之间对齐视图也很容易。实际使用起来与WPF的Grid非常类似甚至说没什么区别。&lt;/p&gt;
&lt;p&gt;在这一部分，我们将学习如何创建一个Grid并指定行和列。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145524910-1770294003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;7&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;9&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Grid.ColumnSpan&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

       BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;

       FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#FFA500&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;X&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#0000ff&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;-&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#8000ff&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;+&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#0080ff&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;C&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#808080&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;=&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.ColumnSpan&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;

        BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;#000066&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt;

        FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们首先在Grid中使用这些标记定义行数和列数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; 在此之后，我们将在其中排布视图&lt;/p&gt;
&lt;p&gt; 例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;7&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; TextColor&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;36&quot;&lt;/span&gt;&lt;span&gt; BorderRadius&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该按钮将被放置在第二行（Grid.Row=&quot;1&quot;）第一列（Grid.Column=&quot;0&quot;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145727906-479817400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145737016-124084915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Height属性定义行的高度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;Auto&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该值可以是Auto或者100或者星号（*），我们可以指定2*（甚至n*）。&lt;/p&gt;
&lt;p&gt;使用Width属性定义列的宽度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该值可以是Auto或者100或者星号（*），我们可以指定2*（甚至n*）。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;Auto&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;2*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Label &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; BackgroundColor&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145908698-240324413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;ScrollView&lt;/h2&gt;
&lt;p&gt;ScrollView是一个可以滚动的内容。&lt;/p&gt;
&lt;p&gt;如果不使用ScrollView：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Green&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Firebrick&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;YellowGreen&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718145953101-668860633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在以上示例中，颜色为Yellow Green的BoxView将不显示，然后我们向其中添加一个ScrollView，通过滚动，我们就可以看到全部的内容。ScrollView将向界面UI添加一个滚动指示器。当我们需要指定水平滚动或者垂直滚动，再或者双向滚动时，我们可以使用到Orientation属性。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollView &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; or &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollView &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Vertical&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; or &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollView &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Both&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ScrollView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Green&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;Firebrick&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoxView &lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;=&quot;YellowGreen&quot;&lt;/span&gt;&lt;span&gt; HeightRequest&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ScrollView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/139239/201807/139239-20180718150018621-2000601417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多详细信息，请参见&lt;a href=&quot;https://developer.xamarin.com/guides/xamarin-forms/user-interface/layouts/scroll-view/&quot; target=&quot;_blank&quot;&gt;此链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ScrollView通常被用来显示一个列表（ListView）。&lt;/p&gt;
&lt;p&gt;下篇文章我们将说一说Page（页面）相关的内容。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:03:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/9329222.html</dc:identifier>
</item>
<item>
<title>fork/join 全面剖析 - 浮云骑士LIN</title>
<link>http://www.cnblogs.com/linlinismine/p/9295701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linlinismine/p/9295701.html</guid>
<description>&lt;p&gt;    &lt;strong&gt;fork/join作为一个并发框架在jdk7的时候就加入到了我们的java并发包java.util.concurrent中，并且在java 8 的lambda并行流中充当着底层框架的角色。这样一个优秀的框架设计，我自己想了解一下它的底层代码是如何实现的，所以我尝试的去阅读了JDK相关的源码。下面我打算分享一下阅读完之后的心得~。&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;span&gt; 1、fork/join的设计思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;        了解一个框架的第一件事，就是先了解别人的设计思路!&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201807/905730-20180711145448299-68610441.png&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    fork/join大体的执行过程就如上图所示，先把一个大任务分解(fork)成许多个独立的小任务，然后起多线程并行去处理这些小任务。处理完得到结果后再进行合并(join)就得到我们的最终结果。显而易见的这个框架是借助了现代计算机多核的优势并行去处理数据。这看起来好像没有什么特别之处，这个套路很多人都会，并且工作中也会经常运用~。其实fork/join的最特别之处在于它还运用了一种叫work-stealing(工作窃取)的算法，这种算法的设计思路在于把分解出来的小任务放在多个双端队列中，而线程在队列的头和尾部都可获取任务。当有线程把当前负责队列的任务处理完之后，它还可以从那些还没有处理完的队列的尾部窃取任务来处理，这连线程的空余时间也充分利用了！。&lt;/strong&gt;work-stealing原理图如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201807/905730-20180711154403541-918084876.png&quot; alt=&quot;工作窃取&quot; width=&quot;231&quot; height=&quot;200&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;     2、实现fork/join  定义了哪些角色？。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      &lt;span&gt; 了解设计原理，这仅仅是第一步！要了解别人整个的实现思路， 还需要了解别人为了实现这个框架定义了哪些角色，并了解这些角色的职责范围是什么的。因为知道谁负责了什么，谁做什么，这样整个逻辑才能串起来！在JAVA里面角色是以类的形式定义的,而了解类的行为最直接的方式就是看定义的公共方法~。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt;&lt;strong&gt;这里介绍JDK里面与fork/join相关的主要几个类：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         ForkJoinPool：充当fork/join框架里面的管理者，最原始的任务都要交给它才能处理。它负责控制整个fork/join有多少个workerThread，workerThread的创建，激活都是由它来掌控。它还负责workQueue队列的创建和分配，每当创建一个workerThread，它负责分配相应的workQueue。然后&lt;/strong&gt;&lt;strong&gt;它把接到的活都交给workerThread去处理，它可以说是整个frok/join的容器。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        ForkJoinWorkerThread：fork/join里面真正干活的&quot;工人&quot;，本质是一个线程。里面有一个ForkJoinPool.WorkQueue的队列存放着它要干的活，接活之前它要向ForkJoinPool注册(registerWorker)，拿到相应的workQueue。然后就从workQueue里面拿任务出来处理。它是依附于&lt;/strong&gt;ForkJoinPool而存活，如果&lt;strong&gt;ForkJoinPool的销毁了,它也会跟着结束。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       ForkJoinPool.WorkQueue: 双端队列就是它，它负责存储接收的任务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       ForkJoinTask：代表fork/join里面任务类型，我们一般用它的两个子类RecursiveTask、RecursiveAction。这两个区别在于RecursiveTask任务是有返回值，RecursiveAction没有返回值。任务的处理逻辑包括任务的切分都集中在compute()方法里面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    3、fork/join初始化时做了什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     大到一个系统，小到一个框架，初始化工作往往是体现逻辑的一个重要地方！因为这是开始的地方，后面的逻辑会有依赖！所以把初始化看明白了，后面很多逻辑就容易理解多了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    下面上一段代码，(ps:这段代码是在网上找到的，并做了一小部分的修改)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class CountTask extends RecursiveTask&amp;lt;Integer&amp;gt; {

    private static final int THRESHOLD = 2; //阀值
    private int start;
    private int end;

    public CountTask(int start,int end){
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
         int sum = 0;
         boolean canCompute = (end - start) &amp;lt;= THRESHOLD;
         if(canCompute){
             for(int i = start; i &amp;lt;= end; i++){
                 sum += i;
             }
         }else{
             int middle = (start + end) / 2;
             CountTask leftTask = new CountTask(start,middle);
             CountTask rightTask = new CountTask(middle + 1,end);
             //执行子任务
             leftTask.fork();
             rightTask.fork();
             //等待子任务执行完，并得到其结果
             Integer rightResult = rightTask.join();
             Integer leftResult = leftTask.join();
             //合并子任务
             sum = leftResult + rightResult;
         }
         return sum;
    }
    
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        CountTask countTask = new CountTask(1,200);
        ForkJoinTask&amp;lt;Integer&amp;gt; forkJoinTask = forkJoinPool.submit(countTask);
        System.out.println(forkJoinTask.get());
    }
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    代码的执行过程解释起来也是很简单就是把[1,200]，分成[1,100],[101,200],然后再对每个部分进行一个递归分解最终分解成[1,2],[3,4],[5,6].....[199,200]独立的小任务，然后两两求和合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;    &lt;/strong&gt;&lt;strong&gt;  其实显然易见负责整个fork/join初始化工作的就是ForkJoinPool！初始化代码就是那一行 ForkJoinPool forkJoinPool = new ForkJoinPool(),点进去查看源码。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ForkJoinPool forkJoinPool = new ForkJoinPool();
//最终调用到这段代码 
public ForkJoinPool(int parallelism, 
                    ForkJoinWorkerThreadFactory factory, 
                    UncaughtExceptionHandler handler, 
                    boolean asyncMode) { 
    this(checkParallelism(parallelism), //并行度,当前机器的cpu核数
            checkFactory(factory), //工作线程创建工厂
            handler, //异常处理handler
            asyncMode ? FIFO_QUEUE : LIFO_QUEUE, //任务队列出队模式 异步：先进先出，同步：后进先出
            &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);
    checkPermission();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    看完初始化的代码我们可以知道原来创建&lt;/strong&gt;ForkJoinPool创建workerThread的工作都是统一由一个叫ForkJoinWorkerThreadFactory的工厂去创建，创建出来的线程都有一个统一的前辍名称&quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;.&lt;strong&gt;队列出队模式是LIFO(后进先出)，那这样后面的入队的任务是会被先处理的。所以上面提到对代码做了一些修改就是先处理rightTask，再处理leftTask。这其实是对代码的一种优化！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    //执行子任务
     leftTask.fork();
     rightTask.fork();
 
     Integer rightResult = rightTask.join();
     Integer leftResult = leftTask.join();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、任务的提交逻辑？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;span&gt;  fork/join其实大部分逻辑处理操作都集中在提交任务和处理任务这两块，了解任务的提交基本上后面就很容易理解了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    fork/join提交任务主要分为两种：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    第一种:第一次提交到forkJoinPool &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
     ForkJoinTask&amp;lt;Integer&amp;gt; forkJoinTask = forkJoinPool.submit(countTask);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　 第二种:任务切分之后的提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
     leftTask.fork();
     rightTask.fork();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;  &lt;span&gt; 提交到forkJoinPool :&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   代码调用路径&lt;/strong&gt;&lt;strong&gt; submit(ForkJoinTask&amp;lt;T&amp;gt; task) -&amp;gt;  externalPush(ForkJoinTask&amp;lt;?&amp;gt; task)  -&amp;gt;  externalSubmit(ForkJoinTask&amp;lt;?&amp;gt; task)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   下面贴上externalSubmit的详细代码，着重留意注释的部分。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 private void externalSubmit(ForkJoinTask&amp;lt;?&amp;gt; task) {
        int r;                                    // initialize caller's probe
        if ((r = ThreadLocalRandom.getProbe()) == 0) {
            ThreadLocalRandom.localInit();
            r = ThreadLocalRandom.getProbe();
        }
        for (;;) { //采用循环入队的方式
            WorkQueue[] ws; WorkQueue q; int rs, m, k;
            boolean move = false;
            if ((rs = runState) &amp;lt; 0) {
                tryTerminate(false, false);     // help terminate 
                throw new RejectedExecutionException();
            }
            else if ((rs &amp;amp; STARTED) == 0 ||     // initialize 初始化操作
                     ((ws = workQueues) == null || (m = ws.length - 1) &amp;lt; 0)) {
                int ns = 0;
                rs = lockRunState();
                try {
                    if ((rs &amp;amp; STARTED) == 0) {
                        U.compareAndSwapObject(this, STEALCOUNTER, null,
                                               new AtomicLong());
                        // create workQueues array with size a power of two 
                        int p = config &amp;amp; SMASK; // ensure at least 2 slots //config就是cpu的核数
                        int n = (p &amp;gt; 1) ? p - 1 : 1;
                        n |= n &amp;gt;&amp;gt;&amp;gt; 1; n |= n &amp;gt;&amp;gt;&amp;gt; 2;  n |= n &amp;gt;&amp;gt;&amp;gt; 4;
                        n |= n &amp;gt;&amp;gt;&amp;gt; 8; n |= n &amp;gt;&amp;gt;&amp;gt; 16; n = (n + 1) &amp;lt;&amp;lt; 1; //算出workQueues的大小n,n一定是2的次方数
                        workQueues = new WorkQueue[n];  //初始化队列，然后跳到最外面的循环继续把任务入队~
                        ns = STARTED;
                    }
                } finally {
                    unlockRunState(rs, (rs &amp;amp; ~RSLOCK) | ns);
                }
            }
            else if ((q = ws[k = r &amp;amp; m &amp;amp; SQMASK]) != null) { //选中了一个一个非空队列
                if (q.qlock == 0 &amp;amp;&amp;amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) { //利用cas操作加锁成功！
                    ForkJoinTask&amp;lt;?&amp;gt;[] a = q.array;
                    int s = q.top;
                    boolean submitted = false; // initial submission or resizing
                    try {                      // locked version of push
                        if ((a != null &amp;amp;&amp;amp; a.length &amp;gt; s + 1 - q.base) ||
                            (a = q.growArray()) != null) {
                            int j = (((a.length - 1) &amp;amp; s) &amp;lt;&amp;lt; ASHIFT) + ABASE; //计算出任务在队列中的位置
                            U.putOrderedObject(a, j, task);  //把任务放在队列中
                            U.putOrderedInt(q, QTOP, s + 1); //更新一次存放的位置
                            submitted = true;
                        }
                    } finally {
                        U.compareAndSwapInt(q, QLOCK, 1, 0); //利用cas操作释放锁！
                    }
                    if (submitted) {
                        signalWork(ws, q);
                        return; //任务入队成功了！跳出循环！
                    }
                }
                move = true;                   // move on failure
            }
            else if (((rs = runState) &amp;amp; RSLOCK) == 0) { // create new queue 选中的队列是空，初始化完队列，然后继续入队！
                q = new WorkQueue(this, null);
                q.hint = r;
                q.config = k | SHARED_QUEUE;
                q.scanState = INACTIVE;
                rs = lockRunState();           // publish index
                if (rs &amp;gt; 0 &amp;amp;&amp;amp;  (ws = workQueues) != null &amp;amp;&amp;amp;
                    k &amp;lt; ws.length &amp;amp;&amp;amp; ws[k] == null)
                    ws[k] = q;                 // else terminated
                unlockRunState(rs, rs &amp;amp; ~RSLOCK);
            }
            else
                move = true;                   // move if busy
            if (move)
                r = ThreadLocalRandom.advanceProbe(r);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　  通过对externalSubmit方法的代码进行分析，我们知道了第一次提交任务给&lt;/strong&gt;forkJoinPool时是在无限循环for (;;)&lt;strong&gt;中入队。第一步先检查workQueues是不是还没有创建，如果没有，则进行创建。之后跳到外层for循环并随机选取&lt;/strong&gt;workQueues里面一个队列，并判断队列是否已创建。没有创建，则进行创建！后又跳到外层for循环直到选到一个非空队列并且加锁成功！这样最后才把任务入队~。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     所以我们知道fork/join的任务队列workQueues并不是初始化的时候就创建好了，而是在有任务提交的时候才创建！并且每次入队时都需要利用cas操作来进行加锁和释放锁！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  &lt;span&gt;   任务切分之后的提交：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  public final ForkJoinTask&amp;lt;V&amp;gt; fork() {
        Thread t;
        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
            ((ForkJoinWorkerThread)t).workQueue.push(this); //workerThread直接入自己的workQueue
        else
            ForkJoinPool.common.externalPush(this);
        return this;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
final void externalPush(ForkJoinTask&amp;lt;?&amp;gt; task) {
        WorkQueue[] ws; WorkQueue q; int m;
        int r = ThreadLocalRandom.getProbe();
        int rs = runState;
        if ((ws = workQueues) != null &amp;amp;&amp;amp; (m = (ws.length - 1)) &amp;gt;= 0 &amp;amp;&amp;amp;
            (q = ws[m &amp;amp; r &amp;amp; SQMASK]) != null &amp;amp;&amp;amp; r != 0 &amp;amp;&amp;amp; rs &amp;gt; 0 &amp;amp;&amp;amp;
            U.compareAndSwapInt(q, QLOCK, 0, 1)) { //随机选取了一个非空队列，并且加锁成功！下面是普通的入队过程~
            ForkJoinTask&amp;lt;?&amp;gt;[] a; int am, n, s;
            if ((a = q.array) != null &amp;amp;&amp;amp;
                (am = a.length - 1) &amp;gt; (n = (s = q.top) - q.base)) {
                int j = ((am &amp;amp; s) &amp;lt;&amp;lt; ASHIFT) + ABASE;
                U.putOrderedObject(a, j, task);
                U.putOrderedInt(q, QTOP, s + 1);
                U.putIntVolatile(q, QLOCK, 0);
                if (n &amp;lt;= 1)
                    signalWork(ws, q);
                return; //结束方法
            }
            U.compareAndSwapInt(q, QLOCK, 1, 0); //一定要释放锁！
        }&lt;br/&gt;//这个就是上面的externalSummit方法，逻辑是一样的~
        externalSubmit(task);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　从代码中我们知道了提交一个fork任务的过程和第一次提交到forkJoinPool的过程是大同小异的。主要区分了提交任务的线程是不是workerThread，如果是，任务直接入workerThread当前的workQueue，不是则尝试选中一个workQueue q。如果q非空并且加锁成功则进行入队，否则执行与&lt;/strong&gt;第一次任务提交到forkJoinPool差不多的逻辑~。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     5、任务的消费&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        提交到任务的最终目的，是为了消费任务并最终获取到我们想要的结果。介绍任务消费之前我们先了解一个我们的任务ForkJoinTask有哪些关键属性和方法。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    /** The run status of this task */
    volatile int status; // accessed directly by pool and workers
    static final int DONE_MASK   = 0xf0000000;  // mask out non-completion bits
    static final int NORMAL      = 0xf0000000;  // must be negative
    static final int CANCELLED   = 0xc0000000;  // must be &amp;lt; NORMAL
    static final int EXCEPTIONAL = 0x80000000;  // must be &amp;lt; CANCELLED
    static final int SIGNAL      = 0x00010000;  // must be &amp;gt;= 1 &amp;lt;&amp;lt; 16
    static final int SMASK       = 0x0000ffff;  // short bits for tags
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  final int doExec() { //任务的执行入口
    int s; boolean completed;
    if ((s = status) &amp;gt;= 0) {
        try {
            completed = exec();
        } catch (Throwable rex) {
            return setExceptionalCompletion(rex);
        }
        if (completed)
            s = setCompletion(NORMAL);
    }
    return s;
   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;  再看一下RecursiveTask的定义  &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public abstract class RecursiveTask&amp;lt;V&amp;gt; extends ForkJoinTask&amp;lt;V&amp;gt; {
    private static final long serialVersionUID = 5232453952276485270L;

    /**
     * The result of the computation.
     */
    V result;

    /**
     * The main computation performed by this task.
     * @return the result of the computation
     */
    protected abstract V compute(); //我们实现的处理逻辑

    public final V getRawResult() { //获取返回计算结果
        return result;
    }

    protected final void setRawResult(V value) {
        result = value;
    }
    /**
     * Implements execution conventions for RecursiveTask.
     */
    protected final boolean exec() {
        result = compute(); //存储计算结果
        return true;
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在代码中我们看到任务的真正执行链路是 doExec -&amp;gt; exec -&amp;gt; compute -&amp;gt; 最后设置status 和 result。既然定义状态status并且还是volatile类型我们可以推断出workerThread在获取到执行任务之后都会先判断status是不是已完成或者异常状态，才决定要不要处理该任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      下面看一下任务真正的处理逻辑代码！&lt;/strong&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  Integer rightResult = rightTask.join()
   
    public final V join() {
        int s;
        if ((s = doJoin() &amp;amp; DONE_MASK) != NORMAL)
            reportException(s);
        return getRawResult();
     }
 
    //执行处理前先判断staus是不是已完成，如果完成了就直接返回
   //因为这个任务可能被其它线程窃取过去处理完了
    private int doJoin() {
        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
        return (s = status) &amp;lt; 0 ? s :
            ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
            (w = (wt = (ForkJoinWorkerThread)t).workQueue).
            tryUnpush(this) &amp;amp;&amp;amp; (s = doExec()) &amp;lt; 0 ? s :
            wt.pool.awaitJoin(w, this, 0L) :
            externalAwaitDone();
    }  
 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;strong&gt;代码的调用链是从上到下。整体处理逻辑如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     线程是workerThread：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     先判断任务是否已经处理完成，任务完成直接返回，没有则直接尝试出队tryUnpush(this) 然后执行任务处理doExec()。如果没有出队成功或者处理成功，则执行wt.pool.awaitJoin(w, this, 0L)。wt.pool.awaitJoin(w, this, 0L)的处理逻辑简单来说也是在一个for(;;）中不断的轮询任务的状态是不是已完成，完成就直接退出方法。否就继续尝试出队处理。直到任务完成或者超时为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   线程不是workerThread:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   直接进行入externalAwaitDone()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 private int externalAwaitDone() {
        int s = ((this instanceof CountedCompleter) ? // try helping
                 ForkJoinPool.common.externalHelpComplete(
                     (CountedCompleter&amp;lt;?&amp;gt;)this, 0) :
                 ForkJoinPool.common.tryExternalUnpush(this) ? doExec() : 0);
        if (s &amp;gt;= 0 &amp;amp;&amp;amp; (s = status) &amp;gt;= 0) {
            boolean interrupted = false;
            do {
                if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {
                    synchronized (this) {
                        if (status &amp;gt;= 0) {
                            try {
                                wait(0L);
                            } catch (InterruptedException ie) {
                                interrupted = true;
                            }
                        }
                        else
                            notifyAll();
                    }
                }
            } while ((s = status) &amp;gt;= 0);
            if (interrupted)
                Thread.currentThread().interrupt();
        }
        return s;
   
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    externalAwaitDone的处理逻辑其实也比较简单，当前线程自己先尝试把任务出队ForkJoinPool.common.tryExternalUnpush(this) ? doExec()然后处理掉，如果不成功就交给workerThread去处理，然后利用object/wait的经典方法去监听任务status的状态变更。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;&lt;strong&gt;  6、任务的窃取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;        &lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;一直说fork/join的任务是&lt;strong&gt;work-stealing(工作窃取)，那任务究竟是怎么被窃取的呢。我们分析一下任务是由workThread来窃取的，workThread是一个线程。线程的所有逻辑都是由run()方法执行，所以任务的窃取逻辑一定在run()方法中可以找到！&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public void run() { //线程run方法
        if (workQueue.array == null) { // only run once
            Throwable exception = null;
            try {
                onStart();
                pool.runWorker(workQueue);  //在这里处理任务队列！
            } catch (Throwable ex) {
                exception = ex;
            } finally {
                try {
                    onTermination(exception);
                } catch (Throwable ex) {
                    if (exception == null)
                        exception = ex;
                } finally {
                    pool.deregisterWorker(this, exception);
                }
            }
        }
    }

   /**
     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.
     */
    final void runWorker(WorkQueue w) {
        w.growArray();                   // allocate queue  进行队列的初始化
        int seed = w.hint;               // initially holds randomization hint
        int r = (seed == 0) ? 1 : seed;  // avoid 0 for xorShift
        for (ForkJoinTask&amp;lt;?&amp;gt; t;;) { //又是无限循环处理任务！
            if ((t = scan(w, r)) != null) //在这里获取任务！
                w.runTask(t);
            else if (!awaitWork(w, r))
                break;
            r ^= r &amp;lt;&amp;lt; 13; r ^= r &amp;gt;&amp;gt;&amp;gt; 17; r ^= r &amp;lt;&amp;lt; 5; // xorshift
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;其实只要看下面的英文注释就知道了大概scan(WorkQueue w, int r)就是用来窃取任务的！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;60&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Scans for and tries to steal a top-level task. Scans start at a
     * random location, randomly moving on apparent contention,
     * otherwise continuing linearly until reaching two consecutive
     * empty passes over all queues with the same checksum (summing
     * each base index of each queue, that moves on each steal), at
     * which point the worker tries to inactivate and then re-scans,
     * attempting to re-activate (itself or some other worker) if
     * finding a task; otherwise returning null to await work.  Scans
     * otherwise touch as little memory as possible, to reduce
     * disruption on other scanning threads.
     *
     * @param w the worker (via its WorkQueue)
     * @param r a random seed
     * @return a task, or null if none found
     */
    private ForkJoinTask&amp;lt;?&amp;gt; scan(WorkQueue w, int r) {
        WorkQueue[] ws; int m;
        if ((ws = workQueues) != null &amp;amp;&amp;amp; (m = ws.length - 1) &amp;gt; 0 &amp;amp;&amp;amp; w != null) {
            int ss = w.scanState;                     // initially non-negative
            for (int origin = r &amp;amp; m, k = origin, oldSum = 0, checkSum = 0;;) {
                WorkQueue q; ForkJoinTask&amp;lt;?&amp;gt;[] a; ForkJoinTask&amp;lt;?&amp;gt; t;
                int b, n; long c;
                if ((q = ws[k]) != null) {   //随机选中了非空队列 q
                    if ((n = (b = q.base) - q.top) &amp;lt; 0 &amp;amp;&amp;amp;
                        (a = q.array) != null) {      // non-empty
                        long i = (((a.length - 1) &amp;amp; b) &amp;lt;&amp;lt; ASHIFT) + ABASE;  //从尾部出队,b是尾部下标
                        if ((t = ((ForkJoinTask&amp;lt;?&amp;gt;)
                                  U.getObjectVolatile(a, i))) != null &amp;amp;&amp;amp;
                            q.base == b) {
                            if (ss &amp;gt;= 0) {
                                if (U.compareAndSwapObject(a, i, t, null)) { //利用cas出队
                                    q.base = b + 1;
                                    if (n &amp;lt; -1)       // signal others
                                        signalWork(ws, q); 
                                    return t;  //出队成功，成功窃取一个任务！
                                }
                            }
                            else if (oldSum == 0 &amp;amp;&amp;amp;   // try to activate 队列没有激活，尝试激活
                                     w.scanState &amp;lt; 0)
                                tryRelease(c = ctl, ws[m &amp;amp; (int)c], AC_UNIT);
                        }
                        if (ss &amp;lt; 0)                   // refresh
                            ss = w.scanState;
                        r ^= r &amp;lt;&amp;lt; 1; r ^= r &amp;gt;&amp;gt;&amp;gt; 3; r ^= r &amp;lt;&amp;lt; 10; 
                        origin = k = r &amp;amp; m;           // move and rescan
                        oldSum = checkSum = 0;
                        continue;
                    }
                    checkSum += b;
                }&lt;br/&gt;//k = k + 1表示取下一个队列 如果（k + 1） &amp;amp; m == origin表示 已经遍历完所有队列了
                if ((k = (k + 1) &amp;amp; m) == origin) {    // continue until stable  
                    if ((ss &amp;gt;= 0 || (ss == (ss = w.scanState))) &amp;amp;&amp;amp; 
                        oldSum == (oldSum = checkSum)) {
                        if (ss &amp;lt; 0 || w.qlock &amp;lt; 0)    // already inactive
                            break;
                        int ns = ss | INACTIVE;       // try to inactivate
                        long nc = ((SP_MASK &amp;amp; ns) |
                                   (UC_MASK &amp;amp; ((c = ctl) - AC_UNIT)));
                        w.stackPred = (int)c;         // hold prev stack top
                        U.putInt(w, QSCANSTATE, ns);
                        if (U.compareAndSwapLong(this, CTL, c, nc))
                            ss = ns;
                        else
                            w.scanState = ss;         // back out
                    }
                    checkSum = 0;
                }
            }
        }
        return null;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　所以我们知道任务的窃取从workerThread运行的那一刻就已经开始了！先随机选中一条队列看能不能窃取到任务，取不到则窃取下一条队列，直接遍历完一遍所有的队列，如果都窃取不到就返回null。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;  以上就是我阅读fork/join源码之后总结出来一些心得，写了那么多我觉得也只是描述了个大概而已，真正详细有用的东西还需要仔细去阅读里面的代码才行。如果大家有兴趣的话，不妨也去尝试一下吧-。-~&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:02:00 +0000</pubDate>
<dc:creator>浮云骑士LIN</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linlinismine/p/9295701.html</dc:identifier>
</item>
<item>
<title>Java 小记 - 时间的处理与探究 - 捷义</title>
<link>http://www.cnblogs.com/youclk/p/9299575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youclk/p/9299575.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;时间的处理与日期的格式转换几乎是所有应用的基础职能之一，几乎所有的语言都会为其提供基础类库。作为曾经 .NET 的重度使用者，赖其优雅的语法，特别是可扩展方法这个神级特性的存在，我几乎没有特意关注过这些个基础类库，他们如同空气一般，你呼吸着，却不用感受其所在何处。煽情结束，入坑 Java 后甚烦其时间处理方式，在此做个总结与备忘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801714/201807/801714-20180712152112216-1742752031.png&quot; alt=&quot;主题图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;date-制造的麻烦&quot;&gt;1. Date 制造的麻烦&lt;/h2&gt;
&lt;h3 id=&quot;simpledateformat-存在的问题&quot;&gt;1.1 SimpleDateFormat 存在的问题&lt;/h3&gt;
&lt;p&gt;初级阶段，我仍对基础类库保留着绝对的信任，时间类型毫不犹豫地使用了 &lt;code&gt;Date&lt;/code&gt;，并且使用 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 类去格式化日期，介于项目中会频繁使用他们，我做了类似如下的封装：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DateUtils {
    public static SimpleDateFormat DATE_FORMAT;

    static {
        DATE_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    }

    public static String getFormatDate(Date date) {
       return DATE_FORMAT.format(date);
    }

    public static Date parseSimpleDate(String strDate) throws ParseException {
        return DATE_FORMAT.parse(strDate);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试跑过之后我便如数应用了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void formatDateTest() throws ParseException {
    Date date = DateUtils.parseSimpleDate(&quot;2018-07-12&quot;);
    boolean result = DateUtils.getFormatDate(date).equals(&quot;2018-07-12&quot;);

    Assert.assertTrue(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而项目上线后频繁报 &lt;code&gt;java.lang.NumberFormatException&lt;/code&gt; 异常，被好一顿吐槽，一查资料才知道 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 竟然是线程不安全的。看了下源码，定位到问题所在：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Calendar calendar;
// Called from Format after creating a FieldDelegate
private StringBuffer format(Date date, StringBuffer toAppendTo,
                            FieldDelegate delegate) {
    // Convert input date to time field list
    calendar.setTime(date);

    boolean useDateFormatSymbols = useDateFormatSymbols();

    for (int i = 0; i &amp;lt; compiledPattern.length; ) {
        int tag = compiledPattern[i] &amp;gt;&amp;gt;&amp;gt; 8;
        int count = compiledPattern[i++] &amp;amp; 0xff;
        if (count == 255) {
            count = compiledPattern[i++] &amp;lt;&amp;lt; 16;
            count |= compiledPattern[i++];
        }

        switch (tag) {
        case TAG_QUOTE_ASCII_CHAR:
            toAppendTo.append((char)count);
            break;

        case TAG_QUOTE_CHARS:
            toAppendTo.append(compiledPattern, i, count);
            i += count;
            break;

        default:
            subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);
            break;
        }
    }
    return toAppendTo;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;血槽已空，就这么使用了内部变量，回过头看下了注释，人家早已友情提示，呵呵：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Date formats are not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试中复现：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801714/201807/801714-20180712171322923-1522996533.png&quot; alt=&quot;SimpleDateFormat 多线程测试&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;simpledateformat-线程不安全的解决方案&quot;&gt;1.2 SimpleDateFormat 线程不安全的解决方案&lt;/h3&gt;
&lt;p&gt;最简单，最不负责任的方法就是加锁：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (DATE_FORMAT) {
    return DATE_FORMAT.format(strDate);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因格式化日期常会应用在列表数据的遍历处理中，弃之。还有一种较好的解决方案就是线程内独享，代码修改如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DateUtils {

    private static ThreadLocal&amp;lt;DateFormat&amp;gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&amp;gt; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));

    public static String getFormatDate(Date date) {
        return THREAD_LOCAL.get().format(date);
    }

    public static Date parseSimpleDate(String strDate) throws ParseException {
        return THREAD_LOCAL.get().parse(strDate);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来还算不错，兼顾了线程安全与效率，但，好死不死的，当初把 &lt;code&gt;DATE_FORMAT&lt;/code&gt; 定义为 &lt;code&gt;public&lt;/code&gt;，并且在某些特殊的场景中直接使用了该静态变量，总之不能通过只改一个工具类解决所有问题，左右都是麻烦，于是乎干脆直接抛弃 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 换 &lt;code&gt;org.apache.commons.lang3.time.DateFormatUtils&lt;/code&gt; 取而代之，更改代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DateUtils  extends org.apache.commons.lang3.time.DateUtils {

    public static String DATE_PATTERN = &quot;yyyy-MM-dd&quot;;

    public static String getFormatDate(Date date) {
        return DateFormatUtils.format(date, DATE_PATTERN);
    }

    public static Date parseSimpleDate(String strDate) throws ParseException {
        return parseDate(strDate, DATE_PATTERN);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;烦人的-calendar&quot;&gt;1.3 烦人的 Calendar&lt;/h3&gt;
&lt;p&gt;除了日期格式的转换，应用中的对时间处理的另一大需求就是计算，感激 &lt;code&gt;org.apache.commons.lang3.time.DateUtils&lt;/code&gt; 这个工具类为我们做了绝大部分的封装，能想到的一些基础的计算都可以直接 “无脑” 使用了。但有时仍然免不了要传 &lt;code&gt;Calendar&lt;/code&gt; 中的各种参数进入，特别是那一堆烦人的常量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final static int ERA = 0;
public final static int YEAR = 1;
public final static int MONTH = 2;
public final static int WEEK_OF_YEAR = 3;
public final static int WEEK_OF_MONTH = 4;
public final static int DATE = 5;
public final static int DAY_OF_MONTH = 5;
public final static int DAY_OF_YEAR = 6;
public final static int DAY_OF_WEEK = 7;
public final static int DAY_OF_WEEK_IN_MONTH = 8;
public final static int AM_PM = 9;
public final static int HOUR = 10;
public final static int HOUR_OF_DAY = 11;
public final static int MINUTE = 12;
public final static int SECOND = 13;
public final static int MILLISECOND = 14;
public final static int ZONE_OFFSET = 15;
public final static int DST_OFFSET = 16;
public final static int FIELD_COUNT = 17;
public final static int SUNDAY = 1;
public final static int MONDAY = 2;
public final static int TUESDAY = 3;
public final static int WEDNESDAY = 4;
public final static int THURSDAY = 5;
public final static int FRIDAY = 6;
public final static int SATURDAY = 7;
public final static int JANUARY = 0;
public final static int FEBRUARY = 1;
public final static int MARCH = 2;
public final static int APRIL = 3;
public final static int MAY = 4;
public final static int JUNE = 5;
public final static int JULY = 6;
public final static int AUGUST = 7;
public final static int SEPTEMBER = 8;
public final static int OCTOBER = 9;
public final static int NOVEMBER = 10;
public final static int DECEMBER = 11;
public final static int UNDECIMBER = 12;
public final static int AM = 0;
public final static int PM = 1;
public static final int ALL_STYLES = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能存在即合理，我定然是没有资格评判什么，我只是不喜欢。大而全的方法固然得存在，但是不是得和常用的方案区别开呢，或许会有声音说：“你可以自己动手抽离呀”，是啊，例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Date getBeginOfMonth(Date date) {
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(date);

    calendar.set(Calendar.DATE, 1);
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);

    return calendar.getTime();
}

public static Date getEndOfMonth(Date date) {
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(date);

    calendar.set(Calendar.DATE, calendar.getActualMaximum(Calendar.DATE));
    calendar.set(Calendar.HOUR_OF_DAY, calendar.getActualMaximum(Calendar.HOUR_OF_DAY));
    calendar.set(Calendar.MINUTE, calendar.getActualMaximum(Calendar.MINUTE));
    calendar.set(Calendar.SECOND, calendar.getActualMaximum(Calendar.SECOND));
    calendar.set(Calendar.MILLISECOND, calendar.getActualMaximum(Calendar.MILLISECOND));

    return calendar.getTime();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使这些代码只会存在于工具类中，但，只能说不喜欢吧，他们不该从我的手里写出来。&lt;/p&gt;
&lt;h2 id=&quot;instant-的救赎&quot;&gt;2. Instant 的救赎&lt;/h2&gt;
&lt;p&gt;Java8 中新增的日期核心类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Instant
LocalDate
LocalTime
LocalDateTime&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其余的还有一些时区的以及计算相关的类会在后续的代码示例中提及，这儿主要说下 &lt;code&gt;Instant&lt;/code&gt;，查看源码可看到其仅包含两个关键字段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    * The number of seconds from the epoch of 1970-01-01T00:00:00Z.
    */
private final long seconds;
/**
    * The number of nanoseconds, later along the time-line, from the seconds field.
    * This is always positive, and never exceeds 999,999,999.
    */
private final int nanos;


/**
    * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.
    * &amp;lt;p&amp;gt;
    * The epoch second count is a simple incrementing count of seconds where
    * second 0 is 1970-01-01T00:00:00Z.
    * The nanosecond part of the day is returned by {@code getNanosOfSecond}.
    *
    * @return the seconds from the epoch of 1970-01-01T00:00:00Z
    */
public long getEpochSecond() {
    return seconds;
}

/**
    * Gets the number of nanoseconds, later along the time-line, from the start
    * of the second.
    * &amp;lt;p&amp;gt;
    * The nanosecond-of-second value measures the total number of nanoseconds from
    * the second returned by {@code getEpochSecond}.
    *
    * @return the nanoseconds within the second, always positive, never exceeds 999,999,999
    */
public int getNano() {
    return nanos;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;秒和纳秒组合的绝对时间差不多是现在公认的最好的时间处理方式了吧，全世界各地的绝对时间都是相同的，所以可以先把烦人的时区还有那矫情的夏令时丢一边，是一个非常好的中间值设计。&lt;/p&gt;
&lt;h3 id=&quot;instant-与-localdatetime-的互转&quot;&gt;2.1 Instant 与 LocalDateTime 的互转&lt;/h3&gt;
&lt;p&gt;由于 &lt;code&gt;Instant&lt;/code&gt; 不包含时区信息，因此转换时需要指定时区，我们来看看以下示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void timeZoneTest() {
    Instant instant = Instant.now();

    LocalDateTime timeForChina = LocalDateTime.ofInstant(instant, ZoneId.of(&quot;Asia/Shanghai&quot;));
    LocalDateTime timeForAmerica = LocalDateTime.ofInstant(instant, ZoneId.of(&quot;America/New_York&quot;));
    long dif = Duration.between(timeForAmerica, timeForChina).getSeconds() / 3600;

    Assert.assertEquals(dif, 12L);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上海用的是东八区的时间，纽约用的是西五区的时间，地理时差应为 13 个小时，但美国使用了夏令时，因此实际时差为 12 个小时，以上单元测试能通过证明 &lt;code&gt;LocalDateTime&lt;/code&gt; 已经帮帮我们处理了夏令时问题。源代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static LocalDateTime ofInstant(Instant instant, ZoneId zone) {
    Objects.requireNonNull(instant, &quot;instant&quot;);
    Objects.requireNonNull(zone, &quot;zone&quot;);
    ZoneRules rules = zone.getRules();
    ZoneOffset offset = rules.getOffset(instant);
    return ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可看出获取时间偏移量的关键类为：&lt;code&gt;ZoneRules&lt;/code&gt;，由此反过来转换也非常简单，参照源码中的写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void instantTest() {

    LocalDateTime time = LocalDateTime.parse(&quot;2018-07-13T00:00:00&quot;);
    ZoneRules rules = ZoneId.of(&quot;Asia/Shanghai&quot;).getRules();
    Instant instant = time.toInstant(rules.getOffset(time));

    LocalDateTime timeBack = LocalDateTime.ofInstant(instant, ZoneId.of(&quot;Asia/Shanghai&quot;));

    Assert.assertEquals(time, timeBack);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;再谈格式化&quot;&gt;2.2 再谈格式化&lt;/h3&gt;
&lt;p&gt;新增的日期格式转换类为 &lt;code&gt;DateTimeFormatter&lt;/code&gt;，虽然还达不到如 &lt;code&gt;C#&lt;/code&gt; 那般随心所欲，但至少是线程安全了，可以放心使用，其次，好歹也预置了几个常用的格式模板，为对其进一步地封装提供了一些便利性。&lt;/p&gt;
&lt;p&gt;常用的字符串转日期方式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void parse() {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
    LocalDateTime time = LocalDateTime.parse(&quot;2018-07-13 12:05:30.505&quot;,formatter);
    System.out.println(time);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上示例代码哟有三点让人十分不爽，其一，我需要获得的是一个时间类型，他不存在格式的问题，显式指定模板接而进行转换看起来很傻；其二，时间的显示格式是正则轻易可穷尽的，就那么几种，还需要显式传入模板，看起来很傻；其三，&lt;code&gt;LocalDateTime.parse()&lt;/code&gt; 不支持 &lt;code&gt;LocalDate&lt;/code&gt; 格式的模板，看起来很傻；&lt;/p&gt;
&lt;p&gt;因此我对其做了一个简易的封装，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DateUtils {

    public static HashMap&amp;lt;String, String&amp;gt; patternMap;

    static {
        patternMap = new HashMap&amp;lt;&amp;gt;();

        // 2018年7月13日 12时5分30秒，2018-07-13 12:05:30，2018/07/13 12:05:30
        patternMap.put(&quot;^\\d{4}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D+\\d{3}\\D*$&quot;,
                &quot;yyyy-MM-dd-HH-mm-ss-SSS&quot;);
        patternMap.put(&quot;^\\d{4}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D+\\d{2}\\D*$&quot;,
                &quot;yyyy-MM-dd-HH-mm-ss&quot;);
        patternMap.put(&quot;^\\d{4}\\D+\\d{2}\\D+\\d{2}\\D*$&quot;, &quot;yyyy-MM-dd&quot;);

        // 20180713120530
        patternMap.put(&quot;^\\d{14}$&quot;, &quot;yyyyMMddHHmmss&quot;);
        patternMap.put(&quot;^\\d{8}$&quot;, &quot;yyyyMMdd&quot;);
    }

    public static LocalDateTime parse(String text) {

        for (String key : patternMap.keySet()) {
            if (Pattern.compile(key).matcher(text).matches()) {

                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(patternMap.get(key));
                text = text.replaceAll(&quot;\\D+&quot;, &quot;-&quot;)
                        .replaceAll(&quot;-$&quot;, &quot;&quot;);

                return parse(formatter, text);
            }
        }
        throw new DateTimeException(&quot;can't match a suitable pattern!&quot;);
    }

    public static LocalDateTime parse(DateTimeFormatter formatter, String text) {

        TemporalAccessor accessor = formatter.parseBest(text,
                LocalDateTime::from,
                LocalDate::from);

        LocalDateTime time;
        if (accessor instanceof LocalDate) {
            LocalDate date = LocalDate.from(accessor);
            time = LocalDateTime.of(date, LocalTime.MIDNIGHT);
        } else {
            time = LocalDateTime.from(accessor);
        }

        return time;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void parse() {
    String[] array = new String[]{
            &quot;2018-07-13 12:05:30&quot;,
            &quot;2018/07/13 12:05:30.505&quot;,
            &quot;2018年07月13日 12时05分30秒&quot;,
            &quot;2018年07月13日 12时05分30秒505毫秒&quot;,
            &quot;2018-07-13&quot;,
            &quot;20180713&quot;,
            &quot;20180713120530&quot;,
    };

    System.out.println(&quot;-------------------------&quot;);
    for (String s : array) {
        System.out.println(DateUtils.parse(s));
    }
    System.out.println(&quot;-------------------------&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801714/201807/801714-20180718133126689-1554571679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上示例应该够满足大部分的应用场景了，有特殊的情况出现继而往 &lt;code&gt;patternMap&lt;/code&gt; 中添加即可。&lt;/p&gt;
&lt;p&gt;反过来日期转字符串，这时候传入 &lt;code&gt;pattern&lt;/code&gt; 是说的过去的，因为对此场景而言显示格式成为了核心业务，例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void format() {
    LocalDateTime time = LocalDateTime.of(2018, 7, 13, 12, 5, 30);
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);

    Assert.assertEquals(time.format(formatter), &quot;2018-07-13 12:05:30.000&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，对于常用的格式也应当封装入工具类中。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;到此暂时告一段落，后续若有遇到更复杂的应用场景再继续补充。这篇文章拖了好几天才匆匆收尾，期间经历了一些事情可谓是...，前些阶段接二连三地上了好几个 java 项目，本以为紧绷的弦可以松一松，喘口气，花点时间做些总结，写写文章。&lt;/p&gt;
&lt;p&gt;哪晓得，项目上线的第二天公司倒闭了，来了一堆特勤又是盘问又是查封，接着所有员工全部遣散回家。那几天整个很懵X，所有管理层没有一个出来解释情况（ps：貌似进去的进去，失联的失联），网上一爬才晓得互金界集体暴雷，然后，就完了。昨日助其黄袍加身，今日恨不能解其体，食其肉，一夜之间灰飞烟灭，我也算亲眼见识到了这幅场景。正好卡在交社保的关头，看着炸锅的维权群和各类小道消息，归就一声长叹。&lt;/p&gt;
&lt;p&gt;无奈又得重新出发，虽可借塞翁失马宽慰之，但终免不了些许落寞。若君有良机，肯请告知~（能吃苦，自我驱动强，学习能力尚可😅），微信：youclk。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我的公众号《有刻》，我们共同成长！&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801714/201805/801714-20180504015424584-1286454815.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 07:01:00 +0000</pubDate>
<dc:creator>捷义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youclk/p/9299575.html</dc:identifier>
</item>
</channel>
</rss>