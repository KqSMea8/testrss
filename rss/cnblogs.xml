<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis可视化工具 Redis Desktop Manager - 那一叶随风</title>
<link>http://www.cnblogs.com/phpstudy2015-6/p/9536831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/phpstudy2015-6/p/9536831.html</guid>
<description>&lt;h4&gt;1、前言&lt;/h4&gt;
&lt;p&gt;　　从接触Redis也有两年，平时就使用它来做缓存层，它给我的印象就是很强大，内置的数据结构很齐全，加上Redis5.0的到来，新增了很多特色功能。而Redis5.0最大的新特性就是多出了一个数据结构Stream，它是一个新的强大的支持多播的可持久化的消息队列，可以去了解学习一下哟。言归正传，之所以写下这篇文章是因为公司里面的电脑一直都有装Redis可视化工具，用起来很方便，感觉很有必要在家里自己的电脑装上一个，在安装使用的过程中也出现之前遇到的一些小问题，因此写下这篇博客记录一下。&lt;/p&gt;

&lt;h4&gt;2、软件安装&lt;/h4&gt;
&lt;p&gt;软件版本：&lt;/p&gt;
&lt;p&gt;　　1、CentOS 7&lt;/p&gt;
&lt;p&gt;　　2、Redis3.2&lt;/p&gt;
&lt;p&gt;　　3、redis-desktop-manager-0.8.8.384&lt;/p&gt;
&lt;p&gt;百度云（可视化工具）：&lt;a href=&quot;https://pan.baidu.com/s/1a2UV9mHikGkGFTF6BFoqdg&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1a2UV9mHikGkGFTF6BFoqdg&lt;/a&gt; 密码：ahfw&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://redisdesktop.com/download&quot; target=&quot;_blank&quot;&gt;https://redisdesktop.com/download&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;　　2.1、安装Redis&lt;/h4&gt;
&lt;p&gt;CentOS 7直接yum安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; redis  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此方式直接安装不是最新的版本呢&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
安装最新的版本需要安装Remi的软件源：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rpms.famillecollet.com/enterprise/remi-release-7.rpm&lt;/span&gt;
&lt;span&gt;yum&lt;/span&gt; --enablerepo=remi &lt;span&gt;install&lt;/span&gt; redis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完毕后启动Redis测试一下是否安装成功：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、启动&lt;br/&gt;service redis start
或者
systemctl start redis&lt;br/&gt;2、检查是否启动&lt;br/&gt;ps -A|grep redis&lt;br/&gt;3、查看安装时创建的文件 &lt;br/&gt;rpm -ql redis&lt;br/&gt;4、查看redis版本&lt;br/&gt;&lt;/span&gt;redis-cli --version&lt;br/&gt;&lt;span&gt;5、设置开机自启&lt;br/&gt;&lt;/span&gt;chkconfig redis on&lt;br/&gt;或者&lt;br/&gt;systemctl enable redis.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到如下则表示启动成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826133428743-29256522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连接Redis：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826133747617-1967581368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.2、安装redis-desktop-manager&lt;/h4&gt;
&lt;p&gt;　　Windows下直接安装即可&lt;/p&gt;
&lt;p&gt;　　可参考官网&lt;/p&gt;

&lt;h4&gt;3、测试连接并抛出问题&lt;/h4&gt;
&lt;h4&gt;　　3.1、测试连接&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826134632340-126665088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接链接可能会出现下面问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826134736871-76773622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　3.2、抛出问题&lt;/h4&gt;
&lt;p&gt; 1、Redis安装后默认只能在localhost访问，若在进行远程访问可能会被限制，不能连接&lt;/p&gt;
&lt;p&gt; 2、在Linux主机里面，一般都打开防火墙，因此我们通过Reids的默认端口6379进行访问，可能被限制&lt;/p&gt;
&lt;p&gt; 3、在上面例子中，我们直接使用redis-cli直接连接就可以访问了。那如果放开权限允许远程登录，没有验证机制将会导致安全问题&lt;/p&gt;
&lt;p&gt; 4、假设开放远程连接权限，并设置了验证机制，那么Redis的主从复制又需要如何处理呢&lt;/p&gt;
&lt;h4&gt;4、解决问题&lt;/h4&gt;
&lt;h4&gt;　　4.1、问题1&lt;/h4&gt;
&lt;p&gt;　　我们可以通过修改Redis的配置文件即可解决&lt;/p&gt;
&lt;p&gt;a、注释掉bind 127.0.0.1允许所有的ip访问redis&lt;/p&gt;
&lt;p&gt;b、将修改为：protected-mode no （Redis3.2新增的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;whereis&lt;/span&gt; redis    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找配置文件路径&lt;/span&gt;
&lt;span&gt;vi&lt;/span&gt; /etc/&lt;span&gt;redis.conf   
systemctl restart redis   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改好配置文件后保存并重启&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826140909522-1384588107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826140447742-1062654593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826140455461-27339104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决完这个问题后，即表明Redis软件本身允许远程连接了，但是我们还需要解决防火墙的问题才可以进行远程连接。&lt;/p&gt;
&lt;h4&gt;　　4.2、问题2&lt;/h4&gt;
&lt;p&gt;　　CentsOS7防火墙改成firewall，不再是之前的iptables，因此开放端口的方式有点区别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;开放端口如下：
firewall&lt;/span&gt;-cmd --zone=public --add-port=&lt;span&gt;6379&lt;/span&gt;/tcp --&lt;span&gt;permanent
&lt;/span&gt;--zone    　　　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;作用域&lt;/span&gt;
--add-port=&lt;span&gt;6379&lt;/span&gt;/tcp  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加端口，格式为：端口/通讯协议&lt;/span&gt;
--permanent   　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;永久生效，没有此参数重启后失效&lt;/span&gt;
&lt;span&gt;重启防火墙：
systemctl stop firewalld.service 
systemctl start firewalld.service
systemctl restart firewalld.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826141715853-568928350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试连接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826141803225-1964742023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826141942153-2028487260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　连接成功&lt;/p&gt;
&lt;h4&gt;　　4.2、问题3&lt;/h4&gt;
&lt;p&gt; 　　设置密码的验证机制有两种方式，包括配置文件修改（永久）和命令行修改（临时，重启服务后无效）&lt;/p&gt;
&lt;p&gt;　　a、配置文件修改&lt;/p&gt;
&lt;p&gt;　　将去掉#requirepass foobared前面的注释，并更改为自己的密码 requirepass 密码，最后重启Redis&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826142825231-785128940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826142626812-468341795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　测试：&lt;/p&gt;
&lt;p&gt;　　从下面的命令行可以看到，不输入密码，则获取不到数据，即设置密码验证机制成功&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826143112304-18992253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图形化工具同理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826143720385-639216973.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826143730363-1802949352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b、命令行修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
config get requirepass        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取校验密码&lt;/span&gt;
config set requirepass mypassword2      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置密码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/789055/201808/789055-20180826144530468-410057391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　4.4、问题4&lt;/h4&gt;
&lt;p&gt;　　若master设置了密码则slave也要设置相应的密码参数否则无法进行正常复制的。&lt;br/&gt;　　slave中配置文件内找到如下行，移除注释，修改密码即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
#masterauth  mstpassword 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（以上是自己的一些见解，若有不足或者错误的地方请各位指出）&lt;/p&gt;
&lt;p&gt; 作者：&lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;那一叶随风&lt;/a&gt;   &lt;a href=&quot;http://www.cnblogs.com/phpstudy2015-6/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/phpstudy2015-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 原文地址：  &lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/9536831.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/phpstudy2015-6/p/9536831.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/phpstudy2015-6/p/%20https://www.cnblogs.com/phpstudy2015-6/p/6732784.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 声明：本博客文章为原创，只代表本人在工作学习中某一时间内总结的观点或结论。转载时请在文章页面明显位置给出原文链接&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 07:05:00 +0000</pubDate>
<dc:creator>那一叶随风</dc:creator>
<og:description>1、前言 从接触Redis也有两年，平时就使用它来做缓存层，它给我的印象就是很强大，内置的数据结构很齐全，加上Redis5.0的到来，新增了很多特色功能。而Redis5.0最大的新特性就是多出了一个数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/phpstudy2015-6/p/9536831.html</dc:identifier>
</item>
<item>
<title>FTP服务-实现vsftpd虚拟用户 - 一入IT深似海·</title>
<link>http://www.cnblogs.com/xsuid/p/9537235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xsuid/p/9537235.html</guid>
<description>&lt;p&gt;前几篇介绍了基础，这篇将具体实现几个案例&lt;/p&gt;

&lt;h2&gt;实现基于文件验证的vsftpd虚拟用户，每个用户独立一个文件夹&lt;/h2&gt;
&lt;h3&gt;1、创建用户数据库文件&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vim /etc/vsftpd/vusers.txt
qq
centos
momo
centos
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：文件内容格式为奇数行为用户名，偶数行为密码&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、设置权限与编译此文件&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
cd /etc/vsftpd/
db_load -T -t hash -f vusers.txt vusers.db ##编译文件
chmod 600 vusers.db 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：修改权限是为了安全&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、创建linux用户和ftp目录（这个账号将来虚拟账号映射成它）&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
useradd -s /sbin/nologin vftpuser
chmod 555 /home/vftpuser/  ###把用户家目录的写权限去掉
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：映射账号对根要没有写权限&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mkdir upload  ##创建上传用的文件夹
chown vftpuser upload/  
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：把这个文件夹的所属人改为vftpuser用户，次用户虽然对 /home/vftpuser/ 就也是根，没有写权限，但是对根下的目录有写权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把匿名写权限打开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140654117-1947694316.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140654484-82262813.png&quot; alt=&quot;clipboard&quot; width=&quot;500&quot; height=&quot;123&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4、修改pam配置文件&lt;/h3&gt;
&lt;p&gt;vim /etc/pam.d/vusers.db  #这个名字叫什么都可&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
auth required pam_userdb.so db=/etc/vsftpd/vusers  
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意：这个vusers名字一定要和第二步中创建的xxxx.db名字一样&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
account required pam_userdb.so db=/etc/vsftpd/vusers
&lt;/pre&gt;
&lt;h3&gt;5、让主配置文件知道你要用自己修改的pam模块&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140654683-1841919587.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140654949-1712958715.png&quot; alt=&quot;clipboard&quot; width=&quot;746&quot; height=&quot;76&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：放在vusers.txt里面的就是合法用户，可以登陆&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6、把所有系统账号映射成我们创建的vftpuser账号，并关闭linux系统账号登陆&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;vim /etc/vsftpd/vsftpd.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
guest_enable=YES
guest_username=vftpuser
&lt;/pre&gt;

&lt;h3&gt;7、虚拟用户建立独立的配置文件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;vim /etc/vsftpd/vsftpd.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
user_config_dir=/etc/vsftpd/vftpuser.d/
&lt;/pre&gt;

&lt;h4&gt;创建上面这个文件夹创建出来&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mkdir /etc/vsftpd/vftpuser.d/
&lt;/pre&gt;
&lt;h4&gt;在这个文件夹目录下创建针对虚拟用户的配置&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
[root@centos7_77 vftpuser.d]# cat &amp;gt; qq
anon_upload_enable=YES
anon_mkdir_write_enable=YES      
备注：意思是说虚拟用户qq有匿名写权限
&lt;/pre&gt;

&lt;h3&gt;8、让两个虚拟用户进来时看到的文件夹不一样&lt;/h3&gt;
&lt;p&gt;vim /etc/vsftpd/vftpuser.d/qq&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
local_root=/data/qq
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：要是这个文件夹不存在就创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mkdir /data/qq&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：在qq目录下创建个文件用于测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;touch /data/qq/qq.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重启，测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140655271-1015141681.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140655686-995657766.png&quot; alt=&quot;clipboard&quot; width=&quot;728&quot; height=&quot;295&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：想要增加用户，在vusers.txt文件中写入，再生成db文件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;实现：基于MYSQL验证的vsftpd虚拟用户&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;说明：本实验在两台CentOS主机上实现，一台做为FTP服务器，一台做数据库服务器&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、安装所需要包和包组&lt;/h3&gt;
&lt;h4&gt;在数据库服务器上安装包：&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;Centos7：在数据库服务器上安装&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
yum –y install mariadb-server
systemctl start mariadb.service
systemctl enable mariadb
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;Centos6：在数据库服务器上安装&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
yum –y install mysql-server
&lt;/pre&gt;

&lt;h3&gt;在FTP服务器上安装vsftpd和pam_mysql包&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;centos6：pam_mysql由epel6的源中提供&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum install vsftpd pam_mysql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;centos7：无对应rpm包，需手动编译安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum -y groupinstall &quot;Development Tools&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum -y install mariadb-devel pam-devel vsftpd&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载pam_mysql-0.7RC1.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/pam-mysql/&quot;&gt;&lt;span&gt;https://sourceforge.net/projects/pam-mysql/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;1、解压缩pam模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;[root@centos7_77 ~]# tar xvf pam_mysql-0.7RC1.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cd pam_mysql-0.7RC1/&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、编译&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
[root@centos7_77 pam_mysql-0.7RC1]# ./configure --with-pam-mods-dir=/lib64/security --with-mysql=/usr --with-pam=/usr
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：这样需要注意指定的位置，mysql&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在还没有pam_mysql.so&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140656706-411015722.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140657471-950305189.png&quot; alt=&quot;clipboard&quot; width=&quot;1047&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;开始make&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;[root@centos7_77 pam_mysql-0.7RC1]# make &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140658919-1025134597.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140659265-1752817174.png&quot; alt=&quot;clipboard&quot; width=&quot;1070&quot; height=&quot;222&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、创建数据库和表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）创建ftpdb数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MariaDB [(none)]&amp;gt; create database ftpdb;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）授权一个用户可以连这个数据库（有读权限就行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MariaDB [(none)]&amp;gt; grant select on ftpdb.* to vsftpd@'localhost' identified by 'centos';&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）创建一个表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MariaDB [ftpdb]&amp;gt; create table users (id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, name CHAR(50) BINARY NOT NULL, password CHAR(48) BINARY NOT NULL );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）往表里增加虚拟用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MariaDB [ftpdb]&amp;gt; INSERT INTO users(name,password) values('gg',password('centos'));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MariaDB [ftpdb]&amp;gt; INSERT INTO users(name,password) values('mm',password('centos'));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140659498-1036792741.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140659814-13872768.png&quot; alt=&quot;clipboard&quot; width=&quot;742&quot; height=&quot;188&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、准备一个pam配置文件（在FTP服务器上建立pam认证所需文件）&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
cd /etc/pam.d/
vim vsftpd.mysql

auth required pam_mysql.so user=vsftpd passwd=centos host=localhost db=ftpdb table=users usercolumn=name passwdcolumn=password
 crypt=2
account required pam_mysql.so user=vsftpd passwd=centos host=localhost db=ftpdb table=users usercolumn=name passwdcolumn=passw
ord crypt=2
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;28&quot;&gt;
&lt;p&gt;&lt;span&gt;配置字段说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• auth 表示认证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• account 验证账号密码正常使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• required 表示认证要通过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• pam_mysql.so模块是默认的相对路径，是相对/lib64/security/路径而言，也可以写绝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对路径；后面为给此模块传递的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• user=vsftpd为登录mysql的用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• passwd=magedu 登录mysql的的密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• host=mysqlserver mysql服务器的主机名或ip地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• db=vsftpd 指定连接msyql的数据库名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• table=users 指定连接数据库中的表名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• usercolumn=name 当做用户名的字段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• passwdcolumn=password 当做用户名字段的密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• crypt=2 密码的加密方式为mysql password()函数加密&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;4、让ftp服务器知道调用我们配置的pam模块配置文件&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vim /etc/vsftpd/vsftpd.conf
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140700053-1925082654.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140700318-1030184843.png&quot; alt=&quot;clipboard&quot; width=&quot;373&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5、映射为系统账号vftpuser&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;vim /etc/vsftpd/vsftpd.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
guest_enable=YES
guest_username=vftpuser
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：意思说，启动guest用户，系统用户映射为guest用户，而guest用户是vftpuser，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别忘了去掉此用户的家目录的读W权限&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6、让登陆的账号权限不一样（针对每个用户都有自己的配置文件）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;指定用户存放配置的文件夹&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vim /etc/vsftpd/vsftpd.conf
user_config_dir=/etc/vsftpd/vftpuser.d
cd /etc/vsftpd/vftpuser.d
[root@centos7_77 vftpuser.d]# cat &amp;gt; mm
local_root=/data/mm
cat &amp;gt; gg
local_root=/data/gg
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：要想gg mm 充当虚拟用户的根必须没有写权限&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
[root@centos7_77 data]# chmod a=rx mm
[root@centos7_77 data]# chmod a=rx gg
再gg、mm目录下创建个文件好测试
[root@centos7_77 gg]# touch gg.txt
[root@centos7_77 mm]# touch mm.txt
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;重启&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140700572-342577384.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140700903-522154341.png&quot; alt=&quot;clipboard&quot; width=&quot;628&quot; height=&quot;297&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140701134-1133328834.png&quot;&gt;&lt;img title=&quot;clipboard&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180826140701411-517647587.png&quot; alt=&quot;clipboard&quot; width=&quot;670&quot; height=&quot;329&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：要想让gg用户有写权限，在/etc/vsftpd/vftpuser.d/gg文件中加入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;anon_upload_enable=YES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;anon_mkdir_write_enable=YES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还要对/data/gg这个目录要有写权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;setfacl -m u:vftpuser:rwx /data/gg&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 06:07:00 +0000</pubDate>
<dc:creator>一入IT深似海&amp;#183;</dc:creator>
<og:description>前几篇介绍了基础，这篇将具体实现几个案例 实现基于文件验证的vsftpd虚拟用户，每个用户独立一个文件夹 1、创建用户数据库文件 备注：文件内容格式为奇数行为用户名，偶数行为密码 2、设置权限与编译此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xsuid/p/9537235.html</dc:identifier>
</item>
<item>
<title>PICE（5）：MongoDBStreaming - gRPC -MGO Service - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/9536859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/9536859.html</guid>
<description>&lt;p&gt;&lt;span&gt;  我在前面提到过MongoDB不支持像SQL般字符式的操作指令，所以我们必须对所有的MongoDB操作指令建立protobuf类型才能支持MongoDB指令的序列化。在对上一篇博文里我们把MongoDB的消息指令序列化单独挑出来讨论了一番，在这篇我们准备在一个MongoDB scala开发环境里通过streaming运算来示范这些protobuf消息的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 与前面我们介绍过的JDBC-streaming和Cassandra-streaming对应操作指令的处理相同，MGO-streaming也是是通过一个Context对象来描述操作方式和内容细节的，MGOContext定义如下：&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MGOContext(
                         dbName: String,
                         collName: String,
                         actionType: MGO_ACTION_TYPE &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
                         action: Option[MGOCommands] &lt;/span&gt;=&lt;span&gt; None,
                         actionOptions: Option[Any] &lt;/span&gt;=&lt;span&gt; None,
                         actionTargets: Seq[String] &lt;/span&gt;=&lt;span&gt; Nil
                       ) {
    ctx &lt;/span&gt;=&amp;gt;&lt;span&gt;
    def setDbName(name: String): MGOContext &lt;/span&gt;= ctx.copy(dbName =&lt;span&gt; name)

    def setCollName(name: String): MGOContext &lt;/span&gt;= ctx.copy(collName =&lt;span&gt; name)

    def setActionType(at: MGO_ACTION_TYPE): MGOContext &lt;/span&gt;= ctx.copy(actionType =&lt;span&gt; at)

    def setCommand(cmd: MGOCommands): MGOContext  &lt;/span&gt;= ctx.copy(action =&lt;span&gt; Some(cmd))

    def toSomeProto &lt;/span&gt;= MGOProtoConversion.ctxToProto(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)

  }

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; MGOContext {
    def apply(db: String, coll: String) &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(db, coll)
    def fromProto(proto: sdp.grpc.services.ProtoMGOContext): MGOContext &lt;/span&gt;=&lt;span&gt;
      MGOProtoConversion.ctxFromProto(proto)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;上面的代码里包括了toSomeProto, fromProto两个函数来实现MGOContext的序列化转换处理。这两个函数的实现包含在文章后面提供的源代码中。MongoDB的.proto文件idl定义如下：&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google/protobuf/wrappers.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google/protobuf/any.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb/scalapb.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;


option (scalapb.options) &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use a custom Scala package name
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; package_name: &quot;io.ontherocks.introgrpc.demo&quot;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't append file name to package&lt;/span&gt;
  flat_package: &lt;span&gt;true&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; generate one Scala file for all messages (services still get their own file)&lt;/span&gt;
  single_file: &lt;span&gt;true&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add imports to generated file
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; useful when extending traits or using custom types
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import: &quot;io.ontherocks.hellogrpc.RockingMessage&quot;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code to put at the top of generated file
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; works only with `single_file: true`
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;preamble: &quot;sealed trait SomeSealedTrait&quot;&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Demoes various customization options provided by ScalaPBs.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

package sdp.grpc.services;

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;misc/sdp.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

message ProtoMGOBson {
  bytes bson &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message ProtoMGODocument {
  bytes document &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message ProtoMGOResultOption { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
   int32 optType = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
   ProtoMGOBson bsonParam &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
   int32 valueParam &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
}

message ProtoMGOAdmin{
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; tarName = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  repeated ProtoMGOBson bsonParam  &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
  ProtoAny options &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; objName = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
}

message ProtoMGOContext {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MGOContext&lt;/span&gt;
  &lt;span&gt;string&lt;/span&gt; dbName = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; collName = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
  int32 commandType &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
  repeated ProtoMGOBson bsonParam &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
  repeated ProtoMGOResultOption resultOptions &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
  repeated &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; targets = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
  ProtoAny options &lt;/span&gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;
  repeated ProtoMGODocument documents &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
  google.protobuf.BoolValue only &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
  ProtoMGOAdmin adminOptions &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google/protobuf/wrappers.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google/protobuf/any.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scalapb/scalapb.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;


option (scalapb.options) &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use a custom Scala package name
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; package_name: &quot;io.ontherocks.introgrpc.demo&quot;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't append file name to package&lt;/span&gt;
  flat_package: &lt;span&gt;true&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; generate one Scala file for all messages (services still get their own file)&lt;/span&gt;
  single_file: &lt;span&gt;true&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add imports to generated file
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; useful when extending traits or using custom types
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import: &quot;io.ontherocks.hellogrpc.RockingMessage&quot;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code to put at the top of generated file
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; works only with `single_file: true`
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;preamble: &quot;sealed trait SomeSealedTrait&quot;&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Demoes various customization options provided by ScalaPBs.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

package sdp.grpc.services;

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;misc/sdp.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cql/cql.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jdbc/jdbc.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mgo/mgo.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

service MGOServices {
  rpc clientStreaming(stream HelloMsg) returns (stream HelloMsg) {}
  rpc runQueries(stream ProtoMGOContext) returns (stream ProtoMGODocument) {}
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;以上通过import &quot;mgo/mgo.proto&quot;引用了ProtoMGOContext类型，并在服务定义rpc runQueries里用作了传入参数。&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package sdp.grpc.mongo.server

import sdp.mongo.engine._
import MGOClasses._
import MGOEngine._
import akka.NotUsed
import akka.stream.scaladsl.Flow
import sdp.logging.LogSupport
import sdp.grpc.services._
import org.mongodb.scala._
import scala.concurrent._
import akka.stream.ActorMaterializer
import sdp.mongo.engine.MGOProtoConversion.MGODocument


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MGOStreamingServices(&lt;span&gt;implicit&lt;/span&gt;&lt;span&gt; ec: ExecutionContextExecutor,
                            mat: ActorMaterializer, client: MongoClient)
  extends MgostreamingGrpcAkkaStream.MGOServices with LogSupport {
  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def clientStreaming: Flow[HelloMsg, HelloMsg, NotUsed] =&lt;span&gt; {
    Flow[HelloMsg]
      .map {r &lt;/span&gt;=&amp;gt; HelloMsg(r.hello+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, mongo ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}
  }

  &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def runQueries: Flow[ProtoMGOContext, ProtoMGODocument, NotUsed] =&lt;span&gt;
    Flow[ProtoMGOContext]
    .flatMapConcat {p &lt;/span&gt;=&amp;gt;&lt;span&gt;
      val ctx &lt;/span&gt;=&lt;span&gt; MGOContext.fromProto(p)
      mongoStream(ctx).map{doc &lt;/span&gt;=&amp;gt;&lt;span&gt; MGODocument.toProto(doc)}
    }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;这个runQueries服务函数的处理流程是：接收ProtoMGOContext、转换成MGOContext、传给mongoStream、运算mongoStream返回ProtoMGODocument结果。mongoStream函数的代码如下：&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  def mongoStream(ctx: MGOContext)(
    &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; client: MongoClient, ec: ExecutionContextExecutor): Source[Document, NotUsed] =&lt;span&gt; {
    log.info(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt;  MGOContext: ${ctx}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    def toResultOption(rts: Seq[ResultOptions]): FindObservable[Document] &lt;/span&gt;=&amp;gt; FindObservable[Document] = findObj =&amp;gt;&lt;span&gt;
      rts.foldRight(findObj)((a,b) &lt;/span&gt;=&amp;gt;&lt;span&gt; a.toFindObservable(b))

    val db &lt;/span&gt;=&lt;span&gt; client.getDatabase(ctx.dbName)
    val coll &lt;/span&gt;=&lt;span&gt; db.getCollection(ctx.collName)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ctx.action ==&lt;span&gt; None) {
      log.error(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt; uery action cannot be null!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query action cannot be null!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      ctx.action.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(None, Nil, &lt;span&gt;false&lt;/span&gt;) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
&lt;span&gt;          MongoSource(coll.find())
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(None, Nil, &lt;span&gt;true&lt;/span&gt;) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
&lt;span&gt;          MongoSource(coll.find().first())
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(Some(filter), Nil, &lt;span&gt;false&lt;/span&gt;) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
&lt;span&gt;          MongoSource(coll.find(filter))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(Some(filter), Nil, &lt;span&gt;true&lt;/span&gt;) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
&lt;span&gt;          MongoSource(coll.find(filter).first())
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(None, sro, _) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
          val next =&lt;span&gt; toResultOption(sro)
          MongoSource(next(coll.find[Document]()))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(Some(filter), sro, _) =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindObservable&lt;/span&gt;
          val next =&lt;span&gt; toResultOption(sro)
          MongoSource(next(coll.find[Document](filter)))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt;&lt;span&gt;
          log.error(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt; unsupported streaming query [${ctx.action.get}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt; unsupported streaming query [${ctx.action.get}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

      }
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; { &lt;span&gt;case&lt;/span&gt; e: Exception =&amp;gt;&lt;span&gt;
      log.error(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt; runtime error: ${e.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongoStream&amp;gt; Error: ${e.getMessage}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MGOStreamClient(host: String, port: Int)(
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt;&lt;span&gt; ec: ExecutionContextExecutor) extends LogSupport {

  val channel &lt;/span&gt;=&lt;span&gt; ManagedChannelBuilder
    .forAddress(host, port)
    .usePlaintext()
    .build()

  val stub &lt;/span&gt;=&lt;span&gt; MgostreamingGrpcAkkaStream.stub(channel)

  def echoHello: Source[HelloMsg, NotUsed] &lt;/span&gt;=&lt;span&gt; {
    val row &lt;/span&gt;= HelloMsg(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    val rows &lt;/span&gt;= List.fill[HelloMsg](&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)(row)
    Source
      .fromIterator(() &lt;/span&gt;=&amp;gt;&lt;span&gt; rows.iterator)
      .via(stub.clientStreaming)
  }

  val filter &lt;/span&gt;= and(equal(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;California&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    equal(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alameda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    equal(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;))

  val proj &lt;/span&gt;= exclude(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rowid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  val proj1 &lt;/span&gt;= include(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  val rtxfmr &lt;/span&gt;=&lt;span&gt; Seq(
    ResultOptions(
      optType &lt;/span&gt;=&lt;span&gt; FOD_LIMIT,
      value &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;),
    ResultOptions(
      optType &lt;/span&gt;=&lt;span&gt; FOD_PROJECTION,
      bson &lt;/span&gt;= Some(proj)) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;,
    ResultOptions(
      optType = FOD_PROJECTION,
      bson = Some(proj1)) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  )

  val cmd &lt;/span&gt;= Find(filter = Some(filter), andThen =&lt;span&gt; rtxfmr)

  val ctx &lt;/span&gt;= MGOContext(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aqmrpt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).setCommand(cmd)

  def mgoQueries: Source[ProtoMGODocument,NotUsed] &lt;/span&gt;=&lt;span&gt; {
       Source
         .single[ProtoMGOContext](ctx.toSomeProto.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;)
      .via(stub.runQueries)
  }
}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; MGOStreamingClient extends App {
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val system = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EchoNumsClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val mat =&lt;span&gt; ActorMaterializer.create(system)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val ec =&lt;span&gt; system.dispatcher
  val mgoClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MGOStreamClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;50051&lt;/span&gt;&lt;span&gt;)

   mgoClient.mgoQueries.runForeach(pd &lt;/span&gt;=&amp;gt;&lt;span&gt;
      println(MGODocument.fromProto(pd).toJson()))

  scala.io.StdIn.readLine()
  mat.shutdown()
  system.terminate()

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;measureid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$numberLong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;California&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alameda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1999&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt;&lt;span&gt; }
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;measureid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$numberLong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;California&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alameda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1999&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt;&lt;span&gt; }
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;measureid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$numberLong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;California&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alameda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;2000&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;260&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package sdp.mongo.engine
import org.mongodb.scala.bson.collection.immutable.Document
import org.bson.conversions.Bson
import sdp.grpc.services._
import protobuf.bytes.Converter._
import MGOClasses._
import MGOAdmins._
import MGOCommands._
import org.bson.BsonDocument
import org.bson.codecs.configuration.CodecRegistry
import org.mongodb.scala.bson.codecs.DEFAULT_CODEC_REGISTRY
import org.mongodb.scala.FindObservable

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; MGOProtoConversion {

  type MGO_COMMAND_TYPE &lt;/span&gt;=&lt;span&gt; Int
  val MGO_COMMAND_FIND            &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_COUNT           &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_DISTICT         &lt;/span&gt;= &lt;span&gt;21&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_DOCUMENTSTREAM  &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_AGGREGATE       &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_INSERT          &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_DELETE          &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_REPLACE         &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
  val MGO_COMMAND_UPDATE          &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;


  val MGO_ADMIN_DROPCOLLECTION    &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_CREATECOLLECTION  &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_LISTCOLLECTION    &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_CREATEVIEW        &lt;/span&gt;= &lt;span&gt;11&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_CREATEINDEX       &lt;/span&gt;= &lt;span&gt;12&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_DROPINDEXBYNAME   &lt;/span&gt;= &lt;span&gt;13&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_DROPINDEXBYKEY    &lt;/span&gt;= &lt;span&gt;14&lt;/span&gt;&lt;span&gt;
  val MGO_ADMIN_DROPALLINDEXES    &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;


  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminContext(
                           tarName: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                           bsonParam: Seq[Bson] &lt;/span&gt;=&lt;span&gt; Nil,
                           options: Option[Any] &lt;/span&gt;=&lt;span&gt; None,
                           objName: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                         ){
    def toProto &lt;/span&gt;=&lt;span&gt; sdp.grpc.services.ProtoMGOAdmin(
      tarName &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tarName,
      bsonParam &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.bsonParam.map {b =&amp;gt;&lt;span&gt; sdp.grpc.services.ProtoMGOBson(marshal(b))},
      objName &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objName,
      options &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.options.map(b =&amp;gt;&lt;span&gt; ProtoAny(marshal(b)))

    )
  }

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; AdminContext {
    def fromProto(msg: sdp.grpc.services.ProtoMGOAdmin) &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdminContext(
      tarName &lt;/span&gt;=&lt;span&gt; msg.tarName,
      bsonParam &lt;/span&gt;= msg.bsonParam.map(b =&amp;gt;&lt;span&gt; unmarshal[Bson](b.bson)),
      objName &lt;/span&gt;=&lt;span&gt; msg.objName,
      options &lt;/span&gt;= msg.options.map(b =&amp;gt;&lt;span&gt; unmarshal[Any](b.value))
    )
  }

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Context(
                      dbName: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                      collName: String &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                      commandType: MGO_COMMAND_TYPE,
                      bsonParam: Seq[Bson] &lt;/span&gt;=&lt;span&gt; Nil,
                      resultOptions: Seq[ResultOptions] &lt;/span&gt;=&lt;span&gt; Nil,
                      options: Option[Any] &lt;/span&gt;=&lt;span&gt; None,
                      documents: Seq[Document] &lt;/span&gt;=&lt;span&gt; Nil,
                      targets: Seq[String] &lt;/span&gt;=&lt;span&gt; Nil,
                      only: Boolean &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      adminOptions: Option[AdminContext] &lt;/span&gt;=&lt;span&gt; None
                    ){

    def toProto &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
      dbName &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dbName,
      collName &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.collName,
      commandType &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commandType,
      bsonParam &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bsonParam.map(bsonToProto),
      resultOptions &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resultOptions.map(_.toProto),
      options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.options ==&lt;span&gt; None)
        Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        Some(ProtoAny(marshal(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) },
      documents &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.documents.map(d =&amp;gt;&lt;span&gt; sdp.grpc.services.ProtoMGODocument(marshal(d))),
      targets &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targets,
      only &lt;/span&gt;= Some(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.only),
      adminOptions &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.adminOptions.map(_.toProto)
    )

  }

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; MGODocument {
    def fromProto(msg: sdp.grpc.services.ProtoMGODocument): Document &lt;/span&gt;=&lt;span&gt;
      unmarshal[Document](msg.document)
    def toProto(doc: Document): sdp.grpc.services.ProtoMGODocument &lt;/span&gt;=
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProtoMGODocument(marshal(doc))
  }

  &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; MGOProtoMsg {
    def fromProto(msg: sdp.grpc.services.ProtoMGOContext) &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context(
      dbName &lt;/span&gt;=&lt;span&gt; msg.dbName,
      collName &lt;/span&gt;=&lt;span&gt; msg.collName,
      commandType &lt;/span&gt;=&lt;span&gt; msg.commandType,
      bsonParam &lt;/span&gt;=&lt;span&gt; msg.bsonParam.map(protoToBson),
      resultOptions &lt;/span&gt;= msg.resultOptions.map(r =&amp;gt;&lt;span&gt; ResultOptions.fromProto(r)),
      options &lt;/span&gt;= msg.options.map(a =&amp;gt;&lt;span&gt; unmarshal[Any](a.value)),
      documents &lt;/span&gt;= msg.documents.map(doc =&amp;gt;&lt;span&gt; unmarshal[Document](doc.document)),
      targets &lt;/span&gt;=&lt;span&gt; msg.targets,
      adminOptions &lt;/span&gt;= msg.adminOptions.map(ado =&amp;gt;&lt;span&gt; AdminContext.fromProto(ado))
    )
  }

  def bsonToProto(bson: Bson) &lt;/span&gt;=&lt;span&gt;
    ProtoMGOBson(marshal(bson.toBsonDocument(
      classOf[org.mongodb.scala.bson.collection.immutable.Document],DEFAULT_CODEC_REGISTRY)))

  def protoToBson(proto: ProtoMGOBson): Bson &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bson {
    val bsdoc &lt;/span&gt;=&lt;span&gt; unmarshal[BsonDocument](proto.bson)
    &lt;/span&gt;&lt;span&gt;override&lt;/span&gt; def toBsonDocument[TDocument](documentClass: Class[TDocument], codecRegistry: CodecRegistry): BsonDocument =&lt;span&gt; bsdoc
  }

  def ctxFromProto(proto: ProtoMGOContext): MGOContext &lt;/span&gt;=&lt;span&gt; proto.commandType match {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_FIND =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
        action &lt;/span&gt;=&lt;span&gt; Some(Find())
      )
      def toResultOption(rts: Seq[ProtoMGOResultOption]): FindObservable[Document] &lt;/span&gt;=&amp;gt; FindObservable[Document] = findObj =&amp;gt;&lt;span&gt;
        rts.foldRight(findObj)((a,b) &lt;/span&gt;=&amp;gt;&lt;span&gt; ResultOptions.fromProto(a).toFindObservable(b))

      (proto.bsonParam, proto.resultOptions, proto.only) match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Nil, Nil, None) =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Nil, Nil, Some(b)) =&amp;gt; ctx.setCommand(Find(firstOnly =&lt;span&gt; b))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (bp,Nil,None) =&amp;gt;&lt;span&gt; ctx.setCommand(
          Find(filter &lt;/span&gt;=&lt;span&gt; Some(protoToBson(bp.head))))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (bp,Nil,Some(b)) =&amp;gt;&lt;span&gt; ctx.setCommand(
          Find(filter &lt;/span&gt;= Some(protoToBson(bp.head)), firstOnly =&lt;span&gt; b))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (bp,fo,None) =&amp;gt;&lt;span&gt; {
          ctx.setCommand(
            Find(filter &lt;/span&gt;=&lt;span&gt; Some(protoToBson(bp.head)),
              andThen &lt;/span&gt;=&lt;span&gt; fo.map(ResultOptions.fromProto)
            ))
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (bp,fo,Some(b)) =&amp;gt;&lt;span&gt; {
          ctx.setCommand(
            Find(filter &lt;/span&gt;=&lt;span&gt; Some(protoToBson(bp.head)),
              andThen &lt;/span&gt;=&lt;span&gt; fo.map(ResultOptions.fromProto),
              firstOnly &lt;/span&gt;=&lt;span&gt; b))
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt;&lt;span&gt; ctx
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_COUNT =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
        action &lt;/span&gt;=&lt;span&gt; Some(Count())
      )
      (proto.bsonParam, proto.options) match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Nil, None) =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (bp, None) =&amp;gt;&lt;span&gt; ctx.setCommand(
          Count(filter &lt;/span&gt;=&lt;span&gt; Some(protoToBson(bp.head)))
        )
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Nil,Some(o)) =&amp;gt;&lt;span&gt; ctx.setCommand(
          Count(options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt;&lt;span&gt; ctx
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_DISTICT =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
        action &lt;/span&gt;= Some(Distict(fieldName =&lt;span&gt; proto.targets.head))
      )
      (proto.bsonParam) match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Nil =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; bp: Seq[ProtoMGOBson] =&amp;gt;&lt;span&gt; ctx.setCommand(
          Distict(fieldName &lt;/span&gt;= proto.targets.head,filter =&lt;span&gt; Some(protoToBson(bp.head)))
        )
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; _ =&amp;gt;&lt;span&gt; ctx
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_AGGREGATE =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
        action &lt;/span&gt;= Some(Aggregate(proto.bsonParam.map(p =&amp;gt;&lt;span&gt; protoToBson(p))))
      )
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_LISTCOLLECTION =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_QUERY,
        action &lt;/span&gt;=&lt;span&gt; Some(ListCollection(proto.dbName)))
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_INSERT =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_UPDATE,
        action &lt;/span&gt;=&lt;span&gt; Some(Insert(
          newdocs &lt;/span&gt;= proto.documents.map(doc =&amp;gt;&lt;span&gt; unmarshal[Document](doc.document))))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt;&lt;span&gt; ctx.setCommand(Insert(
          newdocs &lt;/span&gt;= proto.documents.map(doc =&amp;gt;&lt;span&gt; unmarshal[Document](doc.document)),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_DELETE =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_UPDATE,
        action &lt;/span&gt;=&lt;span&gt; Some(Delete(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head)))
      )
      (proto.options, proto.only) match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (None,None) =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (None,Some(b)) =&amp;gt;&lt;span&gt; ctx.setCommand(Delete(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          onlyOne &lt;/span&gt;=&lt;span&gt; b))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Some(o),None) =&amp;gt;&lt;span&gt; ctx.setCommand(Delete(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Some(o),Some(b)) =&amp;gt;&lt;span&gt; ctx.setCommand(Delete(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)),
          onlyOne &lt;/span&gt;=&lt;span&gt; b)
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_REPLACE =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_UPDATE,
        action &lt;/span&gt;=&lt;span&gt; Some(Replace(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          replacement &lt;/span&gt;=&lt;span&gt; unmarshal[Document](proto.documents.head.document)))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt;&lt;span&gt; ctx.setCommand(Replace(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          replacement &lt;/span&gt;=&lt;span&gt; unmarshal[Document](proto.documents.head.document),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_COMMAND_UPDATE =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_UPDATE,
        action &lt;/span&gt;=&lt;span&gt; Some(Update(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          update &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.tail.head)))
      )
      (proto.options, proto.only) match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (None,None) =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (None,Some(b)) =&amp;gt;&lt;span&gt; ctx.setCommand(Update(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          update &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.tail.head),
          onlyOne &lt;/span&gt;=&lt;span&gt; b))
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Some(o),None) =&amp;gt;&lt;span&gt; ctx.setCommand(Update(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          update &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.tail.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (Some(o),Some(b)) =&amp;gt;&lt;span&gt; ctx.setCommand(Update(
          filter &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.head),
          update &lt;/span&gt;=&lt;span&gt; protoToBson(proto.bsonParam.tail.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)),
          onlyOne &lt;/span&gt;=&lt;span&gt; b)
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_DROPCOLLECTION =&amp;gt;
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;=&lt;span&gt; Some(DropCollection(proto.collName))
      )
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_CREATECOLLECTION =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;=&lt;span&gt; Some(CreateCollection(proto.collName))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt;&lt;span&gt; ctx.setCommand(CreateCollection(proto.collName,
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_CREATEVIEW =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;= Some(CreateView(viewName =&lt;span&gt; proto.targets.head,
          viewOn &lt;/span&gt;=&lt;span&gt; proto.targets.tail.head,
          pipeline &lt;/span&gt;= proto.bsonParam.map(p =&amp;gt;&lt;span&gt; protoToBson(p))))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt; ctx.setCommand(CreateView(viewName =&lt;span&gt; proto.targets.head,
          viewOn &lt;/span&gt;=&lt;span&gt; proto.targets.tail.head,
          pipeline &lt;/span&gt;= proto.bsonParam.map(p =&amp;gt;&lt;span&gt; protoToBson(p)),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_CREATEINDEX=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;= Some(CreateIndex(key =&lt;span&gt; protoToBson(proto.bsonParam.head)))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt; ctx.setCommand(CreateIndex(key =&lt;span&gt; protoToBson(proto.bsonParam.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_DROPINDEXBYNAME=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;= Some(DropIndexByName(indexName =&lt;span&gt; proto.targets.head))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt; ctx.setCommand(DropIndexByName(indexName =&lt;span&gt; proto.targets.head,
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_DROPINDEXBYKEY=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;= Some(DropIndexByKey(key =&lt;span&gt; protoToBson(proto.bsonParam.head)))
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt; ctx.setCommand(DropIndexByKey(key =&lt;span&gt; protoToBson(proto.bsonParam.head),
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MGO_ADMIN_DROPALLINDEXES=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MGOContext(
        dbName &lt;/span&gt;=&lt;span&gt; proto.dbName,
        collName &lt;/span&gt;=&lt;span&gt; proto.collName,
        actionType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN,
        action &lt;/span&gt;=&lt;span&gt; Some(DropAllIndexes())
      )
      proto.options match {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; ctx
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(o) =&amp;gt;&lt;span&gt; ctx.setCommand(DropAllIndexes(
          options &lt;/span&gt;=&lt;span&gt; Some(unmarshal[Any](o.value)))
        )
      }
    }

  }

  def ctxToProto(ctx: MGOContext): Option[sdp.grpc.services.ProtoMGOContext] &lt;/span&gt;=&lt;span&gt; ctx.action match {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; None =&amp;gt;&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Some(act) =&amp;gt;&lt;span&gt; act match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Count(filter, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_COUNT,
          bsonParam &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt; (filter ==&lt;span&gt; None) Seq.empty[ProtoMGOBson]
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Seq(bsonToProto(filter.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))},
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
                      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
      ))
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Distict(fieldName, filter) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_DISTICT,
          bsonParam &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt; (filter ==&lt;span&gt; None) Seq.empty[ProtoMGOBson]
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Seq(bsonToProto(filter.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))},
          targets &lt;/span&gt;=&lt;span&gt; Seq(fieldName)

        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Find(filter, andThen, firstOnly) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_FIND,
          bsonParam &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt; (filter ==&lt;span&gt; None) Seq.empty[ProtoMGOBson]
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Seq(bsonToProto(filter.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))},
          resultOptions &lt;/span&gt;=&lt;span&gt; andThen.map(_.toProto)
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Aggregate(pipeLine) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_AGGREGATE,
          bsonParam &lt;/span&gt;=&lt;span&gt; pipeLine.map(bsonToProto)
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Insert(newdocs, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_INSERT,
          documents &lt;/span&gt;= newdocs.map(d =&amp;gt;&lt;span&gt; ProtoMGODocument(marshal(d))),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Delete(filter, options, onlyOne) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_DELETE,
          bsonParam &lt;/span&gt;=&lt;span&gt; Seq(bsonToProto(filter)),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) },
          only &lt;/span&gt;=&lt;span&gt; Some(onlyOne)
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Replace(filter, replacement, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_REPLACE,
          bsonParam &lt;/span&gt;=&lt;span&gt; Seq(bsonToProto(filter)),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) },
          documents &lt;/span&gt;=&lt;span&gt; Seq(ProtoMGODocument(marshal(replacement)))
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Update(filter, update, options, onlyOne) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_COMMAND_UPDATE,
          bsonParam &lt;/span&gt;=&lt;span&gt; Seq(bsonToProto(filter),bsonToProto(update)),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) },
          only &lt;/span&gt;=&lt;span&gt; Some(onlyOne)
        ))


      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; DropCollection(coll) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; coll,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_DROPCOLLECTION
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; CreateCollection(coll, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; coll,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_CREATECOLLECTION,
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; ListCollection(dbName) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_LISTCOLLECTION
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; CreateView(viewName, viewOn, pipeline, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_CREATEVIEW,
          bsonParam &lt;/span&gt;=&lt;span&gt; pipeline.map(bsonToProto),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) },
          targets &lt;/span&gt;=&lt;span&gt; Seq(viewName,viewOn)
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; CreateIndex(key, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_CREATEINDEX,
          bsonParam &lt;/span&gt;=&lt;span&gt; Seq(bsonToProto(key)),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))


      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; DropIndexByName(indexName, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_DROPINDEXBYNAME,
          targets &lt;/span&gt;=&lt;span&gt; Seq(indexName),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; DropIndexByKey(key, options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_DROPINDEXBYKEY,
          bsonParam &lt;/span&gt;=&lt;span&gt; Seq(bsonToProto(key)),
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))


      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; DropAllIndexes(options) =&amp;gt;&lt;span&gt;
        Some(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; sdp.grpc.services.ProtoMGOContext(
          dbName &lt;/span&gt;=&lt;span&gt; ctx.dbName,
          collName &lt;/span&gt;=&lt;span&gt; ctx.collName,
          commandType &lt;/span&gt;=&lt;span&gt; MGO_ADMIN_DROPALLINDEXES,
          options &lt;/span&gt;= { &lt;span&gt;if&lt;/span&gt;(options ==&lt;span&gt; None) Some(ProtoAny(com.google.protobuf.ByteString.EMPTY))
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; Some(ProtoAny(marshal(options.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;))) }
        ))

    }
  }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sun, 26 Aug 2018 04:31:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>我在前面提到过MongoDB不支持像SQL般字符式的操作指令，所以我们必须对所有的MongoDB操作指令建立protobuf类型才能支持MongoDB指令的序列化。在对上一篇博文里我们把MongoDB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/9536859.html</dc:identifier>
</item>
<item>
<title>scala的多种集合的使用(7)之集Set的操作方法 - IoT慧智星</title>
<link>http://www.cnblogs.com/zhaohadoopone/p/9534982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaohadoopone/p/9534982.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1.给集添加元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)用+=、++=和add给可变集添加元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var set = scala.collection.mutable.Set[Int]()
set: scala.collection.mutable.Set[Int] = Set()

scala&amp;gt; set += 1
res48: scala.collection.mutable.Set[Int] = Set(1)

scala&amp;gt; set += (2,3)
res49: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala&amp;gt; set ++= Vector(4,5)
res50: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&amp;gt; set.add(6)
res51: Boolean = true

scala&amp;gt; set
res52: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 6, 3, 4)

scala&amp;gt; set.add(5)
res53: Boolean = false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)使用+和++方法，通过向前一个集添加元素生成一个新的集。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val set = Set(1,3,5,2,7)
set: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 7, 3)

scala&amp;gt; val set1 = set + (8,9)
set1: scala.collection.immutable.Set[Int] = Set(5, 1, 9, 2, 7, 3, 8)

scala&amp;gt; val set2 = set1 ++ List(10,11)
set2: scala.collection.immutable.Set[Int] = Set(5, 10, 1, 9, 2, 7, 3, 11, 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2.从集中删除元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)处理可变集时，用-=和--=从集中删除元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var set = scala.collection.mutable.Set(1,2,3,4,5)
set: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&amp;gt; set -= 1
res57: scala.collection.mutable.Set[Int] = Set(5, 2, 3, 4)

scala&amp;gt; set -= (2,3)
res58: scala.collection.mutable.Set[Int] = Set(5, 4)

scala&amp;gt; set --= Array(4,5)
res59: scala.collection.mutable.Set[Int] = Set()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)处理可变集，retain和clear删除集中元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var set = scala.collection.mutable.Set(1,2,3,4,5)
set: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&amp;gt; set.retain(_ &amp;gt; 2);println(set)
Set(5, 3, 4)

scala&amp;gt; set.clear;println(set)
Set()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)处理可变集时，remove的返回值可以提示集是否有元素被删除。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var set = scala.collection.mutable.Set(1,2,3,4,5)
set: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala&amp;gt; set.remove(2);println(set)
Set(1, 5, 3, 4)

scala&amp;gt; set.remove(3)
res64: Boolean = true

scala&amp;gt; set
res65: scala.collection.mutable.Set[Int] = Set(1, 5, 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4)处理不可变集时，可以使用-和--操作符删除元素，同时将结果重新赋给一个新的变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val s1 = Set(1,2,3,4,5)
s1: scala.collection.immutable.Set[Int] = Set(5, 1, 2, 3, 4)

scala&amp;gt; val s2 = s1 -1
s2: scala.collection.immutable.Set[Int] = Set(5, 2, 3, 4)

scala&amp;gt; val s3 = s2 - (2,3)
s3: scala.collection.immutable.Set[Int] = Set(5, 4)

scala&amp;gt; val s4 = s3 -- Array(4,5)
s4: scala.collection.immutable.Set[Int] = Set()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;3.使用可排序集&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)SortedSet返回元素时有序的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val s = scala.collection.SortedSet(3,1,2,5,6,9)
s: scala.collection.SortedSet[Int] = TreeSet(1, 2, 3, 5, 6, 9)

scala&amp;gt; val s = scala.collection.SortedSet(&quot;c&quot;,&quot;g&quot;,&quot;a&quot;,&quot;b&quot;)
s: scala.collection.SortedSet[String] = TreeSet(a, b, c, g)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)LinkedHashSet按照插入顺序保存元素的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val s = scala.collection.mutable.LinkedHashSet(10,8,3,5,7)
s: scala.collection.mutable.LinkedHashSet[Int] = Set(10, 8, 3, 5, 7)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 26 Aug 2018 04:21:00 +0000</pubDate>
<dc:creator>IoT慧智星</dc:creator>
<og:description>1.给集添加元素 1)用+=、++=和add给可变集添加元素。 2)使用+和++方法，通过向前一个集添加元素生成一个新的集。 2.从集中删除元素 1)处理可变集时，用-=和 从集中删除元素。 2)处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaohadoopone/p/9534982.html</dc:identifier>
</item>
<item>
<title>数据结构（java版）学习笔记（四）——线性表之循环链表 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/9536510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/9536510.html</guid>
<description>&lt;h2 id=&quot;单向循环链表&quot;&gt;单向循环链表&lt;/h2&gt;
&lt;p&gt;PS：有阴影的结点是头结点&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念：&lt;/h3&gt;
&lt;p&gt;最后一个结点的链域值不为NULL，而是指向头结点&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826104305821-1106597394.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826110055100-359193811.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点：&lt;/h3&gt;
&lt;p&gt;从表中的任意结点出发，都可以找到表中其他结点&lt;/p&gt;
&lt;h3 id=&quot;循环条件&quot;&gt;循环条件&lt;/h3&gt;
&lt;p&gt;p==h&lt;/p&gt;
&lt;h2 id=&quot;双向链表&quot;&gt;双向链表&lt;/h2&gt;
&lt;h3 id=&quot;概念-1&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;链表中的每一个结点有两个指针域，一个指向前趋，另外一个指向后继&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826105445893-2114867572.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826105841515-1722536937.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;双向循环链表&quot;&gt;双向循环链表&lt;/h2&gt;
&lt;h3 id=&quot;概念-2&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;双向链表中的头结点的前趋指针域指向了尾结点，尾结点的后继指针域指向了头结点，即可称为双向循环链表&lt;/p&gt;
&lt;h3 id=&quot;判空条件&quot;&gt;判空条件&lt;/h3&gt;
&lt;p&gt;头结点的前趋指针与后继指针指向了本身&lt;/p&gt;
&lt;h3 id=&quot;插入算法&quot;&gt;插入算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在p结点前插入新结点&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826112218906-1235784444.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;s.prior = p.prior;&lt;/li&gt;
&lt;li&gt;p.prior.next = s;&lt;/li&gt;
&lt;li&gt;s.next = p;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;p.prior = s;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; boolean insert(DulNode h,int i,char x){
     DulNode p,s;
     int j = 1;
     p = h.next;//从第一个结点开始
     //查找第i个结点，当p指向头结点h或p指向第i个结点结束
     while(p!=h||j&amp;lt;i){
         j++;
         p = p.next;
     }
     if(j==i){
         s = new DulNode();//初始化s结点
         s.data =x;//存放数据在s结点
         s.prior = p.prior;
         p.prior.next =s;
         s.next =p;
         p.prior =s;
         return true;
     }else{
         return false;
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除算法&quot;&gt;删除算法&lt;/h3&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180826113608170-44483946.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;p.prior.next = p.next;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;p.next.prior = p.prior;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; boolean delete(DulNode h,int i,char x){
     DulNode p,s;
     int j = 1;
     p = h.next;//从第一个结点开始
     //查找第i个结点，当p指向头结点h或p指向第i个结点结束
     while(p!=h||j&amp;lt;i){
         j++;
         p = p.next;
     }
     if(j==i){
         p.prior.next = p.next;
         p.next.prior = p.prior;
         return true;
     }else{
         return false;
     }
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 26 Aug 2018 03:40:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description>单向循环链表 PS：有阴影的结点是头结点 概念： 最后一个结点的链域值不为NULL，而是指向头结点 特点： 从表中的任意结点出发，都可以找到表中其他结点 循环条件 p==h 双向链表 概念 链表中的每</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/9536510.html</dc:identifier>
</item>
<item>
<title>STL——模拟实现空间配置器 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/9520226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/9520226.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;我们在日常编写C++程序时，常常会用到我们的STL标准库来帮助我们解决问题，这当中我们用得最多估计就是它里面的vector、list容器了，它们带来的便利不用多说（毕竟OJ、刷题什么的，基本全是它们的身影），而在日常学习中我们对STL中另一大组件&lt;strong&gt;—空间配置器&lt;/strong&gt; 了解可能就相对较少了。不过它也是个有用的东西，之所以这么说，主要就在于它解决了在内存分配过程中出现的内存碎片问题，具体就是&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201808/1272978-20180826112755650-341515086.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，对于一块从堆上分配的内存，由于对该块内存的释放通常是不确定的，通常取决于用户，对于刚释放完的那32字节，虽归还给了os，但由于中间都是碎片化的内存，所以此时想要利用那32字节再从os申请20字节内存却无法完成了。&lt;br/&gt;而在多线程环境下，这种内存碎片问题带来的影响就更大了，多个线程频繁的进行内存申请和释放，同时申请、释放的内存块有大有小；程序执行过程当中这些碎片的内存就有可能间接造成内存浪费，再一个os要对这样频繁的操作管理，势必会影响到它的效率。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;sgi版本空间配置器stdalloc&quot;&gt;SGI版本空间配置器—std::alloc&lt;/h2&gt;
&lt;p&gt;STL中配置器总是隐藏在一切组间（具体说是，container）的背后，默默工作。但站在STL实现角度看，我们第一个需要搞清楚的就是空间配置器，因为我们操作所有STL对象基本都会存放容器当中，而容器一定需要配置空间来置放资料的，不弄清它的原理，以后STL使用中就可能遭遇更多的绊脚石。&lt;br/&gt;&lt;strong&gt;std::alloc&lt;/strong&gt; 是SGI STL中默认的空间配置器。如：&lt;br/&gt;&lt;code&gt;vector&amp;lt;int, std::alloc&amp;gt; iv&lt;/code&gt;&lt;br/&gt;是的，它的写法好像并不是标准的写法（标准写法应该是allocator），而且它也不接受参数，但这并不会给我们带来困扰，因为它是默认的，很少需要我们自行指定配置器名称。（至于为什么不用allocator这个更标准的写法，这源于它的效率问题。具体可以参考&lt;strong&gt;STL源码剖析&lt;/strong&gt;），今天主要来看看alloc版本配置器实现原理，加深自己关于空间分配的理解。&lt;/p&gt;&lt;p&gt;配置器要完成的其实就是对象构造前的空间配置和对象析构后的空间释放。参考SGI中做法配置器对此设计要考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;向系统堆空间获取空间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑多线程状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑内存不足时的应对措施&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑过多“小型区块” 可能带来的内存碎片问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于此，alloc实现中设计了双层级配置器模型。一级配置器直接使用malloc和free，二级配置器则视情况采取不同的策略，具体来讲就是：当需求的内存块超过128字节时，就将其视为大块内存需求，便直接调用一级配置器来分配；当需要内存块&amp;lt; 128字节，便交由二级配置器来管理（这当中可能还联合一级配置器一起使用，具体原因在后面）。&lt;/p&gt;
&lt;h2 id=&quot;一级空间配置器&quot;&gt;一级空间配置器&lt;/h2&gt;
&lt;p&gt;首先，一级配置器STL默认名通常是&lt;code&gt;__malloc_alloc_template&amp;lt;0&amp;gt;&lt;/code&gt;.在STL实现中将它typedef为了alloc。然后 要注意的是源于&lt;code&gt;__USE_MALLOC&lt;/code&gt;通常未定义，它在STL中并不是默认的配置器。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一级配置器模拟实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#pragma once

#include &amp;lt;iostream&amp;gt;
#include &amp;lt;windows.h&amp;gt;
using namespace std;

//一级空间配置器
typedef void(*HANDLE_FUNC)();

template &amp;lt;int inst&amp;gt; // inst为预留参数，方便以后扩展
class __MallocAllocTemplate 
{
private:
    /*定义函数指针类型成员，方便回调执行用户
    自定义的内存释放函数，该成员默认设置不执行*/
    static HANDLE_FUNC __malloc_alloc_oom_handler;

    static void* OOM_Malloc(size_t n){
        while (1){
            if (0 == __malloc_alloc_oom_handler){
                throw bad_alloc();
            }else{
                __malloc_alloc_oom_handler();  //释放内存
                Sleep(200);
                void* ret = malloc(n);
                if (ret)
                    return ret;
            }
        }
    }
public:
    static void* Allocate(size_t n){
        void *result = malloc(n);
        //malloc申请失败，执行OOM_Malloc再请求申请内存
        if (0 == result)
            result = OOM_Malloc(n);
        cout&amp;lt;&amp;lt;&quot;申请成功!&quot;&amp;lt;&amp;lt;endl;
        return result;
    }

    static void Deallocate(void *p, size_t /* n */){
        free(p);
    }
    /*设置oom_malloc句柄函数，*/
    static HANDLE_FUNC SetMallocHandler(HANDLE_FUNC f){
        HANDLE_FUNC old = f;
        __malloc_alloc_oom_handler = f;
        return old;
    }
};

template&amp;lt;int inst&amp;gt;
HANDLE_FUNC __MallocAllocTemplate&amp;lt;inst&amp;gt;::__malloc_alloc_oom_handler = 0;

//自定义的内存释放函数
static void FreeMemory(){
    cout&amp;lt;&amp;lt;&quot;执行用户自定义函数，开始释放内存...&quot;&amp;lt;&amp;lt;endl;
}
void Test_Alloc1();
void Test_Alloc2();&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;关于一级配置器实现中.-注意两个地方&quot;&gt;关于一级配置器实现中. 注意两个地方：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;当中的内存分配Allocate和释放Dellocate都是简单封装malloc和free，同时该类的成员函数中都是用&lt;strong&gt;static修饰的静态成员函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;之所以设置为静态成员函数，是想要在类外部直接进行调用，而不去创建对象。配置器面向的单位是进程。由于在一个进程中可能存在不同的容器，它们都会向空间配置器要内存。与此同时C++中注重封装，所以又将它们用class进行了封装&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;实现了一个&lt;strong&gt;static void* OOM_Malloc(size_t )&lt;/strong&gt; 函数 。这通常是在一次malloc调用失败后，再去调用它来抛出bad_alloc异常。但这里设计考虑它的扩展性。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;一级配置器类中声明了一个&lt;strong&gt;函数指针类型&lt;/strong&gt;成员“**__malloc_alloc_oom_handler&lt;strong&gt;” 如果用户自己有帮助os得到空间加以分配freeMemory方法，就可以通过该成员 ，让&lt;/strong&gt;OOM_malloc**中回调你的freeMemor函数进而帮助os获得内存，使得malloc分配成功。&lt;/li&gt;
&lt;li&gt;可以通过&lt;strong&gt;static HANDLE_FUNC SetMallocHandler(HANDLE_FUNC f)&lt;/strong&gt;来进行设置该__malloc_alloc_oom_handler成员&lt;/li&gt;
&lt;li&gt;这一般是自己设计的一种策略。设计这个函数就是一个提升空间配置器效率的一个方法，因为要保证malloc尽可能的成功。这一般是大佬去玩儿的。我们这还是乖乖把句柄函数初始化为0，使用默认的方式吧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现完了一级配置器，但从前面我们知道，这个一级的配置器效率并不高，所以STL真正具有设计哲学接下来就是下面的二级配置器了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;二级空间配置器&quot;&gt;二级空间配置器&lt;/h2&gt;
&lt;p&gt;首先当调用方需求的内存小于128字节时，此时便要利用二级配置器来分配内存了，当然不仅仅如此，这个二级配置器还要进行内存回收工作。整个空间配置器正是因为它才能达到真正的迅速分配内存。而缘由还要从它的组成结构开始说起&lt;br/&gt;&lt;strong&gt;它的组成结构有两个：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一个内存池（一大块内存）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个自由链表（&lt;/strong&gt;freelist&lt;strong&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201808/1272978-20180826112822722-912247281.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意到有两个指针&lt;strong&gt;startFree、endfree&lt;/strong&gt;，它们就相当于水位线的一种东西，它表示了内存池的大小。&lt;br/&gt;自由链表中其实是一个大小为16的指针数组，间隔为8的倍数。各自管理大小分别为8，16，24 &lt;strong&gt;. . .&lt;/strong&gt; 120，128 字节的小额区块。在每个下标下挂着一个链表，把同样大小的内存块链接在一起。（这貌似就是哈希桶吧！）&lt;/p&gt;
&lt;h4 id=&quot;分配内存过程&quot;&gt;分配内存过程：&lt;/h4&gt;
&lt;p&gt;首先，当我们的容器向配置器申请&amp;lt;128小块内存时，先就要从对应的链表中取得一块。具体就是：拿着申请内存大小进行近似除8的方法算得在这个指针数组中下标，紧接着就可以从链表中取出第一块内存返回。当一块内存用完，用户释放时，进行同样的操作，接着计算对于的下标再将该块内存头插到对应链表中。&lt;br/&gt;（当然实际计算这些对应下标时，采用两个更准确、高效的函数，见后面，这里只是简单分析）&lt;/p&gt;&lt;p&gt;看看&lt;strong&gt;链表结点结构和链接&lt;/strong&gt;&lt;br/&gt;二级配置器中有一个这样结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;union Obj{
        union Obj* _freelistlink;
        char client_data[1];    /* The client sees this.  用来调试用的*/
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意到这是一个联合体, 这个结构起的作用就是&lt;/strong&gt;一块内存块空闲时，就在一个内存块中抠出4个字节大小来，然后强制这个&lt;strong&gt;obj&lt;/strong&gt;以此来链接到下一个空闲块，当这个内存块交付给用户时，它就直接存储用户的数据。obj* 是4个字节那么大，但是大部分内存块大于4。我们想要做的只是将一块块内存区块链接起来，我们不用看到内存里所有的东西，所以我们可以只用强转为obj*就可以实现大内存块的链接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再一个就是自由链表中的不同下标下区块都是以8为单位往上增的，并且最小得为8字节&lt;/strong&gt; 。理由很简单，因为我们还要考虑在64位机子的环境。因为每一个区块至少要存下一个obj*，这样才能把小区块连接起来。&lt;/li&gt;
&lt;li&gt;也正是源于上面这样的原因。若我们仅仅需求5字节内存，就造成3字节浪费；所以我们的这个二级配置器引入了另一个问题——&lt;strong&gt;内碎片问题&lt;/strong&gt;（前面我们配合自由链表解决的只是os分配内存外碎片问题）。对于链接起来的小区块，我们同样不能对它百分百的利用，毕竟万事终难全嘛。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，我们到这讨论的还基于一个前提上——freelist下面挂有链接起来的小区块。&lt;strong&gt;当freelist上的某个位置下面没有挂上这些小区块呢？&lt;/strong&gt;这就是下面&lt;strong&gt;Refill&lt;/strong&gt;，&lt;strong&gt;chunkAlloc&lt;/strong&gt;这两个函数要干的事情了。&lt;/p&gt;
&lt;h4 id=&quot;二级配置器相关接口&quot;&gt;二级配置器相关接口：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#pragma once
#include &quot;Allocator.h&quot;

///////////////////////////////////////////////////////////////////////
//二级空间配置器

template &amp;lt;bool threads, int inst&amp;gt;
class __DefaultAllocTemplate
{
public:
    // 65   72  -&amp;gt; index=8
    // 72   79
    static size_t FREELIST_INDEX(size_t n){
        return ((n + __ALIGN-1)/__ALIGN - 1);
    }

    // 65   72  -&amp;gt; 72
    // 72   79
    static size_t ROUND_UP(size_t bytes)  {
        return (((bytes) + __ALIGN-1) &amp;amp; ~(__ALIGN - 1));
    }
    
    static void* ChunkAlloc(size_t size, size_t&amp;amp; nobjs);//获取大块内存    
    static void* Refill(size_t bytes);                  //填充自由链表    
    static void* Allocate(size_t n);                    //分配返回小内存块  
    static void Deallocate(void* p, size_t n);          //管理回收内存

private:
    enum {__ALIGN = 8 };
    enum {__MAX_BYTES = 128 }; 
    enum {__NFREELISTS = __MAX_BYTES/__ALIGN };

    union Obj{
        union Obj* _freelistlink;
        char client_data[1];    /* The client sees this.  用来调试用的*/
    };

    // 自由链表
    static Obj* _freelist[__NFREELISTS];

    // 内存池
    static char* _startfree;
    static char* _endfree;
    static size_t _heapsize;
};

//__DefaultAllocTemplate成员初始化
template &amp;lt;bool threads, int inst&amp;gt;
typename __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::Obj*
__DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::_freelist[__NFREELISTS] = {0};

// 内存池
template &amp;lt;bool threads, int inst&amp;gt;
char* __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::_startfree = NULL;

template &amp;lt;bool threads, int inst&amp;gt;
char* __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::_endfree = NULL;

template &amp;lt;bool threads, int inst&amp;gt;
size_t __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::_heapsize = 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;refillchunkalloc函数&quot;&gt;Refill、chunkAlloc函数&lt;/h2&gt;
&lt;p&gt;前面说了，当我们需求的内存块在所对自由链表的下标处没挂有内存块时，我们就必须调用refill去填充自由链表了。申请时一般一次性申请20个内存块大小的内存（可参加STL实现源码）。&lt;br/&gt;&lt;strong&gt;那又从那里找呢？&lt;/strong&gt;——当然内存池啦！分配这么大块内存到二级配置器就是现在来用的。可以通过移动startFree指针快速地从内存池内给“切割”出来这一段内存，然后按照大小切成小块挂在自由链表下面。&lt;strong&gt;在这个过程中&lt;/strong&gt;可以直接将第一小块内存块返回给用户，其余的再挂在自由链表下，方便下次分配了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;基于这样思路就可以将refill实现如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void* __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::Refill(size_t bytes)
{
    size_t nobjs = 20;   /*默认从内存池取20块对象，填充*/
    //从内存池中拿到一大块内存
    char* chunk = (char*)ChunkAlloc(bytes, nobjs);
    if (nobjs == 1)      /*只取到了一块*/
        return chunk;

    size_t index = FREELIST_INDEX(bytes);
    printf(&quot;返回一个对象，将剩余%u个对象挂到freelist[%u]下面\n&quot;, nobjs-1, index);

    Obj* cur = (Obj*)(chunk + bytes);
    _freelist[index] = cur;
    for (size_t i = 0; i &amp;lt; nobjs-2; ++i){
        Obj* next = (Obj*)((char*)cur + bytes);
        cur-&amp;gt;_freelistlink = next;

        cur = next;
    }

    cur-&amp;gt;_freelistlink = NULL;

    return chunk;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：chunkAlloc向内存池索要内存&lt;/p&gt;
&lt;h4 id=&quot;考虑一个问题&quot;&gt;考虑一个问题&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;到此，我们好像就会有一个疑问。既然简单移动startfree就可以欢快的从内存池取到得一块内存返回，那为什么又要一次性取20块，返回一块，将剩下那19块挂到freelist对应位置下面呢？挨个挂上去还这么麻烦！每次都直接从内存池返回一块内存不是更欢快吗？&lt;/strong&gt;在这里当然不用担心出现外碎片问题。因为在每次内存释放时，可以添加到我们维护的自由链表上，继续下次分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;&lt;strong&gt;而在这里，其实是考虑了高并发的情况：&lt;/strong&gt;这种的并发情况下，当从内存池取的一块需要的内存，无疑会有多个线程同时来操作，startfree执行加法返回一块内存也不是原子操作，所以在此必然就会涉及加锁解锁，同时这些线程取得内存块大小也不统一，所有这么多的线程必然会因为这里的锁而影响执行速度，影响效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一次性取上20块就能缓解这种状况&lt;/strong&gt;，当多个线程要取的内存块不一样时，此时便不会锁住，因为是从不同链表上取；此时，锁只会锁在多个线程从同一个链表上取一块相同大小内存上。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;虽然从内存池取一段内存操作也涉及着加锁，但由于调用Refill填充自由链表次数相对会少很多，所以上面这样一次性取20块做法是可以提高高并发下程序执行效率。&lt;p&gt;&lt;strong&gt;接下来就是chuncAlloc函数&lt;/strong&gt;&lt;br/&gt;它表示从内存池那一大块内存，同时也尽可能保证内存池像水池一样有“水”。&lt;strong&gt;它遵循4条方针:&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存池内存够多，直接“大方的”返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存池内存有些吃紧了，尽量返回调用方需求的内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存池“穷得吃土”了，需要求助os来malloc来为它补充“源头活水”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;os也“吃土”了，内存池“灵机一动”，打上了后面自由链表的主意。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;都一无所获，内存池最后一搏，调用一级配置器&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后一级配置器基于自己的out-of-memory处理机制，或许有机会释放其它的内存拿来此处使用。如果可以就成功“帮助”内存池，否则发出&lt;strong&gt;bad_alloc&lt;/strong&gt;异常通知用户。&lt;/p&gt;&lt;p&gt;基于这样的思路，便可以模拟实现出ChunkAlloc函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//function：从内存池申请一大块内存
template &amp;lt;bool threads, int inst&amp;gt;
void* __DefaultAllocTemplate&amp;lt;threads, inst&amp;gt;::ChunkAlloc(size_t size, size_t&amp;amp; nobjs)
{
    size_t totalbytes = nobjs*size;
    size_t leftbytes = _endfree - _startfree;

    //a) 内存池中有足够内存
    if (leftbytes &amp;gt;= totalbytes){
        printf(&quot;内存池有足够%u个对象的内存块\n&quot;, nobjs);
        void* ret = _startfree;
        _startfree += totalbytes;
        return ret;

    //b) 内存池仅剩部分对象内存块
    }else if (leftbytes &amp;gt; size){
        nobjs = leftbytes/size;  /*保存能够使用对象块数*/
        totalbytes = size*nobjs;
        printf(&quot;内存池只有%u个对象的内存块\n&quot;, nobjs);

        void* ret = _startfree;
        _startfree += totalbytes;
        return ret;

    //c) 内存池中剩余内存不足一个对象块大小
    }else{
        // 1.先处理掉内存池剩余的小块内存，将其头插到对应自由链表上
        if(leftbytes &amp;gt; 0){
            size_t index = FREELIST_INDEX(leftbytes);
            ((Obj*)_startfree)-&amp;gt;_freelistlink = _freelist[index];
            _freelist[index] = (Obj*)_startfree;
        }

        // 2.调用malloc申请更大的一块内存放入内存池
        size_t bytesToGet = totalbytes*2 + ROUND_UP(_heapsize&amp;gt;&amp;gt;4);
        _startfree = (char*)malloc(bytesToGet);

        printf(&quot;内存池没有内存，到系统申请%ubytes\n&quot;, bytesToGet);
                
        if (_startfree == NULL){    
        //3. malloc申请内存失败，内存池没有内存补给，到更大的自由链表中找
            size_t index = FREELIST_INDEX(size);
            for (; index &amp;lt; __NFREELISTS; ++index){
                //自由链表拿出一块放到内存池
                if (_freelist[index]){              
                    _startfree = (char*)_freelist[index]; //BUG ??
                    Obj* obj = _freelist[index];
                    _freelist[index] = obj-&amp;gt;_freelistlink;
                    return ChunkAlloc(size, nobjs);  
                }
            }
        _endfree = NULL;  /*in case of exception.  ！！保证异常安全*/
            //逼上梁山，最后一搏. 若内存实在吃紧，则一级配置器看看out-of-memory能否尽点力，不行就抛异常通知用户
            _startfree = (char*)__MallocAllocTemplate&amp;lt;0&amp;gt;::Allocate(bytesToGet);
        }
        
        _heapsize += bytesToGet;
        _endfree = _startfree + bytesToGet;
         //递归调用自己，为了修正nobjs
        return ChunkAlloc(size, nobjs);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里也还要注意一个点：就是_&lt;code&gt;endfree= NULL&lt;/code&gt;&lt;/strong&gt;这一句&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这句话很容易被我们忽略掉。这其实是十分重要的一句话，这关乎到异常安全问题，在内存池穷山尽水之时，它取调用了一级配置器，希望一级配置器能否释放一些内存，在chunkAlloc内可以malloc成功，但通常这都是失败的，所以一级配置器便抛出了异常，然而异常抛出并不意味着程序结束，此时的endfree并不为NULL并且可能是较大的数，（endfree保持以前的值）此时的startfree指针是为NULL的。这两者的差值表示着内存池有着&lt;strong&gt;大块的内存&lt;/strong&gt;，然而这已不属于内存池了。&lt;/p&gt;
&lt;h2 id=&quot;整理一下配置器分配的流程&quot;&gt;整理一下配置器分配的流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201808/1272978-20180826112854572-384622522.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后配置器封装的simple_alloc接口&quot;&gt;最后，配置器封装的simple_alloc接口&lt;/h2&gt;
&lt;p&gt;无论alloc被定义为第一级或第二级配置器，SGI还为它包装了一个接口Simple_alloc，使配置器接口符合STL规格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifdef __USE_MALLOC
typedef __MallocAllocTemplate&amp;lt;0&amp;gt; alloc;
#else
typedef __DefaultAllocTemplate&amp;lt;false, 0&amp;gt; alloc;
#endif


template&amp;lt;class T, class Alloc&amp;gt;
class SimpleAlloc 
{
public:
    static T* Allocate(size_t n){ 
        return 0 == n? 0 : (T*) Alloc::Allocate(n * sizeof (T));
    }

    static T* Allocate(void){ 
        return (T*) Alloc::Allocate(sizeof (T));
    }

    static void Deallocate(T *p, size_t n){ 
        if (0 != n)
            Alloc::Deallocate(p, n * sizeof (T));
    }

    static void Deallocate(T *p){ 
        Alloc::Deallocate(p, sizeof (T));
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面内部四个成员函数其实都是单纯的转调用，调用传递给配置器的成员函数，这个接口时配置器的配置单位从bytes转为了个别元素的大小。SGI STL中容器全部使用simple_alloc接口，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt; class T, class Alloc= alloc&amp;gt;
class vector{
protected:
    //专属空间配置器，每次配置一个元素大小
    typedef simple_alloc&amp;lt;value_type, Alloc&amp;gt; data_allocator;
    void deallocate(){
        if(...)
            data_allocator::deallocate(start, end_of_storage- start);
    }
    ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了将问题控制在一定复杂度内，到此以上的这些，仅仅处理了单线程的情况。对于并发的情况，它的处理过程会相对更复杂。我们可以查看STL中空间配置器的源码实现来进一步的学习，这当中又会体现出很多优秀的思想，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;例如，在对chunk_alloc的操作加锁时，就采用了类似“智能指针”的机理。因为在多线程的情况下，在chunk_alloc分配内存时，可能会因为某个线程因异常终止而没有进行解锁的操作，进而使其他线程阻塞，影响程序的执行。&lt;br/&gt;STL中这里加锁，用的是一个封装lock类对象，当这个对象出了作用符就可以自动析构，实现解锁操作，保证了异常安全问题。 所以不难看出，这就是基于&lt;strong&gt;RAII&lt;/strong&gt;思想的实际应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;STL配置器还有许多其它优秀设计，这里只是本人对它的部分认识。为了加深理解，我们可以查看STL中源码进行更深入学习。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tp16b/project/tree/master/alloc/src&quot;&gt;模拟整体实现：https://github.com/tp16b/project/tree/master/alloc/src&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;参考：&lt;/strong&gt;《STL源码剖析》&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 03:30:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<og:description>[TOC] 问题 我们在日常编写C++程序时，常常会用到我们的STL标准库来帮助我们解决问题，这当中我们用得最多估计就是它里面的vector、list容器了，它们带来的便利不用多说（毕竟OJ、刷题什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/9520226.html</dc:identifier>
</item>
<item>
<title>JDK源码分析(三)——HashMap 下（基于JDK8） - 默数至天亮</title>
<link>http://www.cnblogs.com/rain4j/p/9536570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rain4j/p/9536570.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;  在&lt;a href=&quot;https://www.cnblogs.com/rain4j/p/9380606.html&quot;&gt;上文&lt;/a&gt;我们基于JDK7分析了HashMap的实现源码，介绍了HashMap的加载因子loadFactor、阈值threshold概念以及增删元素的机制。JDK8在JDK7的基础上对HashMap的实现进行了进一步的优化，最主要的改变就是新增了红黑树作为底层数据结构。&lt;/p&gt;
&lt;h4 id=&quot;hashmap数据结构&quot;&gt;HashMap数据结构&lt;/h4&gt;
&lt;p&gt;  首先我们回忆一下JDK7中HashMap的实现，HashMap是以数组和单链表构成，当出现哈希冲突时，冲突的元素在桶中依次形成单链表，数据结构如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1156589/201808/1156589-20180826104712411-1050825252.png&quot;/&gt;&lt;br/&gt;JDK7中哈希冲突时使用链表存储冲突元素，当出现大量哈希冲突元素，那么在单链表查找一个元素的复杂度为O(N)，为了优化出现大量哈希冲突元素的查找问题，JDK8中规定：当单链表存储元素个数超过阈值TREEIFY_THRESHOLD（8）时，将单链表转换为红黑树，红黑树查找元素复杂度为O(logN),提高了查找效率，JDK8中HashMap的存储结构：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1156589/201808/1156589-20180826104801981-1615685200.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;内部字段及构造方法&quot;&gt;内部字段及构造方法&lt;/h3&gt;
&lt;h4 id=&quot;node类&quot;&gt;Node类&lt;/h4&gt;
&lt;p&gt;  使用Node类存储键值对元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;treenode类&quot;&gt;TreeNode类&lt;/h4&gt;
&lt;p&gt;  TreeNode是构成红黑树的基本元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion
        boolean red;

        //构造一个树结点
        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, val, next);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;内部字段&quot;&gt;内部字段&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //数组初始容量，为16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16

    //数组最大容量
    static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;

    //默认加载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    //单链表转化为红黑树的阈值
    static final int TREEIFY_THRESHOLD = 8;

    /**
     * 主要用于resize()扩容过程中, 当对原来的红黑树根据hash值拆分成两条链表后,
     * 如果拆分后的链表长度 &amp;lt;=UNTREEIFY_THRESHOLD, 那么就采用链表形式管理hash值冲突;
     * 否则, 采用红黑树管理hash值冲突.
     */
    static final int UNTREEIFY_THRESHOLD = 6;

    /**
     * 当集合中的容量大于这个值时，表中的桶才能进行树化 ，否则桶内元素太多时会扩容，
     * 而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
     */
    static final int MIN_TREEIFY_CAPACITY = 64;

    //第一次使用是初始化，数组长度总是2的幂次
    transient Node&amp;lt;K,V&amp;gt;[] table;

    transient int size;

    int threshold;

    final float loadFactor;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造方法&quot;&gt;构造方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public HashMap(int initialCapacity, float loadFactor) {
        //检查参数合法性
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                    initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                    loadFactor);
        this.loadFactor = loadFactor;
        //这里只是初始化，最终赋值在resize方法里
        this.threshold = tableSizeFor(initialCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;哈希值与索引计算&quot;&gt;哈希值与索引计算&lt;/h3&gt;
&lt;h4 id=&quot;hashobject-key&quot;&gt;hash(Object key)&lt;/h4&gt;
&lt;p&gt;  在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。&lt;br/&gt;  这个方法非常巧妙，它通过h &amp;amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp;amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;amp;比%具有更高的效率。计算过程如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1156589/201808/1156589-20180826104909168-187591999.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }

    //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的
    //根据hash值和table数组长度计算键值对存储位置的索引
    static int indexFor(int h, int length) {  
        return h &amp;amp; (length-1);  //第三步 取模运算
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;存储元素&quot;&gt;存储元素&lt;/h3&gt;
&lt;h4 id=&quot;putk-key-v-value&quot;&gt;put(K key, V value)&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }

    /**
     * Implements Map.put and related methods
     * @param hash hash for key
     * @param key the key 键
     * @param value the value to put 值
     * @param onlyIfAbsent if true, don't change existing value 表示不要更改现有值
     * @param evict if false, the table is in creation mode. false表示table处于创建模式
     * @return previous value, or null if none
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        //使用局部变量tab而不是类成员，方法栈上访问更快
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        //如果table为null或者长度为0，则进行初始化
        if ((tab = table) == null || (n = tab.length) == 0)
            //扩容
            n = (tab = resize()).length;
        //散列到对应的桶中，如果桶为空则直接放到桶中即可
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            //else分支表示散列到的桶中元素不为空
            Node&amp;lt;K,V&amp;gt; e; K k;
            //桶中链表的根节点的key就是要插入的键值对的key
            if (p.hash == hash &amp;amp;&amp;amp;
                    ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            //如果是红黑树，插入到红黑树中
            else if (p instanceof TreeNode)
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            //插入到单链表中
            else {
                //遍历链表，并统计桶中键值对元素数量
                for (int binCount = 0; ; ++binCount) {
                    //该Key在链表中不存在，插入末尾 此时e为null
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        //单链表元素个数超过TREEIFY_THRESHOLD，树化
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                        //注意从这里break出来的e为null
                    }
                    //该Key已经在链表中
                    if (e.hash == hash &amp;amp;&amp;amp;
                            ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        //注意从这里break出来的e不为null
                        break;

                    p = e;
                }
            }
            // e != null，说明该Key已经在存在于HashMap中,在这个桶中
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                //根据onlyIfAbsent和old
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        //超过阈值，就进行扩容
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;扩容&quot;&gt;扩容&lt;/h3&gt;
&lt;h4 id=&quot;resize&quot;&gt;resize( )&lt;/h4&gt;
&lt;p&gt;  resize方法相对比较复杂，但是有比较巧妙，因为要考虑数据结构的不同怎么把元素从老的table中放到扩容后的table中。主要的思路也就是两步：先根据老的table的长度决定扩容后table的长度，以及新的阈值threshold；在桶中数据不为空的情况下，把桶中的数据迁移到新的table数组中，这里就要考虑在桶中只有一个元素（没有发生哈希冲突）、桶中元素以单链表形式存储（发生哈希冲突但是不超过8个）、桶中元素以红黑树形式存储（哈希冲突元素个数超过8个）。只有一个元素，直接根据哈希值和新的table数组长度计算出新的索引，红黑树调用split方法，这里我们重点分析一下怎么把桶中的单链表迁移到新桶中，从而体会到JDK的巧妙设计。&lt;/p&gt;
&lt;p&gt;  resize的扩容策略是每次扩容2倍（newThr = oldThr &amp;lt;&amp;lt; 1），为了把单链表元素迁移到新的桶中，并不是向JDK7那样直接根据哈希值散列得到新的索引值，经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1156589/201808/1156589-20180826105001092-1473982487.jpg&quot;/&gt;&lt;br/&gt;元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1156589/201808/1156589-20180826105027486-1341438840.jpg&quot;/&gt;&lt;br/&gt;因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final Node&amp;lt;K,V&amp;gt;[] resize() {
        //使用oldTab指向原来的hash表，通常方法内都使用局部变量，局部变量在方法栈上，而对象的成员在堆上
        //方法栈的访问比堆更高效
        //记录扩容前table数组，阈值，长度
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            //原来的容量已经很大了，超过了MAXIMUM_CAPACITY无法再调整
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //容量加倍
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                    oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
        //oldCap &amp;lt; 0,oldThr &amp;gt; 0,table空间尚未分配，初始化分配空间
        //旧阀值大于0，则将新容量直接等于就阀值
        else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        //阀值等于0，oldCap也等于0（集合未进行初始化）
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            //threshhold=capacity*load_factor
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //计算新的阀值上限
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                    (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        //原来的表中有内容，表明这是一次扩容，需要将Entry散列到新的位置
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                //遍历所有bin
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    //旧桶中元素置为null，方便GC
                    oldTab[j] = null;
                    //该桶中只有一个节点，直接散列到新的位置
                    if (e.next == null)
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //该桶中是一颗红黑树，通过红黑树的split方法处理
                        //待会再看split方法
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        do {
                            next = e.next;
                            // 与oldCap按位相与，判断结果是一还是零
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        //原索引
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        //原索引+oldCap
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;
&lt;h4 id=&quot;removeobject-key&quot;&gt;remove(Object key)&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public V remove(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
                null : e.value;
    }

    final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
        //tab不为空，p指向根据hash散列到桶中第一个节点
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
                (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
            Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
            //第一个节点就命中
            if (p.hash == hash &amp;amp;&amp;amp;
                    ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                //在红黑树中查找目标节点
                if (p instanceof TreeNode)
                    node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
                    //在单链表中查找目标节点
                else {
                    do {
                        if (e.hash == hash &amp;amp;&amp;amp;
                                ((k = e.key) == key ||
                                        (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //找到目标节点且符合移除的条件
            if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
                    (value != null &amp;amp;&amp;amp; value.equals(v)))) {
                //红黑树移除
                if (node instanceof TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
                //单链表移除
                //移除的节点是单链表首节点
                else if (node == p)
                    tab[index] = node.next;
                //移除的节点不是单链表首节点
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查找元素&quot;&gt;查找元素&lt;/h3&gt;
&lt;h4 id=&quot;getobject-key&quot;&gt;get(Object key)&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k;
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
                (first = tab[(n - 1) &amp;amp; hash]) != null) {
            //hash值对应的桶中第一个元素
            //第一个元素符合查找条件
            if (first.hash == hash &amp;amp;&amp;amp; // always check first node
                    ((k = first.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                //红黑树查找
                if (first instanceof TreeNode)
                    return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);
                do {
                    //单链表查找
                    if (e.hash == hash &amp;amp;&amp;amp;
                            ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  JDK8使用了红黑树优化了HashMap的性能，即使发生了大量的哈希碰撞也能够以O(logN)查找到元素，不会影响到服务器的性能。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 02:53:00 +0000</pubDate>
<dc:creator>默数至天亮</dc:creator>
<og:description>[TOC] 概述   在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rain4j/p/9536570.html</dc:identifier>
</item>
<item>
<title>一看就懂系列之 由浅入深聊一聊php的垃圾回收机制 - datang6777</title>
<link>http://www.cnblogs.com/datang6777/p/9536547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datang6777/p/9536547.html</guid>
<description>&lt;p&gt;是的，平时经常听到大牛说到的gc，就是垃圾回收器，全称Garbage Collection。&lt;/p&gt;
&lt;p&gt;早期版本，准确地说是5.3之前(不包括5.3)的垃圾回收机制，是没有专门的垃圾回收器的。只是简单的判断了一下变量的zval的refcount是否为0，是的话就释放否则不释放直至进程结束。&lt;/p&gt;
&lt;p&gt;乍一看确实没毛病啊，然而其中隐藏着变量内存溢出的风险：&lt;a href=&quot;http://bugs.php.net/bug.php?id=33595&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://bugs.php.net/bug.php?id=33595&lt;/a&gt; ，无法回收的内存造成了内存泄漏，所以PHP5.3出现了专门负责清理垃圾数据、防止内存泄漏的GC。&lt;/p&gt;
&lt;p&gt;下文将由浅入深(凭感觉)来记录下php的垃圾回收机制是怎么一回事？&lt;/p&gt;
&lt;p&gt;1.php引用计数基本知识点&lt;/p&gt;
&lt;p&gt;2.php的内存管理机制&lt;/p&gt;
&lt;p&gt;3.php中垃圾是如何定义的？&lt;/p&gt;
&lt;p&gt;4.老版本php中如何产生内存泄漏？&lt;/p&gt;
&lt;p&gt;5.5.3版本以后php是如何处理垃圾内存的？&lt;/p&gt;
&lt;p&gt;6.涉及到垃圾回收的知识点&lt;/p&gt;

&lt;p&gt;首先必须要先讲讲这个会引起垃圾回收的关键基数是怎么回事？&lt;/p&gt;
&lt;p&gt;关于php的zval结构体，以及refcount与is_ref的知识点，在&lt;a href=&quot;http://blog.csdn.net/u011957758/article/details/72633938&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;菜鸟学php扩展 之 详解php扩展的变量(四) &lt;/a&gt;已描述非常清楚。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不准确但却通俗的说： &lt;br/&gt;refcount：多少个变量是一样的用了相同的值，这个数值就是多少。 &lt;br/&gt;is_ref：bool类型，当refcount大于2的时候，其中一个变量用了地址&amp;amp;的形式进行赋值，好了，它就变成1了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要讲讲如何用php来直观的看到这些计数的变化，走一波。 &lt;br/&gt;首先需要在php上装上xdebug的扩展。&lt;/p&gt;
&lt;p&gt;1.第一步：查看内部结构&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;name:(refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;18)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.第二步：增加一个计数&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;
    &lt;span class=&quot;hljs-variable&quot;&gt;$temp_name = &lt;span class=&quot;hljs-variable&quot;&gt;$name;
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;name:(refcount=&lt;span class=&quot;hljs-number&quot;&gt;2, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;18)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吧，refcount＋1了。&lt;/p&gt;
&lt;p&gt;3.第三步：引用赋值&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;
    &lt;span class=&quot;hljs-variable&quot;&gt;$temp_name = &amp;amp;&lt;span class=&quot;hljs-variable&quot;&gt;$name;
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;name:(refcount=&lt;span class=&quot;hljs-number&quot;&gt;2, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;1),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;18)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的引用赋值会导致zval通过is_ref来标记是否存在引用的情况。&lt;/p&gt;
&lt;p&gt;4.第四步：数组型的变量&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = [&lt;span class=&quot;hljs-string&quot;&gt;'a'=&amp;gt;&lt;span class=&quot;hljs-string&quot;&gt;'咖啡色', &lt;span class=&quot;hljs-string&quot;&gt;'b'=&amp;gt;&lt;span class=&quot;hljs-string&quot;&gt;'的羊驼'];
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;name:
(refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),
array (size=&lt;span class=&quot;hljs-number&quot;&gt;2)
  &lt;span class=&quot;hljs-string&quot;&gt;'a' =&amp;gt; (refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;9)
  &lt;span class=&quot;hljs-string&quot;&gt;'b' =&amp;gt; (refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;9)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还挺好理解的，对于数组来看是一个整体，对于内部kv来看又是分别独立的整体，各自都维护着一套zval的refount和is_ref。&lt;/p&gt;
&lt;p&gt;5.第五步：销毁变量&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;
    &lt;span class=&quot;hljs-variable&quot;&gt;$temp_name = &lt;span class=&quot;hljs-variable&quot;&gt;$name;
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');
    &lt;span class=&quot;hljs-keyword&quot;&gt;unset(&lt;span class=&quot;hljs-variable&quot;&gt;$temp_name);
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'name');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;name:(refcount=&lt;span class=&quot;hljs-number&quot;&gt;2, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;18)
name:(refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),&lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-string&quot;&gt;'咖啡色的羊驼' (&lt;span class=&quot;hljs-built_in&quot;&gt;length=&lt;span class=&quot;hljs-number&quot;&gt;18)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;refcount计数减1，说明unset并非一定会释放内存，当有两个变量指向的时候，并非会释放变量占用的内存，只是refcount减1.&lt;/p&gt;

&lt;p&gt;知道了zval是怎么一回事，接下来看看如何通过php直观看到内存管理的机制是怎么样的。&lt;/p&gt;
&lt;h2 id=&quot;外在的内存变化&quot;&gt;外在的内存变化&lt;/h2&gt;
&lt;p&gt;先来一段代码：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs cs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1593248
&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1593384
&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1593248&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;大致过程：定义变量-&amp;gt;内存增加-&amp;gt;清除变量-&amp;gt;内存恢复&lt;/p&gt;
&lt;h2 id=&quot;潜在的内存变化&quot;&gt;潜在的内存变化&lt;/h2&gt;
&lt;p&gt;当执行：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时候，内存的分配做了两件事情：1.为变量名分配内存，存入符号表 2.为变量值分配内存&lt;/p&gt;
&lt;p&gt;再来看代码：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php

    var_dump(memory_get_usage());
    &lt;span class=&quot;hljs-keyword&quot;&gt;for(&lt;span class=&quot;hljs-variable&quot;&gt;$i=&lt;span class=&quot;hljs-number&quot;&gt;0;&lt;span class=&quot;hljs-variable&quot;&gt;$i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;100;&lt;span class=&quot;hljs-variable&quot;&gt;$i++)
    {
        &lt;span class=&quot;hljs-variable&quot;&gt;$a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;.&lt;span class=&quot;hljs-variable&quot;&gt;$i;
        &lt;span class=&quot;hljs-variable&quot;&gt;$$a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;;    
        }
        var_dump(memory_get_usage());
        &lt;span class=&quot;hljs-keyword&quot;&gt;for(&lt;span class=&quot;hljs-variable&quot;&gt;$i=&lt;span class=&quot;hljs-number&quot;&gt;0;&lt;span class=&quot;hljs-variable&quot;&gt;$i&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;100;&lt;span class=&quot;hljs-variable&quot;&gt;$i++)
        {
            &lt;span class=&quot;hljs-variable&quot;&gt;$a = &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;.&lt;span class=&quot;hljs-variable&quot;&gt;$i;
                &lt;span class=&quot;hljs-keyword&quot;&gt;unset(&lt;span class=&quot;hljs-variable&quot;&gt;$$a);    
    }
    var_dump(memory_get_usage());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;会得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs cs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1596864
&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1612080
&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-number&quot;&gt;1597680&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;简直爆炸，怎么和之前看的不一样？内存没有全部回收回来。&lt;/p&gt;
&lt;p&gt;对于php的核心结构Hashtable来说，由于未知性，定义的时候不可能一次性分配足够多的内存块。所以初始化的时候只会分配一小块，等不够的时候在进行扩容，而Hashtable只扩容不减少，所以就出现了上述的情况:当存入100个变量的时候，符号表不够用了就进行一次扩容，当unset的时候只释放了”为变量值分配内存”，而“为变量名分配内存”是在符号表的，符号表并没有缩小，所以没收回来的内存是被符号表占去了。&lt;/p&gt;
&lt;h2 id=&quot;潜在的内存申请与释放设计&quot;&gt;潜在的内存申请与释放设计&lt;/h2&gt;
&lt;p&gt;php和c语言一样，也是需要进行申请内存的，只不过这些操作作者都封装到底层了，php使用者无感知而已。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;php的内存申请小设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;php并非简单的向os申请内存，而是会申请一大块内存，把其中一部分分给申请者，这样当再有逻辑来申请内存的时候，就不需要向os申请了，避免了频繁调用。当内存不够的时候才会再次申请&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;php的内存释放小设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当释放内存的时候，php并非会把内存还给os，而是把内存轨道自己维护的空闲内存列表，以便重复利用，&lt;/p&gt;

&lt;p&gt;准确地说，判断是否为垃圾，主要看有没有变量名指向变量容器zval，如果没有则认为是垃圾，需要释放。&lt;/p&gt;
&lt;p&gt;打个比方：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;咖啡色的羊驼&quot;;
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;当定义&lt;span id=&quot;MathJax-Element-1-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;m&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;e&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x7684;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x65F6;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5019;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xFF0C;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5904;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x7406;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5B8C;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5B57;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x7B26;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4E32;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x51C6;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5907;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x505A;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5176;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4ED6;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4E8B;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x60C5;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x7684;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x65F6;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5019;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xFF0C;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5BF9;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4E8E;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x6211;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x4EEC;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x6765;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x8BF4;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-2&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-3&quot; class=&quot;mi&quot;&gt;n&lt;span id=&quot;MathJax-Span-4&quot; class=&quot;mi&quot;&gt;a&lt;span id=&quot;MathJax-Span-5&quot; class=&quot;mi&quot;&gt;m&lt;span id=&quot;MathJax-Span-6&quot; class=&quot;mi&quot;&gt;e&lt;span id=&quot;MathJax-Span-7&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-8&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-9&quot; class=&quot;mo&quot;&gt;的&lt;span id=&quot;MathJax-Span-10&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-11&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-12&quot; class=&quot;mo&quot;&gt;时&lt;span id=&quot;MathJax-Span-13&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-14&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-15&quot; class=&quot;mo&quot;&gt;候&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;mo&quot;&gt;，&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-20&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;mo&quot;&gt;处&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-23&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-24&quot; class=&quot;mo&quot;&gt;理&lt;span id=&quot;MathJax-Span-25&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-26&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-27&quot; class=&quot;mo&quot;&gt;完&lt;span id=&quot;MathJax-Span-28&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-29&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-30&quot; class=&quot;mo&quot;&gt;字&lt;span id=&quot;MathJax-Span-31&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-32&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-33&quot; class=&quot;mo&quot;&gt;符&lt;span id=&quot;MathJax-Span-34&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-35&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-36&quot; class=&quot;mo&quot;&gt;串&lt;span id=&quot;MathJax-Span-37&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-38&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-39&quot; class=&quot;mo&quot;&gt;准&lt;span id=&quot;MathJax-Span-40&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-41&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-42&quot; class=&quot;mo&quot;&gt;备&lt;span id=&quot;MathJax-Span-43&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-44&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-45&quot; class=&quot;mo&quot;&gt;做&lt;span id=&quot;MathJax-Span-46&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-47&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-48&quot; class=&quot;mo&quot;&gt;其&lt;span id=&quot;MathJax-Span-49&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-50&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-51&quot; class=&quot;mo&quot;&gt;他&lt;span id=&quot;MathJax-Span-52&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-53&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-54&quot; class=&quot;mo&quot;&gt;事&lt;span id=&quot;MathJax-Span-55&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-56&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-57&quot; class=&quot;mo&quot;&gt;情&lt;span id=&quot;MathJax-Span-58&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-59&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-60&quot; class=&quot;mo&quot;&gt;的&lt;span id=&quot;MathJax-Span-61&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-62&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-63&quot; class=&quot;mo&quot;&gt;时&lt;span id=&quot;MathJax-Span-64&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-65&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-66&quot; class=&quot;mo&quot;&gt;候&lt;span id=&quot;MathJax-Span-67&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-68&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-69&quot; class=&quot;mo&quot;&gt;，&lt;span id=&quot;MathJax-Span-70&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-71&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-72&quot; class=&quot;mo&quot;&gt;对&lt;span id=&quot;MathJax-Span-73&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-74&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-75&quot; class=&quot;mo&quot;&gt;于&lt;span id=&quot;MathJax-Span-76&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-77&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-78&quot; class=&quot;mo&quot;&gt;我&lt;span id=&quot;MathJax-Span-79&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-80&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-81&quot; class=&quot;mo&quot;&gt;们&lt;span id=&quot;MathJax-Span-82&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-83&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-84&quot; class=&quot;mo&quot;&gt;来&lt;span id=&quot;MathJax-Span-85&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-86&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-87&quot; class=&quot;mo&quot;&gt;说&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;name的时候，处理完字符串准备做其他事情的时候，对于我们来说name就是可以回收的垃圾了，然而对于引擎来说，$name还是实打实存在的refcount也还是1，所以就不是垃圾，不能回收。当调用unset的时候，也并不一定引擎会认为它是一个垃圾而进行回收，主要还是看refcount是不是真的变为0了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;产生内存泄漏主要真凶：环形引用。 &lt;br/&gt;现在来造一个环形引用的场景：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$a = [&lt;span class=&quot;hljs-string&quot;&gt;'one'];
    &lt;span class=&quot;hljs-variable&quot;&gt;$a[] = &amp;amp;&lt;span class=&quot;hljs-variable&quot;&gt;$a;
    xdebug_debug_zval(&lt;span class=&quot;hljs-string&quot;&gt;'a');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;得到：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs php has-numbering&quot;&gt;a:
(refcount=&lt;span class=&quot;hljs-number&quot;&gt;2, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;1),
&lt;span class=&quot;hljs-keyword&quot;&gt;array (size=&lt;span class=&quot;hljs-number&quot;&gt;2)
  &lt;span class=&quot;hljs-number&quot;&gt;0 =&amp;gt; (refcount=&lt;span class=&quot;hljs-number&quot;&gt;1, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;0),string &lt;span class=&quot;hljs-string&quot;&gt;'one' (length=&lt;span class=&quot;hljs-number&quot;&gt;3)
  &lt;span class=&quot;hljs-number&quot;&gt;1 =&amp;gt; (refcount=&lt;span class=&quot;hljs-number&quot;&gt;2, is_ref=&lt;span class=&quot;hljs-number&quot;&gt;1),
        &amp;amp;&lt;span class=&quot;hljs-keyword&quot;&gt;array&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;这样 $a数组就有了两个元素，一个索引为0，值为one字符串，另一个索引为1，为$a自身的引用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20170808033118763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTk1Nzc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;图1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时删掉$a:&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    &lt;span class=&quot;hljs-variable&quot;&gt;$a = [&lt;span class=&quot;hljs-string&quot;&gt;'one'];
    &lt;span class=&quot;hljs-variable&quot;&gt;$a[] = &amp;amp;&lt;span class=&quot;hljs-variable&quot;&gt;$a;
    &lt;span class=&quot;hljs-keyword&quot;&gt;unset(&lt;span class=&quot;hljs-variable&quot;&gt;$a);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20170808033143769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTk1Nzc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;图2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果在小于php5.3的版本就会出现一个问题：$a已经不在符号表了，没有变量再指向此zval容器，用户已无法访问，但是由于数组的refcount变为1而不是0，导致此部分内存不能被回收从而产生了内存泄漏。&lt;/p&gt;

&lt;h2 id=&quot;判断处理过程&quot;&gt;判断处理过程&lt;/h2&gt;
&lt;p&gt;为解决环形引用导致的垃圾，产生了新的GC算法，遵守以下几个基本准则：&lt;/p&gt;
&lt;p&gt;1.如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾&lt;/p&gt;
&lt;p&gt;2.如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾&lt;/p&gt;
&lt;p&gt;3.如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾&lt;/p&gt;
&lt;p&gt;are you ok?&lt;/p&gt;
&lt;p&gt;来个白话文版：就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾&lt;/p&gt;
&lt;p&gt;引用php官方手册的配图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20170808033231227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTk1Nzc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;图3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。&lt;/p&gt;
&lt;p&gt;B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。&lt;/p&gt;
&lt;p&gt;C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性）&lt;/p&gt;
&lt;p&gt;D：遍历zval节点，将C中标记成白色的节点zval释放掉。&lt;/p&gt;
&lt;p&gt;are you ok?&lt;/p&gt;
&lt;p&gt;来个白话文版的： &lt;br/&gt;例如：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php
    $&lt;span class=&quot;hljs-operator&quot;&gt;a = [&lt;span class=&quot;hljs-string&quot;&gt;'one']; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为进行unset之前(step1)，进行算法计算，对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样说明zval_a不是一个垃圾不进行回收。&lt;/p&gt;
&lt;p&gt;当执行unset的时候(step2)，进行算法计算，由于环形引用，上文得出会有垃圾的结构体，zval_a的refcount是1(zval_a中的索引1指向zval_a)，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就认为zval_a是一个需要回收的垃圾。&lt;/p&gt;
&lt;p&gt;算法总的套路:对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。&lt;/p&gt;
&lt;h2 id=&quot;算法优化配置&quot;&gt;算法优化配置&lt;/h2&gt;
&lt;p&gt;可能会发现，每次都进行这样的操作好像会影响性能，是的，php做事情套路都是走批量的原则。&lt;/p&gt;
&lt;p&gt;申请内存也是申请一大块，仅使用当前的一小部分剩下的等下回再用，避免多次申请。&lt;/p&gt;
&lt;p&gt;这个gc算法也是这样，会有一个缓冲区的概念，等缓冲区满了才会一次性去给清掉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开关配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;php.ini中设置 zend.enable_gc 项来开启或则关闭GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓冲区配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缓冲区默认可以放10,000个节点，当缓冲区满了才会清理。可以通过修改Zend/zend_gc.c中的GC_ROOT_BUFFER_MAX_ENTRIES 来改变这个数值，需要重新编译链接PHP&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关键函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gc_enable() : 开启GC&lt;/p&gt;
&lt;p&gt;gc_disable() : 关闭GC&lt;/p&gt;
&lt;p&gt;gc_collect_cycles() : 在节点缓冲区未满的情况下强制执行垃圾分析算法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.unset函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;unset只是断开一个变量到一块内存区域的连接，同时将该内存区域的引用计数-1；内存是否回收主要还是看refount是否到0了，以及gc算法判断。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.= null 操作；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&quot;MathJax-Element-2-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;u&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x662F;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x76F4;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x63A5;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x5C06;&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-88&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-89&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-90&quot; class=&quot;mi&quot;&gt;a&lt;span id=&quot;MathJax-Span-91&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-92&quot; class=&quot;mi&quot;&gt;n&lt;span id=&quot;MathJax-Span-93&quot; class=&quot;mi&quot;&gt;u&lt;span id=&quot;MathJax-Span-94&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-95&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-96&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-97&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-98&quot; class=&quot;mo&quot;&gt;是&lt;span id=&quot;MathJax-Span-99&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-100&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-101&quot; class=&quot;mo&quot;&gt;直&lt;span id=&quot;MathJax-Span-102&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-103&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-104&quot; class=&quot;mo&quot;&gt;接&lt;span id=&quot;MathJax-Span-105&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-106&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-107&quot; class=&quot;mo&quot;&gt;将&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;a=null是直接将a 指向的数据结构置空，同时将其引用计数归0。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.脚本执行结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;脚本执行结束，该脚本中使用的所有内存都会被释放，不论是否有引用环。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 02:47:00 +0000</pubDate>
<dc:creator>datang6777</dc:creator>
<og:description>前言 是的，平时经常听到大牛说到的gc，就是垃圾回收器，全称Garbage Collection。 早期版本，准确地说是5.3之前(不包括5.3)的垃圾回收机制，是没有专门的垃圾回收器的。只是简单的判</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/datang6777/p/9536547.html</dc:identifier>
</item>
<item>
<title>由自定义事件到vue数据响应 - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/9536356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/9536356.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基本原理。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览器自定义事件&quot;&gt;浏览器自定义事件&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;除了我们常见的click，touch等事件之外，浏览器支持我们定义和分发自定义事件。&lt;br/&gt;创建也十分简单：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//创建名为test的自定义事件
var event = new Event('test')
//如果是需要更多参数可以这样
var event = new CustomEvent('test', { 'detail': elem.dataset.time });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数现代浏览器对new Event/CustomEvent 的支持还算可以（IE除外），可以看下具体情况：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/16571803c3080b60?w=2554&amp;amp;h=1016&amp;amp;f=png&amp;amp;s=135371&quot;/&gt;&lt;br/&gt;可以放心大胆的使用，如果非要兼容IE那么有下面的方式&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var event = document.createEvent('Event');
//相关参数
event.initEvent('test', true, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义事件的触发和原生事件类似，可以通过冒泡事件触发。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;form&amp;gt;
  &amp;lt;textarea&amp;gt;&amp;lt;/textarea&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;触发如下，这里就偷个懒，直接拿mdn的源码来示例了，毕竟清晰易懂。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const form = document.querySelector('form');
const textarea = document.querySelector('textarea');


//创建新的事件，允许冒泡，支持传递在details中定义的所有数据
const eventAwesome = new CustomEvent('awesome', {
  bubbles: true,
  detail: { text: () =&amp;gt; textarea.value }
});

  //form元素监听自定义的awesome事件，打印text事件的输出
  // 也就是text的输出内容
form.addEventListener('awesome', e =&amp;gt; console.log(e.detail.text()));
  //  
  // textarea当输入时，触发awesome
textarea.addEventListener('input', e =&amp;gt; e.target.dispatchEvent(eventAwesome));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子很清晰的展示了自定义事件定义、监听、触发的整个过程，和原生事件的流程相比看起来多了个触发的步骤，原因在原生事件的触发已经被封装无需手动处理而已。&lt;/p&gt;
&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;h3 id=&quot;各大js类库&quot;&gt;各大js类库&lt;/h3&gt;
&lt;p&gt;各种js库中用到的也比较多，例如zepto中的tap，原理就是监听touch事件，然后去触发自定的tap事件(当然这种成熟的框架做的是比较严谨的)。可以看下部分代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//这里做了个event的map，来将原始事件对应为自定义事件以便处理
// 可以只关注下ontouchstart，这里先判断是否移动端，移动端down就对应touchstart，up对应touchend，后面的可以先不关注
eventMap = (__eventMap &amp;amp;&amp;amp; ('down' in __eventMap)) ? __eventMap :
      ('ontouchstart' in document ?
      { 'down': 'touchstart', 'up': 'touchend',
        'move': 'touchmove', 'cancel': 'touchcancel' } :
      'onpointerdown' in document ?
      { 'down': 'pointerdown', 'up': 'pointerup',
        'move': 'pointermove', 'cancel': 'pointercancel' } :
       'onmspointerdown' in document ?
      { 'down': 'MSPointerDown', 'up': 'MSPointerUp',
        'move': 'MSPointerMove', 'cancel': 'MSPointerCancel' } : false)
 //监听事件
     $(document).on(eventMap.up, up)
      .on(eventMap.down, down)
      .on(eventMap.move, move)       
 //up事件即touchend时，满足条件的会触发tap    
 var up = function (e) {
      /* 忽略 */
       tapTimeout = setTimeout(function () {
           var event = $.Event('tap')
            event.cancelTouch = cancelAll
            if (touch.el) touch.el.trigger(event); 
          },0）
        }
     //其他   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布订阅&quot;&gt;发布订阅&lt;/h3&gt;
&lt;p&gt;和原生事件一样，大部分都用于观察者模式中。除了上面的库之外，自己开发过程中用到的地方也不少。&lt;br/&gt;举个例子，一个输入框表示单价，另一个div表示五本的总价，单价改变总价也会变动。借助自定义事件应该怎么实现呢。&lt;br/&gt;html结构比较简单&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;div &amp;gt;一本书的价格：&amp;lt;input type='text' id='el' value=10 /&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div &amp;gt;5本书的价格：&amp;lt;span id='el2'&amp;gt;50&amp;lt;/span&amp;gt;元&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当改变input值得时候，效果如下&lt;a href=&quot;http://xxdy.tech/event/index.html&quot;&gt;demo地址&lt;/a&gt; ：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/165718064234986c?w=600&amp;amp;h=185&amp;amp;f=gif&amp;amp;s=7690486&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概思路捋一下：&lt;br/&gt;1、自定义事件，priceChange，用来监听改变price的改变&lt;br/&gt;2、 加个监听事件，priceChange触发时改变total的值。&lt;br/&gt;3、input value改变的时候，触发priceChange事件&lt;br/&gt;代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  const count = document.querySelector('#el'),
      total1 = document.querySelector('#el2');
  const eventAwesome = new CustomEvent('priceChange', {
      bubbles: true,
      detail: { getprice: () =&amp;gt; count.value }
    });
  document.addEventListener('priceChange', function (e) {
      var price = e.detail.getprice() || 0
      total1.innerHTML=5 * price
    })
  el.addEventListener('change', function (e) {
    var val = e.target.value
    e.target.dispatchEvent(eventAwesome)
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码确实比较简单，当然实现的方式是多样的。但是看起来是不是有点vue数据响应的味道。&lt;br/&gt;确实目前大多数框架中都会用到发布订阅的方式来处理数据的变化。例如vue，react等，以vue为例子，我们可以来看看其数据响应的基本原理。&lt;/p&gt;
&lt;h2 id=&quot;自定义事件&quot;&gt;自定义事件&lt;/h2&gt;
&lt;p&gt;这里的自定义事件就是前面提到的第二层定义了，非基于浏览器的事件。这种事件也正是大型前端项目中常用到。对照原生事件，应该具有on、trigger、off三个方法。分别看一下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对照原生事件很容易理解，绑定一个事件，应该有对应方法名和回调,当然还有一个事件队列&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Event1{
    constructor(){
      // 事件队列
      this._events = {}
    }
    // type对应事件名称，call回调
    on(type,call){
      let funs = this._events[type]
      // 首次直接赋值，同种类型事件可能多个回调所以数组
      // 否则push进入队列即可
      if(funs){
        funs.push(call)
      }else{
        this._events.type=[]
        this._events.type.push(call)
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;触发事件trigger&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 触发事件
    trigger(type){
      let funs = this._events.type,
        [first,...other] = Array.from(arguments)
      //对应事件类型存在，循环执行回调队列  
      if(funs){
        let i = 0,
            j = funs.length;
        for (i=0; i &amp;lt; j; i++) {
          let cb = funs[i];
          cb.apply(this, other);
        }
      }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;解除绑定：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 取消绑定，还是循环查找
    off(type,func){
      let funs = this._events.type
      if(funs){
        let i = 0,
          j = funs.length;
        for (i = 0; i &amp;lt; j; i++) {
          let cb = funs[i];
           if (cb === func) {
            funs.splice(i, 1);
            return;
          }
        }
      }
      return this
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个简单的事件系统就完成了，结合这个事件系统，我们可以实现下上面那个例子。&lt;br/&gt;html不变，绑定和触发事件的方式改变一下就好&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; // 初始化 event1为了区别原生Event
  const event1 = new Event1()    
  
  // 此处监听 priceChange 即可
  event1.on('priceChange', function (e) {
      // 值获取方式修改
      var price = count.value || 0
      total1.innerHTML = 5 * price
    })  
  el.addEventListener('change', function (e) {
    var val = e.target.value
    // 触发事件
    event1.trigger('priceChange')
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样同样可以实现上面的效果，实现了事件系统之后，我们接着实现一下vue里面的数据响应。&lt;/p&gt;
&lt;h3 id=&quot;vue的数据响应&quot;&gt;vue的数据响应&lt;/h3&gt;
&lt;p&gt;说到vue的数据响应，网上相关文章简直太多了，这里就不深入去讨论了。简单搬运一下基本概念。详细的话大家可以自行搜索。&lt;/p&gt;
&lt;h3 id=&quot;基本原理&quot;&gt;基本原理&lt;/h3&gt;
&lt;p&gt;直接看图比较直观：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/25/165718027cb03c89?w=800&amp;amp;h=500&amp;amp;f=png&amp;amp;s=64811&quot;/&gt;&lt;br/&gt;就是通过观察者模式来实现，不过其通过数据劫持方式实现的更加巧妙。&lt;br/&gt;数据劫持是通过Object.defineProperty()来监听各个属性的变化，从而进行一些额外操作。&lt;br/&gt;举个简单例子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let a = {
   b:'1' 
}
Object.defineProperty(a,'b',{
        get(){
            console.log('get&amp;gt;&amp;gt;&amp;gt;',1)
            return 1
        },
        set(newVal){
            console.log('set&amp;gt;&amp;gt;&amp;gt;11','设置是不被允许的')
            return 1
        }
    })
a.b //'get&amp;gt;&amp;gt;&amp;gt;1'
a.b = 11    //set&amp;gt;&amp;gt;&amp;gt;11 设置是不被允许的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所谓数据劫持就是在get/set操作时加上额外操作，这里是加了些log，如果在这里去监听某些属性的变化，进而更改其他属性也是可行的。&lt;br/&gt;要达到目的，应该对每个属性在get是监听，set的时候出发事件，且每个属性上只注册一次。&lt;br/&gt;另外应该每个属性对应一个监听者，这样处理起来比较方便，如果和上面那样全放在一个监听实例里面，有多个属性及复杂操作时，就太难维护了。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//基本数据
let data = {
    price: 5,
    count: 2
  },
callb = null  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以对自定义事件进行部分改造,&lt;br/&gt;不需要显式指定type，全局维护一个标记即可&lt;br/&gt;事件数组一维即可，因为是每个属性对应一个示例&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Events {
    constructor() {
      this._events = []
    }
    on() {
      //此处不需要指定tyep了
      if (callb &amp;amp;&amp;amp; !this._events.includes(callb)) {
        this._events.push(callb)
      }
    }
    triger() {
      this._events.forEach((callb) =&amp;gt; {
        callb &amp;amp;&amp;amp; callb()
      })
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应上图中vue的Data部分，就是实行数据劫持的地方&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Object.keys(data).forEach((key) =&amp;gt; {
    let initVlue = data[key]
    const e1 = new Events()
    Object.defineProperty(data, key, {
      get() {
         //内部判断是否需要注册
        e1.on()
        // 执行过置否
        callb = null
        // get不变更值
        return initVlue
      },
      set(newVal) {
        initVlue = newVal
        // set操作触发事件，同步数据变动
        e1.triger()
      }
    })
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时数据劫持即事件监听准备完成，大家可能会发现callback始终为null，这始终不能起作用。为了解决该问题，下面的watcher就要出场了。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function watcher(func) {
    // 参数赋予callback，执行时触发get方法，进行监听事件注册
    callb = func
    // 初次执行时，获取对应值自然经过get方法注册事件
    callb()
    // 置否避免重复注册
    callb = null
  }
  // 此处指定事件触发回调，注册监听事件
  watcher(() =&amp;gt; {
    data.total = data.price * data.count
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就保证了会将监听事件挂载上去。到这里，乞丐版数据响应应该就能跑了。&lt;br/&gt;再加上dom事件的处理，双向绑定也不难实现。&lt;br/&gt;可以将下面的完整代码放到console台跑跑看。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let data = {
    price: 5,
    count: 2
  },
    callb = null

  class Events {
    constructor() {
      this._events = []
    }
    on() {
      if (callb &amp;amp;&amp;amp; !this._events.includes(callb)) {
        this._events.push(callb)
      }
    }
    triger() {
      this._events.forEach((callb) =&amp;gt; {
        callb &amp;amp;&amp;amp; callb()
      })
    }
  }
 
  Object.keys(data).forEach((key) =&amp;gt; {
    let initVlue = data[key]
    const e1 = new Events()
    Object.defineProperty(data, key, {
      get() {
         //内部判断是否需要注册
        e1.on()
        // 执行过置否
        callb = null
        // get不变更值
        return initVlue
      },
      set(newVal) {
        initVlue = newVal
        // set操作触发事件，同步数据变动
        e1.triger()
      }
    })
  })
  function watcher(func) {
    // 参数赋予callback，执行时触发get方法，进行监听事件注册
    callb = func
    // 初次执行时，获取对应值自然经过get方法注册事件
    callb()
    // 置否避免重复注册
    callb = null
  }
  // 此处指定事件触发回调，注册监听事件
  watcher(() =&amp;gt; {
    data.total = data.price * data.count
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d&quot;&gt;vue数据响应的实现&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events&quot;&gt;Creating and triggering events&lt;/a&gt;&lt;br/&gt;看到知识盲点，就需要立即行动，不然下次还是盲点。正好是事件相关，就一并总结了下发布订阅相关进而到了数据响应的实现。个人的一点心得记录，分享出来希望共同学习和进步。&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/blog&quot;&gt;更多请移步我的博客&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://xxdy.tech/event/index.htmll&quot;&gt;demo地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/blog/blob/master/source/event/index.html&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 01:25:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<og:description>前言 除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/9536356.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——视图与页面 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9533725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9533725.html</guid>
<description>&lt;p&gt;当一个Action完成它的任务后，通常需要返回一个实现IActionResult的对象，而最常见的就是View或者ViewResult，所谓的视图对象。那么视图与最终所看到的页面之间的联系又是怎样形成的，这便是本文想要探讨的问题。&lt;/p&gt;
&lt;p&gt;在ResourceInvoker类之中，可以找到下列的代码。这些代码是对返回结果——IActionResult的进一步处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;case State.ResultInside:
    {
        ...

        var task = InvokeResultAsync(_result);
        if (task.Status != TaskStatus.RanToCompletion)
        {
            next = State.ResultEnd;
            return task;
        }

        goto case State.ResultEnd;
    }

protected async Task InvokeResultAsync(IActionResult result)
{
    var actionContext = _actionContext;

    _diagnosticSource.BeforeActionResult(actionContext, result);
    _logger.BeforeExecutingActionResult(result);

    try
    {
        await result.ExecuteResultAsync(actionContext);
    }
    finally
    {
        _diagnosticSource.AfterActionResult(actionContext, result);
        _logger.AfterExecutingActionResult(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IActionResult接口的实现类ViewResult中会调用ViewResultExecutor类的方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override async Task ExecuteResultAsync(ActionContext context)
{
    ...

    var executor = context.HttpContext.RequestServices.GetRequiredService&amp;lt;IActionResultExecutor&amp;lt;ViewResult&amp;gt;&amp;gt;();
    await executor.ExecuteAsync(context, this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ViewResultExecutor类里则需要先通过RazorViewEngine类找到对应的视图。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task ExecuteAsync(ActionContext context, ViewResult result)
{
    ...

    var viewEngineResult = FindView(context, result);
    viewEngineResult.EnsureSuccessful(originalLocations: null);

    var view = viewEngineResult.View;
    using (view as IDisposable)
    {

        await ExecuteAsync(
            context,
            view,
            result.ViewData,
            result.TempData,
            result.ContentType,
            result.StatusCode);
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RazorViewEngine类返回的结果是RazorView对象。注意其内部已包含了IRazorPage对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ViewEngineResult GetView(string executingFilePath, string viewPath, bool isMainPage)
{
    ...

    var cacheResult = LocatePageFromPath(executingFilePath, viewPath, isMainPage);
    return CreateViewEngineResult(cacheResult, viewPath);
}

public ViewEngineResult FindView(ActionContext context, string viewName, bool isMainPage)
{
    ...

    var cacheResult = LocatePageFromViewLocations(context, viewName, isMainPage);
    return CreateViewEngineResult(cacheResult, viewName);
}

private ViewEngineResult CreateViewEngineResult(ViewLocationCacheResult result, string viewName)
{
    ...

    var page = result.ViewEntry.PageFactory();

    var viewStarts = new IRazorPage[result.ViewStartEntries.Count];
    for (var i = 0; i &amp;lt; viewStarts.Length; i++)
    {
        var viewStartItem = result.ViewStartEntries[i];
        viewStarts[i] = viewStartItem.PageFactory();
    }

    var view = new RazorView(this, _pageActivator, viewStarts, page, _htmlEncoder, _diagnosticSource);
    return ViewEngineResult.Found(viewName, view);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到视图后，ViewResultExecutor再调用其父类ViewExecutor的ExecuteAsync方法。其内部将调用RazorView类的RenderAsync方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected async Task ExecuteAsync(
    ViewContext viewContext,
    string contentType,
    int? statusCode)
{
    ...

    var response = viewContext.HttpContext.Response;

    ResponseContentTypeHelper.ResolveContentTypeAndEncoding(
        contentType,
        response.ContentType,
        DefaultContentType,
        out var resolvedContentType,
        out var resolvedContentTypeEncoding);

    response.ContentType = resolvedContentType;

    if (statusCode != null)
    {
        response.StatusCode = statusCode.Value;
    }

    using (var writer = WriterFactory.CreateWriter(response.Body, resolvedContentTypeEncoding))
    {
        var view = viewContext.View;

        var oldWriter = viewContext.Writer;
        try
        {
            viewContext.Writer = writer;

            DiagnosticSource.BeforeView(view, viewContext);

            await view.RenderAsync(viewContext);

            DiagnosticSource.AfterView(view, viewContext);
        }
        finally
        {
            viewContext.Writer = oldWriter;
        }

        // Perf: Invoke FlushAsync to ensure any buffered content is asynchronously written to the underlying
        // response asynchronously. In the absence of this line, the buffer gets synchronously written to the
        // response as part of the Dispose which has a perf impact.
        await writer.FlushAsync();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RazorView类中可以看到其核心的处理与IRazorPage的ExecuteAsync方法紧密相关。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task RenderAsync(ViewContext context)
{
    ...

    _bufferScope = context.HttpContext.RequestServices.GetRequiredService&amp;lt;IViewBufferScope&amp;gt;();
    var bodyWriter = await RenderPageAsync(RazorPage, context, invokeViewStarts: true);
    await RenderLayoutAsync(context, bodyWriter);
}

private async Task&amp;lt;ViewBufferTextWriter&amp;gt; RenderPageAsync(
    IRazorPage page,
    ViewContext context,
    bool invokeViewStarts)
{
    var writer = context.Writer as ViewBufferTextWriter;
    ...

    // The writer for the body is passed through the ViewContext, allowing things like HtmlHelpers
    // and ViewComponents to reference it.
    var oldWriter = context.Writer;
    var oldFilePath = context.ExecutingFilePath;

    context.Writer = writer;
    context.ExecutingFilePath = page.Path;

    try
    {
        if (invokeViewStarts)
        {
            // Execute view starts using the same context + writer as the page to render.
            await RenderViewStartsAsync(context);
        }

        await RenderPageCoreAsync(page, context);
        return writer;
    }
    finally
    {
        context.Writer = oldWriter;
        context.ExecutingFilePath = oldFilePath;
    }
}

private async Task RenderPageCoreAsync(IRazorPage page, ViewContext context)
{
    page.ViewContext = context;
    _pageActivator.Activate(page, context);

    _diagnosticSource.BeforeViewPage(page, context);

    try
    {
        await page.ExecuteAsync();
    }
    finally
    {
        _diagnosticSource.AfterViewPage(page, context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但当查找IRazorPage接口的实现。从&lt;code&gt;RazorPageBase&lt;/code&gt;到&lt;code&gt;RazorPage&lt;/code&gt;，再到&lt;code&gt;RazorPage&amp;lt;TModel&amp;gt;&lt;/code&gt;，这些都只是抽象类，且都没有对ExecuteAsync方法有具体实现。&lt;/p&gt;
&lt;p&gt;源码里找不到进一步的实现类，线索到这里断开了。&lt;/p&gt;
&lt;p&gt;这时可以建立一个MVC的应用程序，编译后找到它的bin目录，会看到其中包含一个*.View.dll文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180825164431371-77765344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用反编译软件，比如dotPeek，查看里面的内容，会找到一些由cshtml文件生成的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180825164632529-756857788.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以其中Views_Home_Index为例，其实际上为&lt;code&gt;RazorPage&amp;lt;TModel&amp;gt;&lt;/code&gt;的一个实现类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180825164830689-1589273945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它内部的ExecuteAsync方法正是生成页面内容的关键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180825165030381-1771018868.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是VS模板自动生成的页面，上面的代码十分冗杂。为了更清晰地检查核心的代码，不妨减少下页面的复杂度。&lt;/p&gt;
&lt;p&gt;把index.cshtml文件内容改成如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;
    Layout = null;
}

&amp;lt;p&amp;gt;Hello World!&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次编译后，可以看到ExecuteAsync方法的内容变成了下面的样子：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task ExecuteAsync()
{
  ((ViewDataDictionary) this.get_ViewData()).set_Item(&quot;Title&quot;, (object) &quot;Home Page&quot;);
  ((RazorPageBase) this).set_Layout((string) null);
  ((RazorPageBase) this).BeginContext(65, 21, true);
  ((RazorPageBase) this).WriteLiteral(&quot;\r\n&amp;lt;p&amp;gt;Hello World!&amp;lt;/p&amp;gt;&quot;);
  ((RazorPageBase) this).EndContext();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难看出，最终展现的页面内容便是通过RazorPageBase类的WriteLiteral方法生成的。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 00:01:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>当一个Action完成它的任务后，通常需要返回一个实现IActionResult的对象，而最常见的就是View或者ViewResult，所谓的视图对象。那么视图与最终所看到的页面之间的联系又是怎样形成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9533725.html</dc:identifier>
</item>
</channel>
</rss>