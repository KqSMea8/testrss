<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python学习手册之内部方法、操作符重载和对象生命周期 - 清洁工老板</title>
<link>http://www.cnblogs.com/dustman/p/10017357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dustman/p/10017357.html</guid>
<description>&lt;p&gt; 在上一篇文章中，我们介绍了 Python 的类和继承，现在我们介绍 Python 的内部方法、操作符重载和对象生命周期。&lt;/p&gt;
&lt;p&gt; 查看上一篇文章请点击：https://www.cnblogs.com/dustman/p/10016359.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;内部方法和操作符重载&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;内部的方法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Python&lt;/strong&gt; 里有一些特殊的方法，也就是以双下划线开头并且以双下划线结尾的。它们可以是变量如 &lt;strong&gt;__doc__&lt;/strong&gt;，也可以是方法如 &lt;strong&gt;__init__&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;它们常见用途是操作符重载。这意味着可以自定义类的操作符，允许在这些类上使用加减乘除等运算符&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面代码实现了&lt;strong&gt;__call__&lt;/strong&gt;方法的对象，相当于重载了 ()，可以实现调用功能。 实现&lt;strong&gt;非波纳契数列&lt;/strong&gt;的类&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fib():
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
  ret &lt;/span&gt;= [1,1&lt;span&gt;]
  num &lt;/span&gt;=&lt;span&gt; int(args[0])
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num == 1&lt;span&gt;:
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [1&lt;span&gt;,]
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
   &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; len(ret)&amp;lt;&lt;span&gt; num:
    ret.append(ret[&lt;/span&gt;-1]+ret[-2&lt;span&gt;])
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret

fib &lt;/span&gt;=&lt;span&gt; Fib()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fib(7))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;
[&lt;/span&gt;1, 1, 2, 3, 5, 8, 13&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;&lt;span&gt;斐波那契数列，是数学上一个无穷数列。其形式为
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;，&lt;span&gt;1&lt;/span&gt;，&lt;span&gt;2&lt;/span&gt;，&lt;span&gt;3&lt;/span&gt;，&lt;span&gt;5&lt;/span&gt;，&lt;span&gt;8&lt;/span&gt;，&lt;span&gt;13&lt;/span&gt;&lt;span&gt;……
从第三项开始，每一项都是前两项之和。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类运算重载的方法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__sub__&lt;/strong&gt; 表示运算符 &lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__mul__&lt;/strong&gt; 表示运算符 &lt;strong&gt;*&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__truediv__&lt;/strong&gt; 表示运算符 &lt;strong&gt;/&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__floordiv__&lt;/strong&gt; 表示运算符 &lt;strong&gt;//&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__mod__&lt;/strong&gt; 表示运算符 &lt;strong&gt;%&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__pow__&lt;/strong&gt; 表示运算符 &lt;strong&gt;**&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__and__&lt;/strong&gt; 表示运算符 &lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__xor__&lt;/strong&gt; 表示运算符 &lt;strong&gt;^&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__or__&lt;/strong&gt; 表示运算符 &lt;strong&gt;|&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;表达式 &lt;strong&gt;x + y&lt;/strong&gt; 会被 Python 转换成 &lt;strong&gt;x.__add__(y)&lt;/strong&gt;。但是，如果 &lt;strong&gt;x&lt;/strong&gt; 没有实现 &lt;strong&gt;__add__&lt;/strong&gt; 方法并且 &lt;strong&gt;x&lt;/strong&gt; 和 &lt;strong&gt;y&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;是不同的类型，那么会调用 &lt;strong&gt;y.__radd__(x)&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于上面提到的所有方法，都有相等的添加 r 前缀的方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,text):
  self.text &lt;/span&gt;=&lt;span&gt; text

 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__mul__&lt;/span&gt;&lt;span&gt;(self, other):
  line &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; *&lt;span&gt; len(other.text)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join([self.text,line,other.text])

msg &lt;/span&gt;= Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
hello &lt;/span&gt;= Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I like Python!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(msg * hello)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;
Hello
&lt;/span&gt;==============&lt;span&gt;
I like Python!
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;上面例子中，我们定义了类 Foo 的一个乘法方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Python 同样提供了数据比较方面的方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__it__&lt;/strong&gt; 表示运算符 &lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__le__&lt;/strong&gt; 表示运算符 &lt;strong&gt;&amp;lt;=&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__eq__&lt;/strong&gt; 表示运算符 &lt;strong&gt;==&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__ne__&lt;/strong&gt; 表示运算符 &lt;strong&gt;!=&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__gt__&lt;/strong&gt; 表示运算符 &lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__ge__&lt;/strong&gt; 表示运算符 &lt;strong&gt;&amp;gt;=&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果类没有实现 &lt;strong&gt;__ne__&lt;/strong&gt; ，则返回 &lt;strong&gt;__eq__&lt;/strong&gt; 相反的值。其他运算符之间没有这样的关系。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; FooString():
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
  self.name &lt;/span&gt;=&lt;span&gt; name

 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;&lt;span&gt;(self, obj):
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name ==&lt;span&gt; obj.name

a &lt;/span&gt;= FooString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
b &lt;/span&gt;= FooString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a &amp;lt; b)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;
False
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类中还有一些方法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__len__&lt;/strong&gt; 可用来做 &lt;strong&gt;len()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__getitem__&lt;/strong&gt; 可用来做键值读取，适用于 &lt;strong&gt;[]&lt;/strong&gt; 运算符。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__setitem__&lt;/strong&gt; 设置给定值的值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__delitem__&lt;/strong&gt; 删除给定键对应的元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__iter__&lt;/strong&gt; 用来遍历对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;__contains__&lt;/strong&gt; 用来做 &lt;strong&gt;in&lt;/strong&gt; 操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有许多其他的神奇方法，我们在这里就不一一谈论了，例如&lt;strong&gt;__call__&lt;/strong&gt; 用于将对象作为函数调用，&lt;/span&gt; &lt;span&gt;&lt;strong&gt;__init__&lt;/strong&gt; ，&lt;strong&gt;__str__&lt;/strong&gt; 等等用于将对象转换为 Python 基础数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把一个类做成一个字典&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo():
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
  self.data &lt;/span&gt;=&lt;span&gt; {}
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, key):
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data.get(key)

 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__setitem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,key, value)
  self.data[key] &lt;/span&gt;=&lt;span&gt; value

 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;(self, key): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;触发del&lt;/span&gt;
  &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__delitme__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, key)

obj &lt;/span&gt;= Foo() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化Foo&lt;/span&gt;
obj[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行__setitem__&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(obj[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行__getitem__&lt;/span&gt;

&lt;span&gt;del&lt;/span&gt; obj[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:false;&quot;&gt;
&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;
__setitem name Python
__getitem__ name
Python
__delitme__ name
&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;键值读取函数&lt;/span&gt; &lt;strong&gt;&lt;span&gt;__getitem__&lt;/span&gt; &lt;/strong&gt;&lt;span&gt;还可以根据表达式返回字典中的&lt;/span&gt; &lt;strong&gt;key&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;__setitem__&lt;/span&gt; &lt;/strong&gt;&lt;span&gt;设置&lt;/span&gt; &lt;strong&gt;key&lt;/strong&gt; &lt;span&gt;对应的&lt;/span&gt; &lt;strong&gt;value&lt;/strong&gt; &lt;span&gt;值。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象会经历三个生命周期：创建，操作，销毁。&lt;/span&gt;&lt;br/&gt;对象生命周期的第一阶段是它类变量和方法的定义。&lt;br/&gt;接下来下一阶段是这个实例的实例化。当 &lt;strong&gt;__init__&lt;/strong&gt; 被调用是，内存分配给存储实例。在此之前，调用类的 &lt;strong&gt;__new__&lt;/strong&gt; 方法，这通常仅在特殊情况下会被重写。在此以后，该对象就可以使用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;现在，其他代码可以通过调用对象上的函数或访问其属性与对象进行交互。最后它使用完毕并可被销毁。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当一个对象被销毁时，分配给它的内存会被释放，并可以用于其他目的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当对象的引用计数达到零时，对象将销毁。引用计数是指引用对象的变量和其他元素的数量。如果没有任何变量引用它（它的引用计数为零），意味着没有任何东西可以与其交互，因此可以安全地删除它。在此也可以被删除。&lt;strong&gt;del&lt;/strong&gt; 语句将对象的引用计数减少一个，这通常会导致对象被删除。&lt;strong&gt;del&lt;/strong&gt; 语句调用对象的方法 &lt;strong&gt;__del__&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在不再需要对象是删除对象的过程称为垃圾收集。对象的引用计数在分配新名称或放在容器 (列表、元组或字典) 中时会增加。当使用 del 删除对象时，对象的引用计数会减少。当对象的引用计数达到零时，Python 会自动删除它。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;a=1       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对象 1 被 变量a引用，对象1的引用计数器为1&lt;/span&gt;
b=a       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对象1 被变量b引用，对象1的引用计数器加1&lt;/span&gt;
c=a       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对象1 被变量c引用，对象1的引用计数器加1&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; a     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除变量a，解除a对1的引用&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; b     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除变量b，解除b对1的引用&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; c     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除变量C，解除C对1的引用&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;上面的例子，创建了一个含 1 的对象，对象的计数器加了 3 次，然后对象的计数器减了三次。这时该对象会被自动内存管理销毁。&lt;br/&gt;像 C 这样的低级语言没有这种自动内存管理系统。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;“数学就是用来把七成人筛出去的。”&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:44:00 +0000</pubDate>
<dc:creator>清洁工老板</dc:creator>
<og:description>在上一篇文章中，我们介绍了 Python 的类和继承，现在我们介绍 Python 的内部方法、操作符重载和对象生命周期。 查看上一篇文章请点击：https://www.cnblogs.com</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dustman/p/10017357.html</dc:identifier>
</item>
<item>
<title>iOS开发者学习Flutter - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/10020664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/10020664.html</guid>
<description>&lt;p&gt;本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。&lt;/p&gt;
&lt;p&gt;开发 Flutter 时，你的 iOS 经验和技能将会大有裨益，因为 Flutter 依赖于移动操作系统的众多功能和配置。Flutter 是用于为移动设备构建用户界面的全新方式，但它也有一个插件系统用于和 iOS（及 Android）进行非 UI 任务的通信。如果你是 iOS 开发专家，则你不必将 Flutter 彻底重新学习一遍。&lt;/p&gt;
&lt;p&gt;你可以将此文档作为 cookbook，通过跳转并查找与你的需求最相关的问题。&lt;/p&gt;
&lt;h2 id=&quot;views&quot;&gt;Views&lt;/h2&gt;
&lt;h3 id=&quot;uiview-相当于-flutter-中的什么&quot;&gt;UIView 相当于 Flutter 中的什么？&lt;/h3&gt;
&lt;p&gt;在 iOS 中，构建 UI 的过程中将大量使用 view 对象。这些对象都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; 的实例。它们可以用作容器来承载其他的 UIView，最终构成你的界面布局。&lt;/p&gt;
&lt;p&gt;在 Flutter 中，你可以粗略地认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Widget&lt;/code&gt; 相当于 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; 。Widget 和 iOS 中的控件并不完全等价，但当你试图去理解 Flutter 是如何工作的时候，你可以认为它们是“声明和构建 UI 的方法”。&lt;/p&gt;
&lt;p&gt;然而，Widget 和 UIView 还是有些区别的。首先，widgets 拥有不同的生存时间：它们一直存在且保持不变，直到当它们需要被改变。当 widgets 和它们的状态被改变时，Flutter 会构建一颗新的 widgets 树。作为对比，iOS 中的 views 在改变时并不会被重新创建。但是与其说 views 是可变的实例，不如说它们被绘制了一次，并且直到使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;setNeedsDisplay()&lt;/code&gt; 之后才会被重新绘制。&lt;/p&gt;
&lt;p&gt;此外，不像 UIView，由于不可变性，Flutter 的 widgets 非常轻量。这是因为它们本身并不是什么控件，也不会被直接绘制出什么，而只是 UI 的描述。&lt;/p&gt;
&lt;p&gt;Flutter 包含了 &lt;a href=&quot;https://material.io/develop/flutter/&quot;&gt;Material 组件&lt;/a&gt;库。这些 widgets 遵循了 &lt;a href=&quot;https://material.io/design/&quot;&gt;Material 设计规范&lt;/a&gt;。MD 是一个灵活的设计系统，并且为包括 iOS 在内的&lt;a href=&quot;https://material.io/design/platform-guidance/cross-platform-adaptation.html#cross-platform-guidelines&quot;&gt;所有系统进行了优化&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是用 Flutter 实现任何的设计语言都非常的灵活和富有表现力。在 iOS 平台，你可以使用 &lt;a href=&quot;https://flutter.io/widgets/cupertino/&quot;&gt;Cupertino widgets&lt;/a&gt; 来构建遵循了 &lt;a href=&quot;https://developer.apple.com/design/resources/&quot;&gt;Apple’s iOS design language&lt;/a&gt; 的界面。&lt;/p&gt;
&lt;h3 id=&quot;我怎么来更新-widgets&quot;&gt;我怎么来更新 Widgets？&lt;/h3&gt;
&lt;p&gt;在 iOS 上更新 views，只需要直接改变它们就可以了。在 Flutter 中，widgets 是不可变的，而且不能被直接更新。你需要去操纵 widget 的 state。&lt;/p&gt;
&lt;p&gt;这也正是有状态的和无状态的 widget 这一概念的来源。一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatelessWidget&lt;/code&gt; 正如它听起来一样，是一个没有附加状态的 widget。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StatelessWidget&lt;/code&gt; 在你构建初始化后不再进行改变的界面时非常有用。&lt;/p&gt;
&lt;p&gt;举个例子，你可能会用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView&lt;/code&gt; 来展示你的 logo &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt; 。如果这个 logo 在运行时不会改变，那么你就可以在 Flutter 中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatelessWidget&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果你希望在发起 HTTP 请求时，依托接收到的数据动态的改变 UI，请使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatefulWidget&lt;/code&gt;。当 HTTP 请求结束后，通知 Flutter 框架 widget 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt; 更新了，好让系统来更新 UI。&lt;/p&gt;
&lt;p&gt;有状态和无状态的 widget 之间一个非常重要的区别是，&lt;code class=&quot;highlighter-rouge&quot;&gt;StatefulWidget&lt;/code&gt; 拥有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt; 对象来存储它的状态数据，并在 widget 树重建时携带着它，因此状态不会丢失。&lt;/p&gt;
&lt;p&gt;如果你有疑惑，请记住以下规则：如果一个 widget 在它的 &lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt; 方法之外改变（例如，在运行时由于用户的操作而改变），它就是有状态的。如果一个 widget 在一次 build 之后永远不变，那它就是无状态的。但是，即便一个 widget 是有状态的，包含它的父亲 widget 也可以是无状态的，只要父 widget 本身不响应这些变化。&lt;/p&gt;
&lt;p&gt;下面的例子展示了如何使用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatelessWidget&lt;/code&gt; 。一个常见的 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatelessWidget&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt;widget。如果你查看 Text 的实现，你会发现它是 StatelessWidget 的子类。&lt;/p&gt;
&lt;div class=&quot;language-dart highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;highlight language-dart&quot;&gt;
&lt;code class=&quot; language-dart&quot;&gt;&lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;n&quot;&gt;Text&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;(
  &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;s&quot;&gt;'I like Flutter!'&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;,
  &lt;span class=&quot;nl&quot;&gt;style&lt;span class=&quot;token punctuation&quot;&gt;:&lt;span class=&quot;token punctuation&quot;&gt; &lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;n&quot;&gt;TextStyle&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nl&quot;&gt;fontWeight&lt;span class=&quot;token punctuation&quot;&gt;:&lt;span class=&quot;token punctuation&quot;&gt; &lt;span class=&quot;n&quot;&gt;FontWeight&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;bold&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;,&lt;span class=&quot;token punctuation&quot;&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;阅读上面的代码，你可能会注意到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt; widget 并不显示地携带任何状态。它通过传入给它的构造器的数据来渲染，除此之外再无其他。&lt;/p&gt;
&lt;p&gt;但是，如果你希望 &lt;code class=&quot;highlighter-rouge&quot;&gt;I like Flutter&lt;/code&gt; 在点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;FloatingActionButton&lt;/code&gt; 时动态的改变呢？&lt;/p&gt;
&lt;p&gt;为了实现这个，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;StatefulWidget&lt;/code&gt; 包裹 &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt; widget，并在用户点击按钮时更新它。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;language-dart highlighter-rouge&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight language-dart&quot;&gt;
&lt;code class=&quot; language-dart&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;nc&quot;&gt;SampleApp &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;kd&quot;&gt;extends &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;n&quot;&gt;StatelessWidget &lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;o&quot;&gt;{
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</description>
<pubDate>Mon, 26 Nov 2018 07:41:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<og:description>Flutter for iOS 开发者 本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/10020664.html</dc:identifier>
</item>
<item>
<title>CTF-PWN练习 - 洪七公</title>
<link>http://www.cnblogs.com/klmyoil/p/10020595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/klmyoil/p/10020595.html</guid>
<description>&lt;h3&gt;预备知识&lt;/h3&gt;
&lt;p&gt;本实验要求实验者具备如下的相关知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、了解CTF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      CTF的全称是Capture The Flag，即夺旗的意思，因此CTF比赛也称为夺旗比赛。CTF夺旗赛是计算机安全竞赛的一种形式，CTF比赛主要表现以下几个技能上：逆向工程、密码 学、ACM编程、Web漏洞、二进制溢出、网络和取证等。在国际CTF赛事中，二进制溢出也称之为PWN。&lt;/p&gt;
&lt;p&gt;      PWN是一个黑客语法的俚语词，自&quot;own&quot;这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的 情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：&quot;You just got pwned!&quot;）。有一个非常著名的国际赛事叫做Pwn2Own，相信你现在已经能够理解这个名字的含义了，即通过打败对手来达到拥有的目的。&lt;/p&gt;
&lt;p&gt;      CTF中PWN题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE或者Linux下的ELF文件等），然后参赛选手通过对二进制程 序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到溢出攻击的效果，最终拿到目标机器的shell夺取flag。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Linux管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      Linux管道可以将一个进程的标准输出作为另一个进程的标准输入，管道的操作符号为“|”，比如ls命令可用于查看当前目录下的文件列表，而grep命 令可用于匹配特定的字符，因此ls | grep test命令可用于列出当前目录下文件名包含test的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Python基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      在Linux shell中执行python -c &quot;print 'Hello'&quot;可以执行双引号中的Python语句，即通过print打印出Hello字符串。Python中单引号和双引号没有区别，因为这里使用双 引号修饰Python语句，因此使用单引号修饰字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、gdb调试器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　gdb是Linux下常用的一款命令行调试器，拥有十分强大的调试功能。gdb命令如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152252275-1858658949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、汇编基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      读懂常见的汇编指令是CTF竞赛中PWN解题的基本要求，汇编指令如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152406664-1944899691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　汇编语言中，esp寄存器用于指示当前函数栈帧的栈顶的位置，函数中局部变量都存储在栈空间中，栈的生长方向是向下的（即从高地址往低地址方向生长）。&lt;/p&gt;
&lt;p&gt;      缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，使得溢出的数据覆盖在合法数据上，理想的情况是程序检查数据长度并不允许输入超 过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。&lt;/p&gt;
&lt;h3&gt;实验目的&lt;/h3&gt;
&lt;p&gt;1）了解CTF竞赛中的PWN题型&lt;/p&gt;
&lt;p&gt;2）了解缓冲区溢出攻击&lt;/p&gt;
&lt;p&gt;3）熟悉gdb的基本用法&lt;/p&gt;
&lt;h3&gt;实验环境&lt;/h3&gt;
&lt;p&gt;服务器：CentOS6.5，IP地址：随机分配&lt;/p&gt;
&lt;p&gt;辅助工具：Python，gdb&lt;/p&gt;
&lt;h3&gt;实验步骤一&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      主机/home/test/1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出&lt;strong&gt;Please try again.&lt;/strong&gt;的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出&lt;strong&gt;Congratulations, you pwned it.&lt;/strong&gt;信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码审计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      在实际的CTF竞赛的PWN题目中，一般是不会提供二进制程序的源代码的。这里为了方便大家学习，给出二进制程序的C语言源代码供大家分析，以源码审计的方式确定漏洞所在位置，方便后续进行汇编级别的分析。&lt;/p&gt;
&lt;p&gt;      （在没有源代码的情况下，我们通常使用IDA Pro对二进制程序进行逆向分析，使用IDA的Hex-Rays插件可以将反汇编代码还原为C语言伪代码，可以达到类似源代码的可读效果，在后期的实验中会专门对IDA的使用进行讲解）&lt;/p&gt;
&lt;p&gt;      使用cd /home/test/1切换到程序所在目录，执行cat pwn1.c即可看到源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)

{

    int modified;

    char buffer[64];

    modified = 0;

    gets(buffer);        // 引发缓冲区溢出

    if (modified != 0)

    {
        printf(&quot;Congratulations, you pwned it.\n&quot;);
    }

    else
    {
        printf(&quot;Please try again.\n&quot;);
    }
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。&lt;/p&gt;
&lt;h3&gt;实验步骤二&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用gdb调试程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152716343-1073859544.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下面是对main函数中的汇编代码的解释：&lt;/p&gt;
&lt;p&gt;0x080482a0 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;0&lt;strong&gt;&amp;gt;:&lt;/strong&gt;   &lt;strong&gt;push&lt;/strong&gt;   %ebp&lt;/p&gt;
&lt;p&gt;0x080482a1 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;1&lt;strong&gt;&amp;gt;:&lt;/strong&gt;   &lt;strong&gt;mov&lt;/strong&gt;    %esp&lt;strong&gt;,%&lt;/strong&gt;&lt;strong&gt;ebp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482a3 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;3&lt;strong&gt;&amp;gt;:&lt;/strong&gt;   &lt;strong&gt;and&lt;/strong&gt;    $0xfffffff0&lt;strong&gt;,%esp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; esp = esp - 0x60，即在栈上分配0x60）字节的空间&lt;/p&gt;
&lt;p&gt;0x080482a6 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;6&lt;strong&gt;&amp;gt;:&lt;/strong&gt;   &lt;strong&gt;sub&lt;/strong&gt;    $0x60&lt;strong&gt;,%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; modified变量位于esp + 0x5C处，将其初始化为0&lt;/p&gt;
&lt;p&gt;0x080482a9 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;9&lt;strong&gt;&amp;gt;:&lt;/strong&gt;   movl   $0x0&lt;strong&gt;,&lt;/strong&gt;0x5c&lt;strong&gt;(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; buffer位于esp + 0x1C处&lt;/p&gt;
&lt;p&gt;0x080482b1 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;17&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;lea&lt;/strong&gt;    0x1c&lt;strong&gt;(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;),%&lt;/strong&gt;&lt;strong&gt;eax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482b5 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;21&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;mov&lt;/strong&gt;    %eax&lt;strong&gt;,(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; 调用gets(buffer)读取输入数据&lt;/p&gt;
&lt;p&gt;0x080482b8 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;24&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;call&lt;/strong&gt;   0x8049360 &lt;strong&gt;&amp;lt;&lt;/strong&gt;gets&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; 判断modified变量的值是否是0&lt;/p&gt;
&lt;p&gt;0x080482bd &lt;strong&gt;&amp;lt;+&lt;/strong&gt;29&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  cmpl   $0x0&lt;strong&gt;,&lt;/strong&gt;0x5c&lt;strong&gt;(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; 如果modified的值等于0，就跳转到 0x080482d2&lt;/p&gt;
&lt;p&gt;0x080482c2 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;34&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;je&lt;/strong&gt;     0x80482d2 &lt;strong&gt;&amp;lt;&lt;/strong&gt;main&lt;strong&gt;+&lt;/strong&gt;50&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; modified不为0，打印成功提示&lt;/p&gt;
&lt;p&gt;0x080482c4 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;36&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  movl   $0x80b3eec&lt;strong&gt;,(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482cb &lt;strong&gt;&amp;lt;+&lt;/strong&gt;43&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;call&lt;/strong&gt;   0x8049500 &lt;strong&gt;&amp;lt;&lt;/strong&gt;puts&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482d0 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;48&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;jmp&lt;/strong&gt;    0x80482de &lt;strong&gt;&amp;lt;&lt;/strong&gt;main&lt;strong&gt;+&lt;/strong&gt;62&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;; modified为0，打印失败提示&lt;/p&gt;
&lt;p&gt;0x080482d2 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;50&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  movl   $0x80b3f0b&lt;strong&gt;,(%&lt;/strong&gt;&lt;strong&gt;esp&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482d9 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;57&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;call&lt;/strong&gt;   0x8049500 &lt;strong&gt;&amp;lt;&lt;/strong&gt;puts&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482de &lt;strong&gt;&amp;lt;+&lt;/strong&gt;62&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;mov&lt;/strong&gt;    $0x0&lt;strong&gt;,%&lt;/strong&gt;&lt;strong&gt;eax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482e3 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;67&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;leave&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0x080482e4 &lt;strong&gt;&amp;lt;+&lt;/strong&gt;68&lt;strong&gt;&amp;gt;:&lt;/strong&gt;  &lt;strong&gt;ret&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C = 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。&lt;/p&gt;
&lt;p&gt;      下面在gdb中进行验证，在gdb中执行b *0x080482bd命令对gets的下一条指令下一个断点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152753876-1069740346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在gdb中执行r命令，让被调试的pwn1程序跑起来，就可以输入数据进行测试了，这里我们输入64个A以及1个B（即 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB），按下 Enter键程序就在断点处断下了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152838111-1952898648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在gdb中输入x $esp+0x5C，查看modified变量的值已经被修改成了0x00000042，而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152903433-1021599850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在gdb中连续两次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152933752-2119506654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在gdb中输入c命令就可以让程序继续执行，看到输出了通过提示信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126152957189-981871499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;实验步骤三&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;体验溢出攻击效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      通过上面的步骤我们已经知道了如果控制输入数据来进行攻击，以达到进入if语句分支的目的。下面我们就可以通过构造输入数据进行攻击了。&lt;/p&gt;
&lt;p&gt;      如果你还没有退出gdb，输入q命令就可以退出gdb。下面通过python语句构造输入数据，然后通过管道传给pwn1程序，执行命令python -c &quot;print 'A'*64+'B'&quot; | ./pwn1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281056/201811/1281056-20181126153032633-26092391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 看到已经成功发起了溢出攻击，程序被你PWN掉啦！&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:32:00 +0000</pubDate>
<dc:creator>洪七公</dc:creator>
<og:description>预备知识 本实验要求实验者具备如下的相关知识。 一、了解CTF CTF的全称是Capture The Flag，即夺旗的意思，因此CTF比赛也称为夺旗比赛。CTF夺旗赛是计算机安全竞赛的一种形式，CT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/klmyoil/p/10020595.html</dc:identifier>
</item>
<item>
<title>SpringBoot(八)   Spring和消息队列RabbitMQ - 阿来丶</title>
<link>http://www.cnblogs.com/JiangLai/p/10019917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JiangLai/p/10019917.html</guid>
<description>&lt;p&gt;1.大多数应用中，可以通过消息服务中间件来提升系统异步能力和拓展解耦能力。&lt;/p&gt;
&lt;p&gt;2.消息服务中的两个重要概念：&lt;strong&gt;消息代理（Message broker）&lt;/strong&gt;和&lt;strong&gt;目的地（destination）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当消息发送者发送消息后，将由消息代理接管，消息代理保证消息传递到指定目的地。&lt;/p&gt;
&lt;p&gt;3.消息队列主要有两种形式的目的地： &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;队列：&lt;strong&gt;点对点方式通信&lt;/strong&gt;（point-to-point）&lt;/li&gt;
&lt;li&gt;主题：&lt;strong&gt;发布/订阅消息服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;点对点式：消息发送者发送消息后，消息代理将其放入一个队列中，消息接受者从队列中读取数据，接受者接收数据后，将消息移除队列。&lt;/p&gt;
&lt;p&gt;发布订阅：消息发布者将消息发布到主题中，多个接受者可以订阅主题，当消息到达时，所有的订阅者都会接收到消息。&lt;/p&gt;
&lt;p&gt;4.JMS(Java Message Service) Java消息服务：基于JVM消息代理的规范。&lt;/p&gt;
&lt;p&gt;5.AMQP（Advanced Message Queuing Protocol）：它是一个面向消息中间件的开放式标准应用层协议。兼容JMS，RabbitMQ是AMQP的一个实现。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;span&gt;JMS&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;AMQP&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Java API&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;网络线级协议&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;跨平台&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;跨语言&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;Model&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(1)、Peer-2-Peer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2)、Pub/Sub&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(1)、direct exchange&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2)、fanout exchange&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(3)、topic change&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(4)、headers exchange&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(5)、system exchange&lt;/span&gt;&lt;br/&gt;&lt;span&gt;后四种都是pub/sub ,差别路由机制做了更详细的划分&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;支持消息类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;TextMessage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MapMessage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ByteMessage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;StreamMessage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ObjectMessage&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Message&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;byte[]通常需要序列化&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Message:消息头和消息体组成，消息体是不透明的，而消息头上则是由一系列的可选属性组成，属性：路由键【routing-key】,优先级【priority】,指出消息可能需要持久性存储【delivery-mode】&lt;/p&gt;
&lt;p&gt;Publisher:消息的生产者，也是一个向交换器发布消息的客户端应用程序&lt;/p&gt;
&lt;p&gt;Exchange:交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列&lt;/p&gt;
&lt;p&gt;Exchange的4中类型：direct【默认】点对点，fanout,topic和headers, 发布订阅，不同类型的Exchange转发消息的策略有所区别&lt;/p&gt;
&lt;p&gt;Queue:消息队列，用来保存消息直到发送给消费者，它是消息的容器，也是消息的终点，一个消息可投入一个或多个队列，消息一直在队列里面，等待消费者连接到这个队列将数据取走。&lt;/p&gt;
&lt;p&gt;Binding:绑定，队列和交换机之间的关联，多对多关系&lt;/p&gt;
&lt;p&gt;Connection:网络连接，例如TCP连接&lt;/p&gt;
&lt;p&gt;Channel:信道，多路复用连接中的一条独立的双向数据流通道，信道是建立在真是的TCP链接之内的虚拟连接AMQP命令都是通过信道发送出去的。不管是发布消息，订阅队列还是接受消息，都是信道，减少TCP的开销，复用一条TCP连接。&lt;/p&gt;
&lt;p&gt;Consumer:消息的消费者，表示一个从消息队列中取得消息的客户端的 应用程序&lt;/p&gt;
&lt;p&gt;VirtualHost:小型的rabbitMQ,相互隔离&lt;/p&gt;
&lt;p&gt;Broker:表示消息队列 服务实体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1350478/201811/1350478-20181126140842651-449459066.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Exchange的三种方式&lt;/p&gt;
&lt;p&gt;direct：根据路由键直接匹配，一对一&lt;/p&gt;
&lt;p&gt;fanout:不经过路由键，直接发送到每一个队列&lt;/p&gt;
&lt;p&gt;topic:类似模糊匹配的根据路由键，来分配绑定的队列。#匹配一个或者多个单词，*匹配一个单词&lt;/p&gt;

&lt;p&gt;在RabbitMQ官网的下载页面&lt;code&gt;https://www.rabbitmq.com/download.html&lt;/code&gt;中，我们可以获取到针对各种不同操作系统的安装包和说明文档。这里，我们将对几个常用的平台一一说明。&lt;/p&gt;
&lt;p&gt;下面我们采用的Erlang和RabbitMQ Server版本说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Erlang/OTP 19.1&lt;/li&gt;
&lt;li&gt;RabbitMQ Server 3.6.5&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;Windows安装&quot;&gt;Windows安装&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;安装Erland，通过官方下载页面&lt;code&gt;http://www.erlang.org/downloads&lt;/code&gt;获取exe安装包，直接打开并完成安装。&lt;/li&gt;
&lt;li&gt;安装RabbitMQ，通过官方下载页面&lt;code&gt;https://www.rabbitmq.com/download.html&lt;/code&gt;获取exe安装包。&lt;/li&gt;
&lt;li&gt;下载完成后，直接运行安装程序。&lt;/li&gt;
&lt;li&gt;RabbitMQ Server安装完成之后，会自动的注册为服务，并以默认配置启动起来。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;Windows安装&quot;&gt;Docker安装&lt;/h4&gt;
&lt;p&gt;1、打开虚拟机，在docker中安装RabbitMQ&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.安装rabbitmq，使用镜像加速
docker pull registry.docker&lt;/span&gt;-cn.com/library/rabbitmq:&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;management
[root@node1 &lt;/span&gt;~&lt;span&gt;]# docker images
REPOSITORY                                     TAG                 IMAGE ID            CREATED             SIZE
registry.docker&lt;/span&gt;-cn.com/library/rabbitmq        &lt;span&gt;3&lt;/span&gt;-management        c51d1c73d028        &lt;span&gt;11&lt;/span&gt; days ago         &lt;span&gt;149&lt;/span&gt;&lt;span&gt; MB
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.运行rabbitmq
##### 端口：&lt;/span&gt;&lt;span&gt;5672&lt;/span&gt; 客户端和rabbitmq通信 &lt;span&gt;15672&lt;/span&gt;&lt;span&gt;：管理界面的web页面

docker run &lt;/span&gt;-d -p &lt;span&gt;5672&lt;/span&gt;:&lt;span&gt;5672&lt;/span&gt; -p &lt;span&gt;15672&lt;/span&gt;:&lt;span&gt;15672&lt;/span&gt; --&lt;span&gt;name myrabbitmq c51d1c73d028

#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.查看运行
docker ps&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、打开网页客户端并登陆   网址：http://localhost:15672/，账号【guest】,密码【guest】，登陆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1350478/201811/1350478-20181126151006661-1206205381.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、添加 【direct】【faout】【topic】的绑定关系等&lt;/p&gt;
&lt;p&gt;4、发布信息测试 。&lt;/p&gt;

&lt;h3&gt;(1)Java代码的方式使用RabbitMQ&lt;/h3&gt;
&lt;p&gt;1.在pom.xml文件中添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent &lt;span&gt;from&lt;/span&gt; repository --&amp;gt;
&amp;lt;/parent&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在&lt;code&gt;application.properties&lt;/code&gt;中配置关于RabbitMQ的连接和用户信息，用户可以回到上面的安装内容，在管理页面中创建用户。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  rabbitmq:
    host: &lt;/span&gt;192.168.1.125&lt;span&gt;
    port: &lt;/span&gt;5672&lt;span&gt;
    username: guest
    password: guest&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.创建消息生产者。通过注入Rabbit&lt;code&gt;Template&lt;/code&gt;接口的实例来实现消息的发送，Rabbit&lt;code&gt;Template&lt;/code&gt;接口定义了一套针对AMQP协议的基础操作。在Spring Boot中会根据配置来注入其具体实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Autowired
    RabbitTemplate rabbitTemplate;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextLoads() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Message需要自己构建一个；定义消息体内容和消息头
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rabbitTemplate.send(exchange, routingKey, message);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object 默认当成消息体，只需要传入要发送的对象，自动化序列发送给rabbitmq；&lt;/span&gt;
        Map&amp;lt;String,Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;&quot;msg&quot;, &quot;这是第一个信息&quot;&lt;span&gt;);
        map.put(&lt;/span&gt;&quot;data&quot;, Arrays.asList(&quot;helloWorld&quot;,123,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象被默认序列以后发送出去 exchange 和 routingKey都是在浏览器端定义好的。&lt;/span&gt;
        rabbitTemplate.convertAndSend(&quot;exchange.direct&quot;,&quot;test.news&quot;&lt;span&gt;,map);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.JSON序列化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAMQPConfig  {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MessageConverter messageConverter(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Jackson2JsonMessageConverter();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.接收消息（取出队列中的消息）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reciverAndConvert(){

    Object o &lt;/span&gt;= rabbitTemplate.receiveAndConvert(&quot;test.news&quot;&lt;span&gt;);
    System.out.println(o.getClass());
    System.out.println(o);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;（2）注解方式使用RabbitMQ&lt;/h3&gt;
&lt;p&gt;1.主程序开启RabbitMQ的注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@EnableRabbit &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启基于注解的rabbitmq&lt;/span&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AmqpApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(AmqpApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.使用注解的方式接收&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookService {
    @RabbitListener(queues &lt;/span&gt;= &quot;test.news&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; receive(Book book){
        System.out.println(book);
    }

    @RabbitListener(queues &lt;/span&gt;= &quot;test&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; receive02(Message message){
        System.out.println(message.getBody());
        System.out.println(message.getMessageProperties());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;（3）创建 Exchange（交换器）、Queue（消息队列）、Bind（绑定规则）--- AmqpAdmin。&lt;/h3&gt;
&lt;p&gt;1.创建一个Exange&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createExchange(){
    amqpAdmin.declareExchange(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DirectExchange(&quot;amqpadmin.direct&quot;&lt;span&gt;));
    System.out.println(&lt;/span&gt;&quot;Create Finish&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.创建Queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createQueue(){

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数1：名字  参数2：是否持久化  &lt;/span&gt;
    amqpAdmin.declareQueue(&lt;span&gt;new&lt;/span&gt; Queue(&quot;amqpadmin.queue&quot;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
    System.out.println(&lt;/span&gt;&quot;Create Queue Finish&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.创建Bind规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createBind(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数1：目的地    参数2：类型（队列或者交换器）   参数3：exchange的名称    参数4：路由件       参数5：参数&lt;/span&gt;
    amqpAdmin.declareBinding(&lt;span&gt;new&lt;/span&gt; Binding(&quot;amqpadmin.queue&quot;,Binding.DestinationType.QUEUE , &quot;amqpadmin.direct&quot;, &quot;amqp.haha&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 4.删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteExchange(){
    amqpAdmin.deleteExchange(&lt;/span&gt;&quot;amqpadmin.direct&quot;&lt;span&gt;);
    System.out.println(&lt;/span&gt;&quot;delete Finish&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Nov 2018 07:31:00 +0000</pubDate>
<dc:creator>阿来丶</dc:creator>
<og:description>概述 1.大多数应用中，可以通过消息服务中间件来提升系统异步能力和拓展解耦能力。 2.消息服务中的两个重要概念：消息代理（Message broker）和目的地（destination） 当消息发送者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JiangLai/p/10019917.html</dc:identifier>
</item>
<item>
<title>设计模式回顾系列之总体介绍 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10020447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10020447.html</guid>
<description>&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;背景与介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　设计模式是经过反复使用、经过分类的代码总结。设计模式的目的是提高代码可重用性和可靠性，并使代码条理清晰、易于理解、易于维护。&lt;/p&gt;
&lt;p&gt;　　设计模式描述了在各种情况下，要选择什么样的方案来解决问题。设计模式通常以类和对象来描述其中的关系和相互作用，换句话就是在设计模式里，这些类和普通的类没有区别，只是它们的相互作用形成了各种设计模式，并解决了很多现实性的问题。&lt;/p&gt;
&lt;p&gt;　　设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。&lt;/p&gt;
&lt;p&gt;　　设计模式是对面向对象的绝佳应用，它提供了众多不断重复发生在我们周围的问题的解决方案。学习设计模式可以更好的理解面向对象的内容，同时面向对象也为设计模式提供了很好的理论基础，在学习的过程中，会接触到很多面向对象的相关应用。&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;设计原则&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;单一职责原则 &lt;span&gt;（&lt;/span&gt;&lt;span&gt;Single Responsiblity Principle SRP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;开闭原则&lt;span&gt;（&lt;/span&gt;Open Closed Principle&lt;span&gt;，&lt;/span&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;模块应对扩展开放，而对修改关闭。直白点说就是，模块应尽量在不修改原代码的情况下进行扩展&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;里氏代换原则&lt;span&gt;（&lt;/span&gt;Liskov Substitution Principle&lt;span&gt;，&lt;/span&gt;&lt;span&gt;LSP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;如果调用的是父类的话，那么换成子类也完全可以运行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依赖倒转原则&lt;span&gt;（&lt;/span&gt;Dependency Inversion Principle&lt;span&gt;，&lt;/span&gt;&lt;span&gt;DIP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;把父类都替换成它的子类，而不会导致程序的行为发声变化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接口隔离原则&lt;span&gt;（&lt;/span&gt;Interface Segregation Principle&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ISP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;合成&lt;/span&gt;/&lt;span&gt;聚合复用原则（&lt;/span&gt;&lt;span&gt;Composite/Aggregate Reuse Principle&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CARP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最小知识原则（&lt;/span&gt;Principle of Least Knowledge&lt;span&gt;，&lt;/span&gt;&lt;span&gt;PLK&lt;/span&gt;&lt;span&gt;，也叫&lt;/span&gt;迪米特法则）
&lt;ul&gt;&lt;li&gt;一个对象应对其他对象有尽可能少的了解，也就是说要做好信息的隐藏，这个原则可以更多的从封装的角度去思考，包括方法与属性的设计。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;分类&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　根据&lt;/span&gt;GOF&lt;span&gt;《设计模式》一书，设计模式分为三个大类，共&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　以下改编自维基百科，另外再附一张总览图，方便有个总体的概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/533598/201811/533598-20181126153522519-284510628.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;38&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;&lt;strong&gt;模式名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;566&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;工厂方法模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;抽象工厂模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;单例模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;确保一个类只有一个实例，并提供对该实例的全局访问。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;生成器模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;原型模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型&lt;span&gt;,&lt;/span&gt;&lt;span&gt;创建新的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;566&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;适配器模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;桥接模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将一个抽象与实现解耦，以便两者可以独立的变化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;组合模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;修饰模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;外观模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;享元模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;通过共享以便有效的支持大量小颗粒对象。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;代理模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;为其他对象提供一个代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot; valign=&quot;center&quot; width=&quot;566&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;责任链模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;命令模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;解释器模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个语言&lt;span&gt;,&lt;/span&gt; &lt;span&gt;定义它的文法的一种表示，并定义一个解释器&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;该解释器使用该表示来解释语言中的句子。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;迭代器模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;提供一种方法顺序访问一个聚合对象中各个元素&lt;span&gt;,&lt;/span&gt; &lt;span&gt;而又不需暴露该对象的内部表示。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;中介者模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;备忘录模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;观察者模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;状态模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;策略模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;模板方法模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;55&quot;&gt;
&lt;p&gt;访问者模式&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;511&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

</description>
<pubDate>Mon, 26 Nov 2018 07:29:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>1. 背景与介绍 设计模式是经过反复使用、经过分类的代码总结。设计模式的目的是提高代码可重用性和可靠性，并使代码条理清晰、易于理解、易于维护。 设计模式描述了在各种情况下，要选择什么样的方案</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10020447.html</dc:identifier>
</item>
<item>
<title>Nginx实践--安全升级 - 木子墨</title>
<link>http://www.cnblogs.com/heioray/p/10020245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heioray/p/10020245.html</guid>
<description>&lt;p&gt;之前写了一些nginx的东西，这次继续，主要使用upstream针对proxy_pass转发做个处理&lt;br/&gt;一般情况下我们在使用nginx反向代理的时候，都是如下配置，&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;...
location /api {
   proxy_pass https://b.test.com; # 设置代理服务器的协议和地址
   proxy_cookie_domain b.test.com  a.test.com; # 修改cookie，针对request和response互相写入cookie
}       
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就实现了'/api'目录接口的转发。功能是实现了，&lt;strong&gt;但是有什么问题么？还真有！&lt;/strong&gt;&lt;br/&gt;如果我们可以反向代理，如果别人也知道了我们的接口域名也不是可以自己搭一个nginx服务器就可以代理到我们的接口服务器上去？？？是不是感觉很危险，是的。。。对此当时做的时候就加了一个临时方案，在接口服务中添加一个ip白名单，白名单中的ip都是nginx服务器的ip，然后就项目上线了。这样也实现了需求，但ip如果被伪造了怎么办？于是我们想到了另一个方案，使用内网IP代替对外开放的域名，这样在一定程度上就直接拦截了外部的直接访问，具体实现如下，&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;upstream apiServer {
    server 10.10.10.10.:8888
}
...
location /api {
   proxy_pass https://apiServer; 
   proxy_cookie_domain apiServer a.test.com; 
}       
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用upstream定义了一个apiServer的组，将转发都指向这里，这时相当于我们把可能存在的用户直接访问接口服务器的可能给关闭了，也就是途中红色的那部分危险操作～～&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/461976/201811/461976-20181126150053735-1115387633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能你会想upstream的使用纯属多余，的确当apiServer只有一台机器的时候，这个的确可以不用，但是多台机器的时候，虽然proxy_pass虽然可以定义多条但是太麻烦了。。。使用upstream组统一管理即可，同时使用upstream还有一些优势比如给多个server设置负载均衡，upstream组中支持通过weight参数来设置当前server在负载均衡中所占的比重，此外还可以通过设置backup参数指定某些服务器作为备份机等等。详细的配置内容还是建议大家参考&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html&quot;&gt;Nginx upstream官方文档&lt;/a&gt;。&lt;br/&gt;此外，除了安全性方面，使用内网ip进行接口转发也省去了转发中的DNS重新解析的过程，有利于大幅提升接口转发效率。同时若不想破坏已经做好的SLB的话，也可以不使用upstream，直接转发到SLB服务器的内网ip应该也是可以的。&lt;/p&gt;
&lt;p&gt;综上，在proxy_pass转发中我们使用了两种方案来对安全性做一些提升&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;proxy_pass转发到外网域名，同时在接口服务器上添加访问来源白名单，把nginx服务器的ip写进去&lt;/li&gt;
&lt;li&gt;proxy_pass转发到内网域名，多服务器的话使用upstream统一管理并实现负载均衡，也能提升转发效率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种方案是不是通用的呢？这样可行的话，我们的接口服务器是不是都不用设置外网可访问的域名了呢？&lt;br/&gt;第二种方案是可以通用的，但是这不意味着我们就可以抛弃外部可访问的域名，因为在一个落地业务中，比如第三方授权、微信支付等情况下外部可访问域名还是必须要有的。因此只有那些不需要与第三方进行通信，比如仅供公司内部使用的管理系统等，就可以直接抛弃外网域名了。此时个人建议就是上面两种方案结合一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;proxy_pass的转发使用内网ip，来提升转发效率，同时对外部访问添加白名单，只暴露需要和第三方通信的接口即可。&lt;br/&gt;这样在安全和效率高上就都能得到一定的提升。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如有错误，欢迎大家指正&lt;br/&gt;好好学习，天天向上～～&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:29:00 +0000</pubDate>
<dc:creator>木子墨</dc:creator>
<og:description>之前写了一些nginx的东西，这次继续，主要使用upstream针对proxy_pass转发做个处理 一般情况下我们在使用nginx反向代理的时候，都是如下配置， 这样就实现了'/api'目录接口的转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heioray/p/10020245.html</dc:identifier>
</item>
<item>
<title>Unity中的后期处理：PostProcessing - THEFOOL_时雨</title>
<link>http://www.cnblogs.com/acgstone/p/10020408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/acgstone/p/10020408.html</guid>
<description>&lt;p&gt;“想要实现这个效果，让我们来编写一个Shader。。”&lt;br/&gt;“Shader？？？”&lt;br/&gt;相信绝大多数开发者都有看过那些炫酷的效果而跃跃欲试却又对Shader代码望而却步的经历，新版本的unity新增的PostProcessing组件，让许多人看到了希望，虽然效果数量有限，却对于开发来说有很大的收益。&lt;/p&gt;
&lt;h2 id=&quot;安装postprocessing&quot;&gt;安装PostProcessing&lt;/h2&gt;
&lt;p&gt;PostProcessing是unity内置的后期效果增强组件，可以在极短的时间内得到各种常用特效的效果，对于编写Shader的苦手（比如在下）来说，确实是个天大的福音了。第一次接触PostProcessing与实际开发中，效果确实惊艳到了，之后PostProcessing就成了游戏开发的必备组件==。PostProcessing可以在资源包管理器中直接安装得到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_01.png&quot; alt=&quot;01&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新工程请在All中找到PostProcessing并点击右上角的install即可，我的已经安装完毕，所以界面有些不同，如果版本不一致没有资源包的话可以访问PostProcessing的Github页面： &lt;a href=&quot;https://github.com/Unity-Technologies/PostProcessing&quot;&gt;PostProcessing&lt;/a&gt; 按照说明将PostProcessing拖入工程文件夹就可以用了。附上官方效果对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_02.png&quot; alt=&quot;使用前&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_03.png&quot; alt=&quot;使用后&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这么看效果还是很明显的。虽然效果是在大型项目展示的，但是PostProcessing完全可以用在小型项目中构建各种各样出色的效果。&lt;/p&gt;
&lt;h2 id=&quot;使用postprocessing&quot;&gt;使用PostProcessing&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;PostProcessing Layer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们需要在相机中添加一个Post-process Layer组件来渲染相机图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_TIM%E6%88%AA%E5%9B%BE20181123174355.png&quot; alt=&quot;Post-process Layer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Trigger触发器默认是相机本身，如果有需要可以设置为其他物体，如挂载到角色上面，可以实现进入特定区域触发特效，这个后面再说。Layer是一个很重要也很容易忽略的角色，必须保证postprocessing volume所处层级与此项相同，一般来说建议设置专用层以提高渲染性能。其次的抗锯齿 延迟雾效等等看项目情况调整即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PostProcessing volume&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_postprocessingVolume.png&quot; alt=&quot;postprocessingVolume&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Volume分为全局和局部两种实现方式，全局只需选中Is Global选项。局部需要挂载Collider3D组（记得选中Is Trigger）件并取消Is Global选项，当PostProcessing Layer中的触发器（Trigger）进入Collider中就能看到效果了，可以实现洞穴等场景的变换特效。（切记把挂载PostProcessing Volume组件的物体Layer设置为PostProcessing Layer中的对应Layer）&lt;/p&gt;
&lt;p&gt;Blend Distance用来实现特效的渐弱，使特效自然渐进的出场或退场。Weight影响权重，0完全不起作用，1效果全开。效果会在多个volume混合时根据这几个属性数值进行叠加。&lt;/p&gt;
&lt;p&gt;profile就是特效的配置文件了，点击new即可创建新的特效配置，之后点击Add effect-&amp;gt;Unity即可看到PostProcessing提供的11中特效。直接点击就可以再面板中看到相应的特效，展开即可进行编辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_addEffect.png&quot; alt=&quot;effect&quot;/&gt;&lt;/p&gt;
&lt;p&gt;All生效所有属性，None禁用所有属性，也可以只用其中的某些属性，选中相应的属性栏就可以了。&lt;br/&gt;下面简单说一说这些特效，如果用到某个特效再细细分析。&lt;/p&gt;
&lt;h2 id=&quot;post-process特效&quot;&gt;Post-process特效&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Ambient Occlusion 环境光遮罩：用来使像是世界中难以照射到光线的角落，交叉点等地方变暗。&lt;/li&gt;
&lt;li&gt;Anti aliasing：抗锯齿：抗锯齿功能提供的算法可以是锯齿感明显的边缘更加平滑，虽然锯齿感减少，却会使物体变得模糊。&lt;/li&gt;
&lt;li&gt;Auto Exposure 自动曝光：模拟人眼适应各种黑暗与光亮的效果，比如从黑暗的隧道出来时，人眼会有短暂时间的炫目。&lt;/li&gt;
&lt;li&gt;Bloom 辉光：最常用的Post-process特效之一，效果和他的名字一样，提供图像从明亮边缘扩散的效果，Dirtiness可以模拟污渍和灰尘来衍生Bloom特效，在FPS游戏中常见这类效果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-bloom.jpg&quot; alt=&quot;screenshot-bloom&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Intensity&lt;/td&gt;
&lt;td&gt;辉光的强度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Threshold&lt;/td&gt;
&lt;td&gt;过滤掉小于此光照强度的像素点，注： 该值以伽马空间表示&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Soft Knee&lt;/td&gt;
&lt;td&gt;在低于/高于阈值的渐变（0 =硬阈值，1 =软阈值）之间进行转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Clamp&lt;/td&gt;
&lt;td&gt;限制辉光像素的数量，该值以伽马空间表示&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Diffusion&lt;/td&gt;
&lt;td&gt;以与屏幕分辨率无关的方式改变遮蔽效果的程度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Anamorphic Ratio&lt;/td&gt;
&lt;td&gt;通过垂直（在范围[-1,0]中）或水平（在范围[0,1]中）缩放辉光来模拟变形镜头的效果&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Color&lt;/td&gt;
&lt;td&gt;辉光的色调&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Fast Mode&lt;/td&gt;
&lt;td&gt;通过降低效果质量来提升表现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Texture&lt;/td&gt;
&lt;td&gt;模拟污垢为镜片添加污迹或灰尘&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Intensity&lt;/td&gt;
&lt;td&gt;镜头污渍的数量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;Chromatic Aberration 色差：在边界产生一些颜色条纹，模拟相机镜头为颜色没有汇聚的缺陷行为来增加艺术性的效果，可以用来模拟中毒特效。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-chroma.jpg&quot; alt=&quot;screenshot-chroma&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Color Grading 颜色分级：另一个经常用到的特效，用于校正镜头中的颜色与亮度，来实现电影或海报效果，可以理解为手机中的何种滤镜。需要一定的专业基础才能玩转，但是通过调整Tonemapping（色调映射）的mod可以快速实现一些效果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-grading.jpg&quot; alt=&quot;screenshot-grading&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Deferred Fog 延时雾效：雾是根据与相机的距离将颜色叠加到对象上的效果。 这用于模拟室外环境中的雾或雾，并且通常还用于在摄像机的远剪裁平面向前移动以提高性能时隐藏对象的剪裁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-fog.jpg&quot; alt=&quot;screenshot-fog&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Depth of Field 景深：常用特效之一，模拟相机镜头的对焦效果而产生模糊感。模糊不仅给出了关于物体距离的视觉提示，而且还引入了散景，这是令人愉悦的视觉伪像。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-dof.jpg&quot; alt=&quot;screenshot-dof&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Focus Distance&lt;/td&gt;
&lt;td&gt;对焦距离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Aperture&lt;/td&gt;
&lt;td&gt;孔径比（称为f-stop或f-number）。值越小，景深越浅&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Focal Length&lt;/td&gt;
&lt;td&gt;镜头和胶片之间的距离。 值越大，景深越浅&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Max Blur Size&lt;/td&gt;
&lt;td&gt;散景滤镜的卷积核大小，决定散景的最大半径&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;Grain 颗粒效果：模拟老电影屏幕上的颗粒感，用于模拟老式显像设备。&lt;/li&gt;
&lt;li&gt;Lens Distortion 镜头失真：此效果通过扭曲或不失真最终渲染图片来模拟镜头的形状。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-distortion.jpg&quot; alt=&quot;screenshot-distortion&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Motion Blur 运动模糊：“运动模糊”是一种常见的后处理效果，可以模拟当相机拍摄的对象移动得比相机的曝光时间快时图像的模糊。运动模糊用于在大多数类型的游戏中产生微妙的效果，但在一些类型中被夸大，例如赛车游戏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-motionblur.jpg&quot; alt=&quot;screenshot-motionblur&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Screen space Reflections 屏幕空间反射：屏幕空间反射是一种重用屏幕空间数据来计算反射的技术。 它通常用于产生更微妙的反射，例如在潮湿的地板表面或水坑中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-ssr.jpg&quot; alt=&quot;screenshot-ssr&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vignette 晕影：在摄影中，晕影是用于与中心相比朝向图像边缘变暗和/或去饱和的术语。经常用于艺术效果，例如将焦点绘制到图像的中心。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;screenshot-vignette&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/acgstone/1349675/o_screenshot-vignette.jpg&quot; alt=&quot;screenshot-vignette&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;以上只是对PostProcessing的一些简介，PostProcessing是个复杂的组件，要想搞清全部特效需要大量的实践与相关的专业知识，对于初学者或想要快速构建游戏效果的人来说，认识PostProcessing特效和添加特效只是最基本的一步。因为调整PostProcessing是个细致且漫长的过程，请务必在游戏开发接近尾声时再斟酌效果，调整参数。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:27:00 +0000</pubDate>
<dc:creator>THEFOOL_时雨</dc:creator>
<og:description>“想要实现这个效果，让我们来编写一个Shader。。” “Shader？？？” 相信绝大多数开发者都有看过那些炫酷的效果而跃跃欲试却又对Shader代码望而却步的经历，新版本的unity新增的Post</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/acgstone/p/10020408.html</dc:identifier>
</item>
<item>
<title>理解OpenShift（1）：网络之 Router 和 Route - SammyLiu</title>
<link>http://www.cnblogs.com/sammyliu/p/10013461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sammyliu/p/10013461.html</guid>
<description>&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/sammyliu/p/10013461.html%20&quot; target=&quot;_blank&quot;&gt;理解OpenShift（1）：网络之Router 和 Route&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1. OpenShift 为什么需要 Router 和 Route？&lt;/h2&gt;
&lt;p&gt;顾名思义，Router 是路由器，Route 是路由器中配置的路由。OpenShift 中的这两个概念是为了解决从集群外部（就是从除了集群节点以外的其它地方）访问服务的需求。不晓得为什么OpenShift 要将Kubernetes 中的 Ingress 改为 Router，我倒是觉得 Ingress 名字更贴切。&lt;/p&gt;
&lt;p&gt;从外部通过 router 和从内部通过 servide 访问 pod 中的应用两个过程的简单的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181124203554066-1004108549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，某个应用的三个pod 分别位于 node1，node2 和 node3 上。OpenShift 中有三层IP地址概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pod 自己的 IP 地址，可以类比为 OpenStack 中虚拟机的固定IP。它只有在集群内才有意义。&lt;/li&gt;
&lt;li&gt;service 的 IP 地址。Service 通常有 ClusterIP，这也是一种集群内部的IP 地址。&lt;/li&gt;
&lt;li&gt;应用的外部 IP 地址，可以类比为OpenStack 中的浮动IP，或者IDC IP（和浮动IP 之间是NAT 映射关系）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，要从集群外部访问 pod 中的应用，无非两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是利用一个代理（proxy），把外部 IP 地址转化为后端的 Pod IP 地址。这就是 OpenShift router/route 的思路。OpenShift 中的 router 服务，是一个运行在特定节点（通常是基础架构节点）上的集群基础服务，由集群管理员负责创建和管理。它可以有多个副本（pod）。router 中可有多个 route，每个 route 能通过外部HTTP 请求的域名找出其后端的 pod 列表，并进行网络包的转发。也就是将pod 中的应用暴露到外网域名，使得用户可以外面通过域名访问到应用。这实际上是一种七层负载均衡器。OpenShift 默认采用 HAProxy 来实现，当然也支持其它实现，比如 F5.&lt;/li&gt;
&lt;li&gt;另一种是将服务直接暴露到集群外。这种方式具体会在『服务 Service』那一篇文章中详细解释。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2. OpenShift 如何利用 HAProxy 实现 router 和 route？&lt;/h2&gt;
&lt;h3&gt;2.1 Router 部署&lt;/h3&gt;
&lt;p&gt;使用 ansible 采用默认配置部署 OpenShift 集群时，在集群 Infra 节点上，会以 Host networking 方式运行一个 HAProxy 的 pod，它会在所有网卡的 80 和 443 端口上进行监听。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@infra-node3 cloud-user]# netstat -lntp |&lt;span&gt; grep haproxy
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;10443&lt;/span&gt;         &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;583&lt;/span&gt;/&lt;span&gt;haproxy         
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;10444&lt;/span&gt;         &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;583&lt;/span&gt;/&lt;span&gt;haproxy         
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;              &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;583&lt;/span&gt;/&lt;span&gt;haproxy         
tcp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;443&lt;/span&gt;             &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;583&lt;/span&gt;/haproxy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，172.0.0.1 上的 10443 和 10444 是HAproxy 自己使用的。下文会有解释。&lt;/p&gt;
&lt;p&gt;因此，在每个 infra 节点上，只能有一个 HAProxy pod，因为这些端口只能被占用一次。如果调度器找不到满足要求的节点，则router 服务的调度就会失败：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;7&lt;/span&gt; nodes are available: &lt;span&gt;2&lt;/span&gt; node(s) didn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t have free ports for the requested pod ports, 5 node(s) didn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;t match node selector
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OpenShift HAProxy Router 支持两种部署方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是常见的单Router 服务部署，它有一个或多个实例（pod），分布在多个节点上，负责整个集群上部署的服务的对外访问。&lt;/li&gt;
&lt;li&gt;另一种是分片（sharding）部署。此时，会有多个 Router 服务，每个Router 服务负责指定的若干project，两者之间采用标签（label）进行映射。这是为了解决单个 Router 的性能不够问题而提出的解决方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OpenShift 提供了 &lt;strong&gt;oc adm router&lt;/strong&gt; 命令来创建 router 服务。&lt;/p&gt;
&lt;p&gt;创建router：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@master1 cloud-user]# oc adm router router2 --replicas=&lt;span&gt;1&lt;/span&gt; --service-account=&lt;span&gt;router
&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;: password &lt;span&gt;for&lt;/span&gt;&lt;span&gt; stats user admin has been set to J3YyPjlbqf
&lt;/span&gt;--&amp;gt;&lt;span&gt; Creating router router2 ...
    warning: serviceaccounts &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;router&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; already exists
    clusterrolebinding.authorization.openshift.io &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;router-router2-role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created
    deploymentconfig.apps.openshift.io &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;router2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created
    service &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;router2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; created
&lt;/span&gt;--&amp;gt; Success
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细的部署方法请参见官方文档 https://docs.openshift.com/container-platform/3.11/install_config/router/default_haproxy_router.html。&lt;/p&gt;
&lt;h3&gt;2.2 Router pod 中的 HAProxy 进程&lt;/h3&gt;
&lt;p&gt;在 Router 服务的每个 pod 之中，openshift-router 进程启动了一个 haproy 进程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UID        PID  PPID  C STIME TTY          TIME CMD
&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;+     &lt;span&gt;1&lt;/span&gt;     &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; Nov21 ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt; /usr/bin/openshift-&lt;span&gt;router
&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;+ &lt;span&gt;16011&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/haproxy -f /&lt;span&gt;var&lt;/span&gt;/lib/haproxy/conf/haproxy.config -p /&lt;span&gt;var&lt;/span&gt;/lib/haproxy/run/haproxy.pid -x /&lt;span&gt;var&lt;/span&gt;/lib/haproxy/run/haproxy.sock -sf &lt;span&gt;16004&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 haproxy 使用的配置文件（只是部分）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;global
  maxconn &lt;/span&gt;&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;
  daemon
  ca&lt;/span&gt;-base /etc/&lt;span&gt;ssl
  crt&lt;/span&gt;-base /etc/&lt;span&gt;ssl
 。。。。&lt;/span&gt;&lt;span&gt;  

defaults
  maxconn &lt;/span&gt;&lt;span&gt;20000&lt;/span&gt;&lt;span&gt;

  # Add x&lt;/span&gt;-forwarded-&lt;span&gt;for&lt;/span&gt;&lt;span&gt; header.
&lt;/span&gt;&lt;span&gt;
  # server openshift_backend &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
  errorfile &lt;/span&gt;&lt;span&gt;503&lt;/span&gt; /var/lib/haproxy/conf/error-page-&lt;span&gt;503&lt;/span&gt;&lt;span&gt;.http

&lt;/span&gt;&lt;span&gt;。。。
  timeout http&lt;/span&gt;-&lt;span&gt;request 10s
  timeout http&lt;/span&gt;-keep-&lt;span&gt;alive 300s

  # Long timeout &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; WebSocket connections.
  timeout tunnel 1h

frontend public
    
  bind :&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;
  mode http
  tcp&lt;/span&gt;-request inspect-&lt;span&gt;delay 5s
  tcp&lt;/span&gt;-request content accept &lt;span&gt;if&lt;/span&gt;&lt;span&gt; HTTP
  monitor&lt;/span&gt;-uri /&lt;span&gt;_______internal_router_healthz

  # Strip off Proxy headers to prevent HTTpoxy (https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;httpoxy.org/)&lt;/span&gt;
  http-request del-&lt;span&gt;header Proxy

  # DNS labels are &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; insensitive (RFC &lt;span&gt;4343&lt;/span&gt;), we need to convert the &lt;span&gt;hostname&lt;/span&gt;&lt;span&gt; into lowercase
  # before matching, or any requests containing uppercase characters will never match.
  http&lt;/span&gt;-request set-header Host %&lt;span&gt;[req.hdr(Host),lower]

  # check &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; we need to redirect/&lt;span&gt;force using https.
  acl secure_redirect base,map_reg(&lt;/span&gt;/var/lib/haproxy/conf/os_route_http_redirect.map) -&lt;span&gt;m found
  redirect scheme https &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; secure_redirect

  use_backend &lt;/span&gt;%[base,map_reg(/var/lib/haproxy/conf/&lt;span&gt;os_http_be.map)]

  default_backend openshift_default

# public ssl accepts all connections and isn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t checking certificates yet certificates to use will be&lt;/span&gt;
# determined by the next backend &lt;span&gt;in&lt;/span&gt; the chain &lt;span&gt;which&lt;/span&gt;&lt;span&gt; may be an app backend (passthrough termination) or a backend
# that terminates encryption &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; this router (edge)
frontend public_ssl
    
  bind :&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;
  tcp&lt;/span&gt;-request  inspect-&lt;span&gt;delay 5s
  tcp&lt;/span&gt;-request content accept &lt;span&gt;if&lt;/span&gt; { req_ssl_hello_type &lt;span&gt;1&lt;/span&gt;&lt;span&gt; }

  # &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; the connection is SNI and the route is a passthrough don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t use the termination backend, just use the tcp backend&lt;/span&gt;
  # &lt;span&gt;for&lt;/span&gt; the SNI &lt;span&gt;case&lt;/span&gt;, we also need to compare it &lt;span&gt;in&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;-insensitive mode (by converting it to lowercase) as RFC &lt;span&gt;4343&lt;/span&gt;&lt;span&gt; says
  acl sni req.ssl_sni &lt;/span&gt;-&lt;span&gt;m found
  acl sni_passthrough req.ssl_sni,lower,map_reg(&lt;/span&gt;/var/lib/haproxy/conf/os_sni_passthrough.map) -&lt;span&gt;m found
  use_backend &lt;/span&gt;%[req.ssl_sni,lower,map_reg(/var/lib/haproxy/conf/os_tcp_be.map)] &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sni sni_passthrough

  # &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; the route is SNI and NOT passthrough enter the termination flow
  use_backend be_sni &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; sni

  # non SNI requests should enter a default termination backend rather than the custom cert SNI backend since it
  # will not be able to match a cert to an SNI host
  default_backend be_no_sni

&lt;/span&gt;&lt;span&gt;。。。&lt;br/&gt;backend be_edge_http:demoprojectone:jenkins
  mode http
  option redispatch
  option forwardfor
  balance leastconn
  timeout server  4m

  timeout check 5000ms
  http&lt;/span&gt;-request set-header X-Forwarded-Host %&lt;span&gt;[req.hdr(host)]
  http&lt;/span&gt;-request set-header X-Forwarded-Port %&lt;span&gt;[dst_port]
  http&lt;/span&gt;-request set-header X-Forwarded-Proto http &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;{ ssl_fc }
  http&lt;/span&gt;-request set-header X-Forwarded-Proto https &lt;span&gt;if&lt;/span&gt;&lt;span&gt; { ssl_fc }
  http&lt;/span&gt;-request set-header X-Forwarded-Proto-Version h2 &lt;span&gt;if&lt;/span&gt; { ssl_fc_alpn -&lt;span&gt;i h2 }
  http&lt;/span&gt;-request add-header Forwarded &lt;span&gt;for&lt;/span&gt;=%[src];host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)];proto-version=%[req.hdr(X-Forwarded-Proto-&lt;span&gt;Version)]
  cookie 4376ea64d7d0abf11209cfe5f7cca1e7 insert indirect nocache httponly secure
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-84nrt:jenkins:&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.13&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.13&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; cookie 8669a19afc9f0fed6824feb9fb1cf4ac weight &lt;span&gt;256&lt;/span&gt;&lt;span&gt;

。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了简单期间，上面只是配置文件的部分内容，它主要包括三种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局配置，比如最大连接数 maxconn，超时时间 timeout 等；以及front部分，即前端配置，HAProxy 默认会在 443 和 80 两个端口上分别监听外部 https 和 http 请求。&lt;/li&gt;
&lt;li&gt;backend，即每个服务的后端配置，里面有很多关键内容，比如后端协议（mode）、负载均衡方法（balance）、后端列表（server，这里是pod，包括其IP 地址和端口）、证书等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，OpenShift 的路由器功能需要能对这三部分进行管理和控制。&lt;/p&gt;
&lt;p&gt;关于负载均衡器和 HAProxy 的详细介绍，可以参考 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sammyliu/p/4656176.html&quot;&gt;Neutron 理解 (7): Neutron 是如何实现负载均衡器虚拟化的&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;h3&gt;2.3 全局配置管理&lt;/h3&gt;
&lt;p&gt;要指定或修改 HAProxy 的全局配置，OpenShift 有提供两种方式：&lt;/p&gt;
&lt;p&gt;（1）第一种是使用 &lt;strong&gt;oc adm router&lt;/strong&gt; 命令在创建 router 时候指定各种参数，比如 --max-connections 用于设置最大连接数。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
oc adm router --max-connections=&lt;span&gt;200000&lt;/span&gt; --ports=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;81:80,444:443&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; router3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建出来的HAProxy 的 maxconn 将是 20000，router3 这个服务对外暴露出来的端口是 81 和 444，但是 HAProxy pod 的端口依然是 80 和 443.&lt;/p&gt;
&lt;p&gt;（2）通过设置 dc/&amp;lt;dc router名&amp;gt; 的环境变量来设置 router 的全局配置。&lt;/p&gt;
&lt;p&gt;在官方文档 https://docs.openshift.com/container-platform/3.4/architecture/core_concepts/routes.html#haproxy-template-router 中有完整的环境变量列表。比如运行以下命令后，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 oc set &lt;span&gt;env&lt;/span&gt; dc/router3 ROUTER_SERVICE_HTTPS_PORT=&lt;span&gt;444&lt;/span&gt; ROUTER_SERVICE_HTTP_PORT=&lt;span&gt;81&lt;/span&gt; STATS_PORT=&lt;span&gt;1937&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;router3 会重新部署，新部署的HAProxy 的 https 监听端口是 444，http 监听端口是 80，统计端口是 1937.&lt;/p&gt;
&lt;h3&gt; 2.4 OpenShift passthrough 类型的 route 与 HAProxy backend&lt;/h3&gt;
&lt;p&gt;（1）通过OpenShift Console 或者 oc 命令创建一条 route，它将 sit 项目的 jenkins 服务暴露到域名 sitjenkins.com.cn：&lt;/p&gt;
&lt;p&gt;在界面上创建 route：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181125230654068-1608465599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181125230717313-1621823852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Name:                   sitjenkins.com.cn
Namespace:              sit&lt;/span&gt;&lt;span&gt;
Labels:                 app&lt;/span&gt;=jenkins-&lt;span&gt;ephemeral
                        template&lt;/span&gt;=jenkins-ephemeral-&lt;span&gt;template
Annotations:            &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Requested Host:         sitjenkins.com.cn&lt;/span&gt;&lt;span&gt;
Path:                   &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
TLS Termination:        passthrough&lt;/span&gt;&lt;span&gt;
Endpoint Port:          web

Service:        jenkins
Weight:         &lt;/span&gt;&lt;span&gt;100&lt;/span&gt; (&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;)
Endpoints:      &lt;/span&gt;&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;, &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，service name 起了一个中介作用，把 route 和服务的端点（也就是pod）连接了起来。&lt;/p&gt;
&lt;p&gt;（2）router 服务的两个 pod 中的 HAProxy 进程的配置文件中多了一个backend：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Secure backend, pass through
backend be_tcp:sit:sitjenkins.com.cn
  balance source

  hash&lt;/span&gt;-&lt;span&gt;type consistent
  timeout check 5000ms}
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-bqhfj:jenkins:&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; weight &lt;span&gt;256&lt;/span&gt;&lt;span&gt; check inter 5000ms
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-h2fff:jenkins:&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; weight &lt;span&gt;256&lt;/span&gt; check inter 5000ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，这些后端 server 其实就是 pod，它们是 openshift 通过步骤（1）中的 service name 找到的。balance 是负载均衡策略，后文会解释。&lt;/p&gt;
&lt;p&gt;（3）文件 /var/lib/haproxy/conf/os_sni_passthrough.map 中多了一条记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sh&lt;/span&gt;-&lt;span&gt;4.2&lt;/span&gt;$ &lt;span&gt;cat&lt;/span&gt; /var/lib/haproxy/conf/&lt;span&gt;os_sni_passthrough.map
&lt;/span&gt;^sitjenkins\.com\.cn(:[&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9&lt;/span&gt;]+)?(/.*)?$ &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）文件 /var/lib/haproxy/conf/os_tcp_be.map 中多了一条记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sh&lt;/span&gt;-&lt;span&gt;4.2&lt;/span&gt;$ &lt;span&gt;cat&lt;/span&gt; /var/lib/haproxy/conf/&lt;span&gt;os_tcp_be.map
&lt;/span&gt;^sitjenkins\.com\.cn(:[&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9&lt;/span&gt;]+)?(/.*)?$ be_tcp:sit:sitjenkins.com.cn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）HAProxy 根据上面的 map 文件为该条 route 选择第（2）步中增加的 backend的逻辑如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
frontend public_ssl  &lt;span&gt;#解释：前端协议 https，&lt;/span&gt;

  bind :&lt;span&gt;443  &lt;span&gt;##前端端口 443&lt;/span&gt;&lt;/span&gt;
  tcp-request  inspect-delay 5s
  tcp-request content accept &lt;span&gt;if&lt;/span&gt; { req_ssl_hello_type &lt;span&gt;1&lt;/span&gt; }

  # &lt;span&gt;if&lt;/span&gt; the connection is SNI and the route is a passthrough don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t use the termination backend, just use the tcp backend&lt;/span&gt;
  # &lt;span&gt;for&lt;/span&gt; the SNI &lt;span&gt;case&lt;/span&gt;, we also need to compare it &lt;span&gt;in&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;-insensitive mode (by converting it to lowercase) as RFC &lt;span&gt;4343&lt;/span&gt; says
  acl sni req.ssl_sni -m found &lt;span&gt;##检查 https request 支持 sni&lt;/span&gt;
  acl sni_passthrough req.ssl_sni,lower,map_reg(/var/lib/haproxy/conf/os_sni_passthrough.map) -m found &lt;span&gt;##检查通过 sni 传来的 hostname 在 os_sni_patthrough.map 文件中&lt;/span&gt;
  use_backend %[req.ssl_sni,lower,map_reg(/var/lib/haproxy/conf/os_tcp_be.map)] &lt;span&gt;if&lt;/span&gt; sni sni_passthrough &lt;span&gt;##从 oc_tcp_be.map 中根据 sni hostname 获取 backend name&lt;/span&gt;

  # &lt;span&gt;if&lt;/span&gt; the route is SNI and NOT passthrough enter the termination flow
  use_backend be_sni &lt;span&gt;if&lt;/span&gt; sni

  # non SNI requests should enter a default termination backend rather than the custom cert SNI backend since it
  # will not be able to match a cert to an SNI host
  default_backend be_no_sni
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）HAPorxy 进程会重启，从而应用修改了的配置文件。&lt;/p&gt;
&lt;p&gt;理解（5）中的脚本需要的一些背景知识：&lt;/p&gt;
&lt;p&gt;从上面的蓝色注释中，我们能看到 HAProxy 进程通过 https 请求中通过 SNI 传入的域名 sitjenkins.com.cn ，在 os_tcp_be.map 文件中获取到了 backend 名称 be_tcp:sit:sitjenkins.com.cn，这样就和（2）步骤中的 backend 对应上了。&lt;/p&gt;
&lt;p&gt;OpenShift 的 router 使用的 HAProxy 采用基于域名的负载均衡路由方式，示例如下，具体说明请参加官方文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181125231238465-302249391.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.5 OpenShift edge 和 re-encrypt 类型的 route 与 HAProxy&lt;/h3&gt;
&lt;p&gt;HAProxy 前端：前端依然是在 443 端口监听外部 HTTPS 请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;frontend public_ssl
  bind :&lt;/span&gt;&lt;span&gt;443&lt;br/&gt;&lt;/span&gt;&lt;span&gt;.....
  # &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; the route is SNI and NOT passthrough enter the termination flow
  use_backend be_sni &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sni
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，当 TLS 终止类型不是 passthrough （edge 或者 re-encrypt）时，会使用backend be_sni。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;backend be_sni
  server fe_sni &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;10444&lt;/span&gt; weight &lt;span&gt;1&lt;/span&gt; send-prox
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这个后端是由本机的 127.0.0.1:10444 提供服务，因此又转到了前端 fe_sni：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;frontend fe_sni
  # terminate ssl on edge
  bind &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;10444&lt;/span&gt; ssl no-sslv3 crt /var/lib/haproxy/router/certs/default.pem crt-list /var/lib/haproxy/conf/cert_config.map accept-&lt;span&gt;proxy
  mode http
&lt;/span&gt;&lt;span&gt;。。。。。。

  # map to backend
  # Search from most specific to general path (host &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt;).
  # Note: If no match, haproxy uses the default_backend, no other
  #       use_backend directives below this will be processed.
  use_backend &lt;/span&gt;%[base,map_reg(/var/lib/haproxy/conf/&lt;span&gt;os_edge_reencrypt_be.map)]

  default_backend openshift_default&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;map 映射文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sh&lt;/span&gt;-&lt;span&gt;4.2&lt;/span&gt;$ &lt;span&gt;cat&lt;/span&gt; /var/lib/haproxy/conf/&lt;span&gt;os_edge_reencrypt_be.map
&lt;/span&gt;^edgejenkins\.com\.cn(:[&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9&lt;/span&gt;]+)?(/.*)?$ be_edge_http:sit:jenkins-edge
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Edge 类型 route 的 HAProxy 后端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
backend be_edge_http:sit:jenkins-&lt;span&gt;edge
  mode http
  option redispatch
  option forwardfor
  balance leastconn

  timeout check 5000ms
  .....&lt;/span&gt;&lt;span&gt;
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-bqhfj:jenkins:&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; cookie 71c6bd03732fa7da2f1b497b1e4c7993 weight &lt;span&gt;256&lt;/span&gt;&lt;span&gt; check inter 5000ms
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-h2fff:jenkins:&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; cookie fa8d7fb72a46958a7add1406e6d26cc8 weight &lt;span&gt;256&lt;/span&gt; check inter 5000ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Re-encrypt 类型 route 的 HAProxy 后端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Plain http backend or backend with TLS terminated at the edge or a
# secure backend with re&lt;/span&gt;-&lt;span&gt;encryption.
backend be_secure:sit:reencryptjenkins.com.cn
  mode http
&lt;/span&gt;&lt;span&gt;。。。。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    http-request set-header X-Forwarded-Host %[req.hdr(host)]&lt;br/&gt;    http-request set-header X-Forwarded-Port %[dst_port]&lt;br/&gt;    http-request set-header X-Forwarded-Proto http if !{ ssl_fc }&lt;br/&gt;    http-request set-header X-Forwarded-Proto https if { ssl_fc }&lt;br/&gt;    http-request set-header X-Forwarded-Proto-Version h2 if { ssl_fc_alpn -i h2 }&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-bqhfj:jenkins:&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.15&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; cookie ... weight &lt;span&gt;256&lt;/span&gt; ssl verifyhost jenkins.sit.svc verify required ca-&lt;span&gt;file&lt;/span&gt; /var/run/secrets/kubernetes.io/serviceaccount/service-&lt;span&gt;ca.crt check inter 5000ms &lt;span&gt;#与后端的链路采用 ssl 加密，并且要检查hostname&lt;/span&gt;
  server pod:jenkins&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-h2fff:jenkins:&lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;0.10&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; cookie ... weight &lt;span&gt;256&lt;/span&gt; ssl verifyhost jenkins.sit.svc verify required ca-&lt;span&gt;file&lt;/span&gt; /var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt check inter 5000ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以看出来重新使用密钥对连接进行加密，但是不知道为何 mode 依然是 http，而不是 https。&lt;/p&gt;
&lt;h3&gt; 2.6 设置和修改 route 配置&lt;/h3&gt;
&lt;p&gt;route 配置主要有以下几个比较重要的：&lt;/p&gt;
&lt;p&gt;（1）SSL 终结方式。共三种：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;edge：TLS 在 router 上被终结，然后非SSL网络包被转发给后端 pod。因此需要在 router 上安装 TLS 证书。不安装的话，会使用 router 的默认证书。&lt;/li&gt;
&lt;li&gt;passthrough：加密网络包直接被发给 pod，router 上不做TLS 终结，因为不需要在 router 上配置证书或密钥。&lt;/li&gt;
&lt;li&gt;Re-encryption：是 edge 的一种变种。首先 router 上会使用一个证书做 TSL 终结，然后使用另外的证书再进行加密，然后发给后端 pod。因此，整个网络路径都是加密的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置：&lt;/p&gt;
&lt;p&gt;（2）负载均衡策略。也有三种：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;roundrobin：根据权重轮流使用所有后端。&lt;/li&gt;
&lt;li&gt;leastconn：选择最少连接的后端接收请求。&lt;/li&gt;
&lt;li&gt;source：将源IP进行哈希，确保来自同一个源IP的请求发给同一个后端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要修改整个 router 的负载均衡策略，可使用 ROUTER_TCP_BALANCE_SCHEME 环境变量，为该 router 的所有 passthrough 类型的 route设置负载均衡策略，使用 ROUTER_LOAD_BALANCE_ALGORITHM 为其它类型的 route 设置策略。&lt;/li&gt;
&lt;li&gt;可以使用 &lt;a href=&quot;http://haproxy.router.openshift.io/balance&quot;&gt;haproxy.router.openshift.io/balance&lt;/a&gt; 为某个 route 设置负载均衡策略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 举例：&lt;/p&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;设置整个 router 的环境变量：oc set env dc/router ROUTER_TCP_BALANCE_SCHEME=roundrobin&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;改完以后，该 router 实例会重新部署，所有 passthrough 的 route 都是 roundrobin 类型的了。默认为 source 类型。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;修改某个 route 的负载均衡的策略：oc edit route aaaa.svc.cluster.local&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;32&quot;&gt;
&lt;div&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;修改完成后，HAProxy 中对应该 route 的 backend 中的 balance 值会被修改为 leastconn。&lt;/p&gt;
&lt;h2&gt;3. OpenShift router 服务如何实现高可用？&lt;/h2&gt;
&lt;p&gt;OpenShift router 服务支持两种高可用模式。&lt;/p&gt;
&lt;h3&gt;3.1 单 router 服务多副本，并利用和DNS/LB 实现高可用&lt;/h3&gt;
&lt;p&gt;这种模式只部署一个 router 服务，它支持集群的所有对外暴露的服务。要实现HA，需要设置副本数（replicas）大于1，使得会在超过一台服务器上创建pod，然后再通过DNS轮询或者四层负载均衡。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181126143523739-1716569271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 router/pod 中的 HAProxy 要实现本地配置文件，因此实际上它们是有状态容器。OpenShift 采用 etcd 作为配置的统一存储，openshift-router 进程应该是采取某种机制（被通知或定时拉取）从 etcd 中获取 router 和 route 的配置，然后再修改本地的配置文件，再重启 HAPorxy 进程来应用新修改了的配置文件。 要深入了解这里面的工作原理，可以去看源代码。&lt;/p&gt;
&lt;h3&gt;3.2 多 router 服务通过分片（sharding）实现高可用&lt;/h3&gt;
&lt;p&gt;这种模式下，管理员需要创建和部署多个 router 服务，每个router 服务支持一个或几个 project/namespace。router 和 project/namespace 之间的映射使用标签（label）来实现。具体的配置请参考官网 https://docs.openshift.com/container-platform/3.11/install_config/router/default_haproxy_router.html。实际上，和一些产品（比如mysql，memedcache）的分片功能类似，该功能更多地是为了解决性能问题，而无法完全解决高可用问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181126142837748-1584340235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4. 常见问题如何排查？&lt;/h2&gt;
&lt;p&gt;从上面的分析可以看出，要使得 router 和 route 都正常工作，至少要确保以下几个环节都是没问题的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端使用 route 中配置的域名和端口来访问服务。&lt;/li&gt;
&lt;li&gt;DNS 能将域名解析到目标 router 所在的服务器（在使用分片配置时比较复杂，尤其需要注意）。&lt;/li&gt;
&lt;li&gt;如有采用另外的四层负载均衡器的话，它得配置正确、工作正常。&lt;/li&gt;
&lt;li&gt;HAProxy 能通过域名匹配到正确的backend。&lt;/li&gt;
&lt;li&gt;router 和 route 的配置被正确地反映到了 HAProxy 的配置文件中了。&lt;/li&gt;
&lt;li&gt;HAProxy 进程重启了，从而读取了新修改的配置文件。&lt;/li&gt;
&lt;li&gt;后端 pod 列表正确，并且至少有一个 pod 正常工作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果您看到如下的错误页面，则说明上面的第3到7点至少有一处不能正常功能。此时，进行有针对性的排查即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181126144145306-985545888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;感谢您的阅读，欢迎关注我的微信公众号：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181126152157602-744511459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;/div&gt;

</description>
<pubDate>Mon, 26 Nov 2018 07:19:00 +0000</pubDate>
<dc:creator>SammyLiu</dc:creator>
<og:description>理解OpenShift（1）：网络之Router 和 Route 1. OpenShift 为什么需要 Router 和 Route？ 顾名思义，Router 是路由器，Route 是路由器中配置的路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sammyliu/p/10013461.html</dc:identifier>
</item>
<item>
<title>循序渐进学习数据结构之线性表 - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/10020424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/10020424.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150746685-1549651143.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;名词解释&quot;&gt;1.名词解释：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线性表：&lt;/strong&gt;由n个数据特性相同的元素构成的有限序列，有顺序存储和链式存储两种表示形式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150805447-635402253.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空表&lt;/strong&gt;：线性表中元素的个数n=0的表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性表的链式存储结构&lt;/strong&gt;：特点是用一组任意的存储单元存储线性表的数据元素，包括两个域，其中存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环单链表&lt;/strong&gt;：是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150825689-2082526635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;循环双链表&lt;/strong&gt;：是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，头节点同时指向最后一个节点，整个链表形成一个环。（这个图画的太丑啦！！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150835471-1519322951.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：是指有两个指针域，其一指向直接后继，另一指向直接前趋。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150845911-1218853938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性结构&lt;/strong&gt;：若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非空线性表或线性结构特点：&lt;/strong&gt; 1.存在唯一的一个被称作“第一个”的数据元素；2.存在唯一的一个被称作“最后一个”的数据元素；3.除第一个之外，结构中的每个数据元素均只有一个前驱；4.除最后一个之外，结构中的每个数据元素均只有一个后继&lt;/p&gt;
&lt;h2 id=&quot;存储结构&quot;&gt;2.存储结构&lt;/h2&gt;
&lt;h3 id=&quot;顺序表&quot;&gt;1.顺序表&lt;/h3&gt;
&lt;h4 id=&quot;特点&quot;&gt;1.特点&lt;/h4&gt;
&lt;p&gt;（一）利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致&lt;br/&gt;（二）在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种存取元素的方法被称为随机存取法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;优缺点&quot;&gt;2.优缺点&lt;/h4&gt;
&lt;p&gt;优点: 存储密度大（结点本身所占存储量/结点结构所占存储量）；可以随机存取表中任一元素&lt;/p&gt;
&lt;p&gt;缺点：在插入、删除某一元素时，需要移动大量元素；浪费存储空间；属于静态存储形式，数据元素的个数不能自由扩充。&lt;br/&gt;　&lt;br/&gt;　&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了克服这样的缺点---链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;链表&quot;&gt;2.链表&lt;/h3&gt;
&lt;p&gt;链表各结点由两个域组成：数据域：存储元素数值数据；指针域：存储直接后继结点的存储位置&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150859203-842225800.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150914987-1390832423.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头指针：&lt;/strong&gt;指向链表中第一个结点的指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头结点：&lt;/strong&gt;在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首元结点：&lt;/strong&gt;指链表中存储第一个数据元素a1的结点&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;链表中设置头结点的好处：&lt;/p&gt;
&lt;p&gt;⒈便于首元结点的处理&lt;br/&gt;首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;&lt;/p&gt;
&lt;p&gt;⒉便于空表和非空表的统一处理&lt;br/&gt;无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。&lt;br/&gt;头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;特点-1&quot;&gt;1.特点&lt;/h4&gt;
&lt;p&gt;（一）结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻&lt;br/&gt;（二）访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等　&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种存取元素的方法被称为顺序存取法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;优缺点-1&quot;&gt;2.优缺点&lt;/h4&gt;
&lt;p&gt;优点: 存储密度小（结点本身所占存储量/结点结构所占存储量）；删除或者插入操作时间复杂度低&lt;/p&gt;
&lt;p&gt;缺点：在查询的时候需要从头节点开始查找，时间复杂度高。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了克服这样的缺点---双链表，循环链表等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;顺序表的基本操作&quot;&gt;1.顺序表的基本操作：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.初始化顺序表（参数用引用）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status InitList_Sq(SqList &amp;amp;L){                //构造一个空的顺序表L
    L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间
    if(!L.elem) exit(OVERFLOW);            //存储分配失败
    L.length=0;                    //空表长度为0
    return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;1.初始化顺序表（参数用指针）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status InitList_Sq(SqList *L){                    //构造一个空的顺序表L
    L-&amp;gt;elem=new ElemType[MAXSIZE];   //为顺序表分配空间
    if(!L-&amp;gt;elem) exit(OVERFLOW);            //存储分配失败
    L-&amp;gt;length=0;                                    //空表长度为0
    return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.取值（根据位置i获取相应位置数据元素的内容） ：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int GetElem(SqList L,int i,ElemType &amp;amp;e)
{
  if (i&amp;lt;1||i&amp;gt;L.length) 
    return 0;                            //判断i值是否合理，若不合理，返回0  
  e=L.elem[i-1];                           //第i-1的单元存储着第i个数据
  return 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.查找（根据指定数据获取数据所在的位置 ） ：&lt;br/&gt;在线性表L中查找值为e的数据元素&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int LocateELem(SqList L,ElemType e)
{
  for (i=0;i&amp;lt; L.length;i++)
      if (L.elem[i]==e) return i+1;                
  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.插入（插入到第i个结点之前 ） ：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status ListInsert_Sq(SqList &amp;amp;L,int i ,ElemType e){
   if(i&amp;lt;1 || i&amp;gt;L.length+1) return ERROR;             //i值不合法
   if(L.length==MAXSIZE) return ERROR;      //当前存储空间已满     
   for(j=L.length-1;j&amp;gt;=i-1;j--) 
       L.elem[j+1]=L.elem[j];                              //插入位置及之后的元素后移
    L.elem[i-1]=e;                                                //将新元素e放入第i个位置
    ++L.length;                                //表长增1
    return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.删除（删除第i个结点） ：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status ListDelete_Sq(SqList &amp;amp;L,int i){
   if((i&amp;lt;1)||(i&amp;gt;L.length)) return ERROR;    //i值不合法
   for (j=i;j&amp;lt;=L.length-1;j++)                   
　  　L.elem[j-1]=L.elem[j];                      //被删除元素之后的元素前移  
   --L.length;                                             //表长减1
  return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;单链表的基本操作&quot;&gt;2.单链表的基本操作：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 初始化&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;【算法步骤】&lt;/p&gt;
&lt;p&gt;（1）生成新结点作头结点，用头指针L指向头结点。&lt;br/&gt;（2）头结点的指针域置空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status InitList_L(LinkList &amp;amp;L){ 
   L=new LNode;                     
   L-&amp;gt;next=NULL;　　　　　
   return OK; 
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 取值（根据位置i获取相应位置数据元素的内容）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status GetElem_L(LinkList L,int i,ElemType &amp;amp;e){ 
     p=L-&amp;gt;next;j=1;                     //初始化
     while(p&amp;amp;&amp;amp;j&amp;lt;i){          //向后扫描，直到p指向第i个元素或p为空 
       p=p-&amp;gt;next; ++j; 
     } 
     if(!p || j&amp;gt;i)return ERROR;  //第i个元素不存在 
     e=p-&amp;gt;data;                            //取第i个元素 
     return OK; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. 查找&lt;br/&gt;根据指定数据获取数据所在的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 在链表L中查找值为e的数据元素，并返回该结点
LNode *LocateELem_L (LinkList L，Elemtype e) {
 //返回L中值为e的数据元素的地址，查找失败返回NULL
  p=L-&amp;gt;next;
  while(p &amp;amp;&amp;amp;p-&amp;gt;data!=e)  
        p=p-&amp;gt;next;                      
  return p;     
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.插入&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;【算法步骤】&lt;br/&gt;（一）找到ai-1存储位置p&lt;/p&gt;
&lt;p&gt;（二）生成一个新结点*s&lt;/p&gt;
&lt;p&gt;（三）将新结点*s的数据域置为x&lt;/p&gt;
&lt;p&gt;（四）新结点*s的指针域指向结点ai&lt;/p&gt;
&lt;p&gt;（五）令结点&lt;em&gt;p的指针域指向新结点&lt;/em&gt;s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150938793-785060295.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 核心代码
s-&amp;gt;next=p-&amp;gt;next;  
p-&amp;gt;next= s;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;//在L中第i个元素之前插入数据元素e 
Status ListInsert_L(LinkList &amp;amp;L,int i,ElemType e){ 
      p=L;j=0; 
      while(p&amp;amp;&amp;amp;j&amp;lt;i−1){p=p-&amp;gt;next;++j;}   //寻找第i−1个结点 
      if(!p||j&amp;gt;i−1)return ERROR;                  //i大于表长 + 1或者小于1  
      s=new LNode;          //生成新结点s 
      s-&amp;gt;data=e;                         //将结点s的数据域置为e 
      s-&amp;gt;next=p-&amp;gt;next;                   //将结点s插入L中 
      p-&amp;gt;next=s; 
      return OK; 
}//ListInsert_L 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.删除&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;【算法步骤】&lt;/p&gt;
&lt;p&gt;（一）找到ai-1存储位置p&lt;/p&gt;
&lt;p&gt;（二）保存要删除的结点的值&lt;/p&gt;
&lt;p&gt;（三）令p-＞next指向ai的直接后继结点&lt;/p&gt;
&lt;p&gt;（四）释放结点ai的空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126150950646-13521403.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int ListDelete_L(LinkList &amp;amp;L,int i,ElemType &amp;amp;e){
    p=L;j=0; 
    while(p-&amp;gt;next &amp;amp;&amp;amp;j&amp;lt;i-1){             //寻找第i个结点，并令p指向其前驱 
        p=p-&amp;gt;next; ++j; 
    } 
    if(!(p-&amp;gt;next)||j&amp;gt;i-1) return 0;      //删除位置不合理 
    q=p-&amp;gt;next;                                   //临时保存被删结点的地址以备释放 
    p-&amp;gt;next=q-&amp;gt;next;                   //改变删除结点前驱结点的指针域 
    e=q-&amp;gt;data;                               //保存删除结点的数据域 
    delete q;                                //释放删除结点的空间 
    return 1; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;双向链表的基本操作&quot;&gt;3.双向链表的基本操作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.双向链表的插入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126151002459-1211497978.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 核心代码
1. s-&amp;gt;prior=p-&amp;gt;prior;
2. p-&amp;gt;prior-&amp;gt;next=s;
3. s-&amp;gt;next=p;
4. p-&amp;gt;prior=s;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status ListInsert_DuL(DuLinkList &amp;amp;L,int i,ElemType e){
   if(!(p=GetElemP_DuL(L,i))) return ERROR;
    s=new DuLNode; 
   s-&amp;gt;data=e;
   s-&amp;gt;prior=p-&amp;gt;prior;  
   p-&amp;gt;prior-&amp;gt;next=s;
   s-&amp;gt;next=p;  
   p-&amp;gt;prior=s;
   return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.双向链表的删除：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126151015362-820253477.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;// 核心代码
1. p-&amp;gt;prior-&amp;gt;next=p-&amp;gt;next;

2. p-&amp;gt;next-&amp;gt;prior=p-&amp;gt;prior;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;Status ListDelete_DuL(DuLinkList &amp;amp;L,int i,ElemType &amp;amp;e){
   if(!(p=GetElemP_DuL(L,i)))     return ERROR;
   e=p-&amp;gt;data;
   p-&amp;gt;prior-&amp;gt;next=p-&amp;gt;next;
   p-&amp;gt;next-&amp;gt;prior=p-&amp;gt;prior;
   delete p; 
   return OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;循环链表的基本操作&quot;&gt;4.循环链表的基本操作&lt;/h2&gt;
&lt;p&gt;理解单链表和双向链表的操作，循环链表的操作也类似。这里不在赘述。&lt;/p&gt;
&lt;h2 id=&quot;四比较顺序表和单链表&quot;&gt;四、比较顺序表和单链表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126151029985-876334059.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注公众号：coder辰砂 （一个认认真真写东西的公众号）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181126151151543-1771736016.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:15:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>一、思维导图 二、线性表的基本概念 1.名词解释： 线性表： 由n个数据特性相同的元素构成的有限序列，有顺序存储和链式存储两种表示形式。 空表 ：线性表中元素的个数n=0的表。 线性表的链式存储结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/10020424.html</dc:identifier>
</item>
<item>
<title>设计模式是什么鬼（享元） - 后端技术精选</title>
<link>http://www.cnblogs.com/javazhiyin/p/10020433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javazhiyin/p/10020433.html</guid>
<description>&lt;p&gt;&lt;span&gt;//作者：凸凹里歐&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;元，始也，本初，根源之意，计算机中的二进制“元”其实就1和0，这两个东西组合起来有无穷无尽的可能，这便形成了计算机中的大千世界，正如“阴”和“阳”为万物之首一样，这也是为什么称其为二元。顾名思义，享元就是共享本元的意思，然而这个模式的英文叫做Flyweight，能飞起来一般的重量，轻量级的意思，“享元”其实并非意译，但这并不影响其对这个模式的最佳诠释。&lt;/p&gt;
&lt;p&gt;我们来看一个实例，比如我们要开发一款RPG游戏，游戏地图通常非常大，而且有各种各样，有草地、沙漠、荒原，水路等等，在写代码之前，我们先思考下应该怎样去建模。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p99.pstatp.com/large/pgc-image/301bfd1ce3d84ac9aaf55c16fdcf0218&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于这种地图，我们加载一整张图片来做地图？如果地图太大，图片加载相当卡顿吧？而且大片地图上其实都是重复的图片素材，整图加载设计也有失灵活性。再仔细观察下，这地图无非就是很多小图片（元）拼起来的哦，这不就是类似于我们装修时贴马赛克嘛？&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/a911d0296e1648f78903bdac69cb8809&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这可简单了！我们应该有个砖块类，持有“图片”，“位置”等属性信息，然后实例化这些砖块再调用其“绘制”方法把图片显示在地图某位置上即可。二话不说开始写代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tile {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; String image;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地砖所用的图片材质&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x, y;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地砖所在坐标&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; Tile(String image, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.image =&lt;span&gt; image;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  System.out.print(&quot;从磁盘加载[&quot; + image + &quot;]图片，耗时半秒。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; draw() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  System.out.println(&quot;在位置[&quot; + x + &quot;:&quot; + y + &quot;]上绘制图片：[&quot; + image + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码看起来非常简单，第3行的地砖材质图片我们用String来模拟代替，第7行初始化时我们把图片加载到内存，比如说这个IO操作要耗费半秒时间，好了我们先测试绘制第一行砖块，运行一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以绘制第一行为例&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;河流&quot;, 10, 10&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;河流&quot;, 10, 20&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;石路&quot;, 10, 30&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;草坪&quot;, 10, 40&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;草坪&quot;, 10, 50&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;草坪&quot;, 10, 60&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;草坪&quot;, 10, 70&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Tile(&quot;草坪&quot;, 10, 80&lt;span&gt;).draw();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 运行结果
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; 从磁盘加载[河流]图片，耗时半秒。。。在位置[10:10]上绘制图片：[河流]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; 从磁盘加载[河流]图片，耗时半秒。。。在位置[10:20]上绘制图片：[河流]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; 从磁盘加载[石路]图片，耗时半秒。。。在位置[10:30]上绘制图片：[石路]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:40]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:50]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:60]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:70]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:80]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有没有发现问题？每加载一张图都要耗费掉半秒钟，才画了8张地砖图就4秒钟流逝了，如果构建整张地图得多少时间？这就像是在慢性自杀，如此效率严重影响了游戏的用户体验，光卡顿在地图加载这给漫长的过程就已经让玩家失去兴趣了。&lt;/p&gt;
&lt;p&gt;相信大家一定想到了《设计模式是什么鬼（原型）》模式吧？对，我们把相同的图共享出来，用克隆的方式代替物件图实例化的过程，从而加快初始化速度。再想想，共享元貌似没什么问题，速度也加快了，但对象数量貌似还是个严重问题，每一个小物件图都要对应一个对象，这么个小游戏用得着那么大的内存开销么，搞不好甚至会造成内存溢出，嗯，设计模式一定还是有问题。&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/36a3c759b4bd45fda775bac2ac28bf6d&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;沿着共享的思路我们再看下到底需不需要这么多对象？这些对象不同的地方在于其坐标的不同，再就是材质的不同，也就是图的不同了，能不能从这些对象里抽取出来一些共同点呢？首先每个图的坐标都不一样，是没办法共享的，但是材质图是重复出现的，是可以共享的，同样的材质图会在不同的坐标位置上重复出现，那么这个材质图是可以做成共享元的。&lt;/p&gt;
&lt;p&gt;既然坐标不能共享，那就不做为材质类的共享元属性，由客户端维护这些坐标并作为参数传入好了，而且这些材质都有绘制能力，那就先定义一个接口吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Drawable {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制方法，接收地图坐标。&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然，我们也可以用抽象类抽出更多的属性和方法代替接口，使子类变得简单，这里为了清晰说明问题就用接口。接下来是材质类们，统统实现这个绘制接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Water &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Drawable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String image;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;河流图片材质&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Water() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.image = &quot;河流&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; System.out.print(&quot;从磁盘加载[&quot; + image + &quot;]图片，耗时半秒。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; System.out.println(&quot;在位置[&quot; + x + &quot;:&quot; + y + &quot;]上绘制图片：[&quot; + image + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;ql-align-justify&quot;&gt;注意第6行因为是河流材质类，所以初始化我们直接加载河流图片素材，这就是类内部即将做共享的“元”数据了，也叫做“内蕴状态”，至于“外蕴状态”就是坐标了，只作为参数从外部传入不做共享。接下来是草地、石子路等等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Grass &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Drawable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; String image;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;草坪图片材质&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Grass() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.image = &quot;草坪&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  System.out.print(&quot;从磁盘加载[&quot; + image + &quot;]图片，耗时半秒。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  System.out.println(&quot;在位置[&quot; + x + &quot;:&quot; + y + &quot;]上绘制图片：[&quot; + image + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Stone &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Drawable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; String image;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;石路图片材质&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stone() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.image = &quot;石路&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  System.out.print(&quot;从磁盘加载[&quot; + image + &quot;]图片，耗时半秒。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  System.out.println(&quot;在位置[&quot; + x + &quot;:&quot; + y + &quot;]上绘制图片：[&quot; + image + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; House &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Drawable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; String image;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;房子图片材质&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; House() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.image = &quot;房子&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  System.out.print(&quot;从磁盘加载[&quot; + image + &quot;]图片，耗时一秒。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  System.out.println(&quot;将图层切到最上层。。。&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;房子盖在地上，所以切换到顶层图层。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;  System.out.println(&quot;在位置[&quot; + x + &quot;:&quot; + y + &quot;]上绘制图片：[&quot; + image + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;source-code&quot;&gt;
&lt;code&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;注意上面这个的房子类有所不同，它有自己特有的绘制行为方法，也就是在地板图层之上绘制房子，覆盖掉下面的地板，使其变得更加立体。这也就是为什么我们非要用接口或抽象类来做引用，使实现类可以有自己独特的行为方式，多态的好处立竿见影。接下来就是实现“元之共享”的关键了，我们来做一个简单工厂类，看代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Factory {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图件工厂&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Drawable&amp;gt; images;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图库&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Factory() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  images = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Drawable&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Drawable getDrawable(String image) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存里如果没有图件，则实例化并放入缓存。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;images.containsKey(image)){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (image) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  &lt;span&gt;case&lt;/span&gt; &quot;河流&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  images.put(image, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Water());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;case&lt;/span&gt; &quot;草坪&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  images.put(image, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Grass());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;case&lt;/span&gt; &quot;石路&quot;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  images.put(image, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stone());
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存里必然有图，直接取得并返回。&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; images.get(image);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个图件工厂维护着所有元对象的图库，构造方法于第5行会初始化一个哈希图的缓存”池“，当客户端于第8行需要实例化图件的时候，我们先观察这个图库池里存在不存在已实例化过的图件，也就是看有无已做共享的图元，如果没有则实例化并加入图库共享池供下次使用，这便是”元之共享“的秘密了。巧夺天工的设计一气呵成，已经迫不及待去运行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先实例化图件工厂&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  Factory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Factory();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以第一行为例&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  factory.getDrawable(&quot;河流&quot;).draw(10, 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  factory.getDrawable(&quot;河流&quot;).draw(10, 20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  factory.getDrawable(&quot;石路&quot;).draw(10, 30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  factory.getDrawable(&quot;草坪&quot;).draw(10, 40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  factory.getDrawable(&quot;草坪&quot;).draw(10, 50&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  factory.getDrawable(&quot;草坪&quot;).draw(10, 60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  factory.getDrawable(&quot;草坪&quot;).draw(10, 70&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  factory.getDrawable(&quot;草坪&quot;).draw(10, 80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;运行结果
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; 从磁盘加载[河流]图片，耗时半秒。。。在位置[10:10]上绘制图片：[河流]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; 在位置[10:20]上绘制图片：[河流]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; 从磁盘加载[石路]图片，耗时半秒。。。在位置[10:30]上绘制图片：[石路]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; 从磁盘加载[草坪]图片，耗时半秒。。。在位置[10:40]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; 在位置[10:50]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; 在位置[10:60]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; 在位置[10:70]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; 在位置[10:80]上绘制图片：[草坪]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，我们抛弃了利用new关键字肆意妄为地制造对象，而是改用这个图件工厂去帮我们把元构建并共享起来。显而易见，我们看到运行结果中每次实例化对象会耗费半秒时间，再次请求对象时就不再会加载图片耗费时间了，也就是从共享图池直接拿到了，不再造次。更妙的是，如果画完整个地图只需要实例化需要用到的某些元素材而已，即使是那个大房子图件也只需要实例化一次就够了。至此，CPU速度，内存轻量化同时做到了优化，整个游戏用户体验得到了极大的提升。&lt;/p&gt;
&lt;p&gt;享元的精髓当然重点不止于”享“，更重要的是对于元的辨识，例如那个从外部客户端传入的坐标参数，如果我们依然把坐标也当作共享对象元数据（内蕴状态）的话，那么这个结构将无元可享，大量的对象就如同世界上没有相同的两片树叶一样多不胜数，最终会导致图库池被撑爆，享元将变得毫无意义。所以，对于整个系统数据结构的分析、设计、规划显得尤为重要。&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/0cf63c7d92e340f0bf86098abf0b70fb&quot; alt=&quot;&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p&gt;内外相济，里应外合，以不变应万变的化繁为简，元，万变不离其宗，享之。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 07:13:00 +0000</pubDate>
<dc:creator>后端技术精选</dc:creator>
<og:description>//作者：凸凹里歐 元，始也，本初，根源之意，计算机中的二进制“元”其实就1和0，这两个东西组合起来有无穷无尽的可能，这便形成了计算机中的大千世界，正如“阴”和“阳”为万物之首一样，这也是为什么称其为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javazhiyin/p/10020433.html</dc:identifier>
</item>
</channel>
</rss>