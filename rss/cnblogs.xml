<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>QT使用websocket进行长连接 - 徐沛东</title>
<link>http://www.cnblogs.com/xupeidong/p/9401519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xupeidong/p/9401519.html</guid>
<description>&lt;p&gt;一般我们用的最多的就是http请求，但是频繁的请求可能对服务造成的压力很大，所以今天谈谈websocket长连接，一句话：简单&lt;/p&gt;
&lt;p&gt;1、什么是长连接？&lt;/p&gt;
&lt;p&gt;A：一次请求连接，终身使用，就可以长久的保持信息的交互，除非服务挂了&lt;/p&gt;
&lt;p&gt;2、QT里面是如何使用websocket进行长连接的&lt;/p&gt;
&lt;p&gt;①首先在pro文件里面添加QT += websockets&lt;/p&gt;
&lt;p&gt;②#include &amp;lt;QWebSocket&amp;gt;&lt;/p&gt;
&lt;p&gt;③初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
_pdataRecvWS = new QWebSocket();
connect(_pdataRecvWS,SIGNAL(disconnected()),this,SLOT(onDisconnected()),Qt::AutoConnection);
connect(_pdataRecvWS,SIGNAL(textMessageReceived(QString)),this,SLOT(onTextReceived(QString)),Qt::AutoConnection);
connect(_pdataRecvWS,SIGNAL(connected()),this,SLOT(onConnected()),Qt::AutoConnection);
connect(_ptimer,SIGNAL(timeout()),this,SLOT(reconnect()),Qt::AutoConnection);
_pdataRecvWS-&amp;gt;open(QUrl(&quot;ws://localhost:8080&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④对应的槽函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//断开连接会触发这个槽函数
void MainWindow::onDisconnected()
{
    _ptimer-&amp;gt;start(3000);
    ui-&amp;gt;textEdit-&amp;gt;append(&quot;websocket is disconnected&quot;);
}
//连接成功会触发这个槽函数
void MainWindow::onConnected()
{
    _ptimer-&amp;gt;stop();
    ui-&amp;gt;textEdit-&amp;gt;append(&quot;connect successful&quot;);
}
//收到服务发来的消息会触发这个槽函数
void MainWindow::onTextReceived(QString msg)
{
    ui-&amp;gt;textEdit-&amp;gt;append(&quot;textReceiveString&quot; + msg);
}
//断开连接会启动定时器，触发这个槽函数重新连接
void MainWindow::reconnect()
{
    ui-&amp;gt;textEdit-&amp;gt;append(&quot;websocket reconnected&quot;);
    _pdataRecvWS-&amp;gt;abort();
    _pdataRecvWS-&amp;gt;open(QUrl(&quot;ws://localhost:8080&quot;));
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 01 Aug 2018 07:30:00 +0000</pubDate>
<dc:creator>徐沛东</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xupeidong/p/9401519.html</dc:identifier>
</item>
<item>
<title>JAVA算法之递归 - Coope</title>
<link>http://www.cnblogs.com/zhoukebo/p/9353293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoukebo/p/9353293.html</guid>
<description>&lt;h3&gt;Ⅰ、三角数字&lt;/h3&gt;
&lt;p&gt;　　首先我们来看一组数字：1,3,6,10,15,21.....，在这个数列中第n项是由n-1项加n得到的，这个序列中的数字称为三角数字因为他们可以形象化地表示成一个三角形排列。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201807/1424431-20180723204707880-707385518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的图首先我们就可以想到使用循环来查找第n项的数值，下面代码就是从高度为n的列加到高度为1的列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; triangle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n&amp;gt;0&lt;span&gt;){
        total &lt;/span&gt;= total +&lt;span&gt; n;
        &lt;/span&gt;--&lt;span&gt;n;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面方法循环了n次，第一次加n，第二次加n-1，一直加到1从而可以算出第n项的值。&lt;/p&gt;
&lt;p&gt; 使用递归的思想查找第n项的值，此时我们将三角数字看做是第一列和剩余所有列的和，如下图所示，可以写出triangle()方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201807/1424431-20180730150929225-1106894975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; triangle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.   return (n + sumAllColums(n-1))      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们可以发现sumAllColums方法做的事情和triangle做的事情一模一样&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (n + triangle(n-1))      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们可以将上面步骤换为此步骤，从而得到求三角数字的递归算法&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时上面的递归代码是不会终止的，所以我们的每一个递归代码要有一个我们称之为基值（base case）以防止无限递归导致程序崩溃，所以上面求三角函数代码的基值就是1，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; triangle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n==1&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求三角数字的基值&lt;/span&gt;
    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (n+triangle(n-1)) ;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行递归逻辑&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图表示了递归triangle方法的执行过程，假设传入n=5，从5开始每次减1，不断进入方法自身，直到减到1时，方法进行返回，直到返回到最外层。注意，在方法返回1之前，实际上同时有5个不同的triangle()方法实例存在，最外层传入的参数是5，最内层传入的参数是1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201807/1424431-20180730154445797-1828584781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上我们可以总结出递归方法的特征：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;调用自身&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用自身为了解决更小的问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;存在足够简单的层次，即上面说的基值&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;strong&gt;递归的效率&lt;/strong&gt;：递归的过程中控制必须从调用的位置转移到方法的开始处，除此之外这个方法的参数以及返回值会压入到一个内部栈中，从而知道访问的参数值和返回到哪里。所以递归效率较低，我们常常采用递归，是因为他从概念上简化了问题，而不是它更有效率。&lt;/p&gt;
&lt;h3&gt;II、归并排序&lt;/h3&gt;
&lt;p&gt;接下来我们讲讲与递归相关的排序算法，归并排序：&lt;/p&gt;
&lt;p&gt;　　首先这种排序在时间上更有效，时间复杂度为&lt;span&gt;&lt;strong&gt;O(N*logN)&lt;/strong&gt;&lt;/span&gt;，如果排序数据项N为10000，那么一般的简单排序N&lt;sup&gt;2&lt;/sup&gt;就是100000000，而N*logN只是40000，意思就是若使用归并排序需要40s，那么使用插入排序需要近28小时。归并排序的缺点是需要在存储器中有另一个大小等于被排序的数据项数目的数组，所以排序对数组的大小有一定的限制。&lt;/p&gt;
&lt;p&gt; 　　归并算法的核心是归并两个已经有序的数组，我们假设数组A有4个数据项，数组B有6个数据项，他们要被归并到C中，开始的时候C有10个空的存储空间。下表显示了归并进行的必要的比较，每一次比较将较小的数据项复制到数组C中，表中B数组在第八步之后是空的，所以不需要再进行比较，直接将A数组复制到C中去即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201807/1424431-20180731142306655-782589933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们给出归并的java代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] merge(&lt;span&gt;int&lt;/span&gt;[] arrayA,&lt;span&gt;int&lt;/span&gt; sizeA,&lt;span&gt;int&lt;/span&gt;[] arrayB,&lt;span&gt;int&lt;/span&gt; sizeB,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arrayC){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aDex=0,bDex=0,cDex=0;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录三个数组当前的脚标&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(aDex&amp;lt;sizeA&amp;amp;&amp;amp;bDex&amp;lt;sizeB){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时还需进行比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(arrayA[aDex] &amp;lt;&lt;span&gt; arrayB[bdex])
            arrayC[cDex&lt;/span&gt;++] = arrayA[aDex++&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            arrayC[cDex&lt;/span&gt;++] = arrayA[bDex++&lt;span&gt;];
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(aDex&amp;lt;sizeA) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明数组a中还有剩余数据，拷贝到数组c&lt;/span&gt;
          arrayC[cDex++] = arrayA[aDex++&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(bDex&amp;lt;sizeB) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明数组b中还有剩余数据，拷贝到数组c&lt;/span&gt;
          arrayC[cDex++] = arrayB[bDex++&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;   arrayC;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;归并排序&lt;/strong&gt;&lt;/span&gt;简单来讲就是反复地将数组进行分割，利用递归的思想，直到子数组只含有一个数据项（基值），在归并排序方法中每一次调用自身的时候排列都会被分成两部分，并且每一次返回时都会把两个较小的排列合并成一个更大的排列，接下来我们给出归并排序的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DArray {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[] theArray;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储数据的数组&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nElems;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充数据个数索引&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; DArray(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max) {
        theArray &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[max];
        nElems &lt;/span&gt;= 0&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*插入数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; value){
        theArray[nElems&lt;/span&gt;++] =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*归并排序的方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; mergeSort() {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;[] workSpace = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[nElems];
        recMergeSort(workSpace, &lt;/span&gt;0, nElems - 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 利用递归进行归并排序
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; workSpace     工作区
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lowerBound    归并区域的起始索引
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; upperBound    归并区域的结束索引
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; recMergeSort(&lt;span&gt;long&lt;/span&gt;[] workSpace, &lt;span&gt;int&lt;/span&gt; lowerBound, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; upperBound) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lowerBound ==&lt;span&gt; upperBound) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到中间分界点&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; mid = (lowerBound + upperBound) / 2&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先递归调用自己将前半部分的数据归并为有序&lt;/span&gt;
&lt;span&gt;            recMergeSort(workSpace, lowerBound, mid);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后递归调用自己将后半部分的数据归并为有序&lt;/span&gt;
            recMergeSort(workSpace, mid + 1&lt;span&gt;, upperBound);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用归并算法将上面归并有序后的数据进行归并&lt;/span&gt;
            merge(workSpace, lowerBound, mid + 1&lt;span&gt;, upperBound);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 归并算法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; workSpace  工作区
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; lowPtr     首段归并区域的初始索引
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; highPtr    末端归并区域的初始索引
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; upperBound 末端归并区域的结束索引
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;long&lt;/span&gt;[] workSpace, &lt;span&gt;int&lt;/span&gt; lowPtr, &lt;span&gt;int&lt;/span&gt; highPtr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; upperBound) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 0;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作区的index&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lowerBound = lowPtr;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首段归并区域的初始索引（复制到theArray的初始索引）&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; mid = highPtr - 1;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应索引较小区域的结束位置索引&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; n = upperBound - lowerBound + 1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;归并的此段区域所含有的数据项的个数

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对应范围lowPtr到upperBound的数据复制到工作区&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (lowPtr &amp;lt;= mid &amp;amp;&amp;amp; highPtr &amp;lt;=&lt;span&gt; upperBound) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (theArray[lowPtr] &amp;lt;&lt;span&gt; theArray[highPtr]) {
                workSpace[j&lt;/span&gt;++] = theArray[lowPtr++&lt;span&gt;];
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                workSpace[j&lt;/span&gt;++] = theArray[highPtr++&lt;span&gt;];
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对应还未复制完的数据复制到工作区中&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (lowPtr &amp;lt;=&lt;span&gt; mid) {
            workSpace[j&lt;/span&gt;++] = theArray[lowPtr++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (highPtr &amp;lt;=&lt;span&gt; upperBound) {
            workSpace[j&lt;/span&gt;++] = theArray[highPtr++&lt;span&gt;];
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此步骤相当于是将对象内的theArray数组变成lowPtr到upperBound局部有序，将归并到工作区的数据放入theArray的对应位置&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (j = 0; j &amp;lt; n; j++&lt;span&gt;) {
            theArray[lowerBound &lt;/span&gt;+ j] =&lt;span&gt; workSpace[j];
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;归并的效率&lt;/strong&gt;&lt;/span&gt;：（假设复制和比较是最耗时的操作）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201808/1424431-20180801101018931-91097490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制次数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上表中可以看出来当N为2的乘方的时候的操作次数，我们可以这样来理解需要的复制次数，log&lt;sub&gt;2&lt;/sub&gt;N表示将N对半分解为我们归并的基值1的时候需要的步数，然后每一步我们都需要将N个数据项复制到我们的工作区，所以复制到工作区的次数就应该是&lt;strong&gt;&lt;span&gt;N*log&lt;sub&gt;2&lt;/sub&gt;N&lt;/span&gt;&lt;/strong&gt;，这些数据复制到工作区之后还需要复制到原数组中所以复制次数会增加一倍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较次数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424431/201808/1424431-20180801150146539-819476272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中我们可以前面表示进行归并的时候进行的最多和最少的比较次数，后表列举出了包含8个数据项进行归并排序的比较次数，对于八个数据项需要七次归并的操作，对于每一次归并最大比较次数是数据项减1，最小比较次数是数据项的一半，加在一起可算出归并排序需要的比较次数在12到17之间。&lt;/p&gt;
&lt;p&gt;至此关于递归的思想，和关于递归的归并排序就结束了。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 07:23:00 +0000</pubDate>
<dc:creator>Coope</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoukebo/p/9353293.html</dc:identifier>
</item>
<item>
<title>如何自学人工智能路径规划（附资源，百分百亲身经验） - 经济与编程</title>
<link>http://www.cnblogs.com/learningthem/p/9401418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learningthem/p/9401418.html</guid>
<description>
&lt;p&gt;下面的每个资源都是我亲身学过的，且是网上公开公认最优质的资源。&lt;/p&gt;
&lt;p&gt;下面的每个学习步骤也是我一步步走过来的。希望大家以我为参考，少走弯路。&lt;/p&gt;
&lt;p&gt;请大家不要浪费时间找非常多的资料，只看最精华的！&lt;/p&gt;

&lt;p&gt;综述，机器学习的自学简单来说分为三个步骤&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前期：知识储备包括数学知识，机器学习经典算法知识，编程技术（&lt;/span&gt;python）的掌握&lt;/p&gt;
&lt;p&gt;中期：算法的代码实现&lt;/p&gt;
&lt;p&gt;后期：实战水平提升&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器学习路径规划图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1447771/201808/1447771-20180801151350601-342590367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、数学基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人看到数学知识的时候就望而却步，数学是需要的，但是作为入门水平，对数学的要求没有那么的高。假设你上过大学的数学课（忘了也没事），需要的数学知识啃一啃还是基本能理解下来的。&lt;/p&gt;
&lt;p&gt;1.1、数学内容&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性代数：矩阵&lt;/span&gt;/张量乘法、求逆，奇异值分解/特征值分解，行列式，范数等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统计与概率：概率分布，独立性与贝叶斯，最大似然&lt;/span&gt;(MLE)和最大后验估计(MAP)等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优化：线性优化，非线性优化&lt;/span&gt;(凸优化/非凸优化)以及其衍生的如梯度下降、牛顿法等&lt;/p&gt;
&lt;p&gt;微积分：偏微分，链式法则，矩阵求导等&lt;/p&gt;
&lt;p&gt;信息论、数值理论等&lt;/p&gt;
&lt;p&gt;上面的看不太懂没事，不是特别难，学习一下就能理解了。&lt;/p&gt;
&lt;p&gt;1.2、数学资源&lt;/p&gt;
&lt;p&gt;网上有很多人会列举大量大量的课程资源，这是非常不负责任的事，学完那些我头发都得白了。实际上，我们只需要学习其中的一部分就够了。&lt;/p&gt;
&lt;p&gt;1.2.1、吴恩达的斯坦福大学机器学习王牌课程CS229，课后就有对学生数学知识的要求和补充，这些数学知识是完全符合机器学习要求的，不多也不少。墙裂推荐要看，不过只有英文版的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;https://pan.baidu.com/s/1NrCAW38C9lXFqPwqTlrVRA 密码：3k3m&lt;/p&gt;
&lt;p&gt;1.2.2、深度学习的三大开山鼻祖之一Yoshua Bengio写的深度学习（包含了机器学习）领域的教科书，现在以开源的形式在网上公开。这部书被誉为深度学习的圣经。在这里我们只看这本书的第一部分，也就是数学基础。囊括了机器学习所需的所有必备数学基础，而且是从最基础的说起，也不多，必读的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;https://pan.baidu.com/s/1GmmbqFewyCuEA7blXNC-7g 密码：6qqm&lt;/p&gt;
&lt;p&gt;1.2.3、跟机器学习算法相结合的数学知识。上面两部分是理论层面的数学，机器学习算法中会对这些数学进行应用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;https://zhuanlan.zhihu.com/p/25197792，知乎专栏上的一篇好文章，囊括了所有的应用知识点。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;好了，数学方面我只推荐上面三个资源，三个都是必看的。里面很多可能你现在看不太懂，没关系。先大概过一遍，知道自己的数学水平在哪。在看到算法知识的时候，不懂的再回来补就好。后期需要更多的数学资料我会再更新的。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;二、&lt;strong&gt;编程技术&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;编程语言：&lt;/span&gt;python3.5及以上，python易学，这个这期先不细讲。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;三、经典算法知识&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;算法包括机器学习和深度学习，机器学习是深度学习的基础。所以务必先学机器学习的经典算法，再学深度学习的算法。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.1、机器学习&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.1.1、课程资料&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;首推吴恩达的&lt;/span&gt;CS229，经典中的经典，在网易公开课里有视频，翻译，课程讲义，笔记是非常非常完备的。墙裂推荐。这个课程对数学有一定的要求，但&lt;span&gt;我觉得只要你上过大学的数学，然后补一下上面的数学，完全可以直接来看这个&lt;/span&gt;CS229。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;假设你的数学真的很差的话，怎么办？&lt;span&gt;吴恩达在&lt;/span&gt;coursera上也开了一门跟CS229完全匹配的课程，coursera机器学习课&lt;span&gt;。&lt;/span&gt;&lt;span&gt;这门课是&lt;/span&gt;CS229的翻版，唯一不同的是它对数学基本是没有要求了，如果你对数学真的不懂的话，那就先看这个的教程吧。它跟CS229的关系就是同样的广度，但是深度&lt;span&gt;浅很多&lt;/span&gt;&lt;span&gt;，不过你学完&lt;/span&gt;coursera还是要回过头来看CS229的。这个也是免费的。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;CS229课程视频：http://open.163.com/special/opencourse/machinelearning.html&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;课程讲义和中文笔记：&lt;/span&gt;https://pan.baidu.com/s/1MC_yWjcz_m5YoZFNBcsRSQ 密码：6rw6&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.1.2、&lt;span&gt;配套书籍：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;机器学习实战，&lt;/span&gt;&lt;span&gt;必看。&lt;/span&gt;&lt;span&gt;用代码实现了一遍各大经典机器学习算法，必须看，对你理解算法有很大帮助，同时里面也有应用。&lt;/span&gt;&lt;span&gt;如果大家看上面纯理论的部分太枯燥了，就可以来看看这本书来知道在现实中机器学习算法是怎么应用的，会很大程度提升你的学习兴趣&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;当初我可是看了好几遍。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;书籍及课后代码：链接：&lt;/span&gt;https://pan.baidu.com/s/15XtFOH18si316076GLKYfg 密码：sawb&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;李航《统计学习方法》&lt;/span&gt;&lt;span&gt;，配合着看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;https://pan.baidu.com/s/1Mk_O71k-H8GHeaivWbzM-Q 密码：adep&lt;span&gt;，配合着看&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;周志华《机器学习》，机器学习的百科全书&lt;/span&gt;&lt;span&gt;，配合着看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;/span&gt;https://pan.baidu.com/s/1lJoQnWToonvBU6cYwjrRKg 密码：7rzl&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.2、深度学习&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;说到深度学习，我们不得不提斯坦福的另一门王牌课程&lt;/span&gt;CS231，李飞飞教授的。这门课的课程，课后习题，堪称完美。必须必须看。整个系列下来，特别是课后的习题要做，做完之后你会发现，哇哦！它的课后习题就是写代码来实现算法的。这个在网易云&lt;span&gt;课堂&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;有&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;视频地址：&lt;/span&gt;&lt;a href=&quot;http://study.163.com/course/introduction.htm?courseId=1004697005&quot;&gt;&lt;span&gt;http://study.163.com/course/introduction.htm?courseId=1004697005&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;课程笔记翻译，知乎专栏：&lt;/span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21930884&quot;&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/21930884&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;墙裂建议要阅读这个知乎专栏，关于怎么学这门课，这个专栏写的很清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;课后作业配套答案：&lt;/span&gt;https://blog.csdn.net/bigdatadigest/article/category/7425092&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.3、学习时间&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;到这里了，你的机器学习和深度学习算是入门了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;学完上面这些，按一天&lt;/span&gt;6小时，一周六天的话，起码也得三个月吧。上面是基本功一定要认真学。但是，还找不了工作。因为你还没把这些知识应用到实际当中。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.4、实战部分&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.4.1、实战基础&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这一个阶段，你要开始用&lt;/span&gt;tensorflow（谷歌的深度学习框架）、scikit-learn（python的机器学习框架），这两个框架极大程度地集成了各大算法。&lt;span&gt;其实上面在学习&lt;/span&gt;cs231n的时候你就会用到一部分。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;scikit-learn的学习：&lt;a href=&quot;http://sklearn.apachecn.org/cn/0.19.0/%EF%BC%8C%E8%BF%99%E6%98%AFscikit-learn%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%89%88%E7%BF%BB%E8%AF%91%EF%BC%8C%E6%9C%89%E7%90%86%E8%AE%BA%E6%9C%89%E5%AE%9E%E6%88%98%EF%BC%8C%E6%9C%80%E5%A5%BD%E7%9A%84%E5%BA%93%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80&quot;&gt;&lt;span&gt;http://sklearn.apachecn.org/cn/0.19.0/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这是&lt;/span&gt;scikit-learn的官方文档中文版翻译，有理论有实战，最好的库学习资源，没有之一&lt;span&gt;。认真看，传统的机器学习就是用这个库来实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Tensorflow的学习：&lt;a href=&quot;https://tensorflow.google.cn/api_docs/python/?hl=zh-cn%EF%BC%8C%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%BE%88%E8%AF%A6%E5%B0%BD%EF%BC%8C%E8%BF%98%E6%9C%89%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%AD%A6%E4%B9%A0tensorflow%E7%9A%84%E4%B8%8D%E4%BA%8C%E4%B9%8B%E9%80%89&quot;&gt;&lt;span&gt;https://tensorflow.google.cn/api_docs/python/?hl=zh-cn&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;官方文档很详尽，还有实战例子，学习&lt;/span&gt;tensorflow的不二之选&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.4.2、&lt;span&gt;实战进阶&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;仅仅看这两个教程是不够的，你需要更多地去应用这两个库&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;接下来推荐一部神书，机器学习和深度学习的实战教学，非常非常的棒，网上有很多号称实战的书或者例子，我看了基本就是照搬官网的，只有这一本书，是完全按照工业界的流程解决方案进行实战，你不仅能学习到库的应用，还能深入了解工业界的流程解决方案，最好的实战教学书，没有之一。&lt;/span&gt;&lt;span&gt;书名是&lt;/span&gt;hands-on-ml-with-sklearn-and-tf&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;链接：&lt;/span&gt;https://pan.baidu.com/s/1x318qTHGt9oZKQwHkoUvKA 密码：xssj&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.4.3、实战最终阶段&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;kaggle数据竞赛，如果你已经学到了这一步，恭喜你离梦想越来越近了：&lt;span&gt;对于我们初学者来说，没有机会接触到机器学习真正的应用项目，所以一些比赛平台是我们不错的选择。&lt;/span&gt;&lt;span&gt;参加&lt;/span&gt;kaggle竞赛可以给你的简历增分不少，里面有入门级别到专家级别的实战案例，满足你的各方面需求。&lt;span&gt;如果你能学到这一步了，我相信也不需要再看这个了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;上述所有资料的合集：&lt;/span&gt;https://pan.baidu.com/s/1tPqsSmSMZa6qLyD0ng87IQ 密码：ve75&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;学到这个水平，应该是能够实习的水平了，还有很多后面再说吧。比如深度学习和机器学习的就业方向，深度学习得看论文，找工作还得对你得编程基础进行加强，具体就是数据结构与算法，我当年在这个上面可是吃了很大的亏。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;这里面关于深度学习和机器学习的就业其实是两个方向，上面的其实也没有说全。一般来说，你得选择一个方向专攻。我建议的是，自学的最好在后期侧重机器学习方向，而不是深度学习。深度学习的岗位实在是太少，要求太高。机器学习还算稍微好点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;重点：上面的学习路径是主要框架，但是不意味着仅仅学习这些就够了。根据每个人基础的不同，你有可能需要另外的学习资料补充。但是，我希望大家可以按照上面的主框架走，先按上面我推荐的资源学，有需要的再去看别的（我之后也会推荐），上面的我能列出来的都是最经典的，最有效率，而且我亲身学过的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;后续&lt;/span&gt;&lt;span&gt;文章：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;上面每个学习步骤还可以细分开来，这是接下来文章的重点。比如&lt;/span&gt;python怎么学，cs229和cs231学习过程中会碰到什么困难，kaggle怎么用，数学还跟不上怎么办？后续都会一一说明。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;欢迎转载，但请注明出处，尊重作者，谢谢大家了！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;欢迎讨论交流，微信公众号：learningthem&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 07:16:00 +0000</pubDate>
<dc:creator>经济与编程</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learningthem/p/9401418.html</dc:identifier>
</item>
<item>
<title>cocos 场景制作流程 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9392490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9392490.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍 cocos 场景制作流程&lt;/p&gt;

&lt;h3&gt;节点和组件&lt;/h3&gt;
&lt;p&gt;　　Cocos Creator 的工作流程是以组件式开发为核心的，组件式架构也称作组件-实体系统，简单的说，就是以组合而非继承的方式进行实体的构建&lt;/p&gt;
&lt;p&gt;　　在 Cocos Creator 中，节点（Node）是承载组件的实体，通过将具有各种功能的组件（Component）挂载到节点上，来让节点具有各式各样的表现和功能&lt;/p&gt;
&lt;p&gt;　　要最快速的获得一个具有特定功能的节点，可以通过层级管理器左上角的创建节点按钮&lt;/p&gt;
&lt;p&gt;　　以创建一个最简单的 Sprite（精灵）节点为例，点击创建节点按钮后选择&lt;code&gt;创建渲染节点/Sprite（精灵）&lt;/code&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201807/740839-20180730193119379-1548222399.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　之后就可以在场景编辑器和层级管理器中看到新添加的 Sprite 节点了。新节点命名为 &lt;code&gt;New Sprite&lt;/code&gt;，表示这是一个主要由 Sprite 组件负责提供功能的节点&lt;/p&gt;
&lt;p&gt;　　选中刚才创建的 &lt;code&gt;New Sprite&lt;/code&gt; 节点，可以看到属性检查器中的显示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801102306415-1715960844.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　属性检查器中以 &lt;code&gt;Node&lt;/code&gt; 标题开始的部分就是节点的属性，节点属性包括了节点的位置、旋转、缩放、尺寸等变换信息和锚点、颜色、不透明度等其他信息&lt;/p&gt;
&lt;p&gt;　　接下来以 &lt;code&gt;Sprite&lt;/code&gt; 标题开始的部分就是 Sprite 组件的属性，在 2D 游戏中，Sprite 组件负责游戏中绝大部分图像的渲染。Sprite 组件最主要的属性就是 &lt;code&gt;Sprite Frame&lt;/code&gt;，可以在这个属性指定 Sprite 在游戏中渲染的图像文件&lt;/p&gt;
&lt;p&gt;　　下面从资源管理器中拖拽任意一张图片资源到属性检查器的 &lt;code&gt;Sprite Frame&lt;/code&gt; 属性中&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801102849041-1819092855.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　刚才的默认 Sprite 图片变成了指定的图片，这就是 Sprite 组件的作用：渲染图片&lt;/p&gt;
&lt;p&gt;　　组件式的结构是以组合方式来实现功能的扩展的，下图中就展示了节点和 Sprite 组件的组合&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801104040668-322351993.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　节点的颜色（Color）属性和不透明度（Opacity）属性直接影响了 Sprite 组件对图片的渲染。颜色和不透明度同样会影响文字（Label）这样的渲染组件的显示。 这两个属性会和渲染组件本身的渲染内容进行相乘，来决定每个像素渲染时的颜色和不透明度。此外不透明度（Opacity）属性还会作用于子节点，可以通过修改父节点的 Opacity 轻松实现一组节点内容的淡入淡出效果&lt;/p&gt;
&lt;p&gt;　　值得注意的是，一个节点上只能添加一个渲染组件，渲染组件包括 Sprite（精灵）， Label（文字），Particle（粒子）等&lt;/p&gt;

&lt;h3&gt;坐标系&lt;/h3&gt;
&lt;p&gt;　　在 iOS, Android, Windows Phone 等平台用原生 SDK 开发应用时使用的是标准屏幕坐标系，原点为屏幕左上角，x 向右，y 向下。&lt;/p&gt;
&lt;p&gt;　　Cocos2d-x 坐标系和 OpenGL 坐标系一样，原点为屏幕左下角，x 向右，y 向上&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801105407070-576707523.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　世界坐标系也叫做绝对坐标系，在 Cocos Creator 游戏开发中表示场景空间内的统一坐标体系，「世界」就用来表示游戏场景&lt;/p&gt;
&lt;p&gt;　　本地坐标系也叫相对坐标系，是和节点相关联的坐标系。每个节点都有独立的坐标系，当节点移动或改变方向时，和该节点关联的坐标系将随之移动或改变方向&lt;/p&gt;
&lt;p&gt;　　Cocos Creator 中的节点（Node）之间可以有父子关系的层级结构，修改节点的位置（Position）属性设定的节点位置是该节点相对于父节点的本地坐标系而非世界坐标系。最后在绘制整个场景时 Cocos Creator 会把这些节点的本地坐标映射成世界坐标系坐标&lt;/p&gt;
&lt;p&gt;　　锚点（Anchor）决定了节点以自身约束框中的哪一个点作为整个节点的位置。选中节点后看到变换工具出现的位置就是节点的锚点位置&lt;/p&gt;
&lt;p&gt;　　锚点由 &lt;code&gt;anchorX&lt;/code&gt; 和 &lt;code&gt;anchorY&lt;/code&gt; 两个值表示，他们是通过节点尺寸计算锚点位置的乘数因子，范围都是 &lt;code&gt;0 ~ 1&lt;/code&gt; 之间。&lt;code&gt;(0.5, 0.5)&lt;/code&gt; 表示锚点位于节点长度乘 0.5 和宽度乘 0.5 的地方，即节点的中心。锚点属性设为 &lt;code&gt;(0, 0)&lt;/code&gt; 时，锚点位于节点本地坐标系的初始原点位置，也就是节点约束框的左下角。锚点位置确定后，所有子节点就会以锚点所在位置作为坐标系原点&lt;/p&gt;
&lt;p&gt;　　节点包括四个主要的变换属性&lt;/p&gt;
&lt;p&gt;　　1、位置(position)&lt;/p&gt;
&lt;p&gt;　　位置（Position） 由 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 两个属性组成，分别规定了节点在当前坐标系 x 轴和 y 轴上的坐标。&lt;/p&gt;
&lt;p&gt;　　2、旋转(rotation)&lt;/p&gt;
&lt;p&gt;　　旋转属性只有一个值，表示节点当前的旋转角度。角度值为正时，节点顺时针旋转，角度值为负时，节点逆时针旋转&lt;/p&gt;
&lt;p&gt; 　　3、缩放(scale)&lt;/p&gt;
&lt;p&gt;　　缩放属性也是一组乘数因子，由 &lt;code&gt;scaleX&lt;/code&gt; 和 &lt;code&gt;scaleY&lt;/code&gt; 两个值组成，分别表示节点在 x 轴和 y 轴的缩放倍率&lt;/p&gt;
&lt;p&gt;　　4、尺寸(size)&lt;/p&gt;
&lt;p&gt;　　尺寸属性由 &lt;code&gt;Width&lt;/code&gt;（宽度）和 &lt;code&gt;Height&lt;/code&gt; （高度）两个值组成，用来规定节点的约束框大小。对于 Sprite 节点来说，约束框的大小也就相当于显示图像的大小&lt;/p&gt;

&lt;h3&gt;节点层级&lt;/h3&gt;
&lt;p&gt;　　当场景中的元素越来越多时，需要通过节点层级来将节点按照逻辑功能归类，并按需要排列显示顺序&lt;/p&gt;
&lt;p&gt;　　每个视觉元素都是一个节点，通常不会把所有节点平铺在场景上，而是会按照一定的分类和次序组织成如下图所示的节点树&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801115425782-1149811658.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　节点树中由箭头连接的两个节点之间就是父子关系，把显示在上面的叫做父节点，下面的叫子节点。在层级管理器中，上面的节点树就会是这个样子&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801115634582-1803159880.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在游戏中经常需要控制复杂的玩家角色，这种角色通常不会只由单个节点组成，下面来看看下面这张图里的英雄角色，就由三个不同的部分组成&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801141011102-213762198.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　将英雄角色的 Sprite 图像显示和帧动画组件放在 &lt;code&gt;body&lt;/code&gt; 节点上，然后需要跟随角色移动的阴影 Sprite 单独拿出来作为 &lt;code&gt;shadow&lt;/code&gt; 节点。最后把负责生命值显示的进度条作为一组独立功能的节点，形成自己的迷你节点树 &lt;code&gt;HPBar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　上面的例子就是典型的根据逻辑需要来组织节点关系，可以根据游戏逻辑操作英雄角色节点的动画播放、左右翻转；根据角色当前血量访问 &lt;code&gt;HPBar&lt;/code&gt; 节点来更新生命值显示；最后他们共同的父节点 &lt;code&gt;player&lt;/code&gt;用于控制角色的移动，并且可以作为一个整体被添加到其他场景节点中&lt;/p&gt;
&lt;p&gt;　　在层级管理器中会按照节点排列顺序依次渲染，也就是显示在列表上面的节点会被下面的节点遮盖住。&lt;code&gt;body&lt;/code&gt; 节点在列表里出现在下面，因此实际渲染时会挡住 &lt;code&gt;shadow&lt;/code&gt; 节点&lt;/p&gt;
&lt;p&gt;　　父节点永远是出现在子节点上面的，因此子节点永远都会遮盖住父节点&lt;/p&gt;
&lt;p&gt;　　虽然父节点可以用来组织逻辑关系甚至是当做承载子节点的容器，但节点数量过多时，场景加载速度会受影响，因此在制作场景时应该避免出现大量无意义的节点，应该尽可能合并相同功能的节点&lt;/p&gt;

&lt;h3&gt;场景编辑器&lt;/h3&gt;
&lt;p&gt;　　Canvas 节点是推荐使用的渲染根节点，将所有渲染相关的节点都放在 Canvas 下面，这样做有以下两点好处：&lt;/p&gt;
&lt;p&gt;　　1、Canvas 能提供多分辨率自适应的缩放功能，以 Canvas 作为渲染根节点能够保证制作的场景在更大或更小的屏幕上都保持较好的图像效果&lt;/p&gt;
&lt;p&gt;　　2、Canvas 的默认锚点位置是 &lt;code&gt;(0.5, 0.5)&lt;/code&gt;，加上 Canvas 节点会根据屏幕大小自动居中显示，所以 Canvas 下的节点会以屏幕中心作为坐标系的原点&lt;/p&gt;
&lt;p&gt;　　除了有具体图像渲染任务的节点之外，还会有一部分节点只负责挂载脚本，执行逻辑，不包含任何渲染相关内容。通常将这些节点放置在场景根层级，和 Canvas 节点并列，如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/740839/201808/740839-20180801145004812-789148065.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　除了 Canvas 下的背景、菜单、玩家角色等节点之外，还将包含有游戏主逻辑组件的 &lt;code&gt;Game&lt;/code&gt;节点放在了和 Canvas 平行的位置上，方便协作的时候其他开发者能够第一时间找到游戏逻辑和进行相关的数据绑定&lt;/p&gt;
&lt;p&gt;　　为场景添加内容时，一般会先从层级管理器的创建节点菜单开始，也就是点击左上角的 &lt;code&gt;+&lt;/code&gt; 按钮弹出的菜单。这个菜单的内容和主菜单中&lt;code&gt;节点&lt;/code&gt;菜单里的内容一致，都可以从几个简单的节点分类中选择需要的基础节点类型并添加到场景中。添加节点时，在层级管理器中选中的节点将成为新建节点的父节点&lt;/p&gt;
&lt;p&gt;　　1、空节点&lt;/p&gt;
&lt;p&gt;　　选择创建节点菜单里的&lt;code&gt;创建空节点&lt;/code&gt;就能够创建一个不包含任何组件的节点。空节点可以作为组织其他节点的容器，也可以用来挂载用户编写的逻辑和控制组件&lt;/p&gt;
&lt;p&gt;　　2、渲染节点&lt;/p&gt;
&lt;p&gt;　　创建节点菜单里下一个类别是&lt;code&gt;创建渲染节点&lt;/code&gt;，这里能找到像 Sprite（精灵）、Label（文字）、ParticleSystem（粒子）、Tilemap（瓦片图）等由节点和基础渲染组件组成的节点类型&lt;/p&gt;
&lt;p&gt;　　这里的基础渲染组件，是无法用其他组件的组合来代替的，因此单独归为渲染类别。要注意每个节点上只能添加一个渲染组件，重复添加会导致报错。但是可以通过将不同渲染节点组合起来的方式实现更复杂的界面控件，比如下面 UI 类中的很多控件节点&lt;/p&gt;
&lt;p&gt;　　3、UI节点&lt;/p&gt;
&lt;p&gt;　　从创建节点菜单中的&lt;code&gt;创建 UI 节点&lt;/code&gt;类别里可以创建包括 Button（按钮）、Widget（对齐挂件）、Layout（布局）、ScrollView（滚动视图）、EditBox（输入框）等节点在内的常用 UI 控件。UI 节点大部分都是由渲染节点组合而成的，比如通过菜单创建的 Button 节点，就包含了一个包含 Button + Sprite 组件的按钮背景节点，加上一个包含 Label 组件的标签节点&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 07:09:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9392490.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz day08——实现内核 (中) 扩展内核 - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/antz08.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz08.html</guid>
<description>&lt;p&gt;　&lt;span&gt;　在前几天的任务中，我们已经简单实现了MBR，直接操作显示器和硬盘操作来加载其他扇区的程序，如今已经可以进入保护模式了，并且编写了我们自己的内核程序，这个内核虽然什么也没有做，但还是成功被加载进内存了。接下来我们要将这个内核程序编写详细的内容了。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SELECTOR_KERNEL_CS    equ    &lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;extern    cstart
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;extern    gdt_ptr
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;[SECTION .bss]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; StackSpace        resb    &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;StackTop:&lt;/span&gt;        
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;[section .text]    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;global _start    
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;_start:&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    esp, StackTop
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;sgdt&lt;/span&gt;&lt;span&gt;    [gdt_ptr]    
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    cstart    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;lgdt&lt;/span&gt;&lt;span&gt;    [gdt_ptr]    
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;    &lt;span&gt;SELECTOR_KERNEL_CS:&lt;/span&gt;&lt;span&gt;csinit
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;csinit:&lt;/span&gt;        
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;hlt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这四行代码就可以完成切换堆栈和更换GDT任务了。StackTop定义在.bss段中，大小为2KB，操作GDT时用到了gdt_ptr和cstart分别时一个全局变量和全局函数，定义在c代码start.c中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;const.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;protect.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

PUBLIC    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;*    memcpy(&lt;span&gt;void&lt;/span&gt;* pDst, &lt;span&gt;void&lt;/span&gt;* pSrc, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; iSize);
PUBLIC &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;    disp_str(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt; pszInfo);

PUBLIC    t_8            gdt_ptr[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];     
PUBLIC    DESCRIPTOR        gdt[GDT_SIZE];
 
PUBLIC &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cstart()
{
    disp_str(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-----\&quot;cstart\&quot; begins-----\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    memcpy(    &lt;/span&gt;&amp;amp;&lt;span&gt;gdt,                    
        (&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;*)(*((t_32*)(&amp;amp;gdt_ptr[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]))),   
        &lt;/span&gt;*((t_16*)(&amp;amp;gdt_ptr[&lt;span&gt;0&lt;/span&gt;])) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;        
        );

    t_16&lt;/span&gt;* p_gdt_limit = (t_16*)(&amp;amp;gdt_ptr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    t_32&lt;/span&gt;* p_gdt_base  = (t_32*)(&amp;amp;gdt_ptr[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;*p_gdt_limit = GDT_SIZE * &lt;span&gt;sizeof&lt;/span&gt;(DESCRIPTOR) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;*p_gdt_base  = (t_32)&amp;amp;&lt;span&gt;gdt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　cstart()首先把位于Loader中的原GDT全部复制给新的GDT，然后把gdt_ptr中的内容换为新的GDT的基地址和界限。复制GDT用的是memepy，至于它的函数定义就不详细写了，这个是c中非常出名的一个函数了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然还有一些类型，结构体和宏，这些可以放置在.h的头文件中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　protect.h :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef    _TINIX_PROTECT_H_
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    _TINIX_PROTECT_H_
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt; s_descriptor        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 共 8 个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    t_16    limit_low;         
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    t_16    base_low; 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    t_8    base_mid;     
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    t_8    attr1;         
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    t_8    limit_high_attr2; 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    t_8    base_high;         
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}DESCRIPTOR;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　type.h :&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef    _TINIX_TYPE_H_
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    _TINIX_TYPE_H_
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; typedef    unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;        t_32;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; typedef    unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;        t_16;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; typedef    unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;        t_8;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; typedef    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;            t_bool;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　const.h :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef    _TINIX_CONST_H_
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    _TINIX_CONST_H_
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    PUBLIC     
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    PRIVATE    static    
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;    GDT_SIZE    128
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来在linux下编译链接。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　nasm -f elf -o kernel.o kernel.asm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　nasm -f elf -o string.o string.asm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　gcc -c -o start.o start.c&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ld -s  -Ttext 0x30400 -o kernel.bin kernel.o string.o start.o&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将bin使用工具写入(day01或者dd) ，打开查看结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201808/1291955-20180801142712637-693576291.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到cstart成功切换了堆栈与GDT。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　随着代码量的增多，编译链接的命令也越来越多了，你可能之前没有接触过Makefile，但这是一个非常高效的东西，值得学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Makefile 是和 make 命令一起配合使用的，&lt;/span&gt;&lt;span&gt;很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂，&lt;/span&gt;&lt;span&gt;Makefile的组织流程的能力如此之强, 不仅可以用来编译项目, 还可以用来组织我们平时的一些日常操作. 这个需要大家发挥自己的想象力.。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Makefile基本语法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;target ... : prerequisites ...
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    command
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     ...
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;target ... : prerequisites ; command
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    command
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　prerequisites就是要生成那个target所需要的文件或是目标。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　command也就是make需要执行的命令。（任意的Shell命令）&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　来举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # Makefile &lt;span&gt;for&lt;/span&gt;&lt;span&gt; boot
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# Programs, flags, etc.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; ASM        =&lt;span&gt; nasm
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ASMFLAGS    = 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;# This Program
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; TARGET        =&lt;span&gt; boot.bin loader.bin
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;# All Phony Targets
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;.PHONY : everything clean all
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# Default starting position
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;everything : $(TARGET)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;clean :
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     rm -&lt;span&gt;f $(TARGET)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;all : clean everything
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; boot.bin : boot.asm ./include/load.inc ./include/&lt;span&gt;fat12hdr.inc
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     $(ASM) $(ASMFLAGS) -o $@ $&amp;lt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; loader.bin : loader.asm ./include/load.inc ./include/fat12hdr.inc ./include/&lt;span&gt;pm.inc
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     $(ASM) $(ASMFLAGS) -o $@ $&amp;lt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　#是注释的意思， =用来定义变量 ， ASM和ASMFLAGS就是两个变量，使用变量要用$(ASM)和$(ASMFLAGS) 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于 target :  prerequistites &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　command &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　意思就是想要得到target就需要指向命令command。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　target依赖于prerequistites，当prerequistites中至少有一个文件比target文件新时，command才会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看看最后两行，要想得到loader.bin就需要执行命令：&lt;/span&gt;&lt;span&gt;$(ASM) $(ASMFLAGS) -o $@ $&amp;lt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　loader.bin依赖于loader.asm load.inc fat12hdr.inc pm.inc ，这些中只要有一个比target新，command就会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么这里的command是什么意思呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $(ASM) $(ASMFLAGS) -o $@ $&amp;lt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　$@  $&amp;lt; 其实就是target，prerequistites的第一个名字，所以这个命令等价于&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; nasm -o loader.bin loader.asm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　此外你可能还发现了在外的大标签，他们是动作名称，如everything,all,clean，它们用于make后面，比如make all ,make clean，然后就会执行相应的当作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于Makefile我们目前只需要知道这些就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于Antz内核的编写将会暂时停止几天，最近准备看看Linux内核的相关知识。同步会更新在&lt;a title=&quot;https://www.cnblogs.com/LexMoon/category/1267413.html&quot; href=&quot;https://www.cnblogs.com/LexMoon/category/1267413.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/LexMoon/category/1267413.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 06:56:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz08.html</dc:identifier>
</item>
<item>
<title>Java 验证码识别库 Tess4j 学习 - _TBHacker</title>
<link>http://www.cnblogs.com/zengbojia/p/9401047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengbojia/p/9401047.html</guid>
<description>
&lt;p&gt;&lt;span&gt;【在用&lt;/span&gt;java&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Jsoup&lt;/span&gt;&lt;span&gt;做爬虫爬取数据时遇到了验证码识别的问题（基于&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;），找了网上挺多的资料，发现&lt;/span&gt;&lt;span&gt;Tess4j&lt;/span&gt;&lt;span&gt;可以自动识别验证码，在这里简单记录下学习过程及遇到的一些问题。】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;步骤：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;把&lt;/span&gt;tessreact项目里面的tessdata文件夹提取出来放在某个位置：&lt;a href=&quot;https://github.com/tesseract-ocr/tesseract&quot;&gt;&lt;span&gt;https://github.com/tesseract-ocr/tesseract&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要在步骤一的&lt;/span&gt;tessdata文件中加入&lt;span&gt;相关语言包&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;训练文件&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;在这里下载：&lt;/span&gt;&lt;a href=&quot;https://github.com/tesseract-ocr/tessdata&quot;&gt;&lt;span&gt;https://github.com/tesseract-ocr/tessdata&lt;/span&gt;&lt;/a&gt; &lt;span&gt;，&lt;/span&gt;&lt;span&gt;如果是简单的英文数字验证码，下载&lt;/span&gt; eng.traineddata&lt;span&gt;然后放到文件夹里即可，中文的是&lt;/span&gt;chi&lt;span&gt;开头的&lt;/span&gt;traineddata&lt;span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;导入相关依赖，&lt;/span&gt;maven&lt;span&gt;相关依赖如下：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.8.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.java.dev.jna&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jna&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.2.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sourceforge.tess4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;tess4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.1.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jna&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jna&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4，编写相关代码（自测可正常运行）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; yanZhengMaTest.pikachu;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sourceforge.tess4j.Tesseract;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sourceforge.tess4j.TesseractException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码图片存储地址&lt;/span&gt;
        File imageFile = &lt;span&gt;new&lt;/span&gt; File(&quot;C:\\Users\\pc\\Desktop\\1.gif&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;imageFile.exists()){
            System.out.println(&lt;/span&gt;&quot;图片不存在&quot;&lt;span&gt;);;
        }
        Tesseract tessreact &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tesseract();
        tessreact.setDatapath(&lt;/span&gt;&quot;F:\\Program Files (x86)\\Tesseract-OCR\\tessdata&quot;&lt;span&gt;);
        
        String result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;= &quot;测验结果：&quot; +&lt;span&gt; tessreact.doOCR(imageFile);
            System.out.println(result);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TesseractException e) {
            e.printStackTrace();
        }
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;出现异常及处理&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（本人因为开始的时候没用&lt;/span&gt;maven导入依赖，自己去下载了各种网上要的jar包去导入，遇到了一堆问题，最后卡在了Invalid memory access这个异常上，后来通过换成maven项目并解决了异常）&lt;/p&gt;
&lt;p&gt;A.&lt;span&gt;【&lt;/span&gt;Exception in thread &quot;main&quot; java.lang.Error: Invalid memory access：】&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;如果出现类似于&lt;/span&gt; Invalid memory access的异常&lt;/p&gt;
&lt;p&gt;(1). 首先你先确定JAVA代码中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tessreact.setDatapath(&quot;F:\\Program Files (x86)\\Tesseract-OCR\\tessdata&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的地址要填你步骤一下载的&lt;/span&gt;tessdata&lt;span&gt;文件夹地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2). 如果地址无误，那可能是你&lt;span&gt;&lt;strong&gt;tess4j依赖的版本太低&lt;/strong&gt;&lt;/span&gt;，需重新导入依赖，在pom中修改即可。&lt;/p&gt;
&lt;p&gt;B.&lt;span&gt;【&lt;/span&gt;Exception in thread “main” java.lang.UnsupportedClassVersionError: net/sourceforge/tess4j/Tesseract&lt;span&gt;：】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;发生该异常的原因是&lt;/span&gt;JDK版本低于1.7，使用1.7以上即可解决问题。&lt;/p&gt;
&lt;p&gt;C.&lt;span&gt;【出现图片非法异常】：可能是你图片有问题，换张图片试试，下载的图片不要去修改它的后缀，否则也可能报错。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;痛的领悟&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要直接用&lt;/span&gt;java&lt;span&gt;项目自己去导入相关&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包，直接用&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;项目去加入依赖包就好，否则可能会出现一堆莫名其妙的异常，个人觉得是因为&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;项目依赖包导入时还会导入其他&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包，&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;项目则需要自己去补增一些&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包，在此建议用&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;附：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tess4j&lt;span&gt;相关视频：&lt;/span&gt;&lt;a href=&quot;http://tphangout.com/how-to-use-the-tesseract-api-to-perform-ocr-in-your-java-code/&quot;&gt;&lt;span&gt;http://tphangout.com/how-to-use-the-tesseract-api-to-perform-ocr-in-your-java-code/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tesseract-orc-setup&lt;span&gt;下载地址（非必要）&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;https://digi.bib.uni-mannheim.de/tesseract/&quot;&gt;&lt;span&gt;https://digi.bib.uni-mannheim.de/tesseract/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tesseract-orc-setup&lt;span&gt;安装过程&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;非必要&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html&quot;&gt;&lt;span&gt;https://jingyan.baidu.com/article/219f4bf788addfde442d38fe.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tesseract-orc&lt;span&gt;环境配置&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;非必要&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/jianqingwang/p/6978724.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/jianqingwang/p/6978724.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 可识别验证码示例：http://es.bnuz.edu.cn/checkcode.aspx?0.33556625493951997/&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 06:26:00 +0000</pubDate>
<dc:creator>_TBHacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengbojia/p/9401047.html</dc:identifier>
</item>
<item>
<title>Java String类源码解析 - GrayWind</title>
<link>http://www.cnblogs.com/graywind/p/9400616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/graywind/p/9400616.html</guid>
<description>&lt;p&gt;String直接继承Object&lt;/p&gt;
&lt;p&gt;含有一个char[] value，还有一个int hash默认值为0&lt;/p&gt;
&lt;p&gt;new String()的构造产生的是一个值为””的字符数组&lt;/p&gt;
&lt;p&gt;String(&lt;strong&gt;char&lt;/strong&gt; value[], &lt;strong&gt;int&lt;/strong&gt; offset, &lt;strong&gt;int&lt;/strong&gt; count)当count=0且offset&amp;lt;=value.length时构造一个值为””的字符串。offset&amp;gt;0且offset+count&amp;lt;=value.length时复制该部分子串。其余情况都会抛错。&lt;/p&gt;
&lt;p&gt;字符数据类型是一个采用UTF-16编码表示Unicode代码点的代码单元。大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。而length返回的是UTF-16下的代码单元的数量，而codePointCount返回的是代码点的数量。对于大部分人工输入的字符，这两者是相等的，会出现length比codePointCount长的通常是某些数学或者机器符号，需要两个代码单元来表示一个代码点。&lt;/p&gt;
&lt;p&gt;对于返回char[]的方法，底层调用的是System.arraycopy方法，这也是高效的数组拷贝函数。&lt;/p&gt;
&lt;p&gt;getBytes方法会调用StringCoding.encode返回序列化后的byte[]&lt;/p&gt;
&lt;p&gt;关于String a == String b的判断，是指a和b指向内存中的同一个对象，凡是new String初始化的对象，都不会产生a==b的情况，因为他会新开辟一个对象空间，然后复制value的值，仅当b=a初始化时a==b成立。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String a, b;
        a &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        b &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        System.out.println(a&lt;/span&gt;==b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
        a = &quot;123&quot;&lt;span&gt;;
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        System.out.println(a&lt;/span&gt;==b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        a = &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        System.out.println(a&lt;/span&gt;==b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        a = &quot;123&quot;&lt;span&gt;;
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(a);
        System.out.println(a&lt;/span&gt;==b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        a = &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        b &lt;/span&gt;=&lt;span&gt; a;
        System.out.println(a&lt;/span&gt;==b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而a.equals(b)先判断a == b是否成立，再判断b是否是String类，然后逐个比较value数组的值是否相等。equalsIgnoreCase在此基础上忽略大小写的区别&lt;/p&gt;
&lt;p&gt;a.compareTo(b)比较a和b第一个不相等字符的差值，若都相等则比较长度差值。compareToIgnoreCase多一个忽略大小写的区别。regionMatches(int toffset, String other, int ooffset, int len)则是比较a从toffset开始和other从ooffset开始长度为len的部分是否相等。&lt;/p&gt;
&lt;p&gt;startsWith(String prefix, int toffset)字符串从tooffset位置开始和prefix是否相等。endsWith(String suffix)字符串结尾和suffix等长部分是否相等。&lt;/p&gt;
&lt;p&gt;hashCode()调用时，若hash值为0且字符串长度不为0，则要计算hash值，方法是value数组化为31进制&lt;/p&gt;
&lt;p&gt;indexOf是返回第一个出现的指定值的位置，可以通过fromIndex来指定开始查找的位置，而indexOfSupplementary是忽略大小写的该方法。lastIndexOf则是从尾部开始查找最后一个。&lt;/p&gt;
&lt;p&gt;substring根据指定的位置返回一个新的子字符串，若指定位置不符合原字符串的长度，则抛错。&lt;/p&gt;
&lt;p&gt;a.concat(String str)新建一个字符串内容是a+str并返回，不会修改a原本的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String a, b;
        a &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        b &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        a.concat(b);
        System.out.println(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
        System.out.println(a.concat(b));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;123123&lt;/span&gt;
        a =&lt;span&gt; a.concat(b);
        System.out.println(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;123123&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;replace(char oldChar, char newChar)生成一个新的字符串，将原字符串中的oldChar字符全部替换为newChar，不会改变原字符串的值。replaceAll(String regex, String replacement)和前一个方法相比，参数regex是正则表达式，其余相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String a;
        a &lt;/span&gt;= &quot;12131&quot;&lt;span&gt;;
        a.replace(&lt;/span&gt;&quot;1&quot;, &quot;a&quot;&lt;span&gt;);
        System.out.println(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12131&lt;/span&gt;
        a = a.replace(&quot;1&quot;, &quot;a&quot;&lt;span&gt;);
        System.out.println(a);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a2a3a&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;split(String regex, int limit)将字符串按照给定的正则表达式分割为字符串组，limit是分割产生的数组最大数量，对于多余部分不做分割全部保留在最后一个字符串中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String a;
        a &lt;/span&gt;= &quot;1,2,3,4&quot;&lt;span&gt;;
        String[] b &lt;/span&gt;= a.split(&quot;,&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String t : b){
            System.out.print(t &lt;/span&gt;+ &quot; &quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 2 3 4&lt;/span&gt;
&lt;span&gt;        }
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
        String[] c &lt;/span&gt;= a.split(&quot;,&quot;, 3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String t : c){
            System.out.print(t &lt;/span&gt;+ &quot; &quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 2 3,4&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;toCharArray()复制出一个新的char[]而不是直接返回value&lt;/p&gt;
&lt;p&gt;trim()生成一个新的字符串，去掉头部的所有空格&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public&lt;/strong&gt; &lt;strong&gt;native&lt;/strong&gt; String intern()这个方法的作用是在常量池当中寻找是否已经存在该字符串，若已存在则返回该引用，若不存在则在常量池新建。从上面的源码分析中，我们可以看出String的所有操作都是返回一个新的字符串，对自身是没有修改的，String被设计为一个不可变的final对象，理由有以下几点：&lt;/p&gt;
&lt;p&gt;1. 字符串常量池的需要。字符串常量池的诞生是为了提升效率和减少内存分配。、因为String的不可变性，常量池很容易被管理和优化。&lt;/p&gt;
&lt;p&gt;2. 安全性考虑。正因为使用字符串的场景如此之多，所以设计成不可变可以有效的防止字符串被有意或者无意的篡改。（通过反射或者Unsafe直接操作内存的手段也可以实现对所谓不可变String的修改）。&lt;/p&gt;
&lt;p&gt;3. 作为HashMap、HashTable等hash型数据key的必要。因为不可变的设计，jvm底层很容易在缓存String对象的时候缓存其hashcode，这样在执行效率上会大大提升。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        String a, b;
        a &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(a).intern();
        System.out.println(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
        a = &quot;12&quot; + &quot;3&quot;&lt;span&gt;;
        b &lt;/span&gt;= &quot;123&quot;&lt;span&gt;;
        System.out.println(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
        a = &quot;12&quot; + &quot;3&quot;&lt;span&gt;;
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        System.out.println(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
        a = &quot;12&quot; + &quot;3&quot;&lt;span&gt;;
        b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;).intern();
        System.out.println(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
        a = &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
        b &lt;/span&gt;=&lt;span&gt; a.intern();
        System.out.println(a &lt;/span&gt;== b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面一段代码的运行结果我们可以看到，intern()会从常量池寻找指定的字符串，指向同一个常量池对象的时候，a==b就是成立的。这里说明一下最后一个case，首先常量池存在了”123”，然后a获得的引用是另一个”123”（因为是new String得到的对象），而b得到的是常量池中第一个”123”的引用，所以a!=b。对于字符串相加的操作&quot;12&quot; + &quot;3&quot;，操作过后常量池内会有3个字符串，&quot;12&quot;  &quot;3&quot; “123”&lt;/p&gt;

</description>
<pubDate>Wed, 01 Aug 2018 04:54:00 +0000</pubDate>
<dc:creator>GrayWind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/graywind/p/9400616.html</dc:identifier>
</item>
<item>
<title>Elasticsearch集群搭建及使用Java客户端对数据存储和查询 - soinve</title>
<link>http://www.cnblogs.com/soinve/p/9397261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soinve/p/9397261.html</guid>
<description>&lt;p&gt;本次博文发两块，前部分是怎样搭建一个Elastic集群，后半部分是基于Java对数据进行写入和聚合统计。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Elastic集群搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 环境准备。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　该集群环境基于VMware虚拟机、CentOS 7系统，公司目前用的服务器系统基本全是CentOS系统，因此就选了这个。Elasticsearch需要依赖的最低环境就是JDK8，且要配置好环境变量JAVA_HOME. Elasticsearch的安装也可以查看&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;给出的安装说明。&lt;/p&gt;
&lt;p&gt;　　虚拟机系统采用的是最小化安装，没有安装桌面程序。安装完程序再安装JDK，配置环境变量即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 集群搭建。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.1 安装包解压&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下载完成后的Elastic包为elasticsearch-6.3.2.tar.gz，对其解压。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 将elastic包加压到目录 /data/&lt;span&gt;elastic 下
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; zxvf elasticsearch-&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz -C /data/elastic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2.2 配置文件修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　解压后的路径为/data/elastic/elasticsearch-6.3.2，在/data/elastic目录下新增两个文件夹，为data，logs，其中data用来存储节点数据，logs用来存储日志，下面在修改配置文件中需要用到。修改config/elasticsearch.yml如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 集群名称
cluster.name: elastic_test

# 节点名称
node.name: node&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 数据目录，刚才创建的data目录
path.data: &lt;/span&gt;/data/elastic/&lt;span&gt;data

#日志路径 ，刚才创建的logs目录
path.logs: &lt;/span&gt;/data/elastic/&lt;span&gt;logs

#绑定地址，修改为任何机器都能访问
network.host: &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;

#端口，默认9200，不做修改
#http.port: &lt;/span&gt;&lt;span&gt;9200&lt;/span&gt;&lt;span&gt;

# 集群节点，当节点启动后平台就会发现
discovery.zen.&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;.unicast.hosts: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.16.106.190&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.16.106.191&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.16.106.192&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

# 最小主节点数量，配置2&lt;br/&gt;# 该配置告诉ELasticsearch当没有足够的master候选节点的时候，不进行master节点选举，等master节点足够了才进行选举
discovery.zen.minimum_master_nodes: &lt;/span&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2.3 其他机器修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　修改完一台机器后，同样其他两台机器类似修改，注意把节点名称改为不一样的就可以了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.4 集群启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　启动说明：elasticsearch的启动不能使用root用户，所以要新建一个普通用户。以下是具体操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 新建一个用户组为elasticgp
groupadd elasticgp

# 新建一个用户名为elastic的用户，并且归属到elasticgp用户组
useradd &lt;/span&gt;-&lt;span&gt;g elasticgp elastic

# 给用户设置密码
&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt; elastic

# 上面已经减了一个文件夹，&lt;/span&gt;/data/&lt;span&gt;elastic,该文件夹存储了elastic软件和数据目录data及日志目录logs
# 现在将elastic目录的归属组修改成elastgp
&lt;/span&gt;&lt;span&gt;chgrp&lt;/span&gt; -R elasticgp elastic/&lt;span&gt;

# 将文件目录&lt;/span&gt;/data/&lt;span&gt;elastic所属用户修改为用户elastic
&lt;/span&gt;&lt;span&gt;chown&lt;/span&gt; -R elastic elastic/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用户配置好后切换到elastic用户进行启动程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 切换到elastic用户
&lt;/span&gt;&lt;span&gt;su&lt;/span&gt;&lt;span&gt; elastic

# 切换到程序目录下
cd &lt;/span&gt;/data/elastic/elasticsearch-&lt;span&gt;6.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;

# 后台启动程序
.&lt;/span&gt;/bin/elasticsearch -&lt;span&gt;d

# 查看输出日志
tailf ..&lt;/span&gt;/logs/elastic_test.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2.5 问题排查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　启动的时候可能会出现以下两个问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201807/1312542-20180731105554066-1272691728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;问题1：将当前用户的软硬限制调大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　修改文件 /etc/security/limits.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# elastic用户的软限制 当然也可用*&lt;span&gt;代替，标识修改所有用户
elastic soft nofile &lt;/span&gt;&lt;span&gt;65535&lt;/span&gt;&lt;span&gt;
# elastic用户的硬限制 当然也可用&lt;/span&gt;*&lt;span&gt;代替，标识修改所有用户
elastic hard nofile &lt;/span&gt;&lt;span&gt;65537&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;问题2：修改/etc/sysctl&lt;span class=&quot;hljs-preprocessor&quot;&gt;.conf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vm.max_map_count=&lt;span&gt;262144&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;问题3： 启动内存设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在内存不充足的情况下，可以修改elastic的初始内存，在/data/elastic/elasticsearch-6.3.2/config目录下有配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 将内存使用设置为512M
&lt;/span&gt;-&lt;span&gt;Xms512M
&lt;/span&gt;-Xmx512M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;问题4：端口是否开放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　elastic需要用到9200和9300两个端口，可以用telnet来查看端口是否开放，以下是修改防火墙打开端口的命令。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 永久开放9200端口
firewall&lt;/span&gt;-cmd --permanent --zone=public --add-port=&lt;span&gt;9200&lt;/span&gt;/&lt;span&gt;tcp
# 永久开放9300端口
firewall&lt;/span&gt;-cmd --permanent --zone=public --add-port=&lt;span&gt;9300&lt;/span&gt;/&lt;span&gt;tcp

#重新加载防火墙配置，使开放端口生效
firewall&lt;/span&gt;-cmd --reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2.6 集群状态查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如下图，通过访问某一个节点，查看所有的节点，其中node-1为主节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201807/1312542-20180731113412862-1886095728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如下图，查看集群健康状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201807/1312542-20180731113708768-940659328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上为elasticsearch集群具体安装过程。具体的API调用说明可以查看官网&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html&quot; target=&quot;_blank&quot;&gt;CAT_API&lt;/a&gt;和&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html&quot; target=&quot;_blank&quot;&gt;Cluster_APIs&lt;/a&gt;等等。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.7 kibana 使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;集群搭建好之后，可用通过kibana来访问集群的一个节点，然后做一下简单的测试。先去官网下载kibana安装包&lt;strong&gt;　　　　　　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;a href=&quot;https://www.elastic.co/downloads/kibana&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/downloads/kibana&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;我是下载的mac客户端，其他客户端应该也是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;解压kibana安装包后，在bin目录下执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 查看kibana命令帮助
.&lt;/span&gt;/bin/kibana -h
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　会看到如下提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Usage: bin/kibana [command=&lt;span&gt;serve] [options]

  Kibana is an open source (Apache Licensed), browser based analytics and search dashboard &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; Elasticsearch.

  Commands:
    serve  [options]  Run the kibana server
    help  &lt;/span&gt;&amp;lt;command&amp;gt;   Get the help &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a specific command

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serve&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Options:

    &lt;/span&gt;-h, --&lt;span&gt;help                 output usage information
    &lt;/span&gt;-e, --elasticsearch &amp;lt;uri&amp;gt;&lt;span&gt;  Elasticsearch instance
    &lt;/span&gt;-c, --config &amp;lt;path&amp;gt;        Path to the config &lt;span&gt;file&lt;/span&gt;, can be changed with the CONFIG_PATH environment variable as well. Use multiple --&lt;span&gt;config args to include multiple config files.
    &lt;/span&gt;-p, --port &amp;lt;port&amp;gt;&lt;span&gt;          The port to bind to
    &lt;/span&gt;-q, --&lt;span&gt;quiet                Prevent all logging except errors
    &lt;/span&gt;-Q, --&lt;span&gt;silent               Prevent all logging
    &lt;/span&gt;--&lt;span&gt;verbose                  Turns on verbose logging
    &lt;/span&gt;-H, --host &amp;lt;host&amp;gt;&lt;span&gt;          The host to bind to
    &lt;/span&gt;-l, --log-&lt;span&gt;file&lt;/span&gt; &amp;lt;path&amp;gt;      The &lt;span&gt;file&lt;/span&gt;&lt;span&gt; to log to
    &lt;/span&gt;--plugin-&lt;span&gt;dir&lt;/span&gt; &amp;lt;path&amp;gt;        A path to scan &lt;span&gt;for&lt;/span&gt;&lt;span&gt; plugins, this can be specified multiple times to specify multiple directories
    &lt;/span&gt;--plugin-path &amp;lt;path&amp;gt;       A path to a plugin &lt;span&gt;which&lt;/span&gt;&lt;span&gt; should be included by the server, this can be specified multiple times to specify multiple paths
    &lt;/span&gt;--plugins &amp;lt;path&amp;gt;           an alias &lt;span&gt;for&lt;/span&gt; --plugin-&lt;span&gt;dir&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中我们需要用的就是 &lt;span&gt;-e&lt;/span&gt; 参数，来连接指定的elasticsearch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 启动kibana，连接到制定的Elastic服务节点
.&lt;/span&gt;/bin/kibana -e http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;172.16.106.201:9200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动成功后可以访问localhost:5601，如下图，点击监控菜单看到集群的一些状态信息。indices是索引数量，除了自己新建的索引Elasticsearch本身也有一些索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201808/1312542-20180801124227582-1573117363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如下图，点击DevTools菜单，可以对集群节点上的数据进行查询了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201808/1312542-20180801124432283-785059235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、Java客户端对数据存储和查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1. 客户端配置，可以查看&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html&quot; target=&quot;_blank&quot;&gt;官网详细配置&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;采用maven管理，添加依赖的pom配置即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　&amp;lt;!--&lt;/span&gt;&lt;span&gt; Java High Level REST Client &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.elasticsearch.client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;elasticsearch-rest-high-level-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.elasticsearch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;elasticsearch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Client 包缺少一些东西，因此引入此包
            可以具体查看ISSUE https://github.com/elastic/elasticsearch/issues/26959
         &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.elasticsearch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;elasticsearch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 以下是测试主要代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.woasis.elastic.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.HttpHost;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.get.GetRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.get.GetResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.index.IndexRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.index.IndexResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.search.SearchRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.search.SearchResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.RestClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.RestHighLevelClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.xcontent.XContentBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.xcontent.XContentFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.index.query.QueryBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHits;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.builder.SearchSourceBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RestHighLevelClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestHighLevelClient(
            RestClient.builder(
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpHost(&quot;172.16.106.201&quot;,9200, &quot;http&quot;&lt;span&gt;),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpHost(&quot;172.16.106.202&quot;,9200, &quot;http&quot;&lt;span&gt;),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpHost(&quot;172.16.106.203&quot;,9200, &quot;http&quot;&lt;span&gt;)
            )
    );

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向索引下增加数据
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; indexName
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; type
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/putdata&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String putDataForIndex(String indexName, String type){

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(indexName)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;请指定索引名称&quot;&lt;span&gt;;
        }

        SimpleDateFormat simpleDateFormat &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd&quot;&lt;span&gt;);

        StringBuilder indexBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        indexBuilder.append(indexName);
        indexBuilder.append(&lt;/span&gt;&quot;-&quot;&lt;span&gt;);
        indexBuilder.append(simpleDateFormat.format(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));

        String fullIndexName &lt;/span&gt;=&lt;span&gt; indexBuilder.toString();
        System.out.println(&lt;/span&gt;&quot;索引名称是：&quot;+&lt;span&gt;fullIndexName);

        Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            XContentBuilder contentBuilder &lt;/span&gt;=&lt;span&gt; XContentFactory.jsonBuilder();
            contentBuilder.startObject();
            contentBuilder.field(&lt;/span&gt;&quot;name&quot;, &quot;people&quot;+&lt;span&gt;System.currentTimeMillis());
            contentBuilder.field(&lt;/span&gt;&quot;age&quot;, random.nextInt(30&lt;span&gt;));
            contentBuilder.field(&lt;/span&gt;&quot;createDate&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
            contentBuilder.endObject();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引请求&lt;/span&gt;
            IndexRequest indexRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexRequest(fullIndexName, type).source(contentBuilder);

            IndexResponse indexResponse &lt;/span&gt;=&lt;span&gt; client.index(indexRequest);

            System.out.println(indexResponse.getIndex());

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            client.close();&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SUCCESS&quot;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据索引名称，type，id获取数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/getdata&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getData(){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Get请求&lt;/span&gt;
        GetRequest getRequest = &lt;span&gt;new&lt;/span&gt; GetRequest(&quot;people-2018-07-31&quot;,&quot;student&quot;, &quot;DfLL72QBGxN1JyvW1KG4&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            GetResponse response &lt;/span&gt;=&lt;span&gt; client.get(getRequest);
            System.out.println(&lt;/span&gt;&quot;index:&quot;+&lt;span&gt;response.getIndex());
            System.out.println(&lt;/span&gt;&quot;type:&quot;+&lt;span&gt;response.getType());
            System.out.println(&lt;/span&gt;&quot;id:&quot;+&lt;span&gt;response.getId());
            System.out.println(&lt;/span&gt;&quot;sourceString:&quot;+&lt;span&gt;response.getSourceAsString());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SUCCESS&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 搜索数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/searchdata&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String searchData(){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Search请求&lt;/span&gt;
        SearchRequest searchRequest = &lt;span&gt;new&lt;/span&gt; SearchRequest(&quot;people-2018-07-31&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询过滤条件&lt;/span&gt;
        SearchSourceBuilder searchSourceBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SearchSourceBuilder();
        searchSourceBuilder.query(QueryBuilders.termQuery(&lt;/span&gt;&quot;name&quot;,&quot;people1533031470255&quot;&lt;span&gt;));
        searchRequest.source(searchSourceBuilder);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            SearchResponse searchResponse &lt;/span&gt;=&lt;span&gt; client.search(searchRequest);

            SearchHits searchHits &lt;/span&gt;=&lt;span&gt; searchResponse.getHits();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SearchHit hit : searchHits){
                System.out.println(&lt;/span&gt;&quot;index:&quot;+&lt;span&gt;hit.getIndex());
                System.out.println(&lt;/span&gt;&quot;type:&quot;+&lt;span&gt;hit.getType());
                System.out.println(&lt;/span&gt;&quot;id:&quot;+&lt;span&gt;hit.getId());
                System.out.println(&lt;/span&gt;&quot;sourceString:&quot;+&lt;span&gt;hit.getSourceAsString());
            }

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;SUCCESS&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　官方在各个API使用方式上都有详细的讲解，有用到的可以在官网查看。&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html&quot; target=&quot;_blank&quot;&gt;跳转地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1312542/201808/1312542-20180801110006465-1848280171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　该demo程序使用spring boot搭建，可以查看Github源码&lt;a href=&quot;https://github.com/liuzwei/elastic-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/liuzwei/elastic-demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 04:49:00 +0000</pubDate>
<dc:creator>soinve</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soinve/p/9397261.html</dc:identifier>
</item>
<item>
<title>Java并发（4）- synchronized与CAS - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9393135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9393135.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇文章中我们说过，volatile通过lock指令保证了可见性、有序性以及“部分”原子性。但在大部分并发问题中，都需要保证操作的原子性，volatile并不具有该功能，这时就需要通过其他手段来达到线程安全的目的，在Java编程中，我们可以通过锁、synchronized关键字，以及CAS操作来达到线程安全的目的。&lt;/p&gt;
&lt;h2 id=&quot;synchronized&quot;&gt;synchronized&lt;/h2&gt;
&lt;p&gt;在Java的并发编程中，保证线程同步最为程序员所熟悉的就是synchronized关键字，synchronized关键字最为方便的地方是他不需要显示的管理锁的释放，极大减少了编程出错的概率。&lt;/p&gt;
&lt;p&gt;在Java1.5及以前的版本中，synchronized并不是同步最好的选择，由于并发时频繁的阻塞和唤醒线程，会浪费许多资源在线程状态的切换上，导致了synchronized的并发效率在某些情况下不如ReentrantLock。在Java1.6的版本中，对synchronized进行了许多优化，极大的提高了synchronized的性能。只要synchronized能满足使用环境，建议使用synchronized而不使用ReentrantLock。&lt;/p&gt;
&lt;h2 id=&quot;synchronized的三种使用方式&quot;&gt;synchronized的三种使用方式&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;修饰实例方法，为当前实例加锁，进入同步方法前要获得当前实例的锁。&lt;/li&gt;
&lt;li&gt;修饰静态方法，为当前类对象加锁，进入同步方法前要获得当前类对象的锁。&lt;/li&gt;
&lt;li&gt;修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三种使用方式大家应该都很熟悉，有一个要注意的地方是对静态方法的修饰可以和实例方法的修饰同时使用，不会阻塞，因为一个是修饰的Class类，一个是修饰的实例对象。下面的例子可以说明这一点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {
    waitThread();
    notifyThread();
}

private static Object lockObject = new Object();
    
private static void waitThread() {
    
    Thread watiThread = new Thread(new Runnable() {
        
        @Override
        public void run() {
            
            synchronized (lockObject) {
                System.out.println(Thread.currentThread().getName() + &quot;wait-before&quot;);
                
                try {
                    TimeUnit.SECONDS.sleep(2);
                    lockObject.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                
                System.out.println(Thread.currentThread().getName() + &quot;after-wait&quot;);
            }
            
        }
    },&quot;waitthread&quot;);
    watiThread.start();
}

private static void notifyThread() {
    
    Thread watiThread = new Thread(new Runnable() {
        
        @Override
        public void run() {
            
            synchronized (lockObject) {
                System.out.println(Thread.currentThread().getName() + &quot;notify-before&quot;);
                
                lockObject.notify();
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } 
                
                System.out.println(Thread.currentThread().getName() + &quot;after-notify&quot;);
            }
            
        }
    },&quot;notifythread&quot;);
    watiThread.start();
}

//waitthreadwait-before
//notifythreadnotify-before
//notifythreadafter-notify
//waitthreadafter-wait&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中我们开启了两个线程分别锁定静态方法和实例方法，从打印的输出结果中我们可以看到，这两个线程锁定的是不同对象，可以并发执行。&lt;/p&gt;
&lt;h2 id=&quot;synchronized的底层原理&quot;&gt;synchronized的底层原理&lt;/h2&gt;
&lt;p&gt;我们看一段synchronized关键字经过编译后的字节码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (null == instance) {   
    synchronized (DoubleCheck.class) {
        if (null == instance) {   
            instance = new DoubleCheck();   
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180730215628486-603858156.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180730215639365-1260700595.png&quot;/&gt;&lt;br/&gt;可以看到synchronized关键字在同步代码块前后加入了monitorenter和monitorexit这两个指令。monitorenter指令会获取锁对象，如果获取到了锁对象，就将锁计数器加1，未获取到则会阻塞当前线程。monitorexit指令会释放锁对象，同时将锁计数器减1。&lt;/p&gt;
&lt;h2 id=&quot;jdk1.6对synchronized的优化&quot;&gt;JDK1.6对synchronized的优化&lt;/h2&gt;
&lt;p&gt;JDK1.6对对synchronized的优化主要体现在引入了“偏向锁”和“轻量级锁”的概念，同时synchronized的锁只可升级，不可降级：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201808/368583-20180801110651056-178505324.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我不打算详细讲解每种锁的实现，想了解的可以参照《深入理解Java虚拟机》，只简单说下自己的理解。&lt;/p&gt;
&lt;p&gt;偏向锁的思想是指如果一个线程获得了锁，那么就从无锁模式进入偏向模式，这一步是通过CAS操作来做的，进入偏向模式的线程每一次访问这个锁的同步代码块时都不需要再进行同步操作，除非有其他线程访问这个锁。&lt;/p&gt;
&lt;p&gt;偏向锁提高的是那些带同步但无竞争的代码的性能，也就是说如果你的同步代码块很长时间都是同一个线程访问，偏向锁就会提高效率，因为他减少了重复获取锁和释放锁产生的性能消耗。如果你的同步代码块会频繁的在多个线程之间访问，可以使用参数-XX：-UseBiasedLocking来禁止偏向锁产生，避免在多个锁状态之间切换。&lt;/p&gt;
&lt;p&gt;偏向锁优化了只有一个线程进入同步代码块的情况，当多个线程访问锁时偏向锁就升级为了轻量级锁。&lt;/p&gt;
&lt;p&gt;轻量级锁的思想是当多个线程进入同步代码块后，多个线程未发生竞争时一直保持轻量级锁，通过CAS来获取锁。如果发生竞争，首先会采用CAS自旋操作来获取锁，自旋在极短时间内发生，有固定的自旋次数，一旦自旋获取失败，则升级为重量级锁。&lt;/p&gt;
&lt;p&gt;轻量级锁优化了多个线程进入同步代码块的情况，多个线程未发生竞争时，可以通过CAS获取锁，减少锁状态切换。当多个线程发生竞争时，不是直接阻塞线程，而是通过CAS自旋来尝试获取锁，减少了阻塞线程的概率，这样就提高了synchronized锁的性能。&lt;/p&gt;
&lt;h2 id=&quot;synchronized的等待唤醒机制&quot;&gt;synchronized的等待唤醒机制&lt;/h2&gt;
&lt;p&gt;synchronized的等待唤醒是通过notify/notifyAll和wait三个方法来实现的，这三个方法的执行都必须在同步代码块或同步方法中进行，否则将会报错。&lt;/p&gt;
&lt;p&gt;wait方法的作用是使当前执行代码的线程进行等待，notify/notifyAll相同，都是通知等待的代码继续执行，notify只通知任一个正在等待的线程，notifyAll通知所有正在等待的线程。wait方法跟sleep不一样，他会释放当前同步代码块的锁，notify在通知任一等待的线程时不会释放锁，只有在当前同步代码块执行完成之后才会释放锁。下面的代码可以说明这一点:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SynchronizedTest {

    public static synchronized void StaticSyncTest() {

        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 3; i++) {

                    System.out.println(&quot;StaticSyncTest&quot;);
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
        });
        thread.start();

    }

    public synchronized void NonStaticSyncTest() {

        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                for (int i = 0; i &amp;lt; 3; i++) {

                    System.out.println(&quot;NonStaticSyncTest&quot;);
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
        });
        thread.start();
    }
}

public static void main(String[] args) throws InterruptedException {

    SynchronizedTest synchronizedTest = new SynchronizedTest();
    SynchronizedTest.StaticSyncTest();
    synchronizedTest.NonStaticSyncTest();
}

//StaticSyncTest
//NonStaticSyncTest
//StaticSyncTest
//NonStaticSyncTest
//StaticSyncTest
//NonStaticSyncTest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中notify线程通知之后wait线程并没有马上启动，还需要notity线程执行完同步代码块释放锁之后wait线程才开始执行。&lt;/p&gt;
&lt;h2 id=&quot;cas&quot;&gt;CAS&lt;/h2&gt;
&lt;p&gt;在synchronized的优化过程中我们看到大量使用了CAS操作，CAS全称Compare And Set（或Compare And Swap）,CAS包含三个操作数：内存位置(V)、原值(A)、新值(B)。简单来说CAS操作就是一个虚拟机实现的原子操作，这个原子操作的功能就是将旧值(A)替换为新值(B)，如果旧值(A)未被改变，则替换成功，如果旧值(A)已经被改变则替换失败。&lt;/p&gt;
&lt;p&gt;可以通过AtomicInteger类的自增代码来说明这个问题，当不使用同步时下面这段代码很多时候不能得到预期值10000，因为noncasi[0]++不是原子操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void IntegerTest() throws InterruptedException {

    final Integer[] noncasi = new Integer[]{ 0 };

    for (int i = 0; i &amp;lt; 10; i++) {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                for (int j = 0; j &amp;lt; 1000; j++) {
                    noncasi[0]++;
                }
            }
        });
        thread.start();
    }
    
    while (Thread.activeCount() &amp;gt; 2) {
        Thread.sleep(10);
    }
    System.out.println(noncasi[0]);
}

//7889&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用AtomicInteger的getAndIncrement方法来实现自增之后相当于将casi.getAndIncrement()操作变成了原子操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void AtomicIntegerTest() throws InterruptedException {

    AtomicInteger casi = new AtomicInteger();
    casi.set(0);

    for (int i = 0; i &amp;lt; 10; i++) {
        Thread thread = new Thread(new Runnable() {

            @Override
            public void run() {
                for (int j = 0; j &amp;lt; 1000; j++) {
                    casi.getAndIncrement();
                }
            }
        });
        thread.start();
    }
    while (Thread.activeCount() &amp;gt; 2) {
        Thread.sleep(10);
    }
    System.out.println(casi.get());
}

//10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以通过synchronized关键字来达到目的，但CAS操作不需要加锁解锁以及切换线程状态，效率更高。&lt;/p&gt;
&lt;p&gt;再来看看casi.getAndIncrement()具体做了什么，在JDK1.8之前getAndIncrement是这样实现的（类似incrementAndGet）:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile int value;

public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过compareAndSet将变量自增，如果自增成功则完成操作，如果自增不成功，则自旋进行下一次自增，由于value变量是volatile修饰的，通过volatile的可见性，每次get()都能获取到最新值，这样就保证了自增操作每次自旋一定次数之后一定会成功。&lt;/p&gt;
&lt;p&gt;JDK1.8中则直接将getAndAddInt方法直接封装成了原子性的操作，更加方便使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CAS操作是实现Java并发包的基石，他理解起来比较简单但同时也非常重要。Java并发包就是在CAS操作和volatile基础上建立的，下图中列举了J.U.C包中的部分类支撑图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201808/368583-20180801111919717-224220783.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Aug 2018 03:24:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9393135.html</dc:identifier>
</item>
<item>
<title>【watcher】 #02   c# 中实现时间戳等，日期数字及大概率绝对随机数 实现 - 董小保</title>
<link>http://www.cnblogs.com/Bobdong/p/9400218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Bobdong/p/9400218.html</guid>
<description>&lt;p&gt;在Wacher的项目中，用到了很多时间记录的地方，为了将来能够和在线数据打通，我们使用了时间戳来记录时间信息&lt;/p&gt;&lt;p&gt;由于c# 没有现成的方法，所以我们重新写了一个Helper类来帮助我们使用这些公共函数&lt;/p&gt;&lt;p&gt;这个时间戳是10位的时间戳，如果需要和JAVA兼容请在除法中取出3位，保存到毫秒级&lt;/p&gt;&lt;div readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取时间戳
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetTimeSecond(DateTime dataTime)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((dataTime.ToUniversalTime().Ticks - &lt;span&gt;621355968000000000&lt;/span&gt;) / &lt;span&gt;10000000&lt;/span&gt;&lt;span&gt;).ToString();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（无论是string还是long类型，方法中价格强制类型转换即可，目前如果传参是long类型的话只需要ToString即可 ）&lt;/p&gt;&lt;div readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 由时间戳到系统时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;date&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DateTime ReturnDateTime(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; date)
        {
            DateTime dtStart &lt;/span&gt;= TimeZone.CurrentTimeZone.ToLocalTime(&lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lTime = &lt;span&gt;long&lt;/span&gt;.Parse(date + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            TimeSpan toNow &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeSpan(lTime);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dtStart.Add(toNow);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过datetime格式获取 YMD格式数字类型日期
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dataTime&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetDateInt(DateTime dataTime)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dateLong= dataTime.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToInt64(dateLong);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;单机每秒请求10W次不重复，【在网络请求中，我们经常会用到request_id，服务端，客户端均可使用，实测一秒内10W次请求不重复】&lt;/p&gt;&lt;p&gt;使用基于计算机本身的识别因子随机数的随机因子+基于GUid的随机因子的随机数+短时间戳+base64进制转化为短字符。&lt;/p&gt;&lt;div readability=&quot;169&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取绝对随机数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetRandOnlyId()
        {
             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timeStamp= (DateTime.Now.ToUniversalTime().Ticks - &lt;span&gt;13560192000000000&lt;/span&gt;) / &lt;span&gt;10000000&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减少时间戳位数形成新的短时间戳&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; beginRand= IntToi64(&lt;span&gt;new&lt;/span&gt; Random(GetRandomSeed()).Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;99999999&lt;/span&gt;&lt;span&gt;));// 基于计算机硬件的随机因子产生随机数
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; endRand= IntToi64(&lt;span&gt;new&lt;/span&gt; Random(GetGuidSeed()).Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;99999999&lt;/span&gt;&lt;span&gt;));// 基于Guid随机因子产生的的随机数
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; randString = beginRand+ IntToi64(timeStamp)+&lt;span&gt; endRand;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; randString;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取不重复的随机数种子
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; system.Security.Cryptography.RNGCryptoServiceProvider的类，它采用系统当前的硬件信息、进程信息、线程信息、系统启动时间和当前精确时间作为填充因子，通过更好的算法生成高质量的随机数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetRandomSeed()
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
            RNGCryptoServiceProvider rng &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RNGCryptoServiceProvider();
            rng.GetBytes(bytes);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BitConverter.ToInt32(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过Guid  获取随机种子
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetGuidSeed()
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer =&lt;span&gt; Guid.NewGuid().ToByteArray();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iSeed = BitConverter.ToInt32(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; iSeed;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 十进制转64进制
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;xx&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; IntToi64(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; xx)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; retStr = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (xx &amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = Convert.ToInt16(xx - (xx / &lt;span&gt;64&lt;/span&gt;) * &lt;span&gt;64&lt;/span&gt;&lt;span&gt;);
                retStr &lt;/span&gt;= Base64Code[index] +&lt;span&gt; retStr;
                xx &lt;/span&gt;= xx / &lt;span&gt;64&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retStr;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 64 位转化参数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; Base64Code = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;() {
            {   &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;1&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;2&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;3&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;4&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;5&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;6&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;7&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;8&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;9&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;J&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;11&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;12&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;13&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;14&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;15&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;16&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;17&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;18&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;19&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;21&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;22&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;23&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;24&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;25&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;26&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;27&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;28&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;29&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;31&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;32&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;33&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;34&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;35&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;36&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;37&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;38&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;39&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;40&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;41&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;42&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;43&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;44&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;45&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;46&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;47&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;48&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;49&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;51&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;52&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;53&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;54&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;55&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;56&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;57&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;58&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;59&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {   &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;61&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;62&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, {   &lt;span&gt;63&lt;/span&gt;  ,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, };
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Wed, 01 Aug 2018 03:18:00 +0000</pubDate>
<dc:creator>董小保</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Bobdong/p/9400218.html</dc:identifier>
</item>
</channel>
</rss>