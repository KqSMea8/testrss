<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java不走弯路教程（2.Hello,Java!） - java123.vip</title>
<link>http://www.cnblogs.com/java123vip/p/8973744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java123vip/p/8973744.html</guid>
<description>&lt;p&gt;&lt;strong&gt;2.Hello,Java!&lt;/strong&gt;&lt;br/&gt;欢迎来到Java的世界，在上一章，我们已经完成了DOS的基本操作学习和Java的环境搭建，在本章中我们Java来完成一个简单的DOS程序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1 Hello,Java!&lt;/strong&gt;&lt;br/&gt;首先，我们创建一个文件名为MyNotepad.java，保存到c:\work\001下，&lt;br/&gt;文件内内容如下：（注意文件名与文件内容的大小写，以后不再提示）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151644869-1084001300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后启动DOS环境，输入如下命令：&lt;br/&gt;cd c:\work\001&lt;br/&gt;javac MyNotepad.java&lt;br/&gt;java MyNotepad&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151711146-867080615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到输出：Hello,Java!&lt;br/&gt;再次执行java MyNotepad，则无需再次编译。&lt;/p&gt;&lt;p&gt;OK，我们完成了简单的DOS程序，请认真地理解这个过程，因为本教程接下来的内容，将是对这个过程的不断扩展，直至完成Java的学习。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2 查看文件内容&lt;/strong&gt;&lt;br/&gt;现在有一个简单的需求：&lt;br/&gt;输入如下命令来查看文件a.txt的内容：&lt;br/&gt;java MyNotepad a.txt&lt;/p&gt;&lt;p&gt;我们来简单的介绍一下刚才写的MyNotepad.java&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151747144-1427212812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上述程序中，分号代表以行的结束，大括号代表一个区块的结束。&lt;br/&gt;MyNotepad为类名，main为类入口，String[] args用来接收程序的参数，因为程序会有多个参数名比如&lt;br/&gt;java MyNotepad a.txt b.txt c.txt&lt;br/&gt;所以变量args的类型定义为一个可以接收多个字符串(String)的数组用来接收多个参数，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151805354-1685985627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用[]表示该参数为数组。&lt;br/&gt;可以用如下的方法来取得数组中每一个元素的值：&lt;br/&gt;args[0],args[1],args[2]...&lt;/p&gt;&lt;p&gt;注：Java中第一个元素下标为0&lt;/p&gt;&lt;p&gt;我们试着来先来接收输入的参数，并输出到DOS界面：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151836144-1423286732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：加号用来连接两个字符串&lt;/p&gt;&lt;p&gt;编译后运行：java MyNotepad a.txt&lt;br/&gt;输出Hello,a.txt&lt;/p&gt;&lt;p&gt;/////////////////////////////////////&lt;br/&gt;休息一下，我们来看看这个过程是如何完成的：&lt;br/&gt;1.建立文件MyNotepad.java，并写入程序。&lt;br/&gt;2.输入命令javac MyNotepad.java来把程序编译成class文件（MyNotepad.class）&lt;br/&gt;我们称MyNotepad.java为源文件，MyNotepad.class为目标文件（执行文件）&lt;br/&gt;编译过程如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151856642-1187973772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时大家可以把MyNotepad.java删除，因为程序执行是通过解析目标文件（.class文件）来完成的。&lt;br/&gt;我们用记事本打开.class文件看看其中内容，看不懂。。。，对，因为这是机器读的。相对于人来说，&lt;br/&gt;机器读class文件比读java文件更容易。&lt;br/&gt;所以我们需要一个编译过程来把java文件翻译成class文件，同样把class文件翻译成java文件的过程们称为反编译，本教程不讨论反编译的内容。&lt;/p&gt;&lt;p&gt;3.我们运行Java程序，传入参数 MyNotepad a.txt&lt;br/&gt;这个过程中Java程序首先根据传入的参数MyNotepad去环境变量CLASSPATH中查找名为MyNotepad的类定义，即class MyNotepad的定义，&lt;br/&gt;因为我们设置了当前目录.在环境变量CLASSPATH中，所以Java程序在当前目录下找到了MyNotepad的类定义，然后调用该类的固定入口main方法,&lt;br/&gt;并将后续参数a.txt传入给main的args变量。&lt;br/&gt;注：在新版本的JDK中，无需设置环境变量CLASSPATH，编译器会自动查找相关的库文件，以后不再说明。&lt;/p&gt;&lt;p&gt;4.main中将args的第一个传入参数args[0](a.txt)和之前的字符串Hello 拼接到一起，生成新的字符串Hello a.txt,然后作为参数&lt;br/&gt;传递给Syste.out.println方法，该方法将传递的参数&quot;Hello a.txt&quot;输出到DOS界面。&lt;/p&gt;&lt;p&gt;总结：&lt;br/&gt;到目前为止我们接触了如下概念：&lt;br/&gt;类，函数/方法，参数&lt;br/&gt;注：函数和方法是同一概念&lt;br/&gt;可以用下图表示：&lt;br/&gt;public class 类名{&lt;br/&gt;-函数1&lt;br/&gt;-函数2&lt;br/&gt;-函数3&lt;br/&gt;...&lt;br/&gt;-主函数main&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;其中函数定义如下&lt;br/&gt;public static 返回值 函数名(参数类型 参数名){}&lt;/p&gt;&lt;p&gt;其中{}表示一个区块的开始和结束，比如类定义，函数定义。&lt;br/&gt;在如下命令来运行Java程序时，系统会默认调用名称为main的函数并将后续参数传递给main函数。（我们称main为主函数/主方法）&lt;br/&gt;java 类名&lt;/p&gt;&lt;p&gt;函数的返回值我们将在后面介绍.&lt;/p&gt;&lt;p&gt;//////////////////////////////////////////////&lt;/p&gt;&lt;p&gt;接下来我们继续扩展这个程序&lt;/p&gt;&lt;p&gt;对于System.out.println，我们将在后续章节中说明，因为本阶段我们理解不了这句话的具体含义，所以我们将他暂时隐藏起来。&lt;br/&gt;隐藏我们不想看到的内容，首先想到的就是把他变成方法调用，于是我们的程序变成这样：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151930492-367544846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于调用某个类的静态(static)函数，一般直接用 类名.函数名() 格式， 如果当前类则可以省略类名，如上面的程序。&lt;br/&gt;我们改称正式的格式如下：&lt;br/&gt;注：静态函数即函数定义中加入static关键字，我们将在后续章节中说明。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430151949137-1078685007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是觉得不够清晰，我想把这个方法放到别的类中。&lt;br/&gt;新建一个文件MyUtil.java如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152007395-1792001866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改MyNotepad.java如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152033577-105169215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分别编译MyUtil和MyNotepad，并测试运行。&lt;br/&gt;注：只编译MyNotepad也可以，因为会自动编译关联的MyUtil。&lt;/p&gt;&lt;p&gt;OK，程序基本上清晰了，可生成的文件还是在同一目录下，我想把这种工具类或者称为帮助函数放到单独的文件夹中，作为类库来使用。&lt;br/&gt;我们继续扩展：&lt;br/&gt;当前目录为c:\work\001&lt;br/&gt;我们在当前目录下创建新目录util和main&lt;br/&gt;然后将MyUtil.java放入util目录中，MyNotepad.java放入main目录中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152114890-429923162.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们称目录c:\work\001为工程根目录，程序的运行也要在工程的根目录下，因为CLASSPATH中设置了从当前路径(.)开始查找类文件。&lt;br/&gt;在编译和执行的时候我们要将目录名加入到类名前，如下所示：&lt;br/&gt;javac main\MyNotepad.java&lt;br/&gt;java main.MyNotepad&lt;/p&gt;&lt;p&gt;先不要运行，还没说完。&lt;/p&gt;&lt;p&gt;大家看到javac后面跟的是文件的路径，所以用windows的目录格式来定位文件。&lt;br/&gt;java后面跟的是类名，因为Java程序会自动地加载.class类文件。&lt;br/&gt;类名前的目录名我们称为包(package)名，这样防止了不同目录下相同文件无法定位的问题。&lt;/p&gt;&lt;p&gt;所以正式的类名为 包名.类名&lt;/p&gt;&lt;p&gt;所以我们要程序中声明自己所在的包（目录），修改MyNotepad.java如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152213713-1747687039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;注：同时对MyUtil的调用也要用全名&lt;/p&gt;&lt;p&gt;修改MyUtil如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152234596-299529577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译，运行：&lt;br/&gt;javac main\MyNotepad.java&lt;br/&gt;java main.MyNotepad a.txt&lt;br/&gt;输出：Hello a.txt&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152300815-196142764.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察MyNotepad.java中对util.MyUtil的调用，如果有许多个对util.MyUtil的调用，我们则要每次都写全名util.MyUtil。&lt;br/&gt;考虑程序的简洁性，我想只写MyUtil，那么需要在文件的头部加入声明：&lt;br/&gt;import util.*&lt;/p&gt;&lt;p&gt;意思为导入util包(目录)下的的所有类文件&lt;/p&gt;&lt;p&gt;于是程序变成这样：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152330747-1924269440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK,现在我们完全不用关心System.out.println这种输出的实现，只需要做函数/方法调用即可。&lt;/p&gt;&lt;p&gt;继续扩展我们的程序：&lt;br/&gt;对于如下语句&lt;br/&gt;MyUtil.println(&quot;Hello &quot;+args[0]);&lt;br/&gt;我们可以修改成：&lt;br/&gt;String message = &quot;Hello &quot;+args[0];&lt;br/&gt;MyUtil.println(message);&lt;/p&gt;&lt;p&gt;在上面的语句中我们完成了变量的声明与赋值，即声明变量message为String类型，并且将&quot;Hello &quot;+args[0]的结果赋给message。&lt;/p&gt;&lt;p&gt;变量声明的格式如下：&lt;br/&gt;变量类型 变量名；&lt;/p&gt;&lt;p&gt;变量赋值的格式如下：&lt;br/&gt;变量名 = 值；&lt;/p&gt;&lt;p&gt;其中变量的声明和赋值可以写在一起即：&lt;br/&gt;变量类型 变量名 = 值；&lt;/p&gt;&lt;p&gt;Java中有三大类型，基本类型，自定义类型，String&lt;br/&gt;注：由于String比较特殊和常用，所以我们暂时把他单独提出为一个类型。&lt;br/&gt;基本类型包括：char,boolean,byte,short,int,long,float,double&lt;br/&gt;其中我们暂时只需要关注：char,boolean,int（全部小写）&lt;br/&gt;自定义类型即为class声明的类名，默认以大写字母开头，其中包括众多系统类，在此不一一列举。&lt;/p&gt;&lt;p&gt;所以我们暂时关注的类型为：String,char,boolean,int,自定义类（包括众多系统类）&lt;br/&gt;我们的程序变成了这个样子：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152348375-275409482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在MyUtil中加入了读文件的方法，定义如下：&lt;br/&gt;public static String getFileContent(String fileName)&lt;br/&gt;他可以根据传入的文件名，读取当前目录下的文件并返回文件内容。&lt;br/&gt;我们不用关心具体实现，只需要调用即可。MyUtil代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6ceb2e08-8d74-4343-af79-dce0f84f932a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6ceb2e08-8d74-4343-af79-dce0f84f932a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6ceb2e08-8d74-4343-af79-dce0f84f932a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyUtil {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; println(String message){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        System.out.println(message);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getFileContent(String fileName) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         StringBuffer content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         InputStream fis = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         InputStreamReader isr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         BufferedReader br = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             fis = MyUtil.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/&quot;+&lt;span&gt;fileName);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fis == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 System.out.println(&quot;File not found:[&quot; + fileName + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; content.toString();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             isr = &lt;span&gt;new&lt;/span&gt; InputStreamReader(fis, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                content.append(line);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 content.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    br.close();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                    isr.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    fis.close();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; content.toString();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyUtil.java&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;于是我们完成本章的目标，修改程序如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152407384-912054306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152421539-513280635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将a.txt放入c:\work\001下，编译运行程序如下：&lt;br/&gt;javac main\MyNotepad.java&lt;br/&gt;java main.MyNotepad a.txt&lt;br/&gt;输出：abc&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152446651-523452180.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180430152457150-758397656.png&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很简单？是的，因为类似于读文件，输出内容等操作都被封装到工具类中，所以到这里，你只需要掌握环境搭建，运行，变量的声明，赋值和函数的调用。&lt;br/&gt;大家暂时不要关心我封装到MyUtil里的是什么东西，怎么写的，写的对不对，好不好。&lt;br/&gt;你只需要知道如何调用，传入什么参数，返回什么结果，就可以了。&lt;br/&gt;因为程序制造是一个庞大的工程，需要团队协同工作，一个程序员不可能理解所有的东西，所以你更需要关心的是自己的程序的正确性，输入输出，如何调用别人提供的接口，而不是关心全部。&lt;br/&gt;保证全部理解自己范围内的程序，并且保证写出程序的优雅和简洁性是很重要的。&lt;/p&gt;&lt;p&gt;注：本教程只串讲Java学习主线内容和学习方法，如果大家对本教程涉及的知识感到吃力，请在阅读过程中自行补充相关的知识点。&lt;/p&gt;
&lt;p&gt;版权声明：本教程版权归java123.vip所有，禁止任何形式的转载与引用。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 07:26:00 +0000</pubDate>
<dc:creator>java123.vip</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java123vip/p/8973744.html</dc:identifier>
</item>
<item>
<title>含有分类变量（categorical variable）的逻辑回归（logistic regression）中虚拟变量（哑变量，dummy variable）的理解 - 生信小码农</title>
<link>http://www.cnblogs.com/Demo1589/p/8973731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Demo1589/p/8973731.html</guid>
<description>&lt;p&gt;　　使用R语言做逻辑回归的时候，当自变量中有分类变量（大于两个）的时候，对于回归模型的结果有一点困惑，搜索相关知识发现不少人也有相同的疑问，通过查阅资料这里给出自己的理解。&lt;/p&gt;
&lt;p&gt;　　首先看一个实例（数据下载自：http://freakonometrics.free.fr/db.txt）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&amp;gt; db &amp;lt;- read.table(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,header=TRUE,sep=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;&lt;span class=&quot;GGHFMYIBCOB ace_keyword&quot;&gt;&amp;gt; head(db)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;GGHFMYIBMOB&quot;&gt;
  Y       X1       X2 X3
1 1 3.297569 16.25411  B
2 1 6.418031 18.45130  D
3 1 5.279068 16.61806  B
4 1 5.539834 19.72158  C
5 1 4.123464 18.38634  C
6 1 7.778443 19.58338  C
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;gt; summary(db)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;GGHFMYIBMOB&quot;&gt;
       Y               X1               X2        X3     
 Min.   :0.000   Min.   :-1.229   Min.   :10.93   A:197  
 1st Qu.:1.000   1st Qu.: 4.545   1st Qu.:17.98   B:206  
 Median :1.000   Median : 5.982   Median :20.00   C:196  
 Mean   :0.921   Mean   : 5.958   Mean   :19.94   D:197  
 3rd Qu.:1.000   3rd Qu.: 7.358   3rd Qu.:21.89   E:204  
 Max.   :1.000   Max.   :11.966   Max.   :28.71          
&lt;/pre&gt;
&lt;pre class=&quot;GGHFMYIBMOB&quot;&gt;
&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;GGHFMYIBCOB ace_keyword&quot;&gt;&amp;gt; reg &amp;lt;- glm(Y~X1+X2+X3,family=binomial,data=db)&lt;br/&gt;&amp;gt; &lt;span class=&quot;GGHFMYIBCOB ace_keyword&quot;&gt;summary(reg)&lt;/span&gt;&lt;/span&gt;
Call:
glm(formula = Y ~ X1 + X2 + X3, family = binomial, data = db)

Deviance Residuals: 
     Min        1Q    Median        3Q       Max  
-2.98017   0.09327   0.19106   0.37000   1.50646  

Coefficients:
            Estimate Std. Error z value Pr(&amp;gt;|z|)    
(Intercept) -4.45885    1.04646  -4.261 2.04e-05 ***
X1           0.51664    0.11178   4.622 3.80e-06 ***
X2           0.21008    0.07247   2.899 0.003745 ** 
X3B          1.74496    0.49952   3.493 0.000477 ***
X3C         -0.03470    0.35691  -0.097 0.922543    
X3D          0.08004    0.34916   0.229 0.818672    
X3E          2.21966    0.56475   3.930 8.48e-05 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 552.64  on 999  degrees of freedom
Residual deviance: 397.69  on 993  degrees of freedom
AIC: 411.69

Number of Fisher Scoring iterations: 7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该数据集三个自变量中 X1， X2为连续型变量，X3为分类变量（A,B,C,D,E）。 获取逻辑回归结果时发现X3变量的表示形式和X1，X2不一样，并且分别产生了X3B, X3C, X3D, X3E四个新的变量，但是又没有X3A变量。后来查阅相关资料才明白原来逻辑回归中处理分类变量和连续型变量是不一样的。&lt;/p&gt;
&lt;p&gt;　　当分类自变量的类别大于两个的时候，需要建立一组虚拟变量（哑变量）来代表变量的归属性质。一般虚拟变量的数目比分类变量的数目少一个，少掉的那个就作为参照类（reference category）。例如本例中，A就是参照类，X3B, X3C, X3D, X3E就是四个虚拟变量。参照类的选取是随意的，R语言逻辑回归默认将分类变量的第一个factor设置为虚拟变量。此时的回归模型如下：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177740/201804/1177740-20180430135230894-145462759.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四个虚拟变量的取值为1或0，即当观测值中的分类变量属于某一组时，该组的虚拟变量值为1，剩下的虚拟变量值为0。&lt;/p&gt;
&lt;p&gt;例如，当一组观测值（X1，X2，X3，Y）中 X3 的值为B时，虚拟变量X3B = 1， X3C, X3D, X3E 都为0，此时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177740/201804/1177740-20180430140404774-1345843761.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当一组观测值（X1，X2，X3，Y）中 X3 的值为A时， 因为A为参照类，所以此时X3B, X3C, X3D, X3E都为0，此时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177740/201804/1177740-20180430141016217-1733974648.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此在控制变量条件下，即假设两组观测值中，X1， X2相同，而X3分别为A和B， 由上面两式相减可得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177740/201804/1177740-20180430142111389-2038882705.png&quot; alt=&quot;&quot; width=&quot;184&quot; height=&quot;62&quot;/&gt;             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1177740/201804/1177740-20180430142201352-1651609558.png&quot; alt=&quot;&quot; width=&quot;171&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处odds(B/A)为变量B对变量A的发生比率，即变量B的发生比与变量A的发生比的比值。大于1的发生比率表明事件发生的可能性会提高，或者说自变量对事件发生的概率有正的作用。例如，假如说odds(B/A)的数值大于1，那么说明在X1，X2不变的条件下，X3取值B比X3取值A有更大的概率使Y的值为1。（王济川，郭志刚. Logistic 回归模型 —— 方法与应用[M]. 北京：高等教育出版社）&lt;/p&gt;

&lt;p&gt;　　回到开头的例子，根据结果我们得以得出这样的结论，变量X3取值A,C,D对Y的影响差不多，而变量X3取值B,E会使得Y取值为1的概率比去A,C,D显著增大。简单看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt; db_a &amp;lt;- db[db$X3 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,]
&lt;/span&gt;&amp;gt; db_b &amp;lt;- db[db$X3 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,]
&lt;/span&gt;&amp;gt; db_c &amp;lt;- db[db$X3 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,]
&lt;/span&gt;&amp;gt; db_d &amp;lt;- db[db$X3 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,]
&lt;/span&gt;&amp;gt; db_e &amp;lt;- db[db$X3 == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,]

&lt;/span&gt;&amp;gt;&lt;span&gt; table(db_a$Y)

  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt; 
 &lt;span&gt;25&lt;/span&gt; &lt;span&gt;172&lt;/span&gt; 
&amp;gt;&lt;span&gt; table(db_b$Y)

  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt; 
  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;200&lt;/span&gt; 
&amp;gt;&lt;span&gt; table(db_c$Y)

  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt; 
 &lt;span&gt;21&lt;/span&gt; &lt;span&gt;175&lt;/span&gt; 
&amp;gt;&lt;span&gt; table(db_d$Y)

  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt; 
 &lt;span&gt;22&lt;/span&gt; &lt;span&gt;175&lt;/span&gt; 
&amp;gt;&lt;span&gt; table(db_e$Y)

  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;   &lt;span&gt;1&lt;/span&gt; 
  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;199&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致从结果看出确实变量B,E组的Y值为1的比例要高于A,C,D组。&lt;/p&gt;

&lt;p&gt;我们也可以自己定义虚拟变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; levels(db$X3)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&amp;gt; db$X3 &amp;lt;- relevel(db$X3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&lt;span&gt; levels(db$X3)
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同上面的回归模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt; reg &amp;lt;- glm(Y~X1+X2+X3,family=binomial,data=&lt;span&gt;db)
&lt;/span&gt;&amp;gt;&lt;span&gt; summary(reg)

Call:
glm(formula &lt;/span&gt;= Y ~ X1 + X2 + X3, family = binomial, data =&lt;span&gt; db)

Deviance Residuals: 
     Min        1Q    Median        3Q       Max  
&lt;/span&gt;-&lt;span&gt;2.98017&lt;/span&gt;   &lt;span&gt;0.09327&lt;/span&gt;   &lt;span&gt;0.19106&lt;/span&gt;   &lt;span&gt;0.37000&lt;/span&gt;   &lt;span&gt;1.50646&lt;/span&gt;&lt;span&gt;  

Coefficients:
            Estimate Std. Error z value Pr(&lt;/span&gt;&amp;gt;|z|&lt;span&gt;)    
(Intercept) &lt;/span&gt;-&lt;span&gt;2.71389&lt;/span&gt;    &lt;span&gt;1.07274&lt;/span&gt;  -&lt;span&gt;2.530&lt;/span&gt; &lt;span&gt;0.011410&lt;/span&gt; *&lt;span&gt;  
X1           &lt;/span&gt;&lt;span&gt;0.51664&lt;/span&gt;    &lt;span&gt;0.11178&lt;/span&gt;   &lt;span&gt;4.622&lt;/span&gt;  &lt;span&gt;3.8e-06&lt;/span&gt; ***&lt;span&gt;
X2           &lt;/span&gt;&lt;span&gt;0.21008&lt;/span&gt;    &lt;span&gt;0.07247&lt;/span&gt;   &lt;span&gt;2.899&lt;/span&gt; &lt;span&gt;0.003745&lt;/span&gt; **&lt;span&gt; 
X3A         &lt;/span&gt;-&lt;span&gt;1.74496&lt;/span&gt;    &lt;span&gt;0.49952&lt;/span&gt;  -&lt;span&gt;3.493&lt;/span&gt; &lt;span&gt;0.000477&lt;/span&gt; ***&lt;span&gt;
X3C         &lt;/span&gt;-&lt;span&gt;1.77966&lt;/span&gt;    &lt;span&gt;0.51002&lt;/span&gt;  -&lt;span&gt;3.489&lt;/span&gt; &lt;span&gt;0.000484&lt;/span&gt; ***&lt;span&gt;
X3D         &lt;/span&gt;-&lt;span&gt;1.66492&lt;/span&gt;    &lt;span&gt;0.50365&lt;/span&gt;  -&lt;span&gt;3.306&lt;/span&gt; &lt;span&gt;0.000947&lt;/span&gt; ***&lt;span&gt;
X3E          &lt;/span&gt;&lt;span&gt;0.47470&lt;/span&gt;    &lt;span&gt;0.66354&lt;/span&gt;   &lt;span&gt;0.715&lt;/span&gt; &lt;span&gt;0.474364&lt;/span&gt;    
---&lt;span&gt;
Signif. codes:  &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; ‘***’ &lt;span&gt;0.001&lt;/span&gt; ‘**’ &lt;span&gt;0.01&lt;/span&gt; ‘*’ &lt;span&gt;0.05&lt;/span&gt; ‘.’ &lt;span&gt;0.1&lt;/span&gt; ‘ ’ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

(Dispersion parameter &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; binomial family taken to be &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    Null deviance: &lt;/span&gt;&lt;span&gt;552.64&lt;/span&gt;  on &lt;span&gt;999&lt;/span&gt;&lt;span&gt;  degrees of freedom
Residual deviance: &lt;/span&gt;&lt;span&gt;397.69&lt;/span&gt;  on &lt;span&gt;993&lt;/span&gt;&lt;span&gt;  degrees of freedom
AIC: &lt;/span&gt;&lt;span&gt;411.69&lt;/span&gt;&lt;span&gt;

Number of Fisher Scoring iterations: &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要内容就这么多，如果想要更详细的了解可以参考：王济川，郭志刚. Logistic 回归模型 —— 方法与应用[M]. 北京：高等教育出版社&lt;/p&gt;
&lt;p&gt;以及链接：https://www.r-bloggers.com/logistic-regression-and-categorical-covariates/&lt;/p&gt;

&lt;p&gt;版权声明：本文为博主原创文章，博客地址：http://www.cnblogs.com/Demo1589/p/8973731.html，转载请注明出处。　&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 07:21:00 +0000</pubDate>
<dc:creator>生信小码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Demo1589/p/8973731.html</dc:identifier>
</item>
<item>
<title>CRM客户关系管理系统（五） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8973351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8973351.html</guid>
<description>&lt;h2&gt;第五章、分页功能开发&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;5.1.修改BaseKingAdmin和完善前段页面显示&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;现在访问没有注册的model会报错，因为基类中没有写list_display和list_filter。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430121323967-2058741323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在基类中设置一个空列表就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; kingadmin/admin_base.py&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseKingAdmin(object):

    list_display &lt;/span&gt;=&lt;span&gt; []
    list_filter &lt;/span&gt;= []&lt;br/&gt;　　 search_fields = []
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在访问没有报错，但是没有显示出数据，需要在 build_tab_row 里面添加个判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430122315342-671847706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build_table_row(obj,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;生成一条记录的html element&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

    ele &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; admin_class.list_display:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; column_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; admin_class.list_display:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取所有字段对象&lt;/span&gt;
            column_obj =&lt;span&gt; admin_class.model._meta.get_field(column_name)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;字段对象的choices方法，如果有choices，则get_xxx_display&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; column_obj.choices:
                column_data &lt;/span&gt;= getattr(obj,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get_%s_display&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;column_name)()
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                column_data &lt;/span&gt;=&lt;span&gt; getattr(obj,column_name)
            td_ele &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; column_data
            ele &lt;/span&gt;+=&lt;span&gt; td_ele
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        td_ele &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;obj
        ele &lt;/span&gt;+= td_ele
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430123155654-11837347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在table_obj_list.html添加一个判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430123416549-1031034003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）完善前端页面显示&lt;/p&gt;
&lt;p&gt;配置了list_display的显示所有列名，没配置的应该显示model name&lt;/p&gt;
&lt;p&gt;table_obj_lsit.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead
                &lt;/span&gt;&lt;span&gt;&amp;lt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    {% if admin_class.list_display %}
                        {% for column in admin_class.list_display %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ column }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    {% else %}
                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{% get_model_name admin_class %}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    {% endif %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_model_name(admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;获取表名&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; admin_class.model._meta.model_name.upper()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端显示效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430125137830-1751058524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2.分页功能开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.11/topics/pagination/&quot;&gt;&lt;span&gt;django官网paginationg使用说明&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430132026689-660623458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;官网实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430133037530-10382150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430133943443-1451063767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （1）kingadmin/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@login_required
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; table_obj_list(request, app_name, model_name):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;取出指定model里的数据返回给前端&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;拿到admin_class后，通过它找到拿到model&lt;/span&gt;
    admin_class =&lt;span&gt; site.enable_admins[app_name][model_name]
    querysets &lt;/span&gt;=&lt;span&gt; admin_class.model.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;过滤&lt;/span&gt;
    querysets,filter_conditions =&lt;span&gt; get_filter_result(request,querysets)
    admin_class.filter_conditions &lt;/span&gt;=&lt;span&gt; filter_conditions
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分页&lt;/span&gt;
    paginator = Paginator(querysets, 2&lt;span&gt;)  
    page &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        querysets &lt;/span&gt;=&lt;span&gt; paginator.page(page)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; PageNotAnInteger:
        querysets &lt;/span&gt;= paginator.page(1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; EmptyPage:
        querysets &lt;/span&gt;=&lt;span&gt; paginator.page(paginator.num_pages)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kingadmin/table_obj_list.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;querysets&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:querysets,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:admin_class})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）table_obj_lsit.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pagination&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;step-links&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {% if querysets.has_previous %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?page={{ querysets.previous_page_number }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;previous&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {% endif %}

                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;current&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    Page {{ querysets.number }} of {{ querysets.paginator.num_pages }}.
                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

                {% if querysets.has_next %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?page={{ querysets.next_page_number }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;next&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {% endif %}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这个时候访问页面，确实实现分页了，但是点下一页会报错&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430134946114-2042592165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因为在后台把page='2'当成过滤条件了，添加个判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; kingadmin/views.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430135341056-385620415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.3.分页功能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;      &lt;span&gt;&lt;a href=&quot;https://v3.bootcss.com/components/#pagination&quot;&gt;&lt;span&gt;Bootstrap分页组件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430143338816-373502810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （1）kingadmin_tag.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; render_paginator(querysets):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;分页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    ele &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        &amp;lt;ul class=&quot;pagination&quot;&amp;gt;
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;page_range是所有的页，querysets.number是当前页&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; querysets.paginator.page_range:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示前后三页，abs是绝对值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; abs(querysets.number - i) &amp;lt; 3&lt;span&gt;:
            active &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; querysets.number == i:     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果是当前页,class='active'&lt;/span&gt;
                active = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            p_ele &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;&amp;lt;li class=&quot;%s&quot;&amp;gt;&amp;lt;a href=&quot;?page=%s&quot;&amp;gt;%s&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;%&lt;span&gt;(active,i,i)
            ele &lt;/span&gt;+=&lt;span&gt; p_ele
    ele &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; mark_safe(ele)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）table_obj_list.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430151501158-639095598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430151536907-1649836095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 代码已同步 &lt;a href=&quot;https://github.com/derek-zhang123/PerfectCRM&quot;&gt;'num5 完善前段页面显示和分页功能开发'&lt;/a&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 07:21:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8973351.html</dc:identifier>
</item>
<item>
<title>【C#复习总结】匿名类型由来 - mhq_martin</title>
<link>http://www.cnblogs.com/mhq-martin/p/8973686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mhq-martin/p/8973686.html</guid>
<description>&lt;h2&gt;1 属性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这得先从属性开始说，为什么外部代码访问对象内部的数据用属性而不是直接访问呢，这样岂不是更方便一些，但是事实证明直接访问是不安全的。那么，&lt;/span&gt;&lt;span&gt;Anders Hejlsberg&lt;/span&gt;&lt;span&gt;（安德斯·海尔斯伯格）就为&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;加入了属性这种语法糖，用起来跟数据成员一样，但实际上是&lt;/span&gt; &lt;span&gt;setXX()&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;getXX()&lt;/span&gt;&lt;span&gt;，既安全又方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;属性：是访问对象的首选方式，因为它们禁止外部代码访问对象内部的数据存储机制的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; MyIntProp
{
    &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;property get code&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Proerty set code&lt;/span&gt;
&lt;span&gt;    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.1 get&lt;span&gt;关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;get&lt;span&gt;块必须有一个属性的返回值，&lt;/span&gt;简单的属性一般与私有字段相关联，以控制对这个字段的访问&lt;span&gt;，此时&lt;/span&gt;get&lt;span&gt;块可以直接返回该字段的值，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; myInt;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; myIntProp
{
　　&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
　　{
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myInt;
　　}
　　&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
　　{
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Property set code.&lt;/span&gt;&lt;span&gt;
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类外部的代码不能直接访问这个&lt;/span&gt;myInt&lt;span&gt;字段，私有的，必须使用属性来访问该字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.2 set&lt;span&gt;关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;set&lt;span&gt;函数以类似的方法把一个值赋给字段。这里使用&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;表示用户提供的属性值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; myInt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; myIntProp
{
　　&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; 
　　{
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myInt;
　　}
　　&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
　　{
　　　　myInt &lt;/span&gt;=&lt;span&gt; value;
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;value&lt;span&gt;等于类似与属性相同的值，所以如果属性和字段使用相同的类型，就不必担心数据类型转换了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个简单的属性只能直接访问&lt;/span&gt;myInt&lt;span&gt;字段。在对操作进行更多的控制的时候，属性的真正作用才能发挥出来，例如，使用下面的代码实现&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;块：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
{
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(value &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; value &amp;lt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
　　myInt &lt;/span&gt;=&lt;span&gt; value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;只用赋给属性的值在&lt;/span&gt;1~10&lt;span&gt;之间，才会改&lt;/span&gt;&lt;span&gt;myInt&lt;/span&gt;&lt;span&gt;。此时，要做一个重要的设计选择：如果使用了无效值，该怎么办：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么也不做&lt;/li&gt;
&lt;li&gt;给字段赋默认值&lt;/li&gt;
&lt;li&gt;继续执行，就好像没有发生错误一样，但记录下来该事件，以备将来分析&lt;/li&gt;
&lt;li&gt;抛出异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下，后面两个选择效果较好，选择哪个选项取决于如何使用类，以及给用户授予多少控制权。抛出异常给用户提供的控制权相当的大，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
{
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(value &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; value &amp;lt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
　　　　myInt &lt;/span&gt;=&lt;span&gt; value;
　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
　　　　&lt;span&gt;throw&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myIntProp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,value,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myIntProp must be assigned a value between 0 and 10.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这可以在使用属性的代码中通过&lt;/span&gt;try...catch...finaly&lt;span&gt;逻辑来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：属性可以使用&lt;/span&gt;virtual&lt;span&gt;、&lt;/span&gt;&lt;span&gt;override&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;span&gt;关键字，就像方法一样，但这几个关键字不能用于字段。最后，如上述，访问器可以有自己的访问性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实例： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Name;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; intVal;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Val
{
　　&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
　　{
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; intVal;
　　}
　　&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
　　{
　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; value &amp;lt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt; )
　　　　　　intVal &lt;/span&gt;=&lt;span&gt; value;
　　　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
　　　　　　&lt;span&gt;throw&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Val&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,value,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Val must be assigned a value between 0 ang 10.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
　　}
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
{
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+Name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nVal:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;Val;
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MyClass(): &lt;span&gt;this&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
{

}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyClass(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; newName)
{
　　Name &lt;/span&gt;=&lt;span&gt; newName;
　　intVal &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Creating object myobj...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　MyClass myObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MyClass(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My Object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myObj created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = -&lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;0&lt;/span&gt;; i++&lt;span&gt; )
　　{
　　　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
　　　　{
　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nAttempting to assign {0} to myObj.val...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
　　　　　　myObj.Val &lt;/span&gt;=&lt;span&gt; i;
　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value {0} assigned to myObj.val.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, myObj.Val);
　　　　}
　　　　&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
　　　　{
　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception {0} throw.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e.GetType().FullName);
　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message:\n\&quot;{0}\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e.Message);
　　　　}
　　}
　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nOutputting myObj.ToString()...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　Console.WriteLine(myObj.ToString());
　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myObj.ToString() Output.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　Console.ReadKey();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main()&lt;span&gt;中的的代码创建并使用在&lt;/span&gt;&lt;span&gt;MyClass.cs&lt;/span&gt;&lt;span&gt;中定义的&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;类的实例。实例化这个类必须使用非默认的构造函数来进行，因为&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;类的默认构造函数是私有的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Main()&lt;span&gt;试着给&lt;/span&gt;&lt;span&gt;myObj&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;的实例）的&lt;/span&gt;&lt;span&gt;Val&lt;/span&gt;&lt;span&gt;属性赋值。&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环在两次中赋值&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;try..catch...&lt;/span&gt;&lt;span&gt;结构用于检测抛出的异常。把&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;赋给属性时，会抛出&lt;/span&gt;&lt;span&gt;System.ArgumentOutOfException&lt;/span&gt;&lt;span&gt;类型的异常，&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;块中的代码会把改异常的信息输出到控制台窗口中。在下一个循环中，值&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;成功的赋给了&lt;/span&gt;&lt;span&gt;Val&lt;/span&gt;&lt;span&gt;属性，通过这个属性再把值赋给私有字段&lt;/span&gt;&lt;span&gt;intVal&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2 自动属性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;但是呢，安德斯还是觉得代码太多，还应该在优化一下，就想出了自动属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自动属性。利用自动属性，可以用简化的语法声明属性，&lt;/span&gt;C#&lt;span&gt;编译器会自动添加未键入的内容，具体而言，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编译器会声明一个用于存储属性的私有字段，并在属性的&lt;/span&gt;get&lt;span&gt;和&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;块中使用该字段（非常贴心）&lt;/span&gt;，我们无需考虑细节。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; MyIntProp

{
　　&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们按照通常的方式定义属性的可访问性、类型和名称。但是没有给&lt;/span&gt;get&lt;span&gt;和&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;块提供实现的代码。这些块的实现代码（和底层的字段）由编译器提供。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用自动属性时，只能通过属性访问数据，不能通过底层的私有字段来访问，我们不知道底层私有字段的名称（该名称是编译期间定义的）。但这并不是一个真正意义上的限制，因为可以直接使用属性名。自动属性的唯一限制是他们必须包含&lt;/span&gt;get&lt;span&gt;和&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;存储器，无法使用这种方法定义只读和只写属性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3 对象初始化器&lt;/h2&gt;
&lt;p&gt;对象初始化器定义：初始化器分为对象初始化器和集合初始化器，此处指我们讲的是对象初始化器，&lt;/p&gt;
&lt;p&gt;作用：用较少的代码创建一个新对象并为对象的若干属性和公共数据成员进行赋值。&lt;/p&gt;
&lt;p&gt;谈到初始化器，先谈一下构造函数，构造从表面意思就知道这是用来构建类的（当然初始化一些成员也是属于构建的范围，但还有其他作用）&lt;/p&gt;
&lt;p&gt;对象初始化过程：先定义类的属性，再实例化和初始化这个类。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义类的属性用自动属性来定义，实例化和初始化这个类的一个对象实例就必须用&lt;/span&gt;C#&lt;span&gt;里面的默认的无参构造函数来实现下段代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看一个类定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Curry
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MainIngredient { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Style { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Spiciness { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个类有&lt;/span&gt;3 &lt;span&gt;个属性，用自动属性语法来定义。如果希望实例化和初始化这个类的一个对象实例，就必须执行如下几个语句&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;第一种方式&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Curry tastyCurry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Curry();

tastyCurry.MainIngredient &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panir tikka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

tastyCurry.Style &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jalfrezi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

tastyCurry.Spiciness &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果类定义中未包含构造函数，这段代码就使用&lt;/span&gt;C#&lt;span&gt;编译器提供的默认无参数构造函数。&lt;/span&gt;这种方式还是有点复杂，应该还有比这个简单的，你猜对了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.第二种方式（去掉括号）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Curry tastyCurry=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Curry
{
    tastyCurry.MainIngredient &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panir tikka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，

    tastyCurry.Style &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jalfrezi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，

    tastyCurry.Spiciness &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;，
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后问题就来了，如果你有&lt;/span&gt;10&lt;span&gt;个数据成员，实例化和初始化这个类的一个对象实例要写多少个？为了简化这个过程，安德斯又机灵了一下想到了更高级的方式，采用一个合适的非默认构造函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Class tastyCurry =&lt;span&gt;new&lt;/span&gt; Curry(“panir tikka ”, “jalfrezi”,&lt;span&gt;8&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这段代码工作的很好，它会强制使用&lt;/span&gt;Curry&lt;span&gt;类的代码使用这个构造函数，这将阻止前面默认使用无参构造函数的代码运行。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4 匿名类型&lt;/h2&gt;
&lt;p&gt;你以为这样就非常方便了么，只能说你太年轻，天外有天，人外有人，看看我们的题目，对了，就是它，我们的主角，匿名类型。&lt;/p&gt;
&lt;p&gt;匿名类型提供了一种方便的方法，可用来将一组&lt;strong&gt;&lt;span&gt;只读属性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;封装到单个对象中，而无需首先显式定义一个类型。&lt;/span&gt; &lt;span&gt;类型名由编译器生成，并且不能在源代码级使用。&lt;/span&gt; &lt;span&gt;每个属性的类型由编译器推断。可通过使用&lt;/span&gt; new &lt;span&gt;运算符和对象初始值创建匿名类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来，我们举个栗子。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下示例显示了用两个名为&lt;/span&gt; Amount &lt;span&gt;和&lt;/span&gt; &lt;span&gt;Message&lt;/span&gt; &lt;span&gt;的属性进行初始化的匿名类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; v = &lt;span&gt;new&lt;/span&gt; { MainIngredient =“panir tikka ”, Style =“jalfrezi” Spiciness=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;};  

Console.WriteLine(v.MainIngredient &lt;/span&gt;+ v.Style+v.Spiciness);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看见了么，对，没错，就是这么简单。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;备注：关于&lt;/span&gt;C# &lt;span&gt;的匿名类型为什么要限制属性为只读呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来自知乎网友的一段话我觉得说的挺好的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实匿名类型是&lt;/span&gt;C# 3.0&lt;span&gt;引入的，&lt;/span&gt;&lt;span&gt;C# 3.0&lt;/span&gt;&lt;span&gt;引入的所有新特性基本都是为了实现&lt;/span&gt;&lt;span&gt;LINQ&lt;/span&gt;&lt;span&gt;这一伟大的语言特性。&lt;/span&gt;&lt;span&gt;匿名类型是为了解决&lt;/span&gt;LINQ&lt;span&gt;中选择部分字段以及多字段作为分组依据聚合或是多字段联接的问题的。&lt;/span&gt;&lt;span&gt;所以，说白了匿名类型设计的目标就是元组。匿名类型本质上就是关系模型中的元组在&lt;/span&gt;C#&lt;span&gt;里面的映射。元组显然是不可变的，匿名类型也没有必要设计成可变的来自找麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，匿名类型的由来就大致讲清楚了，主要是因为工程师要简便优化代码，匠心创作，匿名类型由此诞生。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;参考文献：【c#入门经典第五版】【&lt;a href=&quot;https://www.zhihu.com/question/24306120/answer/27364863&quot; target=&quot;_blank&quot;&gt;知乎&lt;/a&gt;】&lt;/p&gt;
&lt;div id=&quot;container&quot;&gt;
&lt;div id=&quot;leftContent&quot;&gt;&lt;img src=&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=747535597,1152462222&amp;amp;fm=27&amp;amp;gp=0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div id=&quot;rightContent&quot;&gt;
&lt;h3&gt;友情提示&lt;/h3&gt;
&lt;h3&gt;作者： &lt;a href=&quot;http://www.cnblogs.com/mhq-martin/&quot;&gt;mhq_martin&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;博客园地址： &lt;a href=&quot;http://www.cnblogs.com/mhq-martin/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/mhq-martin/&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/h3&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 30 Apr 2018 07:01:00 +0000</pubDate>
<dc:creator>mhq_martin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mhq-martin/p/8973686.html</dc:identifier>
</item>
<item>
<title>geotrellis使用（四十）优雅的处理请求超过最大层级数据 - shoufengwei</title>
<link>http://www.cnblogs.com/shoufengwei/p/8973677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufengwei/p/8973677.html</guid>
<description>&lt;p&gt;要说清楚这个题目对我来说可能都不是一件简单的事情，我简单尝试。&lt;/p&gt;
&lt;p&gt;研究 GIS 的人应该都清楚在 GIS 中最常用的技术是瓦片技术，无论是传统的栅格瓦片还是比较新颖的矢量瓦片，一旦将数据切好瓦片就会造成其层级固定，假如说 0 - 11 级，请求此层级范围内数据的时候能够正常响应，但是当用户请求超过最高级（假如为 12 ）的时候该如何处理呢？传统方式只能返回 404 ，即显示空白数据，然而有没有更好的方式呢，能够使得用户在请求超过最高级数据的时候能够优雅的并且正确的返回数据而不是直接 404。这个问题可以用手动挡汽车和自动挡汽车进行类比，传统方式就像手动挡，最大只能到 5 档，而现在的需求是希望挡位能变的更高些。但愿我已经清晰的说明了此问题，本文对此原理和实现方案进行简单探讨。&lt;/p&gt;

&lt;h2 id=&quot;原理分析&quot;&gt;1.1 原理分析&lt;/h2&gt;
&lt;p&gt;这个解决方案倒是很容易想象，当超过最大层级（以下简称 zoom）的时候（&amp;gt; 11 级）我们只需要读出最大 zoom（11 级）的此范围内数据对应的瓦片，然后将此瓦片根据此范围进行切割并重新采样到 256 * 256 即可。&lt;/p&gt;
&lt;p&gt;这里面涉及到了瓦片的金字塔体系的一些常用概念。首先层级越大表示分辨率越高，即显示出来的数据越清晰，每提高一层数据量增加4倍，即一个低层级的瓦片包含了比他高一层级的四个瓦片，整个看下来便像一个金字塔一样；而常用的每个瓦片的大小为 256 * 256，直白的说就是一个 256 * 256 的 PNG 或者 JPG 图片，当然也可以是其他尺寸，每个瓦片对应一个 x、y、z 编号，x、y 代表瓦片的行列号，z 代表瓦片的 zoom，屏幕范围内数据所有瓦片按照 x、y、z 正常排列显示出来便得到了整个地图（或者其他数据，如遥感等），就像房顶的瓦片一样，所以称为瓦片技术。有关具体技术和描述可以百度之。&lt;/p&gt;
&lt;h2 id=&quot;实现方案&quot;&gt;1.2 实现方案&lt;/h2&gt;
&lt;p&gt;有了上面的分析，其实这件事情应该已经不困难了。&lt;/p&gt;
&lt;h3 id=&quot;层级&quot;&gt;1.2.1 层级&lt;/h3&gt;
&lt;p&gt;首先获取当前数据的最大层级并判断当前请求是否大于此层级。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getMaxZoom&lt;/span&gt;(layerName: String) =
    attributeStore.&lt;span class=&quot;fu&quot;&gt;layerIds&lt;/span&gt;
      .&lt;span class=&quot;fu&quot;&gt;groupBy&lt;/span&gt;(_.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;)(layerName)
      .&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(_.&lt;span class=&quot;fu&quot;&gt;zoom&lt;/span&gt;)
      .&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;
      
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;exist&lt;/span&gt;(layerId: LayerId) = 
    attributeStore.&lt;span class=&quot;fu&quot;&gt;layerExists&lt;/span&gt;(layerId)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个函数取到当前 layerName 数据的最大层级，其中 attributeStore 为你当前 backend 的后台，可以参考此前文章。&lt;/p&gt;
&lt;p&gt;exist 函数判断当前 layerId 是否存在， layerId 包含 name 信息和 zoom 信息。当然此处你可以直接判断此 layerId 的 zoom 是否大于第一个函数取到的 maxZoom，但是此处我这么写也是埋下一个伏笔，会在后文介绍。&lt;/p&gt;
&lt;h3 id=&quot;取到请求瓦片的范围&quot;&gt;1.2.2 取到请求瓦片的范围&lt;/h3&gt;
&lt;p&gt;想要取到最大层的数据首先要取到瓦片包含数据的范围，这个范围我们只能根据所请求瓦片的 z、y、z 获得，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; layerId: LayerId = &lt;span class=&quot;fu&quot;&gt;LayerId&lt;/span&gt;(name, maxZoom)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; rmd = attributeStore.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;[TileLayerMetadata[SpatialKey]](layerId, Fields.&lt;span class=&quot;fu&quot;&gt;metadata&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; layoutLevel = &lt;span class=&quot;fu&quot;&gt;ZoomedLayoutScheme&lt;/span&gt;(rmd.&lt;span class=&quot;fu&quot;&gt;crs&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;levelForZoom&lt;/span&gt;(rmd.&lt;span class=&quot;fu&quot;&gt;extent&lt;/span&gt;, z)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; mapTransform = &lt;span class=&quot;fu&quot;&gt;MapKeyTransform&lt;/span&gt;(rmd.&lt;span class=&quot;fu&quot;&gt;crs&lt;/span&gt;, layoutLevel.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;layoutCols&lt;/span&gt;, layoutLevel.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;layoutRows&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; targetExtent = &lt;span class=&quot;fu&quot;&gt;mapTransform&lt;/span&gt;(x, y)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先取到 maxZoom 层的元数据，根据投影（rmd.crs）、范围（rmd.extent）及 zoom 信息，获取到当前 z 层的 layout，这个具体细节涉及到金字塔理论，大意是根据投影、范围和层级就可以取到瓦片的编号和范围情况，最终也正是根据 x、y 计算出瓦片数据范围 targetExtent。&lt;/p&gt;
&lt;h3 id=&quot;取到最大层级对应瓦片&quot;&gt;1.2.3 取到最大层级对应瓦片&lt;/h3&gt;
&lt;p&gt;有了瓦片的范围，我们就可以在最大曾中取出此瓦片，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GridBounds&lt;/span&gt;(nx, ny, _, _) = rmd.&lt;span class=&quot;fu&quot;&gt;mapTransform&lt;/span&gt;(targetExtent)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; sourceExtent = rmd.&lt;span class=&quot;fu&quot;&gt;mapTransform&lt;/span&gt;(nx, ny)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; maxZoomTile = tileReader.&lt;span class=&quot;fu&quot;&gt;reader&lt;/span&gt;[SpatialKey, Tile](layerId).&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;SpatialKey&lt;/span&gt;(nx, ny))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tileReader 是 ValueReader 对象，同样与所采用的 backend 有关。其中 nx、ny 正是 maxZoom 层对应的瓦片编号，此处同样用到金字塔理论，高层级的瓦片必然包含在比他层级低的某一个瓦片里，即 sourceExtent 必然能够完全覆盖 targetExtent。&lt;/p&gt;
&lt;h3 id=&quot;将瓦片重采样到所请求的-zoom&quot;&gt;1.2.4 将瓦片重采样到所请求的 zoom&lt;/h3&gt;
&lt;p&gt;现在只需要我们对获取到的瓦片进行裁切并重采样到 256 * 256 即可，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; targetTile = sourceTile.&lt;span class=&quot;fu&quot;&gt;resample&lt;/span&gt;(sourceExtent, &lt;span class=&quot;fu&quot;&gt;RasterExtent&lt;/span&gt;(targetExtent, &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;256&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就获取到了最终的请求瓦片，将此瓦片返回浏览器等其他请求源即可。&lt;/p&gt;
&lt;h2 id=&quot;效果&quot;&gt;1.3 效果&lt;/h2&gt;
&lt;p&gt;展示一下最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704456/201804/704456-20180430145839524-1746569292.png&quot; alt=&quot;11 级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704456/201804/704456-20180430145845227-937633529.png&quot; alt=&quot;12 级&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11 级瓦片是正常取得的瓦片，12 级瓦片即为通过此种方式由 11 级瓦片重采样得到的。&lt;/p&gt;

&lt;p&gt;做产品和做项目有着本质的区别，一个项目可能只需要考虑到通用情况即可，而产品则必须考虑到方方面面，还记得我在上面留的伏笔吗，在那里我没有采用判断所请求 zoom 是否大于 maxZoom 的方式，而是直接判断 exist，这里面有个逻辑问题。假如切瓦片的时候不是每一层都有切到，必然我切了 0 - 5、7 - 11，而没有切第 6 层，那么采用这种方式肯定是有问题的，并且出现这种情况的时候整个逻辑都需要重新修改，因为第 6 层的某个瓦片肯定包含了2 ^ (2 ^ 5) 个 11 层（maxZoom）的瓦片，这样我们就不能简单的只取出一个，而应该将其全部取出并进行拼接然后再重采样。&lt;/p&gt;
&lt;p&gt;再进一步思考，碰到这种方式的时候我们是不是可以取出第 5 层或者第 7 层的某个/些瓦片而不是非要 maxZoom 层的，因为接近的层数据更相似（此处牵扯到层级可视化表达的问题）。&lt;/p&gt;
&lt;p&gt;所以这些都需要我们丰富和设计好逻辑，只有这些都考虑清楚才能设计出完美的产品。具体代码此处就不放出了，如果有需要可以探讨。&lt;/p&gt;

&lt;p&gt;本文介绍了如何在所请求的瓦片层级不存在的情况时通过取出最大层或者相近层的瓦片并进行重采样操作，从而优雅的返回瓦片数据。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0481927710843&quot;&gt;
&lt;p&gt;Geotrellis系列文章链接地址&lt;a href=&quot;http://www.cnblogs.com/shoufengwei/p/5619419.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/shoufengwei/p/5619419.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 30 Apr 2018 06:59:00 +0000</pubDate>
<dc:creator>shoufengwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufengwei/p/8973677.html</dc:identifier>
</item>
<item>
<title>封装一个随机颜色的函数 - 独行的心</title>
<link>http://www.cnblogs.com/duxingdexin/p/8973675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duxingdexin/p/8973675.html</guid>
<description>&lt;p&gt;z针对一些浏览器不支持RGB这属性，为了实现一功能。则需要我们自己封装函数了！！！&lt;/p&gt;
&lt;p&gt;function randomColor(){&lt;br/&gt;         var r = Math.floor(Math.random()*256);&lt;br/&gt;         var g = Math.floor(Math.random()*256);&lt;br/&gt;         var b = Math.floor(Math.random()*256);&lt;br/&gt;         return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;十六进制颜色函数：&lt;/p&gt;
&lt;p&gt;function randomColor16(){&lt;br/&gt;         var r = Math.random(255).toString(16);&lt;br/&gt;         var g = Math.random(255).toString(16);&lt;br/&gt;         var b = Math.random(255).toString(16);&lt;br/&gt;         //255数字转化为16进制&lt;br/&gt;         if(r.length&amp;lt;2) r = &quot;0&quot;+r;&lt;br/&gt;         if(g.length&amp;lt;2) g = &quot;0&quot;+g;&lt;br/&gt;         if(b.length&amp;lt;2) b = &quot;0&quot;+b;&lt;br/&gt;         return &quot;#&quot; + r + g + b;&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 06:58:00 +0000</pubDate>
<dc:creator>独行的心</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duxingdexin/p/8973675.html</dc:identifier>
</item>
<item>
<title>深入了解Java虚拟机和内存管理 - 凝眸v</title>
<link>http://www.cnblogs.com/zj-blog/p/8934823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zj-blog/p/8934823.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.java程序的执行过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;span&gt;java源文件-&amp;gt;解析器-&amp;gt;class文件-&amp;gt;java类加载器-&amp;gt;java运行时数据区-&amp;gt;执行引擎&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180424235414269-1014728792.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.我们接下来看一下java运行时数据区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt; &lt;span&gt;包含程序计数器,虚拟机栈,本地方法栈,方法区,堆,其中程序计数器,虚拟机栈,本地方法区属于指令,方法区和堆属于数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;strong&gt;一、程序计数器&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;span&gt;用来指示程序执行哪一条指令,这跟汇编语言的程序计数器的功能在逻辑上是一样的。JVM规范中规定，如果线程执行的是非native方法，则程序计数器指向的是当前线程正在执行的字节码指令的地址和行号，如果线程执行的是native方法，则程序计数器中的值undefined。每个线程都有自己独立的程序计数器。为什么呢？因为多线程下，一个CPU内核同一时间只会执行一条线程中的指令，因此为了使每个线程在线程切换之后能够恢复到切换之前的程序执行的位置，所以每个线程都有自己独立的程序计数器。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;二、Java虚拟机栈(&lt;span&gt;VM Stack&lt;/span&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;java虚拟机栈中存放的是一个个栈帧,栈是一种数据结构,数据结构是用来存放数据的,所以虚拟机栈也是用来存放数据的。存储当前线程运行方法是所需要的  数据,指令和返回地址。当程序执行一个方法时,就会创建一个栈帧并压入栈中,执行完毕,则会从栈帧中移除栈。虚拟机栈中有:局部变量表,操作数栈,动态链接,方法出口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;局部变量表:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;span&gt;存放局部变量的表,java的基本的数据类型(&lt;span&gt;boolean、byte、char、short、int、float、long、double&lt;/span&gt;),对象的引用&lt;span&gt;（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址），其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;span&gt;操作数栈:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;          &lt;/span&gt; &lt;span&gt;虚拟机把操作数栈作为它的工作区，程序中的所有计算过程都是在借助于操作数栈来完成的，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;      &lt;/strong&gt; 动态连接:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;         每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用（指向运行时常量池：在方法执行的过程中有可能需要用到类中的常量,持有这个引用是为了支持方法调用过程中的动态连接.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt; 方法返回地址:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      本地方法栈(&lt;span&gt;Native Method Stack&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      &lt;span&gt;本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则 为虚拟机使用到的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;三、方法区(Method Area&lt;span data-mce-=&quot;&quot;&gt;）:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;          &lt;span&gt;方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等。运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 四&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;、堆(Heap&lt;span data-mce-=&quot;&quot;&gt;）:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;在C语言中，程序员可以通过malloc函数和free函数在堆上申请和释放空间。那么在Java中是怎么样的呢？Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的），几乎所有的对象实例都在这里分配内存。在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。另外，堆是被所有线程共享的，在JVM中只有一个堆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;&lt;span&gt;五&lt;/span&gt;、内存管理&lt;span data-mce-=&quot;&quot;&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;             &lt;span&gt;JVM将内存划分为6个部分：PC寄存器（也叫程序计数器）、虚拟机栈、堆、方法区、运行时常量池、本地方法栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425000239882-1510949678.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;PC寄存器（程序计数器）&lt;/strong&gt;：用于记录当前线程运行时的位置，每一个线程都有一个独立的程序计数器，线程的阻塞、恢复、挂起等一系列操作都需要程序计数器的参与，因此必须是线程私有的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;java 虚拟机栈&lt;/strong&gt;：在创建线程时创建的，用来存储栈帧，因此也是线程私有的。java程序中的方法在执行时，会创建一个栈帧，用于存储方法运行时的临时数据和中间结果，包括局部变量表、操作数栈、动态链接、方法出口等信息。这些栈帧就存储在栈中。如果栈深度大于虚拟机允许的最大深度，则抛出StackOverflowError异常。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部变量表：方法的局部变量列表，在编译时就写入了class文件&lt;/li&gt;
&lt;li&gt;操作数栈：int x = 1; 就需要将 1 压入操作数栈，再将 1 赋值给变量x&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;java堆&lt;/strong&gt;：java堆被所有线程共享，堆的主要作用就是存储对象。如果堆空间不够，但扩展时又不能申请到足够的内存时，则抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425000516234-475484745.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     &lt;strong&gt;六&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;、垃圾回收机制&lt;span data-mce-=&quot;&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425001042147-1312233796.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425001449512-1752298324.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    (2)、可达性分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    设立若干根对象（GC Root），每个对象都是一个子节点，当一个对象找不到根时，就认为该对象不可达。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425001844797-850929168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、怎么回收？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;        标记——清除算法&lt;/li&gt;
&lt;li&gt;       复制算法&lt;/li&gt;
&lt;li&gt;       分代算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;      (1)、标记——清除算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      遍历所有的GC Root，分别标记处可达的对象和不可达的对象，然后将不可达的对象回收。&lt;/p&gt;
&lt;p&gt;      缺点是：效率低、回收得到的空间不连续&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      (2)、复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     将内存分为两块，每次只使用一块。当这一块内存满了，就将还存活的对象复制到另一块上，并且严格按照内存地址排列，然后把已使用的那块内存统一回   收。&lt;/p&gt;
&lt;p&gt;       优点是：能够得到连续的内存空间 &lt;br/&gt;       缺点是：浪费了一半内存&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;      (3)、分代算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     在java中，把内存中的对象按生命长短分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;     新生代：活不了多久就go die 了，比如局部变量&lt;/li&gt;
&lt;li&gt;     老年代：老不死的，活的久但也会go die，比如一些生命周期长的对象&lt;/li&gt;
&lt;li&gt;     永久代：千年王八万年龟，不死，比如加载的class信息&lt;/li&gt;
&lt;li&gt;     有一点需要注意：新生代和老年代存储在java虚拟机堆上 ；永久代存储在方法区上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/754814/201804/754814-20180425002821981-415156051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     补充：java finalize()方法：&lt;/p&gt;
&lt;p&gt;    在被GC回收前，可以做一些操作，比如释放资源。有点像析构函数，但是一个对象只能调用一次finalize()方法。&lt;/p&gt;


</description>
<pubDate>Mon, 30 Apr 2018 06:55:00 +0000</pubDate>
<dc:creator>凝眸v</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zj-blog/p/8934823.html</dc:identifier>
</item>
<item>
<title>进程间通信——XSI IPC之消息队列 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/8893857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/8893857.html</guid>
<description>
&lt;p&gt; 进程间通信XSI IPC有3种：消息队列、共享内存、信号量。它们之间有很多相似之处，但也有各自的特殊的地方。消息队列作为其中比较简单的一种，它会有些什么东西呢，来一起探讨探讨。。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;strong&gt;结构&lt;/strong&gt;&lt;/span&gt;  &lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法. 每个数据块都被认为是一个类型，接受进程接收的数据块可以有不同的&lt;/span&gt;类型值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过发送消息来避免命名管道的同步和阻塞问题。 消息队列与管道不同的是，消息队列是基于消息的，而管道是基于字节流的，且消息队列的读取不一定是先入先出.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;命名管道：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180429133054327-1924529614.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180429132606076-155024806.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;236&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;消息队列与命名管道有一个不足，就是每个消息最大长度是有上限的.而且还注意消息队列的生命周期是伴随内核的. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以如果你没有显示的删除它，那么在关机前它一直在.这里的消息队列我们可以看成一个链表队列，具体为什么？ 让我们来看看消息队列的结构.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息队列结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tp@tp:&lt;strong&gt;  more  /usr/include/linux/msg.h&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430105120371-790108113.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;387&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此结构定义了队列的当前状态。这里的&lt;/span&gt;&lt;span&gt;&lt;span&gt;_firs&lt;span&gt;t和_last便说明队列的链式结构，它们分别是消息队列的头、尾指针。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;初此以外，我们可能还会疑问这个结构是如何表示出这个消息队列的？举个例子，就是我要找出消息队列的&lt;span&gt;&quot;身份证&quot;.不妨&lt;span&gt;调出&lt;span&gt; &lt;span&gt;struct msqid_ds&lt;span&gt;结构体的第一个条目，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;也就是&lt;span&gt;IPC&lt;span&gt;的共有结构体，我们再看看它的结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180429142650127-462893557.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;291&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该结构体中第一个成员key，其实就是消息队列的唯一标识，想找到一个消息队列就是靠它来找,这个我们待会会说到&lt;span&gt;的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;基本命令&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统能创建多少个消息队列？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;span&gt;cat  /proc/sys/kernel/msgmni&lt;span&gt;查看&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;每个消息队列能装多少个字节？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用&lt;span&gt;cat  /proc/sys/kernel/msgmnb&lt;/span&gt;查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;队列中每一条基类最大是多大？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 用&lt;span&gt;cat  /proc/sys/kernel/msgmax&lt;/span&gt;查看&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;显示消息队列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;　ipcs -q      //s:status&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430111257045-1147507608.png&quot; alt=&quot;&quot; width=&quot;698&quot; height=&quot;143&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　 &lt;span&gt;&lt;span&gt;ipcs&lt;/span&gt; （SystemV IPC系列都可以看）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430111457229-713799349.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来手工删除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;ipcrm -q msqid&lt;/span&gt;   (此例对应65536）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430111927302-1747898778.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;101&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 相关函数&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;1.创建消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　原型：&lt;strong&gt;&lt;span&gt;int msgget(key_t key,     int  msgflg ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回值：-1 返回失败， 个数限制， 打开别人队列没权限。0  成功  id标识已打开的消息队列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　key_t key    //相当于文件名，&lt;span&gt;也可以由函数ftok生产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  int  msgflg   //指定消息队列创建。一般是IPC_CREAT  0644  或者0 （为0 则代表由操作系统自动选择）　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.往消息队列中写数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原型：&lt;span&gt;&lt;strong&gt;int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　void* msgp     //想写入消息队列数据的地址，是&lt;span&gt;&lt;span&gt;&lt;span&gt;指向消息缓冲区的指针，此位置用来暂时存储发送接收消息，是一个用户可定义的通用结构，形态如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msgbuf
{

　　&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; mtype;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k接收类型，可看作消息队列通道号channel   ,同时必须&amp;gt; 0&lt;/span&gt;

　　&lt;span&gt;char&lt;/span&gt; mtext[&lt;span&gt;100&lt;/span&gt;]   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放内容&lt;/span&gt;
}；
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;　　size_t msgsz   //消息大小， 不算上通道号大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　int msgflg     //一般输入0，由操作系统自行选择&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.从消息队列中读数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　原型：&lt;span&gt;&lt;strong&gt;ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;int msgflg)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　void *msgp      //接收的消息放在那里&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　size_t msgsz    //接收消息的地方大小，不算上通道号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　long msgtyp 　  //&lt;span&gt;&lt;span&gt;&lt;span&gt;从消息队列内读取的消息形态（选择何种通道）。值为0，表示消息队列中的所有消息都读取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;int msgflg      //0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;注意msgflg这个参数&lt;/span&gt;，它用来核心程序在队列没有数据的情况的下所采取的行动.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果msgflg和常数IPC_NOWAIT合用，在msgsnd()执行时若是消息队列已满，则&lt;/span&gt;msgsnd()不会阻塞，而会立即返回-1，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果执行的是msgrcv()，则在消息队列呈空时，不做等待马上返回-1，并设定错误码ENOMSG。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当msgflg为0时，msgsnd()及msgrcv()在队列呈满或呈空的情形时，采取阻塞等待的处理方式.&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;4.&lt;strong&gt;设置消息队列属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原型：&lt;span&gt;&lt;strong&gt;int msgctl(int msqid,int cmd, struct msqid_ds *buf)&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; int cmd&lt;/strong&gt;  &lt;/span&gt;    &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;msgctl系统调用函数对msgqid标识的消息队列执行cmd设置。操作系统定义了常见的3种cmd操作：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　IPC_STAT&lt;span&gt;:&lt;span&gt;该命令用来获取消息队列对应的msqid_ds数据结构,并将其保存到buf指定的地址空间.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　IPC_SET&lt;span&gt;:&lt;span&gt;该命令用来设置消息队列的属性，要设置的属性存储在buf中.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　IPC_RMID&lt;span&gt;:&lt;span&gt;从内核中删除msqid标识的消息队列.函数调用删除消息队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;struct msqid_ds *buf)&lt;/span&gt;;   //cmd不是IPC_STAT 可设置为0，自动选择&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;消息队列应用&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小练习：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建客户端（client）和服务端(server) ,使得不同的client端可以通过消息队列向server端发送请求，server端分别对client做出回应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路：大致如图 （channel 相当于消息类型）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430125006591-1180024259.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;实现代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;server.c&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ec8da1c2-e0e8-4271-a0d4-93109ba64b44')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_ec8da1c2-e0e8-4271-a0d4-93109ba64b44&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ec8da1c2-e0e8-4271-a0d4-93109ba64b44&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ec8da1c2-e0e8-4271-a0d4-93109ba64b44',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ec8da1c2-e0e8-4271-a0d4-93109ba64b44&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
  &lt;span&gt;2&lt;/span&gt; #include&amp;lt;stdlib.h&amp;gt;
  &lt;span&gt;3&lt;/span&gt; #include&amp;lt;sys/ipc.h&amp;gt;
  &lt;span&gt;4&lt;/span&gt; #include&amp;lt;sys/msg.h&amp;gt;
  &lt;span&gt;5&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
  &lt;span&gt;6&lt;/span&gt; #include&amp;lt;unistd.h&amp;gt;
  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msgbuf{
  &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; channel ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通道号&lt;/span&gt;
  &lt;span&gt;9&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; mtext[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; };
 &lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
 &lt;span&gt;12&lt;/span&gt; 
 &lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; id = msgget(&lt;span&gt;12345&lt;/span&gt;, IPC_CREAT|&lt;span&gt;0600&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息队列&lt;/span&gt;
 &lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(id == -&lt;span&gt;1&lt;/span&gt;) perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgget&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
 &lt;span&gt;18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;     {
 &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msgbuf mb;
 &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         memset(&amp;amp;mb, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(mb));
 &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(msgrcv(id ,&amp;amp;mb, &lt;span&gt;100&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) == -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从消息队列接收client端送来数据&lt;/span&gt;
 &lt;span&gt;23&lt;/span&gt;             perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgrcv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
 &lt;span&gt;25&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get from Client:%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, mb.mtext+ &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;&lt;span&gt;));
 &lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;      fflush(stdout);&lt;/span&gt;
 &lt;span&gt;27&lt;/span&gt;         mb.channel = *(&lt;span&gt;long&lt;/span&gt;*)(mb.mtext); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将头4个字节强转赋值给队列通道号&lt;/span&gt;
 &lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送回消息队列&lt;/span&gt;
 &lt;span&gt;29&lt;/span&gt;         msgsnd(id, &amp;amp;mb, strlen(mb.mtext+&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;)) + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;     }
 &lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
 &lt;span&gt;32&lt;/span&gt;&lt;span&gt; }
 &lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server.c&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;client.c&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e121dcf5-efb4-43a7-8084-4e846aa2b740')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_e121dcf5-efb4-43a7-8084-4e846aa2b740&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e121dcf5-efb4-43a7-8084-4e846aa2b740&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e121dcf5-efb4-43a7-8084-4e846aa2b740',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e121dcf5-efb4-43a7-8084-4e846aa2b740&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
  &lt;span&gt;2&lt;/span&gt; #include&amp;lt;stdlib.h&amp;gt;
  &lt;span&gt;3&lt;/span&gt; #include&amp;lt;sys/ipc.h&amp;gt;
  &lt;span&gt;4&lt;/span&gt; #include&amp;lt;sys/msg.h&amp;gt;
  &lt;span&gt;5&lt;/span&gt; #include&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
  &lt;span&gt;6&lt;/span&gt; #include&amp;lt;unistd.h&amp;gt;
  &lt;span&gt;7&lt;/span&gt; 
  &lt;span&gt;8&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msgbuf
  &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; channel;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列通道号&lt;/span&gt;
 &lt;span&gt;11&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; mtext[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
 &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt; };
 &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
 &lt;span&gt;14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; id = msgget(&lt;span&gt;12345&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(id == -&lt;span&gt;1&lt;/span&gt;) perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgget&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;     {
 &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; msgbuf mb,rcv;
 &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         memset(&amp;amp;mb, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(mb));
 &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从stdin读入数据到mb.mtext后移sizeof(long)字节出&lt;/span&gt;
 &lt;span&gt;23&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(fgets(mb.mtext+&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;), &lt;span&gt;100&lt;/span&gt;- &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;), stdin) !=&lt;span&gt; NULL)
 &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;         {
 &lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             *(&lt;span&gt;long&lt;/span&gt;*)mb.mtext = getpid(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头部赋值为pid&lt;/span&gt;
 &lt;span&gt;26&lt;/span&gt;             mb.channel = &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选用通道号 1&lt;/span&gt;
 &lt;span&gt;27&lt;/span&gt; 
 &lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送到消息队列. 注意对发送大小的处理&lt;/span&gt;
 &lt;span&gt;29&lt;/span&gt;             msgsnd(id, &amp;amp;mb, strlen(mb.mtext+ &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;))+&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send ok!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
 &lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从消息队列获取&lt;/span&gt;
 &lt;span&gt;33&lt;/span&gt;             memset(&amp;amp;rcv, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(rcv));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
 &lt;span&gt;34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(msgrcv(id, &amp;amp;rcv, &lt;span&gt;100&lt;/span&gt;, (&lt;span&gt;long&lt;/span&gt;)getpid(), &lt;span&gt;0&lt;/span&gt;) ==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgrcv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message back: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, rcv.mtext + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;&lt;span&gt;));
 &lt;/span&gt;&lt;span&gt;37&lt;/span&gt;&lt;span&gt;         }
 &lt;/span&gt;&lt;span&gt;38&lt;/span&gt;&lt;span&gt;     }
 &lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client.c&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;相关makefile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430154757943-1550277666.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;大致使用这些函数便简单地实现了双向通信，&lt;strong&gt;效果就像这样&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180430135350964-789073913.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后总结，&lt;/strong&gt;消息队列相对命名管道优势。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;&lt;span readability=&quot;3&quot;&gt;&lt;span&gt;消息队列与命名管道相比，消息队列的优势在于：&lt;/span&gt;&lt;p&gt;&lt;span&gt;　　1.消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;　　2.基于发送消息机制，避免了像命名管道存在的同步、阻塞问题，不需要由进程自己来提供同步方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;　　3.接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样默认地接收数据。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　4.实现了双向通信&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 06:06:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/8893857.html</dc:identifier>
</item>
<item>
<title>JavaScript原型与原型链 - qfstudy</title>
<link>http://www.cnblogs.com/qfstudy/p/8973373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qfstudy/p/8973373.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、数据类型&lt;/strong&gt;&lt;br/&gt;JavaScript的数据类型可以分为基本数据类型和引用数据类型。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本数据类型(6种)&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Number&lt;/li&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;Symbol(ES6)&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;引用数据类型&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;二、面向对象编程&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;构造函数
&lt;ul&gt;&lt;li&gt;面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。&lt;/li&gt;
&lt;li&gt;JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;2. new命令&lt;/strong&gt;&lt;br/&gt;new命令的作用，就是执行构造函数，返回一个实例对象。&lt;/p&gt;
&lt;p&gt;new 命令的原理&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个空对象，作为将要返回的对象实例。&lt;/li&gt;
&lt;li&gt;将这个空对象的原型，指向构造函数的prototype属性。&lt;/li&gt;
&lt;li&gt;将这个空对象赋值给函数内部的this关键字。&lt;/li&gt;
&lt;li&gt;开始执行构造函数内部的代码。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，返回this对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var Fn=function(){
    this.name='xxx';
    this.old=18;
}
var f1=new Fn();
console.log(f1.name);//xxx
console.log(f1.old);//18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码通过new命令，让构造函数Fn生成一个实例对象，保存在变量f1中。这个新生成的实例对象，从构造函数Fn得到了name和old属性。new命令执行时，构造函数内部的this，就代表了新生成的实例对象,this.name和this.old是实例对象的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var Fn2=function(){
    name='xxx';
    old=18;
}
var f2=new Fn2();
console.log(f2.name);//undefined
console.log(f2.old);//undefined
f2.name='yyy';
console.log(f2.name);//yyy&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;三、原型与原型链&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象是函数创建的，而函数却又是一种对象。也是属性的集合，可以对函数进行自定义属性。&lt;br/&gt;每个函数都有一个属性叫做prototype。&lt;br/&gt;这个prototype的属性值是一个对象，默认的只有一个叫做constructor的属性，指向这个函数本身。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var Fn=function(){
    this.name='xxx';
    this.old=18;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9437556-92397e323138aeca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;383c2593-d64d-4f43-b513-1ad8c252aa29.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到上面new命令的原理的第二条，从这张图可以看到对象的原型，指向构造函数的prototype属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f1.__proto__&lt;/code&gt;指向构造函数的prototype属性,就是对象的原型。所以&lt;code&gt;f1.__proto__===Fn.prototype为true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;prototype的属性值是一个对象，默认的只有一个叫做constructor的属性，指向这个函数本身。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9437556-495c1161dc9d3b01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;029084da-917f-40e5-bea7-393ec5993b63.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;左边为Fn函数，右边就是它的原型&lt;/p&gt;
&lt;p&gt;在上面可以看到&lt;code&gt;f1.__proto__===Fn.prototype&lt;/code&gt;的结果为&lt;code&gt;true&lt;/code&gt;&lt;br/&gt;&lt;code&gt;__proto__&lt;/code&gt;就是指向构造函数的prototype属性，&lt;code&gt;Fn.prototype&lt;/code&gt;就是对象的原型&lt;/p&gt;
&lt;p&gt;即,每个由构造函数创建的对象都有一个__proto__属性，指向创建该对象的函数的prototype。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基于以上，我们得到一个重要的公式&lt;br/&gt;&lt;code&gt;var 对象名 = new 函数名()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;对象名.__proto__=== 函数名.prototype&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;&lt;code&gt;自定义函数.__proto__指向Function.prototype&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.__proto__指向Function.prototype&lt;/code&gt;即&lt;code&gt;Object.__proto__ === Function.prototype//true&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Function.__proto__指向Function.prototype&lt;/code&gt;:Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建。所以Function是被自身创建的。所以它的__proto__指向了自身的Prototype。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function.prototype.__proto__===Object.prototype//true&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Object.prototype确实一个特例——它的__proto__指向的是null&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对象是函数创建的，而函数却又是一种对象。也是属性的集合&lt;/li&gt;
&lt;li&gt;每个函数都有一个属性叫做prototype。&lt;/li&gt;
&lt;li&gt;对象的原型，指向构造函数的prototype属性。&lt;/li&gt;
&lt;li&gt;prototype的属性值是一个对象，默认的只有一个叫做constructor的属性，指向这个函数本身。&lt;/li&gt;
&lt;li&gt;原型既然作为对象，属性的集合，可以自定义的增加许多属性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总之记住下面这几个要点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Object对象是由Function函数创建的&lt;/li&gt;
&lt;li&gt;所有函数都是由Function创建的,函数也是对象&lt;/li&gt;
&lt;li&gt;重要的公式&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;var 对象名 = new 函数名()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;对象名.__proto__=== 函数名.prototype&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;普通函数的prototype属性值是一个对象，且这个对象只有一个属性constructor，没有__proto__这个属性。&lt;/li&gt;
&lt;li&gt;Function.prototype有&lt;code&gt;__proto__&lt;/code&gt;这个属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.__proto__===null&lt;/code&gt;结果为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 30 Apr 2018 04:31:00 +0000</pubDate>
<dc:creator>qfstudy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qfstudy/p/8973373.html</dc:identifier>
</item>
<item>
<title>【图解数据结构】二叉查找树 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8973217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8973217.html</guid>
<description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树定义&quot;&gt;二叉查找树定义&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每棵子树头节点的值都比各自左子树上所有节点值要大，也都比各自右子树上所有节点值要小。&lt;/p&gt;
&lt;p&gt;二叉查找树的中序遍历序列一定是从小到大排列的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二叉查找树节点定义&quot;&gt;二叉查找树节点定义&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 二叉查找树节点
/// &amp;lt;/summary&amp;gt;
public class Node
{
    /// &amp;lt;summary&amp;gt;
    /// 节点值
    /// &amp;lt;/summary&amp;gt;
    public int Data { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 左子节点
    /// &amp;lt;/summary&amp;gt;
    public Node Left { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 右子节点
    /// &amp;lt;/summary&amp;gt;
    public Node Right { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 打印节点值
    /// &amp;lt;/summary&amp;gt;
    public void DisplayNode()
    {
        Console.Write(Data + &quot; &quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;插入节点&quot;&gt;插入节点&lt;/h2&gt;
&lt;p&gt;二叉查找树的插入节点操作相对比较简单，只需要找到要插入节点的位置放置即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;插入节点的整体流程：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;把父节点设置为当前节点，即根节点。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果新节点内的数据值小于当前节点内的数据值，那么把当前节点设置为当前节点的左子节点。如果新节点内的数据值大于当前节点内的数据值，那么就跳到步骤 4。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果当前节点的左子节点的数值为空（null），就把新节点插入在这里并且退出循环。否则，跳到 while 循环的下一次循环操作中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;把当前节点设置为当前节点的右子节点。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果当前节点的右子节点的数值为空（null），就把新节点插入在这里并且退出循环。否则，跳到 while 循环的下一次循环操作中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class BinarySearchTree
{
    public Node root;
    public BinarySearchTree()
    {
        root = null;
    }
    /// &amp;lt;summary&amp;gt;
    /// 二叉查找树插入结点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;i&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public void Insert(int i)
    {
        Node newNode = new Node
        {
            Data = i
        };
        if (root == null)
        {
            root = newNode;
        }
        else
        {
            Node current = root;
            Node parent;
            while (true)
            {
                parent = current;
                if (i &amp;lt; current.Data)
                {
                    current = current.Left;
                    if (current == null)
                    {
                        parent.Left = newNode;
                        break;
                    }
                }
                else
                {
                    current = current.Right;
                    if (current == null)
                    {
                        parent.Right = newNode;
                        break;
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为二叉查找树的中序遍历序列一定是由小到大排列的，所以我们可以通过中序遍历测试二叉查找树的插入操作。关于二叉树遍历操作可以移步我的上一篇博客&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8955856.html&quot;&gt;【图解数据结构】 二叉树遍历&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 二叉查找树中序遍历
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;node&quot;&amp;gt;&amp;lt;/param&amp;gt;
public void InOrder(Node node)
{
    if (node != null)
    {
        InOrder(node.Left);
        node.DisplayNode();
        InOrder(node.Right);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class BinarySearchTreeTest
{
    static void Main(string[] args)
    {
        BinarySearchTree bst = new BinarySearchTree();
        bst.Insert(23);
        bst.Insert(45);
        bst.Insert(16);
        bst.Insert(37);
        bst.Insert(3);
        bst.Insert(99);
        bst.Insert(22);         

        Console.WriteLine(&quot;中序遍历: &quot;);
        bst.InOrder(bst.root);

        Console.ReadKey();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/g7gbI0Lh4g.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的测试代码形成了一棵这样的二叉查找树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/FjkfEcLegA.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查找节点&quot;&gt;查找节点&lt;/h2&gt;
&lt;p&gt;对于 二叉查找树（BST） 有三件最容易做的事情：查找一个特殊数值，找到最小值，以及找到最大值。&lt;/p&gt;
&lt;h3 id=&quot;查找最小值&quot;&gt;查找最小值&lt;/h3&gt;
&lt;p&gt;根据二叉查找树的性质，二叉查找树的最小值一定是在左子树的最左侧子节点。&lt;/p&gt;
&lt;p&gt;所以实现很简单，就是从根结点出发找出二叉查找树左子树的最左侧子节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 查找二叉查找树最小值
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public int FindMin()
{
    Node current = root;
    while (current.Left != null)
    {
        current = current.Left;
    }
    return current.Data;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查找最大值&quot;&gt;查找最大值&lt;/h3&gt;
&lt;p&gt;根据二叉查找树的性质，二叉查找树的最大值一定是在右子树的最右侧子节点。&lt;/p&gt;
&lt;p&gt;所以实现很简单，就是从根结点出发找出二叉查找树右子树的最右侧子节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 查找二叉查找树最大值
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public int FindMax()
{
    Node current = root;
    while (current.Right != null)
    {
        current = current.Right;
    }
    return current.Data;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查找特定值&quot;&gt;查找特定值&lt;/h3&gt;
&lt;p&gt;根据二叉查找树的性质，从根结点开始，比较特定值和根结点值的大小。如果比根结点值大，则说明特定值在根结点右子树上，继续在右子节点执行此操作；如果比根结点值小，则说明特定值在根结点左子树上，继续在左子节点执行此操作。如果到执行完成都没有找到和特定值相等的节点值，那么二叉查找树中没有包含此特定值的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 查找二叉查找树特定值节点
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;key&quot;&amp;gt;特定值&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public Node Find(int key)
{
    Node current = root;
    while (current.Data != key)
    {
        if (key &amp;lt; current.Data)
        {
            current = current.Left;
        }
        if (key &amp;gt; current.Data)
        {
            current = current.Right;
        }
        // 如果已到达 BST 的末尾
        if (current == null)
        {
            return null;
        }
    }
    return current;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除节点&quot;&gt;删除节点&lt;/h2&gt;
&lt;p&gt;相对于前面的操作，二叉查找树的删除节点操作就显得要复杂一些了，因为删除节点会有破坏 BST 正确&lt;br/&gt;层次顺序的风险。&lt;/p&gt;
&lt;p&gt;我们都知道在二叉查找树中的结点可分为：没有子节点的节点，带有一个子节点的节点 ，带有两个子节点的节点 。那么可以将二叉查找树的删除节点操作简单拆分一下，以便于我们的理解。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180429/mFIg6E55D4.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除叶子节点&quot;&gt;删除叶子节点&lt;/h3&gt;
&lt;p&gt;删除叶子节点是最简单的事情。 唯一要做的就是把目标节点的父节点的一个子节点设置为空（null）。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;查看这个节点的左子节点和右子节点是否为空（null）,都为空（null）说明为叶子节点。&lt;/p&gt;
&lt;p&gt;然后检测这个节点是否是根节点。如果是，就把它设置为空（null）。&lt;/p&gt;
&lt;p&gt;否则，如果isLeftChild 为true，把父节点的左子节点设置为空（null）；如果isLeftChild 为false,把父节点的右子节点设置为空（null）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//要删除的结点是叶子结点的处理
if (current.Left == null &amp;amp;&amp;amp; current.Right == null)
{
    if (current == root)
        root = null;
    else if (isLeftChild)
        parent.Left = null;
    else
    {
        parent.Right = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除带有一个子节点的节点&quot;&gt;删除带有一个子节点的节点&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当要删除的节点有一个子节点的时候，需要检查四个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个节点的子节点可能是左子节点；&lt;/li&gt;
&lt;li&gt;这个节点的子节点可能是右子节点；&lt;/li&gt;
&lt;li&gt;要删除的这个节点可能是左子节点；&lt;/li&gt;
&lt;li&gt;要删除的这个节点可能是右子节点。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180429/8J8hmKgFlE.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//要删除的结点是带有一个子节点的节点的处理
//首先判断子结点是左子节点还是右子节点，然后再判断当前节点是左子节点还是右子节点
else if (current.Right == null)
    if (current == root)
        root = current.Left;
    else if (isLeftChild)
        parent.Left = current.Left;
    else
        parent.Right = current.Left;
else if (current.Left == null)
    if (current == root)
        root = current.Right;
    else if (isLeftChild)
        parent.Left = current.Right;
    else
        parent.Right = current.Right;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除带有两个子节点的节点&quot;&gt;删除带有两个子节点的节点&lt;/h3&gt;
&lt;p&gt;如果要删除标记为 52 的节点，需要重构这棵树。这里不能用起始节点为 54 的子树来替换它，因为 54 已经有一个左子节点了。这个问题的答案是把&lt;strong&gt;中序后继节点&lt;/strong&gt;移动到要删除节点的位置上。 当然还要区分后继节点本身是否有子节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180429/eIH2k1kcm8.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180429/2Lg0gEHb3a.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们需要了解一下&lt;strong&gt;后继节点&lt;/strong&gt;的定义。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个节点的后继节点是指，这个节点在中序遍历序列中的下一个节点。相应的，前驱节点是指这个节点在中序遍历序列中的上一个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子，下图中的二叉树中序遍历序列为: DBEAFCG，则A的后继节点为F，A的前驱节点为E。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180429/4D18lDj1jg.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了这些，删除带有两个子节点的节点的操作就可以转化为&lt;strong&gt;寻找要删除节点的后继节点并且把要删除节点的右子树赋给后继结点的右子节点&lt;/strong&gt;，这里需要注意的是如果后继节点本身有子节点，则需要将后继节点的子结点赋给后继节点父节点的左子节点。&lt;/p&gt;
&lt;p&gt;先上获取后继结点的代码，然后举个例子说明:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 获取后继结点
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;delNode&quot;&amp;gt;要删除的结点&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public Node GetSuccessor(Node delNode)
{
    //后继节点的父节点
    Node successorParent = delNode;
    //后继节点
    Node successor = delNode.Right;
    Node current = delNode.Right.Left;
    while (current != null)
    {
        successorParent = successor;
        successor = current;
        current = current.Left;
    }
    //如果后继结点不是要删除结点的右子结点，
    //则要将后继节点的子结点赋给后继节点父节点的左节点
    //删除结点的右子结点赋给后继结点作为 后继结点的后继结点
    if (successor != delNode.Right)
    {
        successorParent.Left = successor.Right;
        successor.Right = delNode.Right;
    }
    return successor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除带有两个子节点的节点的代码实现：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;//要删除的结点是带有两个子节点的节点的处理
else
{
    Node successor = GetSuccessor(current);
    if (current == root)
        root = successor;
    else if (isLeftChild)
        parent.Left = successor;
    else
        parent.Right = successor;
    //因为后继结点是要删除结点右子树的最左侧结点
    //所以后继结点的左子树肯定是要删除结点左子树
    successor.Left = current.Left;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们观察到&lt;strong&gt;删除节点的后继节点一定是删除节点右子树的最左侧节点&lt;/strong&gt;。这里有3种情况：&lt;/p&gt;
&lt;h4 id=&quot;后继节点是删除节点的子节点&quot;&gt;后继节点是删除节点的子节点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/GDh5KLh525.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除节点37，后继节点40是删除节点37的子节点。&lt;code&gt;delNode&lt;/code&gt;是结点37，&lt;code&gt;successor&lt;/code&gt;是节点40，&lt;code&gt;delNode.Right&lt;/code&gt;是节点40，&lt;code&gt;successor == delNode.Right&lt;/code&gt;,后继节点为删除节点的子节点,这种情况是最简单的。&lt;/p&gt;
&lt;h4 id=&quot;后继节点不是删除节点的子节点&quot;&gt;后继节点不是删除节点的子节点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/I0fl20bId7.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后继节点38是删除节点37右子树的最左侧节点。&lt;code&gt;delNode&lt;/code&gt;是节点37，&lt;code&gt;successor&lt;/code&gt;是节点38，&lt;code&gt;successorParent&lt;/code&gt; 是节点40,&lt;code&gt;delNode.Right&lt;/code&gt; 是节点40。&lt;code&gt;successor != delNode.Right&lt;/code&gt;，所以要将 &lt;code&gt;successorParent.Left = successor.Right;successor.Right = delNode.Right;&lt;/code&gt;。因为&lt;code&gt;successor.Right==null&lt;/code&gt;,所以&lt;code&gt;successorParent.Left = null&lt;/code&gt;。&lt;code&gt;successor.Right = delNode.Right&lt;/code&gt;,节点40成为了节点38的右子节点。因为&lt;strong&gt;删除节点的后继节点一定是删除节点右子树的最左侧节点，所以后继节点肯定没有左子节点&lt;/strong&gt;。删除节点被删除后，后继结点会补到删除节点的位置。&lt;code&gt;successor.Left = current.Left;&lt;/code&gt;,也就是删除节点的左子节点变成了后继节点的左子节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成删除节点后的搜索二叉树变为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/1iKJ1gci12.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;后继节点不是删除节点的子节点且有子节点&quot;&gt;后继节点不是删除节点的子节点且有子节点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/6FaidaCaK2.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况和上一种情况相似，唯一的区别是后继节点有子节点（注意肯定是右子节点）。也就是&lt;code&gt;successorParent.Left = successor.Right;&lt;/code&gt;,后继节点的右子节点变成后继结点父节点的左子节点。因为&lt;code&gt;successor.Right&lt;/code&gt;是节点39,所以节点40的左子节点变成了节点39。其它操作和上一种情况完全相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成删除节点后的搜索二叉树变为：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/40FDia4E5D.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;删除节点操作的整体流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把后继节点的右子节点赋值为后继节点的父节点的左子节点。&lt;/li&gt;
&lt;li&gt;把要删除节点的右子节点赋值为后继节点的右子节点。&lt;/li&gt;
&lt;li&gt;从父节点的右子节点中移除当前节点，并且把它指向后继节点。&lt;/li&gt;
&lt;li&gt;从当前节点中移除当前节点的左子节点，并且把它指向后继节点的左子节点。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;综合以上删除节点的三种情况，删除节点操作的完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 二叉查找树删除节点
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public bool Delete(int key)
{
    //要删除的当前结点
    Node current = root;
    //当前结点的父结点
    Node parent = root;
    //当前结点是否是左子树 
    bool isLeftChild = true;
    //先通过二分查找找出要删除的结点
    while (current.Data != key)
    {
        parent = current;
        if (key &amp;lt; current.Data)
        {
            isLeftChild = true;
            current = current.Left;
        }
        else
        {
            isLeftChild = false;
            current = current.Right;
        }
        if (current == null)
            return false;
    }


    //要删除的结点是叶子结点的处理
    if (current.Left == null &amp;amp;&amp;amp; current.Right == null)
    {
        if (current == root)
            root = null;
        else if (isLeftChild)
            parent.Left = null;
        else
        {
            parent.Right = null;
        }
    }

    //要删除的结点是带有一个子节点的节点的处理
    else if (current.Right == null)
        if (current == root)
            root = current.Left;
        else if (isLeftChild)
            parent.Left = current.Left;
        else
            parent.Right = current.Left;
    else if (current.Left == null)
        if (current == root)
            root = current.Right;
        else if (isLeftChild)
            parent.Left = current.Right;
        else
            parent.Right = current.Right;

    //要删除的结点是带有两个子节点的节点的处理
    else
    {
        Node successor = GetSuccessor(current);
        if (current == root)
            root = successor;
        else if (isLeftChild)
            parent.Left = successor;
        else
            parent.Right = successor;
        //因为后继结点是要删除结点右子树的最左侧结点
        //所以后继结点的左子树肯定是要删除结点左子树
        successor.Left = current.Left;
    }
    return true;
}

/// &amp;lt;summary&amp;gt;
/// 获取后继结点
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;delNode&quot;&amp;gt;要删除的结点&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public Node GetSuccessor(Node delNode)
{
    //后继节点的父节点
    Node successorParent = delNode;
    //后继节点
    Node successor = delNode.Right;
    Node current = delNode.Right.Left;
    while (current != null)
    {
        successorParent = successor;
        successor = current;
        current = current.Left;
    }
    //如果后继结点不是要删除结点的右子结点，
    //则要将后继节点的子结点赋给后继节点父节点的左节点
    //删除结点的右子结点赋给后继结点作为 后继结点的后继结点
    if (successor != delNode.Right)
    {
        successorParent.Left = successor.Right;
        successor.Right = delNode.Right;
    }
    return successor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除节点测试&quot;&gt;删除节点测试&lt;/h3&gt;
&lt;p&gt;我们还是使用中序遍历进行测试，首先构造二叉查找树：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    BinarySearchTree bst = new BinarySearchTree();
    bst.Insert(23);
    bst.Insert(45);
    bst.Insert(16);
    bst.Insert(37);
    bst.Insert(3);
    bst.Insert(99);
    bst.Insert(22);
    bst.Insert(40);
    bst.Insert(35);
    bst.Insert(38);
    bst.Insert(44);
    bst.Insert(39);
}          &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构造出的二叉查找树：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/B810BHIK8G.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试分三种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试删除叶子节点&quot;&gt;测试删除叶子节点&lt;/h4&gt;
&lt;p&gt;删除叶子节点39&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Console.Write(&quot;删除节点前: &quot;);
bst.InOrder(bst.root);

bst.Delete(39);

Console.Write(&quot;删除节点后: &quot;);
bst.InOrder(bst.root);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/6IK6b5KILC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试删除带有一个子节点的节点&quot;&gt;测试删除带有一个子节点的节点&lt;/h4&gt;
&lt;p&gt;删除带有一个子节点的节点38&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Console.Write(&quot;删除节点前: &quot;);
bst.InOrder(bst.root);

bst.Delete(38);

Console.Write(&quot;删除节点后: &quot;);
bst.InOrder(bst.root);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/2eekhC1I33.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试删除带有两个子节点的节点&quot;&gt;测试删除带有两个子节点的节点&lt;/h4&gt;
&lt;p&gt;删除带有两个子节点的节点37&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Console.Write(&quot;删除节点前: &quot;);
bst.InOrder(bst.root);

bst.Delete(37);

Console.Write(&quot;删除节点后: &quot;);
bst.InOrder(bst.root);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/GJ84gc5JIJ.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《数据结构与算法 C#语言描述》&lt;/p&gt;
&lt;p&gt;《大话数据结构》&lt;/p&gt;
&lt;p&gt;《数据结构与算法分析 C语言描述》&lt;/p&gt;
&lt;p&gt;五一大家都出去happy了,为什么我还要自己在家撸代码，是因为爱吗？是因为责任吗？都不是。是因为我的心里只有学习（其实是因为&lt;strong&gt;穷&lt;/strong&gt;）。哈哈，提前祝大家五一快乐，吃好玩好！&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;26.253521126761&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Mon, 30 Apr 2018 03:21:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8973217.html</dc:identifier>
</item>
</channel>
</rss>