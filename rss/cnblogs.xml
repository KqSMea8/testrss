<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【原】IOS兼容性之APP内fixed定位头部跳动 - 白水源</title>
<link>http://www.cnblogs.com/coder-dumeng/p/8313542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-dumeng/p/8313542.html</guid>
<description>&lt;p&gt;兼容现象：&lt;/p&gt;
&lt;p&gt;　　在App的webview里边，我们有时候会在页面里写自定义头部，会使用到fixed定位，我们想要的效果是，页面无论怎么滑动，这个自定义的头部始终是固定在顶部的，但是在ios 11以上的版本里边，问题来了，当我们快速滑动页面的时候，页面滚动期间，这个fixed定位的头部会随着页面的滑动滑上去，等到上滑动作执行完毕时，头部才又出现。这个问题在安卓及ios11以下的版本都是没有的。&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;　　直接将这个页面控制在一个盒子里边去滑动，头部相对于这个盒子进行绝对定位。但是这样写带来的副作用就是除类名为wrapper的元素外，其他元素的scrollTop属性值总是0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;bottom:0;-webkit-overflow-scrolling:touch;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;head&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Head&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrapper&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;bottom:0;overflow-y:scroll;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;para&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
              ...
              &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;para&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:31:00 +0000</pubDate>
<dc:creator>白水源</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-dumeng/p/8313542.html</dc:identifier>
</item>
<item>
<title>Python 解析构建数据大杂烩 -- csv、xml、json、excel - sherlockChen</title>
<link>http://www.cnblogs.com/sherlockChen/p/8313529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlockChen/p/8313529.html</guid>
<description>&lt;p&gt;Python 可以通过各种库去解析我们常见的数据。其中 csv 文件以纯文本形式存储表格数据，以某字符作为分隔值，通常为逗号；xml 可拓展标记语言，很像超文本标记语言 Html ，但主要对文档和数据进行结构化处理，被用来传输数据；json 作为一种轻量级数据交换格式，比 xml 更小巧但描述能力却不差，其本质是特定格式的字符串；Microsoft Excel 是电子表格，可进行各种数据的处理、统计分析和辅助决策操作，其数据格式为 xls、xlsx。接下来主要介绍通过 Python 简单解析构建上述数据，完成数据的“珍珠翡翠白玉汤”。&lt;/p&gt;


&lt;p&gt;通过标准库中的 csv 模块，使用函数 reader()、writer() 完成 csv 数据基本读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; csv
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('readtest.csv', newline='') as csvfile:
&lt;span&gt;  4&lt;/span&gt;     reader = csv.reader(csvfile)
&lt;span&gt;  5&lt;/span&gt;     for row in reader:
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(row)
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('writetest.csv', 'w', newline='') as csvfile:
&lt;span&gt;  9&lt;/span&gt;     writer = csv.writer(csvfile)
&lt;span&gt; 10&lt;/span&gt;     writer.writerrow(&quot;&lt;span&gt;onetest&lt;/span&gt;&quot;)
&lt;span&gt; 11&lt;/span&gt;     writer.writerows(&quot;&lt;span&gt;someiterable&lt;/span&gt;&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 reader() 返回迭代器， writer() 通过 writerrow() 或 writerrows() 写入一行或多行数据。两者还可通过参数 dialect 指定编码方式，默认以 excel 方式，即以逗号分隔，通过参数 delimiter 指定分隔字段的单字符，默认为逗号。&lt;/p&gt;
&lt;p&gt;在 Python3 中，打开文件对象 csvfile ，需要通过 newline='' 指定换行处理，这样读取文件时，新行才能被正确地解释；而在 Python2 中，文件对象 csvfile 必须以二进制的方式 'b' 读写，否则会将某些字节（0x1A）读写为文档结束符（EOF），导致文档读取不全。&lt;/p&gt;
&lt;p&gt;除此之外，还可使用 csv 模块中的类 DictReader()、DictWriter() 进行字典方式读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; csv
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('readtest.csv', newline='') as csvfile:
&lt;span&gt;  4&lt;/span&gt;     reader = csv.DictReader(csvfile)
&lt;span&gt;  5&lt;/span&gt;     for row in reader:
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(row['first_test'], row['last_test'])
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('writetest.csv', 'w', newline='') as csvfile:
&lt;span&gt;  9&lt;/span&gt;     fieldnames = ['first_test', 'last_test']
&lt;span&gt; 10&lt;/span&gt;     writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
&lt;span&gt; 11&lt;/span&gt;     writer.writeheader()
&lt;span&gt; 12&lt;/span&gt;     writer.writerow({'first_test': 'hello', 'last_test': 'wrold'})
&lt;span&gt; 13&lt;/span&gt;     writer.writerow({'first_test': 'Hello', 'last_test': 'World'})
&lt;span&gt; 14&lt;/span&gt;     #writer.writerows([{'first_test': 'hello', 'last_test': 'wrold'}, {'first_test': 'Hello', 'last_test': 'World'}])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 DictReader() 返回有序字典，使得数据可通过字典的形式访问，键名由参数 fieldnames 指定，默认为读取的第一行。&lt;/p&gt;
&lt;p&gt;DictWriter() 必须指定参数 fieldnames 说明键名，通过 writeheader() 将键名写入，通过 writerrow() 或 writerrows() 写入一行或多行字典数据。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;通过标准库中的 xml.etree.ElementTree 模块，使用 Element、ElementTree 完成 xml 数据的读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; from xml.etree.ElementTree &lt;span&gt;import&lt;/span&gt; Element, ElementTree
&lt;span&gt;  2&lt;/span&gt; root = Element('language')
&lt;span&gt;  3&lt;/span&gt; root.set('&lt;span&gt;name&lt;/span&gt;', 'python')
&lt;span&gt;  4&lt;/span&gt; direction1 = Element('direction')
&lt;span&gt;  5&lt;/span&gt; direction2 = Element('direction')
&lt;span&gt;  6&lt;/span&gt; direction3 = Element('direction')
&lt;span&gt;  7&lt;/span&gt; direction4 = Element('direction')
&lt;span&gt;  8&lt;/span&gt; direction1.text = 'Web'
&lt;span&gt;  9&lt;/span&gt; direction2.text = 'Spider'
&lt;span&gt; 10&lt;/span&gt; direction3.text = 'BigData'
&lt;span&gt; 11&lt;/span&gt; direction4.text = 'AI'
&lt;span&gt; 12&lt;/span&gt; root.append(direction1)
&lt;span&gt; 13&lt;/span&gt; root.append(direction2)
&lt;span&gt; 14&lt;/span&gt; root.append(direction3)
&lt;span&gt; 15&lt;/span&gt; root.append(direction4)
&lt;span&gt; 16&lt;/span&gt; #&lt;span&gt;import&lt;/span&gt; itertools
&lt;span&gt; 17&lt;/span&gt; #root.extend(chain(direction1, direction2, direction3, direction4))
&lt;span&gt; 18&lt;/span&gt; tree = ElementTree(root)
&lt;span&gt; 19&lt;/span&gt; tree.&lt;span&gt;write&lt;/span&gt;('xmltest.xml')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写 xml 文件时，通过 Element() 构建节点，set() 设置属性和相应值，append() 添加子节点，extend() 结合循环器中的 chain() 合成列表添加一组节点，text 属性设置文本值，ElementTree() 传入根节点构建树，write() 写入 xml 文件。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xml.etree.ElementTree as ET
&lt;span&gt;  2&lt;/span&gt; tree = ET.parse('xmltest.xml')
&lt;span&gt;  3&lt;/span&gt; #from xml.etree.ElementTree &lt;span&gt;import&lt;/span&gt; ElementTree
&lt;span&gt;  4&lt;/span&gt; #tree = ElementTree().parse('xmltest.xml')
&lt;span&gt;  5&lt;/span&gt; root = tree.getroot()
&lt;span&gt;  6&lt;/span&gt; tag = root.tag
&lt;span&gt;  7&lt;/span&gt; attrib = root.attrib
&lt;span&gt;  8&lt;/span&gt; text = root.text
&lt;span&gt;  9&lt;/span&gt; direction1 = root.&lt;span&gt;find&lt;/span&gt;('direction')
&lt;span&gt; 10&lt;/span&gt; direction2 = root[1]
&lt;span&gt; 11&lt;/span&gt; directions = root.&lt;span&gt;findall&lt;/span&gt;('.&lt;span&gt;//direction')&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; for direction in root.&lt;span&gt;findall&lt;/span&gt;('direction'):
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(direction.text)
&lt;span&gt; 14&lt;/span&gt; for direction in root.iter('direction'):
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(direction.text)
&lt;span&gt; 16&lt;/span&gt; root.remove(direction2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读 xml 文件时，通过 ElementTree() 构建空树，parse() 读入 xml 文件，解析映射到空树；getroot() 获取根节点，通过下标可访问相应的节点；tag 获取节点名，attrib 获取节点属性字典，text 获取节点文本；find() 返回匹配到节点名的第一个节点，findall() 返回匹配到节点名的所有节点，find()、findall() 两者都仅限当前节点的一级子节点，都支持 xpath 路径提取节点；iter() 创建树迭代器，遍历当前节点的所有子节点，返回匹配到节点名的所有节点；remove() 移除相应的节点。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，还可通过 &lt;a href=&quot;https://docs.python.org/3/library/xml.sax.html&quot; target=&quot;_blank&quot;&gt;xml.sax&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/3/library/xml.dom.minidom.html&quot; target=&quot;_blank&quot;&gt;xml.dom.minidom&lt;/a&gt; 去解析构建 xml 数据。其中 sax 是基于事件处理的；dom 是将 xml 数据在内存中解析成一个树，通过对树的操作来操作 xml；而 ElementTree 是轻量级的 dom ，具有简单而高效的API，可用性好，速度快，消耗内存少，但生成的数据格式不美观，需要手动格式化。&lt;/p&gt;


&lt;p&gt;通过标准库中的 json 模块，使用函数 dumps()、loads() 完成 json 数据基本读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt; json
&lt;span&gt;  2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; json.&lt;span&gt;dumps&lt;/span&gt;(['foo', {'bar': ('baz', None, 1.0, 2)}])
&lt;span&gt;  3&lt;/span&gt; '[&quot;&lt;span&gt;foo&lt;/span&gt;&quot;, {&quot;&lt;span&gt;bar&lt;/span&gt;&quot;: [&quot;&lt;span&gt;baz&lt;/span&gt;&quot;, null, 1.0, 2]}]'
&lt;span&gt;  4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; json.&lt;span&gt;loads&lt;/span&gt;('[&quot;&lt;span&gt;foo&lt;/span&gt;&quot;, {&quot;&lt;span&gt;bar&lt;/span&gt;&quot;:[&quot;&lt;span&gt;baz&lt;/span&gt;&quot;, null, 1.0, 2]}]')
&lt;span&gt;  5&lt;/span&gt; ['foo', {'bar': ['baz', None, 1.0, 2]}]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;json.dumps() 是将 obj 序列化为 json 格式的 str，而 json.loads() 是反向操作。其中 dumps() 可通过参数 ensure_ascii 指定是否使用 ascii 编码，默认为 True；通过参数  separators=(',', ':') 指定 json 数据格式中的两种分隔符；通过参数 sort_keys 指定是否使用排序，默认为 False。&lt;/p&gt;
&lt;p&gt;除此之外，还可使用 json 模块中的函数 dump()、load() 进行 json 数据读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; json
&lt;span&gt;  2&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('jsontest.json', 'w') as jsonfile:
&lt;span&gt;  3&lt;/span&gt;     json.&lt;span&gt;dump&lt;/span&gt;(['foo', {'bar': ('baz', None, 1.0, 2)}], jsonfile)
&lt;span&gt;  4&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('jsontest.json') as jsonfile:
&lt;span&gt;  5&lt;/span&gt;     json.&lt;span&gt;load&lt;/span&gt;(jsonfile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;功能与 dumps()、loads() 相同，但接口不同，需要与文件操作结合，多传入一个文件对象。&lt;/p&gt;


&lt;p&gt;通过 pip 安装第三方库 xlwt、xlrd 模块，完成 excel 数据的读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xlwt
&lt;span&gt;  2&lt;/span&gt; wbook = xlwt.Workbook(encoding='utf-8')
&lt;span&gt;  3&lt;/span&gt; wsheet = wbook.add_sheet('sheet1')
&lt;span&gt;  4&lt;/span&gt; wsheet.&lt;span&gt;write&lt;/span&gt;(0, 0, 'Hello World')
&lt;span&gt;  5&lt;/span&gt; wbook.save('exceltest.xls')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写 excel 数据时，通过 xlwt.Workbook() 指定编码格式参数 encoding 创建工作表，add_sheet() 添加表单，write() 在相应的行列单元格中写入数据，save() 保存工作表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xlrd
&lt;span&gt;  2&lt;/span&gt; rbook = xlrd.open_workbook('exceltest.xls')
&lt;span&gt;  3&lt;/span&gt; rsheet = book.sheets()[0]
&lt;span&gt;  4&lt;/span&gt; #rsheet = book.sheet_by_index(0)
&lt;span&gt;  5&lt;/span&gt; #rsheet = book.sheet_by_name('sheet1')
&lt;span&gt;  6&lt;/span&gt; nr = rsheet.nrows
&lt;span&gt;  7&lt;/span&gt; nc = rsheet.ncols
&lt;span&gt;  8&lt;/span&gt; rv = rsheet.row_values(0)
&lt;span&gt;  9&lt;/span&gt; cv = rsheet.col_values(0)
&lt;span&gt; 10&lt;/span&gt; cell = rsheet.cell_value(0, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读 excel 数据时，通过 xlrd.open_workbook() 打开相应的工作表，可使用列表下标、表索引 sheet_by_index()、表单名 sheet_by_name() 三种方式获取表单名，nrows 获取行数，ncols 获取列数，row_values() 返回相应行的值列表，col_values() 返回相应列的值列表，cell_value() 返回相应行列的单元格值。&lt;/p&gt;


&lt;p&gt;csv：&lt;a href=&quot;https://docs.python.org/3/library/csv.html&quot; target=&quot;_blank&quot;&gt;Python3 中的 csv&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/2/library/csv.html&quot; target=&quot;_blank&quot;&gt;Python2 中的 csv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;xml：&lt;a href=&quot;https://docs.python.org/3/library/xml.etree.elementtree.html&quot; target=&quot;_blank&quot;&gt;xml.etree.elementtree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;json：&lt;a href=&quot;https://docs.python.org/3/library/json.html&quot; target=&quot;_blank&quot;&gt;Python3 中的 json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;excel：&lt;a href=&quot;https://github.com/python-excel/xlwt&quot; target=&quot;_blank&quot;&gt;github 中的 xlwt&lt;/a&gt;、&lt;a href=&quot;https://github.com/python-excel/xlrd&quot; target=&quot;_blank&quot;&gt;github 中的 xlrd&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 15:29:00 +0000</pubDate>
<dc:creator>sherlockChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sherlockChen/p/8313529.html</dc:identifier>
</item>
<item>
<title>Maven教程（1）--maven的下载、安装与配置 - platycoden</title>
<link>http://www.cnblogs.com/platycoden/p/8313503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/platycoden/p/8313503.html</guid>
<description>&lt;p&gt;Maven下载&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;&lt;span&gt;http://maven.apache.org/download.cgi&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118230938724-634019983.png&quot; alt=&quot;&quot; width=&quot;845&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后，解压得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231010865-1118691542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Maven&lt;span&gt;目录分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bin&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;mvn&lt;/span&gt;&lt;span&gt;运行的脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;boot&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;plexus-&lt;/span&gt;&lt;span&gt;吃辣爽死我&lt;/span&gt;&lt;span&gt;rlds&lt;/span&gt;&lt;span&gt;类加载器框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;conf&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;settings.xml&lt;/span&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lib&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;运行时所需要的&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;类库&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;maven&lt;span&gt;安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;确认电脑上已经安装了&lt;/span&gt;&lt;span&gt;JDK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231041396-489203333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;环境变量的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）新建环境变量&lt;/span&gt;MAVEN_HOME&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231111115-1034763447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）设置环境变量&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231138646-2068549061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编辑&lt;/span&gt;Path&lt;span&gt;，增加“&lt;/span&gt;&lt;span&gt;%MAVEN_HOME%\bin&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）新建环境变量&lt;/span&gt;&lt;span&gt;MAVEN_OPTS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231208006-765814917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常需要设置&lt;/span&gt;MAVEN_OPTS&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;-Xms128m -Xmx512m&lt;/span&gt;&lt;span&gt;，因为&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;默认的最大可用内存往往不能够满足&lt;/span&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;span&gt;运行的需要，比如在项目较大时，使用&lt;/span&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;span&gt;生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到&lt;/span&gt;&lt;span&gt;java.lang.OutOfMemeoryError&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;验证&lt;/span&gt;&lt;span&gt;MAVEN&lt;/span&gt;&lt;span&gt;安装成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231300662-116108411.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:14:00 +0000</pubDate>
<dc:creator>platycoden</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/platycoden/p/8313503.html</dc:identifier>
</item>
<item>
<title>揭密微信跳一跳小游戏那些外挂 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8313488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8313488.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;张小龙：&lt;/strong&gt;这个游戏发布以后，其实它的效果有点超出我们的预期，我们自己开玩笑说，这个游戏突然变成了有史以来可能用户规模最大的一个游戏，因为它的DAU大概到了1点几亿，但同时出现了很多外挂，我没有想到这么小的一款游戏也会有那么多外挂，我朋友圈的朋友也打出了特别高的分，但是我相信不是他自己打出来的。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;1 月 15 日微信在广州召开 2018 年的微信公开课 Pro，张小龙不仅当场玩了一把跳一跳游戏并取得了900多的高分，还特别提到了跳一跳小游戏的外挂：&lt;/p&gt;

&lt;p&gt;在跳一跳这样一个小的游戏里面，如果一个用户看到里面有一堆外挂得了很高的分，对其他一些每天在练习，试图把自己的水平提高，而打一个高分的人就很不公平，他可能就没有动力继续去练习，继续超越自己个人的最高分数。所以这样一个行为，外挂行为其实会破坏整个系统的规则，并且让规则立即变得失效。&lt;/p&gt;

&lt;p&gt;所以，我们这个小游戏发布以后，我们就开始花了很多很多时间来打击外挂。&lt;/p&gt;

&lt;p&gt;本着钻研技术的学习态度，我对目前几款比较火的外挂进行了源码分析，总结出了它们的一些破解思路，其实这些作者都并非恶意，作为一个程序员，还有什么比用技术挑战规则，突破极限要有成就感呢？&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;跳一跳的游戏可以细分为两步骤：距离判断 + 按压模拟，这两步都有下面这些解决方案：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、距离判断：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 简单方案：像素点判断&lt;/p&gt;
&lt;p&gt;● 进阶方案：OpenCV 图像分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、按压模拟：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 简单方案：adb/wda 指令&lt;/p&gt;
&lt;p&gt;● 进阶方案：机械臂模拟手指点击（原创）&lt;/p&gt;

&lt;p&gt;下面逐一介绍这里的实现方法，非常有意思。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、距离判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 像素点判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该方法采用自目前最火的跳一跳小游戏「辅助程序」：&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/blob/master/wechat_jump_auto.py&quot;&gt;wechat_jump_game&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225314740-662408739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，我们先定义了「棋子」和「棋盘」，需要找到的两个目标点用橙色点标注，首先针对棋子的目标点的判断，可以这么做：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225343287-991978156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225403771-1979849632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而针对棋盘中心点的确认的思路则是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225640287-191167433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然还有一些其他方法来尽量缩小棋盘中心点的检测区域，这里简单介绍下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225705115-1679358304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果恰好跳到中心点，下一个棋盘中间会有白色点，则可以直接匹配中心点的色值，得到棋盘中心点，这种情况基本百发百中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225739646-67912366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225800303-1774352786.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但棋盘种类比较多，形状也各异，而且棋盘表面并非纯色，还有其他颜色，所以即使像素判断的代码里增加了很多特殊 case，依旧不能做到非常完美：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225828818-679581757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下，目前这个方案基本没有太大问题，但如果跳一跳游戏把背景改成了非线性渐变，或随机飘落一些物体，或棋盘表面更加复杂，那这里的算法就基本不可用了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. OpenCV 图像分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于像素点的判断低效而且不够健壮，而利用 OpenCV 计算机视觉库则可以从图像分析层面进一步简化判断逻辑提升效率，首先采用该方法的跳一跳小游戏「辅助程序」来自 wechat_jump_jump。它是这么得到棋子的位置的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225853256-18824017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225915787-361807072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接下来找棋盘的中心点，假如下一个棋盘存在白色的示意点，同样采用上面的模板匹配方法进行匹配，若匹配不上（匹配值小于某阈值，也许下个棋盘本身就是白色，所以灰度图分辨不出），则采用第二种方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225940568-386841718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里是否准确的精髓就在于高斯滤波去除图像噪音的临界点以及 Canny 函数中阈值的设定，需要不断调整参数到最优状态。&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230031974-1017271424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、按压模拟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. adb/wda 指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这两个分别是针对 Android 和 iOS 的命令行工具，可以将手机和电脑连接起来，并通过命令行发送指令，指令中就包含了屏幕的截图和按压模拟。不过 iOS 配置起来稍微麻烦一点，具体操作指引可以参考 这里。其核心的命令有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230107240-1981315483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，如果嫌配置麻烦，还可以通过 Android 的 AirDrop App 或 iOS 的 QuickTime 把手机屏幕投到电脑中，然后通过 Python 的 Pillow 库来截取投屏的内容，再做进一步的图像识别工作。&lt;/p&gt;

&lt;p&gt;还有一点值得一提，按压时间这部分还是有优化的空间，前面提到了跳跃距离和按压时间基本是线性关系，但越到后面可以越发现，距离并非和按压时间绝对成线性比例，因为游戏本身不是一个纯 2D 的平面场景（2.5D），所以我们测量到的直线距离在 2.5D 场景中是有变化的，虽然影响不大，但在游戏后期棋盘越来越小，距离越来越大时，容易凸现出问题来，所以关于距离的计算有几种不同的解决：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230135256-267758978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;拟合函数的细节可以参考：&lt;/p&gt;
&lt;p&gt;1）&lt;a href=&quot;https://github.com/metowolf/JumpJumpHelper&quot;&gt;https://github.com/metowolf/JumpJumpHelper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/issues/744&quot;&gt;https://github.com/wangshub/wechat_jump_game/issues/744&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/pull/841&quot;&gt;https://github.com/wangshub/wechat_jump_game/pull/841&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 机械臂模拟手指点击&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本着学术探究的态度，结合之前折腾开源硬件的经历，所以也斗胆想给跳一跳小游戏增加一点动手环节，把触摸模拟这一操作通过机械臂来物理完成，于是在万能淘宝里淘了一个一百多快钱的机械臂和部分配件，自己编写了控制代码，把按压时间传输作为机械臂按下的停留时间，想法确定后便开始购置物品：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230216568-891559270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到货后折腾一两个晚上，最后成功搭建好了，大家看看效果（电容笔偶尔还是会触碰不良）&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://v.qq.com/x/page/s05329u9gun.html&quot; target=&quot;_blank&quot;&gt;https://v.qq.com/x/page/s05329u9gun.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过对外挂程序源码的研读，学习到了非常多创新的思维，这也算是外挂留给代码世界的果实。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于腾讯WeTest手游安全测试团队&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;腾讯WeTest手游安全测试团队从2011年初开始对手游安全领域进行探索和技术积累，旨在通过提前发现游戏版本的安全漏洞，预警风险，打造出业界领先的手游安全测试技术方案，在工具上已经支持所有腾讯在研和运营的手游项目。团队通过使用与正式服同样的游戏客户端和服务器，模拟外挂工作室制作外挂的过程，依靠自身的技术积累来提高专业程度，持续保持漏洞的发现率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;目前提供了专家测试服务，希望通过提前发现游戏版本的安全漏洞，预警风险，帮助提高腾讯游戏的品牌和口碑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://wetest.qq.com/product/sr?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;服务目前已经对外开放，点击&lt;/span&gt;&lt;span&gt;http://wetest.qq.com/product/sr&lt;/span&gt;&lt;/a&gt;   &lt;span&gt;即可使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
















</description>
<pubDate>Thu, 18 Jan 2018 15:10:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8313488.html</dc:identifier>
</item>
<item>
<title>spring使用之旅（二） ---- AOP的使用 - 南京-徐成</title>
<link>http://www.cnblogs.com/njxc/p/8313391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/njxc/p/8313391.html</guid>
<description>&lt;ol&gt;&lt;li&gt;什么是AOP？&lt;/li&gt;
&lt;li&gt;AOP基本概念&lt;/li&gt;
&lt;li&gt;AOP使用--注解方式&lt;/li&gt;
&lt;li&gt;AOP使用--XML方式&lt;/li&gt;
&lt;li&gt;实例--日志&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　写在最前面的(源码地址)：&lt;/p&gt;
&lt;p&gt;　　　　https://github.com/xc83415134/spring_aop_demo&lt;/p&gt;
&lt;p&gt;一、什么是AOP？&lt;/p&gt;
&lt;p&gt;　　AOP（Aspect Oriented Programmin）即面向切面编程（或者翻译成以切面为导向的编程模式？），一种OOP延续的编程思想，将系统中非核心业务提取出来，从而将其与其所影响的对象解耦，切面就是提取出来的功能模块。切面可以帮助我们模块化横切关注点，常见的有日志、安全、事物等。&lt;/p&gt;
&lt;p&gt;　　对于一个信用卡应用程序来说，存款、取款、帐单管理是它的主关注点，日志和持久化将成为横切整个对象结构的横切关注点。&lt;/p&gt;
&lt;p&gt;二、AOP基本概念&lt;/p&gt;
&lt;p&gt;以下为维基百科部分说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;关注点（concern）：对软件工程有意义的小的、可管理的、可描述的软件组成部分，一个关注点通常只同一个特定概念或目标相关联。
主关注点（core concern）：一个软件最主要的关注点。
关注点分离（separation of concerns，SOC）：标识、封装和操纵只与特定概念、目标相关联的软件组成部分的能力，即标识、封装和操纵关注点的能力。
方法（method）：用来描述、设计、实现一个给定关注点的软件构造单位。
横切（crosscut）：两个关注点相互横切，如果实现它们的方法存在交集。
支配性分解（dominant decomposition）：将软件分解成模块的主要方式。传统的程序设计语言是以一种线性的文本来描述软件的，只采用一种方式（比如：类）将软件分解成模块；这导致某些关注点比较好的被捕捉，容易进一步组合、扩展；但还有一些关注点没有被捕捉，弥散在整个软件内部。支配性分解一般是按主关注点进行模块分解的。
横切关注点（crosscutting concerns）：在传统的程序设计语言中，除了主关注点可以被支配性分解方式捕捉以外，还有许多没有被支配性分解方式捕捉到的关注点，这些关注点的实现会弥散在整个软件内部，这时这些关注点同主关注点是横切的。
侧面（aspect）：在支配性分解的基础上，提供的一种辅助的模块化机制，这种新的模块化机制可以捕捉横切关注点。&lt;br/&gt;从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在在整个应用程序中的变动就可以很好的管理起来。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、AOP使用--注解方式&lt;/p&gt;
&lt;p&gt;　　1.启用AOP&lt;/p&gt;
&lt;p&gt;　　以下为启用AspectJ自动代理，同时需声明Spring aop 命名空间（注意标红的部分）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;context:annotation-config /&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;foo.bar&quot;/&amp;gt;

    &amp;lt;!--启用aspectj自动代理--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.定义被监听类&lt;/p&gt;
&lt;p&gt;　　普通的类，待监听对象无特殊&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observed;

import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/16.
 * 说话的人A
 */&lt;span&gt;
@Component
public class&lt;span&gt; HelloByAnnotation {
    public void&lt;span&gt; sayHello(String arg) {
        System.out.println(arg);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.定义切面&lt;/p&gt;
&lt;p&gt;　　首先加入@Component注解，让spring扫描到，注入spring容器中。加入@Aspect注解，声明其为切面，再通过@Pointcut注解表面某一方法为切点，（括号内：execution表明为在方法执行时触发，*为返回任意类型，后面紧跟的为指定方法，String为接收参数类型，&amp;amp;&amp;amp;表示并且，arg为接收的参数）。其他注解：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;注解&lt;/td&gt;
&lt;td&gt;通知&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@After&lt;/td&gt;
&lt;td&gt;通知方法在目标方法返回或抛出异常后调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@AfterReturning&lt;/td&gt;
&lt;td&gt;通知方法在目标方法返回后调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@AfterThrowing&lt;/td&gt;
&lt;td&gt;通知方法在目标方法抛出异常后&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Around&lt;/td&gt;
&lt;td&gt;通知方法在目标方法封装起来&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Before&lt;/td&gt;
&lt;td&gt;通知方法在目标方法调用前执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observer;

import&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*&lt;span&gt;;
import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/16.
 *
 * 大脑活动
 * 执行顺序：
 *   {@link Around} -&amp;gt; {@link Before} -&amp;gt; 目标方法 -&amp;gt; {@link Around}
 *        -&amp;gt; {@link After}
 *        -&amp;gt; {@link AfterReturning} 或 {@link AfterThrowing}
 */&lt;span&gt;
@Component
@Aspect
public class&lt;span&gt; brain {

    /**
     * 定义切点
     * *:返回任意
     * *.sayHello:指定方法
     * String:指定接收类型
     * arg:指定接收参数
     */&lt;span&gt;
    @Pointcut(&quot;execution(* foo.bar.observed.HelloByAnnotation.sayHello(String)) &amp;amp;&amp;amp; args(arg)&quot;&lt;span&gt;)
    public void&lt;span&gt; speak(String arg){}

    /**
     * 目标方法调用前执行
     */&lt;span&gt;
    @Before(&quot;speak(arg)&quot;&lt;span&gt;)
    public void&lt;span&gt; think(String arg){
        System.out.println(&quot;1.说话前要注意三思而后行:&quot; +&lt;span&gt; arg);
    }

    /**
     * 目标方法返回后执行
     */&lt;span&gt;
    @AfterReturning(&quot;speak(arg)&quot;&lt;span&gt;)
    public void&lt;span&gt; listen(String arg){
        System.out.println(&quot;2.说完后要虚心接受长辈的教诲&quot;&lt;span&gt;);
    }

    /**
     * 目标方法抛出异常后
     */&lt;span&gt;
    @AfterThrowing(&quot;speak(arg)&quot;&lt;span&gt;)
    public void&lt;span&gt; reflection(String arg){
        System.out.println(&quot;3.说错话后要反思为什么&quot;&lt;span&gt;);
    }

    /**
     * 目标方法前、后执行两次
     */&lt;span&gt;
    @Around(&quot;speak(arg)&quot;&lt;span&gt;)
    public void doThings(ProceedingJoinPoint joinPoint, String arg) throws&lt;span&gt; Throwable {
        System.out.println(&quot;4.准备干点其他事&quot;&lt;span&gt;);
        joinPoint.proceed();
        System.out.println(&quot;4.其他事做完&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4.执行main测试（执行前，可以先看下第5步）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar;

import&lt;span&gt; foo.bar.observed.HelloByAnnotation;
import&lt;span&gt; foo.bar.observed.IDeclareHello;
import&lt;span&gt; org.springframework.context.ApplicationContext;
import&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

public class&lt;span&gt; HelloApp {
    public static void&lt;span&gt; main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;&lt;span&gt;);
        excuteByAnnotion(context);
    }

    /**
     * 基于注解配置
     * @param context
     */
    private static void&lt;span&gt; excuteByAnnotion(ApplicationContext context) {
        HelloByAnnotation helloByAnnotation = context.getBean(HelloByAnnotation.class&lt;span&gt;);
        helloByAnnotation.sayHello(&quot;Hello world!  -- by annotation&quot;&lt;span&gt;);

        IDeclareHello declareHello =&lt;span&gt; (IDeclareHello)helloByAnnotation;
        declareHello.sayBye();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.通过注解引入新功能&lt;/p&gt;
&lt;p&gt;　　通过aop对原类进行功能加强（装饰模式），即可以动态的对一个类添加方法（有意思不？）。&lt;/p&gt;
&lt;p&gt;　　定义一个普通的接口和实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observed;

/**
 * Created by xuc on 2018/1/16.
 */
public interface&lt;span&gt; IDeclareHello {
    void&lt;span&gt; sayBye();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observed;

import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/16.
 *
 * {@link HelloByAnnotation} 的装饰类，为其添加方法
 */&lt;span&gt;
@Component
public class DeclareHello implements&lt;span&gt; IDeclareHello{
    public void&lt;span&gt; sayBye(){
        System.out.println(&quot;执行再见方法：Bye!&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　定义一个切面，再通过@DeclareParents注解（就当她是个媒婆，撮合原类和加强类，哈哈哈哈...）,value为原类（男方），变量为加强接口（女方），最后就可以生娃娃了……^.^&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.declaretion;

import&lt;span&gt; foo.bar.observed.DeclareHello;
import&lt;span&gt; foo.bar.observed.IDeclareHello;
import&lt;span&gt; org.aspectj.lang.annotation.Aspect;
import&lt;span&gt; org.aspectj.lang.annotation.DeclareParents;
import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/16.
 *
 * 将{@link DeclareHello}介绍给{@link HelloIntroducer}
 * 这是一种装饰模式，是对原类的加强
 */&lt;span&gt;
@Component
@Aspect
public class&lt;span&gt; HelloIntroducer {

    @DeclareParents(value = &quot;foo.bar.observed.HelloByAnnotation&quot;, defaultImpl = DeclareHello.class&lt;span&gt;)
    public static&lt;span&gt; IDeclareHello declareHello;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　四、AOP使用--XML方式&lt;/p&gt;
&lt;p&gt;　　与上面的基于注解方式无异，只是切面定义无需破坏原代码，可以再XML中实现，下面简单说明下。&lt;/p&gt;
&lt;p&gt;　　1.定义一个普通的类，待监听对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observed;

import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/17.
 */&lt;span&gt;
@Component
public class&lt;span&gt; HelloByXml {

    public void&lt;span&gt; sayHello(String arg) {
        System.out.println(arg);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.再定义一个普通的类，切面类（对，切面累，不是切糕累。。），无需声明其为切面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.observer;

import&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/17.
 * 小脑活动
 */&lt;span&gt;
@Component
public class&lt;span&gt; Cerebellum {

    public void&lt;span&gt; think(String arg){
        System.out.println(&quot;1.说话前要注意三思而后行:&quot; +&lt;span&gt; arg);
    }

    /**
     * 目标方法返回后执行
     */
    public void&lt;span&gt; listen(String arg){
        System.out.println(&quot;2.说完后要虚心接受长辈的教诲s&quot;&lt;span&gt;);
    }

    /**
     * 目标方法抛出异常后
     */
    public void&lt;span&gt; reflection(String arg){
        System.out.println(&quot;3.说错话后要反思为什么&quot;&lt;span&gt;);
    }

    /**
     * 目标方法前、后执行两次
     */
    public void doThings(ProceedingJoinPoint joinPoint, String arg) throws&lt;span&gt; Throwable {
        System.out.println(&quot;4.准备干点其他事&quot;&lt;span&gt;);
        joinPoint.proceed();
        System.out.println(&quot;4.其他事做完&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.XML配置切面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
    &amp;lt;context:annotation-config /&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;foo.bar&quot;/&amp;gt;

    &amp;lt;!--启用aspectj自动代理--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy /&amp;gt;

    &amp;lt;!-- XML方式 演示--&amp;gt;
    &amp;lt;!--此处仅列举一个前置通知，其他与注解形式类似--&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:aspect ref=&quot;cerebellum&quot;&amp;gt;
            &amp;lt;aop:pointcut id=&quot;speak&quot; expression=&quot;execution(* foo.bar.observed.HelloByXml.sayHello(String)) and args(arg)&quot;/&amp;gt;
            &amp;lt;aop:before method=&quot;think&quot; pointcut-ref=&quot;speak&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4.执行main测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar;

import&lt;span&gt; foo.bar.observed.HelloByAnnotation;
import&lt;span&gt; foo.bar.observed.HelloByXml;
import&lt;span&gt; foo.bar.observed.IDeclareHello;
import&lt;span&gt; org.springframework.context.ApplicationContext;
import&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

public class&lt;span&gt; HelloApp {
    public static void&lt;span&gt; main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;&lt;span&gt;);
        excuteByXml(context);
    }

    /**
     * 基于XML配置
     * @param context
     */
    private static void&lt;span&gt; excuteByXml(ApplicationContext context) {
        HelloByXml helloByXml = context.getBean(HelloByXml.class&lt;span&gt;);
        helloByXml.sayHello(&quot;Hello world!  -- by xml&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　五、实例--日志&lt;/p&gt;
&lt;p&gt;　　以上为Spring AOP的基本使用方法，下面举一个实际开发的例子，基于自定义注解与切面结合实现异步日志入库（实际上也是个小例子。。。）。&lt;/p&gt;
&lt;p&gt;　　1.定义一个注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.annotation;

import java.lang.annotation.*&lt;span&gt;;

/**
 * Created by xuc on 2018/1/18.
 * 日志生成注解(切点)
 */&lt;span&gt;
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Inherited
public @interface&lt;span&gt; PrintLog {
    int&lt;span&gt; type();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.定义一个切面，声明上面的注解为其切点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; foo.bar.annotation;

import&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
import&lt;span&gt; org.aspectj.lang.annotation.Around;
import&lt;span&gt; org.aspectj.lang.annotation.Aspect;
import&lt;span&gt; org.springframework.stereotype.Component;

/**
 * Created by xuc on 2018/1/18.
 */&lt;span&gt;
@Aspect
@Component
public class&lt;span&gt; PrintLogOperation {
    @Around(&quot;within(foo.bar.observed..*) &amp;amp;&amp;amp; @annotation(printLog)&quot;&lt;span&gt;)
    public void offerMailPo(ProceedingJoinPoint jp, PrintLog printLog) throws&lt;span&gt; Throwable {
        if (printLog.type() == 0&lt;span&gt;){
            System.out.println(&quot;你好啊，我是一条日志...&quot;&lt;span&gt;);
        }
        jp.proceed();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　　　环境： IDEA、Spring4.0&lt;/p&gt;
&lt;p&gt;　　　　参考资料： 《spring实战》&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 14:37:00 +0000</pubDate>
<dc:creator>南京-徐成</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/njxc/p/8313391.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——21. 为后代设计接口 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8313363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8313363.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Java 8之前，不可能在不破坏现有实现的情况下为接口添加方法。 如果向接口添加了一个新方法，现有的实现通常会缺少该方法，从而导致编译时错误。 在Java 8中，添加了默认方法（ default method）构造[JLS 9.4]，目的是允许将方法添加到现有的接口。 但是增加新的方法到现有的接口是充满风险的。&lt;/p&gt;
&lt;p&gt;默认方法的声明包含一个默认实现，该方法允许实现接口的类直接使用，而不必实现默认方法。 虽然在Java中添加默认方法可以将方法添加到现有接口，但不能保证这些方法可以在所有已有的实现中使用。 默认的方法被“注入（injected）”到现有的实现中，没有经过实现类的知道或同意。 在Java 8之前，这些实现是用默认的接口编写的，它们的接口永远不会获得任何新的方法。&lt;/p&gt;
&lt;p&gt;许多新的默认方法被添加到Java 8的核心集合接口中，主要是为了方便使用lambda表达式（第6章）。 Java类库的默认方法是高质量的通用实现，在大多数情况下，它们工作正常。 但是，&lt;strong&gt;编写一个默认方法并不总是可能的，它保留了每个可能的实现的所有不变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，考虑在Java 8中添加到Collection接口的&lt;code&gt;removeIf&lt;/code&gt;方法。例如，考虑在Java 8中添加到Collection接口的&lt;code&gt;removeIf&lt;/code&gt;方法。此方法删除给定布尔方法（或&lt;code&gt;Predicate&lt;/code&gt;函数式接口）返回true的所有元素。默认实现被指定为使用迭代器遍历集合，调用每个元素的谓词，并使用迭代器的&lt;code&gt;remove&lt;/code&gt;方法删除谓词返回true的元素。 据推测，这个声明看起来像这样：默认实现被指定为使用迭代器遍历集合，调用每个元素的&lt;code&gt;Predicate&lt;/code&gt;函数式接口，并使用迭代器的&lt;code&gt;remove&lt;/code&gt;方法删除Predicate函数式接口返回true的元素。 根据推测，这个声明看起来像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Default method added to the Collection interface in Java 8

default boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter) {

    Objects.requireNonNull(filter);

    boolean result = false;

    for (Iterator&amp;lt;E&amp;gt; it = iterator(); it.hasNext(); ) {

        if (filter.test(it.next())) {

            it.remove();

            result = true;

        }

    }

    return result;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是可能为&lt;code&gt;removeIf&lt;/code&gt;方法编写的最好的通用实现，但遗憾的是，它在一些实际的Collection实现中失败了。 例如，考虑&lt;code&gt;org.apache.commons.collections4.collection.SynchronizedCollection&lt;/code&gt;方法。 这个类出自Apache Commons类库中，与java.util包中的静态工厂&lt;code&gt;Collections.synchronizedCollection&lt;/code&gt;方法返回的类相似。 Apache版本还提供了使用客户端提供的对象进行锁定的能力，以代替集合。 换句话说，它是一个包装类（条目 18），它们的所有方法在委托给包装集合类之前在一个锁定对象上进行同步。&lt;/p&gt;
&lt;p&gt;Apache的&lt;code&gt;SynchronizedCollection&lt;/code&gt;类仍然在积极维护，但在撰写本文时，并未重写&lt;code&gt;removeIf&lt;/code&gt;方法。 如果这个类与Java 8一起使用，它将继承&lt;code&gt;removeIf&lt;/code&gt;的默认实现，但实际上不能保持类的基本承诺：自动同步每个方法调用。 默认实现对同步一无所知，并且不能访问包含锁定对象的属性。 如果客户端在另一个线程同时修改集合的情况下调用&lt;code&gt;SynchronizedCollection&lt;/code&gt;实例上的&lt;code&gt;removeIf&lt;/code&gt;方法，则可能会导致&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常或其他未指定的行为。&lt;/p&gt;
&lt;p&gt;为了防止在类似的Java平台类库实现中发生这种情况，比如&lt;code&gt;Collections.synchronizedCollection&lt;/code&gt;返回的包级私有的类，JDK维护者必须重写默认的&lt;code&gt;removeIf&lt;/code&gt;实现和其他类似的方法来在调用默认实现之前执行必要的同步。 原来不属于Java平台的集合实现没有机会与接口更改进行类似的改变，有些还没有这样做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在默认方法的情况下，接口的现有实现类可以在没有错误或警告的情况下编译，但在运行时会失败&lt;/strong&gt;。 虽然不是非常普遍，但这个问题也不是一个孤立的事件。 在Java 8中添加到集合接口的一些方法已知是易受影响的，并且已知一些现有的实现会受到影响。&lt;/p&gt;
&lt;p&gt;应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（条目 20）。&lt;/p&gt;
&lt;p&gt;还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。&lt;/p&gt;
&lt;p&gt;准则是清楚的。 尽管默认方法现在是Java平台的一部分，&lt;strong&gt;但是非常悉心地设计接口仍然是非常重要的&lt;/strong&gt;。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的API。&lt;/p&gt;
&lt;p&gt;因此，在发布之前测试每个新接口是非常重要的。 多个程序员应该以不同的方式实现每个接口。 至少，你应该准备三种不同的实现。 编写多个使用每个新接口的实例来执行各种任务的客户端程序同样重要。 这将大大确保每个接口都能满足其所有的预期用途。 这些步骤将允许你在发布之前发现接口中的缺陷，但仍然可以轻松地修正它们。 &lt;strong&gt;虽然在接口被发布后可能会修正一些存在的缺陷，但不要太指望这一点&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 14:28:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8313363.html</dc:identifier>
</item>
<item>
<title>前端小白的算法之路 - 新哥·lewis</title>
<link>http://www.cnblogs.com/lewiscutey/p/8313325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lewiscutey/p/8313325.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;时隔多日终于解决了埋在心头的一道难题，霎时云开雾散，今天把一路而来碰到的疑惑和心得都记录下来，也算是开启了自己探索算法的大门。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;span&gt;问题背景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;曾经有一个年少轻狂的职场小白，在前端圈子里摸爬滚打将近两年，本计划在js的道路上越走越远，以至于每天沉浸在js红皮书里不能自拔，突然有一天脑抽想找leader比划两下，于是出现了下面的对话，小白：leader，您最近在干嘛？手里有需要亟待解决的难题吗？leader：咦，确实有哎，咱的项目随着业务的不断发展，日均PV也越来越多，公司的两台机器已经快满足不了需求，现在需要解决一下机器的问题。小白：那还不简单，就是多搞几台机器，四核换八核，可以并行处理就OK了。leader：小伙子想法很美好啊，钱从哪来？那我先问你个简单的问题&lt;a href=&quot;http://www.cnblogs.com/lewiscutey/p/8313325.html#footnote-1&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;，你写个算法出来。于是这个问题应用而生，小白也开始了苦苦的算法中。。。&lt;/p&gt;
&lt;h3 id=&quot;-1&quot;&gt;&lt;span&gt;问题阐述&lt;/span&gt;&lt;/h3&gt;
&lt;h5 id=&quot;1ksk3006003005001000700300&quot;&gt;&lt;span&gt;假设一台双核处理器可以并行处理任务，它们的处理速度都为1k/s，每个任务均以k为单位，如[300, 600, 300, 500, 1000, 700, 300]，且每个任务不能拆分必须由单独的核来执行，求一堆任务的最短时间算法？&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;（如果你对这个问题感兴趣或者觉得自己很NB，可以停下来试着写一下这个算法，不要偷看我的代码哈😃高手略过😂）&lt;/p&gt;
&lt;h3 id=&quot;-2&quot;&gt;&lt;span&gt;算法之路&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;看到这个问题，第一反应很简单，无非就是先排个序，然后看情况再分配任务，于是有了下面的&lt;strong&gt;第一版程序：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arr = [&lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;700&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; left = [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; right = [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; lefts = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; rights = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; flag = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; newArr = arr.sort(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; b - a);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (flag) {&lt;br/&gt;left.push(newArr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);&lt;br/&gt;right.push(newArr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;newArr = newArr.slice(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;left.push(newArr[newArr.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]);&lt;br/&gt;right.push(newArr[newArr.length - &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]);&lt;br/&gt;newArr = newArr.slice(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, newArr.length - &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;flag = !flag; &lt;br/&gt;lefts = left.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;rights = right.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (newArr.length &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (newArr.length == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((lefts - rights) &amp;gt; newArr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lefts;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;right.push(newArr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]);&lt;br/&gt;rights = right.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; rights;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (lefts &amp;lt; rights) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; rights;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; lefts;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; task(newArr);&lt;br/&gt;};&lt;br/&gt;alert(&lt;span class=&quot;hljs-string&quot;&gt;&quot;最短时间为：&quot;&lt;/span&gt; + task(arr) + &lt;span class=&quot;hljs-string&quot;&gt;'s'&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本思路就是&lt;strong&gt;先把一堆任务排序，然后开始分配，第一次给第一台机子最大值，第二台机子次大值，第二次给第一台机子最小值，第二台机子次小值，依次递归调用累加，直至最后结束，如果是奇数个任务最后剩下一个任务的话，需要把这个任务分给时间较小的一组，最后返回一组时间较大的即是最终所需的最短时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然这个程序是有问题的，于是开始了研究，多天之后依旧没有给出正确的答案，凭借一己之力显然不能解决，然后开始在segmentfault上提问，没想到很快就有人回复了，&lt;code&gt;是NP-hard问题。近似算法参见&lt;/code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Partition_problem#Approximation_algorithm_approaches&quot;&gt;partition problem&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;看到回复后迫不及待的开始百度Google，竟然让我大吃一惊，&lt;strong&gt;2000年，美国克莱数学研究所公布了世界七大数学难题，又称千禧年大奖难题。其中P与NP问题被列为这七大世界难题之首，&lt;/strong&gt;看到这大大激发了我对这一问题的研究热情，于是开始了NP问题的研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NP-hard，&lt;/strong&gt;其中NP是指非确定性多项式（non-deterministic polynomial，缩写NP）。所谓的非确定性是指，可用一定数量的运算去解决多项式时间内可解决的问题。NP-hard问题通俗来说是其解的正确性能够被“很容易检查”的问题，这里“很容易检查”指的是存在一个多项式检查算法。相应的，若NP中所有问题到某一个问题是图灵可归约的，则该问题为NP困难问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98&quot;&gt;旅行推销员问题&lt;/a&gt;就是最著名的NP问题之一，当然我要解决的这个问题&lt;strong&gt;（多线程多机调度问题）&lt;/strong&gt;也属于NP问题之一，一般使用&lt;strong&gt;贪心算法&lt;/strong&gt;来解决，于是我就开始了贪心算法之路。&lt;/p&gt;
&lt;h3 id=&quot;-3&quot;&gt;&lt;span&gt;算法描述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;贪心算法：&lt;/strong&gt;（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思想：&lt;/strong&gt; 贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;建立数学模型来描述问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;把求解的问题分成若干个子问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对每一子问题求解，得到子问题的局部最优解；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;把子问题的解局部最优解合成原来解问题的一个解。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-4&quot;&gt;&lt;span&gt;解决思路&lt;/span&gt;&lt;/h3&gt;
&lt;h5 id=&quot;-5&quot;&gt;&lt;span&gt;多线程问题主要是多个服务器可以并行处理多个任务，寻求处理所有任务的情况下，用掉最少时间的问题。因为任务并不局限于在某一个服务器上处理，而且任务不能拆分，所以还是要综合考虑怎么分配任务，属于多线程问题。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;核心思路：&lt;/strong&gt;（n代表任务，m代表机器）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;将n个独立的任务按照时间从大到小排序;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果n&amp;lt;=m,则需要的最短时间就是n个任务当中的最大时间；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果n&amp;gt;m,则先给每个机器依次分配任务，第一次就分配了m个作业；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后循环第一次分配的m个任务时间，选取处理时间最短的机器分配第m+1个任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;依次循环所有机器所需时间，并选取最短时间的机器分配下一个任务；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最后比较返回最长时间的机子时间则为所需的最短时间。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实现过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1108319/201801/1108319-20180118231745646-1153293373.jpg&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;358&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;-6&quot;&gt;&lt;span&gt;程序设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第二版程序：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arr = [&lt;span class=&quot;hljs-number&quot;&gt;700&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;900&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; newArr = arr.sort(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; b - a);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; left = [newArr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; right = [newArr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]];&lt;br/&gt;newArr = newArr.slice(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; lefts = newArr[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; rights = newArr[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;newArr.forEach(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;item, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (lefts &amp;lt; rights) {&lt;br/&gt;left.push(item);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;right.push(item);&lt;br/&gt;}&lt;br/&gt;lefts = left.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;rights = right.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.max(lefts, rights);&lt;br/&gt;};&lt;br/&gt;alert(&lt;span class=&quot;hljs-string&quot;&gt;&quot;最短时间为：&quot;&lt;/span&gt; + task(arr) + &lt;span class=&quot;hljs-string&quot;&gt;'s'&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的第二版程序还是以最初的问题双核处理器（相当于两个机子）实现的，经测试正确通过，于是又拓展了多线程多机器的常见问题，就有了最终版的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三版程序：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; tasks = [&lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;600&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;700&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;300&lt;/span&gt;];&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;task&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;tasks, nums&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;tasks = tasks.sort(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; b - a);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; machine = &lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.parse(&lt;span class=&quot;hljs-built_in&quot;&gt;JSON&lt;/span&gt;.stringify(&lt;span class=&quot;hljs-built_in&quot;&gt;Array&lt;/span&gt;(nums).fill([])));&lt;br/&gt;tasks.forEach(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;item, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(index &amp;lt; nums) {&lt;br/&gt;machine[index].push(item);&lt;br/&gt;}&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; times = &lt;span class=&quot;hljs-built_in&quot;&gt;Array&lt;/span&gt;(nums);&lt;br/&gt;machine.forEach(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;item, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;times[index] = item.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;});&lt;br/&gt;tasks = tasks.slice(nums);&lt;br/&gt;tasks.forEach(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;item, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;times.some(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;items, indexs&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(items == &lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.min(...times)) {&lt;br/&gt;machine[indexs].push(item);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;});&lt;br/&gt;machine.forEach(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;items, indexs&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;times[indexs] = items.reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b);&lt;br/&gt;});&lt;br/&gt;});&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Math&lt;/span&gt;.max(...times);&lt;br/&gt;};&lt;br/&gt;alert(&lt;span class=&quot;hljs-string&quot;&gt;&quot;最短输出时间为：&quot;&lt;/span&gt; + task(tasks, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) + &lt;span class=&quot;hljs-string&quot;&gt;'s'&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，终于可以松口气了，这一路下来也是历尽艰辛，在此非常感谢清华大学的&lt;code&gt;@萝卜&lt;/code&gt;的指点迷津，一语惊醒梦中人，让我找到了解法，虽然不是最优的算法，也让我醍醐灌顶，打开了探索算法的大门。以上代码是用JavaScript实现的（你可以用你熟悉的语言实现一下哈😃），其他语言也是一样的逻辑，所以做前端的千万不要在js的世界里妄自尊大，要站在CTO的角度放眼全局，尤其是多熟悉一些算法，这样的话编程思维更有逻辑性，解决问题能力更强，在公司的不可替代性也就更大了。&lt;/p&gt;
&lt;h3 id=&quot;-7&quot;&gt;&lt;span&gt;反思总结&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;算法是计算机科学领域最重要的基石之一，因为计算机语言和开发平台日新月异，但万变不离其宗的是最基础的算法和理论，比如数据结构、算法设计、编译原理、计算机操作系统和数据库原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比喻为“内功”，把新的语言、技术、标准比拟为“外功”。整天赶时髦的人最后只懂得招式，没有功力，是不可能成为武林高手的。由此知道了算法的重要性，以后要多加学习。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;善于向别人请教，计算机这个领域博大精深，自己不懂的还有很多很多，就比如这次脑子里就没有贪心算法这种思想，只能硬碰运气试答案，显然是浪费时间瞎折腾，遇到研究好久都没答案的问题一定要多加请教。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;善于归纳总结，积少成多，厚积薄发。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;-8&quot;&gt;&lt;span&gt;最后以村上春树的一句话送给大家共勉：&lt;code&gt;不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。&lt;/code&gt;&lt;/span&gt;&lt;/h5&gt;
</description>
<pubDate>Thu, 18 Jan 2018 14:24:00 +0000</pubDate>
<dc:creator>新哥&amp;#183;lewis</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lewiscutey/p/8313325.html</dc:identifier>
</item>
<item>
<title>[工具]我怎么使用思维导图 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/XMind.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/XMind.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;已经不记得是什么时候开始用思维导图的，可能是刚开始工作不久就开始用了。我只记得刚开始是看到思维导图的介绍，觉得功能强大又很有趣，就慢慢开始尝试，然后习惯，然后就离不开了。前不久又买了一本思维导图的书《日常生活中的思维导图》，里面有一段话我很赞同：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;制作思维导图是将画在中央的主题逐渐细化分解的过程。先把从主题延伸出的粗线（主支）分解成中等粗细的线条，再把每跟线条继续分解成细线，然后再把他们分解得更细……制作思维导图就是分解步骤的不断重复。这个过程可以帮助我们从不同角度透彻地分析一个主题。不仅如此，把所有内容都画在一张纸上，可以纵观全局，还能注意到信息之间的联系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不久前老婆做了关于数据可视化的培训，我有帮忙整理资料，发现她虽然见识过各种图表，但对思维导图了解甚少（毕竟和数据没什么关系）。回想起来身边用思维导图的确实很少见，可能了解思维导图的人还比较少 ，写这篇文章除了是介绍一种好用的工具，主要也是写给老婆，希望对她工作有帮助吧。&lt;/p&gt;
&lt;h2 id=&quot;用什么软件&quot;&gt;2. 用什么软件&lt;/h2&gt;
&lt;p&gt;很久以前我使用过一段时间破解版的&lt;a href=&quot;https://www.mindjet.com/&quot;&gt;MindManager&lt;/a&gt;，虽然功能强大，但其实个人使用时用不到那么多功能。后来我使用免费版的&lt;a href=&quot;https://www.xmind.cn/&quot;&gt;Xmind&lt;/a&gt;，免费版只是缺少一些专业功能（甘特图、导出Word等），反正核心功能够用就好，必要时升级到付费版本也不贵。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180117221317740-1916247874.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近几年一些在线的脑图软件也十分好用，如 &lt;a href=&quot;http://naotu.baidu.com/&quot;&gt;百度脑图 - 便捷的思维工具&lt;/a&gt; 和 &lt;a href=&quot;https://www.processon.com/&quot;&gt;ProcessOn - 免费在线作图，实时协作&lt;/a&gt; （网速关系不太用国外的。）&lt;/p&gt;
&lt;p&gt;可惜没有微软的工具，这种充满“生产力”“学习”“商业技能”等标签的工具应该是微软最喜欢的，还好Office365商店里有也有不少思维导图的插件。&lt;/p&gt;
&lt;h2 id=&quot;什么时候用&quot;&gt;3. 什么时候用&lt;/h2&gt;
&lt;p&gt;在《日常生活中的思维导图》这本书中，思维导图在生活学习工作方方面面大展拳脚，简直无所不能，让人大开眼界。我自己的话，虽然在决策、架构等方面也用得也不少，不过用得最多还是学习和排程。&lt;/p&gt;
&lt;h3 id=&quot;在学习中使用思维导图&quot;&gt;3.1 在学习中使用思维导图&lt;/h3&gt;
&lt;p&gt;我常常想如果求学时期就学会了使用思维导图，学习应该会轻松很多。无论什么知识，都符合思维导图“围绕一个主题，层层展开，相互联系”的特征。比起普通的笔记，思维导图对理解和整理知识点很有帮助。最重要的是思维导图为学习引入了一种趣味。最近觉得思维导图对学习历史尤其有用，例如下面是最近学习中国历史的一部分笔记：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180117224458334-2112693882.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180117221436709-1400719627.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用思维导图整理排程&quot;&gt;3.2 用思维导图整理排程&lt;/h3&gt;
&lt;p&gt;其实也不是经常用，大部分情况下Todo是一个List，或者用四象限的方式管理，不过很多时候一个人的工作和生活都是混乱的，并不可以顺序执行。下图是我最近一个星期的排程（工作部分为虚构），因为最近新项目启动，周末又安排了活动，正好又碰上了几件私事，整个星期工作和生活的安排都很混乱，这种时候最适合用思维导图整理下排程。每天一早我会检视已完成一部分的工作，在准备当天做的工作打上“未启动”的标记，当工作完成后再更改标记。 这样根据整个思维导图的颜色我可以清楚整个星期的进度，以及接下来要做的工作。（当然最后还是会转写到一个列表方便写每周的工作报告。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180118100128209-819413326.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;因为年轻而犯下的错&quot;&gt;4. 因为年轻而犯下的错&lt;/h2&gt;
&lt;h3 id=&quot;过度追去美观&quot;&gt;4.1 过度追去美观&lt;/h3&gt;
&lt;p&gt;为方便记忆和理解重点可以使用很多颜色或其它作图技巧，但目的应该是解决问题。过度追求美观，试各种模板，浪费了大把的时间，最后才发现还不如默认模板好看。&lt;/p&gt;
&lt;h3 id=&quot;以为思维导图是万能的&quot;&gt;4.2 以为思维导图是万能的&lt;/h3&gt;
&lt;p&gt;各种思维导图的书都把思维导图夸到无所不能，其实很多时候还是Excel或OneNote更好用，或者要配合使用。就连上文说的时间管理，这种做法没办法给一组任务设定期限及提醒（也许升级到Pro可以），通常我都是用思维导图整理完混乱的排程后，如果有重要的事件会在Microsoft To-Do中添加一条有截止日期和提醒的To-Do，不会完全依赖思维导图。&lt;/p&gt;
&lt;h3 id=&quot;以为思维导图只能有一个中心主题&quot;&gt;4.3 以为思维导图只能有一个中心主题&lt;/h3&gt;
&lt;p&gt;思维导图强调要有一个中心主题，其实大可不必，用得更自由也不算错。例如下面是我制作的楚汉争霸思维导图，虽然没有中心主题，但脉路还算清晰，而且又好玩。无论工作还是学习，开心还是很重要的。思维导图的一个特点是富含乐趣，做起来不要太过死板。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180117221522990-932796208.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;过于复杂或过于详细&quot;&gt;4.4 过于复杂或过于详细&lt;/h3&gt;
&lt;p&gt;思维导图有“1分支1词语”的规则，即每个分支都是一个词语，不能是一个句子。虽然我觉得不必严格遵守，但现在我也很赞同不要将思维导图弄得太详细，太复杂。有时越详细的句子越限制想象力。&lt;/p&gt;
&lt;h2 id=&quot;我喜欢的小技巧&quot;&gt;5. 我喜欢的小技巧&lt;/h2&gt;
&lt;p&gt;分享个小技巧，我读书时很喜欢将所有目录章节输入到思维导图，再在各个章节上做笔记。人手一个个标题输入太费时间，很多时候我都是直接从豆瓣上复制整个目录到文本文件，用Tab做二级标题的缩进，然后再粘贴到XMind里。下面这个思维导图也才花了几分钟：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/38937/201801/38937-20180118101100224-685532632.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;延伸阅读&quot;&gt;6. 延伸阅读&lt;/h2&gt;
&lt;p&gt;文章开头提到的《日常生活中的思维导图》这本书是最近买的，这并不是我都的第一本思维导图的书，但应该是印象最深刻的，大力推荐。不仅内容让我大开眼界，而且还很实用。可惜插图的文字是手写体，潦草得几乎看不懂，难道这就是艺术？&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;7. 结语&lt;/h2&gt;
&lt;p&gt;虽然开始实用思维导图好多年了，偶尔还会发现新的用法。例如前两年看某小说学会了“任何时候总是存在三个选项”这个想法，当遇到不能马上解决的问题时我会在思维导图上随便列三条路线，最终通常都会得出以下结果之一：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在三条路线中选出最好的作为解决方案。&lt;/li&gt;
&lt;li&gt;也有可能是三条路线的组合应用。&lt;/li&gt;
&lt;li&gt;全部行不通，但起码整理好行不通的理由，对提出问题的人（通常上司或同事或合作对象）有个交代。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;得益于思维导图的简单，怎么用、用成什么样完全看个人的发挥，这篇文章也只是结合自己的经验介绍些入门的知识，希望对探索思维导图有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;8. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26761558/&quot;&gt;日常生活中的思维导图 (豆瓣)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/21248595&quot;&gt;撰写论文的过程中如何有效利用思维导图&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/20273625&quot;&gt;思维导图真的有效吗？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 12:11:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dino623/p/XMind.html</dc:identifier>
</item>
<item>
<title>在 .NET 中，扫描局域网服务的实现 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/serverscan.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/serverscan.html</guid>
<description>&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扫描结果
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionResult
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; IPAddress 地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IPAddress Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否可连接上
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanConnected { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扫描完成事件参数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScanCompleteEventArgs
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结果集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;ConnectionResult&amp;gt; Reslut { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扫描进度事件参数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ScanProgressEventArgs
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 进度百分比
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Percent { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扫描局域网中的服务
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerScanner : IServerScanner
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 同一网段内 IP 地址的数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SegmentIpMaxCount = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DateTimeOffset _endTime;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _locker = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SynchronizationContext _originalContext =&lt;span&gt; SynchronizationContext.Current;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ConnectionResult&amp;gt; _resultList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ConnectionResult&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DateTimeOffset _startTime;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录调用/完成委托的数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _totalCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServerScanner()
        {
            Timeout &lt;/span&gt;= TimeSpan.FromSeconds(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当扫描完成时，触发此事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;List&amp;lt;ConnectionResult&amp;gt;&amp;gt;&lt;span&gt; OnScanComplete;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当扫描进度发生更改时，触发此事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; EventHandler&amp;lt;ScanProgressEventArgs&amp;gt;&lt;span&gt; OnScanProgressChanged;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扫描端口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ScanPort { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单次请求的超时时长，默认为2秒
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; TimeSpan Timeout { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用 TcpClient 测试是否可以连上指定的 IP 与 Port
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ipAddress&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;port&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsConnected(IPAddress ipAddress, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; TestConnection(ipAddress, port);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.CanConnected;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用 TcpClient 测试是否可以连上指定的 IP 与 Port
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ip&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;port&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsConnected(&lt;span&gt;string&lt;/span&gt; ip, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port)
        {
            IPAddress ipAddress;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (IPAddress.TryParse(ip, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; ipAddress))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IsConnected(ipAddress, port);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP 地址格式不正确&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开始扫描当前网段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartScan()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ScanPort == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须指定扫描的端口 ScanPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除可能存在的数据&lt;/span&gt;
&lt;span&gt;            _resultList.Clear();
            _totalCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            _startTime &lt;/span&gt;=&lt;span&gt; DateTimeOffset.Now;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到本网段的 IP&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; ipList =&lt;span&gt; GetAllRemoteIPList();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成委托列表&lt;/span&gt;
            List&amp;lt;Func&amp;lt;IPAddress, &lt;span&gt;int&lt;/span&gt;, ConnectionResult&amp;gt;&amp;gt; funcs = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;IPAddress, &lt;span&gt;int&lt;/span&gt;, ConnectionResult&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; SegmentIpMaxCount; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmpF = &lt;span&gt;new&lt;/span&gt; Func&amp;lt;IPAddress, &lt;span&gt;int&lt;/span&gt;, ConnectionResult&amp;gt;&lt;span&gt;(TestConnection);
                funcs.Add(tmpF);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步调用每个委托&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; SegmentIpMaxCount; i++&lt;span&gt;)
            {
                funcs[i].BeginInvoke(ipList[i], ScanPort, OnComplete, funcs[i]);
                _totalCount &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 得到本网段的所有 IP
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;IPAddress&amp;gt;&lt;span&gt; GetAllRemoteIPList()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; localName =&lt;span&gt; Dns.GetHostName();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; localIPEntry =&lt;span&gt; Dns.GetHostEntry(localName);

            List&lt;/span&gt;&amp;lt;IPAddress&amp;gt; ipList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IPAddress&amp;gt;&lt;span&gt;();

            IPAddress localInterIP &lt;/span&gt;= localIPEntry.AddressList.FirstOrDefault(m =&amp;gt; m.AddressFamily ==&lt;span&gt; AddressFamily.InterNetwork);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localInterIP == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前计算机不存在内网 IP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; localInterIPBytes =&lt;span&gt; localInterIP.GetAddressBytes();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= SegmentIpMaxCount; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对末位进行替换&lt;/span&gt;
                localInterIPBytes[&lt;span&gt;3&lt;/span&gt;] = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)i;
                ipList.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IPAddress(localInterIPBytes));
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ipList;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnComplete(IAsyncResult ar)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state = ar.AsyncState &lt;span&gt;as&lt;/span&gt; Func&amp;lt;IPAddress, &lt;span&gt;int&lt;/span&gt;, ConnectionResult&amp;gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; state.EndInvoke(ar);

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_locker)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到结果中&lt;/span&gt;
&lt;span&gt;                _resultList.Add(result);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报告进度&lt;/span&gt;
                _totalCount -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; percent = (SegmentIpMaxCount - _totalCount) * &lt;span&gt;100&lt;/span&gt; /&lt;span&gt; SegmentIpMaxCount;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SynchronizationContext.Current ==&lt;span&gt; _originalContext)
                {
                    OnScanProgressChanged&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ScanProgressEventArgs { Percent =&lt;span&gt; percent });
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    _originalContext.Post(conState &lt;/span&gt;=&amp;gt;&lt;span&gt;
                    {
                        OnScanProgressChanged&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ScanProgressEventArgs { Percent =&lt;span&gt; percent });
                    }, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_totalCount == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过事件抛出结果&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (SynchronizationContext.Current ==&lt;span&gt; _originalContext)
                    {
                        OnScanComplete&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, _resultList);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        _originalContext.Post(conState &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        {
                            OnScanComplete&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, _resultList);
                        }, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算耗时&lt;/span&gt;
                    Debug.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Compete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    _endTime &lt;/span&gt;=&lt;span&gt; DateTimeOffset.Now;
                    Debug.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Duration: {_endTime - _startTime}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 测试是否可以连接到
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;address&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;port&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; ConnectionResult TestConnection(IPAddress address, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port)
        {
            TcpClient c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TcpClient();

            ConnectionResult result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionResult();
            result.Address &lt;/span&gt;=&lt;span&gt; address;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (TcpClient tcp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TcpClient())
            {
                IAsyncResult ar &lt;/span&gt;= tcp.BeginConnect(address, port, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                WaitHandle wh &lt;/span&gt;=&lt;span&gt; ar.AsyncWaitHandle;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ar.AsyncWaitHandle.WaitOne(Timeout, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
                    {
                        tcp.Close();
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        tcp.EndConnect(ar);
                        result.CanConnected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                }
                &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
                {
                    wh.Close();
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
    }&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 18 Jan 2018 11:30:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/serverscan.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExecutor详解 - 爱宝贝丶</title>
<link>http://www.cnblogs.com/zhangxufeng/p/8312528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxufeng/p/8312528.html</guid>
<description>&lt;p&gt;       ThreadPoolExecutor顾名思义，是一个线程池管理工具类，该类主要提供了任务管理，线程的调度和相关的hook方法来控制线程池的状态。&lt;/p&gt;
&lt;h4 id=&quot;方法说明&quot;&gt;1.方法说明&lt;/h4&gt;
&lt;p&gt;任务管理主要方法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(Runnable command);
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(Callable&amp;lt;T&amp;gt; task);
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(Runnable task, T result);
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt; &lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(Runnable task);
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;Runnable&amp;gt; &lt;span class=&quot;fu&quot;&gt;shutdownNow&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       上述方法中，execute()和submit()方法在有空闲线程存在的情况下会立即调用该线程执行任务，区别在于execute()方法是忽略任务执行结果的，而submit()方法则可以获取结果。除此之外，ThreadPoolExecutor还提供了shutdown()和shutdownNow()方法用于关闭线程池，区别在于shutdown()方法在调用之后会将任务队列中的任务都执行完毕之后再关闭线程池，而shutdownNow()方法则会直接关闭线程池，并且将任务队列中的任务导出到一个列表中返回。&lt;/p&gt;
&lt;p&gt;       除上述用于执行任务的方法外，ThreadPoolExecutor还提供了如下几个hook（钩子）方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;beforeExecute&lt;/span&gt;(Thread t, Runnable r);
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;afterExecute&lt;/span&gt;(Runnable r, Throwable t);
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;terminated&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在ThreadPoolExecutor中这几个方法默认都是空方法，beforeExecute()会在每次任务执行之前调用，afterExecute()会在每次任务结束之后调用，terminated()方法则会在线程池被终止时调用。使用这几个方法的方式就是声明一个子类继承ThreadPoolExecutor，并且在子类中重写需要定制的钩子方法，最后在创建线程池时使用该子类实例即可。&lt;/p&gt;
&lt;h4 id=&quot;任务调度&quot;&gt;2.任务调度&lt;/h4&gt;
&lt;h5 id=&quot;a.相关参数&quot;&gt;a.相关参数&lt;/h5&gt;
&lt;p&gt;       对于ThreadPoolExecutor的实例化，其主要有如下几个重要的参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; corePoolSize, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; maximumPoolSize, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; keepAliveTime, 
                          TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, 
                          ThreadFactory threadFactory, RejectedExecutionHandler handler);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize: 线程池核心线程的数量；&lt;/li&gt;
&lt;li&gt;maximumPoolSize: 线程池可创建的最大线程数量；&lt;/li&gt;
&lt;li&gt;keepAliveTime: 当线程数量超过了corePoolSize指定的线程数，并且空闲线程空闲的时间达到当前参数指定的时间时该线程就会被销毁，如果调用过allowCoreThreadTimeOut(boolean value)方法允许核心线程过期，那么该策略针对核心线程也是生效的；&lt;/li&gt;
&lt;li&gt;unit: 指定了keepAliveTime的单位，可以为毫秒，秒，分，小时等；&lt;/li&gt;
&lt;li&gt;workQueue: 存储未执行的任务的队列；&lt;/li&gt;
&lt;li&gt;threadFactory: 创建线程的工厂，如果未指定则使用默认的线程工厂；&lt;/li&gt;
&lt;li&gt;handler: 指定了当任务队列已满，并且没有可用线程执行任务时对新添加的任务的处理策略；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;b.调度策略&quot;&gt;b.调度策略&lt;/h5&gt;
&lt;p&gt;       当初始化一个线程池之后，池中是没有任何用户执行任务的活跃线程的，当新的任务到来时，根据配置的参数其主要的执行任务如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若线程池中线程数小于corePoolSize指定的线程数时，每来一个任务，都会创建一个新的线程执行该任务，无论线程池中是否已有空闲的线程；&lt;/li&gt;
&lt;li&gt;若当前执行的任务达到了corePoolSize指定的线程数时，也即所有的核心线程都在执行任务时，此时来的新任务会保存在workQueue指定的任务队列中；&lt;/li&gt;
&lt;li&gt;当所有的核心线程都在执行任务，并且任务队列中存满了任务，此时若新来了任务，那么线程池将会创建新线程执行任务；&lt;/li&gt;
&lt;li&gt;若所有的线程（maximumPoolSize指定的线程数）都在执行任务，并且任务队列也存满了任务时，对于新添加的任务，其都会使用handler所指定的方式对其进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;c.调度策略注意点&quot;&gt;c.调度策略注意点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;在第二步中，当前核心线程都在执行任务，并且任务队列已满时，会创建新的线程执行任务，这里需要注意的是，创建新线程的时候当前总共需要执行的任务数是(corePoolSize + workQueueSize)，并不是只有corePoolSize个任务；&lt;/li&gt;
&lt;li&gt;在第三步中，这里workQueue主要有三种类型：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue，第一个是有界阻塞队列，第二个是无界阻塞队列，当然也可以为其指定界限大小，第三个是同步队列，对于ArrayBlockingQueue，其是需要指定队列大小的，当队列存满了任务线程池就会创建新的线程执行任务，对于LinkedBlockingQueue，如果其指定界限，那么和ArrayBlockingQueue区别不大，如果其不指定界限，那么其理论上是可以存储无限量的任务的，实际上能够存储Integer.MAX_VALUE个任务（还是相当于可以存储无限量的任务），此时由于LinkedBlockingQueue是永远无法存满任务的，因而maxPoolSize的设定将没有意义，一般其会设定为和corePoolSize相同的值，对于SynchronousQueue，其内部是没有任何结构存储任务的，当一个任务添加到该队列时，当前线程和后续添加任务的线程都会被阻塞，直至有一个线程从该队列中取出任务，当前线程才会被释放，因而如果线程池使用了该队列，那么一般corePoolSize都会设计得比较小，maxPoolSize会设计得比较大，因为该队列比较适合大量并且执行时间较短的任务的执行；&lt;/li&gt;
&lt;li&gt;在第四步中，DiscardPolicy和DiscardOldestPolicy一般不会配合SynchronousQueue使用，因为当同步队列阻塞了任务时，该任务都会被抛弃；对于AbortPolicy，因为如果队列已满，那么其会抛出异常，因而使用时需要小心；对于CallerRunsPolicy，由于当有新的任务到达时会使用调用线程执行当前任务，因而使用时需要考虑其对服务器响应的影响，并且还需要注意的是，相对于其他几个策略，该策略不会抛弃任务到达的任务，因为如果到达的任务使队列满了而只能使用调用线程执行任务时，说明线程池设计得不够合理，如果任其发展，那么所有的调用线程都可能会被需要执行的任务所阻塞，导致服务器出现问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;源码讲解&quot;&gt;3.源码讲解&lt;/h4&gt;
&lt;h5 id=&quot;a.主要属性&quot;&gt;a.主要属性&lt;/h5&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;fu&quot;&gt;ctlOf&lt;/span&gt;(RUNNING, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; COUNT_BITS = Integer.&lt;span class=&quot;fu&quot;&gt;SIZE&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 32&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CAPACITY   = (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS) - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;co&quot;&gt;// 00011111 11111111 11111111 11111111&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; RUNNING    = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS; &lt;span class=&quot;co&quot;&gt;// 11100000 00000000 00000000 00000000&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SHUTDOWN   =  &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS; &lt;span class=&quot;co&quot;&gt;// 00000000 00000000 00000000 00000000&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; STOP       =  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS; &lt;span class=&quot;co&quot;&gt;// 00100000 00000000 00000000 00000000&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TIDYING    =  &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS; &lt;span class=&quot;co&quot;&gt;// 01000000 00000000 00000000 00000000&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TERMINATED =  &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &amp;lt;&amp;lt; COUNT_BITS; &lt;span class=&quot;co&quot;&gt;// 01100000 00000000 00000000 00000000&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       由于ThreadPoolExecutor需要管理多种状态，并且还要记录当前执行任务的线程的数量，如果使用多个变量，并发更新时管理将会非常复杂，这里ThreadPoolExecutor则主要使用一个AtomicInteger类型的变量ctl存储所有主要的信息。ctl是一个32位的整形数字，初始值为0，其最高的三位用于存储当前线程池的状态信息，主要有RUNNING，SHUTDOWN，STOP，TIDING和TERMINATED，分别表示运行状态，关闭状态，终止状态，整理状态和结束状态。这几种状态对应的具体数值信息如上述代码所示，这里需要注意的一点是，在ThreadPoolExecutor中，这几种状态在数值上是从小到大依次增大的，并且状态流转也是依次往下的，这就为其判断状态信息提供了比较便利的方式，如当需要判断线程池状态是否处于SHUTDOWN状态时，只需要判断其代表状态位部分的值是否等于SHUTDOWN即可。在ctl中，除了最高三位用于表示状态外，其余位所代表的数值则指定了当前线程池中正在执行任务的线程数。如下是操作ctl属性的相关方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runStateOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c)     { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; c &amp;amp; ~CAPACITY; }
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c)  { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; c &amp;amp; CAPACITY; }
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ctlOf&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; wc) { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rs | wc; }

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runStateLessThan&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; s) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; c &amp;lt; s;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runStateAtLeast&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; s) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; c &amp;gt;= s;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isRunning&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; c &amp;lt; SHUTDOWN;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareAndIncrementWorkerCount&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expect) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ctl.&lt;span class=&quot;fu&quot;&gt;compareAndSet&lt;/span&gt;(expect, expect + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareAndDecrementWorkerCount&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expect) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ctl.&lt;span class=&quot;fu&quot;&gt;compareAndSet&lt;/span&gt;(expect, expect - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;runStateOf(int c): 用于获取当前线程池的状态，c为当前线程池工作时的ctl属性值；&lt;/li&gt;
&lt;li&gt;workerCountOf(int c): 用于获取当前线程池正在工作的线程数量，c为当前线程池工作时的ctl属性值；&lt;/li&gt;
&lt;li&gt;ctlOf(int rs, int wc): 这里rs表示当前线程的工作状态，wc则表示正在工作的线程数，该方法用于将这两个参数组装为一个ctl属性值；&lt;/li&gt;
&lt;li&gt;runStateLessThan(int c, int s): 判断当前线程池状态是否未达到指定状态，如前所述，状态流转在数值上是依次增大的，因而这里只需要判断其大小即可；&lt;/li&gt;
&lt;li&gt;runStateAtLeast(int c, int s): 用于判断当前线程池状态是否至少处于某种状态；&lt;/li&gt;
&lt;li&gt;isRunning(int c): 用于判断当前线程池是否处于正常运行状态；&lt;/li&gt;
&lt;li&gt;compareAndIncrementWorkerCount(int expect): 增加当前线程池的工作线程数量值；&lt;/li&gt;
&lt;li&gt;compareAndDecrementWorkerCount(int expect): 减少当前线程池的工作线程数量值。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;b.主要方法&quot;&gt;b.主要方法&lt;/h5&gt;
&lt;p&gt;       对于线程池的execute()和submit()方法，其实在底层submit()方法会将传入的任务封装为一个FutureTask对象，由于FutureTask对象是实现了Runnable接口的，因而其也可以当做一个任务执行，这里就是将封装后的FutureTask对象传递给execute()方法执行的。我们这里则主要讲解execute()方法的实现方式，如下是execute()方法的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(Runnable command) {
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (command == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException();

  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();    &lt;span class=&quot;co&quot;&gt;// 获取当前线程池状态&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(c) &amp;lt; corePoolSize) {
    &lt;span class=&quot;co&quot;&gt;// 当工作线程数小于核心线程数时，则调用addWorker()方法创建线程并执行任务&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(command, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;))
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;// 若添加失败，则更新当前线程池状态&lt;/span&gt;
  }
  
  &lt;span class=&quot;co&quot;&gt;// 执行到此处，则说明线程池中的工作线程要么大于等于核心线程数，要么当前线程池已经被命令关闭了(addWorker方法添加失败的原因)，因而这里判断线程池是否为RUNNING状态，是则将任务添加到任务队列中&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRunning&lt;/span&gt;(c) &amp;amp;&amp;amp; workQueue.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(command)) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; recheck = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 添加队列成功后双重验证，确保线程池处于正确状态&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (! &lt;span class=&quot;fu&quot;&gt;isRunning&lt;/span&gt;(recheck) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(command))
      &lt;span class=&quot;fu&quot;&gt;reject&lt;/span&gt;(command);
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(recheck) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
      &lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);   &lt;span class=&quot;co&quot;&gt;// 若线程池中没有线程，则创建一个新线程执行添加的任务&lt;/span&gt;
  } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(command, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;))
    &lt;span class=&quot;fu&quot;&gt;reject&lt;/span&gt;(command);    &lt;span class=&quot;co&quot;&gt;// 线程池至少处于SHUTDOWN状态，拒绝当前任务的执行&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在execute()方法中，其首先判断线程池工作线程数是否小于核心线程数，是则创建核心线程执行任务，添加失败或者工作线程数大于等于核心线程数时，则将任务添加到任务队列中，添加成功后会进行双重验证确保当前线程池处于正确的状态，并且确保当前有可用的线程执行新添加的任务。由此可见对于execute()方法的实现，其比较核心的方法是addWorker()方法，如下是addWorker()方法的实现方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(Runnable firstTask, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; core) {
  retry:
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rs = &lt;span class=&quot;fu&quot;&gt;runStateOf&lt;/span&gt;(c); &lt;span class=&quot;co&quot;&gt;// 获取当前运行状态&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 判断当前线程池是否至少为SHUTDOWN状态，并且firstTask和任务队列中没有任务，是则直接返回&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; !(rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !workQueue.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()))
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
      &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; wc = &lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(c);
      &lt;span class=&quot;co&quot;&gt;// 判断是否工作线程数大于可记录的最大线程数，或者工作线程超过了指定的核心线程或者最大线程数&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY || wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
      &lt;span class=&quot;co&quot;&gt;// 走到这一步说明当前线程池处于RUNNING状态，或者任务队列存在任务，并且工作线程数不超过&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// 指定的线程数量，那么就增加工作线程数量，成功则继续往下执行，失败则重复上述添加步骤&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndIncrementWorkerCount&lt;/span&gt;(c))
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt; retry;
      c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;runStateOf&lt;/span&gt;(c) != rs)
        &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt; retry;
    }
  }

  &lt;span class=&quot;co&quot;&gt;// 记录工作线程数的变量已经更新，接下来创建线程执行任务&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; workerStarted = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; workerAdded = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  Worker w = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    w = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Worker&lt;/span&gt;(firstTask);  &lt;span class=&quot;co&quot;&gt;// 创建一个工作者对象&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread t = w.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;mainLock&lt;/span&gt;;
      mainLock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rs = &lt;span class=&quot;fu&quot;&gt;runStateOf&lt;/span&gt;(ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;());

        &lt;span class=&quot;co&quot;&gt;// 重新检查线程池状态，或者是判断当前是SHUTDOWN状态，而firstTask为空，这说明任务队列此时不为空&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN || (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)) {
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t.&lt;span class=&quot;fu&quot;&gt;isAlive&lt;/span&gt;())
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalThreadStateException();
          workers.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(w);   &lt;span class=&quot;co&quot;&gt;// 将创建的工作者添加到工作者集合中&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; s = workers.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s &amp;gt; largestPoolSize)
            largestPoolSize = s;    &lt;span class=&quot;co&quot;&gt;// 更新已使用的最大线程数&lt;/span&gt;
          workerAdded = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
      } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
        mainLock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
      }
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (workerAdded) {
        t.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;// 工作者对象成功创建之后，调用该工作者执行任务&lt;/span&gt;
        workerStarted = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
      }
    }
  } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!workerStarted)
      &lt;span class=&quot;fu&quot;&gt;addWorkerFailed&lt;/span&gt;(w);
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; workerStarted;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在addWorker()方法中，其首先检查当前线程池是否处于RUNNING状态，或者处于SHUTDOWN状态，但是任务队列中还存在有任务，那么其就会创建一个新的Worker对象，并且将其添加到工作者对象集合中，然后调用工作者对象所维护的线程执行任务，如下是工作者对象的实现代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Worker &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractQueuedSynchronizer &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = 6138294804551838833L;
  &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread thread;  &lt;span class=&quot;co&quot;&gt;// 当前工作者中执行任务的线程&lt;/span&gt;
  Runnable firstTask;   &lt;span class=&quot;co&quot;&gt;// 第一个需要执行的任务&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; completedTasks; &lt;span class=&quot;co&quot;&gt;// 当前工作者完成的任务数&lt;/span&gt;

  &lt;span class=&quot;fu&quot;&gt;Worker&lt;/span&gt;(Runnable firstTask) {
    &lt;span class=&quot;co&quot;&gt;// 默认设置为-1，那么如果不调用当前工作者的run()方法，那么其状态是不会改变的，&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 其他的线程也无法使用当前工作者执行任务，在run()方法调用的runWorker()方法中会&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 调用unlock()方法使当前工作者处于正常状态&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;firstTask&lt;/span&gt; = firstTask;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;getThreadFactory&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;newThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);   &lt;span class=&quot;co&quot;&gt;// 使用线程工厂创建线程&lt;/span&gt;
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    &lt;span class=&quot;fu&quot;&gt;runWorker&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);    &lt;span class=&quot;co&quot;&gt;// 使用当前工作者执行任务&lt;/span&gt;
  }

  &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isHeldExclusively&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
  }

  &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; unused) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) {
      &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;());
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  }

  &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; unused) {
    &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;()        { &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); }
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;()  { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); }
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;()      { &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); }
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isLocked&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isHeldExclusively&lt;/span&gt;(); }

  &lt;span class=&quot;co&quot;&gt;// 如果当前线程已经在执行任务，那么将其标记为打断状态，待其任务执行完毕则终止任务的执行&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;interruptIfStarted&lt;/span&gt;() {
    Thread t;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (t = thread) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !t.&lt;span class=&quot;fu&quot;&gt;isInterrupted&lt;/span&gt;()) {
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        t.&lt;span class=&quot;fu&quot;&gt;interrupt&lt;/span&gt;();
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SecurityException ignore) {
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在工作者对象中，其主要维护了一个工作者线程，用于执行任务。该工作者对象继承了AbstractQueuedSynchronizer，用于控制当前工作者工作状态的获取，并且其也实现了Runnable接口，将主要任务的执行封装到run()方法中。如下是runWorker()方法的具体实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runWorker&lt;/span&gt;(Worker w) {
  Thread wt = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
  Runnable task = w.&lt;span class=&quot;fu&quot;&gt;firstTask&lt;/span&gt;;
  w.&lt;span class=&quot;fu&quot;&gt;firstTask&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
  w.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();   &lt;span class=&quot;co&quot;&gt;// 重置Worker对象的状态&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 首先执行工作者线程中的任务，然后循环从任务队列中获取任务执行&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (task != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || (task = &lt;span class=&quot;fu&quot;&gt;getTask&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      w.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
      &lt;span class=&quot;co&quot;&gt;// 检查当前线程池的状态，如果线程池被终止或者线程池终止并且当前线程已被打断&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((&lt;span class=&quot;fu&quot;&gt;runStateAtLeast&lt;/span&gt;(ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(), STOP) ||
           (Thread.&lt;span class=&quot;fu&quot;&gt;interrupted&lt;/span&gt;() &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;runStateAtLeast&lt;/span&gt;(ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(), STOP))) &amp;amp;&amp;amp; !wt.&lt;span class=&quot;fu&quot;&gt;isInterrupted&lt;/span&gt;())
        wt.&lt;span class=&quot;fu&quot;&gt;interrupt&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;beforeExecute&lt;/span&gt;(wt, task);    &lt;span class=&quot;co&quot;&gt;// 调用钩子方法进行预处理&lt;/span&gt;
        Throwable thrown = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
          task.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();   &lt;span class=&quot;co&quot;&gt;// 执行任务&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (RuntimeException x) {
          thrown = x; &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; x;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Error x) {
          thrown = x; &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; x;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable x) {
          thrown = x; &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(x);
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
          &lt;span class=&quot;fu&quot;&gt;afterExecute&lt;/span&gt;(task, thrown);   &lt;span class=&quot;co&quot;&gt;// 调用钩子方法进行任务完成后的处理工作&lt;/span&gt;
        }
      } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
        task = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;    &lt;span class=&quot;co&quot;&gt;// 重置工作者的初始任务&lt;/span&gt;
        w.&lt;span class=&quot;fu&quot;&gt;completedTasks&lt;/span&gt;++;
        w.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
      }
    }
    completedAbruptly = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    &lt;span class=&quot;fu&quot;&gt;processWorkerExit&lt;/span&gt;(w, completedAbruptly);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       可以看到，在runWorker()方法中，其首先会执行工作者对象的初始化任务，当执行完毕后会通过一个无限循环不断在任务队列中获取任务执行。如下是getTask()方法的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Runnable &lt;span class=&quot;fu&quot;&gt;getTask&lt;/span&gt;() {
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; timedOut = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rs = &lt;span class=&quot;fu&quot;&gt;runStateOf&lt;/span&gt;(c);

    &lt;span class=&quot;co&quot;&gt;// 判断当前线程是否处于STOP状态，或者处于SHUTDOWN状态，并且工作队列是空的，是则不返回任务&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;())) {
      &lt;span class=&quot;fu&quot;&gt;decrementWorkerCount&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; wc = &lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(c);
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;    &lt;span class=&quot;co&quot;&gt;// 是否允许空闲线程过期&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 工作线程数大于最大允许线程数，或者线程在指定时间内无法从工作队列中获取到新任务，则销毁当前线程&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut)) &amp;amp;&amp;amp; (wc &amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; || workQueue.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;())) {
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndDecrementWorkerCount&lt;/span&gt;(c))
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
      &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;co&quot;&gt;// 允许核心线程过期或者工作线程数大于corePoolSize时，从任务队列获取任务时会指定等待时间，&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// 否则会一直等待任务队列中新的任务&lt;/span&gt;
      Runnable r = timed ? workQueue.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(keepAliveTime, TimeUnit.&lt;span class=&quot;fu&quot;&gt;NANOSECONDS&lt;/span&gt;) : workQueue.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;();
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (r != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; r;
      timedOut = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException retry) {
      timedOut = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       可以看到，getTask方法首先会判断当前线程池状态是否为STOP状态，或者是SHUTDOWN状态，并且任务队列是空的，是则不返回任务，否则会根据相关参数从任务队列中获取任务执行。&lt;/p&gt;
&lt;p&gt;       以上execute()方法的主要实现步骤，在ThreadPoolExecutor中另一个至关重要的方法则是shutdown()方法，以下是shutdown()方法的主要代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;() {
  &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;mainLock&lt;/span&gt;;
  mainLock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;fu&quot;&gt;checkShutdownAccess&lt;/span&gt;();  &lt;span class=&quot;co&quot;&gt;// 检查对线程状态的控制权限&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;advanceRunState&lt;/span&gt;(SHUTDOWN);  &lt;span class=&quot;co&quot;&gt;// 更新当前线程池状态为SHUTDOWN&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;interruptIdleWorkers&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// 打断空闲的工作者&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;onShutdown&lt;/span&gt;();   &lt;span class=&quot;co&quot;&gt;// 钩子方法，但是没有对外公开，因为该方法只有包访问权限&lt;/span&gt;
  } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    mainLock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
  }
  &lt;span class=&quot;fu&quot;&gt;tryTerminate&lt;/span&gt;();   
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       在shutdown()方法中，其首先检查当前线程是否有修改线程状态的权限，然后将当前线程池的状态修改为SHUTDOWN，接着调用interruptIdleWorkers()方法中断所有处于空闲状态的线程，最后则是调用tryTerminate()方法尝试将当前线程池的状态由SHUTDOWN修改为TERMINATED，这里interruptIdleWorkers()方法最终会调用其重载方法interruptIdleWorkers(boolean)方法，该方法代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;interruptIdleWorkers&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; onlyOne) {
  &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;mainLock&lt;/span&gt;;
  mainLock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Worker w : workers) {
      Thread t = w.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!t.&lt;span class=&quot;fu&quot;&gt;isInterrupted&lt;/span&gt;() &amp;amp;&amp;amp; w.&lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;()) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
          t.&lt;span class=&quot;fu&quot;&gt;interrupt&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SecurityException ignore) {
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
          w.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
        }
      }
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (onlyOne)
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    }
  } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    mainLock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       可以看到，该方法会遍历所有的工作者对象，如果其处于空闲状态，则将其终止。对于处于工作状态的线程，由于在shutdown()方法中已经将当前线程池的状态设置为SHUTDOWN，那么工作状态的线程会将任务队列中的任务都执行完毕之后自动销毁。&lt;/p&gt;
&lt;p&gt;       本文主要讲解了ThreadPoolExecutor的主要方法，线程池的调度方式，以及其核心功能的实现原理，如本文有任何不当之处，敬请指正，谢谢！&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 10:59:00 +0000</pubDate>
<dc:creator>爱宝贝丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxufeng/p/8312528.html</dc:identifier>
</item>
</channel>
</rss>