<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用 k8s 运行一次性任务 - 每天5分钟玩转 Docker 容器技术（132） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8454758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8454758.html</guid>
<description>&lt;p&gt;&lt;span&gt;容器按照持续运行的时间可分为两类：服务类容器和工作类容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务类容器通常持续提供服务，需要一直运行，比如 http server，daemon 等。工作类容器则是一次性任务，比如批处理程序，完成后容器就退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 的 Deployment、ReplicaSet 和 DaemonSet 都用于管理服务类容器；对于工作类容器，我们用 Job。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一个简单的 Job 配置文件 myjob.yml：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064045805-321573546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;batch/v1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是当前 Job 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② 指明当前资源的类型为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Job&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定什么情况下需要重启容器。对于 Job，只能设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Never&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。对于其他 controller（比如 Deployment）可以设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Always&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply -f myjob.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 启动 Job。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064105847-1011314811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl get job&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 Job 的状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064121563-254103002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 都为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示按照预期启动了一个 Pod，并且已经成功执行。&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 Pod 的状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064133952-1424103149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为 Pod 执行完毕后容器已经退出，需要用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--show-all&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 才能查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Completed&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态的 Pod。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl logs&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以查看 Pod 的标准输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064149313-949204956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是 Pod 成功执行的情况，如果 Pod 失败了会怎么样呢？我们下一节讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 21:50:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8454758.html</dc:identifier>
</item>
<item>
<title>2017总结 - Arlenmbx</title>
<link>http://www.cnblogs.com/13224ACMer/p/8456161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/13224ACMer/p/8456161.html</guid>
<description>&lt;p&gt;2017过去了，辛苦又颇有收获的一年，这一年，一直跑在北京-哈尔滨-杭州三地，要把火车票和机票加起来，不下于20张，记得在北京实习的时候，不超过两周就会被学校叫回去考试，那时候对火车有种莫名的恐惧感。租的房子已经换过了5个。每一次找房子搬家都是最头疼的时候。实习接触的很多都是陌生的知识，一边要完成工作的内容，还要抽时间学习新的知识，还有学校的各种乱七八糟的考试，实验报告，毕业设计等等一大堆的烂摊子，每到晚上回到家的时候总会幻想这如果是宿舍多好，还有可以唠嗑的同学，可惜这里只有我一个人，睡觉，第二天还要早起工作。&lt;/p&gt;
&lt;p&gt;先说2017这一年---》&lt;/p&gt;
&lt;p&gt;1:比赛：&lt;/p&gt;
&lt;p&gt;没有参加一场比赛，这个主要还是因为自己一直在实习，没有时间和机会回学校参加，比较遗憾，也许比赛的事情就再也没有以后了。&lt;/p&gt;
&lt;p&gt;2:找实习：&lt;/p&gt;
&lt;p&gt;我找实习比较晚，大概都3月10号之后了，那时候投了很多，不过收到面试通知的时间都很晚，其实一开始拿到b家的实习offer，后续别的家的面试我就都拒绝了，除了a家。因为a在我心里还是比较向往的。不过在没有拿到offer之前的实习还是比较轻松顺利的，大致工作时间为1095的b和9105的a我觉得都属于正常工作强调（ps：工作时间不绝对，只是个人认为）&lt;/p&gt;
&lt;p&gt;3:秋招：&lt;/p&gt;
&lt;p&gt;秋招真是个屌丝逆袭的过程，几家欢喜几家愁，不过得到上天的眷顾，让我的秋招变得很顺利，顺利的拿到了很多喜欢公司的offer（ps：也不是很多，就是自己比较中意的3，4家，无论去其中哪一个都可以接受），不过也并不全是一帆风顺。其中的苦就不说了，不过感觉相对于大多数人还是拿到的更顺利些。在最终选择的时候其实犹豫不决，不过最终还是想回归本质，回到我喜欢的那个团队。虽然我个人意愿想去北京，更习惯北方的天气和饮食习惯，不过这都是可以改变的，get到技能也许对我来说更重要一些，说实话，HZ这里确实很多条件都比北京好很多，交通，天气，消费，MM..........&lt;/p&gt;
&lt;p&gt;4:个人娱乐：&lt;/p&gt;
&lt;p&gt;这一年，逛知乎，脉脉的频率大幅度增加，看头条，快手，火山视频，微博的频率大幅度降低，甚至卸载了头条，火山和微博，由于公司有台球，我又捡起了3年未练的台球，发现球技并没降低太多，时常想起高中那时候酷爱台球的我，每天放学都要打到半夜才回家的我，真是美好，那时候很多同学都要放学挑战我来5杆，不过大多数都是被我打败了，哈哈~~,最近在抽空学习guitar&lt;/p&gt;
&lt;p&gt;5：感情：&lt;/p&gt;
&lt;p&gt;nil，高中犯的错大学偿还，自从高中和初恋相处了三年，并在大学分手后再也没有接触过女生，也许是累了，对这方面目前真的是一点不感兴趣。三年后，LZ还要坚持做好一个单身狗的职责。&lt;/p&gt;
&lt;p&gt;6：亲情：&lt;/p&gt;
&lt;p&gt;这一年和家人接触甚少，算了一下，在家呆着时间没有超过10天，过年也没有回去，亏欠家人的还是好多，实习结束后一定要回家好好陪陪家人&lt;/p&gt;
&lt;p&gt;7：后记：&lt;/p&gt;
&lt;p&gt;大学四年，交的朋友不多，一个手可以数过来吧，不过我觉得这样才是真实的大学吧&lt;/p&gt;
&lt;p&gt;大学四年，回家的时间不多，一年大概全算上也就20天吧，几乎奉献给了竞赛和码砖，不过我觉得这样才是充实的大学吧&lt;/p&gt;
&lt;p&gt;大学四年，没有交往过女朋友，几乎都是和男生接触，不过我觉得这样才是理工科的大学吧&lt;/p&gt;
&lt;p&gt;大学四年，在宿舍的日子不过，一半都是在实验室打地铺度过了，不过我觉得这样才是无悔的大学吧&lt;/p&gt;

&lt;p&gt;本人不才，双非本科弱菜一枚，可我一直坚信计算机行业不分学历，只看技术，四年里，对我帮助的人很多&lt;/p&gt;
&lt;p&gt;感谢我的父母和家人对我的支持，无论我在学习做什么，他们一如既往的支持我，他们永远相信我&lt;/p&gt;
&lt;p&gt;感谢我的教练，四年来无形之中成为了我的指明灯&lt;/p&gt;
&lt;p&gt;感谢我的学长和学姐，对我学习路线的引导以及找实习工作的内推&lt;/p&gt;
&lt;p&gt;感谢我的队友王** 以及不断加入我们两个人的队伍中的所有人，我们一起刷了不知多少套的题，一起经历了无数AC的快感&lt;/p&gt;
&lt;p&gt;感谢我的几个好同学，大班长和强哥，考试前的复习，技术的讨论以及酒桌上的吹牛逼一直有我们几个的身影&lt;/p&gt;
&lt;p&gt;感谢大三实习认识的主管和师姐以及优秀的同事，感谢你们在我实习中对我的帮助，让我少走了很多弯路，打开了我的视野&lt;/p&gt;
&lt;p&gt;感谢博客园团队，让我4年来沉浸在这片属于我自己的天地，一步步搭建起自己的梦想家园&lt;/p&gt;
&lt;p&gt;感谢..........&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　---------柳下 &lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　   2018.2.21  01:44　　　　    &lt;/p&gt;

</description>
<pubDate>Tue, 20 Feb 2018 17:46:00 +0000</pubDate>
<dc:creator>Arlenmbx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/13224ACMer/p/8456161.html</dc:identifier>
</item>
<item>
<title>eclipse的maven项目中找不到Maven Dependencies - Visitors</title>
<link>http://www.cnblogs.com/dmeck/p/8456034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dmeck/p/8456034.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　今天记录一个初级错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　比如我们在eclipse创建maven项目来运行我们的web项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220232558221-444071489.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220232638333-2061703535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180221000201509-2011198444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　搭建完工程后发现javax-servlet包全部报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233344619-1791450561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　到这里我还不知道什么原因，想看原因的伙伴请移步最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找了半天都说是改eclipse配置文件，但是还是没用，只能翻看我之前看的项目视频，看看它是怎么搭建的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233653208-69720744.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先它是一个pom工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233737958-362939039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继承这个pom的jar&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234145247-1081648039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我操没问题啊，然后我又创建了下面这个项目一遍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220233102404-567774525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为毛还是没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234416763-2054746630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; --------------------------------------------------------------耿直的分割线-----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220235907120-1939506093.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;好了，细心的朋友已经知道原因了&lt;img src=&quot;https://images2018.cnblogs.com/blog/864142/201802/864142-20180220234623712-735798958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到它了吗？翻阅maven官方手册才知道，&lt;strong&gt;这是一个pom工程才会有的，它使里面的jar包不会加载，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意思就是，这是创建pom工程才会有的标签！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以后还是老老实实的看看手册才靠谱，不然以后就要看《从删库到跑路》这本名言了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 所以说这篇博客文不应该叫&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/doStudying/p/6478281.html&quot;&gt;解决项目中找不到Maven Dependencies&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而是叫 &amp;lt;dependencyManagement&amp;gt;标签的作用，但是相信很多老哥都是这样找bug出现的问题，但不知到问题所在，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总是去搜bug出现的问题，而不知道真正的问题，所以我觉得这个标题比较靠谱&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 20 Feb 2018 15:56:00 +0000</pubDate>
<dc:creator>Visitors</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dmeck/p/8456034.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：重启 manager 节点引发 docker swarm 集群宕机 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8455956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8455956.html</guid>
<description>&lt;p&gt;为了迎接春节假期后的访问高峰，我们今天对 docker swarm 集群进行了变更操作，购买了1台阿里云4核8G的服务器作为 worker 节点，由原来的  3 manager nodes + 2 worker nodes 变为  3 manager nodes + 3 worker nodes 。&lt;/p&gt;
&lt;p&gt;晚上，我们对已经持续运行一段时间的5个节点逐一进行重启操作，重启方式如下：&lt;/p&gt;
&lt;p&gt;1）docker node update --availability drain 让节点下线&lt;br/&gt;2）阿里云控制台重启服务器&lt;br/&gt;3）docker node update --availability active 让节点上线&lt;/p&gt;
&lt;p&gt;以前多次进行过这样的操作，未曾遇到问题，而今天在将其中1台manager节点下线后竟然意外地引发了整个集群宕机 。。。21:39 - 22:02 左右，这个突发的故障给您带来很大的麻烦，请您谅解。受这次故障影响的站点有 &lt;a href=&quot;https://ing.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;闪存&lt;/a&gt;，&lt;a href=&quot;https://q.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博问&lt;/a&gt;，&lt;a href=&quot;https://edu.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;班级&lt;/a&gt;，&lt;a href=&quot;https://home.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;园子&lt;/a&gt;，&lt;a href=&quot;https://msg.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;短信息&lt;/a&gt;，&lt;a href=&quot;https://job.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;招聘&lt;/a&gt;，&lt;a href=&quot;https://group.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;小组&lt;/a&gt;，&lt;a href=&quot;https://wz.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;网摘&lt;/a&gt;，&lt;a href=&quot;https://news.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;新闻&lt;/a&gt;，openapi 。&lt;/p&gt;
&lt;p&gt;经过分析，我们得到的教训是尽可能避免只有2个manager节点的情况（manager节点采用的是投票机制，少数服从多数，2个节点的投票永远是1:1，这也是一种不稳定情况）。针对这个教训，我们调整了节点的部署，改为了 5 manager nodes + 1 worker nodes ，这样即使2个manger节点下线或出问题，也不会群龙无首。&lt;/p&gt;
&lt;p&gt;docker swarm 集群的不稳定让我们如履薄冰，今年我们会想尽一切办法彻底解决这个问题。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:33:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8455956.html</dc:identifier>
</item>
<item>
<title>5.C++里的4种新型类型转换 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8456000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8456000.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1首先来&lt;span&gt;回顾&lt;/span&gt;&lt;span&gt;C的&lt;span&gt;强制转换&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大家都知道&lt;/span&gt;,&lt;span&gt;在编译&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言中的强制转换时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;编译器&lt;span&gt;不会检查&lt;/span&gt;转换是否成功&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;都会编译正确&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Position
{
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y;
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
 &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Position *&lt;span&gt;p;

 i&lt;/span&gt;=&lt;span&gt;0x123456&lt;/span&gt;&lt;span&gt;;

 p&lt;/span&gt;=(&lt;span&gt;struct&lt;/span&gt; Position *&lt;span&gt;)i;

 printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;px=%d,py=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;x,p-&amp;gt;&lt;span&gt;y);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;输出结果如下图所示&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201802/1182576-20180220231349143-1675499389.png&quot; alt=&quot;&quot; width=&quot;318&quot; height=&quot;89&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从上图可以看到&lt;/span&gt;,&lt;span&gt;只有当运行代码时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;才会出现段错误问题&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt;C&lt;span&gt;代码&lt;strong&gt;&lt;span&gt;上千行&lt;/span&gt;&lt;/strong&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;若出现这种问题&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是非常难找的&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2.C++的新型类型转换&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以在&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;便引入了&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;种&lt;/span&gt;&lt;/strong&gt;强制类型转换&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;span&gt;static_cast&lt;/span&gt;(&lt;span&gt;静态类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;基本数据&lt;/span&gt;&lt;/strong&gt;类型之间的转换&lt;/span&gt;&lt;span&gt;(char,int,const int&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不能用于&lt;/strong&gt;&lt;/span&gt;基本数据类型指针之间的转换&lt;/span&gt;&lt;span&gt;(char *,int *&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有继承关系类对象&lt;/span&gt;&lt;/strong&gt;之间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;类指针&lt;/span&gt;&lt;/strong&gt;之间的转换&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    int&lt;/span&gt; i = &lt;span&gt;0x45&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    c &lt;/span&gt;= static_cast&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;(i);    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char* pc = static_cast&amp;lt;char*&amp;gt;(&amp;amp;i);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能用于基本指针之间转换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 &lt;span&gt;const_cast&lt;/span&gt;(&lt;span&gt;去常类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;去除&lt;/span&gt;&lt;/strong&gt;变量的&lt;strong&gt;&lt;span&gt;只读属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;且强制转换的类型必须是&lt;strong&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;或&lt;strong&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt;1&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const：定义一个常量x&lt;/span&gt; 

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&amp;amp; j =&lt;span&gt;2&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const引用:定义一个只读变量j&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&amp;amp; p1= const_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;amp;&amp;gt;(x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换int &amp;amp;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; *p2 = const_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;*&amp;gt;(&amp;amp;j);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换int*

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int p3 = const_cast&amp;lt;int&amp;gt;(j);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能转换普通数据型&lt;/span&gt;
&lt;span&gt;
p1&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;*p2=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x=%d,   j=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,x,j);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1=%d  *p2=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p1,*p2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
x=&lt;span&gt;1&lt;/span&gt;   j=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

p1&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;  *p2=&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从输出结果&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可以看出修改&lt;/span&gt;&lt;span&gt;p1,p2,&lt;/span&gt;&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;内容变换了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是因为变量&lt;/span&gt;&lt;span&gt;j&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;引用定义的&lt;/span&gt;&lt;span&gt;,所以&lt;/span&gt;&lt;span&gt;是个只读变量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 dynamic_cast(&lt;span&gt;动态类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有继承关系的类指针&lt;/span&gt;&lt;/strong&gt;间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;strong&gt;&lt;span&gt;有交叉关系的类指针&lt;/span&gt;&lt;/strong&gt;间的转换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;具有&lt;span&gt;&lt;strong&gt;类型检查&lt;/strong&gt;&lt;/span&gt;的功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要&lt;strong&gt;&lt;span&gt;虚函数&lt;/span&gt;&lt;/strong&gt;的支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不能用于&lt;/strong&gt;&lt;/span&gt;基本数据类型指针之间的转换&lt;/span&gt;&lt;span&gt;(char *,int *&lt;span&gt;等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 reinterpret_ cast(&lt;span&gt;解读类型转换&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;用于&lt;span&gt;&lt;strong&gt;所有指针&lt;/strong&gt;&lt;/span&gt;的强制转换&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(&lt;span&gt;解读是指&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;对要转换的数据进行重新的解读&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; j=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;   *p1=reinterpret_cast&amp;lt;&lt;span&gt;int&lt;/span&gt; *&amp;gt;(&amp;amp;&lt;span&gt;i);

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;  *p2=reinterpret_cast&amp;lt;&lt;span&gt;char&lt;/span&gt; *&amp;gt;(&amp;amp;&lt;span&gt;j);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int  p3=reinterpret_cast&amp;lt;int &amp;gt;i;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此行错误,不能转换普通数据型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:24:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8456000.html</dc:identifier>
</item>
<item>
<title>Redis安装和基础介绍 - appleYang</title>
<link>http://www.cnblogs.com/zhikou/p/8455992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhikou/p/8455992.html</guid>
<description>&lt;p&gt;&lt;br/&gt;一：初识Redis&lt;/p&gt;
&lt;p&gt;　　Redis是一个远程内存数据库，它不仅性能强劲，而且还具有复制特性以及为解决问题而生的独一无二的数据模型。Redis提供了5种不同类型的数据结构，各式各样的问题都可以很自然地映射到这些数据结构上：Redis有着数据库没有的适应用户使用需求，此外，通过复制、持久化和客服端分片等特性，用户可以很方便的将Redis扩展成一个能够包含数百GB数据、每秒处理上百万次请求的系统。&lt;/p&gt;
&lt;p&gt;　　上面对Redis数据库只说出了一部分真相。Redis是一个速度非常快的非关系数据库，它可以存储键（key）与5种不同类型的值（value）之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片（是一种将数据划分为多个部分的方法，对数据的划分可以基于键包含的id，基于键的散列值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台服务器上，也可以从多台服务器上获取到数据，这种方法在解决某些问题时可以获得线性级别的性能提升）来扩展写的性能，接下来具体操作。&lt;/p&gt;
&lt;p&gt;二：安装Redis服务&lt;/p&gt;
&lt;p&gt;　　官方的Redis并没有Window安装包，但可以上github上有开源的代码，点击：&lt;a href=&quot;https://github.com/ServiceStack/redis-windows&quot; target=&quot;_blank&quot;&gt;https://github.com/ServiceStack/redis-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220225652148-2027098308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开cmd开启redis-server&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230313814-827363576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redis-cli.exe文件是客户端，cmd运行它之后就可以执行redis命令了。&lt;/p&gt;

&lt;div start=&quot;1&quot;&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span&gt;redis-server --service-install redis.windows.conf --loglevel verbose &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230701019-961611406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看服务是否存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220230914776-75768410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Redis的命令还是需要打开它的客户端redis-cli.exe的。&lt;/p&gt;
&lt;p&gt;更多的redis命令，可以看官方网站或中文站，戳这里：&lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;顺便介绍一个Redis可视化工具，&lt;a href=&quot;https://github.com/uglide/RedisDesktopManager&quot; target=&quot;_blank&quot;&gt;RedisDesktopManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它开源的，托管在github上：&lt;a href=&quot;https://github.com/uglide/RedisDesktopManager&quot; target=&quot;_blank&quot;&gt;https://github.com/uglide/RedisDesktopManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终，为了什么呢？不安装会出错的，大哥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1137026/201802/1137026-20180220231629137-1064669965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后开启服务之后就可以成功运行了&lt;/p&gt;

</description>
<pubDate>Tue, 20 Feb 2018 15:18:00 +0000</pubDate>
<dc:creator>appleYang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhikou/p/8455992.html</dc:identifier>
</item>
<item>
<title>【SSH框架】之Hibernate系列一 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8455986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8455986.html</guid>
<description>
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3 id=&quot;h1hibernate&quot;&gt;1、Hibernate框架概述&lt;/h3&gt;
&lt;p&gt;（1）、什么是Hibernate&lt;br/&gt;Hibernate是一个开放源代码的 ORM 框架，是主流的Java持久层框架之一，它对 JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。&lt;br/&gt;（2）、Hibernate在三层架构中的位置&lt;br/&gt;上篇文章所讲的Struts2框架取代的是三层框架中的web层，而Hibernate框架取代的则是dao层，具体描述如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b33a5e0e10c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）、什么是ORM&lt;br/&gt;ORM（Object Relational Mapping），即对象关系映射，就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把 ORM 理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM 实现原理如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b359b2c1b9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（4）、Hibernate框架的优势与功能&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Hlbernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。&lt;/li&gt;
&lt;li&gt;Hlbernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO (DataAccess Object，数据访问对象）层编码工作。操作数据库的时候，可以以面向对象的方式来完成，不再需要书写SQL语句。&lt;/li&gt;
&lt;li&gt;Hlbernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。&lt;/li&gt;
&lt;li&gt;可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h2hibernate&quot;&gt;2、搭建Hibernate框架，完成第一个应用实例&lt;/h3&gt;
&lt;p&gt;（1）、创建一个web项目，导入所需要的jar包，包括数据库驱动包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b37b63c6d3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）、创建数据库demo_project和表user，建表语句如下：&lt;/p&gt;

&lt;p&gt;创建数据库demo_project语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create &lt;span class=&quot;hljs-keyword&quot;&gt;database demo_project;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见表user语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE &lt;span class=&quot;hljs-string&quot;&gt;`user` (
  &lt;span class=&quot;hljs-string&quot;&gt;`id` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;10) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`name` &lt;span class=&quot;hljs-built_in&quot;&gt;varchar(&lt;span class=&quot;hljs-number&quot;&gt;50) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`age` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;3) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`height` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;11) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`weight` &lt;span class=&quot;hljs-keyword&quot;&gt;double(&lt;span class=&quot;hljs-number&quot;&gt;10,&lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY (&lt;span class=&quot;hljs-string&quot;&gt;`id`)
) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET=utf8;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、创建实体User.java，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.demo;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、导入约束，在与实体同一个包下新建ORM配置文件User.hbm.xml，书写ORM元数据，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.hbm.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC 
    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、在src下新建hibernate.cfg.xml主配置文件，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-configuration&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;session-factory&amp;gt;

         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）、新建测试类TestDemo.java，书写测试代码，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TestDemo.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Session;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.SessionFactory;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Transaction;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.cfg.Configuration;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.junit.Test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.hibernate.domain.User;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）、使用JUnit测试运行，信息插入成功，具体结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b3c5e45d471?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b414a6abb2b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本项目运行环境：jdk1.7、Tomcat7.0&lt;/p&gt;

&lt;h3 id=&quot;h3hibernate&quot;&gt;3、Hibernate配置文件详解&lt;/h3&gt;
&lt;p&gt;（1）、orm元数据配置详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;property&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、Hibernate主配置文件详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;引入orm元数据配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;关注微信公众号compassblog，后台回复 “&lt;strong&gt;Hibernate系列一&lt;/strong&gt;&lt;span&gt;” 获取本项目源码&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;

&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;
&lt;h2&gt;扫码关注微信公众号，了解更多&lt;/h2&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180220230815636&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:14:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8455986.html</dc:identifier>
</item>
<item>
<title>使用 RxJS 实现一个简易的仿 Elm 架构应用 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8455974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8455974.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 前端&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;什么是-elm-架构&quot;&gt;什么是 Elm 架构&lt;/h2&gt;
&lt;p&gt;Elm 架构是一种使用 Elm 语言编写 Web 前端应用的简单架构，在代码模块化、代码重用以及测试方面都有较好的优势。使用 Elm 架构，可以非常轻松的构建复杂的 Web 应用，无论是面对重构还是添加新功能，它都能使项目保持良好的健康状态。&lt;/p&gt;
&lt;p&gt;Elm 架构的应用通常由三部分组成——&lt;strong&gt;模型&lt;/strong&gt;、&lt;strong&gt;更新&lt;/strong&gt;、&lt;strong&gt;视图&lt;/strong&gt;。这三者之间使用 &lt;strong&gt;Message&lt;/strong&gt; 来相互通信。&lt;/p&gt;
&lt;h3 id=&quot;模型&quot;&gt;模型&lt;/h3&gt;
&lt;p&gt;模型通常是一个简单的 POJO 对象，包含了需要展示的数据或者是界面显示逻辑的状态信息，在 Elm 语言中，通常是自定义的“记录类型”，模型对象及其字段都是不可变的（immutable）。使用 TypeScript 的话，可以简单的用接口来描述模型：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export interface IHabbitPresetsState {
    presets: IHabbitPreset[];
    isLoading: boolean;
    isOperating: boolean;
    isOperationSuccess: boolean;
    isEditing: boolean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，我们就需要在心中谨记，&lt;strong&gt;永远不要去修改模型的字段！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;message&quot;&gt;Message&lt;/h3&gt;
&lt;p&gt;Message 用来定义应用程序在运行过程中可能会触发的事件，例如，在一个秒表应用中，我们会定义“开始计时”、“暂停计时”、“重置”这三种事件。在 Elm 中，可以使用 Union Type 来定义 Message，如果使用 TypeScript 的话，可以定义多个消息类，然后再创建一个联合类型定义：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export type HabbitPresetsMsg =
    Get | Receive
    | Add | AddResp
    | Delete | DeleteResp
    | Update | UpdateResp
    | BeginEdit | StopEdit;

export class Get {
}

export class Receive {
    constructor(public payload: IHabbitPreset[]) { }
}

export class Add {
    constructor(public payload: IHabbitPreset) { }
}

export class AddResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class Delete {
    constructor(public payload: number) {
    }
}

export class DeleteResp {
    constructor(public payload: number) { }
}

export class Update {

    constructor(public payload: IHabbitPreset) {
    }
}

export class UpdateResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class BeginEdit {
    constructor(public payload: number) { }
}

export class StopEdit {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的应用程序一般从视图层来触发 Message，比如，在页面加载完毕后，就立即触发“加载数据”这个 Message，被触发的 Message 由更新模块来处理。&lt;/p&gt;
&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;
&lt;p&gt;更新，即模型的更新方式，通常是一个函数，用 TypeScript 来描述这个函数就是：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;update(state: IHabbitPresetsState, msg: HabbitPresetsMsg): IHabbitPresetsState&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每当一个新的 Message 被触发的时候，Elm 架构便会将应用程序当前的模型跟接受到 Message 传入 update 函数，再把执行结果作为应用程序新的模型——这就是模型的更新。&lt;br/&gt;在 Elm 程序中，视图的渲染仅依赖模型中的数据，所以，模型的更新往往会导致视图的更新。&lt;/p&gt;
&lt;h3 id=&quot;视图&quot;&gt;视图&lt;/h3&gt;
&lt;p&gt;Elm 语言自带了一个前端的视图库，其特点是视图的更新仅依赖模型的更新，几乎所有的 Message 也都是由视图来触发。但在这篇文章里面，我将使用 Angular5 来演示效果，当然了，也可以使用 React 或者 jQuery 来实现视图，这取决于个人爱好。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;至此，我们大致的了解了一下 Elm 架构的几个要点：模型、更新、视图以及 Message。一个 Elm 架构的程序，通常是视图因为用户的动作触发特定 Message，然后由这个触发的 Message 跟当前应用的模型计算得出新的模型，新的模型的产生使得视图产生变化。&lt;/p&gt;
&lt;h2 id=&quot;开始实现&quot;&gt;开始实现&lt;/h2&gt;
&lt;p&gt;首先让我们写出一个空的框架：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TState 表示应用程序的模型类型，TMsgType 表示应用程序的消息联合类型。&lt;/p&gt;
&lt;p&gt;由上一节可以知道，Message 是应用程序能够运行的关键，Message 在运行时要能够手动产生，并且，Message 的触发还要能被监听，所以，可以使用 RxJS/Subject 来构建一个 Message 流。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
    private readonly $msg = new Subject&amp;lt;TMsgType&amp;gt;();
    send(msg: TMsgType) {
        this.$msg.next(msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里之所以定义一个 send 函数是为了更好的将代码封装起来，消息流对外只暴露一个触发消息的接口。&lt;/p&gt;
&lt;p&gt;接下来，我们可以考虑一下模型流的实现。他跟消息流很类似，首先要能被监听，其次，还接收到消息后还要能手动产生，所以也可以使用 Subject 来实现。但是这里我用的是 BehaviorSubject ，因为 Behavior Subject 能够保留最后产生的对象，这样我们就可以随时访问模型里面的数据，而不需要使用 Subscribe。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，1/3 的工作已经完成了，现在来按照我们的要求，使用 rxjs 让消息流能正确的触发模型流的更新。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.update, initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scan 是 rxjs 的一个操作符，类似于 JS 中的 reduce，LINQ 中的 Aggregate。因为设置了一个初始模型（initState），所以在消息流每次产生新的消息的时候，update 函数就可以接收到上一次计算出来的模型，以及最新接收到的消息，然后返回新的模型。也就是说，scan 将消息流转化为了新的模型流。接着订阅这个模型流，并用之前定义的 BehaviorSubject 来广播新的模型。&lt;/p&gt;
&lt;p&gt;这里就接近完成 1/2 的工作了，模型跟消息这两个的东西已经实现好了，接下来就继续实现更新。&lt;/p&gt;
&lt;p&gt;Elm 是一门函数式语言，模式匹配的能力比 js 不知道高到哪里去了，既然要模仿 Elm 架构，那么这个地方也要仿出来。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; =
    [new (...args: any[]) =&amp;gt; TMsg, (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState];

    /**
     * Pattern matching syntax
     * @template TMsg
     * @param {new (...args: any[]) =&amp;gt; TMsg} type constructor of Msg
     * @param {(acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState} reducer method to compute new state
     * @returns {Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;}
     * @memberof ElmArch
     */
    caseOf&amp;lt;TMsg&amp;gt;(
        type: new (...args: any[]) =&amp;gt; TMsg,
        reducer: (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState)
        : Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; {
        return [type, reducer];
    }

    matchWith&amp;lt;TMsg&amp;gt;($msg: Subject&amp;lt;TMsgType&amp;gt;, patterns: Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;[]) {
        return (acc: TState, msg: TMsg) =&amp;gt; {
            const state = acc;
            for (const it of patterns) {
                if (msg instanceof it[0]) {
                    return it[1](state, msg, $msg);
                }
            }
            throw new Error('Invalid Message Type');
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们定义了一个元组类型 &lt;code&gt;Pattern&lt;/code&gt; 用来表示模式匹配的语法，在这里面，主要需要实现的是基于类型的匹配，所以元组的第一个元素是消息类，第二个参数是当匹配成功时要执行的回调函数，用来计算新的模型，使用 &lt;code&gt;caseOf&lt;/code&gt; 函数可以创建这种元组。&lt;code&gt;matchWith&lt;/code&gt; 函数的返回值是一个函数，与 &lt;code&gt;scan&lt;/code&gt; 的第一个参数的签名相符合，第一个参数是最后被创建出来的模型，第二个参数是接收到的消息。在这个函数中，我们找到与接收到的消息相匹配的 pattern 元组，然后用这个元组的第二个元素计算出新的模型。&lt;/p&gt;
&lt;p&gt;用上面的东西就可以比较好的模拟模式匹配的功能了，写出来的样子像这样：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;const newStateAcc = matchWith(msg, [
            caseOf(GetMonth, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(GetMonthRecv, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(ChangeDate, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecord, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecordRecv, (s, m) =&amp;gt; {
                // blablabla
            })
        ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，之前用来构建模型流的地方就需要做一些改动：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在构建模型流需要依赖一个初始状态跟一个模式数组，那么就可以用一个函数封装起来，将这两个依赖项作为参数传入：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;begin(initState: TState, patterns: Pattern&amp;lt;any, TState, TMsgType&amp;gt;[]) {
        const $res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);
        this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });
        return $res;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止，2/3 的工作就已经完成了，我们设计出了消息流、模型流以及处理消息的更新方法，做一个简单的计数器是完全没有问题的。&lt;a href=&quot;https://stackblitz.com/edit/angular-6uk7be?embed=1&amp;amp;file=app/hello.component.ts&quot;&gt;点击查看样例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是实际上，我们需要面对的问题远不止一个计数器这么简单，更多的情况是处理请求，有时候还需要处理消息的时候触发新的消息。对于异步的请求，需要在请求的响应中触发新的消息，可以直接调用 &lt;code&gt;$msg.next()&lt;/code&gt; ，对于需要在更新的操作中触发新的消息，也可以主动调用 &lt;code&gt;$msg.next()&lt;/code&gt; 这个函数就好了。&lt;/p&gt;
&lt;p&gt;不过，事情往往没有这么简单，因为模型流并不是从消息流直接通过 rxjs 的操作符转换出来的，而更新函数中模式匹配部分执行时间长短不一，这可能导致消息与模型更新顺序不一致的问题。我想出的解决方法是：对于同步的操作需要触发新的消息，就必须要保证当前消息处理完成后，模型的更新被广播出去后才能触发新的消息。基于这一准则，我就又添加了一些代码：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type UpdateResult&amp;lt;TState, TMsgType&amp;gt; = TState | [TState, TMsgType[]];

/**
* Generate a result of a new state with a sets of msgs, these msgs will be published after new state is published
* @param {TState} newState
* @param {...TMsgType[]} msgs
* @returns {UpdateResult&amp;lt;TState, TMsgType&amp;gt;}
* @memberof ElmArch
*/
nextWithCmds(newState: TState, ...msgs: TMsgType[]): UpdateResult&amp;lt;TState, TMsgType&amp;gt; {
    if (arguments.length === 1) {
        return newState;
    } else {
        return [newState, msgs];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我添加了新的类型—— &lt;code&gt;UpdateResult&amp;lt;TState, TMsgType&amp;gt;&lt;/code&gt;，这个类型表示模型类型或模型类型与消息数组类型的元组类型。这么说起来确实有些绕口，这个类型存在的意义就是：Update 函数除了返回新的模型之外，还可以选择性的返回接下来要触发的消息。这样，单纯的模型流就变成了模型消息流，接着在 &lt;code&gt;subscribe&lt;/code&gt; 的地方，在原先的模型流产生新的模型的地方后面再去触发新的消息流，如果返回结果中有需要触发的消息的话。&lt;/p&gt;
&lt;p&gt;完整代码在此：&lt;a href=&quot;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&quot; class=&quot;uri&quot;&gt;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用样例&quot;&gt;使用样例&lt;/h2&gt;
&lt;p&gt;在上面的 gits 中提到了一个样例，但是不是很完整，之后会放出完整例子。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看到这里，你可能已经发现了，本文实现的这个小工具看起来跟 redux 挺像的，确实，redux 也是 js 程序员对 Elm 架构的致敬。通过把 Web 应用的逻辑拆解成一个个状态间改变的逻辑，可以帮助我们更好的理解所编写的东西，同时，也让 MV* 的思想得到进一步的展现，因为在编写 update 相关的代码的时候，可以在实现业务逻辑的同时而毫不碰触 UI 层面的东西，所以，正如本文开头提到的，视图可以是任何东西：React、Angular、jQuery，这都没关系，只要能够对模型的 Observable 流的改变做出响应， DOM API 也是可以的，可能，这就是所谓的响应式编程吧。&lt;/p&gt;
&lt;h3 id=&quot;对于普通的-angular-应用来说意味这什么&quot;&gt;对于普通的 Angular 应用来说意味这什么？&lt;/h3&gt;
&lt;p&gt;在我自己将这个小工具结合 Angular 的使用体验来看，最大的改变就是&lt;strong&gt;代码变得更加有规律&lt;/strong&gt;了，特别是处理异步并改变 UI 的场景，变得更容易套路化，更容易套路化就意味着更方便生成代码了。再一个，在 Angualr 中，如果组件依赖的所有输入都是 Observable 对象，那么可以将默认的变更检查策略改为：OnPush。这样，&lt;strong&gt;Angular 就不用对这个组件进行“脏检查”了&lt;/strong&gt;，只有在 Observable 发生更新的时候，才会去重新改变组件，这个好处，不言而喻。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:06:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8455974.html</dc:identifier>
</item>
<item>
<title>ES6 学习笔记之一 块作用域与let和const - 刘兴伟</title>
<link>http://www.cnblogs.com/matchless/p/8455218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/matchless/p/8455218.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;在学习ES6的块作用域和 let、const 之前，我们先来看看ES5以前的 var 关键字。&lt;/p&gt;
&lt;p&gt;var 关键字用于定义一个变量，通常我们会将其与变量的赋值合并为一条语句，就像下面这样（例1）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际情况是有些微妙的。&lt;/p&gt;
&lt;p&gt;在JavaScript中，变量的定义与否，虽然不像强类型语言那样重要，但也还是有所不同的。&lt;/p&gt;
&lt;p&gt;变量未定义，是一种未捕获类型的错误，输出的结果是变量未定义，同时终止后续脚本的执行，示例如下（例2）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
age is not defined.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已经定义但未赋值的变量，输出的结果是undefined（这个undefined不是未定义，是指变量的值为undefined，这是JavaSript中的一个特殊的值）。示例如下（例3）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;var 定义变量语句，在JavaScript中会被编译器提前到整个作用域的最前端，无论它写在脚本的哪个位置。示例如下（例4）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;这个待遇只有 var 定义语句都有，赋值语句是不会被提前的。当我们在代码中写下一条定义的同时赋值的 var 语句时，编译器会将其拆分为定义语句和赋值语句，并将定义语句提前，而赋值语句仍然留在原处。&lt;/p&gt;
&lt;p&gt;请看下面的例子（例5）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30;&lt;br/&gt;console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与如下例子的输出是一致的（例6）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还知道，JavaScript中变量可以不定义就使用，比如（例7）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age = 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;这种直接赋值的语句，与定义的同时赋值，还是有所不同。参见下面的例子（例8）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以一例5有这么大的区别，在于这里只有变量赋值，没有 var 定义部分。编译器不会自动补充一个 var 定义并提前至作用域最前（或者说编译器补充了一个隐含的 var 定义，但是这个隐含的 var 定义不会被提前），因此第一个console.log语句会直接报出变量未定义的错误，之后的变量赋值和输出语句不被执行。&lt;/p&gt;
&lt;p&gt;为避免误用未定义的变量，在使用变量前，要养成在使用变量前用 var 进行定义的好习惯:)。除非在函数作用域内要使用父作用域的变量，这也是闭包存在的根源。&lt;/p&gt;
&lt;p&gt;如果可能，可以使用严格模式，即在脚本作用域的第一行，写下 &quot;use strict&quot;（注意要带着又引号哦）。这样做的一个好处是，WebStorm 这样的 IDE 会在为未定义的变量赋值时，直接给出警告。&lt;/p&gt;
&lt;h3&gt;块作用域&lt;/h3&gt;
&lt;p&gt;块作用域是指用一对花括号括住的语句块使用域。在ES5以前，是没有块作用域的，它只有函数作用域，因此 var 在非函数作用域的括号内，与在括号外，没有区别。为了保持向下兼容，在ES6中，var 在块作用域中仍然保持其原有性状。如下例（例9）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未定义就赋值的变量，也与原来的表现一致（例10）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要使块作用域别有不一样的意义，就需要 let 和 const，这两个关键字了。&lt;/p&gt;

&lt;p&gt;---恢复内容结束---&lt;/p&gt;
&lt;p&gt;在学习ES6的块作用域和 let、const 之前，我们先来看看ES5以前的 var 关键字。&lt;/p&gt;
&lt;p&gt;var 关键字用于定义一个变量，通常我们会将其与变量的赋值合并为一条语句，就像下面这样（例1）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但实际情况是有些微妙的。&lt;/p&gt;
&lt;p&gt;在JavaScript中，变量的定义与否，虽然不像强类型语言那样重要，但也还是有所不同的。&lt;/p&gt;
&lt;p&gt;变量未定义，是一种未捕获类型的错误，输出的结果是变量未定义，同时终止后续脚本的执行，示例如下（例2）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
age is not defined.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已经定义但未赋值的变量，输出的结果是undefined（这个undefined不是未定义，是指变量的值为undefined，这是JavaSript中的一个特殊的值）。示例如下（例3）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;var 定义变量语句，在JavaScript中会被编译器提前到整个作用域的最前端，无论它写在脚本的哪个位置。示例如下（例4）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;

&lt;p&gt;这个待遇只有 var 定义语句都有，赋值语句是不会被提前的。当我们在代码中写下一条定义的同时赋值的 var 语句时，编译器会将其拆分为定义语句和赋值语句，并将定义语句提前，而赋值语句仍然留在原处。&lt;/p&gt;
&lt;p&gt;请看下面的例子（例5）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30;&lt;br/&gt;console.log(age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与如下例子的输出是一致的（例6）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age;
console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还知道，JavaScript中变量可以不定义就使用，比如（例7）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age = 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;这种直接赋值的语句，与定义的同时赋值，还是有所不同。参见下面的例子（例8）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
age &lt;/span&gt;= 30&lt;span&gt;;
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以一例5有这么大的区别，在于这里只有变量赋值，没有 var 定义部分。编译器不会自动补充一个 var 定义并提前至作用域最前（或者说编译器补充了一个隐含的 var 定义，但是这个隐含的 var 定义不会被提前），因此第一个console.log语句会直接报出变量未定义的错误，之后的变量赋值和输出语句不被执行。&lt;/p&gt;
&lt;p&gt;为避免误用未定义的变量，在使用变量前，要养成在使用变量前用 var 进行定义的好习惯:)。除非在函数作用域内要使用父作用域的变量，这也是闭包存在的根源。&lt;/p&gt;
&lt;p&gt;如果可能，可以使用严格模式，即在脚本作用域的第一行，写下 &quot;use strict&quot;（注意要带着又引号哦）。这样做的一个好处是，WebStorm 这样的 IDE 会在为未定义的变量赋值时，直接给出警告。&lt;/p&gt;
&lt;h3&gt;块作用域&lt;/h3&gt;
&lt;p&gt;块作用域是指用一对花括号括住的语句块使用域。在ES5以前，是没有块作用域的，它只有函数作用域，因此 var 在非函数作用域的括号内，与在括号外，没有区别。为了保持向下兼容，在ES6中，var 在块作用域中仍然保持其原有性状。如下例（例9）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined
&lt;/span&gt;30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未定义就赋值的变量，也与原来的表现一致（例10）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;要使块作用域别有不一样的意义，就需要 let 和 const，这两个关键字了。&lt;/p&gt;
&lt;p&gt;let 关键字与 var 的作用类似，都是定义变量，也都可以在定义变量的同时，为变量赋值。不同之处有以下两点：&lt;/p&gt;
&lt;p&gt;第一，let 可以定义（仅在）块作用域内（有效）的变量。如下例所示（例11）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    let age &lt;/span&gt;= 30&lt;span&gt;;
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对照例9，可以看出区别所在。&lt;/p&gt;
&lt;p&gt;第二，let 定义变量语句，不会被提前至作用域最前。见下例（例12）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
let age &lt;/span&gt;= 30;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对照例4，可以看出区别所在。&lt;/p&gt;
&lt;p&gt;还有一个细节，let 和 var 都有在子作用域内定义与父作用域同名变量时，屏蔽父作用域同名变量的作用。&lt;/p&gt;
&lt;p&gt;见如下两例：&lt;/p&gt;
&lt;p&gt;（例13）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
    console.log(age);
})();
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（例14）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
{
    let age &lt;/span&gt;= 30&lt;span&gt;;
    console.log(age);
}
console.log(age);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果均为：&lt;/p&gt;

&lt;p&gt;区别在于，如果在子作用域中，定义同名变量之前就使用该变量，对于 var 而言，由于其会被提前至本作用域的开头，因此得到的是undefined。对于let，不会被提前，却也不会使用父作用域的变量，而是报出引用错误。示例如下：&lt;/p&gt;
&lt;p&gt;（例15）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(age);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;

&lt;p&gt;（例16）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 20&lt;span&gt;;
{
    console.log(age);
    let age &lt;/span&gt;= 30&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ReferenceError: age is not defined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 还要说明一点，在ES6中，所有具有语句块含义花括号括住的部分都构成块作用域，包括单纯的语句块、if语句块、while语句块、for语句块、break语句块和函数语句块。&lt;/p&gt;
&lt;p&gt;而出现在if语句块的条件部分，for语句块的循环变量赋值部分的let定义，相当于在语句块内部执行的let定义。&lt;/p&gt;
&lt;p&gt;尤其在for的循环变量定义，会在每次迭代中执行一遍，就相当于每次迭代定义一个变量，迭代结束销毁，循环多少次，生成多少个不同的循环变量。 这个特点的实际意义，可以用下面的两个示例说明。&lt;/p&gt;
&lt;p&gt;（例17）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(i);
    }
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能会预期其输出结果为：&lt;/p&gt;

&lt;p&gt;实际输出结果为：&lt;/p&gt;

&lt;p&gt;（例18）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(i);
    }
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;p&gt;在没有块作用域和let关键字之前，要实现同样效果，需要利用闭包（例19）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn  =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    fn[i] &lt;/span&gt;= (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log(i);
        }
    })(i);
}
fn[&lt;/span&gt;0&lt;span&gt;]();
fn[&lt;/span&gt;1&lt;span&gt;]();
fn[&lt;/span&gt;2]();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 let 相较于 var 优势明显，又没有明显的缺点，在ES6兼容环境下，可以完全抛弃 var，而用 let 代替。&lt;/p&gt;
&lt;p&gt;《你不知道的JavaScript》中，提倡C语言风格的 let 使用方法，即在作用域的起始处使用 let 定义作用域内的所有变量，这样可以避免变量未定义就使用的情况发生。&lt;/p&gt;
&lt;p&gt;个人觉得还是按现代编程语言就近声明的惯例更合适，可以避免无意识的误用，而且在阅读时也不需要在代码间跳跃以寻找变量定义和赋值。不过如果能保持代码块的简短，又能坚持同一变量在同一作用域内不作两用的原则，其实放在哪儿都无关紧要。&lt;/p&gt;
&lt;p&gt;对于 const，其实没有太多需要说明的，常量定义而已。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 14:19:00 +0000</pubDate>
<dc:creator>刘兴伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/matchless/p/8455218.html</dc:identifier>
</item>
<item>
<title>什么是递归?先了解什么是递归. - Pushy</title>
<link>http://www.cnblogs.com/Pushy/p/8455862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Pushy/p/8455862.html</guid>
<description>&lt;blockquote readability=&quot;5.1153846153846&quot;&gt;
&lt;p&gt;你好！欢迎阅读我的博文，你可以跳转到&lt;a href=&quot;http://blog.pushy.site/&quot;&gt;我的个人博客网站&lt;/a&gt;，会有更好的排版效果和功能。&lt;br/&gt;此外，本篇博文为本人Pushy原创，如需转载请注明出处：&lt;a href=&quot;http://blog.pushy.site/posts/1519134018&quot; class=&quot;uri&quot;&gt;http://blog.pushy.site/posts/1519134018&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一说起递归,我想每个人都不陌生.举个从小就听过的例子:从前有座山,山里有座庙,庙里有个和尚,和尚在讲故事,从前有座山,山里有座庙,庙里有个和尚,和尚在讲故事,从前有座山...,还有你从两面相对的镜子中看到的画面,其实都是抽象出来的递归现象,但是严格来说并不是递归,因为会一直重复下去,没有终止条件,那就称为死循环了.有关递归和死循环的异同我们之后会说到,那么现在先来了解一下什么是递归?&lt;/p&gt;
&lt;p&gt;那么什么是递归呢? &lt;strong&gt;要理解递归,就得先了解什么是递归&lt;/strong&gt;,实际上这句话就是一个递归.这么说可能不好理解,接下来我举个简单的例子来解释这段话的意义.&lt;/p&gt;
&lt;p&gt;假设我们现在都不知道什么是递归,我们自然想到打开浏览器,输入到谷歌的网页,我们点击搜索递归,然后我们在为维基百科中了解到了递归的基本定义,在了解到了递归实际上是和栈有关的时候,你又蒙圈了,什么是栈呢?数据结构没学清楚,此时的你只能又打开谷歌,搜索什么是栈.接下来你依次了解了内存/操作系统.在你基本了解好知识之后,你通过操作系统了解了内存,通过内存了解了栈,通过栈了解了什么是递归这下你恍然大悟!原来这就是递归啊!&lt;/p&gt;
&lt;p&gt;这下应该有点明白了吧,这个过程其实就是递归的过程,如果不了解递归,那就先了解什么是递归,可能你会说这是个循环并不是递归,我们前面说到,递归是需要终止条件的,那么&lt;strong&gt;你明白递归是什么&lt;/strong&gt;其实就是终止条件.整个过程,搜索引擎充当递归函数(只是形象的假设);在你去依次查找递归/栈/内存/操作系统的过程为前行阶段,在你都了解完之后,反回去了解含义的过程为退回阶段.如果还是不太清楚,可以接着看下面的例子&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;2. 示例:&lt;/h2&gt;
&lt;p&gt;也许之前你在网络上看到过这张图片:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/xiaoliyu.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上这张图就很形象地表达出了递归,这句&lt;strong&gt;吓得我抱起了抱着抱着抱着我的小鲤鱼的我的我的我&lt;/strong&gt;如果从字面意义上看可能看不出是什么意思,那么我们可以通过代码来实现同样的效果:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(depth) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'抱着'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;depth) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'我的小鲤鱼'&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;depth)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 递归调用&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'的我'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'吓得我抱起了'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;Recursion&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在终端的打印结果为如下,可以看到和上面的那段话是一样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/xiaoliyuconsole.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码其实十分简单,但是需要理解的是:&lt;code&gt;if&lt;/code&gt;代码块的条件(&lt;code&gt;!depth&lt;/code&gt;)为递归调用的终止条件,在&lt;code&gt;else&lt;/code&gt;代码块内递归调用函数.我们前面有说到递归的过程是存在前行和退回阶段的,那么在前行阶段我们在每次调用函数后,打印出了&quot;抱着&quot;,并且当&lt;code&gt;depth≠0&lt;/code&gt;时重新调用该函数;在退回阶段,将会去执行代码&lt;code&gt;console.log('的我');&lt;/code&gt;再打印出&quot;的我&quot;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/people/chuyue/activities&quot;&gt;褚跃跃&lt;/a&gt;的图也能比较清楚地反映出这个过程:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.pushy.site/pic/enterReturn.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了!这下你应该明白什么是递归了吧?如果你还没有明白什么是递归的话,你可以看&lt;a href=&quot;http://www.cnblogs.com/Pushy/p/8455862.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用&quot;&gt;3. 应用:&lt;/h2&gt;
&lt;h3 id=&quot;斐波拉契数列&quot;&gt;3.1 斐波拉契数列:&lt;/h3&gt;
&lt;p&gt;有关递归应用的应用有很多,例如注明的&lt;a href=&quot;https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin&amp;amp;fromid=10078434&amp;amp;fromtitle=%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97&quot;&gt;斐波拉契数列&lt;/a&gt;就可以通过递归来实现:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; fib(x):
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 当x &amp;gt; 2时,开始递归调用fib()函数:&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; fib(x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; fib(x &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(fib(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# 打印结果为:8&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要对&lt;code&gt;i&amp;lt;2&lt;/code&gt;时的特殊情况做出判断,当&lt;code&gt;x==0&lt;/code&gt;时,直接返回&lt;code&gt;0&lt;/code&gt;,当&lt;code&gt;x==1&lt;/code&gt;时,直接返回&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;遍历文件&quot;&gt;3.2 遍历文件:&lt;/h3&gt;
&lt;p&gt;首先我们需要了解遍历的算法:定义的&lt;code&gt;file_display&lt;/code&gt;函数以某个目录(&lt;code&gt;/home/pushy&lt;/code&gt;)作为遍历的起点.遇到一个子目录时,就先接着遍历子目录(递归调用函数);遇到一个文件时,就直接对改文件进行操作(这里只打印出文件的文件名):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; file_display(filepath):
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; each &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; os.listdir(filepath):
        &lt;span class=&quot;co&quot;&gt;# 得到文件的绝对路径:&lt;/span&gt;
        absolute_path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.join(filepath, each)
        &lt;span class=&quot;co&quot;&gt;# 得到是否为文件还是目录的布尔值:&lt;/span&gt;
        is_file &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.isfile(absolute_path)
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; is_file:
            &lt;span class=&quot;co&quot;&gt;# 当前的绝对路径为文件:&lt;/span&gt;
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(each)
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;co&quot;&gt;# 当前的绝对路径为目录:&lt;/span&gt;
            file_display(absolute_path)

file_display(&lt;span class=&quot;st&quot;&gt;'/home/pushy'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以遍历到&lt;code&gt;/home/pushy&lt;/code&gt;路径下的所有文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/Pushy/p/pic/readFile.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外我们还可以使用递归来创建目录:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; os

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; createFile(dirname):
    exits &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; os.path.exists(dirname)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; exits:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 开始递归调用函数,并接受其返回值:&lt;/span&gt;
        rec_result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; createFile(os.path.dirname(dirname))
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; rec_result:
            &lt;span class=&quot;co&quot;&gt;# 如果不存在该目录,则创建dirname的目录,并返回已经创建(存在)的值True:&lt;/span&gt;
            os.mkdir(dirname)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

createFile(&lt;span class=&quot;st&quot;&gt;'./aa/bb/cc'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;循环与递归&quot;&gt;4. 循环与递归:&lt;/h2&gt;
&lt;p&gt;好了,递归的知识差不多介绍完了.如果看完上边大概已经了解了循环和递归的区别了.对了!简单来说,循环是有去无回,而递归则是有去有回(因为存在终止条件).&lt;/p&gt;
&lt;p&gt;举个栗子,你用你手中的钥匙打开一扇门,结果去发现前方还有一扇门,紧接着你又用钥匙打开了这扇门,然后你又看到一扇们...但是当你开到某扇门时,发现前方是一堵墙无路可走了,你选择原路返回.这就是递归&lt;/p&gt;
&lt;p&gt;但是如果你打开一扇门后,同样发现前方也有一扇们,紧接着你又打开下一扇门...但是却一直没有碰到尽头,这就是循环.&lt;/p&gt;

&lt;blockquote readability=&quot;1.0714285714286&quot;&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20507130&quot;&gt;[知乎]什么是递归&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/#3.3.1&quot;&gt;七天学会NodeJs--递归算法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 20 Feb 2018 13:38:00 +0000</pubDate>
<dc:creator>Pushy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Pushy/p/8455862.html</dc:identifier>
</item>
</channel>
</rss>