<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ELK日志系统之通用应用程序日志接入方案 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/9596017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/9596017.html</guid>
<description>&lt;blockquote readability=&quot;5.6681415929204&quot;&gt;
&lt;p&gt;前边有两篇ELK的文章分别介绍了&lt;a href=&quot;https://mp.weixin.qq.com/s/umH7ImZZVhdfgMdZ3Hz5fA&quot;&gt;MySQL慢日志收集&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/s/CYUls7uczVwGzwptZOX0Dg&quot;&gt;Nginx访问日志收集&lt;/a&gt;，那么各种不同类型应用程序的日志该如何方便的进行收集呢？且看本文我们是如何高效处理这个问题的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;规范的日志存放路径和输出格式将为我们后续的收集和分析带来极大的方便，无需考虑各种不同路径、格式的兼容问题，只需要针对固定几类日志做适配就可以了，具体的规范如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志存放路径规范&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;项目日志只能输出到固定的位置，例如&lt;code&gt;/data/logs/&lt;/code&gt;目录下&lt;/li&gt;
&lt;li&gt;同一类型（例如java web）的日志文件名保持统一，例如都叫&lt;code&gt;application.log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个类型的项目可以记录多个不同的日志文件，例如&lt;code&gt;exception.log&lt;/code&gt;和&lt;code&gt;business.log&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;日志输出格式规范&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;日志输出必须为JSON格式，这个很重要&lt;/li&gt;
&lt;li&gt;同一类型的项目应采用统一的日志输出标准，尽量将日志输出模块化，所有项目引用同一模块&lt;/li&gt;
&lt;li&gt;输出日志中必须包含标准时间（timestamp）、应用名称（appname）、级别（level）字段，日志内容记录清晰易懂&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;日志信息级别规范&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;debug&lt;/td&gt;
&lt;td&gt;调试日志，日志信息量最多&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;info&lt;/td&gt;
&lt;td&gt;一般信息日志，最常用的级别&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;notice&lt;/td&gt;
&lt;td&gt;最具有重要性的普通条件信息&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;warning&lt;/td&gt;
&lt;td&gt;警告级别&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;错误级别，某个功能不能正常工作&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;critical&lt;/td&gt;
&lt;td&gt;严重级别，整个系统不能正常工作&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;alert&lt;/td&gt;
&lt;td&gt;需要立刻修改的日志&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;emerg&lt;/td&gt;
&lt;td&gt;内核崩溃等严重信息&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上到下级别依次从低到高，日志量从多到少，正确选择日志级别帮助后期快速排查问题&lt;/p&gt;
&lt;h2 id=&quot;我们为什么要制定这样的规范&quot;&gt;我们为什么要制定这样的规范？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/6/165abe5660b20694?w=489&amp;amp;h=469&amp;amp;f=png&amp;amp;s=42097&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们的项目都跑在Docker里，Docker镜像由基础镜像+项目代码组成&lt;/li&gt;
&lt;li&gt;基础镜像打包了运行项目的基础环境，例如spring cloud微服务项目，则打包了jre服务&lt;/li&gt;
&lt;li&gt;规范了日志存放及输出后，我们可以把作为日志收集agent的filebeat一并打包进基础镜像，因为同一类型项目的日志路径、格式都是一致的，filebeat配置文件可以通用&lt;/li&gt;
&lt;li&gt;这样我们在后续的部署过程中就不需要关心日志相关的内容，只要项目镜像引用了这个基础镜像就能自动接入了我们的日志服务，实现日志的收集、处理、存储与展示&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们通用日志采集方案如下图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/6/165abe566039affd?w=1071&amp;amp;h=620&amp;amp;f=png&amp;amp;s=45932&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序跑在容器里，容器内自带Filebeat程序收集日志&lt;/li&gt;
&lt;li&gt;收集完成后传给kafka集群，logstash读取kafka集群数据写入elasticsearch集群&lt;/li&gt;
&lt;li&gt;kibana读取elasticsearch集群数据展示在web上，开发、运维等需要查看日志的用户登录kibana查看&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Client端Filebeat配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;filebeat.prospectors:

- input_type: log
  paths:
    - /home/logs/app/business.log
    - /home/logs/app/exception.log

  json.message_key: log
  json.keys_under_root: true

output.kafka:
  hosts: [&quot;10.82.9.202:9092&quot;,&quot;10.82.9.203:9092&quot;,&quot;10.82.9.204:9092&quot;]
  topic: filebeat_docker_java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Kafka接收到的数据格式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;@timestamp&quot;:&quot;2018-09-05T13:17:46.051Z&quot;,&quot;appname&quot;:&quot;app01&quot;,&quot;beat&quot;:{&quot;hostname&quot;:&quot;52fc9bef4575&quot;,&quot;name&quot;:&quot;52fc9bef4575&quot;,&quot;version&quot;:&quot;5.4.0&quot;},&quot;classname&quot;:&quot;com.domain.pay.service.ApiService&quot;,&quot;date&quot;:&quot;2018-09-05 21:17:45.953+0800&quot;,&quot;filename&quot;:&quot;ApiService.java&quot;,&quot;hostname&quot;:&quot;172.17.0.2&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;linenumber&quot;:285,&quot;message&quot;:&quot;param[{\&quot;email\&quot;:\&quot;TEST@163.COM\&quot;,\&quot;claimeeIP\&quot;:\&quot;123.191.2.75\&quot;,\&quot;AccountName\&quot;:\&quot;\&quot;}]&quot;,&quot;source&quot;:&quot;/home/logs/business.log&quot;,&quot;thread&quot;:&quot;Thread-11&quot;,&quot;timestamp&quot;:1536153465953,&quot;type&quot;:&quot;log&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Server端Logstash配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input {
    kafka {
        bootstrap_servers =&amp;gt; &quot;10.82.9.202:9092,10.82.9.203:9092,10.82.9.204:9092&quot;
        topics =&amp;gt; [&quot;filebeat_docker_java&quot;]
    }
}

filter {
    json {
        source =&amp;gt; &quot;message&quot;
    }

    date {
        match =&amp;gt; [&quot;timestamp&quot;,&quot;UNIX_MS&quot;]
        target =&amp;gt; &quot;@timestamp&quot;
    }
}

output {
    elasticsearch {
        hosts =&amp;gt; [&quot;10.82.9.205&quot;, &quot;10.82.9.206&quot;, &quot;10.82.9.207&quot;]
        index =&amp;gt; &quot;filebeat-docker-java-%{+YYYY.MM.dd}&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都是基础配置很简单，不做过多解释，通过以上简单的配置就能实现任何应用程序的日志收集&lt;/p&gt;

&lt;p&gt;收集日志到elasticsearch之后，就可以通过kibana配置展示应用程序的日志了，方便开发及时发现问题，在线定位问题&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/6/165abe565fdc66b1?w=1402&amp;amp;h=519&amp;amp;f=png&amp;amp;s=75462&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;通用的基础与前提是规范，规范做好了事半功倍&lt;/li&gt;
&lt;li&gt;日志打印Json格式不方便本地查看？这个可以把日志输出格式当做配置写在配置文件中，不同环境加载不同配置，就跟开发环境加载开发数据库一样&lt;/li&gt;
&lt;li&gt;日志系统上线到现在稳定运行接近2年，除了刚开始有点不适应以为，都是越用越好用，现在他们已经离不开ELK日志系统了，大大提高了工作的效率&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/6/1650dfc4a28a8e56?w=430&amp;amp;h=476&amp;amp;f=jpeg&amp;amp;s=68454&quot; alt=&quot;长按关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有帮助，请转发分享给更多的人。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 23:17:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>前边有两篇ELK的文章分别介绍了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/9596017.html</dc:identifier>
</item>
<item>
<title>Linux ugo 权限 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/9573355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/9573355.html</guid>
<description>&lt;p&gt;&lt;span&gt;Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。本文将介绍 ugo 权限的基本概念。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;说明：本文的演示环境为 ubuntu 16.04。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Linux 文件的 ugo 权限把对文件的访问者划分为三个类别：文件的所有者、组和其他人。所谓的 ugo 就是指 user(也称为 owner)、group 和 other 三个单词的首字母组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件的所有者&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。在一台允许多个用户访问的 Linux 主机上，可以通过文件的所有者来区分一个文件属于某个用户。当然，一个用户也无权查看或更改其它用户的文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件所属的组&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;假如有几个用户合作开发同一个项目，如果每个用户只能查看和修改自己创建的文件就太不方便了，也就谈不上什么合作了。所以需要一个机制允许一个用户查看和修改其它用户的文件，此时就用到组的概念的。我们可以创建一个组，然后把需要合作的用户都添加都这个组中。在设置文件的访问权限时，允许这个组中的用户对该文件进行读取和修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其他人&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;如果我想把一个文件共享给系统中的所有用户该怎么办？通过组的方式显然是不合适的，因为需要把系统中的所有用户都添加到一个组中。并且系统中添加了新用户该怎么办，每添加一个新用户就把他添加到这个组中吗？这个问题可以通过其他人的概念解决。在设置文件的访问权限时，允许其他人户对该文件进行读取和修改。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用 ll 命令可以查看文件的属性信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120433886-1208627732.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;第一组指明文件的类型和 ugo 权限信息。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第二组是对文件的引用计数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第三组是文件的所有者。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第四组是文件所属的组。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其它的信息我们暂时忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件类型&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;第一组的第一个字符描述文件的类型，常见的类型有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;d 表示目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;- 表示普通文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;l 表示链接文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b 表示块设备文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c 表示字符设备文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;s 表示 socket 文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件的 ugo 权限信息&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;第一组信息一个 10 个字符，除去第一个表示文件类型的字符，其它 9 个字符表示文件的 ugo 权限信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120612711-514991426.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这 9 个字符以三个为一组，都是 rwx 或 - 的组合。其中，&lt;strong&gt;r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)&lt;/strong&gt;。 这三个权限的位置不会改变，如果没有对应的权限，就会以 -(减号)代替。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以上图所示，&lt;span&gt;&lt;strong&gt;第一组为文件所有者的权限，第二组为文件所属组的权限，第三组为其他人的权限。&lt;/strong&gt;&lt;/span&gt;其表示的具体含义为：文件所有者具有对文件的读写权限，文件所属组的用户具有对文件读写的权限，而其他人只有读取文件的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面让我们来详细的解释一下读写执行的权限。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;r (read)：可以读取文件的实际内容，比如读取文本文件内的文字等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;w (write)：可以编辑、增加、删除文件的内容(但不含删除该文件)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;x (execute)：该文件具有可以被系统执行的权限。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以看出，对于文件来说，rwx 主要针对的是文件的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对目录而言，目录中存储的主要是目录下文件名称的列表，这与普通文件是有些不同的：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;r (read contents in directory)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;表示具有读取目录下文件名称的权限，也就是说你可以通过 ls 命令把目录下的文件列表查询出来。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;比如我们使用用户 nick 创建一个目录 testdir，并在该目录下创建两个文件，此时 testdir 的权限为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120725811-798924724.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他人具有 r 权限，所以可以通过 ls 命令查看该目录下的文件，这里我们通过 tester 用户查看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120755345-1006218256.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们修改该目录的权限：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120824909-878908603.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在其他人已经没有这个目录上的 r 权限了，再让用户 tester 执行 ls 命令试试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902120918497-442955145.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在其他人已经没有权限查看目录下的文件名了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;w (modify contents of directory)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;具有 w 权限表明你可以在该目录下执行如下的操作：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建新的文件和目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;删除已经存在的文件与目录(不论该文件的权限为何!)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重命名已存在的文件或目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;移动该目录内文件、目录的位置。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;x (access directory)&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;目录虽然不能被执行，但是却具有可以执行的权限。目录的 x 权限表示用户是否可以&lt;strong&gt;&lt;span&gt;进入该目标并成为当前的工作目录&lt;/span&gt;&lt;/strong&gt;。注意，如果用户对目录没有 x 权限，则无法查看&lt;strong&gt;&lt;span&gt;该目录下的文件的内容(注意与 r 权限的区别)&lt;/span&gt;&lt;/strong&gt;。比如我们移除 testdir 目录上的 x 权限：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121026974-1205400718.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时虽然其他人具有读 testfile1 文件的权限，但我们用 tester 用户读取其内容时：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121056114-538687161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示没有权限，原因就是我们移除了 testdir 目录的 x 权限。所以，&lt;strong&gt;&lt;span&gt;如果要允许目录被其他人浏览时，至少要给予 r 和 x 的权限&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件的所有者&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;第三组信息显示文件的所有者，图片中显示的文件所有者为 nick。文件的所有者一般是创建该文件的用户，对该文件具有完全的权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件所属的组&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;第四组信息显示文件所属的组。当我们通过 adduser 命令创建用户时一般会创建一个同名的组，该用户就属于与他同名的组(比如笔者机器上的用户 nick 就属于 nick 组)。当我们创建文件和目录时，其默认所属的组就是所有者所在的组。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用户和组的信息分别记录在 /etc/passwd、/etc/group 文件中。可以直接以读取文本文件的方式查看其内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121213231-839180029.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两个文件的内容是任何人都有权查看的，比如 /etc/passwd 文件的内容如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121242099-1922423267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该图只显示了部分用户的信息，其中的每一行代表一个用户。/etc/group 文件的结构与 /etc/passwd 文件的结构类似。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在新建文件时会根据创建者的身份和其它的一些设置为文件生成默认的权限。比如我们全面看到的文件 testfile：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121343785-1969164862.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们介绍如何通过下面的命令修改文件权限相关的信息：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;chown ：改变文件所有者&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;chgrp ：改变文件所属的组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;chmod ：改变文件的权限&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;改变文件所有者&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;通过 chown 命令可以改变文件的所有者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; tester testfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121424166-1568049947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改变文件所属的组&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;通过 chgrp 命令可以改变文件所属的组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121450157-2062031993.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改变文件的权限&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;通过 chmod 命令可以改变文件的权限。对于文件的 rwx 权限，有两种表示方法，数字表示法和字符表示法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以数字表示权限的方式如下：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;r: 4&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;w: 2&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;x: 1&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;如果是 rwx 权限就是 4 + 2 + 1 = 7 ，r-x 就是 4 + 1 = 5 ，--- 则为 0。所以 rw-rw-r-- 就可以用 664 来表示。如果我们想把文件的权限修改为 rwxrwxrwx，可以使用下面的命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; testfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121530456-328850239.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以字符表示权限的方式如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用字符 u, g, o 分别代表文件所有者(user)、文件所属的组(group)和其他人(other)，这就是 ugo 权限叫法的由来。只不过还有一个 a 可以表示全部的身份(all)。具体更改权限的语法如下：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;chmod [u g o a] [+ - =] [rwx] 文件/目录&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;比如我们可以通过下面的命令把 testfile 的权限设回 rw-rw-r--：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;chmod&lt;/span&gt; ug=rw,o=r testfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121604499-709716840.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想去掉组的 w 权限并给其他人添加 x 权限可以执行下面的命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;chmod&lt;/span&gt; g-&lt;span&gt;w&lt;/span&gt;,o+x testfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121635314-2044709669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可通过 a 为全部身份设置权限，比如 rwx：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;chmod&lt;/span&gt; a=rwx testfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201809/952033-20180902121704070-1525632957.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ugo 权限是学习和使用 Linux 系统的基础，本文只介绍了其中最基本的概念和操作，希望可以帮助大家了解 Linux 的权限及其简单的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;http://cn.linux.vbird.org/linux_basic/0210filepermission.php&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;鸟哥 Linux 的文件权限与目录配置&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/lingtian213/article/details/76553725&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;linux文件权限【基本权限ugo】&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://linux.die.net/man/1/chown&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;chown man page&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://linux.die.net/man/1/chgrp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;chgrp man page&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://linux.die.net/man/1/chmod&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;chmod man page&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 23:05:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<og:description>Linux 系统中文件的 ugo 权限是 Linux 进行权限管理的基本方式。本文将介绍 ugo 权限的基本概念。说明：本文的演示环境为 ubuntu 16.04。 文件的所有者和组 Linux 文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/9573355.html</dc:identifier>
</item>
<item>
<title>图算法--最短路径算法的实现与应用 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/9521605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/9521605.html</guid>
<description>&lt;h2&gt;最短路径&lt;/h2&gt;
&lt;p&gt;在解决网络路由的问题中，寻找图中一个顶点到另一个顶点的最短路径或最小带权路径是非常重要的过程。&lt;/p&gt;
&lt;p&gt;正式表述为，给定一个有向带权图G=(V,E)，顶点s到V中顶点t的最短路径为在E中边的集合S中连接s到t代价最小的路径。&lt;/p&gt;
&lt;p&gt;当找到S时，我们就解决了单对顶点最短路径问题。要做到这一点，实际上首先要解决更为一般的单源最短路径问题，单源最短路径问题是解决单对顶点最短路径过程中的一部分。在单源最短路径问题中，计算从一个顶点s到其他与之相邻顶点之间的最短路径。之所以要用这个方法解决此问题是因为没有其他更好的办法能用来解决单对顶点最短路径问题。&lt;/p&gt;
&lt;h2&gt;Dijkstra算法&lt;/h2&gt;
&lt;p&gt;解决单源最短路径问题的方法之一就是Dijkstra算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra算法会生成一棵最短路径树，树的根为起始顶点s，树的分支为从顶点s到图G中所有其他顶点的最短路径&lt;/strong&gt;。此算法要求图中所有的权值均为非负数。与Prim算法一样，Dijkstra算法也是一种利用贪心算法计算并最终能够产生最优结果的算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从根本上说，Dijkstra算法通过选择一个顶点，并不断地探索与此顶点相关的边，以此来确定每个顶点的最短路径最否是最优&lt;/strong&gt;。此算法类似广度优先搜索算法，因为在往图中更深的顶点探寻之前首先要遍历与此顶点相关的所有顶点。为了计算s与其他所有顶点之前的最短路径，Dijkstra算法需要维护每个顶点的色值和最短路径估计。通常，最短路径估计由变量d表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开始，将所有色值设置为白色，最短路径估计设置为∞（代表一个足够大的数，大于图中所有边的权值）。将起始顶点的最短路径估计设置为0。随着算法的不断演进，在最短路径树中为每个顶点（除起始顶点）指派一个父结点。在算法结束之前，顶点的父结点可能会发生几次变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dijkstra算法的运行过程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，在图中所有白色顶点之间，选择最短路径估计值最小的顶点u&lt;/strong&gt;。初始，最短路径估计值被设置为0的顶点将做为起始顶点。当选择此顶点后，将其涂成黑色。&lt;/p&gt;
&lt;p&gt;接&lt;strong&gt;下来，对于每个与u相邻的顶点v，释放其边（u，v）&lt;/strong&gt;。当释放边后，我们要确认是否要更新到目前为止所计算的最短路径。方法就是将（u，v）的权值加到u的最短路径估计中。如果这个合计值小于或等于v的最短路径估计，就将这个值指派给v，作为v的新最短路径估计。&lt;strong&gt;同时，将u设置为v的父结点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重复这个过程，直到所有的顶点都标记为黑色。一旦计算完最短路径树，那么从s到另外一个顶点t的最短路径就能唯一确定：从树中t处的结点开始向随后的父结点查找，直到到达s。此寻找路径的反向路径即为s到t的最短路径。&lt;/p&gt;
&lt;p&gt;下图展示了由a到图中其他顶点的最短路径的计算过程。例如，a到b的最短路径为（a，c，f，b），其权值为7。最短路径估计和每个顶点的父结点都显示在每个顶点的旁边。最短路径估计显示在斜线的左边，父结点显示在斜线的右边。浅灰色的边是最短路径树增长过程中的边。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201808/1281268-20180824075655506-2018010016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 最短路径的接口定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;shortest&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;int shortest(Graph *graph, const PathVertex *start, List *paths, int (*match)(const void *key1, const void *key2));&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：如果计算最短路径成功，返回0；否则，返回-1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：用于计算顶点start与有向带权图graph中其他所有顶点之间的最短路径。此操作会改变graph，所以如果有必要，在调用此操作之前先对图进行备份。&lt;/p&gt;
&lt;p&gt;graph中的每个顶点必须包含PathVertex类型的数据。通过设置PathVertex结构体中的成员weight的值来指定每个边的权值，weitht的值由传入graph_ins_edge的参数data2决定。用PathVertex结构体的成员data来保存与顶点相关的数据，例如顶点的标识符。&lt;/p&gt;
&lt;p&gt;graph的match函数（此函数在用graph_init对图进行初始化时调用）用来比较PathVertex结构体中的data成员。此函数与传入shortest中的参数match相同。&lt;/p&gt;
&lt;p&gt;一旦计算完成，最短路径的相关信息将会返回给paths，paths是存储PathVertex结构体的列表。在paths中，起始顶点的父结点设置为NULL。而其他每个顶点的parents成员都指向位于该顶点之前的那个顶点，这个顶点位于从起始顶点开始的最短路径之上。paths中的顶点指向graph中的实际顶点，所以只要能够访问paths，函数调用都就必须要保证graph中的内存空间有效。一旦不再使用paths，就调用list_destroy来销毁paths。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（EV&lt;sup&gt;2&lt;/sup&gt;），其中V是图中的顶点个数，E是边的条目数。&lt;/p&gt;
&lt;h2&gt;最短路径的实现与分析&lt;/h2&gt;
&lt;p&gt;为了计算有向带权图中一个顶点到其他所有顶点的最短路径，其图的表示方法与最小生成树中的表示方法相同。只是用PathVertex结构体取代顶点MstVertex结构。&lt;/p&gt;
&lt;p&gt;PathVertex能够表示带树图，同时能够追踪Dijkstra算法所需要的顶点和边的信息。&lt;strong&gt;此结构体包含5个成员：data是与顶点相关的数据；weight是到达该顶点的边的权值；color是顶点的颜色；d是顶点的最短路径估计；parent是最短路径中顶点的交结点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造一个包含pathvertex结构体的图的过程与构造一个包含MstVertex结构体的图的过程相同。&lt;/p&gt;
&lt;p&gt;shortest操作&lt;strong&gt;首先初始化邻接表结构链表中的每个顶点&lt;/strong&gt;。将每个顶点的最短路径估计初始化为DBL_MAX（起始顶点除外，起始顶点的初始值为0.0）。用存储在邻接表结构链表中的顶点来维护顶点的色值、最短路径估计和父结点。其原因与计算最小生成树时的解释相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra算法的核心是用一个单循环为图中的每个结点迭代一次&lt;/strong&gt;。在每次的迭代过程中，&lt;strong&gt;首先在所选的白色顶点中选择最短路径估计最小的顶点&lt;/strong&gt;。&lt;strong&gt;同时，在邻接表结构链表中将此顶点涂黑&lt;/strong&gt;。&lt;strong&gt;接下来，遍历与所选顶点相邻的顶点&lt;/strong&gt;。&lt;strong&gt;在遍历每个顶点时，检查它在邻接表结构链表中的颜色和最短路径估计。一旦获得了这些信息，就调用relax释放所选顶点与相邻顶点间的边。如果此过程中发现需要更新相邻顶点的最短路径估计和父结点，那么就在邻接表结构链表中更新此顶点。重复这个过程直到所有顶点都涂成黑色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一旦Dijkstra算法中的主循环结束，计算图中起始顶点到所有其他顶点的最短路径的过程也就完成了。此时，将邻接表结构链表中每个黑色的PathVertex结构体插入链表paths中&lt;/strong&gt;。&lt;strong&gt;在paths中，父结点为NULL的顶点就是起始顶点。其他每个顶点的parent成员都指向从起始顶点开始的最短路径中的前一个顶点。每个PathVertex结构体的成员weight并不经常使用，因为它只在存储到邻接表中时才用的到。&lt;/strong&gt;下图展示了在上图1中计算最短路径时所返回的PathVertex结构体列表。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201808/1281268-20180830062335038-1457064478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;示例：计算最短路径的实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;shortest.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;graph.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;graphalg.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;relax  释放边、更新最短路径估计值、更新父结点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; relax(PathVertex *u, PathVertex *v, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; weight)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;释放顶点u和v之间的边&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(v-&amp;gt;d &amp;gt; u-&amp;gt;d +&lt;span&gt; weight)
    {
        v&lt;/span&gt;-&amp;gt; = u-&amp;gt;d +&lt;span&gt; weight;
        v&lt;/span&gt;-&amp;gt;parent =&lt;span&gt; u;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;shortest  最短路径计算函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; shortest(Graph *graph, &lt;span&gt;const&lt;/span&gt; PathVertex *start, List *paths, &lt;span&gt;int&lt;/span&gt; (*match)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; key2))
{
    AdjList &lt;/span&gt;*&lt;span&gt;adjlist;
    PathVertex &lt;/span&gt;*pth_vertex, *&lt;span&gt;adj_vertex;

    ListElmt &lt;/span&gt;*&lt;span&gt;element, member;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; minimum;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; found,i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化图中的所有顶点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    found &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element = list_head(&amp;amp;graph_adjlists(graph)); element != NULL; element =&lt;span&gt; list_next(element))
    {
        pth_Vertex &lt;/span&gt;= ((AdjList *)list_data(element))-&amp;gt;&lt;span&gt;vertex;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(match(pth_vertex, start))
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;找到并初始化起始顶点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            pth_vertex&lt;/span&gt;-&amp;gt;color =&lt;span&gt; white;
            pth_vertex&lt;/span&gt;-&amp;gt;d = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            pth_vertex&lt;/span&gt;-&amp;gt;parent =&lt;span&gt; NULL;
            found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;非起始顶点，初始化&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            pth_vertex&lt;/span&gt;-&amp;gt;color =&lt;span&gt; white;
            pth_vertex&lt;/span&gt;-&amp;gt;d =&lt;span&gt; DBL_MAX;
            pth_vertex&lt;/span&gt;-&amp;gt;parent =&lt;span&gt; NULL;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果未匹配到起始顶点，程序退出&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;found)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用Dijkstra算法计算从起始顶点开始的最短路径&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    i&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i &amp;lt;&lt;span&gt; graph_vcount(graph))
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;从所有的白色顶点中，选择最短路径估计值最小的顶点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        minimum &lt;/span&gt;=&lt;span&gt; DBL_MAX;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element=list_head(&amp;amp;graph_adjlists(graph)); element!=NULL; element =&lt;span&gt; list_next(element))
        {
            pth_vertex &lt;/span&gt;= ((AdjList*)list_data(element))-&amp;gt;&lt;span&gt;vertex;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pth_vertex-&amp;gt;color == white &amp;amp;&amp;amp; pth_vertex-&amp;gt;d &amp;lt;&lt;span&gt; minimum)
            {
                minimum &lt;/span&gt;= pth_vertex-&amp;gt;&lt;span&gt;d;
                adjlist &lt;/span&gt;=&lt;span&gt; list_data(element);
            }
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将该顶点涂成黑色&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ((PathVertex &lt;/span&gt;*)adjlist-&amp;gt;vertex)-&amp;gt;color =&lt;span&gt; black;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;遍历与所选顶点相邻的顶点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(member=list_head(&amp;amp;adjlist-&amp;gt;adjacent); member != NULL; member =&lt;span&gt; list_next(member))
        {
            adj_vertex &lt;/span&gt;=&lt;span&gt; list_data(member);

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element = list_head(&amp;amp;graph_adjlists(graph)); element != NULL; element =&lt;span&gt; list_next(element))
            {
                pth_vertex &lt;/span&gt;= ((AdjList *)list_data(element))-&amp;gt;&lt;span&gt;vertex;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(match(pth_vertex, adj_vertex))
                {
                    relax(adjlist&lt;/span&gt;-&amp;gt;vertex, pth_vertex, adj_vertex-&amp;gt;&lt;span&gt;weight);
                }
            }
        }
        i&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将邻接表结构链表中每个黑色PathVertexx结构体插入链表paths中&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    list_init(paths,NULL);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element=list_head(&amp;amp;graph_adjlists(graph)); element!=NULL; element=&lt;span&gt;list_next(paths,NULL))
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;加载邻接表结构链表中的每一个黑色顶点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pth_vertex&lt;/span&gt;=((AdjList *)list_data(element))-&amp;gt;&lt;span&gt;vertex;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pth_vertex-&amp;gt;color ==&lt;span&gt; black)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list_ins_next(paths, list_tali(paths), pth_vertex) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                list_destroy(paths);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;最短路径实例：路由表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;最短路径算法在现实中一个很重要的应用是在互联网中对数据进行路由&lt;/strong&gt;。路由是将数据从一个点传输到另一个点的决策过程。在互联网中，路由是沿着相互连接的点（称为网关）传播数据段或数据包的过程。在数据包通过一个网关时，路由器将会查看数据包最终目的地，然后将数据包发往下一个网关。路由器的目的就是将数据包往最接近于目的地的地方发送。&lt;/p&gt;
&lt;p&gt;为了将数据包往最接近目的地的地方发送，每个路由器都要维护互联网的结构信息或拓扑信息。这些信息存储在路由表中。路由表为每个路由器知道如何到达的网关存储一个条目。每个条目指定把数据发送到下一个网关的地址。&lt;/p&gt;
&lt;p&gt;由于路由器会周期性的随着互联网的变化更新其路由表，因此数据包会尽可能地沿着最佳路径传送数据。&lt;strong&gt;有一种类型的路由称为最短路径优先路由或SPF路由，其中每个路由器都维护有自己的网络图，以便它能通过计算自身与其他结点之间的最短路径来更新其路由表&lt;/strong&gt;。&lt;strong&gt;互联网拓扑图是一个有向带权图，其顶点为网关，边为网关之间的连接线。边的权值由连接路径的性能决定&lt;/strong&gt;。偶尔，路由器会交换拓扑和性能的信息，为此还专门设计了一种协议来完成此工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计函数route，利用SPF路由算法计算更新路由表中条目所需要的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该函数接受shortest的paths参数中返回的路径信息列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;它使用此信息来确定路由器要把数据包发送到的下一个网关，以保证此网关离目的地更近了一步。&lt;/p&gt;
&lt;p&gt;要为指定的网关完成一个完整的表，&lt;strong&gt;首先要调用函数shortest，其中网关由start参数传入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着，对于每个路由表中包含的目的地址，调用函数route，其中的目的地址由destination传入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后作为从paths生成的路径的图graph_init中所提供的match函数，把此地址传入match中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;route函数将目的列表paths中的父结点指针指向网关，同时返回一个传送数据包的最佳结点（此结点存放在输出参数next中）&lt;/strong&gt;。next中返回的顶点指向paths中实际的顶点，所以只要还能访问next，paths中的内存空间就必须有效。&lt;/p&gt;
&lt;p&gt;下图A部分展示了互联网中处于a的路由器的路由表的计算过程。B部分展示了处理b的路由器计算路由表的过程。注意，依据在互联网中起始位置的不同，其最短路径也不同。同样需要注意的是，在图B中是没办法到达a的，所以在该表中也没有相关条目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201809/1281268-20180902204829731-1956000002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算路由的时间复杂度为O（n&lt;sup&gt;2&lt;/sup&gt;），其中n为paths中的网关数目。&lt;/p&gt;
&lt;h4&gt;示例：路由表中更新条目的函数实现&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;route.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;graphalg.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;route.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;route&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; route(List *paths, PathVertex *destination, PathVertex **next, &lt;span&gt;int&lt;/span&gt; (*match)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *key1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key2))
{
    PathVertex &lt;/span&gt;*&lt;span&gt;temp,
               &lt;/span&gt;*&lt;span&gt;parent;
    ListElmt   &lt;/span&gt;*&lt;span&gt;element;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;        found;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;查找位于网关链表中的目的地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    found &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element = list_head(paths); element != NULL; element =&lt;span&gt; list_next(element))
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(match(list_data(element),destination))
        {
            temp &lt;/span&gt;=&lt;span&gt; list_data(element);
            parent &lt;/span&gt;= ((PathVertex *)list_data(element))-&amp;gt;&lt;span&gt;parent;
            found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如未发现目标地址，函数退出&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;found)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算到目的地最短路径的下一个网关&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(parent!=&lt;span&gt;NULL)
    {
        temp &lt;/span&gt;=&lt;span&gt; list_data(element);
        found &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(element = list_head(paths); element != NULL; element =&lt;span&gt; list_next(element))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(match(list_data(element),parent))
            {
                parent &lt;/span&gt;= ((PathVertex *)list_data(element))-&amp;gt;&lt;span&gt;parent;
                found &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果目标不能到达，函数退出&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;found)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;*next =&lt;span&gt; temp;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 05 Sep 2018 22:11:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<og:description>最短路径 在解决网络路由的问题中，寻找图中一个顶点到另一个顶点的最短路径或最小带权路径是非常重要的过程。 正式表述为，给定一个有向带权图G=(V,E)，顶点s到V中顶点t的最短路径为在E中边的集合S中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/9521605.html</dc:identifier>
</item>
<item>
<title>XDEBUG+PHPSTORM 开发 调试 - 闲云-野鹤</title>
<link>http://www.cnblogs.com/tl542475736/p/9595701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tl542475736/p/9595701.html</guid>
<description>&lt;h2&gt;XDEBUG+PHPSTORM 开发 调试&lt;/h2&gt;
&lt;p&gt;在我们开发过程中。我们如果经常性的echo、dump效率很低。所以我们就可以使用xdebug进行断点调试。&lt;/p&gt;
&lt;p&gt;下面的教程以 Windows 操作系统为例子。其他操作系统类似。&lt;/p&gt;
&lt;h3&gt;1. 下载xdebug&lt;/h3&gt;
&lt;p&gt;安装xdebug前，请确定自己的php版本和使用的TS或NTS。如果实在不清楚，可以通过以下方式查看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536130176419.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536130176419.png&quot; alt=&quot;1536130176419&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图，第一个红框就是现在使用的php的版本，&lt;/p&gt;
&lt;p&gt;第二个框就是你使用php编译的X86还是X64.&lt;/p&gt;
&lt;p&gt;第三个是表示加载的php.ini的位置。我们会用到，后面需要改php.ini。就是改这个位置。一定不能改错了。&lt;/p&gt;
&lt;p&gt;第四个框，就是Thread Safety 如果是 diabled 就表示我们用的PHP是NTS的。如果是enable 就代表是TS的。待会选择xdebug的时候就会用到上面的信息。&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://xdebug.org/download.php&quot; rel=&quot;nofollow&quot;&gt;https://xdebug.org/download.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据我们上图的信息，我们选择的应该是php7.1 x86 nts的 xdebug拓展&lt;/p&gt;
&lt;p&gt;32bit 就是32位操作系统。也就是x86. 如果后面没有写TS ，就代表这个拓展是NTS的。不要选错了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536130606998.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536130606998.png&quot; alt=&quot;1536130606998&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 安装Xdebug&lt;/h3&gt;
&lt;p&gt;将我们上面下载好的拓展移动到 php 的 extension_dir 的目录。如果不知道自己的拓展目录在哪。还是可以通过&lt;code&gt;phpinfo&lt;/code&gt;查看&lt;/p&gt;
&lt;p&gt;搜索 extension_dir 就是拓展所在的目录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536130879493.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536130879493.png&quot; alt=&quot;1536130879493&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3. 配置Xdebug&lt;/h3&gt;
&lt;p&gt;打开 php.ini php.ini 的位置。通过**phpinfo()**中进行查看。 以免改错位置。&lt;/p&gt;
&lt;p&gt;在后面加上一下配置&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ini&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;[Xdebug]
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;拓展的位置。这里一定要zend_extesion
&lt;span class=&quot;pl-k&quot;&gt;zend_extension=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;php_xdebug-2.7.0alpha1-7.1-vc14-nts.dll&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;启用性能检测分析
&lt;span class=&quot;pl-k&quot;&gt;xdebug.profiler_enable=on
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;启用代码自动跟踪
&lt;span class=&quot;pl-k&quot;&gt;xdebug.auto_trace=on
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;允许收集传递给函数的参数变量
&lt;span class=&quot;pl-k&quot;&gt;xdebug.collect_params=on
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;允许收集函数调用的返回值
&lt;span class=&quot;pl-k&quot;&gt;xdebug.collect_return=on
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_enable=1
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_handle=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;dbgp&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_mode=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;req&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_host=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;localhost&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;端口 可以自己更改，不要冲突，待会需要用到
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_port=9002
&lt;span class=&quot;pl-k&quot;&gt;xdebug.idekey=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;PHPSTORM&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.collect_includes = 1
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_autostart = 1
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;指定堆栈跟踪文件的存放目录
&lt;span class=&quot;pl-k&quot;&gt;xdebug.trace_output_dir=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;D:/debug&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;;指定性能分析文件的存放目录
&lt;span class=&quot;pl-k&quot;&gt;xdebug.profiler_output_dir=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;D:/debug&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.profiler_output_name = cachegrind.out.%t.%p&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 验证Xdebug&lt;/h3&gt;
&lt;p&gt;验证Xdebug。同样使用我们的 &lt;code&gt;phpinfo&lt;/code&gt; 进行验证。记得改完配置，记得重启apache或者nginx 或者其他的web服务器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536131596474.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536131596474.png&quot; alt=&quot;1536131596474&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536131772127.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536131772127.png&quot; alt=&quot;1536131772127&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搜索xdebug。 看到上面的界面就是配置成功了。然后再检查上面的配置是不是和你设置的一致。&lt;/p&gt;
&lt;h2&gt;PHPSTORM 整合Xdebug 进行断点调试&lt;/h2&gt;
&lt;h3&gt;1. 配置Cli Interpreter&lt;/h3&gt;
&lt;p&gt;settings --&amp;gt;Languages Frameworks ---&amp;gt; PHP&lt;/p&gt;
&lt;p&gt;点击红框内的 ...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536132188638.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536132188638.png&quot; alt=&quot;1536132188638&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先点击下图的 + 添加一个新的cli 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;点击 ... 选择你的php.exe的位置。 这个php 一定是你的web用的。跟我们配置Xdebug的要一样。&lt;/p&gt;
&lt;p&gt;选择了之后，底下就会检测到我们的php的版本，和xdebug版本以及php.ini的配置。如果这里的信息和我们phpinfo 看到的不一样，就要检查下，是不是选择的php的版本不对。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536132302256.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536132302256.png&quot; alt=&quot;1536132302256&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 配置debug&lt;/h3&gt;
&lt;p&gt;settings --&amp;gt;Languages Frameworks ---&amp;gt; PHP ---&amp;gt;Debug&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536132609448.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536132609448.png&quot; alt=&quot;1536132609448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更改红框中的端口为我们在php.ini中的配置的端口。我们在php.ini配置了9002.所以这里也要写上9002.不要写错了。否则就会有问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;然后再点击我们DBGp Proxy&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536132748160.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536132748160.png&quot; alt=&quot;1536132748160&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;红框中的配置。按照我们在php.ini中的配置进行填写。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ini&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.idekey=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;PHPSTORM&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_host=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;localhost&lt;span class=&quot;pl-pds&quot;&gt;&quot;
&lt;span class=&quot;pl-k&quot;&gt;xdebug.remote_port=9002&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 配置Server&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536131936983.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536131936983.png&quot; alt=&quot;1536131936983&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后自己本地需要debug的host 、 端口&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133092580.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133092580.png&quot; alt=&quot;1536133092580&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. edit cofigure&lt;/h3&gt;
&lt;p&gt;点击菜单栏中的run。 然后点击edit Congiurations&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133451273.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133451273.png&quot; alt=&quot;1536133451273&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在出来后的选项中，点击 + 然后选择 PHP Web Page&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133508626.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133508626.png&quot; alt=&quot;1536133508626&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择你刚才 添加的 server 以及起始的web地址。 点击 apply 应用&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133605461.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133605461.png&quot; alt=&quot;1536133605461&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;6.开启监听&lt;/h3&gt;
&lt;p&gt;点击下图中的这个小电话的图标。 让你变绿色。&lt;/p&gt;
&lt;p&gt;没有监听的状态&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133804975.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133804975.png&quot; alt=&quot;1536133804975&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正在监听的状态&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536133911407.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536133911407.png&quot; alt=&quot;1536133911407&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;7. 开启调试&lt;/h3&gt;
&lt;p&gt;在我们需要调试的代码处，我们需要加上一个断点，然后程序运行到这个地方，就会停下来。下面以TP5为例子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536134070135.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536134070135.png&quot; alt=&quot;1536134070135&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我们运行我们的项目。就会发现浏览器卡住了，这个时候，我们打开PHPstorm。就会发现。程序停下来了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536134215544.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536134215544.png&quot; alt=&quot;1536134215544&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以很清晰的看到上下文的变量的值。以及框架的执行的流程。这对我们分析一个框架，是很有帮助的。&lt;/p&gt;
&lt;p&gt;然后我们可以进行单步调试，或者步入、跳出等操作&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xianyunyh/studynotes/blob/master/%E5%85%B6%E4%BB%96/images/1536135094157.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/xianyunyh/studynotes/raw/master/%E5%85%B6%E4%BB%96/images/1536135094157.png&quot; alt=&quot;1536135094157&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图中，所有画红圈的就是常用到的工具。其具体功能介绍如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重新请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/5693d2f3b6d905bdd9b570ad3e716fd989882396/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f46353534304332413045333434453633384435433833334633463535324131353f6d6574686f643d646f776e6c6f61642673686172654b65793d3932333939393038663866373838623463303536323735346538336131616438&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5693d2f3b6d905bdd9b570ad3e716fd989882396/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f46353534304332413045333434453633384435433833334633463535324131353f6d6574686f643d646f776e6c6f61642673686172654b65793d3932333939393038663866373838623463303536323735346538336131616438&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/F5540C2A0E344E638D5C833F3F552A15?method=download&amp;amp;shareKey=92399908f8f788b4c0562754e83a1ad8&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此工具，点击后，当前调试所有变量全部销毁，重新开启一轮请求。即如同刷新页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;执行到下一个断点，暂停&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/58833eebfe9cfb3ad17e0696e156e26a38eab560/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f41433241333734343132333934433043383141393642324146423739413231323f6d6574686f643d646f776e6c6f61642673686172654b65793d6230613436323531336435343636353835613239343534633731373861656164&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/58833eebfe9cfb3ad17e0696e156e26a38eab560/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f41433241333734343132333934433043383141393642324146423739413231323f6d6574686f643d646f776e6c6f61642673686172654b65793d6230613436323531336435343636353835613239343534633731373861656164&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/AC2A374412394C0C81A96B2AFB79A212?method=download&amp;amp;shareKey=b0a462513d5466585a29454c7178aead&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此工具点击后，继续 Laravel 生命进程的路程，直到下一个断点，暂停&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;停止调试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/51c2120e5be898a5bd016331c6f09a010d9c825c/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f35304442303244354331463834433532393230303345423939364344343231353f6d6574686f643d646f776e6c6f61642673686172654b65793d6664353633336533643132643266343733663636373462333132636432663837&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/51c2120e5be898a5bd016331c6f09a010d9c825c/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f35304442303244354331463834433532393230303345423939364344343231353f6d6574686f643d646f776e6c6f61642673686172654b65793d6664353633336533643132643266343733663636373462333132636432663837&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/50DB02D5C1F84C5292003EB996CD4215?method=download&amp;amp;shareKey=fd5633e3d12d2f473f6674b312cd2f87&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此工具，停止调试，结束 Laravel 周期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/f94780620c0c20e9ff267a62f01c7b9a6fe60bca/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f34353832433337303444323234363241383939333443424446303539463231343f6d6574686f643d646f776e6c6f61642673686172654b65793d3635333835353836376133663131633236643765623832626239366637636630&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/f94780620c0c20e9ff267a62f01c7b9a6fe60bca/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f34353832433337303444323234363241383939333443424446303539463231343f6d6574686f643d646f776e6c6f61642673686172654b65793d3635333835353836376133663131633236643765623832626239366637636630&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/4582C3704D22462A89934CBDF059F214?method=download&amp;amp;shareKey=653855867a3f11c26d7eb82bb96f7cf0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;变量栏标签，下面的内容是当前调试位置所有能够用到的变量（包含全局和局部），记住能用到就会显示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;定位到当前调试的文件以及行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/f22340b175c9b44a8193ed1e05fcb02321e02b52/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f35393532344537333531453034464543393441413936374545333843313244393f6d6574686f643d646f776e6c6f61642673686172654b65793d6366316639643762303666343635666331373865323465643363623235623135&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/f22340b175c9b44a8193ed1e05fcb02321e02b52/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f35393532344537333531453034464543393441413936374545333843313244393f6d6574686f643d646f776e6c6f61642673686172654b65793d6366316639643762303666343635666331373865323465643363623235623135&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/59524E7351E04FEC94AA967EE38C12D9?method=download&amp;amp;shareKey=cf1f9d7b06f465fc178e24ed3cb25b15&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此工具的作用是当调试行文件关闭了，或者代码视图跑到其它位置了，点击它，就能重新定位到调试文件以及调试行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;跳过当前调试行代码要执行函数，直接返回结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/f10526e2ade05596cb11faa300d1fd95226629f5/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f41384132413746424433444234463936423943463243394246434639463230393f6d6574686f643d646f776e6c6f61642673686172654b65793d3163373933633532373936306264306464383234623264646361643262356236&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/f10526e2ade05596cb11faa300d1fd95226629f5/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f41384132413746424433444234463936423943463243394246434639463230393f6d6574686f643d646f776e6c6f61642673686172654b65793d3163373933633532373936306264306464383234623264646361643262356236&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/A8A2A7FBD3DB4F96B9CF2C9BFCF9F209?method=download&amp;amp;shareKey=1c793c527960bd0dd824b2ddcad2b5b6&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此工具的作用是当调试行代码有调用函数，包含文件，new 新对象时，能够不进入相应函数、文件、类中，直接返回其调用的结果，在当前行中，执行下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;进入和强制进入调用的函数内&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/156fc4d07f7552063b5c0cfcfe771e5ab86fdec5/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f37353932333933453242374334323032423842394442304236393942374636383f6d6574686f643d646f776e6c6f61642673686172654b65793d3037393739346335326433353839383435616431356139643737376332646165&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/156fc4d07f7552063b5c0cfcfe771e5ab86fdec5/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f37353932333933453242374334323032423842394442304236393942374636383f6d6574686f643d646f776e6c6f61642673686172654b65793d3037393739346335326433353839383435616431356139643737376332646165&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/7592393E2B7C4202B8B9DB0B699B7F68?method=download&amp;amp;shareKey=079794c52d3589845ad15a9d777c2dae&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此工具功能正好和上面的相反，即进入和强制进入当前调试行将要调用的函数、方法、包含的文件、new的新对象类文件中，执行相应代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;跳出正在调用的函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/5bb5cfbd113eb8a2677cfa62276a129b5e64dbec/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f36374444444136363035393534433244394541463938314143374532374531333f6d6574686f643d646f776e6c6f61642673686172654b65793d3532356339666338303935346436613866343431346565323563383439366564&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5bb5cfbd113eb8a2677cfa62276a129b5e64dbec/68747470733a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f36374444444136363035393534433244394541463938314143374532374531333f6d6574686f643d646f776e6c6f61642673686172654b65793d3532356339666338303935346436613866343431346565323563383439366564&quot; alt=&quot;img&quot; data-canonical-src=&quot;https://note.youdao.com/yws/api/personal/file/67DDDA6605954C2D9EAF981AC7E27E13?method=download&amp;amp;shareKey=525c9fc80954d6a8f4414ee25c8496ed&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;跳出正在执行的函数、方法、包含的文件、new 新对象的类文件，至调用行，并继续执行调用行下面的代码&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Sep 2018 16:26:00 +0000</pubDate>
<dc:creator>闲云-野鹤</dc:creator>
<og:description>XDEBUG+PHPSTORM 开发 调试 在我们开发过程中。我们如果经常性的echo、dump效率很低。所以我们就可以使用xdebug进行断点调试。 下面的教程以 Windows </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tl542475736/p/9595701.html</dc:identifier>
</item>
<item>
<title>在国企的日子(第二章 入职) - 心灵之火</title>
<link>http://www.cnblogs.com/dgcjiayou/p/9595645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgcjiayou/p/9595645.html</guid>
<description>&lt;p&gt;天灰沉沉的，地皮上不断的发出一阵难闻的气味。一场暴雨即将而至。&lt;/p&gt;
&lt;p&gt;这已经是面试回来的第二天，像往常一样，睡到11点自然醒，我也不知道这个是叫幸福还是悲剧，我的睡眠质量还是挺好的。刚在楼下吃了个10块钱的盖码饭，走到外面，立马感觉马上要下大雨，这种天气，除了在家看看电影，玩玩游戏，还能干啥呢？我苦笑着。其实我是一个蛮喜欢下雨，尤其下大雨的那种人，只有这种天气，我才能心安理得并且能很舒服的宅在家一整天，最好天气稍微冷点，只穿根小内裤躺在床上那就更爽了。既然心里已经做了决定没打算出去逛，直接在吃盖码饭的隔壁小超市买了包瓜子和一些零食，径直往楼上走。&lt;/p&gt;
&lt;p&gt;头上突然响了个雷，震的地皮一阵抖颤，余音还没最后消逝，雨便匆匆忙忙的赶来了，这雨是急性子，来的猛，来的密，远近顿时一片哗哗啦啦的声音。刚上楼，手机就响起来了，我从裤兜里掏出来接听，“喂，您好！”&lt;/p&gt;
&lt;p&gt;“雷刚，我是贾珍珍咧，你昨天面试我们这边通过了，我现在想和你确认下你现在这边的薪资期望”，电话那边传来贾珍珍线上绵绵的声音。我突然想起，她的这个声音和线下其实还是有点区别的，线上电话那头的声音呼吸较缓慢，吐词深浅得当，有点像半夜电台里面那种午夜悄悄话的女主播的声音，而线下的声音干净利落，吐词清澈见底，感觉是初中课堂里面那种带眼镜教政治课的女老师，不过，她永远都是面带微笑，那种微笑可以让你不由自主的放下人与人之间交往的心理防御。&lt;/p&gt;
&lt;p&gt;“嗯，好的”，我心里有种莫名其妙的包袱掉地上的感觉，说实话，这个工作我也不知道是上还是不上，我平常心。&lt;/p&gt;
&lt;p&gt;“雷刚，我最后想确认下你这边的薪资期望是多少呢”,&lt;/p&gt;
&lt;p&gt;“我昨天填表格的时候写了10K啊”，我一脸懵逼，心里想，神马情况，这不是明知故问吗？难道是想压我工资？虽然我现在对钱不是特别感兴趣，但是一个满意的薪酬是决定一个人在工作岗位上幸福程度啊，再说我觉得在这种三线城市工作经验3年开个10K也是市场价啊。&lt;/p&gt;
&lt;p&gt;“嗯，嗯，我看到了呀，但是我们这边是国企，可能给不了这么多，所以想问下你这边最低的薪酬要求是多少”，&lt;/p&gt;
&lt;p&gt;“最低就是10K”，我一身正气的回答道。&lt;/p&gt;
&lt;p&gt;“嘻嘻，我们这边你也看到了，平时做的项目其实并不急，基本不怎么加班，你应该也听说过，国企其它的福利比外面的公司是要好很多的，毕竟是国企嘛”，&lt;/p&gt;
&lt;p&gt;“嗯，但是我这个年龄段也需要存钱，以后也要成家，也要赡养父母，花钱的地方很多，压力挺大的”，我对钱虽然不是特别感兴趣，也没有像刚才话里面讲到的存钱成家赡养父母，我工作3年从来没有往家里面打过任何钱，一人吃饱全家不饿，但是我不能就这样妥协，我是懂行的，我知道一个3年工作经验的java工程师在这个城市的价格。&lt;/p&gt;
&lt;p&gt;“嗯，看来你是个蛮孝顺的孩子，自己也是靠自己的能力准备在这个城市扎根发展，现在你这么优秀的男孩子挺少的了，你现在有女朋友了吗？”，贾珍珍夸奖加关怀的问道我。&lt;/p&gt;
&lt;p&gt;听到这些话，我真的很惭愧，首先我不算的上是个孝顺的孩子，出来工作3年，除了过年回家，平时都不怎么和家里面联系，一般都是我妈有时候打电话过来问，“刚子，工作还好吧，有没有谈到合适的对象”，我有时候听烦了，连电话都懒的接，从上家公司离职出来2个月到现在还没接过父母的电话，因为我自己也挺烦，只会越说越烦。再者，我算什么靠自己能力在这个城市扎根发展，我甚至连想都没想过成家立业，虽然我渴望有个家，家里面有个女人，我也知道家里面没个女人真的不行，但是我觉得这些离我都很远，贾珍珍的这些话也正是我当前的困境。&lt;/p&gt;
&lt;p&gt;“额，谈不上什么孝顺了，现在没能力去孝顺，现在没女朋友”，我怎么突然有种自卑的感觉，虽然我心里不止意淫过多少女的是我的女朋友，但是在实际行动中我却从来没有正儿八经主动去追求过一个女生，半年前有个大姐给我介绍个一个女的，是个本地人，在大型商场上班的，当时在这位大姐的撮合下，我们单独见过一次面，我依然记得当时的情景，刚下完班的我背了个双肩电脑包，穿了双拖鞋，站在公交站牌等，电话联系确定遇见地点后，我远远的看到一个身穿紧身牛仔裤，大长腿，白色衬衫，一头乌亮浓厚的卷发，像黑色的瀑布从头顶倾泻而下，打扮的非常时髦，我知道这种女的只适合在我的意念里面做我的女朋友，我们聊了大概不到10分钟，虽然没有聊房子车子，但是我们自己都觉得双方不合适,无下文。感觉废话有点多，脱离主题了。&lt;/p&gt;
&lt;p&gt;“像你这样在家会做饭，又靠自己能力打拼，事业心这么强的男人肯定会有赏识你的女孩子的，男人现在嘛是应该以事业为重，昨天和你聊我也看的出你是个很有上进心的人，而我们企业也正缺你这样的有上进心的人才”，贾珍珍继续鼓励道。&lt;/p&gt;
&lt;p&gt;“嗯，谢谢夸奖”，我应道。&lt;/p&gt;
&lt;p&gt;“雷刚，我和你说下我们这边的具体福利吧，我们这种逢年过节都有现金红包，一般都是500到1000块钱，过年有年终奖，一般至少半个月工资，具体看项目组每年的项目盈利，盈利的多拿的也就越多，双休平时不怎么加班，国家法定节假日，每年还有1次出国旅游，平时公司内部活动每个月都有”，贾珍珍巴拉巴拉说了一堆。&lt;/p&gt;
&lt;p&gt;“嗯，了解，所以你们这边给的工资是多少呢?”，我知道，这个话题准总不能不谈的，与其叫我开价，我还不如把球再抛给她。&lt;/p&gt;
&lt;p&gt;“我们这边给的薪资是试用期8K，转正8.5K，试用期是一个月”，贾珍珍这个时候的声音很利落干净。&lt;/p&gt;
&lt;p&gt;“啊，少这么多，比我以前工资还低些”，我上家公司就是8K，既然要跳槽换公司，肯定工资要比以前高几千吧，要不然有什么意思，我心里想。&lt;/p&gt;
&lt;p&gt;“我们这边是国企，薪资都是这样的，我们平台很稳定，你这边过来的话是公司重点培养的对象，其实也少不了多少钱，有个好的平台你能发挥的机会更多，其实对你的成长是很有帮助的，再说我们都觉得你挺合适的”。&lt;/p&gt;
&lt;p&gt;我还能说什么，我感觉我该说的都说完了，按照常规，我需要犹豫下再说。&lt;/p&gt;
&lt;p&gt;“嗯，嗯，那我要考虑下再决定”，我说道。&lt;/p&gt;
&lt;p&gt;“嗯，好的，但是你不要考虑太久，我们这边也还在招人中，我们是觉得你挺合适的，这样吧，今天下午可以给我们答复吗？”，贾珍珍追问道。&lt;/p&gt;
&lt;p&gt;“嗯，可以，下午给你答复”。其实对于我来说，现在也没有约面试，也没有其它offer正在选择，我觉得下午就可以给答复，所以我应道。&lt;/p&gt;
&lt;p&gt;“好的，雷刚，先不打扰你了，下午我再联系你，我们期待你的加入哦，好好考虑下”，贾珍珍说完就挂了。&lt;/p&gt;
&lt;p&gt;聊完电话后，我深深的想了下，对自己当前的处境也略分析了下，第一：我已经离职2个多月了，从本身专业技能角度上来说，我不能拖的太长，越拖下去我对这个行业的隔离就会越远，我自己是很清楚的，这2个月我几乎没看过任何和java相关的东西，我一个做技术的，如逆水行舟，不进则退，最重要的是，我都快对java这个职业失去兴趣了，这个也就是我前面所说到我对下一步要走的路的焦虑，我不知道其它工作3年的人有没有和我一样的感觉，我只知道唯一能做的就是再找个工作，一头扎进去，没时间想这些问题就是最好的解决方法。&lt;/p&gt;
&lt;p&gt;第二：我有点孤独，寂寞，我的世界只有我一个人的存在。弗洛姆说过人是群居动物，每个人都害怕孤独，孤独会有死亡恐惧，人为了克服孤独，就得不断的去和别人建立人际关系。&lt;/p&gt;
&lt;p&gt;以前上班和同事一起做项目，扯扯淡，晚上回家可能才有这种感觉，但是这2个月空闲下来让我白天也有这种感觉，我需要融入到社会工作中，和更多的人沟通交流，除了抗寂寞，也能发挥我的个人价值，唉，人啊，忙碌中即时即地的活在当下，清闲中患得患失的思考烦恼。第三：工作的目的是什么除了钱还有什么？我觉得除了上面讲的，还有一点就是生活的规律，这个是我这2个月最糟糕的事情，每天晚上2点睡觉，早上11点起床，不吃早餐，身体快废了，怎么才能生活自律，我觉得工作上班就是最好的方法。第四：这个工作对于我来说，我不是很排斥，再说离家也算近，楼下不远就是公交站，坐公交半个小时左右，要是找个远的，要是搬家就更加麻烦，再说国企相关来说较稳定，再说我没进过国企，以前听同事到处在BB吹嘘说什么who在国企，怎么怎么爽，我也不清楚，我进去了才清楚，还有贾珍珍我想多了解下。&lt;/p&gt;
&lt;p&gt;我这么一分析，感觉这个工作还行啊，我接着反问自己，那不满意的地方在哪里呢？我唯一能想到的就是少了2000快，这2000块钱我急需吗？刚需吗？我心里诺诺的应道，“不差这点钱”。我就是这么一个人，除了我当前的最大困境我处理不了，其它的所有的事情，我一定要在脑袋里面不断的思辨，有个结果我才算完，所以，事情烦恼是不能回避的，只有理清楚了才能获得内心的平静。&lt;/p&gt;
&lt;p&gt;今天下了一整天的雨，先是暴雨，然后就是毛毛雨，一直没停过，今天我没有看片，躺在床上一直在闭目养神，然后困了稍微眯了一下，半睡半清晰的状态从下午1点一直到5点，刚起来舒张下腰，电话那边响起来了，我知道是贾珍珍在问我最后的答复，我直接拿起电话，毫不犹豫的说道，“我明天会准时入职”，电话里面贾珍珍又交待了一些杂事，我挂断电话，做了一个重要的决定：今晚买条鱼，自己做饭吃，这个也是近2月来为数不多的自己做饭吃。&lt;/p&gt;

&lt;p&gt;…………&lt;/p&gt;

&lt;p&gt;第二天早上9点，我准时到达公司，直接走到贾珍珍办公室，贾珍珍今天穿了一件纯白带粉色边运动服，衣服有点紧，本来就饱满的身材显得格外往外凸，微卷的褐色头发扎成一个轻松活泼的辫子，显得有那么点可爱。一看到我来了，很热情，招呼我先坐下，给我倒了一杯水，说道：“你先把你的身份证，学历证，照片给我，我先去复印下”，我把昨天电话里面她要求的早准备好的资料装在一个袋子里面直接拿出来一起给她。她笑着说，“准备的挺周到的，是个做事情有条理的男人”，她笑着夸奖道。拿过资料，叫我先在房间坐一下，她说办公室打印机今天坏了，需要去隔壁另外房间打印下，说完了，就出去了。我坐下来，喝了一口水，环顾周围，发现她的办公室布置的挺简单别致，没有太多花里花哨的修饰却也有别有一番情趣,给人简洁、清爽的视觉效果，屋靠里边有一张大桌子，桌子中央一台27英寸显示器戴尔台式机，显示器下面2个角整整齐齐的贴满了便纸条，桌子左边放了一堆书籍，稍微看下，都是些人事管理相关的6层新的书籍，桌子右边是一个黑色的四格组合文件栏，里面放满了资料册，键盘右边有个漂亮的水杯，上面有些动物花纹，看不清楚，看是能看到里面还有半杯水，水杯旁还有个苹果静静的躺在那里，然后就是我坐的靠桌子大概5厘米的2把椅子，墙上挂了一些精致照片，有个肚子圆滚滚头发稀少的中年男人，我一眼就认出来了就是上次面试带我去见项目经理的网管，我近距离看来下，写了名字，“汪伟”，应该是他的名字吧。&lt;/p&gt;
&lt;p&gt;房间布置就这些，简单，我静下心来能闻的出里面有股淡淡的香味，这股香味是贾珍珍身上的一模一样，我就是这样一个人，思路如潮水，想象力特别丰富的人，从这股香味我能想象出很多意境的事情。&lt;/p&gt;
&lt;p&gt;“雷刚，久等了，我打印好了，你收好你的学历证和身份证”，贾珍珍突然出现在我眼睛，打乱我的思绪。&lt;/p&gt;
&lt;p&gt;我将学历证和身份证收好放到包里。&lt;/p&gt;
&lt;p&gt;“这有些资料你先填下，这2张是合同，你也先看下，有什么问题问我，然后签个字就行”&lt;/p&gt;
&lt;p&gt;，贾珍珍给了我几张纸，有张纸也是关于个人情况的纸和上次来面试的差不多，我把椅子搬到她办公桌前，我哗哗的几下就填完了，另外2份合同我稍微翻了下，重点看了薪资，合同是签3年的，说实话，这种东西也没什么太多的东西可看，因为有太多的地方看不懂，也懒的问，我看到还有个保密协定，为了表示我在认真看，多少也要问点东西吧，于是我问了贾珍珍这个保密协定是什么？&lt;/p&gt;
&lt;p&gt;“因为我们是国企，里面做的项目是不允许对外讲的，要做到保密”，贾珍珍说道。&lt;/p&gt;
&lt;p&gt;“哦，明白，了解”，我应道。&lt;/p&gt;
&lt;p&gt;于是我把填好的资料和签好字的合同都给她。&lt;/p&gt;
&lt;p&gt;“回头我们董事长盖好章和签字好了后，会给你一份合同”，贾珍珍将资料收起来放到桌子里面。&lt;/p&gt;
&lt;p&gt;“我们这边的上班情况你应该都知道了，9点上班，中午12点吃饭，下午2点上班，晚上6点下班，我们中午吃饭都是在统一的楼下3栋食堂吃饭，吃饭要办卡，你的卡等下办理好了我给你，我已经叫网管帮你办去了，卡里面每个月公司会自动冲300块钱在里面，如果用完了自己要去冲”，贾珍珍一连串的说完。&lt;/p&gt;
&lt;p&gt;“哦，好的”，我应道。&lt;/p&gt;
&lt;p&gt;“我现在带你去你的项目组，见你的项目组人员，具体的项目工作安排你的项目经理会和你沟通”，说完，贾珍珍带着我走到走廊一直往前走，走到上次里面面试的会议室的隔壁房间508。&lt;/p&gt;
&lt;p&gt;在门口，我一眼就看到前天面试我的帅气的项目经理李明，我上前主动打招呼，&lt;/p&gt;
&lt;p&gt;“李经理，你好”，&lt;/p&gt;
&lt;p&gt;李明笑容可掬走出来，边走边说，&lt;/p&gt;
&lt;p&gt;“呵呵，来了，来了就好”，&lt;/p&gt;
&lt;p&gt;然后对贾珍珍说，&lt;/p&gt;
&lt;p&gt;“你先忙你的，交给我就行了”。&lt;/p&gt;
&lt;p&gt;然后领我进了房间。&lt;/p&gt;
&lt;p&gt;嚯，好家伙。这个时候我终于看清楚整个房间的全貌，有意思，真的有意思，房间很宽，完全不是写字楼办公室那种布局，里面按照常规应该可以摆4排电脑办公桌，每排至少可以坐8个人办公，但是里面就总共就摆了一排，刚好8个位置，前面2个位置空着的，其余的6个人坐在那里，我用最快的速度扫描了一眼，发现有2个年级和我相仿的在eclipse里面快速的敲着代码，有2个年级稍微大点在讨论着什么问题，另外有个年级更大点头发有些发白的在看股票行情，还有个光头在敲着二郎脚带着耳机在听歌。阳气旺身，清一色童子军啊。里面左墙角边堆满了一张张折叠起的折叠床，颜色是五花八门，我无意中居然还看到有一张豹纹的折叠双人床，尼玛，这是什么情况，我心里默默的想。右墙角边放了个平时讨论会议的白板，白板上面依然还存留些流程设计图之类的笔迹，房间另外一边是个小办公室，估计是经理级别的专用房间。(房间布局有点怪异，后面我才知道，这样布局好打扫卫生，基本上一个部门或者项目组一个房间，房间的卫生也是自己项目组负责)。&lt;/p&gt;
&lt;p&gt;“大家先停下手上的工作，来了个新同事，我和大家介绍下”，李明喊道。&lt;/p&gt;
&lt;p&gt;大家注意力都转向李明，看股票的那大爷拍了下光头强，光头取下耳机也看着这边。&lt;/p&gt;
&lt;p&gt;“雷刚，要不你自己稍微介绍下自己呗”，李明拍了拍我的肩旁，笑呵呵的说道。&lt;/p&gt;
&lt;p&gt;“大家好，我叫雷刚，我是湖南XX人，我今年27岁，来这个城市有3年了，我之前一直做java软件开发这块工作…………”，稍微巴拉巴拉下，最好说了声，&lt;/p&gt;
&lt;p&gt;“初来乍到，大家请多多关照”，说完。李明拍拍手掌。&lt;/p&gt;
&lt;p&gt;“行，挺好的”，李明说道。我给你们稍微介绍下项目组成员吧，&lt;/p&gt;
&lt;p&gt;“这个是王中洪，java高级软件工程师，目前主要负责项目上的日常开发工作”。&lt;/p&gt;
&lt;p&gt;“这个是曾少陵，java前端开发工程师，也是主要负责项目上的日常开发工作，前后台都行的“。&lt;/p&gt;
&lt;p&gt;“里面那位是陈松，java系统分析师，主要负责系统设计，系统方案，以及日常开发工作”，&lt;/p&gt;
&lt;p&gt;“他隔壁那位是汪飞，需求分析师，其它部门的需求到我们这边都是经过他的手，专门负责和产品部门的沟通”，&lt;/p&gt;
&lt;p&gt;“那位在看股票行情叫罗林，是一位非常资深的高级测试，项目组所有的软件开发上线都是要经过他的同意，他现在不是在炒股哦，他现在在看的东西也是和我们项目有关的，后面你就会知道”，&lt;/p&gt;
&lt;p&gt;“最里面那位光头大哥就侯超，超哥，是java资深架构师，平台方面的架构都是他负责的，后面多请教他，会学到很多东西”，&lt;/p&gt;
&lt;p&gt;“嗯”，我应道。&lt;/p&gt;
&lt;p&gt;“我们整个项目成员都在这里，后面会慢慢熟悉，我们项目组所负责的业务回头我再和你慢慢介绍，你今天先熟悉熟悉环境，把一些开发环境弄好，你就坐在王中洪左边吧，你看看这电脑能不能用，要不要重新装个系统，你随便弄”，然后和王中洪打了个招呼叫他有什么问题帮我，然后就走向他自己的办公室。&lt;/p&gt;
&lt;p&gt;我坐在第2位置，仔细打量了下电脑，是台联想台式机，好像是天逸系列，我摸了显示器，明显感觉布满了灰层，我打开包，拿出随身带着的餐纸轻轻的擦着，按下主机电源，过了3秒，开机了，在开机过程中，王中洪说道，&lt;/p&gt;
&lt;p&gt;“这些电脑都是最近3个月新买的，公司每1年都会换一批新机器，这些配置还可以，i5，4核8G的，写代码够了”。&lt;/p&gt;
&lt;p&gt;“嗯，确实这个搞java够了”，我应道，开机不需要密码，是win10操作系统，我进去一看，硬盘里面都非常干净，应该是没人用过，既然这样我也不需要重装系统，我看王中洪他们用的也是win10。&lt;/p&gt;
&lt;p&gt;稍微和王中洪聊了下项目组用的一些java开发工具和版本，和我之前的差不多，我自己先将环境安装起来。&lt;/p&gt;
&lt;p&gt;……….&lt;/p&gt;
&lt;p&gt;这一天过的挺平平常常，项目组内大家都在做自己的事，有问题我也是和王中洪聊了下，中午之前贾珍珍帮我送饭卡来就走了，中午也是和大家一起去楼下食堂吃的饭，可能刚来大家还不熟悉，和几位老前辈聊不上几句话，整个下午自己都是在看王中洪发来的一些文档，从文档里面大概了解下这个项目组是做金融项目的项目。&lt;/p&gt;
&lt;p&gt;晚上6点大家都准时下班。&lt;/p&gt;
&lt;p&gt;无打卡。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 16:04:00 +0000</pubDate>
<dc:creator>心灵之火</dc:creator>
<og:description>天灰沉沉的，地皮上不断的发出一阵难闻的气味。一场暴雨即将而至。 这已经是面试回来的第二天，像往常一样，睡到11点自然醒，我也不知道这个是叫幸福还是悲剧，我的睡眠质量还是挺好的。刚在楼下吃了个10块钱的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgcjiayou/p/9595645.html</dc:identifier>
</item>
<item>
<title>Java并发之线程池ThreadPoolExecutor源码分析学习 - KingJack</title>
<link>http://www.cnblogs.com/KingJack/p/9595621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KingJack/p/9595621.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下所有内容以及源码分析都是基于JDK1.8的，请知悉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我写博客就真的比较没有顺序了，这可能跟我的学习方式有关，我自己也觉得这样挺不好的，但是没办法说服自己去改变，所以也只能这样想到什么学什么了。&lt;/p&gt;
&lt;p&gt;​ 池化技术真的是一门在我看来非常牛逼的技术，因为它做到了在有限资源内实现了资源利用的最大化，这让我想到了一门课程，那就是运筹学，当时在上运筹学的时候就经常做这种类似的问题。&lt;/p&gt;
&lt;p&gt;​ 言归正传吧，我接下来会进行一次线程池方面知识点的学习，也会记录下来分享给大家。&lt;/p&gt;
&lt;p&gt;线程池的内容当中有涉及到AQS同步器的知识点，如果对AQS同步器知识点感觉有点薄弱，可以去看我的上一篇文章。&lt;/p&gt;
&lt;h2 id=&quot;线程池的优势&quot;&gt;线程池的优势&lt;/h2&gt;
&lt;p&gt;​ 既然说到线程池了，而且大多数的大牛也都会建议我们使用池化技术来管理一些资源，那线程池肯定也是有它的好处的，要不然怎么会那么出名并且让大家使用呢？&lt;/p&gt;
&lt;p&gt;​ 我们就来看看它究竟有什么优势？&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;资源可控性：使用线程池可以避免创建大量线程而导致内存的消耗&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提高响应速度：线程池地创建实际上是很消耗时间和性能的，由线程池创建好有任务就运行，提升响应速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;便于管理：池化技术最突出的一个特点就是可以帮助我们对池子里的资源进行管理。由线程池统一分配和管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程池的创建&quot;&gt;线程池的创建&lt;/h2&gt;
&lt;p&gt;​ 我们要用线程池来统一分配和管理我们的线程，那首先我们要创建一个线程池出来，还是有很多大牛已经帮我们写好了很多方面的代码的，Executors的工厂方法就给我们提供了创建多种不同线程池的方法。因为这个类只是一个创建对象的工厂，并没有涉及到很多的具体实现，所以我不会过于详细地去说明。&lt;/p&gt;
&lt;p&gt;​ 老规矩，还是直接上代码吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也就举出一个方法的例子来进行之后的讲解吧，我们可以看出，Executors只是个工厂而已，方法也只是来实例化不同的对象，实际上实例化出来的关键类就是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。现在我们就先来简单地对&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数内的每个参数进行解释一下吧。&lt;/p&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;corePoolSize(核心线程池大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，当任务数大于核心线程数的时候就不会再创建。在这里要注意一点，线程池刚创建的时候，其中并没有创建任何线程，而是等任务来才去创建线程，除非调用了&lt;code&gt;prestartAllCoreThreads()&lt;/code&gt;或者&lt;code&gt;prestartCoreThread()&lt;/code&gt;方法 ，这样才会预先创建好&lt;code&gt;corePoolSize&lt;/code&gt;个线程或者一个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;maximumPoolSize(线程池最大线程数)：线程池允许创建的最大线程数，如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界队列，此参数就没有意义了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;keepAliveTime(线程活动保持时间)：此参数默认在线程数大于&lt;code&gt;corePoolSize&lt;/code&gt;的情况下才会起作用， 当线程的空闲时间达到&lt;code&gt;keepAliveTime&lt;/code&gt;的时候就会终止，直至线程数目小于&lt;code&gt;corePoolSize&lt;/code&gt;。不过如果调用了&lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt;方法，则当线程数目小于&lt;code&gt;corePoolSize&lt;/code&gt;的时候也会起作用.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;unit(keelAliveTime的时间单位)：keelAliveTime的时间单位，一共有7种，在这里就不列举了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;workQueue(阻塞队列)：阻塞队列，用来存储等待执行的任务，这个参数也是非常重要的，在这里简单介绍一下几个阻塞队列。&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ArrayBlockingQueue：这是一个基于数组结构的有界阻塞队列，此队列按照FIFO的原则对元素进行排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按照FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法&lt;code&gt;Executors.newFixedThreadPool()&lt;/code&gt;就是使用了这个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。吞吐量通常要高于LinkedBlockingQueue，静态工厂方法&lt;code&gt;Executors.newCachedThreadPool()&lt;/code&gt;就使用了这个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PriorityBlockingQueue：一个具有优先级的无阻塞队列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;handler(饱和策略)；当线程池和队列都满了，说明线程池已经处于饱和状态了，那么必须采取一种策略来处理还在提交过来的新任务。这个饱和策略默认情况下是&lt;code&gt;AbortPolicy&lt;/code&gt;，表示无法处理新任务时抛出异常。共有四种饱和策略提供，当然我们也可以选择自己实现饱和策略。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AbortPolicy：直接丢弃并且抛出&lt;code&gt;RejectedExecutionException&lt;/code&gt;异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CallerRunsPolicy：只用调用者所在线程来运行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DiscardPolicy：丢弃任务并且不抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;线程池的执行流程就用参考资料里的图介绍一下了，具体我们还是通过代码去讲解。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5814285-e7da0746655d30e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;线程池流程.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面我们简单的讲解了一下&lt;code&gt;Executors&lt;/code&gt;这个工厂类里的工厂方法，并且讲述了一下创建线程池的一些参数以及它们的作用，当然上面的讲解并不是很深入，因为想要弄懂的话是需要持续地花时间去看去理解的，而博主自己也还是没有完全弄懂，不过博主的学习方法是先学了个大概，再回头来看看之前的知识点，可能会更加好理解，所以我们接着往下面讲吧。&lt;/p&gt;
&lt;h2 id=&quot;threadpoolexecutor源码分析&quot;&gt;ThreadPoolExecutor源码分析&lt;/h2&gt;
&lt;p&gt;​ 在上面我们就发现了，&lt;code&gt;Executors&lt;/code&gt;的工厂方法主要就返回了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;对象，至于另一个在这里暂时不讲，也就是说，要学习线程池，其实关键的还是得学会分析&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;这个对象里面的源码，我们接下来就会对&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;里的关键代码进行分析。&lt;/p&gt;
&lt;h3 id=&quot;atomicinteger-ctl&quot;&gt;AtomicInteger ctl&lt;/h3&gt;
&lt;p&gt;​ &lt;code&gt;ctl&lt;/code&gt;是主要的控制状态，是一个复合类型的变量，其中包括了两个概念。&lt;/p&gt;
&lt;p&gt;我们来分析一下跟&lt;code&gt;ctl&lt;/code&gt;有关的一些源代码吧，直接上代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

     //用来表示线程池数量的位数，很明显是29，Integer.SIZE=32
     private static final int COUNT_BITS = Integer.SIZE - 3;
     //线程池最大数量，2^29 - 1
     private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

     // runState is stored in the high-order bits
     //我们可以看出有5种runState状态，证明至少需要3位来表示runState状态
     //所以高三位就是表示runState了
     private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
     private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
     private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
     private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
     private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

     // Packing and unpacking ctl
     private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
     private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
     private static int ctlOf(int rs, int wc) { return rs | wc; }

     //用于存放线程任务的阻塞队列
     private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;

     //重入锁
     private final ReentrantLock mainLock = new ReentrantLock();

     //线程池当中的线程集合，只有当拥有mainLock锁的时候，才可以进行访问
     private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();

     //等待条件支持终止
     private final Condition termination = mainLock.newCondition();

     //创建新线程的线程工厂
     private volatile ThreadFactory threadFactory;

     //饱和策略
     private volatile RejectedExecutionHandler handler;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CAPACITY&lt;/p&gt;
&lt;p&gt;在这里我们讲一下这个线程池最大数量的计算吧，因为这里涉及到源码以及位移之类的操作，我感觉大多数人都还是不太会这个，因为我一开始看的时候也是不太会的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码我们可以看出，是需要&lt;code&gt;1往左移29位&lt;/code&gt;，然后再减去1，那个&lt;code&gt;1往左移29位&lt;/code&gt;是怎么计算的呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     1 &amp;lt;&amp;lt; COUNT_BITS
      ​
      1的32位2进制是
      00000000 00000000 00000000 00000001
      ​
      左移29位的话就是
      00100000 00000000 00000000 00000000
      ​
      再进行减一的操作
      000 11111 11111111 11111111 11111111
      ​
      也就是说线程池最大数目就是
      000 11111 11111111 11111111 11111111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.runState&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正数的原码、反码、补码都是一样的&lt;br/&gt;在计算机底层，是用补码来表示的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int SHUTDOWN = 0 &amp;lt;&amp;lt; COUNT_BITS;
private static final int STOP = 1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TIDYING    = 2 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TERMINATED = 3 &amp;lt;&amp;lt; COUNT_BITS;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;RUNNING&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以接受新任务并且处理已经在阻塞队列的任务&lt;br/&gt;高3位全部是1的话，就是RUNNING状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-1 &amp;lt;&amp;lt; COUNT_BITS

这里是-1往左移29位，稍微有点不一样，-1的话需要我们自己算出补码来
          ​
-1的原码
10000000 00000000 00000000 00000001
          ​
-1的反码，负数的反码是将原码除符号位以外全部取反
11111111 11111111 11111111 11111110
          ​
-1的补码，负数的补码就是将反码+1
11111111 11111111 11111111 11111111
          ​
关键了，往左移29位，所以高3位全是1就是RUNNING状态
111 00000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;SHUTDOWN&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不接受新任务，但是处理已经在阻塞队列的任务&lt;br/&gt;高3位全是0，就是SHUTDOWN状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;0 &amp;lt;&amp;lt; COUNT_BITS
          ​
0的表示
00000000 00000000 00000000 00000000
          ​
往左移29位
00000000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;STOP&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不接受新任务，也不处理阻塞队列里的任务，并且会中断正在处理的任务&lt;br/&gt;所以高3位是001，就是STOP状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1 &amp;lt;&amp;lt; COUNT_BITS
          ​
1的表示
00000000 00000000 00000000 00000001
          ​
往左移29位
00100000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;TIDYING&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所有任务都被中止，workerCount是0，线程状态转化为TIDYING并且调用terminated()钩子方法&lt;br/&gt;所以高3位是010，就是TIDYING状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2 &amp;lt;&amp;lt; COUNT_BITS
          ​
2的32位2进制
00000000 00000000 00000000 00000010
          ​
往左移29位
01000000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;TERMINATED&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;terminated()钩子方法已经完成&lt;br/&gt;所以高3位是110，就是TERMINATED状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;3 &amp;lt;&amp;lt; COUNT_BITS
          ​
3的32位2进制
00000000 00000000 00000000 00000011
          ​
往左移29位
11000000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.部分方法介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;runStateOf(int c)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实时获取runState的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;~CAPACITY
~是按位取反的意思
&amp;amp;是按位与的意思
          ​
而CAPACITY是，高位3个0，低29位都是1，所以是
000 11111 11111111 11111111 11111111
          ​
取反的话就是
111 00000 00000000 00000000 00000000
          ​
传进来的c参数与取反的CAPACITY进行按位与操作
1、低位29个0进行按位与，还是29个0
2、高位3个1，既保持c参数的高3位
既高位保持原样，低29位都是0，这也就获得了线程池的运行状态runState&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;workerCountOf(int c)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;获取线程池的当前有效线程数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CAPACITY的32位2进制是
000 11111 11111111 11111111 11111111
          ​
用入参c跟CAPACITY进行按位与操作
1、低29位都是1，所以保留c的低29位，也就是有效线程数
2、高3位都是0，所以c的高3位也是0
          ​
这样获取出来的便是workerCount的值&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;ctlOf(int rs, int wc)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原子整型变量ctl的初始化方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//结合这几句代码来看
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
          ​
private static int ctlOf(int rs, int wc) { return rs | wc; }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;RUNNING是
111 00000 00000000 00000000 00000000
          ​
ctlOf是将rs和wc进行按位或的操作
          ​
初始化的时候是将RUNNING和0进行按位或
0的32位2进制是
00000000 00000000 00000000 00000000
          ​
所以初始化的ctl是
111 00000 00000000 00000000 00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;核心方法源码分析&quot;&gt;核心方法源码分析&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;execute(Runnable command)方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      public void execute(Runnable command) {
          //需要执行的任务command为空，抛出空指针异常
          if (command == null)  // 1
              throw new NullPointerException();

          /*
          *执行的流程实际上分为三步
          *1、如果运行的线程小于corePoolSize，以用户给定的Runable对象新开一个线程去执行
          *  并且执行addWorker方法会以原子性操作去检查runState和workerCount，以防止当返回false的
          *  时候添加了不应该添加的线程
          *2、 如果任务能够成功添加到队列当中，我们仍需要对添加的线程进行双重检查，有可能添加的线程在前
          *  一次检查时已经死亡，又或者在进入该方法的时候线程池关闭了。所以我们需要复查状态，并有有必
          *  要的话需要在停止时回滚入列操作，或者在没有线程的时候新开一个线程
          *3、如果任务无法入列，那我们需要尝试新增一个线程，如果新建线程失败了，我们就知道线程可能关闭了
          *  或者饱和了，就需要拒绝这个任务
          *
          */

          //获取线程池的控制状态
          int c = ctl.get();  // 2

          //通过workCountOf方法算workerCount值，小于corePoolSize
          if (workerCountOf(c) &amp;lt; corePoolSize) {
              //添加任务到worker集合当中
      if (addWorker(command, true)) 
                  return;  //成功返回
              //失败的话再次获取线程池的控制状态
              c = ctl.get();
          }

          /*
          *判断线程池是否正处于RUNNING状态
          *是的话添加Runnable对象到workQueue队列当中
          */
          if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {  // 3

              //再次获取线程池的状态
              int recheck = ctl.get();

              //再次检查状态
              //线程池不处于RUNNING状态，将任务从workQueue队列中移除
              if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
                  //拒绝任务
                  reject(command);
              //workerCount等于0
              else if (workerCountOf(recheck) == 0)  // 4
                  //添加worker
                  addWorker(null, false);
          }
          //加入阻塞队列失败，则尝试以线程池最大线程数新开线程去执行该任务
      else if (!addWorker(command, false))  // 5 
              //执行失败则拒绝任务
              reject(command);
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来说一下上面这个代码的流程：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、首先判断任务是否为空，空则抛出空指针异常&lt;br/&gt;2、不为空则获取线程池控制状态，判断小于corePoolSize，添加到worker集合当中执行，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如成功，则返回&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;失败的话再接着获取线程池控制状态，因为只有状态变了才会失败，所以重新获取&lt;br/&gt;3、判断线程池是否处于运行状态，是的话则添加command到阻塞队列，加入时也会再次获取状态并且检测&lt;br/&gt;​ 状态是否不处于运行状态，不处于的话则将command从阻塞队列移除，并且拒绝任务&lt;br/&gt;4、如果线程池里没有了线程，则创建新的线程去执行获取阻塞队列的任务执行&lt;br/&gt;5、如果以上都没执行成功，则需要开启最大线程池里的线程来执行任务，失败的话就丢弃&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;有时候再多的文字也不如一个流程图来的明白，所以还是画了个execute的流程图给大家方便理解。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5814285-391891eee2da235f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;execute执行流程.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.addWorker(Runnable firstTask, boolean core)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      private boolean addWorker(Runnable firstTask, boolean core) {
          //外部循环标记
          retry:
          //外层死循环
          for (;;) {
              //获取线程池控制状态
              int c = ctl.get();
              //获取runState
              int rs = runStateOf(c);
      ​
              // Check if queue empty only if necessary.

              /**
              *1.如果线程池runState至少已经是SHUTDOWN
              *2\. 有一个是false则addWorker失败，看false的情况
              * - runState==SHUTDOWN，即状态已经大于SHUTDOWN了
              * - firstTask为null，即传进来的任务为空，结合上面就是runState是SHUTDOWN，但是
              *  firstTask不为空，代表线程池已经关闭了还在传任务进来
              * - 队列为空，既然任务已经为空，队列为空，就不需要往线程池添加任务了
              */
              if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;  //runState大于等于SHUTDOWN,初始位RUNNING
                  ! (rs == SHUTDOWN &amp;amp;&amp;amp;  //runState等于SHUTDOWN
                     firstTask == null &amp;amp;&amp;amp;  //firstTask为null
                     ! workQueue.isEmpty()))  //workQueue队列不为空
                  return false;
      ​
              //内层死循环
              for (;;) {
                  //获取线程池的workerCount数量
                  int wc = workerCountOf(c);
                  //如果workerCount超出最大值或者大于corePoolSize/maximumPoolSize
                  //返回false
                  if (wc &amp;gt;= CAPACITY ||
                      wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                      return false;
                  //通过CAS操作，使workerCount数量+1，成功则跳出循环，回到retry标记
                  if (compareAndIncrementWorkerCount(c))
                      break retry;

                  //CAS操作失败，再次获取线程池的控制状态
                  c = ctl.get();  // Re-read ctl
                  //如果当前runState不等于刚开始获取的runState，则跳出内层循环，继续外层循环
                  if (runStateOf(c) != rs)
                      continue retry;
                  // else CAS failed due to workerCount change; retry inner loop
                  //CAS由于更改workerCount而失败，继续内层循环
              }
          }
      ​
          //通过以上循环，能执行到这是workerCount成功+1了

          //worker开始标记
          boolean workerStarted = false;
          //worker添加标记
          boolean workerAdded = false;
          //初始化worker为null
          Worker w = null;
          try {
              //初始化一个当前Runnable对象的worker对象
              w = new Worker(firstTask);
              //获取该worker对应的线程
              final Thread t = w.thread;
              //如果线程不为null
              if (t != null) {
                  //初始线程池的锁
                  final ReentrantLock mainLock = this.mainLock;
                  //获取锁
                  mainLock.lock();
                  try {
                      // Recheck while holding lock.
                      // Back out on ThreadFactory failure or if
                      // shut down before lock acquired.
                      //获取锁后再次检查，获取线程池runState
                      int rs = runStateOf(ctl.get());
      ​
                      //当runState小于SHUTDOWN或者runState等于SHUTDOWN并且firstTask为null
                      if (rs &amp;lt; SHUTDOWN ||
                          (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {

                          //线程已存活
                          if (t.isAlive()) // precheck that t is startable
                              //线程未启动就存活，抛出IllegalThreadStateException异常
                              throw new IllegalThreadStateException();

                          //将worker对象添加到workers集合当中
                          workers.add(w);
                          //获取workers集合的大小
                          int s = workers.size();
                          //如果大小超过largestPoolSize
                          if (s &amp;gt; largestPoolSize)
                              //重新设置largestPoolSize
                              largestPoolSize = s;
                          //标记worker已经被添加
                          workerAdded = true;
                      }
                  } finally {
                      //释放锁
                      mainLock.unlock();
                  }
                  //如果worker添加成功
                  if (workerAdded) {
                      //启动线程
                      t.start();
                      //标记worker已经启动
                      workerStarted = true;
                  }
              }
          } finally {
              //如果worker没有启动成功
              if (! workerStarted)
                  //workerCount-1的操作
                  addWorkerFailed(w);
          }
          //返回worker是否启动的标记
          return workerStarted;
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也简单说一下这个代码的流程吧，还真的是挺难的，博主写的时候都停了好多次，想砸键盘的说：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、获取线程池的控制状态，进行判断，不符合则返回false，符合则下一步&lt;br/&gt;2、死循环，判断workerCount是否大于上限，或者大于corePoolSize/maximumPoolSize，没有的话则对workerCount+1操作，&lt;br/&gt;3、如果不符合上述判断或+1操作失败，再次获取线程池的控制状态，获取runState与刚开始获取的runState相比，不一致则跳出内层循环继续外层循环，否则继续内层循环&lt;br/&gt;4、+1操作成功后，使用重入锁ReentrantLock来保证往workers当中添加worker实例，添加成功就启动该实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来看看流程图来理解一下上面代码的一个执行流程&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5814285-f4682a62cbff2231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;addWorker.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.addWorkerFailed(Worker w)&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;addWorker方法添加worker失败，并且没有成功启动任务的时候，就会调用此方法，将任务从workers中移除，并且workerCount做-1操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      private void addWorkerFailed(Worker w) {
          //重入锁
          final ReentrantLock mainLock = this.mainLock;
          //获取锁
          mainLock.lock();
          try {
              //如果worker不为null
              if (w != null)
                  //workers移除worker
                  workers.remove(w);
              //通过CAS操作，workerCount-1
              decrementWorkerCount();
              tryTerminate();
          } finally {
              //释放锁
              mainLock.unlock();
          }
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.tryTerminate()&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当对线程池执行了非正常成功逻辑的操作时，都会需要执行tryTerminate尝试终止线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      final void tryTerminate() {
          //死循环
          for (;;) {
              //获取线程池控制状态
              int c = ctl.get();

              /*
              *线程池处于RUNNING状态
              *线程池状态最小大于TIDYING
              *线程池==SHUTDOWN并且workQUeue不为空
              *直接return，不能终止
              */
              if (isRunning(c) ||
                  runStateAtLeast(c, TIDYING) ||
                  (runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty()))
                  return;

              //如果workerCount不为0
              if (workerCountOf(c) != 0) { // Eligible to terminate
                  interruptIdleWorkers(ONLY_ONE);
                  return;
              }
      ​
              //获取线程池的锁
              final ReentrantLock mainLock = this.mainLock;
              //获取锁
              mainLock.lock();
              try {
                  //通过CAS操作，设置线程池状态为TIDYING
                  if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                      try {
                          terminated();
                      } finally {
                          //设置线程池的状态为TERMINATED
                          ctl.set(ctlOf(TERMINATED, 0));
                          //发送释放信号给在termination条件上等待的线程
                          termination.signalAll();
                      }
                      return;
                  }
              } finally {
                  //释放锁
                  mainLock.unlock();
              }
              // else retry on failed CAS
          }
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.runWorker(Worker w)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该方法的作用就是去执行任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void runWorker(Worker w) {
      //获取当前线程
      Thread wt = Thread.currentThread();
      //获取worker里的任务
      Runnable task = w.firstTask;
      //将worker实例的任务赋值为null
      w.firstTask = null;

      /*
      *unlock方法会调用AQS的release方法
      *release方法会调用具体实现类也就是Worker的tryRelease方法
      *也就是将AQS状态置为0，允许中断
      */
      w.unlock(); // allow interrupts
      //是否突然完成
      boolean completedAbruptly = true;
      try {
          //worker实例的task不为空，或者通过getTask获取的不为空
          while (task != null || (task = getTask()) != null) {
              //获取锁
              w.lock();
              // If pool is stopping, ensure thread is interrupted;
              // if not, ensure thread is not interrupted.  This
              // requires a recheck in second case to deal with
              // shutdownNow race while clearing interrupt
              /*
              *获取线程池的控制状态，至少要大于STOP状态
              *如果状态不对，检查当前线程是否中断并清除中断状态，并且再次检查线程池状态是否大于STOP
              *如果上述满足，检查该对象是否处于中断状态，不清除中断标记
              */
              if ((runStateAtLeast(ctl.get(), STOP) ||
                   (Thread.interrupted() &amp;amp;&amp;amp;
                    runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                  !wt.isInterrupted())
                  //中断改对象
                  wt.interrupt();
              try {
                  //执行前的方法，由子类具体实现
                  beforeExecute(wt, task);
                  Throwable thrown = null;
                  try {
                      //执行任务
                      task.run();
                  } catch (RuntimeException x) {
                      thrown = x; throw x;
                  } catch (Error x) {
                      thrown = x; throw x;
                  } catch (Throwable x) {
                      thrown = x; throw new Error(x);
                  } finally {
                      //执行完后调用的方法，也是由子类具体实现
                      afterExecute(task, thrown);
                  }
              } finally {//执行完后
                  //task设置为null
                  task = null;
                  //已完成任务数+1
                  w.completedTasks++;
                  //释放锁
                  w.unlock();
              }
          }
          completedAbruptly = false;
      } finally {
          //处理并退出当前worker
          processWorkerExit(w, completedAbruptly);
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们用文字来说明一下执行任务这个方法的具体逻辑和流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先在方法一进来，就执行了w.unlock()，这是为了将AQS的状态改为0，因为只有getState() &amp;gt;= 0的时候，线程才可以被中断；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;判断firstTask是否为空，为空则通过getTask()获取任务，不为空接着往下执行&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;判断是否符合中断状态，符合的话设置中断标记&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;执行beforeExecute()，task.run()，afterExecute()方法&lt;/li&gt;
&lt;li&gt;任何一个出异常都会导致任务执行的终止；进入processWorkerExit来退出任务&lt;/li&gt;
&lt;li&gt;正常执行的话会接着回到步骤2&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;附上一副简单的流程图:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5814285-23abafc5e23fb5c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;runWorker.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.getTask()&lt;/p&gt;
&lt;p&gt;在上面的runWorker方法当中我们可以看出，当firstTask为空的时候，会通过该方法来接着获取任务去执行，那我们就看看获取任务这个方法到底是怎么样的？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;      private Runnable getTask() {
          //标志是否获取任务超时
          boolean timedOut = false; // Did the last poll() time out?
      ​
          //死循环
          for (;;) {
              //获取线程池的控制状态
              int c = ctl.get();
              //获取线程池的runState
              int rs = runStateOf(c);
      ​
              // Check if queue empty only if necessary.
              /*
              *判断线程池的状态，出现以下两种情况
              *1、runState大于等于SHUTDOWN状态
              *2、runState大于等于STOP或者阻塞队列为空
              *将会通过CAS操作，进行workerCount-1并返回null
              */
              if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
                  decrementWorkerCount();
                  return null;
              }
      ​
              //获取线程池的workerCount
              int wc = workerCountOf(c);
      ​
              // Are workers subject to culling?

              /*
              *allowCoreThreadTimeOut：是否允许core Thread超时，默认false
              *workerCount是否大于核心核心线程池
              */
              boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;
      ​
              /*
              *1、wc大于maximumPoolSize或者已超时
              *2、队列不为空时保证至少有一个任务
              */
              if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
                  &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
                  /*
                  *通过CAS操作，workerCount-1
                  *能进行-1操作，证明wc大于maximumPoolSize或者已经超时
                  */
                  if (compareAndDecrementWorkerCount(c))
                      //-1操作成功，返回null
                      return null;
                  //-1操作失败，继续循环
                  continue;
              }
      ​
              try {
                  /*
                  *wc大于核心线程池
                  *执行poll方法
                  *小于核心线程池
                  *执行take方法
                  */
                  Runnable r = timed ?
                      workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                  workQueue.take();
                  //判断任务不为空返回任务
                  if (r != null)
                      return r;
                  //获取一段时间没有获取到，获取超时
                  timedOut = true;
              } catch (InterruptedException retry) {
                  timedOut = false;
              }
          }
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是文字解说一下上面的代码逻辑和流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;获取线程池控制状态和runState，判断线程池是否已经关闭或者正在关闭，是的话则workerCount-1操作返回null&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;获取workerCount判断是否大于核心线程池&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;判断workerCount是否大于最大线程池数目或者已经超时，是的话workerCount-1，-1成功则返回null，不成功则回到步骤1重新继续&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;判断workerCount是否大于核心线程池，大于则用poll方法从队列获取任务，否则用take方法从队列获取任务&lt;/li&gt;
&lt;li&gt;判断任务是否为空，不为空则返回获取的任务，否则回到步骤1重新继续&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;接下来依然有一副流程图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5814285-32d0795e439afc03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;getTask.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.processWorkerExit&lt;/p&gt;
&lt;p&gt;明显的，在执行任务当中，会去获取任务进行执行，那既然是执行任务，肯定就会有执行完或者出现异常中断执行的时候，那这时候肯定也会有相对应的操作，至于具体操作是怎么样的，我们还是直接去看源码最实际。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     private void processWorkerExit(Worker w, boolean completedAbruptly) {
          /*
          *completedAbruptly:在runWorker出现，代表是否突然完成的意思
          *也就是在执行任务过程当中出现异常，就会突然完成，传true
          *
          *如果是突然完成，需要通过CAS操作，workerCount-1
          *不是突然完成，则不需要-1，因为getTask方法当中已经-1
          *
          *下面的代码注释貌似与代码意思相反了
          */
          if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
              decrementWorkerCount();
      ​
          //生成重入锁
          final ReentrantLock mainLock = this.mainLock;
          //获取锁
          mainLock.lock();
          try {
              //线程池统计的完成任务数completedTaskCount加上worker当中完成的任务数
              completedTaskCount += w.completedTasks;
              //从HashSet&amp;lt;Worker&amp;gt;中移除
              workers.remove(w);
          } finally {
              //释放锁
              mainLock.unlock();
          }
      ​
          //因为上述操作是释放任务或线程，所以会判断线程池状态，尝试终止线程池
          tryTerminate();
      ​
          //获取线程池的控制状态
          int c = ctl.get();

          //判断runState是否小鱼STOP，即是RUNNING或者SHUTDOWN
          //如果是RUNNING或者SHUTDOWN，代表没有成功终止线程池
          if (runStateLessThan(c, STOP)) {
              /*
              *是否突然完成
              *如若不是，代表已经没有任务可获取完成，因为getTask当中是while循环
              */
              if (!completedAbruptly) {
                  /*
                  *allowCoreThreadTimeOut:是否允许core thread超时，默认false
                  *min-默认是corePoolSize
                  */
                  int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                  //允许core thread超时并且队列不为空
                  //min为0，即允许core thread超时，这样就不需要维护核心核心线程池了
                  //如果workQueue不为空，则至少保持一个线程存活
                  if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                      min = 1;
                  //如果workerCount大于min，则表示满足所需，可以直接返回
                  if (workerCountOf(c) &amp;gt;= min)
                      return; // replacement not needed
              }
              //如果是突然完成，添加一个空任务的worker线程--这里我也不太理解
              addWorker(null, false);
          }
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先判断线程是否突然终止，如果是突然终止，通过CAS，workerCount-1&lt;/li&gt;
&lt;li&gt;统计线程池完成任务数，并将worker从workers当中移除&lt;/li&gt;
&lt;li&gt;判断线程池状态，尝试终止线程池&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;线程池没有成功终止
&lt;ul&gt;&lt;li&gt;判断是否突然完成任务，不是则进行下一步，是则进行第三步&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如允许核心线程超时，队列不为空，则至少保证一个线程存活&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;添加一个空任务的worker线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;worker内部类&quot;&gt;Worker内部类&lt;/h3&gt;
&lt;p&gt;​ 我们在上面已经算是挺详细地讲了线程池执行任务&lt;code&gt;execute&lt;/code&gt;的执行流程和一些细节，在上面频繁地出现了一个字眼，那就是worker实例，那么这个worker究竟是什么呢？里面都包含了一些什么信息，以及worker这个任务究竟是怎么执行的呢？&lt;/p&gt;
&lt;p&gt;​ 我们就在这个部分来介绍一下吧，还是直接上源码：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们可以看到Worker内部类继承AQS同步器并且实现了Runnable接口，所以Worker很明显就是一个可执行任务并且又可以控制中断、起到锁效果的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private final class Worker
          extends AbstractQueuedSynchronizer
          implements Runnable
      {
          /**
           * This class will never be serialized, but we provide a
           * serialVersionUID to suppress a javac warning.
           */
          private static final long serialVersionUID = 6138294804551838833L;
  ​
          /** 工作线程，如果工厂失败则为空. */
          final Thread thread;
          /** 初始化任务，有可能为空 */
          Runnable firstTask;
          /** 已完成的任务计数 */
          volatile long completedTasks;
  ​
          /**
           * 创建并初始化第一个任务，使用线程工厂来创建线程
           * 初始化有3步
           *1、设置AQS的同步状态为-1，表示该对象需要被唤醒
           *2、初始化第一个任务
           *3、调用ThreadFactory来使自身创建一个线程，并赋值给worker的成员变量thread
           */
          Worker(Runnable firstTask) {
              setState(-1); // inhibit interrupts until runWorker
              this.firstTask = firstTask;
              this.thread = getThreadFactory().newThread(this);
          }
  ​
    //重写Runnable的run方法
          /** Delegates main run loop to outer runWorker  */
          public void run() {
              //调用ThreadPoolExecutor的runWorker方法
              runWorker(this);
          }
  ​
          // Lock methods
          //
          // The value 0 represents the unlocked state.
          // The value 1 represents the locked state.
    //代表是否独占锁，0-非独占  1-独占
          protected boolean isHeldExclusively() {
              return getState() != 0;
          }

    //重写AQS的tryAcquire方法尝试获取锁
          protected boolean tryAcquire(int unused) {
           //尝试将AQS的同步状态从0改为1
              if (compareAndSetState(0, 1)) {
               //如果改变成，则将当前独占模式的线程设置为当前线程并返回true
                  setExclusiveOwnerThread(Thread.currentThread());
                  return true;
              }
              //否则返回false
              return false;
          }
  ​
    //重写AQS的tryRelease尝试释放锁
          protected boolean tryRelease(int unused) {
           //设置当前独占模式的线程为null
              setExclusiveOwnerThread(null);
              //设置AQS同步状态为0
              setState(0);
              //返回true
              return true;
          }
  ​
    //获取锁
          public void lock()        { acquire(1); }
          //尝试获取锁
          public boolean tryLock()  { return tryAcquire(1); }
          //释放锁
          public void unlock()      { release(1); }
          //是否被独占
          public boolean isLocked() { return isHeldExclusively(); }
  ​
          void interruptIfStarted() {
              Thread t;
              if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
                  try {
                      t.interrupt();
                  } catch (SecurityException ignore) {
                  }
              }
          }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;写这个线程池就真的是不容易了，历时两个星期，中途有很多的地方不懂，而且《Java并发编程的艺术》的这本书当中对线程池的介绍其实并不算多，所以自己看起来也挺痛苦的，还经常会看了这个方法就不知道为什么要调用这个以及调用这个方法是出何用意。而且在这学习的过程当中，有在怀疑自己的学习方法对不对，因为也有人跟我说不需要一句句去看去分析源码，只需要知道流程就可以了，但是后来还是想想按照自己的学习路线走，多读源码总是有好处的，在这里我也给程序猿一些建议，有自己的学习方法的时候，按照自己的方式坚定走下去。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;方腾飞：《Java并发编程的艺术》&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如需转载，请务必注明出处，毕竟一块块搬砖也不是容易的事情。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 05 Sep 2018 15:54:00 +0000</pubDate>
<dc:creator>KingJack</dc:creator>
<og:description>线程池学习 以下所有内容以及源码分析都是基于JDK1.8的，请知悉。 我写博客就真的比较没有顺序了，这可能跟我的学习方式有关，我自己也觉得这样挺不好的，但是没办法说服自己去改变，所以也只能这样想到什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KingJack/p/9595621.html</dc:identifier>
</item>
<item>
<title>Spring Boot（八）集成Spring Cache 和 Redis - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9595584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9595584.html</guid>
<description>&lt;p&gt;在Spring Boot中添加spring-boot-starter-data-redis依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties中指定redis服务器IP、端口和密码、连接数等：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Redis服务器地址
spring.redis.host=127.0.0.1
# Redis服务器连接端口 使用默认端口6379可以省略配置
#spring.redis.port=6379
# Redis服务器连接密码（默认为空）
#spring.redis.password=
&lt;/span&gt;&lt;span&gt;# 连接池最大连接数（如果配置&amp;lt;=0，则没有限制 ）
spring.redis.jedis.pool.max-active=8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用StringRedisTemplate 和RedisTemplate&lt;/h2&gt;
&lt;p&gt;StringRedisTemplate是Spring Boot内置的操作Redis的API实现类,另外还有一个API实现类是RedisTemplate。StringRedisTemplate的API假定所有的数据类型化都是字符类型，即key和value都是字符串类型，对于常见额SpringBoot应用系统，使用字符串操作也已经足够了，而且能方便的通过客户端管理工具管理。StringRedisTemplate继承RedisTemplate，与RedisTemplate不同的是重新设置了序列化策略，使用StringRedisSerialier类来序列化key-value，包括List、Hash、Set等数据结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@SpringBootTest
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootCacheApplicationTests {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     StringRedisTemplate stringRedisTemplate; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作 k-v 字符串&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 　　 RedisTemplate redisTemplate;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k- v 都是对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * redis 常见
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * String(字符串) List(列表) Set(集合) Hash(散列) ZSet(有序集合)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;@Test&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         stringRedisTemplate.opsForValue().append(&quot;StringKey&quot;, &quot;字符串数值&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         String value = stringRedisTemplate.opsForValue().get(&quot;StringKey&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        System.out.println(value);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 　　&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     Product product =  productMapper.getProductById(4L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     redisTemplate.opsForValue().set(&quot;produxtid4&quot;&lt;span&gt;,product);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spring-boot-autoconfigure-2.0.4.RELEASE.jar包中RedisAutoConfiguration.java已经自动声明了两个redis操作bean：&lt;/p&gt;
&lt;p&gt;RedisAutoConfiguration.java实现代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201809/577318-20180905232838852-318118348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们只要在使用的地方注入即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
StringRedisTemplate stringRedisTemplate; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作 k-v 字符串&lt;/span&gt;
&lt;span&gt;@Autowired
RedisTemplate redisTemplate;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k- v 都是对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StringRedisTemplate 提供opsForValue用来操作key-value，如上面的示例，另外还提供了一系列opsForHash()、opsForList()、opsForSet()、opsForZSet()等方法用来操作不同结构类型的数据。&lt;/p&gt;
&lt;p&gt;运行上面的测试方法，查看redis客户端：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201809/577318-20180905232937733-482565263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，出现了一些无法识别的字符，查看RedisTemplate源码可这个是由于默认使用了JDK的序列化机制，而StringRedisTemplate没有出乱码是因为它修改了序列化器&lt;/p&gt;
&lt;p&gt;StringRedisTemplate实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('82420d72-483f-4718-8555-1022adfb9a7e')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_82420d72-483f-4718-8555-1022adfb9a7e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82420d72-483f-4718-8555-1022adfb9a7e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('82420d72-483f-4718-8555-1022adfb9a7e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82420d72-483f-4718-8555-1022adfb9a7e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StringRedisTemplate &lt;span&gt;extends&lt;/span&gt; RedisTemplate&amp;lt;String, String&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    * Constructs a new &amp;lt;code&amp;gt;StringRedisTemplate&amp;lt;/code&amp;gt; instance. {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setConnectionFactory(RedisConnectionFactory)}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    * and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #afterPropertiesSet()} still need to be called.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringRedisTemplate() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       RedisSerializer&amp;lt;String&amp;gt; stringSerializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      setKeySerializer(stringSerializer);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      setValueSerializer(stringSerializer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      setHashKeySerializer(stringSerializer);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;      setHashValueSerializer(stringSerializer);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    * Constructs a new &amp;lt;code&amp;gt;StringRedisTemplate&amp;lt;/code&amp;gt; instance ready to be used.
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; connectionFactory connection factory for creating new connections
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringRedisTemplate(RedisConnectionFactory connectionFactory) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      setConnectionFactory(connectionFactory);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      afterPropertiesSet();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;    &lt;span&gt;protected&lt;/span&gt; RedisConnection preProcessConnection(RedisConnection connection, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; existingConnection) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultStringRedisConnection(connection);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;RedisTemplate实现，截取默认序列化器相关源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('75ea13ed-01d9-4059-9083-40c592e48588')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_75ea13ed-01d9-4059-9083-40c592e48588&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_75ea13ed-01d9-4059-9083-40c592e48588&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('75ea13ed-01d9-4059-9083-40c592e48588',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_75ea13ed-01d9-4059-9083-40c592e48588&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.afterPropertiesSet();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;boolean&lt;/span&gt; defaultUsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (defaultSerializer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认序列化器使用JdkSerializationRedisSerializer&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       defaultSerializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer(
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             classLoader != &lt;span&gt;null&lt;/span&gt; ? classLoader : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().getClassLoader());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enableDefaultSerializer) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (keySerializer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;          keySerializer =&lt;span&gt; defaultSerializer;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;          defaultUsed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (valueSerializer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;          valueSerializer =&lt;span&gt; defaultSerializer;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          defaultUsed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (hashKeySerializer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;          hashKeySerializer =&lt;span&gt; defaultSerializer;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;          defaultUsed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (hashValueSerializer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;          hashValueSerializer =&lt;span&gt; defaultSerializer;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;          defaultUsed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (enableDefaultSerializer &amp;amp;&amp;amp;&lt;span&gt; defaultUsed) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       Assert.notNull(defaultSerializer, &quot;default serializer null and not all serializers initialized&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (scriptExecutor == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.scriptExecutor = &lt;span&gt;new&lt;/span&gt; DefaultScriptExecutor&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;    initialized = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;既然RedisTemplate的默认序列化器不是很方便在redis管理工具中查看，我们可以自己定义一个RedisTemplate实例，修改默认的序列化器。&lt;/p&gt;
&lt;p&gt;实现方式如下，定义一个配置类，重新注入一个RedisTemplate操作bean:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRedisConfig {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 　　　@Bean(name = &quot;redisTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String,Object&amp;gt;&lt;span&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　　&lt;span&gt;//参照StringRedisTemplate内部实现指定序列化器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        redisTemplate.setConnectionFactory(redisConnectionFactory);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        redisTemplate.setKeySerializer(keySerializer());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        redisTemplate.setHashKeySerializer(keySerializer());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        redisTemplate.setValueSerializer(valueSerializer());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        redisTemplate.setHashValueSerializer(valueSerializer());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; RedisSerializer&amp;lt;String&amp;gt;&lt;span&gt; keySerializer() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Jackson序列化器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; RedisSerializer&amp;lt;Object&amp;gt;&lt;span&gt; valueSerializer() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重新运行上面的测试代码，可以发现redis客户端中已经可以正常的显示json格式数据了。&lt;/p&gt;
&lt;h2&gt;SpringBoot集成redis + spring cache&lt;/h2&gt;
&lt;p&gt;Spring Cache集成redis的运行原理：&lt;/p&gt;
&lt;p&gt;Spring缓存抽象模块通过CacheManager来创建、管理实际缓存组件，当SpringBoot应用程序引入spring-boot-starter-data-redi依赖后吗，容器中将注册的是CacheManager实例RedisCacheManager对象，RedisCacheManager来负责创建RedisCache作为缓存管理组件，由RedisCache操作redis服务器实现缓存数据操作。实际测试发现默认注入的RedisCacheManager操作缓存用的是RedisTemplate&amp;lt;Object, Object&amp;gt;，因此我们需要自定义cacheManager，替换掉默认的序列化器。&lt;/p&gt;
&lt;p&gt;实现代码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加mybatis和redis依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加mapper映射：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Mapper
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProductMapper {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     @Select(&quot;select * from tb_product where product_id=#{id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Product getProductById(Long id);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     @Update(&quot;update tb_product set product_name=#{productName},product_desc=#{productDesc} WHERE product_id=#{productId}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; updateProduct(Product product);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     @Delete(&quot;delete from tb_product where product_id=#{id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteProductById(Long id);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     @Select(&quot;select * from tb_product where product_name=#{productName}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    Product getProductByName(String productName);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Service:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.cache.service;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.cache.entity.Product;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.cache.mapper.ProductMapper;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheConfig;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheEvict;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachePut;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.Cacheable;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.Caching;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; @CacheConfig(cacheNames = &quot;product&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductService {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductMapper productMapper;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     @Cacheable(cacheNames = &quot;product1&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = {&quot;product1&quot;,&quot;product2&quot;})&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认key为参数，多个参数SimpleKey [arg1,arg2]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,keyGenerator = &quot;myKeyGenerator&quot;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;,condition=&quot;#a0&amp;gt;10&quot;,unless = &quot;#a0==11&quot;) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者condition=&quot;#id&amp;gt;10&quot;)&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProductById(Long id){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;        Product product =&lt;span&gt;productMapper.getProductById(id);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;       System.out.println(product);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     @CachePut(value=&quot;product&quot;,key = &quot;#result.productId&quot;,condition = &quot;#result!=null&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Product updateProduct(Product product){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; productMapper.updateProduct(product);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         System.out.println(&quot;影响行数：&quot;+&lt;span&gt;count);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(count&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CacheEvict(value=&quot;product&quot;,key=&quot;#id&quot;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CacheEvict(value=&quot;product&quot;,allEntries = true) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清楚所有缓存&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     @CacheEvict(value=&quot;product&quot;,allEntries = &lt;span&gt;true&lt;/span&gt;,beforeInvocation = &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清楚所有缓存&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; deleteProductById(Long id) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        productMapper.deleteProductById(id);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;含有CachePut注解，所以执行这个方法时一定会查询数据库，及时有cacheable注解&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    @Caching(
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             cacheable = {@Cacheable(value=&quot;product&quot;,key=&quot;#productName&quot;&lt;span&gt;)},
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             put =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     @CachePut(value=&quot;product&quot;,key=&quot;#result.productId&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     @CachePut(value=&quot;product&quot;,key=&quot;#result.productName&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Product getProductByName(String productName){
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;         Product product =&lt;span&gt;productMapper.getProductByName(productName);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.cache.controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.cache.entity.Product;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.cache.service.ProductService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductService productService;

    @GetMapping(&lt;/span&gt;&quot;/product/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Product getProduct(@PathVariable(&quot;id&quot;&lt;span&gt;) Long id) {

        Product product &lt;/span&gt;=&lt;span&gt; productService.getProductById(id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;prooduct?productid=1&amp;amp;productName= &amp;amp;&lt;/span&gt;
    @GetMapping(&quot;/product&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product updateProduct(Product product) {
        productService.updateProduct(product);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
    }

    @GetMapping(&lt;/span&gt;&quot;/delproduct&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String delProduct(@RequestParam(value=&quot;id&quot;&lt;span&gt;) Long id) {

        productService.deleteProductById(id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;ok&quot;&lt;span&gt;;
    }

    @GetMapping(&lt;/span&gt;&quot;/product/name/{productName}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Product getEmpByLastName(@PathVariable(&quot;productName&quot;&lt;span&gt;) String productName){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; productService.getProductByName(productName);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义cacheManager实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.cache.config;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.cache.entity.Product;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.CacheManager;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.config.CacheManagementConfigUtils;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Primary;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheConfiguration;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheManager;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheWriter;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnectionFactory;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.RedisTemplate;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.RedisSerializationContext;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.RedisSerializer;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.serializer.StringRedisSerializer;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.UnknownHostException;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.time.Duration;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRedisConfig {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     @Bean(name = &quot;redisTemplate&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String,Object&amp;gt;&lt;span&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        redisTemplate.setConnectionFactory(redisConnectionFactory);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        redisTemplate.setKeySerializer(keySerializer());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        redisTemplate.setHashKeySerializer(keySerializer());
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        redisTemplate.setValueSerializer(valueSerializer());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        redisTemplate.setHashValueSerializer(valueSerializer());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    @Primary
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存配置对象&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         RedisCacheConfiguration redisCacheConfiguration =&lt;span&gt; RedisCacheConfiguration.defaultCacheConfig();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         redisCacheConfiguration = redisCacheConfiguration.entryTtl(Duration.ofMinutes(30L)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置缓存的默认超时时间：30分钟&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                 .disableCachingNullValues()             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是空值，不缓存&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置key序列化器&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                 .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer((valueSerializer())));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置value序列化器&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; RedisCacheManager
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                .builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory))
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                .cacheDefaults(redisCacheConfiguration).build();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; RedisSerializer&amp;lt;String&amp;gt;&lt;span&gt; keySerializer() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; RedisSerializer&amp;lt;Object&amp;gt;&lt;span&gt; valueSerializer() {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启用缓存，添加mybatis Mapper映射扫描：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @MapperScan(&quot;com.sl.cache.mapper&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@EnableCaching
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootCacheApplication {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         SpringApplication.run(SpringbootCacheApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 05 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<og:description>在Spring Boot中添加spring-boot-starter-data-redis依赖： 在application.properties中指定redis服务器IP、端口和密码、连接数等： 使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9595584.html</dc:identifier>
</item>
<item>
<title>一文带你读懂深度学习之Deepmind WaveNet模型和Keras实现 - SeanLiao</title>
<link>http://www.cnblogs.com/seanliao/p/9595536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seanliao/p/9595536.html</guid>
<description>&lt;p&gt;本文主要通俗讲述WaveNet的基本模型和Keras代码理解，以帮助和我一样刚刚入坑并难以理解其代码的小白。&lt;/p&gt;
&lt;p&gt;作者：SeanLiao&lt;/p&gt;
&lt;p&gt;Blog：https://www.cnblogs.com/seanliao/&lt;/p&gt;
&lt;p&gt;原创博文，转载请注明来源。&lt;/p&gt;
&lt;h2&gt;一. 什么是WaveNet?&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;简单来说，WaveNet是一种生成模型，类似VAE、GAN等，WaveNet最大的特点是可以直接生成raw audio的模型，由2017年DeepMind提出，在TTS(文字转语音)任务上可以达到state-of-art的效果。&lt;/p&gt;
&lt;p&gt;此外WaveNet也可以用来做生成文字、生成图片、语音识别等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274464/201809/1274464-20180905222748779-2143685375.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WaveNet的具体相关可以参考以下资料：&lt;/p&gt;
&lt;p&gt;Ref :&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://deepmind.com/blog/wavenet-generative-model-raw-audio/&quot; target=&quot;_blank&quot;&gt;DeepMind WaveNet Blog &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/basveeling/wavenet&quot; target=&quot;_blank&quot;&gt;Keras实现代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1609.03499.pdf&quot; target=&quot;_blank&quot;&gt;WaveNet论文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;窃以为，学习一种网络结构应该结合论文和代码，而理解模型的基础首先是知道模型的输入输出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DeepMind博客上的动图非常清楚地展示了这个模型的工作过程。一定要看！体会！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WaveNet的网络结构并不复杂，说白了其实就是一类变种CNN。但是介绍WaveNet的各种文章只对WaveNet的结构夸夸其谈，丝毫没有涉及模型的输入输出到底是什么，对小白非常不友好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文着重介绍WaveNet keras实现代码中的输入数据组织。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;二. 模型的运作过程&lt;/h2&gt;
&lt;p&gt;　　这里不谈模型的原理和结构（实际上只要理解了CNN，理解WaveNet非常容易）。我们先谈谈WaveNet到底“做了什么”？&lt;/p&gt;
&lt;p&gt;　　由于我不知道怎么上传动图，大家可以到DeepMind博客上查看那张动图。再结合下图论文的原文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274464/201809/1274464-20180905224211591-170671344.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　简单来说，模型的核心是 &lt;strong&gt;对给定的输入序列(x_1, x_2, x_3, x_4, ..., x_n) ， 每次要根据之前的x_1 ~ x_n来预测x_n+1。然后将x_n+1添加在输入序列，再由x_2 ~ x_n+1得到 x_n+1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　由此 我们就可以由一个原始的序列(x_1, x_2, x_3, x_4, ..., x_n) 作为输入，按此模型进行构建，&lt;strong&gt;可以生成任意长度的序列！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　那么疑问来了，代码怎么实现呢？&lt;/strong&gt;博主实在讨厌冗长的Tensorflow代码，于是在github上找到了这个比较多Star的Keras版本代码，clone下来并成功运行后开始分析。&lt;strong/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三. Keras代码中数据的组织&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;本文开头引用给出的Keras代码写得非常好，尤其是自定义层部分。由于封装得比较高级，对小白而言看懂还是有点困难的。下面我就拿其代码来进行简单的分析。&lt;/p&gt;
&lt;p&gt;　　首先我们要注意到论文中的这部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274464/201809/1274464-20180905225833430-2002805708.png&quot; alt=&quot;&quot; width=&quot;773&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样的话，代码就应该很明白了。 还是不懂？ 没关系，下面举个简单的例子。&lt;/p&gt;
&lt;p&gt;　　对于一个序列 “我是超级大帅哥”。 假如取长度为2 步长为1 作为数据进行输入和训练。&lt;/p&gt;
&lt;p&gt;　　则训练时第一次输入模型的数据：x1 = 我是 ， 输出y1 = 是超&lt;/p&gt;
&lt;p&gt;　　第二次：x2 =  是超， y2 = 超级；&lt;/p&gt;
&lt;p&gt;　　第三次： x3 = 超级， y3 = 级大&lt;/p&gt;
&lt;p&gt;　　……&lt;/p&gt;
&lt;p&gt;　　而当训练完毕，使用训练好的模型生成数据时，送入x1 = 我是，理想情况是得到y1 = 是超&lt;/p&gt;
&lt;p&gt;　　只要不断的将输出送到输入再进行预测，就有可能得到一个完整的序列“我是超级大帅哥”！&lt;/p&gt;
&lt;p&gt;　　（别跟我你到这里还搞不懂模型的输入输出是什么......）&lt;/p&gt;
&lt;p&gt;　　那么对于图片和文字的情况呢？这里不做讲解（因为我也还没去看啊喂...），大家可以看看论文原文和github上的tensorflow代码。&lt;/p&gt;
&lt;p&gt;　　如果到这部分都看懂了，好的，其实代码实现也很容易理解，读者请先简单地阅读一遍所有代码，下面对输入输出数据的组织做简单的分析总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型的输入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一段长度为&lt;/span&gt;fragment_length&lt;span&gt;的音频数据&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;设为&lt;/span&gt;&lt;span&gt;audio[begin : begin + fragment_length]&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;模型的输出&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;相邻于输入数据的下一段&lt;/span&gt;fragment_length&lt;span&gt;长的音频序列。步长为&lt;/span&gt;&lt;span&gt;fragment_stride&lt;/span&gt;&lt;span&gt;，输出为&lt;/span&gt;&lt;span&gt;audio[ begin + fragment_stride : begin + fragment_stride + fragment_length ]&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;输入数据的处理&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;1. 对单个音频的处理有：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) &lt;span&gt;读取音频。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b) &lt;span&gt;声道处理&lt;/span&gt;(&lt;span&gt;原代码为单声道音频&lt;/span&gt;&lt;span&gt;)。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) &lt;span&gt;转化为浮点数（这里应该是进行了一个缩放到&lt;/span&gt;0~1&lt;span&gt;之间），&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; wav_to_float(x):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         max_value =&lt;span&gt; np.iinfo(x.dtype).max
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         min_value =&lt;span&gt; np.iinfo(x.dtype).min
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         max_value =&lt;span&gt; np.finfo(x.dtype).max
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         min_value =&lt;span&gt; np.iinfo(x.dtype).min
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     x = x.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, casting=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;safe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     x -=&lt;span&gt; min_value
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     x /= ((max_value - min_value) / 2&lt;span&gt;.)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     x -= 1&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;d) &lt;span&gt;转化为&lt;/span&gt;ulaw&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;编码&lt;/strong&gt;，使用&lt;/span&gt;&lt;span&gt;ulaw&lt;/span&gt;&lt;span&gt;编码的原因是原始音频数据是&lt;/span&gt;&lt;span&gt;16bit&lt;/span&gt;&lt;span&gt;的，则生成的时候一个帧音频有&lt;/span&gt;&lt;span&gt;2^16&lt;/span&gt;&lt;span&gt;个输出值（输出节点数），再进行&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;取值，这样的话代价高昂而且数据点取值范围太大会影响准确率。所以对原始的音频数据进行了&lt;/span&gt;&lt;span&gt;ulaw&lt;/span&gt;&lt;span&gt;编码（可参考：&lt;/span&gt;&lt;a href=&quot;https://blog.csdn.net/wzying25/article/details/79398055)&quot;&gt;&lt;span&gt;https://blog.csdn.net/wzying25/article/details/79398055&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;e) resample&lt;span&gt;到目标采样率。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;f) &lt;span&gt;转化为&lt;/span&gt;uint8&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;数据, &lt;/strong&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; float_to_uint8(x):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     x += 1&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     x /= 2&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     uint8_max_value = np.iinfo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uint8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).max
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     x *=&lt;span&gt; uint8_max_value
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     x = x.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uint8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;单个音频处理的完整代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_wav(desired_sample_rate, filename, use_ulaw):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('reading wavfile...',filename)&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    with warnings.catch_warnings():
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; warnings.simplefilter(&quot;error&quot;)  # 提升警告等级？会导致np.fromstring报错&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         channels =&lt;span&gt; scipy.io.wavfile.read(filename)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     file_sample_rate, audio =&lt;span&gt; channels
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     audio =&lt;span&gt; ensure_mono(audio)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     audio =&lt;span&gt; wav_to_float(audio)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; use_ulaw:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         audio =&lt;span&gt; ulaw(audio)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     audio =&lt;span&gt; ensure_sample_rate(desired_sample_rate, file_sample_rate, audio)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     audio =&lt;span&gt; float_to_uint8(audio)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; audio
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 2. &lt;strong&gt;组织成模型的输入数据&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a) &lt;span&gt;将同一个说话人的音频经过&lt;/span&gt;1&lt;span&gt;中的处理后进行拼接，形成一个&lt;/span&gt;&lt;span&gt;full_sequences。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b) &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;划分测试集&lt;/strong&gt;，代码中将&lt;/span&gt;full_sequences&lt;span&gt;按&lt;/span&gt;&lt;span&gt;9 : 1&lt;/span&gt;&lt;span&gt;进行切分，后&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;部分加入测试集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) &lt;span&gt;对&lt;/span&gt;full_sequences&lt;span&gt;，以&lt;/span&gt;&lt;span&gt;fragment_stride&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;进行分割&lt;/strong&gt;，长度为&lt;/span&gt;&lt;span&gt;fragment_length&lt;/span&gt;&lt;span&gt;（这里只记录序列开始的坐标。得到若干个音频子序列。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fragment_indices(full_sequences, fragment_length, batch_size, fragment_stride, nb_output_bins):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; seq_i, sequence &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(full_sequences):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, sequence.shape[0] -&lt;span&gt; fragment_length, fragment_stride):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; seq_i, i
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; i为input sequence的起点 seq_i为音频文件的id&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;d) &lt;span&gt;生成&lt;/span&gt;batch&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;。&lt;/strong&gt;由&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;得到一个&lt;/span&gt;&lt;span&gt;full_sequence&lt;/span&gt;&lt;span&gt;的全部子序列列表。然后按&lt;/span&gt;&lt;span&gt;batch_size&lt;/span&gt;&lt;span&gt;进行划分。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
batches = cycle(partition_all(batch_size, indices)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; indices为列表&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; batch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; batches:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(batch) &amp;lt;&lt;span&gt; batch_size:
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; np.array(
        [one_hot(full_sequences[e[0]][e[&lt;/span&gt;1]:e[1] + fragment_length]) &lt;span&gt;for&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt; batch], dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uint8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), np.array(
        [one_hot(full_sequences[e[0]][e[&lt;/span&gt;1] + 1:e[1] + fragment_length + 1]) &lt;span&gt;for&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt; batch], dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uint8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;e) &lt;span&gt;此时数据点的取值为&lt;/span&gt;0~255&lt;span&gt;，转换为&lt;/span&gt;&lt;span&gt;onehot&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;编码&lt;/strong&gt;，则输入数据变成了一个二维张量，此时喂入模型即可。相邻的两个子序列前者为输入，后者为输出。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;model的定义和原理待续。&lt;/p&gt;
&lt;p&gt;还有一个简单的实现Keras WaveNet Demo正在赶工……完成后会附上&lt;/p&gt;
&lt;p&gt;实际上，用代码实现模型最头疼的部分就是输入数据的组织，本文以上已经介绍完毕。对于Keras而言已经把网络结构搭建简化得非常容易了。只要理解了模型的原理，实现起来就很容易了。&lt;/p&gt;

</description>
<pubDate>Wed, 05 Sep 2018 15:24:00 +0000</pubDate>
<dc:creator>SeanLiao</dc:creator>
<og:description>本文主要通俗讲述WaveNet的基本模型和Keras代码理解，以帮助和我一样刚刚入坑并难以理解其代码的小白。 作者：SeanLiao Blog：https://www.cnblogs.com/sean</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/seanliao/p/9595536.html</dc:identifier>
</item>
<item>
<title>第一篇：docker 简单入门（一） - 思维空间</title>
<link>http://www.cnblogs.com/fourspace/p/9595514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fourspace/p/9595514.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本篇目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;写在最前面的话&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;docker概念介绍&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;镜像的概念、容器的概念&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;docker的安装介绍&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在最前面的话&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大家好，首先跟大家说声对不起，我班门弄斧了，我本身是做系统开发,使用的语言是C#和JAVA这两类，再多了的编程语言真的是没有精力去学习。docker这门应用技能断断续续的学习着，不精通。是能说我熟悉它，我能使用它。我能简单理解它。所有接下来如果有哪里有写错的地方，大家可以留言给我，如果我看到了，会验证且更正的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我粗略拟定了一个学习总纲，最终的目标是学习大数据研发，分布式架构这类。我不知道我学习的方向是否正确，接下来的课程整理，我会往这边靠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后感谢大家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;docker 概念介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我个人理解的docker技术，就是一个运行的容器，怎么理解？所谓运行的容器，就是系统或者程序所需要的一切必要条件，比如当你运行jar或者war的时候，一句“Hello World”，我们需要什么？需要的是jvm，是jre，那这个时候我们只要jvm，jre足够的内存、cpu、网卡等等，我们的代码就可以在任何地方跑起来。这个时候，有人可能会问，它和虚拟机有什么区别？确实很多人都会拿着虚拟机和docker做对比，那么虚拟机需要的是一个OS(操作系统)，在虚拟出来的操作系统上，我们可以做任何事情。但是大家注意了，如果我只是想要运行一段程序，就安装一个虚拟机，是不是很浪费，而且虚拟机也是很耗物理机器的资源。&lt;/p&gt;
&lt;p&gt;　　所以，虚拟机它是这样子的【OS】-&amp;gt;【Hyper】-&amp;gt;【Guest OS】-&amp;gt;【bin/libs】-&amp;gt;【apps】。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　而，docker它是这样的【OS】-&amp;gt;【docker engine】-&amp;gt;【bin/libs】-&amp;gt;【apps】。&lt;/p&gt;
&lt;p&gt;　　所以通过对比，大家可以清晰的看到两者的区别docker engine 可以与系统隔离同时保持通信。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;镜像的概念、容器的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过上面对docker概念的介绍，我们了解到，docker的守护进程可以很好的将容器内部运行和容器外部执行进行隔离，互不干扰。那么我们怎么写出第一句Hello World呢？我们需要了解两个概念，镜像（image)、容器(container).&lt;/p&gt;
&lt;p&gt;　　我理解下来，容器=镜像+可读写区。什么意思？说白了一点就是，容器就是镜像的运行场所，这个场所为容器提供所必须的可读写区域。就好比，小婴儿在妈妈肚子里面，婴儿好比image，而妈妈的肚子就是container，为小婴儿提供活动的空间和所需的养分。&lt;/p&gt;
&lt;p&gt;　　所以，&lt;span&gt;镜像只是一些只读的文件，而容器就是只读文件+可读写区域&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;docker的安装介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　简单说说，不如实际做做。在做的过程中就可以深刻体会了，凡事都有个过程，不要理会概念和原理，我们可以先模仿，先使用，再反过来看原理。就算理解错了也没关系，因为如果一开始你就懂原理，那docker就是你创造出来的了。哈哈，所以边学边调整原理的认识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么，在开始之前我们来确认下环境，这个非常重要，很重要。首先第一，不要用mac系统，不要用mac系统，不要用mac系统，重要的事情说三遍，因为&lt;span&gt;mac它不是liunx内核&lt;span&gt;。mac的很多命令都是封装的，你无法知道内部的一些信息。它会给你一些莫名其妙的错误提示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　其次，不推荐使用Windows，至于为什么，我也不清楚，只是我在windows下使用docker，会很不习惯。很变扭很鸡肋，感兴趣的可以尝试一下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　最后，推荐Ubuntu或则CentOS，很好用。我使用的是Ubuntu，虽然我没有全部掌握它的命令和参数，但是我使用下来，还是觉得很方便。很好用，有的时候可能比windows还会好点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　当然以上都是我个人的观点，大家可以根据喜好选择系统环境，以后不做说明，文章内出现的系统都为ubuntu.那怎么安装操作系统环境我这里就不讲了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　进入到系统中，在桌面上，右击，选择【打开终端】&lt;/p&gt;
&lt;p&gt;　　查看docker版本&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/349671/201809/349671-20180905225048136-2071815200.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，如果你没有安装docker，就不会出现版本号信息，&lt;/p&gt;
&lt;p&gt;　　在安装之前，我需要需要做一件事情，由于政治、历史原因，砸门国家有个墙非常厉害，长城防火墙对吧，所以在获取docker的时候，我们需要设置下镜像加速。&lt;/p&gt;
&lt;p&gt;　　在命令中输入【sudo vim /etc/docker/daemon.json】，如果提示&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/349671/201809/349671-20180905230204207-181325354.png&quot; alt=&quot;&quot; width=&quot;485&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不要害怕，运行【sudo apt install vim】我们来安装下这个vim命令就可以了。&lt;/p&gt;
&lt;p&gt;　　接上文，在运行完【sudo vim /etc/docker/daemon.json】之后，打开编辑&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/349671/201809/349671-20180905230439144-2008109078.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;58&quot;/&gt;我们用网易的镜像加速，保存好，我们就可以快乐的准备安装docker了。&lt;/p&gt;
&lt;p&gt;　　使用【sudo &lt;span class=&quot;pln&quot;&gt;wget &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;qO&lt;span class=&quot;pun&quot;&gt;- &lt;span class=&quot;pln&quot;&gt;https&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;com&quot;&gt;//get.docker.com/ | sh】静静等待就行，提示安装成功之后【sudo service docker start】启动一下服务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;com&quot;&gt;　　最后，我们再使用上面的查看docker版本的方法查看下docker版本。就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;com&quot;&gt;　　docker的安装有很多方式，不是很难。大家可能会对命令有点陌生，还是那句话，坚持和习惯。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上是我简单的总结，适合快速入门或者想了解下docker的朋友，希望你们能够喜欢。&lt;/p&gt;
&lt;p&gt;以后会不定期更新此类文章，如果转载，请注明出处。&lt;/p&gt;
&lt;p&gt;邮箱:　　wuyun151@163.com　　wuyunlong.著&lt;/p&gt;
&lt;p class=&quot;prettyprint prettyprinted&quot;&gt; &lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 15:18:00 +0000</pubDate>
<dc:creator>思维空间</dc:creator>
<og:description>工作这么多年，从来没有认真整理过自己的知识。这么多年来，很多时候都忙于生活，包括现在也是一样。 所谓技术牛人，只是你比别人先了解，并且你比别人了解的更为深入，仅此而已。所以当我看到很多拽的不行，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fourspace/p/9595514.html</dc:identifier>
</item>
<item>
<title>图的表示、深度广度遍历算法及其应用 - 蒙面的普罗米修斯</title>
<link>http://www.cnblogs.com/datasnail/p/9595517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datasnail/p/9595517.html</guid>
<description>&lt;p&gt;世间的一切对象都可化为节点；世间一切关系都可化为节点间的一条线；从而组成了如梦幻泡影的图。将来的环球必定是图的世界。&lt;/p&gt;
&lt;h3 id=&quot;一图的表示&quot;&gt;一、图的表示&lt;/h3&gt;
&lt;p&gt;图有有向图和无向图，表示方法一般有邻接表、邻接矩阵等方法，无向图和有向图都可以用这两种方法表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.datasnail.cn/postimg/algorithm_graph/graphs.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1. 图的例子&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;
&lt;h4 id=&quot;邻接表&quot;&gt;1、邻接表&lt;/h4&gt;
&lt;p&gt;在邻接表中，对于每个顶点u，使用一个链表把所有与u相邻的点点串起来，并标记这个集合为adj(u)。举个栗子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.datasnail.cn/postimg/algorithm_graph/adj.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2. 邻接表表示图的例子&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;在真正操作图进行实验的时候，一般也都使用邻接矩阵表示，例如要存储图1中的有向图，可以直接用一个csv或者txt文件，存储内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5,14
1,3,2,5,4
2,3,1,5,3
3,2,2,4
4,3,1,5,3
5,3,4,1,2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述文件就是第一行存储了总共的节点数量、边的数量；接下来的每一行就是此顶点的id和邻居的id，并且第2位数字存储了该节点总共有多少邻居节点；为了进一步的操作简单，可以把原有的节点id映射为从0到n，没有边的节点用0补充，此时行号和id相等了，访问起来更加迅速。这样存储的好处是需要较少的内存就可以完成，而且操作简单。&lt;/p&gt;
&lt;h4 id=&quot;邻接矩阵&quot;&gt;2、邻接矩阵&lt;/h4&gt;
&lt;p&gt;邻接矩阵顾名思义就是用一个n*n的矩阵，存储各节点之间的关系，空间复杂度$O(n^2)$，这样存储在一些矩阵运算的时候较为方便，例如转置。图1中两图的邻接矩阵如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.datasnail.cn/postimg/algorithm_graph/matrix.png&quot;/&gt;&lt;br/&gt;图3. 邻接矩阵表示图的例子&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;
&lt;h3 id=&quot;二图周游算法&quot;&gt;二、图周游算法&lt;/h3&gt;
&lt;h4 id=&quot;广度优先遍历&quot;&gt;1、广度优先遍历&lt;/h4&gt;
&lt;p&gt;图的广度遍历顾名思义就是访问图中节点的时候，优先在广度上进行遍历；也就是访问到某节点A时，优先访问完A的所有邻居节点&lt;strong&gt;[节点的访问顺序并没有做要求，在具体的问题中此处可以定义访问顺序]&lt;/strong&gt;，再继续访问邻居的邻居，直接看代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#过程中主要是做三件事：颜色、距离、父节点
BFS(G(V,E),s)
    #初始化
    for each vertex u in V-{s}
        color[u] &amp;lt;- White
        d[u]&amp;lt;-∞
        pai[u]&amp;lt;-None
    endfor
    #处理开始节点
    color[s]&amp;lt;-Gray
    d[s]&amp;lt;-0
    pai[s]&amp;lt;-None
    
    #初始化队列
    Q&amp;lt;-Queue()
    Enqueue(Q,s)
    
    #开始广度访问图
    while not Q.empyt():
        u&amp;lt;-Dequeue(Q)
        for each v in Adj[u]:
            if color[v] = White #检查颜色是否为白色，即没有被访问过
                color[v] &amp;lt;- Gray #颜色，变颜色为灰色
                d[v]&amp;lt;-d[u]+1 #距离
                pai[v]&amp;lt;-u  #父节点
            endif
        endfor
    color[u]&amp;lt;-Black
    endwhile
    End    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;&lt;br/&gt;无向图二着色问题，无奇回路&amp;lt;=&amp;gt;可以二着色&amp;lt;=&amp;gt;可以分为二部图&lt;/p&gt;
&lt;h4 id=&quot;深度优先遍历&quot;&gt;2、深度优先遍历&lt;/h4&gt;
&lt;p&gt;深度优先搜索是从某一顶点开始访问，然后访问他的邻居，与BFS不同的是，当深度优先搜索从某个顶点u访问他的邻居时，只选择其中的一个还未被访问的邻居v，然后暂时弃u的其他邻居于不顾，而从新的儿子节点v去访问v的邻居。当v出发的访问全部完成后，DFS回到u，然后再访问u的第二个邻居，以此类推。这里有个动画就好了，可是我不会画。&lt;br/&gt;深度优先遍历，迭代方法的伪代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;DFS(G(V,E))
    #初始化访问控制的颜色，父节点
    for each vetex u in V
        color[u] = White
        pai[u]=None
    endfor

    #最开始，时间为0
    time &amp;lt;- 0
    
    #对于每个节点进行一次深度优先遍历，防止图节点间不连通
    for each vetex u in V:
        if color[u]=While:
            then DFS-visit(u)
        endif
    endfor
    End
#对节点s，进行深度优先遍历
DFS-Visit(s):

    color[s] &amp;lt;- Gray
    time = time + 1
    d[s]&amp;lt;-time
    #如果访问到节点s的邻居节点，那么对其邻居节点迭代进行深度优先遍历
    for each v in Adj[s]:
        if color[v] = White
            pai[v]&amp;lt;-s
            DFS-Visit(v)
        endif
    endfor
    color[s]&amp;lt;-Black
    f[s]&amp;lt;-time&amp;lt;-time+1
    End&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;区间套定理&quot;&gt;&lt;strong&gt;2.1 区间套定理：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;白路径定理&quot;&gt;&lt;strong&gt;2.2 白路径定理：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;拓扑排序&quot;&gt;&lt;strong&gt;2.3 拓扑排序：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;无回路有向图中最长路径问题&quot;&gt;&lt;strong&gt;2.4 无回路有向图中最长路径问题：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一些应用问题需要找到图中的最短或者最长的&lt;strong&gt;简单路径&lt;/strong&gt;(不含回路的路径），图往往是加权的。但是&lt;span&gt;&lt;strong&gt;对于任意图，找一条最长路径是NPC问题，即使这个图是不加权的图&lt;/strong&gt;&lt;/span&gt;。然而只有这个图是无回路的图时，不论是有向图还是无向图，加权还是不加权图，都可以在线性时间$O(|V|+|E|)=O(n+m)$。细心的我可能发现了，&lt;strong&gt;无回路的图就是棵树或者森林啊&lt;/strong&gt;，两个顶点之间要么不连通，要不然就只有唯一的一条路径。&lt;/p&gt;
&lt;h4 id=&quot;强连通分支&quot;&gt;&lt;strong&gt;&lt;span id=&quot;stronglyconnectedcomponent&quot;&gt;2.5 强连通分支：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;定义1： 如果一个有向图中任意一顶点都有一条通向其他任一顶点的路径，那么这个&lt;span&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/span&gt;称为&lt;strong&gt;强连通图&lt;/strong&gt;（strongly connected graph）&lt;br/&gt;定义2： &lt;span&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/span&gt;G，其&lt;strong&gt;隐含的无向图&lt;/strong&gt;$G'$是指把G中的每条边的方向都去掉后所得到的无向图。&lt;br/&gt;定义3： 如果一个&lt;span&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/span&gt;G所隐含的无向图$G'$是个连通图，那么有向图G称为&lt;strong&gt;弱连通图&lt;/strong&gt;（weakly connected graph）&lt;br/&gt;定义4： 如果一个&lt;span&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/span&gt;的子图是个强连通图，则成为&lt;strong&gt;强连通子图&lt;/strong&gt;（strongly connected subgraph）&lt;br/&gt;定义5： 如果一个&lt;span&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/span&gt;的强连通子图已最大，即不能在加入其他任何一个顶点而仍然强连通，那么这个子图称为&lt;strong&gt;强连通分支&lt;/strong&gt;（strongly connected component）&lt;br/&gt;&lt;strong&gt;这里强连通分支包含于强连通子图内。&lt;/strong&gt;&lt;br/&gt;定义6： &lt;strong&gt;有向图的强连通分支问题&lt;/strong&gt;就是把一个有向图的顶点划分为不相交的若干个强连通分支。&lt;/p&gt;
&lt;h3 id=&quot;三参考文献&quot;&gt;三、参考文献&lt;/h3&gt;
&lt;p&gt;[1] 沈孝钧. 计算机算法基础 : Essentials of computer algorithms[M]. 机械工业出版社, 2014.&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 15:18:00 +0000</pubDate>
<dc:creator>蒙面的普罗米修斯</dc:creator>
<og:description>世间的一切对象都可化为节点；世间一切关系都可化为节点间的一条线；从而组成了如梦幻泡影的图。将来的环球必定是图的世界。 一、图的表示 图有有向图和无向图，表示方法一般有邻接表、邻接矩阵等方法，无向图和有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/datasnail/p/9595517.html</dc:identifier>
</item>
</channel>
</rss>