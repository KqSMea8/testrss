<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>创建 Rex-Ray volume - 每天5分钟玩转 Docker 容器技术（76） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/7624556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/7624556.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面我们安装部署了 Rex-Ray，并且成功配置 VirtualBox backend，今天演示如何创建和使用 Rex-Ray volume。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 docker1 或 docker2 上执行如下命令创建 volume：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;docker volume create --driver rexray --name=mysqldata --opt=size=2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036469334041299.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036843090029709.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;volume&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;span&gt;创建成功，大小为 2GB。在 VirtualBox 宿主机中也能看到&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036463011008098.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036843608084568.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 VirtualBox 使用的是 thin-provisioning，volume 初始分配的空间很小。&lt;/p&gt;
&lt;p&gt;接下来我们将：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 dokcer1 上启动 MySQL 容器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mydb_on_docker1&lt;/span&gt;&lt;/code&gt;，并使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;作为数据卷。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新数据库，然后销毁&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mydb_on_docker1&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在 dokcer2 上启动 MySQL 容器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mydb_on_docker2&lt;/span&gt;&lt;/code&gt;，也使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;作为数据卷，然后验证数据的有效性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;创建容器并使用数据卷&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在 dokcer1 上执行如下命令，启动 MySQL 容器：&lt;br/&gt;&lt;span&gt;docker run --name mydb_on_docker1 -v mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=passw0rd -d mysql&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;-v mysqldata:/var/lib/mysql&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;将之前创建的 volume mount 到 MySQL 的数据目录。&lt;/p&gt;
&lt;p&gt;我们接下来从更底层分析一下这个 mount 是如何实现的。&lt;/p&gt;
&lt;p&gt;首先在 VirtualBox 中查看虚拟机 docker1 的 storage 配置：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036454345044417.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036843789002920.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Rex-Ray volume&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;已经挂载到 docker1。&lt;/p&gt;
&lt;p&gt;执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker volume inspect mysqldata&lt;/span&gt;&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036459685030149.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036844079040077.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;已被 mount 到 docker1 目录&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/lib/libstorage/volumes/mysqldata/data&lt;/span&gt;&lt;/code&gt;，执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker inspect mydb_on_docker1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;查看容器的 volume 信息：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036459950004523.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036844340022346.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;/var/lib/libstorage/volumes/mysqldata/data&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;被 mount 到了容器的目录&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/lib/mysql&lt;/span&gt;&lt;/code&gt;，这样 Rex-Ray volume&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysqldata&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;就已经 mount 到了容器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mydb_on_docker1&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036466697049603.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036844704038586.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;&lt;strong&gt;更新数据库&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;按照如下步骤更新 MySQL 数据：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036469670005578.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036845032097540.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 进入容器&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mydb_on_docker1&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;② 登录数据库，输入容器启动时由环境变量&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;指定的密码。&lt;/p&gt;
&lt;p&gt;③ 切换到数据库&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;④ 创建数据库表&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;my_id&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;⑤ 插入一条数据。&lt;/p&gt;
&lt;p&gt;⑥ 确认数据已经写入。&lt;/p&gt;
&lt;p&gt;执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;docker rm -f mydb_on_docker1&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;删除容器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在容器已经被销毁了，下一节我们将在 docker2 上创建新容器并重新使用 volume &lt;span&gt;mysqldata&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20170926-1506393629819061392.png&quot; src=&quot;http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20171003-1507036845472040533.jpg&quot; alt=&quot;二维码+指纹.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 23:54:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/7624556.html</dc:identifier>
</item>
<item>
<title>Springboot 学习笔记 ① - ~阿坨坨</title>
<link>http://www.cnblogs.com/atuotuo/p/7624818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atuotuo/p/7624818.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前一直在寻找Springboot的学习资料，终于得偿所愿。。。那么，先给自己定一个小目标 - 能够使用Springboot这套架构来搭建自己的服务。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1. 开发环境&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;开发环境其实还是因人而异的（官方的说法是Java7以上，推荐Java8；貌似也可以用Java6）。lz这里的平台为Windows，Jdk版本为1.8，maven版本为3.39。具体信息可以看下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003224936286-1590691388.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;2. 为maven配置aliyun镜像仓库&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于众所周知的原因，我们访问maven官方的网站的时候，速度没有辣么“给力”，所以通过aliyun的镜像仓库来“加速”。具体的配置方法也很简单，就是在&quot;.m2&quot;目录下的“setting.xml”文件中加入如下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nexus-aliyun&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Nexus aliyun&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   &lt;br/&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3. IDE&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我这里使用的是STS，版本为： 3.8.4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003230018193-1123399368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;好了，前面啰嗦了一大堆，终于进入正题啦。。。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 1. 新建一个spring start project &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003230330927-709376191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 2. 选择建立一个Web项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003230729583-1733207390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择完成后，点击“finish”按钮，之后STS就会开始下载项目依赖的项目；待所有东西就绪之后，我们可以看到项目的结构如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003231108083-201249527.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3. 编写controller类，处理Http request&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.HelloSpringBoot.Controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloSpringBootController {

    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello spring boot!&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;@RestController - 该注解表示类 “&lt;/span&gt;HelloSpringBootController”是一个web controller，它用来处理web request
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;@RequestMapping(&quot;/hello&quot;&lt;span&gt;) - 该注解表明请求的相对路径为 “/hello”&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们的编码工作已经完成。&lt;/p&gt;

&lt;h2&gt;4. 启动Springboot项目&lt;/h2&gt;
&lt;p&gt;选中默认生成的文件“HelloSpringBootApplication.java” -&amp;gt; 右键 -&amp;gt; &quot;run as spring boot app&quot;&lt;/p&gt;
&lt;p&gt;启动后，我们会在console里面看到如下输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.5.7.RELEASE)

2017-10-03 23:28:58.291  INFO 9436 --- [           main] c.e.H.HelloSpringBootApplication         : Starting HelloSpringBootApplication on Tuo-PC with PID 9436 (E:\sts-bundle\sts-3.8.4.RELEASE\workspace_springboot\HelloSpringBoot\target\classes started by Tuo in E:\sts-bundle\sts-3.8.4.RELEASE\workspace_springboot\HelloSpringBoot)
2017-10-03 23:28:58.298  INFO 9436 --- [           main] c.e.H.HelloSpringBootApplication         : No active profile set, falling back to default profiles: default
2017-10-03 23:28:58.483  INFO 9436 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@351d0846: startup date [Tue Oct 03 23:28:58 CST 2017]; root of context hierarchy
2017-10-03 23:29:01.261  INFO 9436 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2017-10-03 23:29:01.298  INFO 9436 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2017-10-03 23:29:01.303  INFO 9436 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.20
2017-10-03 23:29:01.696  INFO 9436 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2017-10-03 23:29:01.696  INFO 9436 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3219 ms
2017-10-03 23:29:02.216  INFO 9436 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: 'dispatcherServlet' to [/]
2017-10-03 23:29:02.227  INFO 9436 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]
2017-10-03 23:29:02.230  INFO 9436 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2017-10-03 23:29:02.231  INFO 9436 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2017-10-03 23:29:02.231  INFO 9436 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]
2017-10-03 23:29:02.968  INFO 9436 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@351d0846: startup date [Tue Oct 03 23:28:58 CST 2017]; root of context hierarchy
2017-10-03 23:29:03.114  INFO 9436 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/hello]}&quot; onto public java.lang.String com.example.HelloSpringBoot.Controller.HelloSpringBootController.hello()
2017-10-03 23:29:03.122  INFO 9436 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error]}&quot; onto public org.springframework.http.ResponseEntity&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.util.Map&lt;/span&gt;&lt;span&gt;&amp;lt;java.lang.String, java.lang.Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2017-10-03 23:29:03.123  INFO 9436 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;{[/error],produces=[text/html]}&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2017-10-03 23:29:03.182  INFO 9436 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-10-03 23:29:03.182  INFO 9436 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-10-03 23:29:03.260  INFO 9436 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2017-10-03 23:29:03.628  INFO 9436 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2017-10-03 23:29:03.832  INFO 9436 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2017-10-03 23:29:03.842  INFO 9436 --- [           main] c.e.H.HelloSpringBootApplication         : Started HelloSpringBootApplication in 6.118 seconds (JVM running for 7.13)
2017-10-03 23:29:27.484  INFO 9436 --- [nio-8080-exec-3] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2017-10-03 23:29:27.484  INFO 9436 --- [nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2017-10-03 23:29:27.515  INFO 9436 --- [nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 31 ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;通过输出的内容，我们可以看到Springboot程序已经成功启动！&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5. 通过浏览器，发送web request，验证程序。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171003233430443-1627092595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;OK，我们的第一个基于Springboot的测试程序就大功告成啦，感谢大家的观看，祝大家国庆快乐！！  &lt;/span&gt;&lt;span&gt;^_^&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 15:37:00 +0000</pubDate>
<dc:creator>~阿坨坨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atuotuo/p/7624818.html</dc:identifier>
</item>
<item>
<title>机器学习数学基础之矩阵理论 （二） - tanv</title>
<link>http://www.cnblogs.com/tan-v/p/7624779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tan-v/p/7624779.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;　　       目录&lt;/p&gt;
&lt;p&gt;一、线性空间&lt;/p&gt;
&lt;p&gt;1.    线性空间的概念&lt;/p&gt;
&lt;p&gt;（1） 线性空间的定义&lt;/p&gt;
&lt;p&gt;（2） 线性空间的本质&lt;/p&gt;
&lt;p&gt;2.    线性空间的基&lt;/p&gt;
&lt;p&gt;（1） 线性表示&lt;/p&gt;
&lt;p&gt;（2） 线性相关&lt;/p&gt;
&lt;p&gt;（3） 线性无关&lt;/p&gt;
&lt;p&gt;（4） 线性空间基的定义&lt;/p&gt;
&lt;p&gt;（5） 坐标&lt;/p&gt;
&lt;p&gt;3.   线性空间的范数&lt;/p&gt;
&lt;p&gt;（1） 范数的定义&lt;/p&gt;
&lt;p&gt;（2） 赋范线性空间中的距离&lt;/p&gt;
&lt;p&gt;（3） 欧几里得范数&lt;/p&gt;
&lt;p&gt;（4） Lp范数&lt;/p&gt;
&lt;p&gt;（5） Frobenius范数，矩阵中常用的范数&lt;/p&gt;
&lt;p&gt;二、  矩阵分解&lt;/p&gt;
&lt;p&gt;1.   方阵的正交分解&lt;/p&gt;
&lt;p&gt;（1） 特征值和特征向量的定义&lt;/p&gt;
&lt;p&gt;（2） 特征值：&lt;/p&gt;
&lt;p&gt;（3） 特征向量：&lt;/p&gt;
&lt;p&gt;（4） 矩阵分解&lt;/p&gt;
&lt;p&gt;（5） 特征向量与其特征值之间的关系&lt;/p&gt;
&lt;p&gt;2.   正交分解&lt;/p&gt;
&lt;p&gt;（1） 正交矩阵&lt;/p&gt;
&lt;p&gt;（2）  标准正交基&lt;/p&gt;
&lt;p&gt;（3）  正交矩阵的性质&lt;/p&gt;
&lt;p&gt;（4）  正交分解&lt;/p&gt;
&lt;p&gt;3.   矩阵的奇异值分解(SVD)&lt;/p&gt;
&lt;p&gt;（1） 非退化方阵的SVD&lt;/p&gt;
&lt;p&gt;（2） 一般矩阵的SVD&lt;/p&gt;
&lt;p&gt;（3） 伪逆(Moor-Penrose)&lt;/p&gt;
&lt;p&gt;（4） 不相容线性方程组的解&lt;/p&gt;
&lt;p&gt;（5）  定理&lt;/p&gt;
&lt;p&gt;4.   主成分分析(PCA)&lt;/p&gt;

&lt;p&gt;一、线性空间&lt;/p&gt;
&lt;p&gt;1. 线性空间的概念&lt;/p&gt;
&lt;p&gt;（1）  线性空间的定义&lt;/p&gt;
&lt;p&gt;　　设V是一个非空集合，R为实数域。如果对于任意两个元素 𝛼，𝛽∈𝑉，总有唯一的元素 𝛾∈𝑉与之对应，成为 𝛼和𝛽的和（和的运算法则可以任意定义），记为 𝛾=𝛼+𝛽；&lt;/p&gt;
&lt;p&gt;　　又对于任一实数λ∈𝑅和任一元素𝛼∈𝑉，总有唯一的元素𝛿∈𝑉与之对应，称为λ与𝛼的积（积的运算法则可以任意定义），记作 𝛿=λ𝛼；&lt;/p&gt;
&lt;p&gt;　　并且这两种运算满足以下八条规：&lt;/p&gt;
&lt;p&gt;　　（设𝛼，𝛽，𝛾∈𝑉，λ，𝜇∈𝑅）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（i）&lt;/strong&gt; &lt;strong&gt; 𝛼&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛽&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝛽&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（ii）&lt;/strong&gt; &lt;strong&gt;(𝛼&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛽)&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛾&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;+(&lt;/strong&gt;&lt;strong&gt;𝛽&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛾)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（iii）&lt;/strong&gt; &lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;V&lt;/strong&gt;&lt;strong&gt;中存在零元素&lt;/strong&gt;&lt;strong&gt;𝜃&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑉&lt;/strong&gt;&lt;strong&gt;，对任意的&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑉&lt;/strong&gt;&lt;strong&gt;，都有&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝜃&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（&lt;/strong&gt;&lt;strong&gt;iv&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;对于任何的&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑉&lt;/strong&gt;&lt;strong&gt;，都有&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;的负元素&lt;/strong&gt;&lt;strong&gt;𝛿&lt;/strong&gt;&lt;strong&gt;，使得&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛿&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝜃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（&lt;/strong&gt;&lt;strong&gt;v&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt; &lt;strong&gt; 1&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（&lt;/strong&gt;&lt;strong&gt;vi&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;𝜇𝛼)&lt;/strong&gt;&lt;strong&gt;=(&lt;/strong&gt;&lt;strong&gt;λμ&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（&lt;/strong&gt;&lt;strong&gt;vii&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt; &lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝜇)𝛼&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;λα&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝜇𝛼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（&lt;/strong&gt;&lt;strong&gt;viii&lt;/strong&gt;&lt;strong&gt;）λ&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝛽)&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;λα&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;strong&gt;𝛽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么，集合V就称为（实数域上的）线性空间或向量。&lt;/p&gt;
&lt;p&gt;　　满足上述八条性质的加法和数乘运算叫做线性运算。&lt;/p&gt;
&lt;p&gt;（2） 线性空间的本质：&lt;/p&gt;
&lt;p&gt;　　在数学上其实就是一个集合，线性集合，只要满足&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　对于任意的&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;𝛽&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑉&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;λ&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝜇&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑅&lt;/strong&gt;&lt;strong&gt;，都有λα&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝜇𝛽&lt;/strong&gt;&lt;strong&gt;∈&lt;/strong&gt;&lt;strong&gt;𝑉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt; 　即，加法和数乘都是封闭的，都称为线性空间&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. 线性空间的基&lt;/p&gt;
&lt;p&gt;（1） 线性表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt; ，&lt;strong&gt;𝛽&lt;/strong&gt;∈𝑉，若存在一组实数&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;∈𝑅，满足&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;⋯&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;=&lt;strong&gt;𝛽&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;　　则称&lt;strong&gt;𝛽&lt;/strong&gt;可以由&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;线性表示。&lt;/p&gt;
&lt;p&gt;（2） 线性相关&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;∈𝑉，若存在一组不全为0的实数&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;，满足&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;⋯&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;=&lt;strong&gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　则&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;线性相关。&lt;/p&gt;
&lt;p&gt;　　诠释：&lt;/p&gt;
&lt;p&gt;　　　　1）线性相关，说明至少存在一个向量可以被其余的向量线性表示。&lt;/p&gt;
&lt;p&gt;　　　　2）使用线性方程组来说明，就是至少有一个方程是无用的，即至少有一个向量是废的，无用的。&lt;/p&gt;
&lt;p&gt;（3）  线性无关&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;∈𝑉，若满足&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;⋯&lt;/strong&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;=&lt;strong&gt;0&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;且必有&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝑘&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;strong&gt;𝑘&lt;sub&gt;𝑛&lt;/sub&gt;=0&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　则&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;线性无关。&lt;/p&gt;
&lt;p&gt;　　诠释：&lt;/p&gt;
&lt;p&gt;　　　　1）方程组中每一个方程都是有用的，都是方程组的本质。&lt;/p&gt;
&lt;p&gt;（4） 线性空间基的定义&lt;/p&gt;
&lt;p&gt;　　在线性空间V中，如果存在n个元素&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;，满足：&lt;/p&gt;
&lt;p&gt;　　（i） &lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;线性无关&lt;/p&gt;
&lt;p&gt;　　（ii） V中任一元素𝛼都可以由&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;线性表示&lt;/p&gt;
&lt;p&gt;　　　　  那么，&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;称为线性空间V的一个基，n（基的个数）称为线性空间V的维数。&lt;/p&gt;
&lt;p&gt;　　　　 空间V称为由基&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;张成的线性空间，记作V =span{&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;}。&lt;/p&gt;
&lt;p&gt;　　1)   本质&lt;/p&gt;
&lt;p&gt;　　　　基的本质就是指基是本质的、消不掉的、基础的东西，可以由此刻画出线性空间中其他所有元素，研究线性空间，研究构成这线性空间的基就可以了。&lt;/p&gt;
&lt;p&gt;　　2)   基的性质&lt;/p&gt;
&lt;p&gt;　　　　线性空间V中的任意元素x，都可以由该线性空间的基线性表示：&lt;/p&gt;
&lt;p&gt;　　　　V = { x|x=𝑐&lt;sub&gt;1&lt;/sub&gt;𝛼&lt;sub&gt;1&lt;/sub&gt;+𝑐&lt;sub&gt;2&lt;/sub&gt;𝛼&lt;sub&gt;2&lt;/sub&gt;+⋯+𝑐&lt;sub&gt;𝑛&lt;/sub&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt; }，𝑐&lt;sub&gt;𝑖&lt;/sub&gt;为任意实数，𝑖=1,2,…,𝑛&lt;/p&gt;
&lt;p&gt;（5）  坐标&lt;/p&gt;
&lt;p&gt;　　1）定义&lt;/p&gt;
&lt;p&gt;　　　 若V是一个线性空间，{&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;}是线性空间V的一组基，对于𝛼∈𝑉，如果有 𝛼=𝑥&lt;sub&gt;1&lt;/sub&gt;𝛼&lt;sub&gt;1&lt;/sub&gt;+𝑥&lt;sub&gt;2&lt;/sub&gt;𝛼&lt;sub&gt;2&lt;/sub&gt;+⋯+𝑥&lt;sub&gt;𝑛&lt;/sub&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;，那么由系数所构成的 n维实向量(𝑥&lt;sub&gt;1&lt;/sub&gt;,𝑥&lt;sub&gt;2&lt;/sub&gt;,…,𝑥&lt;sub&gt;𝑛&lt;/sub&gt;)称为𝛼在基{&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;/strong&gt;&lt;strong&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;𝛼&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/strong&gt;}下的　　　　&lt;/p&gt;
&lt;p&gt;　　　坐标。因此，线性空间的元素也称为向量，线性空间也称为向量空间。&lt;/p&gt;
&lt;p&gt;　　2）本质&lt;/p&gt;
&lt;p&gt;　　　在基下的坐标，也就解释了为什么使用坐标可以表示空间中任意一个元素了，如二维坐标中，使用坐标(x,y)可以表示二维空间中任意一个数值。&lt;/p&gt;
&lt;p&gt; 3. 线性空间的范数&lt;/p&gt;
&lt;p&gt;　　范数也称为模&lt;/p&gt;
&lt;p&gt;（1）范数的定义&lt;/p&gt;
&lt;p&gt;　　在线性空间V中定义一种运算||.||:𝑉→𝑹，对于任意的𝛼,𝛽∈𝑉，𝜆∈𝑅，满足如下性质：&lt;/p&gt;
&lt;p&gt;　　（i） || 𝛼||≥ 0，即若 ||𝛼|| = 0 等价于 𝛼 = &lt;strong&gt;𝜃&lt;/strong&gt;（零向量）&lt;/p&gt;
&lt;p&gt;　　（ii） 膨胀性：||𝜆𝛼|| = ||𝜆|| ||𝛼||&lt;/p&gt;
&lt;p&gt;　　（iii） 三角不等式： ||𝛼+𝛽|| ≤ ||𝛼|| + ||𝛽||&lt;/p&gt;
&lt;p&gt;　　则称||.||这种运算为线性空间V的一个范数，称V为赋范线性空间。&lt;/p&gt;
&lt;p&gt;（2）赋范线性空间中的距离&lt;/p&gt;
&lt;p&gt;　　赋范线性空间中的元素𝛼,𝛽∈𝑉，定义||𝛼−𝛽||为𝛼,𝛽之间的距离。（即长度，也在这个线性空间中）&lt;/p&gt;
&lt;p&gt;（3）欧几里得范数&lt;/p&gt;
&lt;p&gt;　　在n维向量空间𝑅&lt;sup&gt;𝑛&lt;/sup&gt;中，对于任意向量&lt;strong&gt;x&lt;/strong&gt; = (𝑥&lt;sub&gt;1&lt;/sub&gt;,𝑥&lt;sub&gt;2&lt;/sub&gt;,…,𝑥&lt;sub&gt;𝑛&lt;/sub&gt;)∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt;, 则欧几里得范数：      &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224042427-240341129.png&quot; alt=&quot;&quot;/&gt;   &lt;/p&gt;
&lt;p&gt;（4）L&lt;sup&gt;p&lt;/sup&gt;范数&lt;/p&gt;
&lt;p&gt;　　在实数空间𝑅&lt;sup&gt;𝑛&lt;/sup&gt;内，但1≤𝑝&amp;lt;∞时，L&lt;sup&gt;p&lt;/sup&gt;范数定义为：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003223855380-2126108022.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当𝑝=∞时，𝑅&lt;sup&gt;𝑛&lt;/sup&gt;空间的𝐿∞范数定义为 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003223945490-1148838412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5） Frobenius范数，矩阵中常用的范数&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224142568-822064117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二、矩阵分解&lt;/p&gt;
&lt;p&gt;1. 方阵的正交分解&lt;/p&gt;
&lt;p&gt;（1）  特征值和特征向量的定义&lt;/p&gt;
&lt;p&gt;　　设 &lt;strong&gt;A&lt;/strong&gt;&lt;sub&gt;n×n&lt;/sub&gt;，如果有数 和n维非零列向量𝒙，使得&lt;/p&gt;
&lt;p&gt;&lt;sub&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224454240-1993490039.png&quot; alt=&quot;&quot;/&gt;&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;　　则称 为&lt;strong&gt;A&lt;/strong&gt;的特征值，非零列向量𝒙为&lt;strong&gt;A&lt;/strong&gt;的对应与特征值 的特征向量。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;/p&gt;
&lt;p&gt;　　　　1）  A是方阵，方阵才有特征值和特征向量&lt;/p&gt;
&lt;p&gt;　　　　2）  特征向量𝒙是非零列向量&lt;/p&gt;
&lt;p&gt;　　　　3）  属于特征值 的特征向量不唯一，有无数个&lt;/p&gt;
&lt;p&gt;　　　　4）  但一个特征向量只能属于一个特征值&lt;/p&gt;
&lt;p&gt;（2）  特征值：&lt;/p&gt;
&lt;p&gt;　　λ&lt;sub&gt;𝑖&lt;/sub&gt;是关于λ的多项式|𝐴−λ𝐼&lt;sub&gt;𝑛&lt;/sub&gt;|=0的根，记作λ&lt;sub&gt;1&lt;/sub&gt;,λ&lt;sub&gt;2&lt;/sub&gt;,…,λ&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;（3） 特征向量：&lt;/p&gt;
&lt;p&gt;　　属于λ&lt;sub&gt;𝑖&lt;/sub&gt;的特征向量是线性方程组 (𝐴−λ&lt;sub&gt;𝑖&lt;/sub&gt;𝐼&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;strong&gt;x&lt;/strong&gt;=0的解。&lt;/p&gt;
&lt;p&gt;（4） 矩阵分解&lt;/p&gt;
&lt;p&gt;　　设{𝒙&lt;sub&gt;𝑖&lt;/sub&gt;&lt;sub&gt;1&lt;/sub&gt;,𝒙&lt;sub&gt;𝑖&lt;/sub&gt;&lt;sub&gt;2&lt;/sub&gt;,…,𝒙&lt;sub&gt;𝑖𝑚&lt;/sub&gt;}是方程组(𝐴−λ&lt;sub&gt;𝑖&lt;/sub&gt;𝐼&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;strong&gt;x&lt;/strong&gt;=0的解空间的基（特征向量），定义一个矩阵：&lt;/p&gt;
&lt;p&gt;　　　　　𝑃&lt;sub&gt;𝑛&lt;/sub&gt;&lt;sub&gt;×&lt;/sub&gt;&lt;sub&gt;𝑛&lt;/sub&gt; = [𝒙&lt;sub&gt;11&lt;/sub&gt;,𝒙&lt;sub&gt;12&lt;/sub&gt;,…,𝒙&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;𝑚&lt;/sub&gt;,𝒙&lt;sub&gt;21&lt;/sub&gt;,𝒙&lt;sub&gt;22&lt;/sub&gt;,…]&lt;sub&gt;𝑛&lt;/sub&gt;&lt;sub&gt;×&lt;/sub&gt;&lt;sub&gt;𝑛&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;    　那么可以把矩阵A分解成如下形式：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224553911-1160264804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　称这样的分解为特征分解（或者称为相似对角化）。&lt;/p&gt;
&lt;p&gt;　　本质：&lt;/p&gt;
&lt;p&gt;　　　　1） A可表示为：基(base)*特征值(feature) （联想到了PCA）&lt;/p&gt;
&lt;p&gt;　　　　2） A的特征分解可表征其特征向量与其特征值之间的关系&lt;/p&gt;

&lt;p&gt; 2.  正交分解&lt;/p&gt;
&lt;p&gt;（1）  正交矩阵&lt;/p&gt;
&lt;p&gt;　　定义：满足 𝐴𝐴&lt;sup&gt;𝑇&lt;/sup&gt;=𝐼&lt;sub&gt;𝑛&lt;/sub&gt;（即𝐴&lt;sup&gt;−1&lt;/sup&gt;=𝐴&lt;sup&gt;𝑇&lt;/sup&gt;）的n阶方阵&lt;/p&gt;
&lt;p&gt;（2）  标准正交基&lt;/p&gt;
&lt;p&gt;　　定义：n个n维向量{𝒙&lt;sub&gt;1&lt;/sub&gt;,𝒙&lt;sub&gt;2&lt;/sub&gt;,…,𝒙&lt;sub&gt;𝑛&lt;/sub&gt;}∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt;，满足一下性质&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224640802-464093391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　则称{𝒙&lt;sub&gt;1&lt;/sub&gt;,𝒙&lt;sub&gt;2&lt;/sub&gt;,…,𝒙&lt;sub&gt;𝑛&lt;/sub&gt;}∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt;为一组标准正交基。&lt;/p&gt;
&lt;p&gt;　　几何意义：向量跟自己平行(长度)，而与其他都垂直，例如二维空间的坐标。&lt;/p&gt;
&lt;p&gt;　　性质：[𝒙&lt;sub&gt;1&lt;/sub&gt;,𝒙&lt;sub&gt;2&lt;/sub&gt;,…,𝒙&lt;sub&gt;𝑛&lt;/sub&gt;]为n阶交正矩阵，则{𝒙&lt;sub&gt;1&lt;/sub&gt;,𝒙&lt;sub&gt;2&lt;/sub&gt;,…,𝒙&lt;sub&gt;𝑛&lt;/sub&gt; ∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt; } 为一组标准正交基，反之也成立。&lt;/p&gt;
&lt;p&gt;（3）  正交矩阵的性质&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224718615-503167454.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4） 正交分解&lt;/p&gt;
&lt;p&gt;　　若n阶方阵A可进行特征分解，即存在n阶可逆矩阵P，使得&lt;/p&gt;
&lt;p&gt;　　　　𝑃&lt;sup&gt;−1&lt;/sup&gt;𝐴𝑃 = 𝑑𝑖𝑎𝑔(λ&lt;sub&gt;1&lt;/sub&gt;,λ&lt;sub&gt;2&lt;/sub&gt;,…,λ&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　其中𝜆&lt;sub&gt;𝑖&lt;/sub&gt;为𝐴的特征值, &lt;strong&gt;𝑃&lt;/strong&gt;&lt;sub&gt;𝑛&lt;/sub&gt;&lt;sub&gt;×&lt;/sub&gt;&lt;sub&gt;𝑛&lt;/sub&gt; = [𝒙&lt;sub&gt;11&lt;/sub&gt;,𝒙&lt;sub&gt;12&lt;/sub&gt;,…,𝒙&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;𝑚&lt;/sub&gt;,𝒙&lt;sub&gt;21&lt;/sub&gt;,𝒙&lt;sub&gt;22&lt;/sub&gt;,…]&lt;sub&gt;𝑛&lt;/sub&gt;&lt;sub&gt;×&lt;/sub&gt;&lt;sub&gt;𝑛&lt;/sub&gt;列向量为𝜆&lt;sub&gt;𝑖&lt;/sub&gt;对应的特征向量。&lt;/p&gt;
&lt;p&gt;　　那么，一定存在：&lt;/p&gt;
&lt;p&gt;　　另一组属于𝜆&lt;sub&gt;𝑖&lt;/sub&gt;的特征向量&lt;strong&gt;Q&lt;/strong&gt;=[𝒚&lt;sub&gt;11,&lt;/sub&gt;𝒚&lt;sub&gt;12&lt;/sub&gt;,…,𝒚&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;𝑚&lt;/sub&gt;,𝒚&lt;sub&gt;21&lt;/sub&gt;,𝒚&lt;sub&gt;22&lt;/sub&gt;,…]，满足向量组{ 𝒚&lt;sub&gt;11,&lt;/sub&gt;𝒚&lt;sub&gt;12&lt;/sub&gt;,…,𝒚&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;𝑚&lt;/sub&gt;,𝒚&lt;sub&gt;21&lt;/sub&gt;,𝒚&lt;sub&gt;22&lt;/sub&gt;,…}是一组n维标准正交基，即&lt;strong&gt;Q&lt;/strong&gt;是n阶正交矩阵，则有&lt;/p&gt;
&lt;p&gt;　　　　𝑄&lt;sup&gt;−1&lt;/sup&gt;𝐴𝑄=𝑄&lt;sup&gt;𝑇&lt;/sup&gt;𝐴𝑄=𝑑𝑖𝑎𝑔(λ&lt;sub&gt;1&lt;/sub&gt;,λ&lt;sub&gt;2&lt;/sub&gt;,…,λ&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　称该分解为正交分解。&lt;/p&gt;
&lt;p&gt;      本质：正交分解是一种特殊的特征分解。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;3.  矩阵的奇异值分解(SVD)&lt;/p&gt;
&lt;p&gt;　　如果矩阵不可特征分解怎么办？引入了矩阵的奇异值分解。&lt;/p&gt;
&lt;p&gt;（1）  非退化方阵的SVD&lt;/p&gt;
&lt;p&gt;　　设𝐴是n阶非退化方阵，即满秩：𝑟(𝐴)=𝑛。那么存在正交矩阵P和Q，使得&lt;/p&gt;
&lt;p&gt;　　　　𝑃&lt;sup&gt;𝑇&lt;/sup&gt;𝐴𝑄=diag(𝛼&lt;sub&gt;1&lt;/sub&gt;,𝛼&lt;sub&gt;2&lt;/sub&gt;,…,𝛼&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　其中 𝛼&lt;sub&gt;𝑖&lt;/sub&gt; &amp;gt; 0（𝑖=1,2,…,𝑛），但不是特征值，而是奇异值。称为非退化方阵的SVD。&lt;/p&gt;
&lt;p&gt;　　性质：&lt;/p&gt;
&lt;p&gt;　　　　1） 不一定每个方阵都可以正交分解，只有实对称矩阵(𝐴=𝐴&lt;sup&gt;𝑇&lt;/sup&gt;)一定可以正交分解。但是每个方阵都可以进行SVD。&lt;/p&gt;
&lt;p&gt;　　　　2）正交分解是同一个正交矩阵Q，SVD分解是两个正交矩阵&lt;strong&gt;P&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Q&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　3）正交分解对角线是特征值，SVD对角线不是特征值，但都大于0&lt;/p&gt;
&lt;p&gt;（2） 一般矩阵的SVD&lt;/p&gt;
&lt;p&gt;　　设A是秩为𝑟(𝑟 &amp;gt; 0)的𝑚×𝑛阶实矩阵，则存在m阶正交矩阵&lt;strong&gt;U&lt;/strong&gt;和n阶正交矩阵&lt;strong&gt;V&lt;/strong&gt;，使得&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003224905536-845726195.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中Λ&lt;sub&gt;𝑟&lt;/sub&gt;=diag (𝜎&lt;sub&gt;1&lt;/sub&gt;,𝜎&lt;sub&gt;2&lt;/sub&gt;,…,𝜎&lt;sub&gt;𝑟&lt;/sub&gt;)&lt;/p&gt;
&lt;p&gt;　　𝜎&lt;sub&gt;1&lt;/sub&gt;≥𝜎&lt;sub&gt;2&lt;/sub&gt;≥⋯≥𝜎&lt;sub&gt;𝑟&lt;/sub&gt;&amp;gt;0为矩阵𝐴的全部奇异值.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003225002505-1877705772.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;54&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　𝑈&lt;sub&gt;𝑖&lt;/sub&gt;,𝑉&lt;sub&gt;𝑖&lt;/sub&gt;为矩阵𝑈,𝑉的列向量。&lt;/p&gt;
&lt;p&gt;（3） 伪逆(Moor-Penrose)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003225106740-1665016982.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　则称𝐴&lt;sup&gt;+&lt;/sup&gt;为矩阵A的伪逆，上述四个方程称为Moore –Penrose方程。&lt;/p&gt;
&lt;p&gt;（4） 不相容线性方程组的解&lt;/p&gt;
&lt;p&gt;　　1）定义：设𝐴∈𝑅&lt;sup&gt;𝑚&lt;/sup&gt;&lt;sup&gt;×&lt;/sup&gt;&lt;sup&gt;𝑛&lt;/sup&gt;,𝒃∈𝑅&lt;sup&gt;𝑚&lt;/sup&gt;，𝐴𝒙=𝒃是不相容线性方程组(即无解的方程组)。&lt;/p&gt;
&lt;p&gt;　　　　　　 若存在向量𝑥&lt;sub&gt;0&lt;/sub&gt;∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt;，使得对于任何𝒙∈𝑅&lt;sup&gt;𝑛&lt;/sup&gt;，都有&lt;/p&gt;
&lt;p&gt;　　　　　　　　||𝐴𝑥&lt;sub&gt;0&lt;/sub&gt;−𝑏||≤||𝐴𝑥−𝑏||&lt;/p&gt;
&lt;p&gt;　　　　　　则称𝑥&lt;sub&gt;0&lt;/sub&gt;为方程组𝐴𝒙=𝒃的最小乘解。&lt;/p&gt;
&lt;p&gt;       本质：虽然无解，但可以找一个与解最近的一个解，最近，则使用范数来衡量。&lt;/p&gt;
&lt;p&gt;　　 2）若𝑢是方程组𝐴𝒙=𝒃的最小二乘解，如果对于任意一个𝑥&lt;sub&gt;0&lt;/sub&gt;，都有&lt;/p&gt;
&lt;p&gt;              　　 ||𝑢|| ≤ ||𝑥&lt;sub&gt;0&lt;/sub&gt;||  （即取自己长度最短的）&lt;/p&gt;
&lt;p&gt;　　　　则称𝑢是最佳最小二乘解。&lt;/p&gt;
&lt;p&gt;（5） 定理&lt;/p&gt;
&lt;p&gt;　　1） 设𝐴∈𝑅&lt;sup&gt;𝑚&lt;/sup&gt;&lt;sup&gt;×&lt;/sup&gt;&lt;sup&gt;𝑛&lt;/sup&gt;，𝒃∈𝑅&lt;sup&gt;𝑚&lt;/sup&gt;，则向量𝒙=𝐴&lt;sup&gt;+&lt;/sup&gt;𝒃是方程组𝐴𝒙=𝒃的最佳最小二乘解。&lt;/p&gt;
&lt;p&gt;　　2） 如果矩阵A的𝑆𝑉𝐷为𝐴=𝑈Λ𝑉&lt;sup&gt;𝑇&lt;/sup&gt;，那么A的伪逆为𝐴&lt;sup&gt;+&lt;/sup&gt;=𝑉Λ&lt;sup&gt;+&lt;/sup&gt;𝑈&lt;sup&gt;𝑇&lt;/sup&gt;，其中Λ&lt;sup&gt;+&lt;/sup&gt;是Λ的伪逆，是将Λ主对角线上非零元素𝜎&lt;sub&gt;𝑖&lt;/sub&gt;取倒数变成1/𝜎&lt;sub&gt;𝑖&lt;/sub&gt;之后再取转置。&lt;/p&gt;
&lt;p&gt;4.  主成分分析(PCA)&lt;/p&gt;
&lt;p&gt;（1）  计算样品数据的协方差矩阵 𝐴=(S&lt;sub&gt;𝑖𝑗&lt;/sub&gt;)&lt;sub&gt;𝑛&lt;/sub&gt;&lt;sub&gt;×&lt;/sub&gt;&lt;sub&gt;𝑛&lt;/sub&gt;，其中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003225356568-1949137355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）  对矩阵𝐴进行正交分解，并对特征值进行排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003225347099-1566891107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3） 确定最小的m，使得贡献率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/718363/201710/718363-20171003225407786-239315148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者大于设定的某个值。&lt;/p&gt;
&lt;p&gt;（4） 则主成分变量为：𝐹&lt;sub&gt;𝑖&lt;/sub&gt; = 𝑄&lt;sub&gt;𝑖&lt;/sub&gt;𝒙 (i=1…m)，其中&lt;/p&gt;
&lt;p&gt;𝒙= (𝑥&lt;sub&gt;1&lt;/sub&gt;,…,𝑥&lt;sub&gt;𝑛&lt;/sub&gt;)&lt;sup&gt;𝑇&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;𝑄&lt;sub&gt;𝑖&lt;/sub&gt;为正交矩阵𝑄的第𝑖列向量&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;      -tany 2017年10月3日 于杭州&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 15:06:00 +0000</pubDate>
<dc:creator>tanv</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tan-v/p/7624779.html</dc:identifier>
</item>
<item>
<title>【充分利用你的Azure】将Azure用作云计算平台（1） - 姜子瑜</title>
<link>http://www.cnblogs.com/ldzhangyx/p/7624771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ldzhangyx/p/7624771.html</guid>
<description>&lt;p&gt;本文将围绕几个步骤来讲。&lt;/p&gt;
&lt;p&gt;因为本人是MSP，微软送了150刀的额度给我随便使用。这篇文章是要讲将Azure用作云计算平台，对于我来说，我是做机器学习的，那么Azure就要有机器学习的平台。&lt;/p&gt;
&lt;p&gt;本文的目的是，在Azure上搭建虚拟机，安装TensorFlow，在本地通过XShell进行远程连接。&lt;/p&gt;
&lt;p&gt;===================================&lt;/p&gt;
&lt;p&gt;1，在Azure上搭虚拟机&lt;/p&gt;
&lt;p&gt;首先我们打开Azure。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037202/201710/1037202-20171003224017740-372789462.png&quot; alt=&quot;&quot; width=&quot;2014&quot; height=&quot;976&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后点击右上角的Terminal，选择Bash，进行最初的准备。此时将会分配一个新的存储空间给你使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037202/201710/1037202-20171003224237974-607086553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; azure-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后：&lt;/p&gt;

&lt;p&gt;接下来我们新建一个资源组用作管理，资源组选择EastUS。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
az group create -n tensorflow -l EastUS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们可能需要一个SSH密钥对，这个我们待会再说。&lt;/p&gt;
&lt;p&gt;接下来我们新建一个虚拟机，选择左边的侧栏：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037202/201710/1037202-20171003224654724-59364341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1037202/201710/1037202-20171003224722661-1683356364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Ubuntu 16.04 LTS即可，之后按照自己需要的进行定制。&lt;/p&gt;
&lt;p&gt;在第一步的时候可能需要你选择用户名或者SSH，此时建议先使用用户名，之后再禁用。&lt;/p&gt;
&lt;p&gt;一切都配置完成之后，启动虚拟机：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
az vm start -g tensorflow -n tensorflow
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用用户名密码登陆。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来我们安装CUDA8 + CuDNN 5.1. TensorFlow官方尚未支持CUDA9，所以我们暂时使用CUDA8.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.nvidia.com/compute/cuda/8.0/prod/local_installers/cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-deb&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; dpkg -i cuda-repo-ubuntu1604-&lt;span&gt;8&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;-local_8.&lt;span&gt;0.44&lt;/span&gt;-1_amd64-&lt;span&gt;deb
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; -&lt;span&gt;y cuda
&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; cuda-repo-ubuntu1604-&lt;span&gt;8&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;-local_8.&lt;span&gt;0.44&lt;/span&gt;-1_amd64-deb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后我们可以使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
nvidia-smi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查看GPU状态。&lt;/p&gt;

&lt;p&gt;下一步安装CuDNN 5.1.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.download.nvidia.com/compute/redist/cudnn/v5.1/cudnn-8.0-linux-x64-v5.1.tgz&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;tar&lt;/span&gt; -xzf cudnn-&lt;span&gt;8.0&lt;/span&gt;-linux-x64-v5.&lt;span&gt;1&lt;/span&gt;.tgz -C /usr/&lt;span&gt;local
&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; cudnn-&lt;span&gt;8.0&lt;/span&gt;-linux-x64-v5.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.tgz
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; ldconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后添加进环境变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export CUDA_HOME=/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
export PATH&lt;/span&gt;=${CUDA_HOME}/&lt;span&gt;bin:${PATH}
export LD_LIBRARY_PATH&lt;/span&gt;=${CUDA_HOME}/lib64:/usr/local/cuda/lib64:${LD_LIBRARY_PATH}
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;因为我喜欢用Python3，所以我要另外装上Python3和对应的pip。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; python3-&lt;span&gt;setuptools
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; easy_install3 pip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，你输入Python3，pip3会启动Python3，而输入python，pip会启动Python2.&lt;/p&gt;

&lt;p&gt;之后安装TensorFlow r1.2（因为1.3版本需要CuDNN 6+）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; -y  python3-&lt;span&gt;dev
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; tensorflow-gpu==&lt;span&gt;1.2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TensorFlow的安装完成。输入下列语句进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; import tensorflow as tf
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; session = tf.Session()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，你可以随时离开虚拟机：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
az vm deallocate -g tensorflow -n tensorflow
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://www.lutzroeder.com/blog/2016-12-27-tensorflow-azure/http://blog.csdn.net/silent56_th/article/details/77587792&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/silent56_th/article/details/77587792&lt;/p&gt;
&lt;p&gt;https://gist.github.com/diegopacheco/576ff74c2013ee79ea8060945b1e9a53&lt;/p&gt;

</description>
<pubDate>Tue, 03 Oct 2017 14:58:00 +0000</pubDate>
<dc:creator>姜子瑜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ldzhangyx/p/7624771.html</dc:identifier>
</item>
<item>
<title>五种IO模型分析 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/7624733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/7624733.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog1&quot;&gt;&lt;span&gt;1. 基础&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2&quot;&gt;&lt;span&gt;2. I/O模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.1&quot;&gt;&lt;span&gt;2.1 Blocking I/O模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.2&quot;&gt;&lt;span&gt;2.2 Non-Blocking I/O模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.3&quot;&gt;&lt;span&gt;2.3 I/O Multiplexing模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.4&quot;&gt;&lt;span&gt;2.4 Signal-driven I/O模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.5&quot;&gt;&lt;span&gt;2.5 Asynchronous I/O模型&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog2.6&quot;&gt;&lt;span&gt;2.6 同步IO和异步IO、阻塞和非阻塞的区分&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog3&quot;&gt;&lt;span&gt;3. select()、poll()和epoll&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog3.1&quot;&gt;&lt;span&gt;3.1 select() &amp;amp; poll()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html#blog3.2&quot;&gt;&lt;span&gt;3.2 epoll&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;在引入IO模型前，先对io等待时某一段数据的&quot;经历&quot;做一番解释。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003132425740-1897420439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当某个程序或已存在的进程/线程(后文将不加区分的只认为是进程)需要某段数据时，它只能在用户空间中属于它自己的内存中访问、修改，这段内存暂且称之为app buffer。假设需要的数据在磁盘上，那么进程首先得发起相关系统调用，通知内核去加载磁盘上的文件。但正常情况下，数据只能加载到内核的缓冲区，暂且称之为kernel buffer。数据加载到kernel buffer之后，还需将数据复制到app buffer。到了这里，进程就可以对数据进行访问、修改了。&lt;/p&gt;
&lt;p&gt;现在有几个需要说明的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1).为什么不能直接将数据加载到app buffer呢&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际上是可以的，有些程序或者硬件为了提高效率和性能，可以实现内核旁路的功能，避过内核的参与，直接在存储设备和app buffer之间进行数据传输，例如RDMA技术就需要实现这样的内核旁路功能。&lt;/p&gt;
&lt;p&gt;但是，最普通也是绝大多数的情况下，为了安全和稳定性，数据必须先拷入内核空间的kernel buffer，再复制到app buffer，以防止进程串进内核空间进行破坏。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(2).上面提到的数据几次拷贝过程，拷贝方式是一样的吗&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不一样。现在的存储设备(包括网卡)基本上都支持DMA操作。什么是DMA(direct memory access，直接内存访问)？简单地说，就是内存和设备之间的数据交互可以直接传输，不再需要计算机的CPU参与，而是通过硬件上的芯片(可以简单地认为是一个小cpu)进行控制。&lt;/p&gt;
&lt;p&gt;假设，存储设备不支持DMA，那么数据在内存和存储设备之间的传输，必须通过计算机的CPU计算从哪个地址中获取数据、拷入到对方的哪些地址、拷入多少数据(多少个数据块、数据块在哪里)等等，仅仅完成一次数据传输，CPU都要做很多事情。而DMA就释放了计算机的CPU，让它可以去处理其他任务。&lt;/p&gt;
&lt;p&gt;再说kernel buffer和app buffer之间的复制方式，这是两段内存空间的数据传输，只能由CPU来控制。&lt;/p&gt;
&lt;p&gt;所以，在加载硬盘数据到kernel buffer的过程是DMA拷贝方式，而从kernel buffer到app buffer的过程是CPU参与的拷贝方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(3).如果数据要通过TCP连接传输出去要怎么办&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如，web服务对客户端的响应数据，需要通过TCP连接传输给客户端。&lt;/p&gt;
&lt;p&gt;TCP/IP协议栈维护着两个缓冲区：send buffer和recv buffer，它们合称为socket buffer。需要通过TCP连接传输出去的数据，需要先复制到send buffer，再复制给网卡通过网络传输出去。如果通过TCP连接接收到数据，数据首先通过网卡进入recv buffer，再被复制到用户空间的app buffer。&lt;/p&gt;
&lt;p&gt;同样，在数据复制到send buffer或从recv buffer复制到app buffer时，是CPU参与的拷贝。从send buffer复制到网卡或从网卡复制到recv buffer时，是DMA操作方式的拷贝。&lt;/p&gt;
&lt;p&gt;如下图所示，是通过TCP连接传输数据时的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003141732271-400909384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(4).网络数据一定要从kernel buffer复制到app buffer再复制到send buffer吗&lt;/strong&gt;？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不是。如果进程不需要修改数据，就直接发送给TCP连接的另一端，可以不用从kernel buffer复制到app buffer，而是直接复制到send buffer。这就是&lt;strong&gt;零复制&lt;/strong&gt;技术。&lt;/p&gt;
&lt;p&gt;例如httpd不需要访问和修改任何信息时，将数据原原本本地复制到app buffer再原原本本地复制到send buffer然后传输出去，但实际上复制到app buffer的过程是可以省略的。使用零复制技术，就可以减少一次拷贝过程，提升效率。&lt;/p&gt;
&lt;p&gt;当然，实现零复制技术的方法有多种，见我的另一篇结束零复制的文章：&lt;span&gt;&lt;a title=&quot;零复制(zero copy)技术&quot; href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7615914.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;零复制(zero copy)技术&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;以下是以httpd进程处理文件类请求时比较完整的数据操作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003145235536-131157754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致解释下：客户端发起对某个文件的请求，通过TCP连接，请求数据进入TCP 的recv buffer，再通过recv()函数将数据读入到app buffer，此时httpd工作进程对数据进行一番解析，知道请求的是某个文件，于是发起某个系统调用(例如要读取这个文件，发起read())，于是内核加载该文件，数据从磁盘复制到kernel buffer再复制到app buffer，此时httpd就要开始构建响应数据了，可能会对数据进行一番修改，例如在响应首部中加一个字段，最后将修改或未修改的数据复制(例如send()函数)到send buffer中，再通过TCP连接传输给客户端。&lt;/p&gt;


&lt;p&gt;所谓的IO模型，描述的是出现I/O等待时进程的状态以及处理数据的方式。围绕着进程的状态、数据准备到kernel buffer再到app buffer的两个阶段展开。其中数据复制到kernel buffer的过程称为&lt;strong&gt;数据准备&lt;/strong&gt;阶段，数据从kernel buffer复制到app buffer的过程称为&lt;strong&gt;数据复制&lt;/strong&gt;阶段。请记住这两个概念，后面描述I/O模型时会一直用这两个概念。&lt;/p&gt;
&lt;p&gt;本文以httpd进程的TCP连接方式处理本地文件为例，请无视httpd是否真的实现了如此、那般的功能，也请无视TCP连接处理数据的细节，这里仅仅只是作为方便解释的示例而已。另外，本文用本地文件作为I/O模型的对象不是很适合，它的重头戏是在套接字上，如果想要看处理TCP/UDP过程中套接字的I/O模型，请看完此文后，再结合我的另一篇文章&quot;&lt;span&gt;&lt;a title=&quot;不可不知的socket和TCP连接过程&quot; href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7623252.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;不可不知的socket和TCP连接过程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&quot;以重新认识I/O模型。&lt;/p&gt;
&lt;p&gt;再次说明，从硬件设备到内存的数据传输过程是不需要CPU参与的，而内存间传输数据是需要CPU参与的。&lt;/p&gt;


&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003151602802-29740447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设客户端发起index.html的文件请求，httpd需要将index.html的数据从磁盘中加载到自己的httpd app buffer中，然后复制到send buffer中发送出去。&lt;/p&gt;
&lt;p&gt;但是在httpd想要加载index.html时，它首先检查自己的app buffer中是否有index.html对应的数据，没有就发起系统调用让内核去加载数据，例如read()，内核会先检查自己的kernel buffer中是否有index.html对应的数据，如果没有，则从磁盘中加载，然后将数据准备到kernel buffer，再复制到app buffer中，最后被httpd进程处理。&lt;/p&gt;
&lt;p&gt;如果使用Blocking I/O模型：&lt;/p&gt;
&lt;p&gt;(1).当设置为blocking i/o模型，httpd从&lt;img title=&quot;1&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155833052-945481739.png&quot; alt=&quot;&quot;/&gt;到&lt;img title=&quot;3&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155859130-1641075549.png&quot; alt=&quot;&quot;/&gt;都是被阻塞的。&lt;br/&gt;(2).只有当数据复制到app buffer完成后，或者发生了错误，httpd才被唤醒处理它app buffer中的数据。&lt;br/&gt;(3).cpu会经过两次上下文切换：用户空间到内核空间再到用户空间。&lt;br/&gt;(4).由于&lt;img title=&quot;2&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155847193-660357263.png&quot; alt=&quot;&quot;/&gt;阶段的拷贝是不需要CPU参与的，所以在&lt;img title=&quot;2&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155847193-660357263.png&quot; alt=&quot;&quot;/&gt;阶段准备数据的过程中，cpu可以去处理其它进程的任务。&lt;br/&gt;(5).&lt;img title=&quot;3&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155859130-1641075549.png&quot; alt=&quot;&quot;/&gt;阶段的数据复制需要CPU参与，将httpd阻塞，在某种程度上来说，有助于提升它的拷贝速度。&lt;br/&gt;(6).这是最省事、最简单的IO模式。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003153915708-1740495360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;(1).当设置为non-blocking时，httpd第一次发起系统调用(如read())后，立即返回一个错误值EWOULDBLOCK(&lt;strong&gt;至于read()读取一个普通文件时能否返回EWOULDBLOCK请无视，毕竟I/O模型主要是针对套接字文件的，就当read()是recv()好了&lt;/strong&gt;)，而不是让httpd进入睡眠状态。UNP中也正是这么描述的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;When we &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; a socket &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be nonblocking, we &lt;span class=&quot;hljs-keyword&quot;&gt;are&lt;/span&gt; telling the kernel &lt;span class=&quot;hljs-string&quot;&gt;&quot;when an I/O operation that I request cannot be completed without putting the process to sleep, do not put the process to sleep, but return an error instead.&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2).虽然read()立即返回了，但httpd还要不断地去发送read()检查内核：数据是否已经成功拷贝到kernel buffer了？这称为轮询(polling)。每次轮询时，只要内核没有把数据准备好，read()就返回错误信息EWOULDBLOCK。&lt;br/&gt;(3).直到kernel buffer中数据准备完成，再去轮询时不再返回EWOULDBLOCK，而是将httpd阻塞，以等待数据复制到app buffer。&lt;br/&gt;(4).httpd在&lt;img title=&quot;1&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155833052-945481739.png&quot; alt=&quot;&quot;/&gt;到&lt;img title=&quot;2&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155847193-660357263.png&quot; alt=&quot;&quot;/&gt;阶段不被阻塞，但是会不断去发送read()轮询。在&lt;img title=&quot;3&quot; src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003155859130-1641075549.png&quot; alt=&quot;&quot;/&gt;被阻塞，将cpu交给内核把数据copy到app buffer。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003154856927-92203933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;称为多路IO模型或IO复用，意思是可以检查多个IO等待的状态。有三种IO复用模型：select、poll和epoll。其实它们都是一种函数，用于监控指定文件描述符的数据是否就绪，就绪指的是对某个系统调用不再阻塞了，例如对于read()来说，就是数据准备好了就是就绪状态。就绪种类包括是否可读、是否可写以及是否异常，其中可读条件中就包括了数据是否准备好。当就绪之后，将通知进程，进程再发送对数据操作的系统调用，如read()。所以，这三个函数仅仅只是处理了数据是否准备好以及如何通知进程的问题。可以将这几个函数结合阻塞和非阻塞IO模式使用，例如设置为非阻塞时，select()/poll()/epoll将不会阻塞在对应的描述符上，调用函数的进程/线程也就不会被阻塞。&lt;/p&gt;
&lt;p&gt;select()和poll()差不多，它们的监控和通知手段是一样的，只不过poll()要更聪明一点，所以此处仅以select()监控单个文件请求为例简单介绍IO复用，至于更具体的、监控多个文件以及epoll的方式，在本文的最后专门解释。&lt;/p&gt;
&lt;p&gt;(1).当想要加载某个文件时，假如httpd要发起read()系统调用，如果是阻塞或者非阻塞情形，那么read()会根据数据是否准备好而决定是否返回，是否可以主动去监控这个数据是否准备到了kernel buffer中呢，亦或者是否可以监控send buffer中是否有新数据进入呢？这就是select()/poll()/epoll的作用。&lt;br/&gt;(2).当使用select()时，httpd发起一个select调用，然后httpd进程被select()&quot;阻塞&quot;。由于此处假设只监控了一个请求文件，所以select()会在数据准备到kernel buffer中时直接唤醒httpd进程。之所以阻塞要加上双引号，是因为select()有时间间隔选项可用控制阻塞时长，如果该选项设置为0，则select不阻塞，此时表示立即返回但一直轮询检查是否就绪，还可以设置为永久阻塞。&lt;br/&gt;(3).当select()的监控对象就绪时，将通知(轮询情况)或唤醒(阻塞情况)httpd进程，httpd再发起read()系统调用，此时数据会从kernel buffer复制到app buffer中并read()成功。&lt;br/&gt;(4).httpd发起第二个系统调用(即read())后被阻塞，CPU全部交给内核用来复制数据到app buffer。 (5).对于httpd只处理一个连接的情况下，IO复用模型还不如blocking I/O模型，因为它前后发起了两个系统调用(即select()和read())，甚至在轮询的情况下会不断消耗CPU。但是IO复用的优势就在于能同时监控多个文件描述符。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003161011833-2056111314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更详细的说明，见本文末。&lt;/p&gt;


&lt;p&gt;即信号驱动IO模型。当开启了信号驱动功能时，首先发起一个信号处理的系统调用，如sigaction()，这个系统调用会立即返回。但数据在准备好时，会发送SIGIO信号，进程收到这个信号就知道数据准备好了，于是发起操作数据的系统调用，如read()。&lt;/p&gt;
&lt;p&gt;在发起信号处理的系统调用后，进程不会被阻塞，但是在read()将数据从kernel buffer复制到app buffer时，进程是被阻塞的。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003170515536-1404504188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;即异步IO模型。当设置为异步IO模型时，httpd首先发起异步系统调用(如aio_read()，aio_write()等)，并立即返回。这个异步系统调用告诉内核，不仅要准备好数据，还要把数据复制到app buffer中。&lt;/p&gt;
&lt;p&gt;httpd从返回开始，直到数据复制到app buffer结束都不会被阻塞。当数据复制到app buffer结束，将发送一个信号通知httpd进程。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003171529536-693464967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看上去异步很好，但是注意，在复制kernel buffer数据到app buffer中时是需要CPU参与的，这意味着不受阻的httpd会和异步调用函数争用CPU。如果并发量比较大，httpd接入的连接数可能就越多，CPU争用情况就越严重，异步函数返回成功信号的速度就越慢。如果不能很好地处理这个问题，异步IO模型也不一定就好。&lt;/p&gt;


&lt;p&gt;阻塞、非阻塞、IO复用、信号驱动都是同步IO模型。因为在发起操作数据的系统调用(如本文的read())过程中是被阻塞的。这里要注意，虽然在加载数据到kernel buffer的数据准备过程中可能阻塞、可能不阻塞，但kernel buffer才是read()函数的操作对象，同步的意思是让kernel buffer和app buffer数据同步。显然，在保持kernel buffer和app buffer同步的过程中，进程必须被阻塞，否则read()就变成异步的read()。&lt;/p&gt;
&lt;p&gt;只有异步IO模型才是异步的，因为发起的异步类的系统调用(如aio_read())已经不管kernel buffer何时准备好数据了，就像后台一样read一样，aio_read()可以一直等待kernel buffer中的数据，在准备好了之后，aio_read()自然就可以将其复制到app buffer。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003173821255-973748186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;前面说了，这三个函数是文件描述符状态监控的函数，它们可以监控一系列文件的一系列事件，当出现满足条件的事件后，就认为是就绪或者错误。事件大致分为3类：可读事件、可写事件和异常事件。它们通常都放在循环结构中进行循环监控。&lt;/p&gt;
&lt;p&gt;select()和poll()函数处理方式的本质类似，只不过poll()稍微先进一点，而epoll处理方式就比这两个函数先进多了。当然，就算是先进分子，在某些情况下性能也不一定就比老家伙们强。&lt;/p&gt;

&lt;h2 id=&quot;3-1-select-poll-&quot;&gt;3.1 select() &amp;amp; poll()&lt;/h2&gt;
&lt;p&gt;首先，通过FD_SET宏函数创建待监控的描述符集合，并将此描述符集合作为select()函数的参数，可以在指定select()函数阻塞时间间隔，于是select()就创建了一个监控对象。&lt;/p&gt;
&lt;p&gt;除了普通文件描述符，还可以监控套接字，因为套接字也是文件，所以select()也可以监控套接字文件描述符，例如recv buffer中是否收到了数据，也即监控套接字的可读性，send buffer中是否满了，也即监控套接字的可写性。select()默认最大可监控1024个文件描述符。而poll()则没有此限制。&lt;/p&gt;
&lt;p&gt;select()的时间间隔参数分3种：&lt;br/&gt;(1).设置为指定时间间隔内阻塞，除非之前有就绪事件发生。&lt;br/&gt;(2).设置为永久阻塞，除非有就绪事件发生。&lt;br/&gt;(3).设置为完全不阻塞，即立即返回。但因为select()通常在循环结构中，所以这是轮询监控的方式。&lt;/p&gt;
&lt;p&gt;当创建了监控对象后，由内核监控这些描述符集合，于此同时调用select()的进程被阻塞(或轮询)。当监控到满足就绪条件时(监控事件发生)，select()将被唤醒(或暂停轮询)，于是select()返回&lt;strong&gt;满足就绪条件的描述符数量&lt;/strong&gt;，之所以是数量而不仅仅是一个，是因为多个文件描述符可能在同一时间满足就绪条件。由于只是返回数量，并没有返回哪一个或哪几个文件描述符，所以通常在使用select()之后，还会在循环结构中的if语句中使用宏函数FD_ISSET进行遍历，直到找出所有的满足就绪条件的描述符。最后将描述符集合通过指定函数拷贝回用户空间，以便被进程处理。&lt;/p&gt;
&lt;p&gt;监听描述符集合的大致过程如下图所示，其中select()只是其中的一个环节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733013/201710/733013-20171003204930115-1866349421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概描述下这个循环监控的过程：&lt;/p&gt;
&lt;p&gt;(1).首先通过FD_ZERO宏函数初始化描述符集合。图中每个小方格表示一个文件描述符。&lt;br/&gt;(2).通过FD_SET宏函数创建描述符集合，此时集合中的文件描述符都被打开，也就是稍后要被select()监控的对象。&lt;br/&gt;(3).使用select()函数监控描述符集合。当某个文件描述符满足就绪条件时，select()函数返回集合中满足条件的数量。图中标黄色的小方块表示满足就绪条件的描述符。&lt;br/&gt;(4).通过FD_ISSET宏函数遍历整个描述符集合，并将满足就绪条件的描述符发送给进程。同时，使用FD_CLR宏函数将满足就绪条件的描述符从集合中移除。&lt;br/&gt;(5).进入下一个循环，继续使用FD_SET宏函数向描述符集合中添加新的待监控描述符。然后重复(3)、(4)两个步骤。&lt;/p&gt;
&lt;p&gt;如果使用简单的伪代码来描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FD_ZERO
&lt;span class=&quot;hljs-function&quot;&gt;for&lt;/span&gt;() {
    &lt;span class=&quot;hljs-function&quot;&gt;FD_SET&lt;/span&gt;()
    &lt;span class=&quot;hljs-function&quot;&gt;select&lt;/span&gt;()
    &lt;span class=&quot;hljs-function&quot;&gt;if&lt;/span&gt;(){
        &lt;span class=&quot;hljs-function&quot;&gt;FD_ISSET&lt;/span&gt;()
        &lt;span class=&quot;hljs-function&quot;&gt;FD_CLR&lt;/span&gt;()
    }
    &lt;span class=&quot;hljs-function&quot;&gt;writen&lt;/span&gt;()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上所说只是一种需要循环监控的示例，具体如何做却是不一定的。不过从中也能看出这一系列的流程。&lt;/p&gt;

&lt;h2 id=&quot;3-2-epoll&quot;&gt;3.2 epoll&lt;/h2&gt;
&lt;p&gt;epoll比poll()、select()先进，考虑以下几点，自然能看出它的优势所在：&lt;/p&gt;
&lt;p&gt;(1).epoll_create()创建的epoll实例可以随时通过epoll_ctl()来新增和删除感兴趣的文件描述符，不用再和select()每个循环后都要使用FD_SET更新描述符集合的数据结构。&lt;br/&gt;(2).在epoll_create()创建epoll实例时，还创建了一个epoll就绪链表list。而epoll_ctl()每次向epoll实例添加描述符时，还会注册该描述符的回调函数。当epoll实例中的描述符满足就绪条件时将触发回调函数，被移入到就绪链表list中。&lt;br/&gt;(3).当调用epoll_wait()进行监控时，它只需确定就绪链表中是否有数据即可，如果有，将复制到用户空间以被进程处理，如果没有，它将被阻塞。当然，如果监控的对象设置为非阻塞模式，它将不会被阻塞，而是不断地去检查。&lt;/p&gt;
&lt;p&gt;也就是说，epoll的处理方式中，根本就无需遍历描述符集合。&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7624733.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/7624733.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/h3&gt;
</description>
<pubDate>Tue, 03 Oct 2017 14:41:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/7624733.html</dc:identifier>
</item>
<item>
<title>HashTable —— 线程安全的散列表 - romanjoy</title>
<link>http://www.cnblogs.com/romanjoy/p/7251203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/romanjoy/p/7251203.html</guid>
<description>&lt;p&gt;HashTable 的一些认识：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;　　底层使用散列表，存贮键值对，键值非null&lt;/li&gt;
&lt;li&gt;       使用synchronize 保证线程安全&lt;/li&gt;
&lt;li&gt;　　如果多线程高发量，推荐使用 concurrentHashMap；如无需多线程，可使用 HashMap&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;■ 重要全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The hash table data.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;底层维护一个Entry(键值对)数组&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;[] table;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The total number of entries in the hash table.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素总量，等同于HashMap的size&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The load factor for the hashtable.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载因子&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * The table is rehashed when its size exceeds this threshold.
 * (The value of this field is (int)(capacity * loadFactor).)
 * 超过阈值进行rehash
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * The number of times this Hashtable has been structurally modified
  * Structural modifications are those that change the number of entries in
  * the Hashtable or otherwise modify its internal structure (e.g.,
  * rehash).  This field is used to make iterators on Collection-views of
  * the Hashtable fail-fast.  (See ConcurrentModificationException).
  * 结构性变动时modCount计数+1，用于遍历时的fail-fast机制生效
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;■ &lt;/span&gt;构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a new, empty hashtable with the specified initial
     * capacity and the specified load factor.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Hashtable(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;span&gt;
                                               initialCapacity);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Load: &quot;+&lt;span&gt;loadFactor);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity==0&lt;span&gt;)
            initialCapacity &lt;/span&gt;= 1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有强调2次幂，cap为0时，默认是1&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;&lt;span&gt;[initialCapacity];
        threshold &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1&lt;span&gt;);
    }

   
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs a new, empty hashtable with a default initial capacity (11)
     * and load factor (0.75).
     * 容量11，负载因子 0.75
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Hashtable() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(11, 0.75f&lt;span&gt;);
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■主要方法&lt;/p&gt;
&lt;p&gt;   - put(K key, V value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make sure the value is not null，而HashMap选择将key为null永远存放为table[0]位置&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Makes sure the key is not already in the hashtable.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保key不在hashtable中
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value&lt;/span&gt;
    Entry tab[] =&lt;span&gt; table;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算下标，这里使用%方法，性能远不及HashMap的位运算 (这也是不推荐使用HashTable的原因之一)&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = tab[index] ; e != &lt;span&gt;null&lt;/span&gt; ; e =&lt;span&gt; e.next) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接使用equals比较，而HashMap多了一层地址比较 `((k = e.key) == key || key.equals(k))`&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((e.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; e.key.equals(key)) {
            V old &lt;/span&gt;=&lt;span&gt; e.value;
            e.value &lt;/span&gt;=&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
        }
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构性变更操作 modCount计数+1&lt;/span&gt;
    modCount++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HashMap选择新增addEntry方法封装一下逻辑&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (count &amp;gt;=&lt;span&gt; threshold) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rehash the table if the threshold is exceeded
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果超过阀值，就进行rehash操作&lt;/span&gt;
&lt;span&gt;        rehash();
        tab &lt;/span&gt;=&lt;span&gt; table;
        hash &lt;/span&gt;=&lt;span&gt; hash(key);
        index &lt;/span&gt;= (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Creates the new entry.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将值插入，返回的为null&lt;/span&gt;
    Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; tab[index];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素&lt;/span&gt;
    tab[index] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size++&lt;/span&gt;
    count++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;- get(Object key)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Entry tab[] &lt;/span&gt;=&lt;span&gt; table;   //临时拷贝，保证数据的时效性
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = tab[index] ; e != &lt;span&gt;null&lt;/span&gt; ; e =&lt;span&gt; e.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; e.key.equals(key)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ■ HashTable 遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by roman on 2017/10/03.
 *【2017 java's day】
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListHashTableTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Hashtable&lt;/span&gt;&amp;lt;String, Object&amp;gt; hb = &lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;String, Object&amp;gt;&lt;span&gt;();
        hb.put(&lt;/span&gt;&quot;1&quot;, &quot;Java&quot;&lt;span&gt;);
        hb.put(&lt;/span&gt;&quot;flag&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        hb.put(&lt;/span&gt;&quot;age&quot;, 44&lt;span&gt;);

        Iterator iterator &lt;/span&gt;=&lt;span&gt; hb.keySet().iterator();
        iterator.forEachRemaining(value &lt;/span&gt;-&amp;gt;&lt;span&gt; System.out.println(hb.get(value)));  //使用了lamda
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ HashTable VS HashMap&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作.&lt;/li&gt;
&lt;li&gt;HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理(统一放入table[0]位置)，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException.&lt;/li&gt;
&lt;li&gt;Hashtable 方法是同步，而HashMap则不是。Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。&lt;/li&gt;
&lt;li&gt;HashTable由于使用sync和%运算(以及相关算法实现)的缘故，相比于HashMap，性能较低，因此非常不推荐继续使用HashTable。&lt;/li&gt;
&lt;li&gt;非竞争环境下推荐使用HashMap。&lt;/li&gt;
&lt;li&gt;多线程环境下推荐使用ConcurrentHashMap。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 03 Oct 2017 13:48:00 +0000</pubDate>
<dc:creator>romanjoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/romanjoy/p/7251203.html</dc:identifier>
</item>
<item>
<title>Hive简记 - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/Hive.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/Hive.html</guid>
<description>&lt;p&gt;在大数据工作中难免遇到数据仓库(OLAP)架构，以及通过Hive SQL简化分布式计算的场景。所以想通过这篇博客对Hive使用有一个大致总结，希望道友多多指教！&lt;/p&gt;
&lt;p&gt;摘要：&lt;/p&gt;
&lt;p&gt;　　1.Hive安装&lt;/p&gt;
&lt;p&gt;　　2.Hive DDL命令&lt;/p&gt;
&lt;p&gt;　　3.Hive DML初步&lt;/p&gt;
&lt;p&gt;　　4.Hive DML高级&lt;/p&gt;
&lt;p&gt;　　5.Hive 优化与配置参数&lt;/p&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;p&gt;　　1.Hive安装&lt;/p&gt;
&lt;p&gt;　　依赖：mysql,jdk,hadoop&lt;/p&gt;
&lt;p&gt;　　安装文档参考：&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/GettingStarted#GettingStarted-InstallationandConfiguration&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;；注意这里hive默认使用Derby数据库，只支持单用户登录。修改具体配置请参考官网说明：&lt;/p&gt;
&lt;h3 id=&quot;GettingStarted-MetadataStore&quot;&gt;Metadata Store&lt;/h3&gt;
&lt;p&gt;Metadata is in an embedded Derby database whose disk storage location is determined by the Hive configuration variable named &lt;code&gt;javax.jdo.option.ConnectionURL&lt;/code&gt;. By default this location is &lt;code&gt;./metastore_db&lt;/code&gt; (see &lt;code&gt;conf/hive-default.xml&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Right now, in the default configuration, this metadata can only be seen by one user at a time.&lt;/p&gt;
&lt;p&gt;Metastore can be stored in any database that is supported by JPOX. The location and the type of the RDBMS can be controlled by the two variables &lt;code&gt;javax.jdo.option.ConnectionURL&lt;/code&gt; and &lt;code&gt;javax.jdo.option.ConnectionDriverName&lt;/code&gt;. Refer to JDO (or JPOX) documentation for more details on supported databases. The database schema is defined in JDO metadata annotations file &lt;code&gt;package.jdo&lt;/code&gt; at &lt;code&gt;src/contrib/hive/metastore/src/model&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the future, the metastore itself can be a standalone server.&lt;/p&gt;
&lt;p&gt;If you want to run the metastore as a network server so it can be accessed from multiple nodes, see &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/HiveDerbyServerMode&quot;&gt;Hive Using Derby in Server Mode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt; 　　2.Hive DDL命令&lt;/p&gt;
&lt;p&gt;　　建表语句：&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td class=&quot;code&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot; readability=&quot;61&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.14&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;and later)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[(col_name data_type [COMMENT col_comment], ... [constraint_specification])]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[COMMENT table_comment]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]  --分区&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] --分桶&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.10&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;and later)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[STORED AS DIRECTORIES]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[　　　　　　　　　　　　　　　　--存储格式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;   &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[ROW FORMAT row_format] 　　　　　&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;   &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[STORED AS file_format]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;| STORED BY &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'storage.handler.class.name'&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;[WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;and later)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[LOCATION hdfs_path]　　　　　　--外部表指定存储路径&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;and later)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[AS select_statement];   -- (Note: Available in Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;and later; not supported &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;external tables)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name　　--复制表&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;LIKE existing_table_or_view_name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[LOCATION hdfs_path];&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　删除表：DROP TABLE [IF EXISTS] table_name [PURGE];&lt;/p&gt;
&lt;p&gt;　　截断表：TRUNCATE TABLE table_name [PARTITION partition_spec];&lt;/p&gt;
&lt;p&gt;　　查看表结构：&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;　　DESCRIBE [EXTENDED|FORMATTED] &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;table_name[.col_name ( [.field_name] | [.&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'$elem$'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;] | [.&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'$key$'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;] | [.&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'$value$'&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;] )* ];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　3.Hive DML初步&lt;/p&gt;
&lt;p&gt;　　加载数据到Hive表：&lt;code class=&quot;java plain&quot;&gt;LOAD DATA [LOCAL] INPATH &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;'filepath'&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;[OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;line number3 index2 alt2&quot; readability=&quot;24.512003589859&quot;&gt;　　插入数据：
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;　　INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...) [IF NOT EXISTS]] select_statement1 FROM from_statement;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;　　INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;code class=&quot;java plain&quot;&gt;INSERT INTO TABLE tablename [PARTITION (partcol1[=val1], partcol2[=val2] ...)] VALUES ( value [, value ...] ) [, ( value [, value ...] )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　Hive数据导出&lt;/p&gt;
&lt;div class=&quot;line number3 index2 alt2&quot; readability=&quot;15.652434456929&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;　　INSERT OVERWRITE [LOCAL] DIRECTORY directory1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;[ROW FORMAT row_format] [STORED AS file_format] (Note: Only available starting with Hive &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.11&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;SELECT ... FROM ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　更新数据：UPDATE tablename SET column = value [, column = value ...] [WHERE expression]&lt;/p&gt;
&lt;p&gt;　　删除数据：DELETE FROM tablename [WHERE expression]&lt;/p&gt;
&lt;p&gt;　　查询数据：&lt;/p&gt;
&lt;div class=&quot;line number4 index3 alt1&quot; readability=&quot;8.4254807692308&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ALL | DISTINCT&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; select_expr, select_expr, ...
  &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; table_reference
  &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;WHERE where_condition&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;[&lt;/span&gt;&lt;span&gt;GROUP BY col_list&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ORDER BY col_list&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;[&lt;/span&gt;&lt;span&gt;CLUSTER BY col_list
    | [DISTRIBUTE BY col_list&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;SORT BY col_list&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
  ]
 &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;LIMIT [offset,&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; rows]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Hive内置函数&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;52.004113345521&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;year(string date)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Return the year part of a date or a timestamp string: year(&quot;1970-01-01 00:00:00&quot;) = 1970, year(&quot;1970-01-01&quot;) = 1970&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;upper(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from converting all characters of A to upper case, for example, upper('fOoBaR') results in 'FOOBAR'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ucase(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Same as upper&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;trim(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from trimming spaces from both ends of A, for example, trim(' foobar ') results in 'foobar'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;to_date(string timestamp)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Return the date part of a timestamp string: to_date(&quot;1970-01-01 00:00:00&quot;) = &quot;1970-01-01&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;substr(string A, int start, int length)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;10&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the substring of A starting from start position with the given length, for example, &lt;br/&gt;substr('foobar', 4, 2) results in 'ba'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;substr(string A, int start)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the substring of A starting from start position till the end of string A. For example, substr('foobar', 4) results in 'bar'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;size(Map&amp;lt;K.V&amp;gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the number of elements in the map type&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;size(Array&amp;lt;T&amp;gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the number of elements in the array type&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;rtrim(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from trimming spaces from the end(right hand side) of A. For example, rtrim(' foobar ') results in ' foobar'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;BIGINT&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;round(double a)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the rounded BIGINT value of the double&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.598513011152&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;regexp_replace(string A, string B, string C)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8.5714285714286&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from replacing all substrings in B that match the Java regular expression syntax(See &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html&quot;&gt;Java regular expressions syntax&lt;/a&gt;) with C. For example, regexp_replace('foobar', 'oo|ar', ) returns 'fb'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;double&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;rand(), rand(int seed)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns a random number (that changes from row to row). Specifiying the seed will make sure the generated random number sequence is deterministic.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;month(string date)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Return the month part of a date or a timestamp string: month(&quot;1970-11-01 00:00:00&quot;) = 11, month(&quot;1970-11-01&quot;) = 11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ltrim(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from trimming spaces from the beginning(left hand side) of A. For example, ltrim(' foobar ') results in 'foobar '&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;lower(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from converting all characters of B to lower case, for example, lower('fOoBaR') results in 'foobar'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;lcase(string A)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Same as lower&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;get_json_object(string json_string, string path)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Extract json object from a json string based on json path specified, and return json string of the extracted json object. It will return null if the input json string is invalid.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;from_unixtime(int unixtime)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;convert the number of seconds from the UNIX epoch (1970-01-01 00:00:00 UTC) to a string representing the timestamp of that moment in the current system time zone in the format of &quot;1970-01-01 00:00:00&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;BIGINT&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;floor(double a)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the maximum BIGINT value that is equal or less than the double&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;int&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;day(string date)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Return the day part of a date or a timestamp string: day(&quot;1970-11-01 00:00:00&quot;) = 1, day(&quot;1970-11-01&quot;) = 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;concat(string A, string B,...)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the string resulting from concatenating B after A. For example, concat('foo', 'bar') results in 'foobar'. This function accepts arbitrary number of arguments and return the concatenation of all of them.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;BIGINT&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;ceil(double a)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;returns the minimum BIGINT value that is equal or greater than the double&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 03 Oct 2017 13:45:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arachis/p/Hive.html</dc:identifier>
</item>
<item>
<title>Java并发/多线程系列——线程安全篇（1） - bug-zhang</title>
<link>http://www.cnblogs.com/bug-zhang/p/7624254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bug-zhang/p/7624254.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Java线程是个对象，和其他任何的Java对象一样。&lt;/span&gt;&lt;span&gt;线程是类的实例&lt;/span&gt;&lt;/span&gt;&lt;code&gt;java.lang.Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;，或&lt;/span&gt;&lt;span&gt;该类&lt;/span&gt;&lt;span&gt;的子类的实例。&lt;/span&gt;&lt;span&gt;除了对象之外，java线程还可以执行代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;创建和启动线程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在Java中创建一个线程是这样完成的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Thread thread = &lt;span&gt;new&lt;/span&gt; Thread();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要启动Java线程，您将调用其start（）方法，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
thread.start();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此示例不指定要执行的线程的任何代码。&lt;/span&gt;&lt;span&gt;启动后，线程将立即停止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有两种方法来指定线程应该执行什么代码。&lt;/span&gt;&lt;span&gt;第一个是继承Thread类并覆盖&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;第二种方法是实现&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt; （&lt;/span&gt;&lt;code&gt;java.lang.Runnable&lt;/code&gt;&lt;span&gt;对 &lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;构造函数）&lt;/span&gt;&lt;span&gt;的接口，&lt;/span&gt;&lt;span&gt;这两个方法都在下面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;继承Thread&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建线程的第一种方法是创建Thread的子类并覆盖该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法。当执行start()方法后，会另起一个线程调用&lt;/span&gt;&lt;span&gt;该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;以下是创建Java &lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;span&gt;的示例&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
     System.out.println(&quot;MyThread running&quot;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MyThread myThread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
myTread.start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;start()&lt;/code&gt;&lt;span&gt;&lt;span&gt;一旦线程启动，&lt;/span&gt;&lt;span&gt; 该&lt;/span&gt;&lt;span&gt;调用将返回。&lt;/span&gt;&lt;span&gt;它不会等到&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法完成。&lt;/span&gt;&lt;span&gt;该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法将像执行不同的CPU一样执行。&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法执行时，它将打印出文本“MyThread running”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;你也可以创建一个这样的匿名子类的&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Thread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
    System.out.println(&quot;Thread Running&quot;);
  }
}

thread.start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此示例将打印出文本“Thread running” &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;实现Runnable接口&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建线程的第二种方法是创建一个&lt;/span&gt;&lt;/span&gt;&lt;code&gt;java.lang.Runnable接口的实现类&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;该实现类&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;可以通过一个被执行&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
     System.out.println(&lt;/span&gt;&quot;MyRunnable running&quot;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;要执行run()方法，需要创建拥有MyRunnable实例的Thread对象，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable());
thread.start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;当线程启动时，它将调用&lt;code&gt;MyRunnable&lt;/code&gt;&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;上面的例子将打印出文本“MyRunnable running”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;您还可以创建一个匿名实现&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;，像这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Runnable myRunnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
      System.out.println(&lt;/span&gt;&quot;Runnable running&quot;&lt;span&gt;);
   }
 }

Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(myRunnable);
thread.start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;继承Thread父类还是实现Runnable接口？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这两种方法没有说哪一种是最好的，这&lt;/span&gt;&lt;span&gt;两种方法都有效。&lt;/span&gt;&lt;span&gt;我个人而言，我更喜欢使用&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;&lt;span&gt;，并将&lt;/span&gt;&lt;span&gt;实现的&lt;/span&gt;&lt;span&gt;一个实例移交给一个&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例。&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;通过线程池&lt;/span&gt;&lt;span&gt;&lt;span&gt;执行该操作时&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;&lt;span&gt; 实例很容易列入队列中，直到来自池的线程空闲时再运行run()方法。而&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread的&lt;/code&gt;&lt;span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;span&gt;就难于实现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时你可能需要实现&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;和子类&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;例如，创建一个子类&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;可以执行多个&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;实现线程池时通常是这种情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;常见的陷阱：调用run()而不是start()&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当创建和启动一个线程时，一个常见的错误是调用&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;而不是&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;的&lt;code&gt;start()，&lt;/code&gt;&lt;span&gt;&lt;span&gt;像这样：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread newThread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(MyRunnable());
newThread.run（）; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应该是start（）;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;起初你可能不会注意到这样会发生错误，因为它&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Runnable&lt;/code&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法是像你预期的那样执行。&lt;/span&gt;&lt;span&gt;但是，它不是刚刚创建的新线程执行。&lt;/span&gt;&lt;span&gt;相反，该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;run()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法由创建线程的线程执行。&lt;/span&gt;&lt;span&gt;换句话说，执行上述两行代码的线程。&lt;/span&gt;&lt;span&gt;要&lt;/span&gt;&lt;span&gt;由新创建的线程去调用&lt;/span&gt;&lt;/span&gt;&lt;code&gt;MyRunnable&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例的&lt;code&gt;run()&lt;/code&gt;&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，你必须通过&lt;/span&gt;&lt;/span&gt;&lt;code&gt;newThread.start()&lt;/code&gt;&lt;span&gt;&lt;span&gt;去调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;线程名称&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;创建Java线程时，可以给它一个名称。&lt;/span&gt;&lt;span&gt;该名称可以帮助您区分不同的线程。&lt;/span&gt;&lt;span&gt;例如，如果多个线程写入&lt;/span&gt;&lt;/span&gt;&lt;code&gt;System.out，&lt;/code&gt;&lt;span&gt;&lt;span&gt;它可以方便地查看哪个线程写了文本。两种不同的创建线程方式的&lt;/span&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Thread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(&quot;New Thread&quot;){
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
      System.out.println(&quot;run by：&quot; &lt;/span&gt;+&lt;span&gt; getName());
   }
};


thread.start();
System.out.println(thread.getName());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MyRunnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable();
Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(runnable, &quot;New Thread&quot;&lt;span&gt;);

thread.start();
System.out.println(thread.getName());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是请注意，由于&lt;/span&gt;&lt;/span&gt;&lt;code&gt;MyRunnable&lt;/code&gt;&lt;span&gt;&lt;span&gt;类不是 &lt;/span&gt;&lt;/span&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;span&gt;&lt;span&gt;的子类，所以它无法通过执行&lt;/span&gt;&lt;/span&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;span&gt;&lt;span&gt;去获取线程名字&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;获取当前线程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;Thread.currentThread()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法能够返回当前线程的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;实例，这样你就可以获取到当前线程中你想得到的东西。例如，您可以获取当前执行代码的线程的名称，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Thread thread =&lt;span&gt; Thread.currentThread();
String threadName &lt;/span&gt;= Thread.currentThread().getName();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Java Thread示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这是一个小例子。&lt;/span&gt;&lt;span&gt;首先打印执行该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;main()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;的线程的名称&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;该线程由JVM分配。&lt;/span&gt;&lt;span&gt;然后它启动10个线程，并给它们全部一个数字作为name(&quot;&quot; &lt;/span&gt;&lt;/span&gt;&lt;code&gt;+ i)&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;然后每个线程将其名称输出，然后停止执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadExample {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(Thread.currentThread().getName());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;10; i ++&lt;span&gt;){
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&quot;&quot; +&lt;span&gt; i){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
              System.out.println(&lt;/span&gt;&quot;Thread：&quot; + getName() +&quot;running&quot;&lt;span&gt;);
            }
          }.start();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;请注意，即使线程按顺序（1,2,3...）启动，它们可能不会按顺序执行，这意味着线程0可能不是第一个用&lt;/span&gt;&lt;/span&gt;&lt;code&gt;System.out&lt;/code&gt;&lt;span&gt;&lt;span&gt;把线程名称输出的。&lt;/span&gt;&lt;span&gt;这是因为线程原则上是并行执行而不是顺序执行的。&lt;/span&gt;&lt;span&gt;JVM操作系统决定执行线程的顺序。每次运行结果会不相同，因此&lt;/span&gt;&lt;span&gt;这个顺序不一定是他们的执行顺序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;竞争条件是在临界区内可能出现的一种特殊情况。临界区是一种轻量级机制，在某一时间内只允许一个线程执行某个给定代码段&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当多线程在临界区执行时，执行结果可能会根据线程执行的顺序而有所不同，临界区被称为包含竞争条件。&lt;/span&gt;&lt;span&gt;竞争条件一词来自比喻，即线程正在通过临界区时进行赛跑，而竞争的结果影响了执行临界区的结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这可能听起来有点复杂，所以我将在以下部分详细阐述竞争条件和临界区。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;临界区&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在同一应用程序中运行多个线程本身不会导致问题。&lt;/span&gt;&lt;span&gt;当多个线程访问相同的资源时，就会出现问题。&lt;/span&gt;&lt;span&gt;例如多个线程同时访问相同的内存（变量，数组或对象），系统（数据库，Web服务等）或文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;事实上，只有一个或多个线程写入这些资源时才会出现问题。&lt;/span&gt;&lt;span&gt;只要资源不变，可以安全地让多个线程读取相同的资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以下是一个临界区的代码示例，如果多个线程同时执行，则可能会失败：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter {

   &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; count = 0&lt;span&gt;;

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; value){
       &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count = &lt;span&gt;this&lt;/span&gt;.count +&lt;span&gt; value;
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;想象一下，如果两个线程A和B正在同一个&lt;/span&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;span&gt;&lt;span&gt;类的&lt;/span&gt;&lt;span&gt;实例上执行add方法&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;没有办法知道操作系统何时在两个线程之间切换。&lt;/span&gt;&lt;span&gt;该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法中&lt;/span&gt;&lt;span&gt;的代码&lt;/span&gt;&lt;span&gt;不会作为Java虚拟机的单个原子指令执行。&lt;/span&gt;&lt;span&gt;相反，它作为一组较小的指令执行，类似于此：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;把这个记录从内存读入注册表。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;添加值进行注册。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;写入寄存器到内存&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;观察以下的线程A和B的混合执行会发生什么：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;this&lt;/span&gt;.count = 0&lt;span&gt;;

A：把这个记录读入一个寄存器（&lt;/span&gt;0&lt;span&gt;）
B：将此记录读入注册表（&lt;/span&gt;0&lt;span&gt;）
B：添加值2进行注册
B：将寄存器值（&lt;/span&gt;2）写入内存。&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count现在等于2
A：添加值3进行注册
A：将寄存器值（&lt;/span&gt;3）写入内存。&lt;span&gt;this&lt;/span&gt;.count现在等于3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;两个线程想要将值2和3添加到计数器。&lt;/span&gt;&lt;span&gt;因此，两个线程完成执行后的值应该是5。&lt;/span&gt;&lt;span&gt;然而，由于两个线程同时执行，所以结果会有所不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在上面列出的执行顺序示例中，两个线程从内存中读取值0。&lt;/span&gt;&lt;span&gt;然后，他们将它们的个人值2和3添加到值中，并将结果写回内存。&lt;/span&gt;&lt;span&gt;而不是5，剩下的值 &lt;/span&gt;&lt;/span&gt;&lt;code&gt;this.count&lt;/code&gt;&lt;span&gt;&lt;span&gt;将是最后一个线程写入其值的值。&lt;/span&gt;&lt;span&gt;在上面的情况下，它是线程A，但也可能是线程B.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;临界区的竞争条件&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上例中的add()方法就包含临界区，当多个线程执行此临界区时，会发生竞争条件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;多个线程竞争相同资源时，其中访问资源的顺序是重要的，称为竞争条件。&lt;/span&gt;&lt;span&gt;导致竞争条件的代码部分称为临界区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;防止竞争条件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;为了防止发生竞争条件，您必须确保临界区作为原子命令执行。这意味着一旦一个线程正在执行它，就不能有其他线程可以执行它，直到第一个线程离开临界区。&lt;/p&gt;
&lt;p&gt;临界区的竞争条件可以通过适当的线程同步来避免。可以使用Java代码的同步块来实现线程同步。线程同步也可以使用其他同步结构（如锁或原子变量，如java.util.concurrent.atomic.AtomicInteger）来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TwoSums {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum1 = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum2 = 0&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; val1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val2){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sum1 +=&lt;span&gt; val1;   
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sum2 +=&lt;span&gt; val2;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，由于两个和变量是相互独立的，所以您可以将它们的求和分解为两个单独的同步块，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TwoSums {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum1 = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum2 = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Integer sum1Lock = &lt;span&gt;new&lt;/span&gt; Integer(1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Integer sum2Lock = &lt;span&gt;new&lt;/span&gt; Integer(2&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; val1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val2){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sum1Lock){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sum1 +=&lt;span&gt; val1;   
        }
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sum2Lock){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sum2 +=&lt;span&gt; val2;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在两个线程可以同时执行该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;两个同步块在不同的对象上同步，因此两个不同的线程可以独立执行两个块。&lt;/span&gt;&lt;span&gt;这样线程将就有较少的等待去执行&lt;/span&gt;&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个例子当然很简单。&lt;/span&gt;&lt;span&gt;在现实生活中的共享资源中，临界区的分解可能会更复杂一些，并且需要更多的分析执行顺序的可能性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;多线程同时安全地调用被称为&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;线程安全&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;如果一段代码是线程安全的，那么它不包含任何&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/bug-zhang/p/7624254.html#race&quot;&gt;&lt;span&gt;&lt;span&gt;竞争条件&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;竞争条件仅在多个线程更新共享资源时发生。&lt;/span&gt;&lt;span&gt;因此，重要的是要知道什么共享资源会被多线程同时执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;局部变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;局部变量存储在每个线程自己的堆栈中。&lt;/span&gt;&lt;span&gt;这意味着局部变量从不在线程之间共享。&lt;/span&gt;&lt;span&gt;这也意味着所有本地变量基本上都是线程安全的。&lt;/span&gt;&lt;span&gt;以下是本地变量的线程安全的示例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; someMethod(){

  &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; threadSafeInt = 0&lt;span&gt;;

  threadSafeInt&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;本地对象的引用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;引用本身不是共享的。&lt;/span&gt;&lt;span&gt;但是，引用的对象不存储在每个线程的本地堆栈中，&lt;/span&gt;&lt;span&gt;所有对象都存储在共享堆中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果本地创建的对象永远不会通过创建他的方法返回，那么它是线程安全的。&lt;/span&gt;&lt;span&gt;实际上，只要没有让对象在方法之间传递后用于其他线程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个线程安全的本地对象的示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; someMethod(){

  LocalObject localObject &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LocalObject();

  localObject.callMethod();
  method2(localObject);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method2(LocalObject localObject){
  localObject.setValue(&lt;/span&gt;&quot;value&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面这个例子，someMethod()这个方法没有将LocalObject传递出去，而是每个线程调用someMethod()都会创建一个新的LocalObject，并在自己的方法内部消化，所以这里是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;对象成员变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对象成员变量与对象一起存储在堆上。&lt;/span&gt;&lt;span&gt;因此，如果两个线程调用同一对象实例上的方法，并且此方法更新该对象的成员变量，则该方法是线程不安全的。&lt;/span&gt;&lt;span&gt;这是一个线程不安全的例子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NotThreadSafe{
    StringBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; add(String text){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.builder.append(text);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果两个线程&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在同一个NotThreadSafe实例上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;同时&lt;/span&gt;&lt;span&gt;调用add()&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;那么它会导致竞争条件。&lt;/span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
NotThreadSafe sharedInstance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotThreadSafe();

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable(sharedInstance)).start();
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable(sharedInstance)).start();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
  NotThreadSafe instance &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyRunnable(NotThreadSafe instance){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.instance =&lt;span&gt; instance;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.instance.add(&quot;some text&quot;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是，如果两个线程&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在不同的实例上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;同时&lt;/span&gt;&lt;span&gt;调用add()&lt;/span&gt;&lt;span&gt;方法 &lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;那么它们不会产生竞争条件。&lt;/span&gt;&lt;span&gt;把上面的例子稍加修改：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; MyRunnable(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotThreadSafe())).start();
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; MyRunnable(&lt;span&gt;new&lt;/span&gt; NotThreadSafe())).start();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;现在这两个线程都拥有自己的实例对象，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;所以他们调用add方法时不会互相干扰。&lt;/span&gt;&lt;span&gt;代码没有竞争条件了。&lt;/span&gt;&lt;span&gt;所以即使一个对象是线程不安全的，它仍然可以以不会导致竞争条件的方式运行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-线程控制逃离准则the-thread-control-escape-rule&quot;&gt;线程控制逃离准则（The Thread Control Escape Rule）&lt;/h2&gt;
&lt;p&gt;为了确定你的代码对某个资源的访问是否是线程安全的，您可以使用“线程控制逃离准则”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;如果一个资源的创建、使用和回收都在同一个线程内完成的，并且从来没有逃离这个线程的控制域，那么该资源就是线程安全的

If a resource is created, used and disposed within the control of the same thread, and never escapes the control of &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; thread, the use of that resource is thread safe.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;资源可以是任何形式的共享资源，如对象，数组，文件，数据库连接，套接字等。在Java中，你并不总是明确地回收某个对象，因此“回收”意味着对该对象的引用不再使用或者置为 null。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使使用线程安全的对象，如果该对象指向一个共享资源，如文件或数据库，那么整个应用程序可能不是线程安全的。&lt;/span&gt;&lt;span&gt;例如，如果线程1和线程2都创建自己的数据库连接，连接1和连接2，则使用每个连接本身是线程安全的。&lt;/span&gt;&lt;span&gt;但是使用数据库的连接点可能不是线程安全的。&lt;/span&gt;&lt;span&gt;例如，如果两个线程执行这样的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
check &lt;span&gt;if&lt;/span&gt;&lt;span&gt; record X exists
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not, insert record X
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果两个线程同时执行，并且他们正在检查的记录X恰好是相同的记录，那么就存在两个线程都进行插入的动作。那么这就是线程不安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种情况也可能发生在对文件或者其他共享资源的操作上。因此，一定要区分一个线程所控制的对象到底是&lt;strong&gt;资源本身&lt;/strong&gt;还是&lt;strong&gt;指向资源的一个引用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;竞争条件只有在多个线程同时访问同一资源&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;且&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;多个线程同时&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;写入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;资源时才会发生。&lt;/span&gt;&lt;span&gt;如果多线程读取相同的资源，那么竞争条件&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;不会发生。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们可以通过让共享对象不可变来确保多线程永远不会更新该对象，从而保证线程安全。例如&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableValue{

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 0&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ImmutableValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ImmutableValue&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;span&gt;的属性value&lt;/span&gt;&lt;span&gt;在构造函数中赋值。&lt;/span&gt;&lt;span&gt;还要注意该没有提供setter方法。&lt;/span&gt;&lt;span&gt;一旦&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ImmutableValue&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例被创建，你不能改变它的属性value。&lt;/span&gt;&lt;span&gt;当然，您可以使用该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;getValue()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;读它&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果需要对&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ImmutableValue&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;span&gt;执行操作，&lt;/span&gt;&lt;span&gt;可以通过操作得到返回一个新的实例&lt;/span&gt;&lt;span&gt;来改变value的值，从而不改变原实例的value值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;看下面例子会更加清晰：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImmutableValue{

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 0&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ImmutableValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
  }

  
      &lt;/span&gt;&lt;strong&gt;&lt;span&gt;public&lt;/span&gt; ImmutableValue add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; valueToAdd){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ImmutableValue(&lt;span&gt;this&lt;/span&gt;.value +&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; valueToAdd);&lt;/strong&gt;
      }
  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;请注意该&lt;/span&gt;&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;返回的是一个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;新&lt;/span&gt;&lt;span&gt;实例，而不是改变自身实例的value值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实例的引用是线程不安全&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;非常重要的是，即使一个对象是不可变的，因此是线程安全，但该对象的引用可能不是线程安全的。&lt;/span&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Calculator{
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ImmutableValue currentValue = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ImmutableValue getValue(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentValue;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(ImmutableValue newValue){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentValue =&lt;span&gt; newValue;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentValue = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentValue.add(newValue);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Calculator&lt;/code&gt;&lt;span&gt;类持有一个&lt;/span&gt;&lt;code&gt;ImmutableValue&lt;/code&gt;&lt;span&gt;&lt;span&gt;实例的引用。但是Calculator&lt;/span&gt;&lt;span&gt;可以通过&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;code&gt;setValue()&lt;/code&gt;&lt;span&gt; 和&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;span&gt;来改变引用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;因此，即使&lt;/span&gt;&lt;/span&gt;&lt;code&gt;Calculator&lt;/code&gt;&lt;span&gt;&lt;span&gt;类在内部使用不可变对象ImmutableValue，但它本身不具有不变性，因此是线程不安全的。&lt;/span&gt;&lt;span&gt;换句话说：&lt;/span&gt;&lt;/span&gt;&lt;code&gt;ImmutableValue&lt;/code&gt;&lt;span&gt;该类是线程安全的，但&lt;/span&gt;&lt;strong&gt;使用它的&lt;/strong&gt;&lt;span&gt;&lt;span&gt;不是。&lt;/span&gt;&lt;span&gt;当尝试通过不变性实现线程安全性时，需要牢记这一点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了使&lt;/span&gt;&lt;code&gt;Calculator&lt;/code&gt;&lt;span&gt;类线程安全，你可以将&lt;/span&gt;&lt;code&gt;getValue()&lt;/code&gt;&lt;span&gt;， &lt;/span&gt;&lt;code&gt;setValue()&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;add()&lt;/code&gt;&lt;span&gt;方法加&lt;/span&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Oct 2017 13:12:00 +0000</pubDate>
<dc:creator>bug-zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bug-zhang/p/7624254.html</dc:identifier>
</item>
<item>
<title>云计算---openstack基础构架以及服务方式详解 - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/7624467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/7624467.html</guid>
<description>&lt;h2&gt;一：什么是openstack&lt;/h2&gt;
&lt;p&gt;       是&lt;span&gt;Rackspace&lt;/span&gt;（美国航天局）和&lt;span&gt;NASA&lt;/span&gt;（一家公司）共同发起的开源项目，他是一系列软件项目的组合。&lt;/p&gt;
&lt;p&gt;       这些项目是&lt;span&gt;松耦合&lt;/span&gt;的关系，可以进行独立的安装，启动和停止，只有在必要的时候才进行通信（优点：扩展性好，安全性高，缺点：安装和配置比较复杂）&lt;/p&gt;
&lt;h2&gt;二：openstack的主要功能组件&lt;/h2&gt;
&lt;h3&gt;1：简介&lt;/h3&gt;

&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003185940521-1308658749.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;534&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 主要分为5个不同的层次16个不同功能模块：&lt;/p&gt;
&lt;p&gt;                 Presentation【表示层】：api模块，ui模块&lt;/p&gt;
&lt;p&gt;                 Logic（Control）【逻辑控制层】：Orchostration【编排服务】，Scheduling【调度服务】，Policy【策略服务】，Image Registry【镜像注册服务】，Logging【日志服务】&lt;/p&gt;
&lt;p&gt;                 Resource【资源管理层】：Compute【计算资源管理模块】，Volume【存储资源管理模块】，Network【网络资源管理模块】&lt;/p&gt;
&lt;p&gt;                 Integration【集成层】：Billing【计量模块】，Identity【身份认证模块】&lt;/p&gt;
&lt;p&gt;                 Mabagement【管理层】：Admin【管理api】，Monitoring【监测】&lt;/p&gt;
&lt;p&gt;子项目是怎样对接起来的：&lt;/p&gt;
&lt;p&gt;                Horizon-UI服务：对应User Dashboard【云下服务给运维用户使用】和Customer Portal【给云上用户使用】&lt;/p&gt;
&lt;p&gt;                Keystone-身份认证：对应Identity&lt;/p&gt;
&lt;p&gt;                Nova-计算服务模块：Compute API，scheduling【调度服务】，policy【策略服务】和Compute【计算管理模块】以及部分Admin API&lt;/p&gt;
&lt;p&gt;               Glance-镜像服务：Image Registry【镜像注册】，Image Registry【镜像API】&lt;/p&gt;
&lt;p&gt;               Cinder【块存储】/swift【网络对象存储】-存储服务：volume【存储资源管理模块】&lt;/p&gt;
&lt;p&gt;               Neutron-网络服务：Network【网络资源管理模块】&lt;/p&gt;
&lt;p&gt;               Heat-编排组织服务：Orchostration【编排服务】&lt;/p&gt;
&lt;p&gt;               Ceilometer-监控计量服务：Billing【计量模块】，，Monitoring【监测】&lt;/p&gt;
&lt;h3&gt;2：Horizon-UI模块&lt;/h3&gt;
&lt;p&gt;              &lt;span&gt;主要服务为openstack用户提供UI服务&lt;span&gt;，也就是负责用户在管理控制台上的所有操作转化为后台API的调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;              用户：&lt;span&gt;云管理员&lt;/span&gt;【负责整个云平台的运营，资源管理和分配】，&lt;span&gt;普通云用户&lt;/span&gt;【在配额范围内，自由操作，使用资源】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                        云管理员界面：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                        &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003193220599-1393619962.png&quot; alt=&quot;&quot; width=&quot;1169&quot; height=&quot;286&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3：Keystone-身份认证模块&lt;/h3&gt;
&lt;p&gt;              &lt;span&gt;主要负责openstack中的身份认证和权限控制&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;              User：即用户，代表可以通过keystone进行访问的人或者程序，User通过认证信息（如密码，api Key等）进行验证&lt;/p&gt;
&lt;p&gt;              Tenant：即租户，它是各个服务中的一些可以访问的资源集合&lt;/p&gt;
&lt;p&gt;              Role：即角色，代表一组用户可以访问资源的权限&lt;/p&gt;
&lt;p&gt;              &lt;span&gt;一家人【租户】租用了一百平米的房子【角色权限】那么这家人每个人【用户】的管理权限是不同的，父母比孩子的管理权限大。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003194449318-1253826013.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;    &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003194428708-404965445.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;316&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;               Service：即服务，如Nova，Glance，Swift。服务只有在keystone上进行注册才能被分配&lt;/p&gt;
&lt;p&gt;               Endpoint：一个服务暴露出来的访问点，如果要访问一个服务，则必须要知道他的endpoint&lt;/p&gt;
&lt;p&gt;               Token：访问资源的令牌，相当于钥匙&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; keystone到底提供了什么服务：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;               Identity服务：验证了身份验证凭证。&lt;/p&gt;
&lt;p&gt;               Token服务：将会验证并管理用于验证请求身份的令牌&lt;/p&gt;
&lt;p&gt;               Catalog：每个服务需要在keystone上进行注册，而他们就是注册在catalog上&lt;/p&gt;
&lt;p&gt;               Policy：决定每个用户有哪些访问控制的权限&lt;/p&gt;
&lt;h3&gt;4：Nova-计算服务&lt;/h3&gt;
&lt;p&gt;               openstack的核心服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;               &lt;/span&gt;一：主要功能包括&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;               1：实例生命周期管理：实例的创建，删除，启动，停止&lt;/p&gt;
&lt;p&gt;               2：计算资源的管理&lt;/p&gt;
&lt;p&gt;               3：向外提供Rest风格的API&lt;/p&gt;
&lt;p&gt;              二：3个不同的功能模块组成&lt;/p&gt;
&lt;p&gt;              nova-api：位于&lt;strong&gt;表示层&lt;/strong&gt;主要接受外部的rest请求&lt;/p&gt;
&lt;p&gt;              nova-scheduler：位于&lt;strong&gt;逻辑控制层&lt;/strong&gt;，主要负责居中调停，选择由哪个主机创建vm&lt;/p&gt;
&lt;p&gt;              nova-compute：负责虚拟机测创建，以及资源的分配，本身并不提供任何虚拟化功能，但他却支持不同的虚拟机形式&lt;/p&gt;
&lt;p&gt;              他们之间并不是听过直接传递，而是通过消息中间件进行消息的传递&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003200914349-809495783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5： Glance-镜像服务&lt;/h3&gt;
&lt;p&gt;           功能：提供虚拟机镜像的存储，查询和检索服务&lt;/p&gt;
&lt;p&gt;           主要为Nova组件提供服务，通过nova创建虚拟机的时候，就必须听过glance获取相应的镜像，然后根据镜像创建虚拟机。&lt;/p&gt;
&lt;p&gt;           依赖于存储服务和数据库服务：存储服务用于存储镜像本身，数据库服务主要用于存储跟镜像相关的各种元数据&lt;/p&gt;
&lt;p&gt;            &lt;strong&gt;glance的架构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003201549661-343781114.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6：swift-存储服务&lt;/h3&gt;
&lt;p&gt;        功能：对外提供高可用分布式对象存储服务&lt;/p&gt;
&lt;p&gt;        特点：无限可扩展，没有端点故障，使用swift不用担心使用的对象会丢失，因为它本身就提供高可用的功能&lt;/p&gt;
&lt;p&gt;                  可以通过HTTP(S)，object api及s3接口存取&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;swift原理图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                  所有的请求都通过proxy进行处理，通过proxy到合适的Account下面找相应的Containe中的某一个object进行存储服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                  在这中间会针对不同的object进行复制，从而保证某一个对象的信息丢失时能够从其他地方找回来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;                                       &lt;/strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003202230193-1687532222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7：cinder-块存储服务&lt;/h3&gt;
&lt;p&gt;                功能：管理所以的块存储设备，为vm服务，&lt;/p&gt;
&lt;p&gt;                对象存储服务主要用于存储分布式的对象，也就意味着你可以从任何地方发起请求存储你的对象&lt;/p&gt;
&lt;p&gt;                块存储服务是本地的，它只能挂在vm上进行使用&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;cinder原理图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;               当一个请求发来时，首先还是发送到cinder本身的api上面，api模块对发过来的请求进行处理，处理后的结果通过消息中间件进行传递，通过消息中间件mq传到cinder-scheduler上面再通过调度器，&lt;/p&gt;
&lt;p&gt;               再决定到哪里申请块存储服务，并且创建一个vm，cinder具体的存储模块的管理都是通过cinder-volume来进行生命周期管理&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003203851146-450573846.png&quot; alt=&quot;&quot; width=&quot;1035&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;8：Neutron-网络服务&lt;/h3&gt;
&lt;p&gt;            功能：提供云计算环境下的虚拟网络功能，为每个租户建立独立的网络环境&lt;/p&gt;
&lt;p&gt;            三种模式：&lt;/p&gt;
&lt;p&gt;                       Flat模式：网桥模式，所有的都需要手工配置&lt;/p&gt;
&lt;p&gt;                       Flat DHCP模式：网桥模式，在网关处单独取了一个DHCP的进程，可以辅助用户进行网络配置&lt;/p&gt;
&lt;p&gt;                       VLAN模式：为每个不同的租户设置了不同的虚拟子网，在这个虚拟子网中，用户可以有自己的ip&lt;/p&gt;
&lt;h2&gt;三：组件间关系和访问流程&lt;/h2&gt;
&lt;h3&gt;1：组件之间的关系&lt;/h3&gt;

&lt;p&gt;               &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003204721302-287701441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2：访问控制流程   &lt;/h3&gt;
&lt;p&gt;                                    &lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201710/1024482-20171003205001349-2093021239.png&quot; alt=&quot;&quot; width=&quot;1024&quot; height=&quot;552&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 03 Oct 2017 12:52:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/7624467.html</dc:identifier>
</item>
<item>
<title>Vue路由vue-router - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/7527273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/7527273.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　在Web开发中，路由是指根据URL分配到对应的处理程序。对于大多数单页面应用，都推荐使用官方支持的vue-router。Vue-router通过管理URL，实现URL和组件的对应，以及通过URL进行组件之间的切换。本文将详细介绍Vue路由vue-router&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;　　在使用vue-router之前，首先需要安装该插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install vue-router
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/740839/201709/740839-20170915165539469-727510081.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　如果在一个模块化工程中使用它，必须要通过 &lt;code&gt;Vue.use()&lt;/code&gt; 明确地安装路由功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import VueRouter from &lt;/span&gt;'vue-router'&lt;span&gt;

Vue.use(VueRouter)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果使用全局的 script 标签，则无须如此&lt;/p&gt;

&lt;h3&gt;使用&lt;/h3&gt;
&lt;p&gt;　　用Vue.js + vue-router创建单页应用非常简单。使用Vue.js ，已经可以通过组合组件来组成应用程序，把vue-router添加进来，需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们&lt;/p&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;h1&amp;gt;Hello App!&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;!-- 使用 router-link 组件来导航，通过传入 `to` 属性指定链接，&amp;lt;router-link&amp;gt; 默认会被渲染成一个 `&amp;lt;a&amp;gt;` 标签 --&amp;gt;
    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/bar&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;!-- 路由出口，路由匹配到的组件将渲染在这里 --&amp;gt;
  &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 定义（路由）组件，可以从其他文件 import 进来&lt;/span&gt;
const Foo = { template: '&amp;lt;div&amp;gt;foo&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt; }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 定义路由&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是通过 Vue.extend() 创建的组件构造器，或者，只是一个组件配置对象。&lt;/span&gt;
const routes =&lt;span&gt; [
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo },
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar }
]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 创建 router 实例，然后传 `routes` 配置，当然还可以传别的配置参数&lt;/span&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; （缩写）相当于 routes: routes&lt;/span&gt;
&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 创建和挂载根实例。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 通过 router 配置参数注入路由，从而让整个应用都有路由功能&lt;/span&gt;
const app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({&lt;br/&gt;　　el:'#app',&lt;br/&gt;　　router&lt;br/&gt;})&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;路由模式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;　　vue-router&lt;/code&gt; 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/#/Hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不想要很丑的 hash，可以用路由的 &lt;strong&gt;history 模式&lt;/strong&gt;，这种模式充分利用 &lt;code&gt;history.pushState&lt;/code&gt; API 来完成 URL 跳转而无须重新加载页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const router = new&lt;span&gt; VueRouter({
  mode: 'history'&lt;span&gt;,
  routes: [...]
})&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当使用 history 模式时，URL 就像正常的 url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/Hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不过这种模式需要后台配置支持。如果后台没有正确的配置，当用户在浏览器直接访问 &lt;code&gt;http://oursite.com/user/id&lt;/code&gt; 就会返回 404&lt;/p&gt;
&lt;p&gt;【服务器配置】&lt;/p&gt;
&lt;p&gt;　　如果要使用history模式，则需要进行服务器配置&lt;/p&gt;
&lt;p&gt;　　所以，要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 &lt;code&gt;index.html&lt;/code&gt; 页面，这个页面就是app 依赖的页面&lt;/p&gt;
&lt;p&gt;　　下面是一些配置的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;apache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;以wamp为例，需要对httpd.conf配置文件进行修改&lt;/p&gt;
&lt;p&gt;　　首先，去掉rewrite_module前面的#号注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LoadModule rewrite_module modules/mod_rewrite.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，将文档所有的AllowOverride设置为all&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;AllowOverride all&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，需要保存一个.htaccess文件放置在根路径下面，文件内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;IfModule mod_rewrite.c&amp;gt;
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
&amp;lt;/IfModule&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;nginx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location / {
  try_files $uri $uri/ /index.html;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【注意事项】&lt;/p&gt;
&lt;p&gt;　　这么做以后，服务器就不再返回404错误页面，因为对于所有路径都会返回 &lt;code&gt;index.html&lt;/code&gt; 文件。为了避免这种情况，应该在Vue应用里面覆盖所有的路由情况，然后再给出一个404页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const router = new VueRouter({
  mode: 'history',
  routes: [
    { path: '*', component: NotFoundComponent }
  ]
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const Foo = { template: '&amp;lt;div&amp;gt;foo&amp;lt;/div&amp;gt;' }
const Bar = { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;' }
const NotFound = {template:'&amp;lt;div&amp;gt;not found&amp;lt;/div&amp;gt;'}

const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar },
  { path: '*', component: NotFound},
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重定向和别名&lt;/h3&gt;
&lt;p&gt;【重定向】&lt;/p&gt;
&lt;p&gt;　　重定向通过 &lt;code&gt;routes&lt;/code&gt; 配置来完成，下面例子是从 &lt;code&gt;/a&lt;/code&gt; 重定向到 &lt;code&gt;/b&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/a', redirect: '/b'&lt;span&gt; }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重定向的目标也可以是一个命名的路由：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/a', redirect: { name: 'foo'&lt;span&gt; }}
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　甚至是一个方法，动态返回重定向目标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/a', redirect: to =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法接收 目标路由 作为参数&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return 重定向的 字符串路径/路径对象&lt;br/&gt;&lt;/span&gt;      return '/home'
&lt;span&gt;    }}
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于不识别的URL地址来说，常常使用重定向功能，将页面定向到首页显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const Foo = { template: '&amp;lt;div&amp;gt;foo&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt; }
const routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo },
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar },
  { path: &lt;/span&gt;'*', redirect: &quot;/foo&quot;&lt;span&gt;},
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【别名】&lt;/p&gt;
&lt;p&gt;　　重定向是指，当用户访问 &lt;code&gt;/a&lt;/code&gt;时，URL 将会被替换成 &lt;code&gt;/b&lt;/code&gt;，然后匹配路由为 &lt;code&gt;/b&lt;/code&gt;，那么别名是什么呢？&lt;code&gt;/a&lt;/code&gt; 的别名是 &lt;code&gt;/b&lt;/code&gt;，意味着，当用户访问 &lt;code&gt;/b&lt;/code&gt; 时，URL 会保持为 &lt;code&gt;/b&lt;/code&gt;，但是路由匹配则为 &lt;code&gt;/a&lt;/code&gt;，就像用户访问 &lt;code&gt;/a&lt;/code&gt; 一样&lt;/p&gt;
&lt;p&gt;　　上面对应的路由配置为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/a', component: A, alias: '/b'&lt;span&gt; }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　『别名』的功能可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构&lt;/p&gt;
&lt;p&gt; 　　处理首页访问时，常常将index设置为别名，比如将'/home'的别名设置为'/index'。但是，要注意的是，&amp;lt;router-link to=&quot;/home&quot;&amp;gt;的样式在URL为/index时并不会显示。因为，router-link只识别出了home，而无法识别index&lt;/p&gt;

&lt;h3&gt;根路径&lt;/h3&gt;
&lt;p&gt;　　设置根路径，需要将path设置为'/'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/&quot;&amp;gt;index&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/bar&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
&lt;span&gt;
const routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'/'&lt;span&gt;, component: Home },
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo },
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　但是，由于默认使用的是全包含匹配，即'/foo'、'/bar'也可以匹配到'/'，如果需要精确匹配，仅仅匹配'/'，则需要在router-link中设置exact属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/&quot; exact&amp;gt;index&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/bar&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
&lt;span&gt;
const routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'/'&lt;span&gt;, component: Home },
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo },
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;嵌套路由&lt;/h3&gt;
&lt;p&gt;　　实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL中各段动态路径也按某种结构对应嵌套的各层组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
/user/foo/profile                     /user/foo/&lt;span&gt;posts
&lt;/span&gt;+------------------+                  +-----------------+
| User             |                  | User            |
| +--------------+ |                  | +-------------+ |
| | Profile      | |  +------------&amp;gt;  | | Posts       | |
| |              | |                  | |             | |
| +--------------+ |                  | +-------------+ |
+------------------+                  +-----------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　借助 &lt;code&gt;vue-router&lt;/code&gt;，使用嵌套路由配置，就可以很简单地表达这种关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/&quot; exact&amp;gt;index&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/bar&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const Home = { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo &lt;/span&gt;=&lt;span&gt; { template: `
  &lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;
      &amp;lt;router-link to=&quot;/foo/foo1&quot;&amp;gt;to Foo1&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;/foo/foo2&quot;&amp;gt;to Foo2&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;/foo/foo3&quot;&amp;gt;to Foo3&amp;lt;/router-link&amp;gt;  
    &amp;lt;/p&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;span&gt;  ` }
const Bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo1 &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;Foo1&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo2 &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;Foo2&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo3 &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;Foo3&amp;lt;/div&amp;gt;' }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
const routes =&lt;span&gt; [
  { path: &lt;/span&gt;'/'&lt;span&gt;, component: Home },
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo ,children:[
    {path:&lt;/span&gt;'foo1'&lt;span&gt;,component:Foo1},
    {path:&lt;/span&gt;'foo2'&lt;span&gt;,component:Foo2},
    {path:&lt;/span&gt;'foo3'&lt;span&gt;,component:Foo3},
  ]},
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要特别注意的是，router的构造配置中，children属性里的path属性只设置为当前路径，因为其会依据层级关系；而在router-link的to属性则需要设置为完全路径&lt;/p&gt;

&lt;p&gt;　　如果要设置默认子路由，即点击foo时，自动触发foo1，则需要进行如下修改。将router配置对象中children属性的path属性设置为''，并将对应的router-link的to属性设置为'/foo'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const Foo =&lt;span&gt; { template: `
  &lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;
      &amp;lt;router-link to=&quot;/foo&quot; exact&amp;gt;to Foo1&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;/foo/foo2&quot;&amp;gt;to Foo2&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;/foo/foo3&quot;&amp;gt;to Foo3&amp;lt;/router-link&amp;gt;  
    &amp;lt;/p&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
  ` }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
const routes =&lt;span&gt; [
  { path: &lt;/span&gt;'/'&lt;span&gt;, component: Home },
  { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo ,children:[
    {path:&lt;/span&gt;''&lt;span&gt;,component:Foo1},
    {path:&lt;/span&gt;'foo2'&lt;span&gt;,component:Foo2},
    {path:&lt;/span&gt;'foo3'&lt;span&gt;,component:Foo3},
  ]},
  { path: &lt;/span&gt;'/bar'&lt;span&gt;, component: Bar },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如下所示&lt;/p&gt;


&lt;h3&gt;命名路由&lt;/h3&gt;
&lt;p&gt;　　有时，通过一个名称来标识一个路由显得更方便，特别是在链接一个路由，或者是执行一些跳转时。可以在创建Router实例时，在&lt;code&gt;routes&lt;/code&gt;配置中给某个路由设置名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const router = new&lt;span&gt; VueRouter({
  routes: [
    {
      path: '/user/:userId'&lt;span&gt;,
      name: 'user'&lt;span&gt;,
      component: User
    }
  ]
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要链接到一个命名路由，可以给 &lt;code&gt;router-link&lt;/code&gt; 的 &lt;code&gt;to&lt;/code&gt; 属性传一个对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&amp;gt;User&amp;lt;/router-link&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这跟代码调用 &lt;code&gt;router.push()&lt;/code&gt; 是一回事&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
router.push({ name: 'user', params: { userId: 123 }})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两种方式都会把路由导航到 &lt;code&gt;/user/123&lt;/code&gt; 路径&lt;/p&gt;
&lt;p&gt;　　命名路由的常见用途是替换router-link中的to属性，如果不使用命名路由，由router-link中的to属性需要设置全路径，不够灵活，且修改时较麻烦。使用命名路由，只需要使用包含name属性的对象即可&lt;/p&gt;
&lt;p&gt;　　[注意]如果设置了默认子路由，则不要在父级路由上设置name属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; exact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'foo1' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'bar' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const Home = { template: '&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;' }
const Foo = { template: `
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'foo1' }&quot;&lt;/span&gt;&lt;span&gt; exact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;to Foo1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'foo2' }&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;to Foo2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'foo3' }&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;to Foo3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ` }
const Bar = { template: '&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;' }
const Foo1 = { template: '&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Foo1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;' }
const Foo2 = { template: '&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Foo2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;' }
const Foo3 = { template: '&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Foo3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;' }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const routes = [
  { path: '/', name:'home', component: Home },
  { path: '/foo', component: Foo ,children:[
    {path:'',name:'foo1', component:Foo1},
    {path:'foo2',name:'foo2', component:Foo2},
    {path:'foo3',name:'foo3', component:Foo3},
  ]},
  { path: '/bar', name:'bar', component: Bar },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如下所示&lt;/p&gt;


&lt;h3&gt;命名视图&lt;/h3&gt;
&lt;p&gt;　　有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 &lt;code&gt;sidebar&lt;/code&gt;（侧导航） 和 &lt;code&gt;main&lt;/code&gt;（主内容） 两个视图，这个时候命名视图就派上用场了。可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 &lt;code&gt;router-view&lt;/code&gt; 没有设置名字，那么默认为 &lt;code&gt;default&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;router-view class=&quot;view one&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用&lt;code&gt;components&lt;/code&gt;配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const router = new&lt;span&gt; VueRouter({
  routes: [
    {
      path: '/'&lt;span&gt;,
      components: {
        default&lt;span&gt;: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; exact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'foo' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'bar' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;side&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
const Home = { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;Foo&amp;lt;/div&amp;gt;'&lt;span&gt;}
const MainBar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;mainBar&amp;lt;/div&amp;gt;'&lt;span&gt; }
const SideBar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;sideBar&amp;lt;/div&amp;gt;'&lt;span&gt; }

const routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'/', name:'home'&lt;span&gt;, component: Home },
  { path: &lt;/span&gt;'/foo', name:'foo'&lt;span&gt;, component: Foo},
  { path: &lt;/span&gt;'/bar', name:'bar'&lt;span&gt;, components: {
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: MainBar,
    side:SideBar
   } },
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如下所示&lt;/p&gt;


&lt;h3&gt;动态路径&lt;/h3&gt;
&lt;p&gt;　　经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，有一个 &lt;code&gt;User&lt;/code&gt; 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，可以在 &lt;code&gt;vue-router&lt;/code&gt; 的路由路径中使用动态路径参数（dynamic segment）来达到这个效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const User =&lt;span&gt; {
  template: &lt;/span&gt;'&amp;lt;div&amp;gt;User&amp;lt;/div&amp;gt;'&lt;span&gt;
}
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态路径参数以冒号开头&lt;/span&gt;
    { path: '/user/:id'&lt;span&gt;, component: User }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在，像 &lt;code&gt;/user/foo&lt;/code&gt; 和 &lt;code&gt;/user/bar&lt;/code&gt; 都将映射到相同的路由&lt;/p&gt;
&lt;p&gt;　　下面是一个比较完整的实例，path:'/user/:id?'表示有没有子路径都可以匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;br&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/&quot; exact&amp;gt;index&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link :to=&quot;{name:'user'}&quot;&amp;gt;User&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link :to=&quot;{name:'bar'}&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;span&gt;
const home &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt;};
const bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt;};
const user &lt;/span&gt;= {template: `&amp;lt;div&amp;gt;
                          &amp;lt;p&amp;gt;user&amp;lt;/p&amp;gt;
                          &amp;lt;router-link style=&quot;margin: 0 10px&quot; :to=&quot;'/user/' + item.id&quot; v-&lt;span&gt;for&lt;/span&gt;=&quot;item in userList&quot; key=&quot;item.id&quot;&amp;gt;{{item.userName}}&amp;lt;/router-link&amp;gt;  
                      &amp;lt;/div&amp;gt;`,
&lt;span&gt;  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;{userList:[{id:1,userName:'u1'},{id:2,userName:'u2'},{id:3,userName:'u3'&lt;span&gt;}]}
  }
};
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el:&lt;/span&gt;'#app'&lt;span&gt;,
  router:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
    routes: [
      { path: &lt;/span&gt;'/', name:'home'&lt;span&gt;, component:home },
      { path: &lt;/span&gt;'/user/:id?', name:'user'&lt;span&gt;, component:user},
      { path: &lt;/span&gt;'/bar', name:'bar'&lt;span&gt;, component:bar},
    ],
  }), 
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一个路径参数使用冒号 &lt;code&gt;:&lt;/code&gt; 标记。当匹配到一个路由时，参数值会被设置到 &lt;code&gt;this.$route.params&lt;/code&gt;，可以在每个组件内使用。于是，可以更新 &lt;code&gt;User&lt;/code&gt; 的模板，输出当前用户的 ID：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const User =&lt;span&gt; {
  template: &lt;/span&gt;'&amp;lt;div&amp;gt;User {{ $route.params.id }}&amp;lt;/div&amp;gt;'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/user/foo&quot;&amp;gt;/user/foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/user/bar&quot;&amp;gt;/user/bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
const User &lt;/span&gt;=&lt;span&gt; {
  template: `&lt;/span&gt;&amp;lt;div&amp;gt;User {{ $route.params.id }}&amp;lt;/div&amp;gt;`
&lt;span&gt;}
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/user/:id'&lt;span&gt;, component: User }
  ]
})
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Vue({ router }).$mount('#app'&lt;span&gt;)
&lt;/span&gt;&amp;lt;/script&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以在一个路由中设置多段『路径参数』，对应的值都会设置到 &lt;code&gt;$route.params&lt;/code&gt; 中。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模式     　　　　　　　　　　　　　　匹配路径     　　　　　　$route.params
&lt;/span&gt;/user/:username     　　　　　　　/user/evan     　　　　{ username: 'evan'&lt;span&gt; }
&lt;/span&gt;/user/:username/post/:post_id   /user/evan/post/123   { username: 'evan', post_id: 123 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　除了 &lt;code&gt;$route.params&lt;/code&gt; 外，&lt;code&gt;$route&lt;/code&gt; 对象还提供了其它有用的信息，例如，&lt;code&gt;$route.query&lt;/code&gt;（如果 URL 中有查询参数）、&lt;code&gt;$route.hash&lt;/code&gt; 等等&lt;/p&gt;
&lt;p&gt;【响应路由参数的变化】&lt;/p&gt;
&lt;p&gt;　　使用路由参数时，例如从 &lt;code&gt;/user/foo&lt;/code&gt; 导航到 &lt;code&gt;user/bar&lt;/code&gt;，&lt;strong&gt;原来的组件实例会被复用&lt;/strong&gt;。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。&lt;strong&gt;不过，这也意味着组件的生命周期钩子不会再被调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　复用组件时，想对路由参数的变化作出响应的话，可以简单地 watch（监测变化） &lt;code&gt;$route&lt;/code&gt; 对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const User =&lt;span&gt; {
  template: &lt;/span&gt;'...'&lt;span&gt;,
  watch: {
    &lt;/span&gt;'$route'&lt;span&gt; (to, from) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对路由变化作出响应...&lt;/span&gt;
&lt;span&gt;    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]有时同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高&lt;/p&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
const home = { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt;};
const bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt;};
const user &lt;/span&gt;=&lt;span&gt; 
  {template: `&lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;user&amp;lt;/p&amp;gt;
    &amp;lt;router-link style=&quot;margin: 0 10px&quot; :to=&quot;'/user/' +item.type + '/'+ item.id&quot; v-&lt;span&gt;for&lt;/span&gt;=&quot;item in userList&quot; key=&quot;item.id&quot;&amp;gt;{{item.userName}}&amp;lt;/router-link&amp;gt;  
    &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&quot;$route.params.id&quot;&amp;gt;
      &amp;lt;div&amp;gt;id:{{userInfo.id}};userName:{{userInfo.userName}} ;type:{{userInfo.type}};&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;`,
&lt;span&gt;  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      userList:[{id:&lt;/span&gt;1,type:'vip',userName:'u1'},{id:2,type:'common',userName:'u2'},{id:3,type:'vip',userName:'u3'&lt;span&gt;}],
      userInfo:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    }
  },
  methods:{
    getData(){
      let id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$route.params.id;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(id){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo = &lt;span&gt;this&lt;/span&gt;.userList.filter((item)=&amp;gt;&lt;span&gt;{
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item.id ==&lt;span&gt; id;
        })[&lt;/span&gt;0&lt;span&gt;]
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo =&lt;span&gt; {};
      }   
    }
  },
  created(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
  },
  watch:{
    $route(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
    },
  }
};
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el:&lt;/span&gt;'#app'&lt;span&gt;,
  router:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
    routes: [
      { path: &lt;/span&gt;'/', name:'home'&lt;span&gt;, component:home },
      { path: &lt;/span&gt;'/user/:type?/:id?', name:'user'&lt;span&gt;, component:user},
      { path: &lt;/span&gt;'/bar', name:'bar'&lt;span&gt;, component:bar},
    ],
  }), 
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;查询字符串&lt;/h3&gt;
&lt;p&gt;　　实现子路由，除了使用动态参数，也可以使用查询字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
const home = { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt;};
const bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt;};
const user &lt;/span&gt;=&lt;span&gt; 
  {template: `&lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;user&amp;lt;/p&amp;gt;
    &amp;lt;router-link style=&quot;margin: 0 10px&quot; :to=&quot;'/user/' +item.type + '/'+ item.id&quot; v-&lt;span&gt;for&lt;/span&gt;=&quot;item in userList&quot; key=&quot;item.id&quot;&amp;gt;{{item.userName}}&amp;lt;/router-link&amp;gt;  
    &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&quot;$route.params.id&quot;&amp;gt;
      &amp;lt;div&amp;gt;id:{{userInfo.id}};userName:{{userInfo.userName}} ;type:{{userInfo.type}};&amp;lt;/div&amp;gt;
      &amp;lt;router-link to=&quot;?info=follow&quot; exact&amp;gt;关注&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;?info=share&quot; exact&amp;gt;分享&amp;lt;/router-link&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;`,
&lt;span&gt;  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      userList:[{id:&lt;/span&gt;1,type:'vip',userName:'u1'},{id:2,type:'common',userName:'u2'},{id:3,type:'vip',userName:'u3'&lt;span&gt;}],
      userInfo:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    }
  },
  methods:{
    getData(){
      let id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$route.params.id;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(id){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo = &lt;span&gt;this&lt;/span&gt;.userList.filter((item)=&amp;gt;&lt;span&gt;{
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item.id ==&lt;span&gt; id;
        })[&lt;/span&gt;0&lt;span&gt;]
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo =&lt;span&gt; {};
      }   
    }
  },
  created(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
  },
  watch:{
    $route(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
    },
  }
};
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el:&lt;/span&gt;'#app'&lt;span&gt;,
  router:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
    routes: [
      { path: &lt;/span&gt;'/', name:'home'&lt;span&gt;, component:home },
      { path: &lt;/span&gt;'/user/:type?/:id?', name:'user'&lt;span&gt;, component:user},
      { path: &lt;/span&gt;'/bar', name:'bar'&lt;span&gt;, component:bar},
    ],
  }), 
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　当需要设置默认查询字符串时，进行如下设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
const user =&lt;span&gt; 
  {template: `&lt;/span&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;user&amp;lt;/p&amp;gt;
    &amp;lt;router-link style=&quot;margin: 0 10px&quot; :to=&quot;{path:'/user/' +item.type + '/'+ item.id,query:{info:'follow'}}&quot; v-&lt;span&gt;for&lt;/span&gt;=&quot;item in userList&quot; key=&quot;item.id&quot;&amp;gt;{{item.userName}}&amp;lt;/router-link&amp;gt;  
    &amp;lt;div v-&lt;span&gt;if&lt;/span&gt;=&quot;$route.params.id&quot;&amp;gt;
      &amp;lt;div&amp;gt;id:{{userInfo.id}};userName:{{userInfo.userName}} ;type:{{userInfo.type}};&amp;lt;/div&amp;gt;
      &amp;lt;router-link to=&quot;?info=follow&quot; exact&amp;gt;关注&amp;lt;/router-link&amp;gt;
      &amp;lt;router-link to=&quot;?info=share&quot; exact&amp;gt;分享&amp;lt;/router-link&amp;gt;
&lt;span&gt;      {{$route.query}}
    &lt;/span&gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;`,
&lt;span&gt;  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      userList:[{id:&lt;/span&gt;1,type:'vip',userName:'u1'},{id:2,type:'common',userName:'u2'},{id:3,type:'vip',userName:'u3'&lt;span&gt;}],
      userInfo:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    }
  },
  methods:{
    getData(){
      let id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$route.params.id;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(id){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo = &lt;span&gt;this&lt;/span&gt;.userList.filter((item)=&amp;gt;&lt;span&gt;{
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item.id ==&lt;span&gt; id;
        })[&lt;/span&gt;0&lt;span&gt;]
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userInfo =&lt;span&gt; {};
      }   
    }
  },
  created(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
  },
  watch:{
    $route(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getData();
    },
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;滚动行为&lt;/h3&gt;
&lt;p&gt;　　使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 &lt;code&gt;vue-router&lt;/code&gt; 能做到，而且更好，它可以自定义路由切换时页面如何滚动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;[注意]这个功能只在 HTML5 history 模式下可用&lt;/p&gt;
&lt;p&gt;　　当创建一个 Router 实例，可以提供一个 &lt;code&gt;scrollBehavior&lt;/code&gt; 方法。该方法在前进、后退或切换导航时触发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const router = new VueRouter({
  routes: [...],
  scrollBehavior (to, from, savedPosition) {
    // return 期望滚动到哪个的位置
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　scrollBehavior&lt;/code&gt; 方法返回 &lt;code&gt;to&lt;/code&gt; 和 &lt;code&gt;from&lt;/code&gt; 路由对象。第三个参数 &lt;code&gt;savedPosition&lt;/code&gt; 当且仅当 &lt;code&gt;popstate&lt;/code&gt; 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用，返回滚动条的坐标{x:number,y:number}&lt;/p&gt;
&lt;p&gt;　　如果返回一个布尔假的值，或者是一个空对象，那么不会发生滚动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于所有路由导航，简单地让页面滚动到顶部。返回 &lt;code&gt;savedPosition&lt;/code&gt;，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrollBehavior (to, from, savedPosition) {
  if (savedPosition) {
    return savedPosition
  } else {
    return { x: 0, y: 0 }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例，点击导航进行切换时，滚动到页面顶部；通过前进、后退按钮进行切换时，保持坐标位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  mode:&lt;/span&gt;'history'&lt;span&gt;,
  routes ,
  scrollBehavior (to, from, savedPosition){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(savedPosition){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; savedPosition;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {x:0,y:0&lt;span&gt;}
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　还可以模拟『滚动到锚点』的行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrollBehavior (to, from, savedPosition) {
  if (to.hash) {
    return {
      selector: to.hash
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;br&amp;gt;
  &amp;lt;p&amp;gt;
    &amp;lt;router-link to=&quot;/&quot; exact&amp;gt;index&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link :to=&quot;{name:'foo' ,hash:'#abc'}&quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link :to=&quot;{ name: 'bar' }&quot;&amp;gt;Go to Bar&amp;lt;/router-link&amp;gt;
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  mode:&lt;/span&gt;'history'&lt;span&gt;,
  routes ,
  scrollBehavior (to, from, savedPosition){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(to.hash){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        selector: to.hash
      }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(savedPosition){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; savedPosition;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {x:0,y:0&lt;span&gt;}
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;过渡动效&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;　　&amp;lt;router-view&amp;gt;&lt;/code&gt; 是基本的动态组件，所以可以用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 组件给它添加一些过渡效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;transition&amp;gt;
  &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/transition&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  .router-link-active&lt;/span&gt;{&lt;span&gt;background&lt;/span&gt;:&lt;span&gt;pink&lt;/span&gt;;}&lt;span&gt;
  .v-enter,.v-leave-to&lt;/span&gt;{&lt;span&gt;
    opacity&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;
  }&lt;span&gt;
  .v-enter-active,.v-leave-active&lt;/span&gt;{&lt;span&gt;
    transition&lt;/span&gt;:&lt;span&gt;opacity .5s&lt;/span&gt;;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; exact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'foo'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'bar' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【单个路由过渡】&lt;/p&gt;
&lt;p&gt;　　上面的用法会给所有路由设置一样的过渡效果，如果想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 并设置不同的 name&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const Foo =&lt;span&gt; {
  template: `
    &amp;lt;transition name=&quot;slide&quot;&amp;gt;
      &amp;lt;div class=&quot;foo&quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;/transition&amp;gt;
&lt;span&gt;  `
}
const Bar =&lt;span&gt; {
  template: `
    &amp;lt;transition name=&quot;fade&quot;&amp;gt;
      &amp;lt;div class=&quot;bar&quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;/transition&amp;gt;
&lt;span&gt;  `
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;路由元信息&lt;/h3&gt;
&lt;p&gt;　　定义路由的时候可以配置 &lt;code&gt;meta&lt;/code&gt; 字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const router = new&lt;span&gt; VueRouter({
  routes: [
    {
      path: '/foo'&lt;span&gt;,
      component: Foo,
      children: [
        {
          path: 'bar'&lt;span&gt;,
          component: Bar,
          meta: { requiresAuth: true&lt;span&gt; }
        }
      ]
    }
  ]
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　routes&lt;/code&gt;配置中的每个路由对象被称为&lt;strong&gt;路由记录&lt;/strong&gt;。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。例如，根据上面的路由配置，&lt;code&gt;/foo/bar&lt;/code&gt; 这个URL将会匹配父路由记录以及子路由记录&lt;/p&gt;
&lt;p&gt;　　一个路由匹配到的所有路由记录会暴露为 &lt;code&gt;$route&lt;/code&gt; 对象（还有在导航钩子中的 route 对象）的 &lt;code&gt;$route.matched&lt;/code&gt; 数组。因此，需要遍历 &lt;code&gt;$route.matched&lt;/code&gt; 来检查路由记录中的 &lt;code&gt;meta&lt;/code&gt; 字段&lt;/p&gt;
&lt;p&gt;　　下面例子展示在全局导航钩子中检查 meta 字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
router.beforeEach((to, from, next) =&amp;gt;&lt;span&gt; {
  if (to.matched.some(record =&amp;gt;&lt;span&gt; record.meta.requiresAuth)) {
    if (!&lt;span&gt;auth.loggedIn()) {
      next({
        path: '/login'&lt;span&gt;,
        query: { redirect: to.fullPath }
      })
    } else&lt;span&gt; {
      next()
    }
  } else&lt;span&gt; {
    next() 
&lt;span&gt;  }
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【基于路由的动态过渡】&lt;/p&gt;
&lt;p&gt;　　可以基于当前路由与目标路由的变化关系，动态设置过渡效果。通过使用路由元信息，在每个路由对象上设置一个index属性保存其索引值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .router-link-active&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;pink&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .left-enter&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;translateX(100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .left-leave-to&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;translateX(-100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .left-enter-active,.left-leave-active&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;transform .5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .right-enter&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;translateX(-100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .right-leave-to&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;translateX(100%)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .right-enter-active,.right-leave-active&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transition&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;transform .5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;  
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; exact&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'foo'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{ name: 'bar' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-link&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;:name&lt;/span&gt;&lt;span&gt;=&quot;transitionName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-view&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const app = new Vue({
  el:'#app',
  router,
  data () {
    return {
      'transitionName': 'left'
    }
  },
  watch: {
    '$route' (to, from) {
      this['transitionName'] = to.meta.index &amp;gt; from.meta.index ? 'right' : 'left';

    }
  },  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;编程式导航&lt;/h3&gt;
&lt;p&gt;　　除了使用&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;创建a标签来定义导航链接，还可以借助router的实例方法，通过编写代码来实现&lt;/p&gt;
&lt;p&gt;【router.push(location)】&lt;/p&gt;
&lt;p&gt;　　想要导航到不同的 URL，则使用 &lt;code&gt;router.push&lt;/code&gt; 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。&lt;/p&gt;
&lt;p&gt;　　当点击 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 时，这个方法会在内部调用，所以说，点击 &lt;code&gt;&amp;lt;router-link :to=&quot;...&quot;&amp;gt;&lt;/code&gt; 等同于调用 &lt;code&gt;router.push(...)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;声明式     　　　　　　　　　　　　编程式
&lt;/span&gt;&amp;lt;router-link :to=&quot;...&quot;&amp;gt;     router.push(...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符串&lt;/span&gt;
router.push('home'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象&lt;/span&gt;
router.push({ path: 'home'&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命名的路由&lt;/span&gt;
router.push({ name: 'user', params: { userId: 123&lt;span&gt; }})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带查询参数，变成 /register?plan=private&lt;/span&gt;
router.push({ path: 'register', query: { plan: 'private' }})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【&lt;code&gt;router.replace(location)&lt;/code&gt;】&lt;/p&gt;
&lt;p&gt;　　跟 &lt;code&gt;router.push&lt;/code&gt; 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;声明式                 　　　　　　　　　　编程式
&lt;/span&gt;&amp;lt;router-link :to=&quot;...&quot; replace&amp;gt;     router.replace(...)        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【&lt;code&gt;router.go(n)&lt;/code&gt;】&lt;/p&gt;
&lt;p&gt;　　这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 &lt;code&gt;window.history.go(n)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在浏览器记录中前进一步，等同于 history.forward()&lt;/span&gt;
router.go(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后退一步记录，等同于 history.back()&lt;/span&gt;
router.go(-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前进 3 步记录&lt;/span&gt;
router.go(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 history 记录不够用，就静默失败&lt;/span&gt;
router.go(-100&lt;span&gt;)
router.go(&lt;/span&gt;100)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【操作history】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　router.push&lt;/code&gt;、&lt;code&gt;router.replace&lt;/code&gt;和&lt;code&gt;router.go&lt;/code&gt;跟&lt;code&gt;history.pushState、&lt;/code&gt;&lt;code&gt;history.replaceState&lt;/code&gt;和&lt;code&gt;history.go类似&lt;/code&gt;， 实际上它们确实是效仿&lt;code&gt;window.history&lt;/code&gt;API的。vue-router的导航方法(&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;replace&lt;/code&gt;、&lt;code&gt;go&lt;/code&gt;)在各类路由模式(&lt;code&gt;history&lt;/code&gt;、 &lt;code&gt;hash&lt;/code&gt;和&lt;code&gt;abstract&lt;/code&gt;)下表现一致&lt;/p&gt;

&lt;h3&gt;导航钩子&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;　　vue-router&lt;/code&gt; 提供的导航钩子主要用来拦截导航，让它完成跳转或取消。有多种方式可以在路由导航发生时执行钩子：全局的、单个路由独享的或者组件级的&lt;/p&gt;
&lt;p&gt;【全局钩子】&lt;/p&gt;
&lt;p&gt;　　可以使用 &lt;code&gt;router.beforeEach&lt;/code&gt; 注册一个全局的 &lt;code&gt;before&lt;/code&gt; 钩子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({ ... })
router.beforeEach((to, from, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当一个导航触发时，全局的 &lt;code&gt;before&lt;/code&gt; 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 &lt;strong&gt;等待中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　每个钩子方法接收三个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;to: Route: 即将要进入的目标路由对象
from: Route: 当前导航正要离开的路由
next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是next()函数传递不同参数的情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。
next(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
next(&lt;/span&gt;'/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]确保要调用 &lt;code&gt;next&lt;/code&gt; 方法，否则钩子就不会被 resolved。&lt;/p&gt;
&lt;p&gt;　　同样可以注册一个全局的 &lt;code&gt;after&lt;/code&gt; 钩子，不过它不像 &lt;code&gt;before&lt;/code&gt; 钩子那样，&lt;code&gt;after&lt;/code&gt; 钩子没有 &lt;code&gt;next&lt;/code&gt; 方法，不能改变导航：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
router.afterEach(route =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是一个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
const Home = { template: '&amp;lt;div&amp;gt;home&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Foo &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;Foo&amp;lt;/div&amp;gt;'&lt;span&gt;}
const Bar &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;'&lt;span&gt; }
const Login &lt;/span&gt;= { template: '&amp;lt;div&amp;gt;请登录&amp;lt;/div&amp;gt;'&lt;span&gt; }
const routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'/', name:'home', component: Home,meta:{index:0&lt;span&gt;}},
  { path: &lt;/span&gt;'/foo', name:'foo', component:Foo,meta:{index:1,login:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}},
  { path: &lt;/span&gt;'/bar', name:'bar', component:Bar,meta:{index:2&lt;span&gt;}},
  { path: &lt;/span&gt;'/login', name:'login'&lt;span&gt;, component:Login,},
]
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes ,
})
router.beforeEach((to, from, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(to.meta.login){
    next(&lt;/span&gt;'/login'&lt;span&gt;);
  }
  next();
});
router.afterEach((to, from)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
  document.title &lt;/span&gt;=&lt;span&gt; to.name;
})
const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el:&lt;/span&gt;'#app'&lt;span&gt;,
  router,
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【单个路由独享】&lt;/p&gt;
&lt;p&gt;　　可以在路由配置上直接定义 &lt;code&gt;beforeEnter&lt;/code&gt; 钩子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    {
      path: &lt;/span&gt;'/foo'&lt;span&gt;,
      component: Foo,
      beforeEnter: (to, from, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;      }
    }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这些钩子与全局 &lt;code&gt;before&lt;/code&gt; 钩子的方法参数是一样的&lt;/p&gt;
&lt;p&gt;【组件内钩子】&lt;/p&gt;
&lt;p&gt;　　可以在路由组件内直接定义以下路由导航钩子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteEnter
beforeRouteUpdate (&lt;/span&gt;2.2&lt;span&gt; 新增)
beforeRouteLeave &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
const Foo =&lt;span&gt; {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在渲染该组件的对应路由被 confirm 前调用，&lt;/span&gt;&lt;span&gt;不能获取组件实例 `this`，&lt;/span&gt;&lt;span&gt;因为当钩子执行前，组件实例还没被创建&lt;/span&gt;
&lt;span&gt;  },
  beforeRouteUpdate (to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在当前路由改变，但是该组件被复用时调用。&lt;/span&gt;&lt;span&gt;举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转时，&lt;/span&gt;&lt;span&gt;由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。&lt;/span&gt;&lt;span&gt;可以访问组件实例 `this`&lt;/span&gt;
&lt;span&gt;  },
  beforeRouteLeave (to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导航离开该组件的对应路由时调用，&lt;/span&gt;&lt;span&gt;可以访问组件实例 `this`&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;　　beforeRouteEnter&lt;/code&gt;钩子&lt;strong&gt;不能&lt;/strong&gt;访问&lt;code&gt;this&lt;/code&gt;，因为钩子在导航确认前被调用，因此即将登场的新组件还没被创建&lt;/p&gt;
&lt;p&gt;　　不过，可以通过传一个回调给 &lt;code&gt;next&lt;/code&gt;来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteEnter (to, from, next) {
  next(vm &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 `vm` 访问组件实例&lt;/span&gt;
&lt;span&gt;  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以在 &lt;code&gt;beforeRouteLeave&lt;/code&gt; 中直接访问 &lt;code&gt;this&lt;/code&gt;。这个 &lt;code&gt;leave&lt;/code&gt; 钩子通常用来禁止用户在还未保存修改前突然离开。可以通过 &lt;code&gt;next(false)&lt;/code&gt; 来取消导航&lt;/p&gt;

&lt;h3&gt;数据获取&lt;/h3&gt;
&lt;p&gt;　　有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，需要从服务器获取用户的数据。可以通过两种方式来实现：&lt;/p&gt;
&lt;p&gt;　　1、&lt;strong&gt;导航完成之后获取&lt;/strong&gt;：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示『加载中』之类的指示&lt;/p&gt;
&lt;p&gt;　　2、&lt;strong&gt;导航完成之前获取&lt;/strong&gt;：导航完成前，在路由的 &lt;code&gt;enter&lt;/code&gt; 钩子中获取数据，在数据获取成功后执行导航。&lt;/p&gt;
&lt;p&gt;　　从技术角度讲，两种方式都不错 —— 就看想要的用户体验是哪种&lt;/p&gt;
&lt;p&gt;【导航完成后获取】&lt;/p&gt;
&lt;p&gt;　　当使用这种方式时，会马上导航和渲染组件，然后在组件的 &lt;code&gt;created&lt;/code&gt; 钩子中获取数据。有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。&lt;/p&gt;
&lt;p&gt;　　假设有一个 &lt;code&gt;Post&lt;/code&gt; 组件，需要基于 &lt;code&gt;$route.params.id&lt;/code&gt; 获取文章数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;loading&quot;&lt;/span&gt;&lt;span&gt; v-if&lt;/span&gt;&lt;span&gt;=&quot;loading&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Loading...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      {{ error }}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ post.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ post.body }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

export default {
  data () {
    return {
      loading: false,
      post: null,
      error: null
    }
  },
  created () {
    // 组件创建完后获取数据，
    // 此时 data 已经被 observed 了
    this.fetchData()
  },
  watch: {
    // 如果路由有变化，会再次执行该方法
    '$route': 'fetchData'
  },
  methods: {
    fetchData () {
      this.error = this.post = null
      this.loading = true
      // replace getPost with your data fetching util / API wrapper
      getPost(this.$route.params.id, (err, post) =&amp;gt; {
        this.loading = false
        if (err) {
          this.error = err.toString()
        } else {
          this.post = post
        }
      })
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【导航完成前获取数据】&lt;/p&gt;
&lt;p&gt;　　通过这种方式，在导航转入新的路由前获取数据。可以在接下来的组件的 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 钩子中获取数据，当数据获取成功后只调用 &lt;code&gt;next&lt;/code&gt; 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export default {
  data () {
    return {
      post: null,
      error: null
    }
  },
  beforeRouteEnter (to, from, next) {
    getPost(to.params.id, (err, post) =&amp;gt; {
      if (err) {
        // display some global error message
        next(false)
      } else {
        next(vm =&amp;gt; {
          vm.post = post
        })
      }
    })
  },
  // 路由改变前，组件就已经渲染完了
  // 逻辑稍稍不同
  watch: {
    $route () {
      this.post = null
      getPost(this.$route.params.id, (err, post) =&amp;gt; {
        if (err) {
          this.error = err.toString()
        } else {
          this.post = post
        }
      })
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒&lt;/p&gt;

&lt;h3&gt;懒加载&lt;/h3&gt;
&lt;p&gt;　　当打包构建应用时，JS包会变得非常大，影响页面加载。如果能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了&lt;/p&gt;
&lt;p&gt;　　结合 Vue 的 异步组件 和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。&lt;/p&gt;
&lt;p&gt;　　首先，可以将异步组件定义为返回一个 Promise 的工厂函数(该函数返回的Promise应该 resolve 组件本身)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Foo = () =&amp;gt; Promise.resolve({ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  组件定义对象 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 webpack 2中，使用动态 import语法来定义代码分块点(split point):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import('./Foo.vue') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; returns a Promise&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]如果使用的是 babel，需要添加&lt;a href=&quot;http://babeljs.io/docs/plugins/syntax-dynamic-import/&quot; target=&quot;_blank&quot;&gt;syntax-dynamic-import&lt;/a&gt;插件，才能使 babel 可以正确地解析语法&lt;/p&gt;
&lt;p&gt;　　结合这两者，这就是如何定义一个能够被 webpack自动代码分割的异步组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Foo = () =&amp;gt; import('./Foo.vue')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在路由配置中什么都不需要改变，只需要像往常一样使用 &lt;code&gt;Foo&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const router = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueRouter({
  routes: [
    { path: &lt;/span&gt;'/foo'&lt;span&gt;, component: Foo }
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【把组件按组分块】&lt;/p&gt;
&lt;p&gt;　　有时候想把某个路由下的所有组件都打包在同个异步块(chunk)中。只需要使用 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-require/#chunkname&quot; target=&quot;_blank&quot;&gt;命名 chunk&lt;/a&gt;，一个特殊的注释语法来提供chunk name(需要webpack &amp;gt; 2.4)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const Foo = () =&amp;gt; import(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;group-foo&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; './Foo.vue'&lt;span&gt;)
const Bar &lt;/span&gt;= () =&amp;gt; import(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;group-foo&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; './Bar.vue'&lt;span&gt;)
const Baz &lt;/span&gt;= () =&amp;gt; import(&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; webpackChunkName: &quot;group-foo&quot; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; './Baz.vue')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中&lt;/p&gt;

</description>
<pubDate>Tue, 03 Oct 2017 12:47:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/7527273.html</dc:identifier>
</item>
</channel>
</rss>