<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>模型和字段 -- Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8413285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8413285.html</guid>
<description>&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;一个模型（model）就是一个单独的、确定的数据的信息源，包含了数据的字段和操作方法。通常，每个模型映射为一张数据库中的表。&lt;/p&gt;
&lt;p&gt;基本的原则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个模型在Django中的存在形式为一个Python类&lt;/li&gt;
&lt;li&gt;每个模型都是django.db.models.Model的子类&lt;/li&gt;
&lt;li&gt;模型的每个字段（属性）代表数据表的某一列&lt;/li&gt;
&lt;li&gt;Django将自动为你生成数据库访问API&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简单示例&quot;&gt;&lt;strong&gt;简单示例：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;下面的模型定义了一个“人”，它具有&lt;code&gt;first_name&lt;/code&gt;和&lt;code&gt;last_name&lt;/code&gt;字段：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Person(models.Model):
    first_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)
    last_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一个字段都是一个类属性，每个类属性表示数据表中的一个列。&lt;/p&gt;
&lt;p&gt;上面的代码，相当于下面的原生SQL语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLE&lt;/span&gt; myapp_person (
    &lt;span class=&quot;ot&quot;&gt;&quot;id&quot;&lt;/span&gt; serial &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;KEY&lt;/span&gt;,
    &lt;span class=&quot;ot&quot;&gt;&quot;first_name&quot;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;,
    &lt;span class=&quot;ot&quot;&gt;&quot;last_name&quot;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;
);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表名&lt;code&gt;myapp_person&lt;/code&gt;由Django自动生成，默认格式为“项目名称+下划线+小写类名”，你可以重写这个规则。&lt;/li&gt;
&lt;li&gt;Django默认自动创建自增主键&lt;code&gt;id&lt;/code&gt;，当然，你也可以自己指定主键。&lt;/li&gt;
&lt;li&gt;上面的SQL语句基于&lt;code&gt;PostgreSQL&lt;/code&gt;语法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常，我们会将模型编写在其所属app下的models.py文件中，没有特别需求时，请坚持这个原则，不要自己给自己添加麻烦。&lt;/p&gt;
&lt;p&gt;创建了模型之后，在使用它之前，你需要先在settings文件中的&lt;code&gt;INSTALLED_APPS&lt;/code&gt; 处，注册&lt;code&gt;models.py&lt;/code&gt;文件所在的&lt;code&gt;myapp&lt;/code&gt;。看清楚了，是注册app，不是模型，也不是&lt;code&gt;models.py&lt;/code&gt;。如果你以前写过模型，可能已经做过这一步工作，可跳过。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTALLED_APPS = [
#...
'myapp',
#...
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当你每次对模型进行增、删、修改时，请务必执行命令&lt;code&gt;python manage.py migrate&lt;/code&gt;，让操作实际应用到数据库上。这里可以选择在执行migrate之前，先执行&lt;code&gt;python manage.py makemigrations&lt;/code&gt;让修改动作保存到记录文件中，方便github等工具的使用。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型字段fields&quot;&gt;模型字段fields&lt;/h2&gt;
&lt;p&gt;字段是模型中最重要的内容之一，也是唯一必须的部分。字段在Python中表现为一个类属性，体现了数据表中的一个列。请不要使用&lt;code&gt;clean&lt;/code&gt;、&lt;code&gt;save&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;等Django内置的模型API名字，防止命名冲突。下面是一个展示，注意字段的写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Musician(models.Model):
    first_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)
    last_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;)
    instrument &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Album(models.Model):
    artist &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Musician, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
    release_date &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.DateField()
    num_stars &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;字段命名约束：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Django不允许下面两种字段名：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;与Python关键字冲突。这会导致语法错误。例如：&lt;/p&gt;
&lt;p&gt;class Example(models.Model):&lt;br/&gt;pass = models.IntegerField() # 'pass'是Python保留字！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;字段名中不能有两个以上下划线在一起，因为两个下划线是Django的查询语法。例如：&lt;/p&gt;
&lt;p&gt;class Example(models.Model):&lt;br/&gt;foo__bar = models.IntegerField() # 'foo__bar' 有两个下划线在一起!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于你可以自定义表名、列名，上面的规则可能被绕开，但是请养成良好的习惯，一定不要那么起名。&lt;/p&gt;
&lt;p&gt;SQL语言的join、where和select等保留字可以作为字段名，因为Django对它们都进行了转义。&lt;/p&gt;
&lt;h2 id=&quot;常用字段类型&quot;&gt;常用字段类型&lt;/h2&gt;
&lt;p&gt;字段类型的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;决定数据库中对应列的数据类型(例如：INTEGER, VARCHAR, TEXT)&lt;/li&gt;
&lt;li&gt;HTML中对应的表单标签的类型，例如&lt;code&gt;&amp;lt;input type=“text” /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在admin后台和自动生成的表单中最小的数据验证需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Django内置了许多字段类型，它们都位于&lt;code&gt;django.db.models&lt;/code&gt;中，例如&lt;code&gt;models.CharField&lt;/code&gt;。这些类型基本满足需求，如果还不够，你也可以自定义字段。&lt;/p&gt;
&lt;p&gt;下表列出了所有Django内置的字段类型，但不包括关系字段类型（字段名采用驼峰命名法，初学者请一定要注意）：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;49&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;AutoField&lt;/td&gt;
&lt;td&gt;一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：&lt;code&gt;id = models.AutoField(primary_key=True)&lt;/code&gt;，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为&lt;code&gt;primary_key=True&lt;/code&gt;。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BigAutoField&lt;/td&gt;
&lt;td&gt;(1.10新增)64位整数类型自增字段，数字范围更大，从1到9223372036854775807&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;BigIntegerField&lt;/td&gt;
&lt;td&gt;64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个textinput标签。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BinaryField&lt;/td&gt;
&lt;td&gt;二进制数据类型。使用受限，少用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;BooleanField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果要接收null值，请使用NullBooleanField。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;CharField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是input text。最常用的filed，没有之一！&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;CommaSeparatedIntegerField&lt;/td&gt;
&lt;td&gt;逗号分隔的整数类型。必须接收一个max_length参数。常用于表示较大的金额数目，例如1,000,000元。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;DateField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class DateField(auto_now=False, auto_now_add=False, **options)&lt;/code&gt;日期类型。一个Python中的datetime.date的实例。在HTML中表现为TextInput标签。在admin后台中，Django会帮你自动添加一个JS的日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） &lt;code&gt;auto_now&lt;/code&gt;:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。&lt;code&gt;auto_now_add&lt;/code&gt;：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了&lt;code&gt;editable=False&lt;/code&gt;和&lt;code&gt;blank=True&lt;/code&gt;属性。如果想具有修改属性，请用default参数。例子：&lt;code&gt;pub_time = models.DateField(auto_now_add=True)&lt;/code&gt;，自动添加发布时间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;DateTimeField&lt;/td&gt;
&lt;td&gt;日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DecimalField&lt;/td&gt;
&lt;td&gt;固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数&lt;code&gt;max_digits&lt;/code&gt;：最大的位数，必须大于或等于小数点位数 。&lt;code&gt;decimal_places&lt;/code&gt;：小数点位数，精度。 当&lt;code&gt;localize=False&lt;/code&gt;时，它在HTML表现为NumberInput标签，否则是text类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：&lt;code&gt;models.DecimalField(..., max_digits=5, decimal_places=2)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;DurationField&lt;/td&gt;
&lt;td&gt;持续时间类型。存储一定期间的时间长度。类似Python中的timedelta。在不同的数据库实现中有不同的表示方法。常用于进行时间之间的加减运算。但是小心了，这里有坑，PostgreSQL等数据库之间有兼容性问题！&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;EmailField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用DJango内置的EmailValidator进行邮箱地址合法性验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;FileField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class FileField(upload_to=None, max_length=100, **options)&lt;/code&gt;上传文件类型，后面单独介绍。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FilePathField&lt;/td&gt;
&lt;td&gt;文件路径类型，后面单独介绍&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FloatField&lt;/td&gt;
&lt;td&gt;浮点数类型，参考整数类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;ImageField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;图像类型，后面单独介绍。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;IntegerField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput标签。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;GenericIPAddressField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class GenericIPAddressField(protocol='both', unpack_ipv4=False, **options)[source]&lt;/code&gt;,IPV4或者IPV6地址，字符串形式，例如&lt;code&gt;192.0.2.30&lt;/code&gt;或者&lt;code&gt;2a02:42fe::4&lt;/code&gt;在HTML中表现为TextInput标签。参数&lt;code&gt;protocol&lt;/code&gt;默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NullBooleanField&lt;/td&gt;
&lt;td&gt;类似布尔字段，只不过额外允许&lt;code&gt;NULL&lt;/code&gt;作为选项之一。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;PositiveIntegerField&lt;/td&gt;
&lt;td&gt;正整数字段，包含0,最大2147483647。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;PositiveSmallIntegerField&lt;/td&gt;
&lt;td&gt;较小的正整数字段，从0到32767。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SlugField&lt;/td&gt;
&lt;td&gt;slug是一个新闻行业的术语。一个slug就是一个某种东西的简短标签，包含字母、数字、下划线或者连接线，通常用于URLs中。可以设置max_length参数，默认为50。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SmallIntegerField&lt;/td&gt;
&lt;td&gt;小整数，包含-32768到32767。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;TextField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;大量文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;TimeField&lt;/td&gt;
&lt;td&gt;时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;URLField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;一个用于保存URL地址的字符串类型，默认最大长度200。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;UUIDField&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品，后面有例子展示。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;这里有如何上传文件和图片的方法&quot;&gt;这里有如何上传文件和图片的方法：&lt;/h3&gt;
&lt;h3 id=&quot;filefield&quot;&gt;1.&lt;strong&gt;FileField：&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class FileField(upload_to=None, max_length=100, **options)[source]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传文件字段（不能设置为主键）。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，可以通过max_length参数自定义。真实的文件是保存在服务器的文件系统内的。&lt;/p&gt;
&lt;p&gt;重要参数&lt;code&gt;upload_to&lt;/code&gt;用于设置上传地址的目录和文件名。如下例所示：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyModel(models.Model):
    &lt;span class=&quot;co&quot;&gt;# 文件被传至`MEDIA_ROOT/uploads`目录，MEDIA_ROOT由你在settings文件中设置&lt;/span&gt;
    upload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.FileField(upload_to&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'uploads/'&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 或者&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 被传到`MEDIA_ROOT/uploads/2015/01/30`目录，增加了一个时间划分&lt;/span&gt;
    upload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.FileField(upload_to&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'uploads/%Y/%m/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Django很人性化地帮我们实现了根据日期生成目录的方式！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;upload_to&lt;/code&gt;参数也可以接收一个回调函数，该函数返回具体的路径字符串&lt;/strong&gt;，如下例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; user_directory_path(instance, filename):
    &lt;span class=&quot;co&quot;&gt;#文件上传到MEDIA_ROOT/user_&amp;lt;id&amp;gt;/&amp;lt;filename&amp;gt;目录中&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'user_&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{0}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{1}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(instance.user.&lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;, filename)

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyModel(models.Model):
    upload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.FileField(upload_to&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;user_directory_path)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子中，&lt;code&gt;user_directory_path&lt;/code&gt;这种回调函数，必须接收两个参数，然后返回一个Unix风格的路径字符串。参数&lt;code&gt;instace&lt;/code&gt;代表一个定义了&lt;code&gt;FileField&lt;/code&gt;的模型的实例，说白了就是当前数据记录。&lt;code&gt;filename&lt;/code&gt;是原本的文件名。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;imagefield&quot;&gt;2. &lt;strong&gt;ImageField&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)[source]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于保存图像文件的字段。其基本用法和特性与FileField一样，只不过多了两个属性height和width。默认情况下，该字段在HTML中表现为一个ClearableFileInput标签。在数据库内，我们实际保存的是一个字符串类型，默认最大长度100，可以通过max_length参数自定义。真实的图片是保存在服务器的文件系统内的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;height_field&lt;/code&gt;参数：保存有图片高度信息的模型字段名。&lt;br/&gt;&lt;code&gt;width_field&lt;/code&gt;参数：保存有图片宽度信息的模型字段名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Django的ImageField需要提前安装pillow模块，pip install pillow即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用FileField或者ImageField字段的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在settings文件中，配置&lt;code&gt;MEDIA_ROOT&lt;/code&gt;，作为你上传文件在服务器中的基本路径（为了性能考虑，这些文件不会被储存在数据库中）。再配置个&lt;code&gt;MEDIA_URL&lt;/code&gt;，作为公用URL，指向上传文件的基本路径。请确保Web服务器的用户账号对该目录具有写的权限。&lt;/li&gt;
&lt;li&gt;添加FileField或者ImageField字段到你的模型中，定义好&lt;code&gt;upload_to&lt;/code&gt;参数，文件最终会放在&lt;code&gt;MEDIA_ROOT&lt;/code&gt;目录的“upload_to”子目录中。&lt;/li&gt;
&lt;li&gt;所有真正被保存在数据库中的，只是指向你上传文件路径的字符串而已。可以通过url属性，在Django的模板中方便的访问这些文件。例如，假设你有一个ImageField字段，名叫&lt;code&gt;mug_shot&lt;/code&gt;，那么在Django模板的HTML文件中，可以使用&lt;code&gt;{{ object.mug_shot.url }}&lt;/code&gt;来获取该文件。其中的object用你具体的对象名称代替。&lt;/li&gt;
&lt;li&gt;可以通过&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;属性，获取文件的名称和大小信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;安全建议&quot;&gt;安全建议&lt;/h3&gt;
&lt;p&gt;无论你如何保存上传的文件，一定要注意他们的内容和格式，避免安全漏洞！务必对所有的上传文件进行安全检查，确保它们不出问题！如果你不加任何检查就盲目的让任何人上传文件到你的服务器文档根目录内，比如上传了一个CGI或者PHP脚本，很可能就会被访问的用户执行，这具有致命的危害。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;filepathfield&quot;&gt;3. &lt;strong&gt;FilePathField&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class FilePathField(path=None, match=None, recursive=False, max_length=100, **options)[source]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种用来保存文件路径信息的字段。在数据表内以字符串的形式存在，默认最大长度100，可以通过max_length参数设置。&lt;/p&gt;
&lt;p&gt;它包含有下面的一些参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;path&lt;/code&gt;：必须指定的参数。表示一个系统绝对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;match&lt;/code&gt;:可选参数，一个正则表达式，用于过滤文件名。只匹配基本文件名，不匹配路径。例如&lt;code&gt;foo.*\.txt$&lt;/code&gt;，只匹配文件名&lt;code&gt;foo23.txt&lt;/code&gt;，不匹配&lt;code&gt;bar.txt&lt;/code&gt;与&lt;code&gt;foo23.png&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recursive&lt;/code&gt;:可选参数，只能是True或者False。默认为False。决定是否包含子目录，也就是是否递归的意思。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allow_files&lt;/code&gt;:可选参数，只能是True或者False。默认为True。决定是否应该将文件名包括在内。它和&lt;code&gt;allow_folders&lt;/code&gt;其中，必须有一个为True。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allow_folders&lt;/code&gt;： 可选参数，只能是True或者False。默认为False。决定是否应该将目录名包括在内。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FilePathField(path=&quot;/home/images&quot;, match=&quot;foo.*&quot;, recursive=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它只匹配&lt;code&gt;/home/images/foo.png&lt;/code&gt;，但不匹配&lt;code&gt;/home/images/foo/bar.png&lt;/code&gt;，因为默认情况，只匹配文件名，而不管路径是怎么样的。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;uuidfield&quot;&gt;4. &lt;strong&gt;UUIDField：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;数据库无法自己生成uuid，因此需要如下使用default参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; uuid     &lt;span class=&quot;co&quot;&gt;# Python的内置模块&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyUUIDModel(models.Model):
    &lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.UUIDField(primary_key&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;, default&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;uuid.uuid4, editable&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 其它字段&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 04 Feb 2018 07:26:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8413285.html</dc:identifier>
</item>
<item>
<title>淘宝小姐姐快到我碗里来(多线程爬虫) - 地球守卫者</title>
<link>http://www.cnblogs.com/huangguifeng/p/8413259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangguifeng/p/8413259.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;今天接到任务，写一个爬虫案例，要写的通俗易懂，还要能包含爬虫的基本知识，让大家从一个案例中学会爬虫！我寻思着应该爬什么大家比较喜欢呢？爬取日本小姐姐？怕尺度太大审核不过!!！那就爬取淘宝小姐姐吧！淘宝小姐姐也是个个水灵的很。&lt;/p&gt;
&lt;p&gt;先上一高清无码大图，让大家过过眼瘾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180116235618053-257002575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;爬虫一共就四个主要步骤：&lt;/p&gt;
&lt;p&gt;1、明确目标：明确需要抓取那些内容，在哪个网页&lt;br/&gt;2、爬：分析网站结构，将所有的网站的内容全部爬下来&lt;br/&gt;3、取：提取我们所需要的数据&lt;br/&gt;4、处理数据：按照需求存储使用&lt;/p&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;明确目标：&lt;br/&gt;网站url: &lt;a href=&quot;https://mm.taobao.com/search_tstar_model.htm?spm=5679.126488.640745.2.2dc084317xDoLY&quot; rel=&quot;nofollow&quot;&gt;https://mm.taobao.com/search_tstar_model.htm?spm=5679.126488.640745.2.2dc084317xDoLY&lt;/a&gt;&lt;br/&gt;抓取内容：&lt;br/&gt;头像：存储在本地硬盘。&lt;br/&gt;名字，城市，身高，体重，点赞数： 保存在mysql数据库&lt;br/&gt;说明：这里只是用作教程并非真的要将爬取的内容作为其它用途，我只是单纯想看看淘宝小姐姐的卓越风姿。&lt;/p&gt;
&lt;p&gt;第二步爬：&lt;/p&gt;
&lt;p&gt;使用到的模块：&lt;/p&gt;
&lt;p&gt;python 3.6： python环境&lt;br/&gt;requests： 发送请求&lt;br/&gt;pymysql： 操作mysql&lt;br/&gt;queue： 队列&lt;br/&gt;random: 产生随机数&lt;/p&gt;
&lt;p&gt;想要看懂这篇文章，还是需要那么一丢丢的python基础知识。&lt;/p&gt;
&lt;p&gt;分析网页结构：&lt;br/&gt;1、确定网页数据的请求方式'GET'还是'POST'，ajax异步请求还是直接浏览器请求，一般ajax请求的url跟我们在浏览器上的url地址栏看到是不一样的，所以我们需要使用到浏览器的开发者工具抓包查看。&lt;/p&gt;
&lt;p&gt;我观察了下淘女郎这个模特库首页是有分页的，这里有个小技巧，来确定请求方式：&lt;br/&gt;我这里使用的是谷歌浏览器，按F12打开浏览器的开发者工具，切换到netrork选项，然后将网页拉到最下面有分页的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180116235702849-340477546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们观察url地址栏上的地址并没有发生改变，所以地址栏上的url对我们没有帮助！这也说明这个网页的内容是通过ajax加载的。&lt;/p&gt;
&lt;p&gt;查看图片上4的位置所有请求的url，发现第一个请求并没有返回任何数据，只有第二个请求有返回数据第三个请求之后的全部都是请求图片的。&lt;/p&gt;
&lt;p&gt;选中第二个请求，选中response，查看返回的数据是json数据，可以将json数据复制到json在线解析网站解析看下返回的是什么，解析出来后我们发现，json数据 &quot;searchDOList&quot; 字段就是包含了当前页所有淘宝小姐姐的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180116235733162-1651417055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;确定我们需要的数据就是在第二请求之后，我们回到开发者管理工具，点击headers查看请求头信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180116235801115-1387540591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;标红框的这几个数据等会写爬虫会用到，分析到这里我们就拿到了等下写爬虫需要的数据：&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;url:https://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8&lt;br/&gt;请求方式：post&lt;br/&gt;post参数：&lt;br/&gt;    q:&lt;br/&gt;    viewFlag:A&lt;br/&gt;    sortType:default&lt;br/&gt;    searchStyle:&lt;br/&gt;    searchRegion:city:&lt;br/&gt;    searchFansNum:&lt;br/&gt;    currentPage:2&lt;br/&gt;    pageSize:100&lt;/p&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;淘女郎一共有1450页，所以采取多线程的方式进行抓取。&lt;/p&gt;&lt;p&gt;线程：一个进程可以有多个线程，所有线程共享进程的内存空间，通讯效率高，切换开销小。&lt;br/&gt;多线程：密集I/O任务（网络I/O，磁盘I/O，数据库I/O）使用多线程合适。&lt;br/&gt;缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180116235839756-93744505.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 抓取线程：&lt;/p&gt;&lt;p&gt;1、设置请求头，网站一般会检查请求头，所以我们在发送请求的时候一般都要携带请求头&lt;br/&gt;根据经验，大部分网站都会对下面字段进行检查：&lt;/p&gt;&lt;p&gt;- origin   表示记录你从那个网站进来&lt;br/&gt;- user-agent  标识浏览器&lt;/p&gt;&lt;p&gt;2、设置id代理，如果一个id请求频繁，一般网站都会封掉这些ip,那么爬虫需要使用代理id。&lt;/p&gt;&lt;p&gt;3、构造post数据，根据刚才在浏览器开发者管理工具中看到的字段构造&lt;/p&gt;&lt;p&gt;4、利用requests模块发送请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ThreadCrawl(Thread):

    def __init__(self,page_queue):
        Thread.__init__(self)  # 继承多线程父类
        self.q = page_queue
    def run(self):

        while True:
            if self.q.empty():
                break
            # 构造请求头
            page = self.q.get()
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36',
                'origin': 'https://mm.taobao.com'
            }
            # 请求url
            url = 'https://mm.taobao.com/tstar/search/tstar_model.do?_input_charset=utf-8'
            # 从任务队列中取出任务，页数

            # 构造post请求数据
            data = {
                'viewFlag': 'A',
                'sortType': 'default',
                'currentPage': page,
                'pageSize': 100,
            }
            # 根据协议类型，选择不同的代理
            proxies = [{&quot;http&quot;: &quot;http://61.135.217.7:80&quot;},
                       {&quot;http&quot;: &quot;http://120.27.144.192:8080&quot;},
                       {&quot;http&quot;: &quot;http://123.119.202.254:8118&quot;},
                       ]  # 普通ip代理设置方式
            proxies = random.choice(proxies)  # 多个代理ip随机选一个发送请求

            # proxy = {&quot;http&quot;: &quot;账号:密码@61.158.163.130:16852&quot;}  #私密ip代理设置方式

            timeout = 3  # 定义重复请求次数
            while timeout:
                # 发送请求
                data = requests.post(url=url, data=data, headers=headers, proxies=proxies).json()
                if data['status'] == -1:  # 如果没有请求到正确的数据将重复请求三次
                    timeout -= 1
                else:
                    data_queue.put(data)  # 将抓取下来的数据放到数据队列
                    break
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 第三步提取：&lt;/p&gt;&lt;p&gt;由于我们抓取的整个网站返回的json数据，使用requests对象的json方法，可以返回一个python的字典对象，所以提取数据时候只需要按照python字典方式提取就可以了这里比较简单。&lt;br/&gt;将淘宝小姐姐的信息插入到数据库，头像url继续放入到url队列中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ParseCrawl(Thread):
    def __init__(self, thread_id, data_queue):
        Thread.__init__(self)  # 继承多线程父类
        self.threadID = thread_id  # 线程id
        self.q = data_queue  # 任务队列

    def run(self):
        while not exitFlag_Parser:
            try:
                data = self.q.get(block=False)  # 从队列中取出一条数据,block=False 设置队列为空时不阻塞，直接抛异常,用try处理.
                                                # 这样主要是防止get方法阻塞
                info_list = data['data']['searchDOList']  # 获取到一页中所有小姐姐的信息
                for info in info_list:
                    # 将提取的数据写入数据库
                    param = [info[&quot;realName&quot;],info['city'],str(info['height']),str(info['weight']),info['totalFavorNum']]
                    sql = 'insert into taobaomm VALUE (0,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;,&quot;%s&quot;)'
                    self.save_mysql(sql,param)
                    # 提取出头像url放入对列
                    avatar_queue.put((info['avatarUrl'], info['realName']))
            except:
                pass


    def save_mysql(self,sql,param):
        # 连接数据库
        com = pymysql.connect(host='192.168.0.103',port=3306,password='mysql',
                        charset='utf8',user='root',database='mm')
        cur = com.cursor()
        cur.execute(sql,param)
        cur.close()
        com.commit()
        com.close()     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 第四步：&lt;/p&gt;&lt;p&gt;下载淘宝小姐姐头像保存到硬盘中。&lt;br/&gt;头像在json中返回的是一个url，所有需要再次请求头像图片。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class LoadImage(Thread):
    def __init__(self, avatar_queue):
        Thread.__init__(self)  # 继承多线程父类
        self.q = avatar_queue  # 任务队列

    def run(self):
        # 控制线程是否退出
        while not exitFlag_Load:
            try:
                url, realName = self.q.get(block=False)  # 从url队列中提取一条数据
                print(url)
                url = 'http:' + url # 拼接头像url
                image = requests.get(url).content  # 请求图片
                # 将头像保存下来以头像命名
                with open('./tp/' + realName + '.png', 'wb') as f:
                    f.write(image)
            except:
                pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主程序逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
if __name__ == '__main__':
    # 创建三个队列
    page_queue,data_queue,avatar_queue = Queue(),Queue(),Queue()

    threadcrawl = []
    parsecrawl = []
    loadcrawl = []
    exitFlag_Parser = False  # 线程状态
    exitFlag_Load = False
    # 将任务入队列
    for i in range(1, 1451):
        page_queue.put(i)
    crawl_list = ['crawl_1','crawl_2','crawl_3','crawl_4']
    # 开四个线程
    for crawl_id in crawl_list:
        crawl = ThreadCrawl(page_queue)
        parse = ParseCrawl(data_queue)
        load = LoadImage(avatar_queue)
        # 将全部线程保存到列表
        threadcrawl.append(crawl)
        parsecrawl.append(parse)
        loadcrawl.append(load)

        # 开启线程
        crawl.start()
        parse.start()
        load.start()

    while not page_queue.empty():
        pass
    # 让主线程等待子线程结束
    for t in threadcrawl:
        t.join()

    # 当数据队列为空时通知线程退出
    while  data_queue.empty():
        pass

    exitFlag_Parser = True
    for t in parsecrawl:
        t.join()

    # 当url 队列为空时通知线程退出
    while not avatar_queue.empty():
        pass
    exitFlag_Load = True
    for t in loadcrawl:
        t.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　费了九牛二虎之力终于写完了，开始运行爬虫，小姐姐们一个一个乖乖的往我的硬盘上跑！想想就激动呢！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180117000201896-1969349770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看下我们数据库已经存了很多妹子信息了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1118358/201801/1118358-20180117000229068-1169127218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关于爬虫一些建议：&lt;/p&gt;&lt;p&gt;1、尽量减少请求次数，能抓列表页就不抓详情页，能抓json数据，尽量不抓页面数据。&lt;/p&gt;&lt;p&gt;2、实际应用时候，反爬措施最常见的一般是，检查请求头，封ip, 验证码。封ip可用代理，验证码可机器识别或者接第三方打码平台。&lt;/p&gt;&lt;p&gt;3、爬取速度尽量不要太快，大家都是混碗饭吃，不要把对方服务器爬崩了，在能接受的范围内延时，重要的是将数据爬取下来。&lt;/p&gt;&lt;p&gt;4、一些网站数据加密，数据动态加载的，可用 Selenium调用浏览器获取源码。&lt;/p&gt;

&lt;p&gt;---恢复内容结束---&lt;/p&gt;
</description>
<pubDate>Sun, 04 Feb 2018 07:20:00 +0000</pubDate>
<dc:creator>地球守卫者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangguifeng/p/8413259.html</dc:identifier>
</item>
<item>
<title>样条曲线重参数化 - 饭后温柔</title>
<link>http://www.cnblogs.com/flytrace/p/8413255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flytrace/p/8413255.html</guid>
<description>&lt;p&gt;前几天在做摄像机轨道时，解决匀速定长运动问题，刚好理解了题述问题。&lt;/p&gt;
&lt;p&gt;首先做完这个曲线上匀速运动的编程实现后，是十分愉悦的。这个问题里，两个科学史上的伟人，牛顿和高斯，相继大显身手，怎能不让人膜拜？，我之前并不了解所涉及的数值分析方法，所以觉得很神奇。&lt;/p&gt;
&lt;p&gt;以下为简洁我会使用向量的表示方法，使用大写数字代表向量。以catmullrom样条曲线(spline)为例，对于一个关于t的多次样条曲线:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Q%28t%29+%3D+At%5E%7B3%7D+%2B+Bt%5E%7B2%7D+%2B+Ct+%2B+D&quot; alt=&quot;Q(t) = At^{3} + Bt^{2} + Ct + D&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说实际中，t的范围都是[0, 1]。当t在[0, 1]中滑动时，Q(t)的集合即为一条平滑曲线。注意到当t以匀速移动时，Q(t)在沿曲线方向上并不是匀速移动。要做到这一点，显然曲线长度是需要考虑的。假设在t点处我们有曲线长度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=s+%3D+L%28t%29&quot; alt=&quot;s = L(t)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么s长度所对应的t即为上面方程的反函数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=t+%3D+L%5E%7B-1%7D%28s%29&quot; alt=&quot;t = L^{-1}(s)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反带入Q(t)，得&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Q%28t%29+%3D+Q%28L%5E%7B-1%7D%28s%29%29+%3D+Z%28s%29&quot; alt=&quot;Q(t) = Q(L^{-1}(s)) = Z(s)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;s的区间显然是0到曲线长度，于是我们可以对s做匀速递增从而拿到Z(s)的位置， 从而完成匀速插值。这就是整个思路，难点在于求S=L(t)，这实际上是一个求积分的问题。很遗憾，一般来说此处该问题你是很难得到一个解析的积分公式的，实际中是通过数值计算方法得到该积分值。&lt;/p&gt;
&lt;p&gt;而既然积分值s我们是用的数值方法得到，那很显然求该积分函数的逆，即给定的s对应的t，也只能通过数值方法得到了，我们将会使用牛顿迭代法。&lt;/p&gt;
&lt;p&gt;该积分我们使用Guass-lengendre积分来实现，通过选定的几个积分点及权重，它神奇而快速的得到精度很高的积分值。我们直接来重点吧，该方法需要一张n阶权重表，比如5阶权重表:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/278594/201802/278594-20180204151706279-1106909267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;及一个计算公式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cint_%7Ba%7D%5E%7Bb%7Df%28x%29dx+%3D+%5Cfrac%7Bb-a%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bw_%7Bi%7Df%28%5Cfrac%7Bb-a%7D%7B2%7Dx_%7Bi%7D%2B%5Cfrac%7Bb%2Ba%7D%7B2%7D%29%7D&quot; alt=&quot;\int_{a}^{b}f(x)dx = \frac{b-a}{2}\sum_{i=1}^{n}{w_{i}f(\frac{b-a}{2}x_{i}+\frac{b+a}{2})}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了应用该公式，我们有:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7Bds%7D%7Bdt%7D+%3D+Q%27%28t%29+%5CRightarrow+ds+%3D+Q%27%28t%29dt+%5CRightarrow+s+%3D+%5Cint_%7B0%7D%5E%7Bt%7DQ%27%28x%29dx&quot; alt=&quot;\frac{ds}{dt} = Q'(t) \Rightarrow ds = Q'(t)dt \Rightarrow s = \int_{0}^{t}Q'(x)dx&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q'(t)为Q(t)的导：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Q%27%28t%29+%3D+3At%5E%7B2%7D+%2B+2Bt+%2B+c&quot; alt=&quot;Q'(t) = 3At^{2} + 2Bt + c&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体对于我们的公式，有:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=s%3D+L%28t%29+%3D+%5Cint_%7B0%7D%5E%7Bt%7DQ%27%28x%29dx+%3D+%5Cfrac%7Bt%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bw_%7Bi%7DQ%27%28%5Cfrac%7Bt%7D%7B2%7Dx_%7Bi%7D%2B%5Cfrac%7Bt%7D%7B2%7D%29%7D&quot; alt=&quot;s= L(t) = \int_{0}^{t}Q'(x)dx = \frac{t}{2}\sum_{i=1}^{n}{w_{i}Q'(\frac{t}{2}x_{i}+\frac{t}{2})}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将表中的值依次带入，迭代计算即可得到t点处的积分值s。比我之前快速实现时所采用的线性分割方法快了100倍有没有？特别是该方程的普适性，对于多阶多项式都适用而且精度非常高。有种魔性在这里，高斯是神。&lt;/p&gt;
&lt;p&gt;现在s=L(t)对我们来说是已知了，那么如何求s所对应的t呢?这实际上是求方程:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=L%28t%29+-+s+%3D+0&quot; alt=&quot;L(t) - s = 0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;的根。因为L(t)没有解析表达，我们将使用牛顿迭代法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=b%3D+a+-+%5Cfrac%7Bf%28a%29%7D%7Bf%27%28a%29%7D&quot; alt=&quot;b= a - \frac{f(a)}{f'(a)}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将得到的b的值作为a再带入上述公式，迭代几次即可逼近s = f(x)的根。具体到我们的公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=b%3D+a+-+%5Cfrac%7BL%28a%29+-+s%7D%7BL%27%28a%29%7D&quot; alt=&quot;b= a - \frac{L(a) - s}{L'(a)}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于特定的s，我们首先要拟定一个初值a，因为样条曲线性质良好，而且一般说来实际中不会允许2点间出现陡峭的曲线，一定会多加一些点令2点间曲线形状为凸或凹的，所以我们可以近似认为t在区间[0, 1]的比例，近似等于s与总长度的比例。而显然总长为L(1),通过前面的高斯积分已经可以算出，于是初始值a我们可拟定为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=a+%3D+%5Cfrac%7Bs%7D%7BL%281%29%7D&quot; alt=&quot;a = \frac{s}{L(1)}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反复迭代(3-4次的精度就不错了)，得出最终t值，再把该值反带入Q(t)中，得到对于给定s值所对应的位置，至此我们完成了样条曲线的重参数化。&lt;/p&gt;
</description>
<pubDate>Sun, 04 Feb 2018 07:15:00 +0000</pubDate>
<dc:creator>饭后温柔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flytrace/p/8413255.html</dc:identifier>
</item>
<item>
<title>Android开发——打造简单的Viewpager指示器（小圆点指示器） - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8413231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8413231.html</guid>
<description>&lt;h2&gt;准备工作：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.两张不同颜色的小圆点图片,可以去&lt;a href=&quot;http://www.iconfont.cn/&quot; target=&quot;_blank&quot;&gt;阿里巴巴矢量图&lt;/a&gt;网站搜索&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我把我使用的图片贴出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204141809435-16263351.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204141817654-319860898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.一个简单的Viewpager的实现&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;下面是简单的Viewpager实现步骤：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.布局文件使用Viewpager&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201801/1210268-20180130154401937-1109435052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.定义一个适配器类使其继承PagerAdapter，复写其中的四个方法，分别是getCount，isViewFromObject，instantiateItem和destroyItem&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　@Override
    &lt;span&gt;public &lt;span&gt;int&lt;span&gt; getCount() {
        &lt;span&gt;return 3;&lt;span&gt;//&lt;span&gt;在Viewpager显示3个页面
&lt;span&gt;    }

    @Override
    &lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; isViewFromObject(View view, Object object) {
        &lt;span&gt;return view==&lt;span&gt;object;
    }

    @Override
    &lt;span&gt;public Object instantiateItem(ViewGroup container, &lt;span&gt;int&lt;span&gt; position) {
        TextView tv = &lt;span&gt;new&lt;span&gt; TextView(container.getContext());
        tv.setGravity(Gravity.CENTER);
        tv.setTextSize(20&lt;span&gt;);
        tv.setText(&quot;第&quot; + position + &quot;页&quot;&lt;span&gt;);

        &lt;span&gt;//&lt;span&gt; 添加到ViewPager容器
&lt;span&gt;        container.addView(tv);

        &lt;span&gt;//&lt;span&gt; 返回填充的View对象
        &lt;span&gt;return&lt;span&gt; tv;


    }

    @Override
    &lt;span&gt;public &lt;span&gt;void destroyItem(ViewGroup container, &lt;span&gt;int&lt;span&gt; position, Object object) {
      
        container.removeView((View) object);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.findviewbyid方法找到viewpager&lt;/h3&gt;
&lt;h3&gt;4.设置适配器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204002944640-835136090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;效果图：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204005340359-402790059.gif&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;731&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;开始：&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.布局的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们来到xml文件中，原本里面只有一个viewpager，我们需要再增加个linearlayout，之后用三个linaerlayout水平放置，并且将其平分（平分使用权重weight属性），中间的linearlayout中水平放入三个ImageView，这个三个ImageView同样使用权重将中间的linearlayout给平分，相信这个布局还是比较简单的吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204144127482-1639633075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们放入ImageView之后，将第一个的ImageView的src设置为蓝色的，其他两个则是设置为灰色的，因为刚开始就是显示viewpager的第一页嘛，这个相信大家都能明白&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204144354904-1593185283.png&quot; alt=&quot;&quot; width=&quot;1076&quot; height=&quot;637&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.复写onpagechangeclicklistener中的onPageSelected方法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先，要说明一下，viewpager有一个接口名为onpagechangeclicklistener&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;onPagechangeclicklistener&lt;/span&gt;说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;99&quot;&gt;
&lt;p&gt;&lt;span&gt;ViewPage使用时，最关键的代码就是setOnPageChangeListener，&lt;span&gt;需要注意的是，高版本好像没有这个方法了，改为了addOnPageChangeListener，名称变了，参数没有变化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数是一个ViewPager.SimpleOnPageChangeListener对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ViewPager.SimpleOnPageChangeListener是个接口，有三个方法，下面做介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：ViewPager有两个操作，一个是用手指滑动翻页，一个是直接setCurrentItem（一般用于点击上面的tab直接setCurrentItem）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的方法介绍也会针对这两种情况分别介绍，&lt;/span&gt;&lt;span&gt;最后还会讨论这三个方法相对执行顺序的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.onPageSelected(int position)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法有一个参数position，代表哪个页面被选中。当用手指滑动翻页的时候，如果翻动成功了（滑动的距离够长），手指抬起来就会立即执行这个方法，position就是当前滑动到的页面。如果直接setCurrentItem翻页，那position就和setCurrentItem的参数一致，这种情况在onPageScrolled执行方法前就会立即执行。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;2.onPageScrolled(int position,float positionOffset, int positionOffsetPixels)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法会在屏幕滚动过程中不断被调用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有三个参数，第一个position，这个参数要特别注意一下。当用手指滑动时，如果手指按在页面上不动，position和当前页面index是一致的；如果手指向左拖动（相应页面向右翻动），这时候position大部分时间和当前页面是一致的，只有翻页成功的情况下最后一次调用才会变为目标页面；如果手指向右拖动（相应页面向左翻动），这时候position大部分时间和目标页面是一致的，只有翻页不成功的情况下最后一次调用才会变为原页面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当直接设置setCurrentItem翻页时，如果是相邻的情况（比如现在是第二个页面，跳到第一或者第三个页面），如果页面向右翻动，大部分时间是和当前页面是一致的，只有最后才变成目标页面；如果向左翻动，position和目标页面是一致的。这和用手指拖动页面翻动是基本一致的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果不是相邻的情况，比如我从第一个页面跳到第三个页面，position先是0，然后逐步变成1，然后逐步变成2；我从第三个页面跳到第一个页面，position先是1，然后逐步变成0，并没有出现为2的情况。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;positionOffset是当前页面滑动比例，如果页面向右翻动，这个值不断变大，最后在趋近1的情况后突变为0。如果页面向左翻动，这个值不断变小，最后变为0。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;positionOffsetPixels是当前页面滑动像素，变化情况和positionOffset一致。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;3.onPageScrollStateChanged(int state)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法在手指操作屏幕的时候发生变化。有三个值：0（END）,1(PRESS) , 2(UP) 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当用手指滑动翻页时，手指按下去的时候会触发这个方法，state值为1，手指抬起时，如果发生了滑动（即使很小），这个值会变为2，然后最后变为0 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总共执行这个方法三次。一种特殊情况是手指按下去以后一点滑动也没有发生，这个时候只会调用这个方法两次，state值分别是1,0 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当setCurrentItem翻页时，会执行这个方法两次，state值分别为2 , 0 。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;三个方法的执行顺序为：用手指拖动翻页时，最先执行一遍onPageScrollStateChanged（1），然后不断执行onPageScrolled，放手指的时候，直接立即执行一次onPageScrollStateChanged（2），然后立即执行一次onPageSelected，然后再不断执行onPageScrollStateChanged，最后执行一次onPageScrollStateChanged（0）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其它的情况由这个可以推出来，不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个原理其实我们只需要关注第一个方法即可，即&lt;strong&gt;onPageSelected(int position)，&lt;/strong&gt;当我们翻页了，这个方法就会执行，是viewpager显示参数为position的那页的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们为viewpager设置这个监听器，复写其中的onPageSelected方法，position为0的时候即是第一页，我们为第一个ImageView设置为蓝色圆形，position为1时，为第二个ImageView设置为蓝色圆形，以此类推，&lt;span&gt;记得在之前的xml文件中给三个ImageView定义一个id哦&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204145827076-926611662.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、效果图&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201802/1210268-20180204150322014-753937887.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;大功告成！！&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本来是实现圆点能够移动的，但是，看不懂大神们写的代码，只能简单的实现这样的小圆点了。。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Feb 2018 07:05:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8413231.html</dc:identifier>
</item>
<item>
<title>4.Ray-Handler之CoreHandler编写 - 几维</title>
<link>http://www.cnblogs.com/CharlesZHENG/p/8413193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CharlesZHENG/p/8413193.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;80.687593743304&quot;&gt;
&lt;h4 id=&quot;4-handler-corehandler-&quot;&gt;4.Ray-Handler之CoreHandler编写&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/4BC3080DF87B49D4976D156F91B9A734?method=download&amp;amp;shareKey=eec79b78ea3d87e0031c7804e0f0b78d&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图右上角所示，Ray中有两类Handler（SubHandler和PartSubHandler）,在使用中，SubHandler派生Actor的CoreHandler，PartSubHandler派生SQLToReadHandler，SQLToReadHandler派生Actor的ToReadHandler，使用Ray主要写Actor的CoreHandler和ToReadHandler。&lt;/p&gt;
&lt;p&gt;CoreHandler是复合消息路由器，包含的功能有：消息路由器、消息处理器、消息分离器、消息聚合器、消息过滤器、消息丰富器、副本同步协调器。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;消息路由器：&lt;/h5&gt;
&lt;p&gt;Tell方法中的Switch块，针对不同的Event类型，将Event事件中的数据分发给不同的事件处理方法CoreHandler承担的是消息路由器的作用。如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override Task Tell(byte[] bytes, IActorOwnMessage&amp;lt;string&amp;gt; data, MessageInfo msg)
{
   switch (data)
   {
       case CoinAddressGeneratingResponse value: return AcceptCoinAddressAsync(value);
       case CoinWithdrawWithholdingFailedMsg value: return RollbackWithholdingAsync(value);
       case CoinWithdrawWithheldEvent value: return CreateWithdrawAsync(value);
       case CoinOrderCreatedEvent value: return CreateOrderAsync(value);
       case CoinOrderCreatedEventV1 value: return CreateOrderAsyncV1(value);
       case CoinPlanOrderCreatedEvent value: return CreatePlanOrderAsync(value);
       case CoinDepositIncreasedEvent value: return CoinDepositIncreased(value);
       case CoinIcoEvent value: return CoinIcoEventHandle(value);
       default: return Task.CompletedTask;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;消息处理器：&lt;/h5&gt;
&lt;p&gt;针对不同的Event类型，在该Actor的CoreHandler里处理该事件，CoreHandler承担的是消息处理器的作用。如下代码中，AmountAddEventHandler方法处理AmountTransferEvent事件。&lt;/p&gt;
&lt;p&gt;在事件处理代码中，可编写的代码如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以只针对当前事件处理。&lt;/li&gt;
&lt;li&gt;可以获得其他actor引用，调用其他actor的方法（包括actor的只读方法和写操作方法）。&lt;/li&gt;
&lt;li&gt;可以调用数据访问层进行数据库读写。（写方法建议在ToReadHandler中进行）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public override Task Tell(byte[] bytes, IActorOwnMessage&amp;lt;string&amp;gt; data, MessageInfo msg)
{
    switch (data)
    {
        case AmountTransferEvent value: return AmountAddEventHandler(value);
        default: return Task.CompletedTask;
    }
}

public Task AmountAddEventHandler(AmountTransferEvent value)
{
    var toActor = HandlerStart.Client.GetGrain&amp;lt;IAccount&amp;gt;(value.ToAccountId);
    return toActor.AddAmount(value.Amount, value.Id);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;消息分离器：&lt;/h5&gt;
&lt;p&gt;当需要将较大的消息分割成多个独立的部分，并将这些独立的部分作为其他actor处理的参数时，CoreHandler承担的是分离器的作用。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;消息聚合器：&lt;/h5&gt;
&lt;p&gt;当需要对不同类型消息中的数据进行聚合统计时，CoreHandler承担的是消息聚合器的作用。&lt;br/&gt;例如：在加密货币交易的场景中，有ETH、BTC、USDT不同的市场，EOS在三个市场中都有交易，现在要统计本周内每个用户EOS的交易量，可以如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override Task Tell(byte[] bytes, IActorOwnMessage&amp;lt;string&amp;gt; data, MessageInfo msg)
{
   switch (data)
   {
       case CoinTradeSoldEvent value: return ActivitySellStatistic(value);
       case CoinTradeBoughtEvent value: return ActivityBuyStatistic(value);
       default: return Task.CompletedTask;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;消息过滤器：&lt;/h5&gt;
&lt;p&gt;CoreHandler有可能收到它不感兴趣额的消息，并且需要丢弃这些无用消息时，CoreHandler可以承担消息过滤器的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override Task Tell(byte[] bytes, IActorOwnMessage&amp;lt;string&amp;gt; data, MessageInfo msg)
{
    switch (data)
    {
        case AmountTransferEvent value: return AmountAddEventHandler(value);
        default: return Task.CompletedTask;//消息过滤
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;消息丰富器：&lt;/h5&gt;
&lt;p&gt;当需要将收到的消息分进一步丰富，并将丰富后的消息作为其他actor处理的参数时，CoreHandler承担的是消息丰富器的作用。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;副本同步协调器：&lt;/h5&gt;
&lt;p&gt;Ray中有主actor和副本actor两类actor，副本actor用于分担主actor的压力，执行一些异步操作。当使用副本actor，需要主actor与副本actor保持同步时，需要CoreHandler将关注的事件交给副本actor，此时CoreHandler承担的是副本同步协调器的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override Task Tell(byte[] bytes, IActorOwnMessage&amp;lt;string&amp;gt; data, MessageInfo msg)
 {
     var replicatedRef = HandlerStart.Client.GetGrain&amp;lt;IAccountRep&amp;gt;(data.StateId);//获得副本actor
     var task = replicatedRef.Tell(bytes);//通知副本同步
     switch (data)
     {
         case AmountTransferEvent value: return Task.WhenAll(task, AmountAddEventHandler(value));
         default: return task;
     }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;-&quot;&gt;示例&lt;/h5&gt;
&lt;p&gt;参考Example中，Ray.Handler项目内的&lt;a href=&quot;https://github.com/RayTale/Ray/tree/master/Example&quot;&gt;AccountCoreHandler&lt;/a&gt;。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;总结&lt;/h5&gt;
&lt;p&gt;CoreHandler实际编写中很简单，主要承担消息路由和消息处理器的作用，其他功能为特殊场景提供了切入点。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 04 Feb 2018 06:53:00 +0000</pubDate>
<dc:creator>几维</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CharlesZHENG/p/8413193.html</dc:identifier>
</item>
<item>
<title>ehcache模糊批量移除缓存 - zer0black</title>
<link>http://www.cnblogs.com/zer0Black/p/8410984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zer0Black/p/8410984.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;

&lt;p&gt;众所周知，encache是现在最流行的java开源缓存框架,配置简单,结构清晰,功能强大。通过注解&lt;code&gt;@Cacheable&lt;/code&gt;可以快速添加方法结果到缓存。通过&lt;code&gt;@CacheEvict&lt;/code&gt;可以快速清除掉指定的缓存。&lt;/p&gt;
&lt;p&gt;但由于&lt;code&gt;@CacheEvict&lt;/code&gt;注解使用的是key-value的，不支持模糊删除，就会遇到问题。当我用&lt;code&gt;@Cacheable&lt;/code&gt;配合Spring EL表达式添加了同一方法的多个缓存比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(&quot;/listOfTask/{page}/&quot;)
@Cacheable(value = &quot;BusinessCache&quot;, key = &quot;'listOfTask_'+ #page&quot;)
public ResponseMessage&amp;lt;PageTaskVO&amp;gt; getTaskList(@PathVariable(&quot;page&quot;) String page) {
    do something...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码是分页获取任务信息。用EL表达式获取到参数中的page，并作为缓存的key，使用&lt;code&gt;@Cacheable&lt;/code&gt;添加到ehcache的缓存中。此时，在缓存中就会出现&lt;code&gt;listOfTask_1&lt;/code&gt;, &lt;code&gt;listOfTask_2&lt;/code&gt;, &lt;code&gt;listOfTask_3&lt;/code&gt;这种类型的key。&lt;/p&gt;
&lt;p&gt;当添加、删除任务时，列表就会发生改变。这时候，就需要把&lt;code&gt;listOfTask_*&lt;/code&gt;相关的缓存全部去掉。而这时，我不知道缓存中到底缓存了多少和&lt;code&gt;listOfTask_*&lt;/code&gt;相关的内容，不可能调用&lt;code&gt;@CacheEvict&lt;/code&gt;挨个删除。&lt;/p&gt;
&lt;p&gt;既然ehcache本身无法支持，那就只能靠我们自己实现了。&lt;/p&gt;

&lt;p&gt;考虑到使用的注解添加的缓存，那么移除缓存也使用注解处理，可以保持开发的一致性。注解对开发者来说也很友好。那么我们就考虑使用自定义注解来来模糊批量移除缓存。&lt;/p&gt;
&lt;p&gt;首先，定义注解&lt;code&gt;CacheRemove&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target({ java.lang.annotation.ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
public @interface CacheRemove {
    String value();
    String[] key();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，value 同 ehcache 一样，用于定义要操作的缓存名。key 是一个数组，用于存放多种缓存 key 的正则表达式。起名 &lt;code&gt;CacheRemove&lt;/code&gt; 清晰易懂，也不与 ehcache 本身的注解冲突。注解的定义到此为止。接下来，就需要处理注解了，由于使用的 spring 框架，很自然的，就会想到用 AOP 来做注解的具体实现。&lt;/p&gt;
&lt;p&gt;注解的目的是批量模糊移除缓存。需考虑如下两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用什么方式模糊匹配&lt;/li&gt;
&lt;li&gt;怎么批量删除key&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我给出的处理方式，也是我认为最简单的处理方式是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用什么方式模糊匹配 —— &lt;code&gt;CacheRemove&lt;/code&gt;中的key传正则，可以传多个，使用正则匹配&lt;/li&gt;
&lt;li&gt;怎么批量删除key —— 循环所有的key，找到匹配正则的就删除&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先定义类名&lt;code&gt;CacheRemoveAspect&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Aspect
@Component
public class CacheRemoveAspect {
    @Pointcut(value = &quot;(execution(* *.*(..)) &amp;amp;&amp;amp; @annotation(com.example.CacheRemove))&quot;)
    private void pointcut() {}

    do something...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在切面中定义切点，使用&lt;code&gt;execution(* *.*(..) &amp;amp;&amp;amp; @annotation(com.example.CacheRemove))&lt;/code&gt;表示所有带注解类&lt;code&gt;CacheRemove&lt;/code&gt;都执行，&lt;code&gt;@annotation&lt;/code&gt;中的值是注解的全限定名。&lt;/p&gt;
&lt;p&gt;切点定义完毕，下面的重头戏就是切面的具体实现了。一般来说，缓存会在增删改的方法执行完后才要移除。所以使用&lt;code&gt;@AfterReturning()&lt;/code&gt;来实现。在具体实现中需要做以下几件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拦截方法上的注解&lt;/li&gt;
&lt;li&gt;判断注解是不是&lt;code&gt;CacheRemove&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于注解传入的 key 是个数组，循环处理每个key&lt;/li&gt;
&lt;li&gt;在循环中编制每个 key 为 pattern， 并循环所有的缓存，移除匹配上的缓存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@AfterReturning(value = &quot;pointcut()&quot;)
private void process(JoinPoint joinPoint){
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    Method method = signature.getMethod();
    CacheRemove cacheRemove = method.getAnnotation(CacheRemove.class);

    if (cacheRemove != null){
        String value = cacheRemove.value();
        String[] keys = cacheRemove.key(); //需要移除的正则key

        List cacheKeys = CacheUtils.cacheKeys(value);
        for (String key : keys){
            Pattern pattern = Pattern.compile(key);
            for (Object cacheKey: cacheKeys) {
                String cacheKeyStr = String.valueOf(cacheKey);
                if (pattern.matcher(cacheKeyStr).find()){
                    CacheUtils.remove(value, cacheKeyStr);
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，为 ehcache 模糊批量移除缓存的具体实现。其中 BusinessCacheUtils 为自己封装的 ehcache 工具类。主要实现获取缓存池，获取缓存，移除缓存，添加缓存，查看所有缓存等正常功能。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CacheUtils {

    private static CacheManager cacheManager = SpringContextHolder.getBean(&quot;ehCacheManagerFactory&quot;);

    public static Object get(String cacheName, String key) {
        Element element = getCache(cacheName).get(key);
        return element == null ? null : element.getObjectValue();
    }

    public static void put(String cacheName, String key, Object value) {
        Element element = new Element(key, value);
        getCache(cacheName).put(element);
    }

    public static void remove(String cacheName, String key) {
        getCache(cacheName).remove(key);
    }

    public static List cacheKeys(String cacheName){
        return getCache(cacheName).getKeys();
    }

   /**
     * 获得一个Cache，没有则创建一个。
     * @param cacheName
     * @return
     */
    private static Cache getCache(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache == null) {
            cacheManager.addCache(cacheName);
            cache = cacheManager.getCache(cacheName);
            cache.getCacheConfiguration().setEternal(true);
        }
        return cache;
    }

    public static CacheManager getCacheManager() {
        return cacheManager;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，整个ehcache 模糊批量移除缓存的功能就实现了。&lt;/p&gt;

&lt;p&gt;整个过程思路简单，用到了一些 AOP 的知识就完成了需要的功能。但具体的移除部分代码可考虑进行优化。通过一次缓存的全部循环，就把需要移除的缓存都移除干净，而不是想现在这样有几个key，就全缓存遍历几次。具体实现留给读者自行完成。希望对各位有所帮助。&lt;/p&gt;
</description>
<pubDate>Sun, 04 Feb 2018 06:36:00 +0000</pubDate>
<dc:creator>zer0black</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zer0Black/p/8410984.html</dc:identifier>
</item>
<item>
<title>【ASP.NET Core】MVC中自定义视图的查找位置 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8412827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8412827.html</guid>
<description>&lt;p&gt;.NET Core 的内容处处可见，刷爆全球各大社区，所以，老周相信各位大伙伴已经看得不少了，故而，老周不考虑一个个知识点地去写，那样会成为年度最大的屁话，何况官方文档也很详尽。老周主要扯一下大伙伴们在入门的时候可能会疑惑的内容。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 可以在一个项目中混合使用 Web Pages 和 MVC ，这是老周最希望的，因为这样会变得更灵活。Web Pages 类似于我们过去的 Web 开发方式，以页面为单位，此模型侧重于功能划分。而 MVC 侧重于数据，有什么样的数据模型就有什么样的 Controller，有什么样的 Controller 就会对应什么样的 Action ，而 Action 又会有对应的 UI，即 View。所以说 MVC 是以数据为核心的。&lt;/p&gt;
&lt;p&gt;如果两者可以同时使用，那在我的项目中，可能有些内容以功能为重点，而另一些内容是以数据为中心的，这样可以灵活地交替使用，因此，老周向来最喜欢空项目模板，因为空的什么都没有，什么都没有才能做到什么都有。大概，老庄所说的“无”，与佛家所说的“空”，就是这样的。&lt;/p&gt;
&lt;p&gt;Web Pages 和 MVC 可以一起用，是因为它们的配置方法是一样的，在 Startup 类中，有两个约定的方法。&lt;/p&gt;
&lt;p&gt;ConfigureServices 方法是告诉应用程序我要用到哪些功能，Service 是用来扩展的，你自己也可以编写各种功能，然后添加到 services 集合中就好了。不管是 W　　eb Pages 还是 MVC ，都是添加这一行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;em&gt;&lt;strong&gt;services.AddMvc();
&lt;/strong&gt;&lt;/em&gt;        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;估计大家会发现，除了 AddMvc 方法外，还有一个 AddMvcCore 方法，你一定会有疑问，这两个家伙一家吗？于是，你会尝试一下把 AddMvc 换成 AddMvcCore ，然后运行时你会发现找不到视图。&lt;/p&gt;
&lt;p&gt;带 Core 结尾的方法，只添加核心的功能，并非 MVC 所需的必备功能，此方法也许更适合 Web API，但即便我们写的是 API 项目，我们也极少用这个方法，所以，在实际开发中，你可以直接无视 AddMvcCore 方法。&lt;/p&gt;
&lt;p&gt;那么，这哥儿俩到底有啥不同呢。咱们不妨看看源代码。AddMvcCore 主要添加了以下功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Options
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;MvcOptions&amp;gt;, MvcCoreMvcOptionsSetup&amp;gt;&lt;span&gt;());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IPostConfigureOptions&amp;lt;MvcOptions&amp;gt;, MvcOptionsConfigureCompatibilityOptions&amp;gt;&lt;span&gt;());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;ApiBehaviorOptions&amp;gt;, ApiBehaviorOptionsSetup&amp;gt;&lt;span&gt;());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IConfigureOptions&amp;lt;RouteOptions&amp;gt;, MvcCoreRouteOptionsSetup&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Action Discovery
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; These are consumed only when creating action descriptors, then they can be deallocated&lt;/span&gt;
&lt;span&gt;
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IApplicationModelProvider, DefaultApplicationModelProvider&amp;gt;&lt;span&gt;());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IApplicationModelProvider, ApiBehaviorApplicationModelProvider&amp;gt;&lt;span&gt;());
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IActionDescriptorProvider, ControllerActionDescriptorProvider&amp;gt;&lt;span&gt;());

            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionDescriptorCollectionProvider, ActionDescriptorCollectionProvider&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Action Selection
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            services.TryAddSingleton&amp;lt;IActionSelector, ActionSelector&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;ActionConstraintCache&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Will be cached by the DefaultActionSelector&lt;/span&gt;
&lt;span&gt;            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IActionConstraintProvider, DefaultActionConstraintProvider&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Controller Factory
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This has a cache, so it needs to be a singleton&lt;/span&gt;
            services.TryAddSingleton&amp;lt;IControllerFactory, DefaultControllerFactory&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Will be cached by the DefaultControllerFactory&lt;/span&gt;
            services.TryAddTransient&amp;lt;IControllerActivator, DefaultControllerActivator&amp;gt;&lt;span&gt;();

            services.TryAddSingleton&lt;/span&gt;&amp;lt;IControllerFactoryProvider, ControllerFactoryProvider&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IControllerActivatorProvider, ControllerActivatorProvider&amp;gt;&lt;span&gt;();
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IControllerPropertyActivator, DefaultControllerPropertyActivator&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Action Invoker
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The IActionInvokerFactory is cachable&lt;/span&gt;
            services.TryAddSingleton&amp;lt;IActionInvokerFactory, ActionInvokerFactory&amp;gt;&lt;span&gt;();
            services.TryAddEnumerable(
                ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;IActionInvokerProvider, ControllerActionInvokerProvider&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; These are stateless&lt;/span&gt;
            services.TryAddSingleton&amp;lt;ControllerActionInvokerCache&amp;gt;&lt;span&gt;();
            services.TryAddEnumerable(
                ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IFilterProvider, DefaultFilterProvider&amp;gt;&lt;span&gt;());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Request body limit filters
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            services.TryAddTransient&amp;lt;RequestSizeLimitFilter&amp;gt;&lt;span&gt;();
            services.TryAddTransient&lt;/span&gt;&amp;lt;DisableRequestSizeLimitFilter&amp;gt;&lt;span&gt;();
            services.TryAddTransient&lt;/span&gt;&amp;lt;RequestFormLimitsFilter&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error description&lt;/span&gt;
            services.TryAddSingleton&amp;lt;IErrorDescriptionFactory, DefaultErrorDescriptorFactory&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ModelBinding, Validation
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The DefaultModelMetadataProvider does significant caching and should be a singleton.&lt;/span&gt;
            services.TryAddSingleton&amp;lt;IModelMetadataProvider, DefaultModelMetadataProvider&amp;gt;&lt;span&gt;();
            services.TryAdd(ServiceDescriptor.Transient&lt;/span&gt;&amp;lt;ICompositeMetadataDetailsProvider&amp;gt;(s =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = s.GetRequiredService&amp;lt;IOptions&amp;lt;MvcOptions&amp;gt;&amp;gt;&lt;span&gt;().Value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultCompositeMetadataDetailsProvider(options.ModelMetadataDetailsProviders);
            }));
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IModelBinderFactory, ModelBinderFactory&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IObjectModelValidator&amp;gt;(s =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = s.GetRequiredService&amp;lt;IOptions&amp;lt;MvcOptions&amp;gt;&amp;gt;&lt;span&gt;().Value;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metadataProvider = s.GetRequiredService&amp;lt;IModelMetadataProvider&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultObjectValidator(metadataProvider, options.ModelValidatorProviders);
            });
            services.TryAddSingleton&lt;/span&gt;&amp;lt;ClientValidatorCache&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;ParameterBinder&amp;gt;(s =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = s.GetRequiredService&amp;lt;IOptions&amp;lt;MvcOptions&amp;gt;&amp;gt;&lt;span&gt;().Value;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggerFactory = s.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; metadataProvider = s.GetRequiredService&amp;lt;IModelMetadataProvider&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelBinderFactory = s.GetRequiredService&amp;lt;IModelBinderFactory&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelValidatorProvider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeModelValidatorProvider(options.ModelValidatorProviders);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterBinder(metadataProvider, modelBinderFactory, modelValidatorProvider, loggerFactory);
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Random Infrastructure
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            services.TryAddSingleton&amp;lt;MvcMarkerService, MvcMarkerService&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;ITypeActivatorCache, TypeActivatorCache&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IUrlHelperFactory, UrlHelperFactory&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IHttpRequestStreamReaderFactory, MemoryPoolHttpRequestStreamReaderFactory&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IHttpResponseStreamWriterFactory, MemoryPoolHttpResponseStreamWriterFactory&amp;gt;&lt;span&gt;();
            services.TryAddSingleton(ArrayPool&lt;/span&gt;&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;&lt;span&gt;.Shared);
            services.TryAddSingleton(ArrayPool&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;.Shared);
            services.TryAddSingleton&lt;/span&gt;&amp;lt;OutputFormatterSelector, DefaultOutputFormatterSelector&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;ObjectResult&amp;gt;, ObjectResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;PhysicalFileResult&amp;gt;, PhysicalFileResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;VirtualFileResult&amp;gt;, VirtualFileResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;FileStreamResult&amp;gt;, FileStreamResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;FileContentResult&amp;gt;, FileContentResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;RedirectResult&amp;gt;, RedirectResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;LocalRedirectResult&amp;gt;, LocalRedirectResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;RedirectToActionResult&amp;gt;, RedirectToActionResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;RedirectToRouteResult&amp;gt;, RedirectToRouteResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;RedirectToPageResult&amp;gt;, RedirectToPageResultExecutor&amp;gt;&lt;span&gt;();
            services.TryAddSingleton&lt;/span&gt;&amp;lt;IActionResultExecutor&amp;lt;ContentResult&amp;gt;, ContentResultExecutor&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Route Handlers
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            services.TryAddSingleton&amp;lt;MvcRouteHandler&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only one per app&lt;/span&gt;
            services.TryAddTransient&amp;lt;MvcAttributeRouteHandler&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Many per app

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Middleware pipeline filter related
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            services.TryAddSingleton&amp;lt;MiddlewareFilterConfigurationProvider&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This maintains a cache of middleware pipelines, so it needs to be a singleton&lt;/span&gt;
            services.TryAddSingleton&amp;lt;MiddlewareFilterBuilder&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码很长，看不懂也没关系，反正你知道它添加这么一堆核心功能。&lt;/p&gt;
&lt;p&gt;我们再来看看 AddMvc 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; services.AddMvcCore();

            builder.AddApiExplorer();
            builder.AddAuthorization();

            AddDefaultFrameworkParts(builder.PartManager);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Order added affects options setup order

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default framework order&lt;/span&gt;
&lt;span&gt;            builder.AddFormatterMappings();
            builder.AddViews();
            builder.AddRazorViewEngine();
            builder.AddRazorPages();
            builder.AddCacheTagHelper();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +1 order&lt;/span&gt;
            builder.AddDataAnnotations(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; +1 order

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +10 order&lt;/span&gt;
&lt;span&gt;            builder.AddJsonFormatters();

            builder.AddCors();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意这句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; builder = services.AddMvcCore();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这说明，运行时是先调用 AddMvcCore 方法添加核心的功能后，再添加 MVC 所必备的其他功能。尤其是下面这几行，很重要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            builder.AddViews();
            builder.AddRazorViewEngine();
            builder.AddRazorPages();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在你明白为什么调用 AddMvcCore 方法后会找不到视图的原因了吧。&lt;/p&gt;

&lt;p&gt;扯远了，咱们还是回到 Startup 类来，弄完 ConfigureServices 方法后，还要在 Configure 方法中 use 一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

           &lt;em&gt;&lt;strong&gt; app.UseMvc();
&lt;/strong&gt;&lt;/em&gt;        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别以为在 services 上面 add 完后就能用，那是两回事，services 集合仅仅说明添加功能，并不代表启用功能，UseMvc 是告诉应用程序在接收到 HTTP 请求后用 MVC 方式进行处理，些时相关的功能才会以中间件的形式插入到 HTTP 处理管道中。&lt;/p&gt;
&lt;p&gt;你可以把 HTTP 处理管道看作一个生产线，而 services 集合中添加的内容相当于采购，我生产过程用到锄头，你帮我买，我用到馒头，你帮我买，我用到铁钳，你帮我买。至于说你买来后怎么用，用多少，那是生产线上的事情了。&lt;/p&gt;
&lt;p&gt;你可以把 ConfigureServices 方法看作是买菜，把 Configure 方法看作是下厨。&lt;/p&gt;

&lt;p&gt;这里顺便废话一下，Startup 类你是可以改为其他名字的，比如叫 MyStart，然后在 Main 入口处改一下 UseStartup 就行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            WebHost.CreateDefaultBuilder(args)
                &lt;em&gt;&lt;strong&gt;.UseStartup&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&amp;lt;MyStart&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;()
&lt;/strong&gt;&lt;/em&gt;                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行的时候，程序会优先查找 Startup 这个名字，如果找不到再找其他的，所以，这个类名没必要改，这样还能减少程序查找的成本，反正你改了名字也没什么实际意义的，还是按照约定来吧。ConfigureServices 方法和 Configure 方法你是不能改的，因为程序会通过反射来找这两个方法。&lt;/p&gt;

&lt;p&gt;说了那么多，下面进入咱们主题，我们知道，默认的约会是把视图页面放到 /Views 目录下的，并且按照 Controller 的名字建立子目录，以 Action 的名字来命名页面文件。&lt;/p&gt;
&lt;p&gt;比如，有个 Controller 叫 Home ，里面有个 Action 叫 Test，那么默认的视图应该是这样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  /&lt;span&gt;Views
     &lt;/span&gt;|--- /&lt;span&gt;Home
         &lt;/span&gt;|--- /Test.cshtml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意文件与目录名是严格区分大小写的，如果 Controller 是 Demo，你的目录是 demo ，是找不到视图，尤其是在 Linux 等系统上运行时，更加要严格遵守大小写的规则。&lt;/p&gt;
&lt;p&gt;有时候，老周会觉得这样的路径不爽，目录层次套得多，老周喜欢对页面文件这样命名：Controller-Action.cshtml。例如，Controller 叫 Home，其中一个 Action 叫 Index ，那么视图页的名字就是 Home-Index.cshtml。&lt;/p&gt;
&lt;p&gt;那么，我们该怎么修改默认的视图查找位置呢。不急，先来看看人家默认的视图查找位置。在 Configure 方法中加入以下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.UseMvc();&lt;/span&gt;
            app.Run(&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出选项实例&lt;/span&gt;
                &lt;em&gt;&lt;strong&gt;IOptions&amp;lt;RazorViewEngineOptions&amp;gt; razoropt = app.ApplicationServices.GetService&amp;lt;IOptions&amp;lt;RazorViewEngineOptions&amp;gt;&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; locations =&lt;span&gt; razoropt.Value.ViewLocationFormats;
                StringBuilder strbd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; locations)
                {
                    strbd.AppendLine(item);
                }
                &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这一行不要少，少了会乱码&lt;/span&gt;
                context.Response.ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain;charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;视图的默认查找位置：\n{strbd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意一个代码约定，services 集合添加功能时，经常会附带各种选项类，而为了便于识别，选项类通常是以 Options 结尾，比如，上面代码中的 RazorViewEngineOptions。&lt;/p&gt;
&lt;p&gt;还记得上面老周贴的源代码吗，在 AddMvc 方法中有这一句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
builder.AddRazorViewEngine();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这会使得 RazorViewEngineOptions 类的实例被加入到依赖注入的列表中，而 services 集合所添加的各种东东会合并到 app.ApplicationServices 属性上，所以，我们通过这个属性可以取出 RazorViewEngineOptions 实例，但是，你要记得：凡是选项配置类都是用 IOptions&amp;lt;TOptions&amp;gt; 泛型对象来包装，虽然它是个接口，其实现类型也许在这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204120843420-1424162452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;依赖注入类型在注册时往往是以接口类型为 key ，这样一来我们无需考虑它有哪些实现类型，只要统一用 IOptions 接口就能获取对应的选项类实例。&lt;/p&gt;
&lt;p&gt;所以你要记住这个约定，选项类都用 IOptiions&amp;lt;TOptions&amp;gt; 类型来包装，并且其 Value 属性中获取选项类的实例，这种约定也是为了区分类型的用途，因为所有类型都可以加入依赖注入列表中的，只有带 IOption 包装的才是选项类。&lt;/p&gt;
&lt;p&gt;要自定义视图的查找方法，你不必要实现 IViewLocationExpander 接口，你只需要修改 RazorViewEngineOptions 类的以下三个属性即可：&lt;/p&gt;
&lt;p&gt;1、PageViewLocationFormats：专用于 Web Pages 模型，定义查找 Razor 页面的查找位置。&lt;/p&gt;
&lt;p&gt;2、AreaViewLocationFormats：定义带 area 的 MVC 模型的 View 页面位置。这个也许你有些陌生，一般 MVC 应用我们少加 area，它的作用可以将 MVC 模型进行分组，比如 admin 组中有 MVC，users 组中也有 MVC，只是前者不能随便访问。&lt;/p&gt;
&lt;p&gt;3、ViewLocationFormats：这是咱们今天的重点，也是最常用的。用于定义视图的查找位置。&lt;/p&gt;

&lt;p&gt;这些属性都是字符列表，可以动态增减。现在我们运行应用，看看上面的代码所输出的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204121927232-2099135745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，默认主要查找两个目录，Views 和它的子目录 Shared。&lt;/p&gt;
&lt;p&gt;这时候，你注意到，路径中有参数，{1} 表示 Controller 名称，{0} 表示 Action 名称。如果 Controller = Home, Action = Index，那么，查找的视图页就是 /Views/Home/Index.cshtml。&lt;/p&gt;
&lt;p&gt;可能你又要问了，为什么参数 0 是 Action名，参数 1 是 Controller名呢，这顺序怎么是反过来的？对的，如果有 Area 的话，路径就可以变成 /{2}/Views/{1}/{0}.cshtml。&lt;/p&gt;
&lt;p&gt;因为 Action 名是必须的，Controller 次之，Area 许多时候可以忽略，所以，Action 名字的参数位置是 0。有的视图页是不需要限定 Controller 名称的，比如以下这几个特殊页面：_Layout.cshtml、_ViewStart.cshtml、_ViewImports.cshtml。在查找这几个视图时，Action 名称直接就叫 ”_Layout“、”_ViewStart“、”_ViewImports“，不需要指定 Controller 的名字。&lt;/p&gt;

&lt;p&gt;好了，知道上面这些原理，相信你也懂得怎么动手了，接下来，老周就以改为 /视图/Controller-Action.cshtml 为例。&lt;/p&gt;
&lt;p&gt;在项目中新建两个目录，咱们来个中文名，就叫”控制器“和”视图“。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204123441998-602744252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，Controller 类放哪儿都行，因为它们是代码，最终会参与编译的，我们要处理的主要是View。&lt;/p&gt;
&lt;p&gt;我们写一个 DemoController 控制器，按照约定，就叫 DemoController，其实类名叫 Demo 也行的。&lt;/p&gt;
&lt;p&gt;然后里面写一个简单的 Test 方法，作为 Action，直接返回与该 Action 关联的视图页。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Test()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着，在 视图 目录下，加一个叫 Demo-Test.cshtml 的文件。注意大小写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204124233060-846099181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后，很重要一步，就是在 Startup.ConfigureServices 方法中加入自定义的视图搜索路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddRazorOptions(opt &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;strong&gt;&lt;em&gt;opt.ViewLocationFormats.Clear();&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空默认的列表&lt;/span&gt;
                opt.ViewLocationFormats.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/视图/{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; RazorViewEngine.ViewExtension);
                opt.ViewLocationFormats.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/视图/{1}-{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt; RazorViewEngine.ViewExtension);
&lt;/em&gt;&lt;/strong&gt;            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里为什么要加一条 /视图/{0}.cshtml 呢，前面说过了，有的特殊页面是只有 Action 的，如 _Layout.cshtml。RazorViewEngine.ViewExtension 是个静态字段，表示视图页的扩展名，其实就是 .cshtml，所以这里你完全可以直接写.cshtml。&lt;/p&gt;

&lt;p&gt;这时候，运行程序，从 http://&amp;lt;your host&amp;gt;:&amp;lt;your port&amp;gt;/Demo/Test 访问，就能找到视图 Demo-Test.cshtml 了。输入 URL 时是不分大小写的，但是，在代码中查找视图时是区分大小写的。&lt;/p&gt;
&lt;p&gt;但为了方便测试，我们在 UseMvc 时加个带默认值的路由。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

           &lt;em&gt;&lt;strong&gt; app.UseMvc(r &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;strong&gt;=&amp;gt;&lt;span&gt; {
                r.MapRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hehe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Demo}/{action=Test}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;);
            });
&lt;/strong&gt;&lt;/em&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路由规则需要一个名字，这个名字有啥用，以后再告诉你。&lt;/p&gt;

&lt;p&gt;此时，运行应用就很方便了，直接根 URL 上去就能看到视图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204125553498-946274014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;再补充一下问题，在 Program.cs 文件中，如果你调用的是默认的 CreateDefaultBuilder 方法是很好办的，因为它会为我们配置好一切。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            BuildWebHost(args).Run();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是，如果你自己改写了代码，比如这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
                       .UseKestrel()
                       .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                       .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                       .Build();
            host.Run();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ASP.NET Core 应用可以独立运行，Kestrel 是传说中的神兽，有了这只神兽，你可以跨平台独立运行。如果你只在 Windows 上独立，除了神兽外，你还可以用 HttpSys。这里我顺便指定了 URL ，端口是 9999。&lt;/p&gt;
&lt;p&gt;运行后，把这个 URL 复制到浏览器可以进行访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204130359701-1648542924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但，你再也找不到视图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/367389/201802/367389-20180204130454373-1317230693.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 为什么呢？因为少了一句代码。你到 \bin 目录下看看，编译只生成了.dll，并没有复制页面和其他资源，而上面的代码执行后，默认是在这个 bin 下面找资源的，所以找不到了。&lt;/p&gt;
&lt;p&gt;解决方法是加上这一句代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
                       .UseKestrel()
                       &lt;em&gt;&lt;strong&gt;.UseContentRoot(Directory.GetCurrentDirectory())
&lt;/strong&gt;&lt;/em&gt;                       .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                       .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                       .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加上这一句后，应用会自动处理当前目录的路径，调试阶段，它查找的是 VS 项目所在的目录，所以能找到视图。而在网站发布后，当前目录会自动变为 .dll 所在的目录，发布时会自动复制项目的资源。&lt;/p&gt;
&lt;p&gt;好了，本文说到这里了，88。&lt;/p&gt;

</description>
<pubDate>Sun, 04 Feb 2018 05:12:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8412827.html</dc:identifier>
</item>
<item>
<title>ng机器学习视频笔记（十六）  ——从图像处理谈机器学习项目流程 - lin_h</title>
<link>http://www.cnblogs.com/linhxx/p/8412846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhxx/p/8412846.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;ng机器学习视频笔记（十六）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;——从图像处理谈机器学习项目流程&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（转载请附上本文链接——linhxx）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一、概述&lt;/p&gt;
&lt;p&gt;         这里简单讨论图像处理的机器学习过程，主要讨论的是机器学习的项目流程。采用的业务示例是OCR（photo optical character recognition，照片光学字符识别），通过一张照片，识别出上面所有带字符的内容。&lt;/p&gt;

&lt;p&gt;二、机器学习流水线&lt;/p&gt;
&lt;p&gt;         对于一个业务项目，通常机器学习是其中一部分的内容，对于整个项目而言，相当于一个流水线(pipeline)。&lt;/p&gt;
&lt;p&gt;         对于OCR，主要流水线为：1-获取照片-&amp;gt;2-字符串区域识别-&amp;gt;3-字符串分割-&amp;gt;4字符辨认-&amp;gt;5-输出结果。其中2~4步都是对结果非常重要的步骤。如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115406076-389210385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、滑动窗口&lt;/p&gt;
&lt;p&gt;         滑动窗口(sliding windows)，通过指定大小的方框，从图片左上角开始，扫描全图，旨在最终识别出需要的内容，如字符串，并用明显的颜色标出。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115410701-1649735977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、行人识别&lt;/p&gt;
&lt;p&gt;         下面先讨论行人识别。&lt;/p&gt;
&lt;p&gt;1）监督学习&lt;/p&gt;
&lt;p&gt;         下面进行监督学习，指定图像的像素是82*36，给出一些这样大小的图片且里面有行人的，标记为分类结果是1；再给一些这样大小的图片，里面没有行人，分类结果标记为0。将这些数据进行监督学习，让机器懂得判断82*36像素的图片，是否有行人。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115414310-904769267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2）滑动窗口&lt;/p&gt;
&lt;p&gt;         首先，用82*36像素，从图像左上角开始，扫描全图，每次右移的位置是一个参数，这个参数设置太小虽然很精确，但是会很慢，通常设置为2~5像素。到达最右边后，会回到最左边，并稍稍往下，再进行第二行的扫描，同样，往下的像素也是一个参数。&lt;/p&gt;
&lt;p&gt;         接着，用比82*36大一些的像素，进行扫描全图（大多少同样是参数设定）。但是这里要注意的是，每次取到一块图，要压缩到82*36像素，给前面步骤训练好的分类器进行判别。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115422217-1270284893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、字符识别&lt;/p&gt;
&lt;p&gt;         1）监督学习&lt;/p&gt;
&lt;p&gt;         同样，选一些有字符的标记为1，没字符的标记为0，进行监督学习。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115425529-1633346092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;         2）滑动窗口&lt;/p&gt;
&lt;p&gt;         同样使用滑动窗口进行检测，区别之处在于，把识别的结果重新生成一幅灰白黑图，颜色越白表示该区域是字符的概率越大，白色表示肯定是字符，黑色表示肯定不是，灰色的深浅表示可能性（如果旁边还有白色，则可能判定为也是字符）。&lt;/p&gt;
&lt;p&gt;         接着，输出结果乘以一个膨胀算子（expand operator），这样可以放大结果，让白色更白，黑色更黑，以便于识别结果。&lt;/p&gt;
&lt;p&gt;         最后再抛弃一些不规则的矩形，剩下的就认为是识别到的字符。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115429982-1312002872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、字符分割&lt;/p&gt;
&lt;p&gt;         字符分割，也用到滑动窗口技术，但是这里称为一维滑动窗口，因为固定了长宽，就一次性扫描一行内容（每次移动的边界还是需要设定的参数）。&lt;/p&gt;
&lt;p&gt;         这里的监督学习，用到的是学习判断图的正中间是否是字符的边界，对于是边界的则画上一条竖线，标记分割完成。如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115433685-727215772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;四、人工数据合成&lt;/p&gt;
&lt;p&gt;         对于机器学习，如果数据不够多，可以考虑使用人工数据合成（artificial data synthesis），即可以理解为“造数据”。但是，造数据也不是随意造的，主要做的工作有以下几点。&lt;/p&gt;
&lt;p&gt;1、取各种字体&lt;/p&gt;
&lt;p&gt;         字体多种多样，在一些网站有开源的字体，里面每个字符都有大量的样式，这就需要对机器进行训练，以便其识别到各种样式的字体，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115437764-1704962193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、字符扭曲&lt;/p&gt;
&lt;p&gt;         由于照片上的字未必是方方正正的，因此字符扭曲很重要，让机器识别出各种扭曲的字符，其也是正确的字符，这样有助于提高识别率，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115440998-1216140179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、注意事项&lt;/p&gt;
&lt;p&gt;         这里的造数据，要考虑到造数据的有效性，即需要的是模拟出各种有可能的情况，而不是仅仅加入一些无意义的噪声。例如下图的第一个内容，字符扭曲，对于识别就有好处；而第二个内容，只是对字符加入一些随机的小噪声，这样对于识别就没有太大用处。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115444279-309527238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;五、上限分析&lt;/p&gt;
&lt;p&gt;         当一个机器学习流水线项目完成，评估后发现正确率不符合预期要求，此时需要考虑对流水线的内容进行优化。但是，流水线的步骤繁多，不可能全盘优化，因此，就需要用到上限分析（ceiling analysis）的分析方案。&lt;/p&gt;
&lt;p&gt;         上限分析类似生物学到的控制变量法，通过逐个控制流水线的不确定因素，来衡量如果将某个步骤优化到100%精确度，对于整个系统精确度的提升会有多少。&lt;/p&gt;
&lt;p&gt;1、串行流水线&lt;/p&gt;
&lt;p&gt;         考虑到串行流水线，假设最终的算法结果的精确度是72%。&lt;/p&gt;
&lt;p&gt;         做法：&lt;/p&gt;
&lt;p&gt;1）对于流水线的每个步骤，从第一个步骤开始，不使用算法，而是直接人工给出第一步应该有的、100%正确的结果，此时再看整个系统的精确度。通过计算此时系统精确度与原始系统精确度的差，可以判断出如果将第一步优化到完美，对整个系统精确度的提升能有多少。&lt;/p&gt;
&lt;p&gt;注意：衡量精确度要用同样的计算方式。&lt;/p&gt;
&lt;p&gt;         2）接着，在第一步的基础上，将第二个步骤也直接给出应有的结果，查看此时的精确度，减去第一步的系统精确度，得出将第二步优化到最佳，对系统精确度的提升的贡献度。&lt;/p&gt;
&lt;p&gt;         3）以此类推，直到计算出每一步的精确度的改进范围，将最需要改进的步骤着重进行优化改进。&lt;/p&gt;
&lt;p&gt;         如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115449576-65486435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、并行流水线&lt;/p&gt;
&lt;p&gt;         对于机器学习，某些步骤需要并行完成，此时同样可以计算精确度，而且用的方式和串行完全一样，不赘述，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115453185-1278697573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;六、总结&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204115456826-1839819661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;         这里是对整个视频课程的总结，在视频课程中，主要分为监督学习、无监督学习、机器学习应用、机器学习技巧四个部分内容，在学习过程中，我认为最有难度的部分，在于BP算法、SVM算法这两个算法的数学推导论证过程，目前我觉得我只达到基本明白的程度，后续还要加强学习。&lt;/p&gt;
&lt;p&gt;         机器学习的算法很巧妙，而且非常有趣，拓宽了我的思维，另外也让我更有信心继续后面的学习。&lt;/p&gt;

&lt;p&gt;七、感悟&lt;/p&gt;
&lt;p&gt;到此为止，学完吴恩达的coursera的机器学习课程，113集，大致20个小时的课程，历时32天（其间我同时完成《机器学习实战》前六章的课程编程与学习），有种终于要正式开始了的感觉。&lt;/p&gt;
&lt;p&gt;         这里仅仅是入门，可能甚至只是还在门边初探机器学习的内容。&lt;/p&gt;
&lt;p&gt;接下来，视频课程部分，我计划学习吴恩达的深度学习微专业；书籍部分，我会先学完《机器学习实战》，接着开始周志华的《机器学习》（俗称西瓜书），巩固机器学习的内容。至于TF框架、机器学习的具体方向、深度学习花书以及其他各种视频、书籍等内容，后续会持续进行。&lt;/p&gt;
&lt;p&gt;2018，加油~&lt;/p&gt;

&lt;p&gt;——written by linhxx&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更多最新文章，欢迎关注微信公众号“决胜机器学习”，或扫描右边二维码。&lt;/strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/669000/201802/669000-20180204105902357-636507966.jpg&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Feb 2018 03:55:00 +0000</pubDate>
<dc:creator>lin_h</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhxx/p/8412846.html</dc:identifier>
</item>
<item>
<title>【JDK1.8】JDK1.8集合源码阅读——Set汇总 - joemsu</title>
<link>http://www.cnblogs.com/joemsu/p/8412715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joemsu/p/8412715.html</guid>
<description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;这一篇里，我将对HashSet、LinkedHashSet、TreeSet进行汇总分析，并不打算一一进行详细介绍，因为JDK对Set的实现进行了取巧。我们都知道Set不允许出现相同的对象，而Map也同样不允许有两个相同的Key（出现相同的时候，就执行更新操作）。所以Set里的实现实际上是调用了对应的Map，将Set的存放的对象作为Map的Key。&lt;/p&gt;

&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;p&gt;这里笔者就以最常用的HashSet为例进行分析，其余的TreeSet、LinkedHashSet类似，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;结构概览&quot;&gt;2.1 结构概览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1256203/201802/1256203-20180204111503029-1496324593.png&quot; alt=&quot;HashSetStruct&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关系也很简单，实现了Set的接口，继承了AbstractSet抽象类，抽象类里面定义了集合的常见操作，与我们之前分析过的ArrayList之类的相似。&lt;/p&gt;

&lt;h3 id=&quot;成员变量&quot;&gt;2.2 成员变量&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// HashMap就是HashSet里实现具体操作的对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; HashMap&amp;lt;E,Object&amp;gt; map;
&lt;span class=&quot;co&quot;&gt;// 将对象作为Value存进去&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object PRESENT = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于使用Map进行操作，把E作为Key，要定义一个PRESENT对象作为Value，每个存入的对象都使用它来作为Value。&lt;/p&gt;

&lt;h3 id=&quot;构造方法&quot;&gt;2.3 构造方法&lt;/h3&gt;
&lt;h4 id=&quot;hashset&quot;&gt;2.3.1 HashSet()&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashSet() {
  map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看了这个，相信园友们应该就知道它是怎么实现的了，我们平时构建HashSet的时候，其实它是在里面new了一个HashMap。&lt;/p&gt;

&lt;h4 id=&quot;hashsetcollection-extends-e-c&quot;&gt;2.3.2 HashSet(Collection&amp;lt;? extends E&amp;gt; c)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashSet(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
  map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) (c.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()/.75f) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;));
  &lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(c);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用传集合的构造方法则是使用了HashMap里指定初始化容量的构造方法，然后再调用addAll()。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; modified = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (E e : c)
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e))
      modified = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; modified;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;addAll方法很简单，其实就是遍历集合c，然后调用add方法，实现插入HashMap。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(e, PRESENT)==&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;add方法则是调用了map的put()方法，将对象作为Key，之前域里的PRESENT作为Value，插入到HashMap中。&lt;/p&gt;

&lt;h4 id=&quot;hashsetint-initialcapacity-float-loadfactor-boolean-dummy&quot;&gt;2.3.3 HashSet(int initialCapacity, float loadFactor, boolean dummy)&lt;/h4&gt;
&lt;p&gt;最后值得一提的是这个构造方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;HashSet(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; loadFactor, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; dummy) {
  map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意它是包访问权限的，而不是&lt;strong&gt;public&lt;/strong&gt;，因为这个构造方法是提供给LinkedHashSet使用的，所以里面初始化的也是LinkedHashMap，有兴趣的园友们也可以去LinkedHashSet里看一下它的构造方法。&lt;/p&gt;

&lt;h2 id=&quot;三set的使用注意事项&quot;&gt;三、Set的使用注意事项&lt;/h2&gt;
&lt;p&gt;笔者前端时间恰好碰到了因为HashSet的底层事项导致的一个bug，在此跟大家分享一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;joemsu 2018-02-04 上午10:33&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserInfo {
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Long id;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String name;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Integer age;

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserInfo&lt;/span&gt;(Long id, String name, Integer age) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt; = id;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt; = name;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt; = age;
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(String name) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt; = name;
  }

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;UserInfo{&quot;&lt;/span&gt; +
      &lt;span class=&quot;st&quot;&gt;&quot;id=&quot;&lt;/span&gt; + id +
      &lt;span class=&quot;st&quot;&gt;&quot;, name='&quot;&lt;/span&gt; + name + &lt;span class=&quot;ch&quot;&gt;'\''&lt;/span&gt; +
      &lt;span class=&quot;st&quot;&gt;&quot;, age=&quot;&lt;/span&gt; + age +
      '}';
  }

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object o) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; == o) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;() != o.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;()) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    UserInfo info = (UserInfo) o;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Objects.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(id, info.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;) &amp;amp;&amp;amp;
      Objects.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(name, info.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;) &amp;amp;&amp;amp;
      Objects.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(age, info.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt;);
  }

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Objects.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(id, name, age);
  }
  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UserInfo为当时笔者要处理的一个pojo对象，由第三方提供，重写了equals和hashCode方法（当时没有发现）。而笔者当时要获取所有的UserInfo对象，放入集合当中进行复杂的逻辑处理，出于可能出现重复对象的考虑（使用递归遍历不同部门下的人员信息，可能存在一个人在多个部门），选择使用HashSet。然后在遍历HashSet集合a的时候，会将每个遍历到的对象加入另一个集合b作记录，事后会将a，b做一个差集，取出其中没有访问到的元素。这个过程中可能会涉及到更新某个对象，具体过程简化如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
  &lt;span class=&quot;co&quot;&gt;// 将对象加入set&lt;/span&gt;
  UserInfo info1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserInfo&lt;/span&gt;(1L, &lt;span class=&quot;st&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;);
  UserInfo info2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserInfo&lt;/span&gt;(2L, &lt;span class=&quot;st&quot;&gt;&quot;lisi&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt;);
  UserInfo info3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UserInfo&lt;/span&gt;(3L, &lt;span class=&quot;st&quot;&gt;&quot;wangwu&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;);
  Set&amp;lt;UserInfo&amp;gt; userInfoSet = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
  userInfoSet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info1);
  userInfoSet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info2);
  userInfoSet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info3);
  
  &lt;span class=&quot;co&quot;&gt;// 对访问到的元素加入集合&lt;/span&gt;
  List&amp;lt;UserInfo&amp;gt; visited = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
  visited.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info1);
  visited.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info2);
  visited.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(info3);
  &lt;span class=&quot;co&quot;&gt;// 假设对其中一个对象进行修改&lt;/span&gt;
  info1.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;liliu&quot;&lt;/span&gt;);
  &lt;span class=&quot;co&quot;&gt;// 去掉访问过的元素&lt;/span&gt;
  userInfoSet.&lt;span class=&quot;fu&quot;&gt;removeAll&lt;/span&gt;(visited);
  userInfoSet.&lt;span class=&quot;fu&quot;&gt;stream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;forEach&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;::println);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的输出结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;UserInfo{id=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, name='liliu', age=&lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，所有修改过的元素都无法移除。当笔者通过debug发现这一现象后立刻就意识到，可能就是hashCode导致被修改过的元素无法访问到，为什么呢，我们可以回顾一下HashMap的remove操作：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, Object key, Object value,
                               &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; matchValue, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; movable) {
  Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, index;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
      (p = tab[index = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
    &lt;span class=&quot;co&quot;&gt;// 省略&lt;/span&gt;
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在HashMap中，是通过Key的hash值来定位桶的位置，当笔者修改了对象的name属性之后，由于重写的hashCode方法里包括了name这一字段，所以，hash值也发生了改变，导致在对应的桶里找不到该对象，也就无法实现remove操作（虽然两个是同一个引用）。&lt;/p&gt;

&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;Set的各种底层实现都是对应的Map，熟悉了Map里的各种方法，相信对于Set的了解也会更加深入。最后谢谢各位园友观看，如果有描述不对的地方欢迎指正，与大家共同进步！&lt;/p&gt;

</description>
<pubDate>Sun, 04 Feb 2018 03:19:00 +0000</pubDate>
<dc:creator>joemsu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joemsu/p/8412715.html</dc:identifier>
</item>
<item>
<title>零基础实现node+express个性化聊天室 - _wind</title>
<link>http://www.cnblogs.com/wind-lanyan/p/8412657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-lanyan/p/8412657.html</guid>
<description>&lt;p&gt;本篇文章使用node+express+jquery写一个个性化聊天室，一起来get一下~（源码地址见文章末尾）&lt;/p&gt;
&lt;h2&gt;效果图&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-97762c0c1751cba70b79223771526323_hd.jpg&quot; alt=&quot;&quot; width=&quot;764&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;764&quot; data-rawheight=&quot;596&quot; data-original=&quot;https://pic3.zhimg.com/v2-97762c0c1751cba70b79223771526323_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97762c0c1751cba70b79223771526323_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;项目结构&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-b9d57dfd3c3f17d5c2712791ac7370aa_hd.jpg&quot; alt=&quot;&quot; width=&quot;247&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;247&quot; data-rawheight=&quot;453&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b9d57dfd3c3f17d5c2712791ac7370aa_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现功能&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;登录检测&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;系统自动提示用户状态（进入/离开）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;显示在线用户&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持发送和接收消息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自定义字体颜色&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持发送表情&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持发送图片&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面将一一讲解如何实现&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;前期准备&lt;/h2&gt;
&lt;blockquote readability=&quot;0.78947368421053&quot;&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143450141843488beddae2a1044cab5acb5125baf0882000&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;node及npm环境&lt;/a&gt;、&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//www.expressjs.com.cn/4x/api.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;express&lt;/a&gt;、&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//socket.io/get-started/chat/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;socket.io&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;具体实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、将聊天室部署到服务器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先用node搭建一个服务器，部署在localhost:3000端口，先尝试向浏览器发送一个“hello world”，新建server.js文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; app = require('express')();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;).Server(app);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; app.get('/', &lt;span&gt;function&lt;/span&gt;(req, res){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路由为localhost:3000时向客户端响应“hello world”&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   res.send('&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;');  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送数据&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; http.listen(3000, &lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听3000端口&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   console.log('listening on *:3000'&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }); 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打开浏览器输入网址：localhost:3000是这样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-015ff43ee089c328b6b11a45afd4e6b7_hd.jpg&quot; alt=&quot;&quot; width=&quot;340&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;340&quot; data-rawheight=&quot;132&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-015ff43ee089c328b6b11a45afd4e6b7_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个node服务器搭建成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来用express向浏览器返回一个html页面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#安装express模块
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; npm install --save express
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将server.js的代码改一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;).Server(app); 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 路由为/默认www静态文件夹&lt;/span&gt;
app.use('/', express.static(__dirname + '/www'));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;express.static(__dirname + '/www');是将www文件夹托管为静态资源，意味着这个文件夹里的文件（html、css、js）彼此可以用相对路径。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在www文件夹中添加index.html文件以及相应的css（相应css代码就不贴了，详情见源码），如下，该页面用了font-awesome小图标&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;chat&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;style/index.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;style/font-awesome-4.7.0/css/font-awesome.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;all&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;h2&amp;gt;请输入你的昵称&amp;lt;/h2&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入昵称...&quot;&lt;/span&gt;&lt;span&gt; autocomplete&lt;/span&gt;&lt;span&gt;=&quot;off&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;nameBtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;确  定&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;image/logo.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          happy聊天室
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;conversation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;messages&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;edit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;color&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;#000000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;双击取消选择&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-smile-o&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;smile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;双击取消选择&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-picture-o&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;img&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;selectBox&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
                      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;smile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
                      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
                      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; autocomplete禁用自动完成功能 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;m&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn rBtn&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;sub&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;发送&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;clear&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;关闭&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;contacts&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;在线人员(&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;num&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;users&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;当前无人在线哟~&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;打开localhost:3000，会看到如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-f3b1006662944ddaf6c48b844836e3be_hd.jpg&quot; alt=&quot;&quot; width=&quot;797&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;797&quot; data-rawheight=&quot;594&quot; data-original=&quot;https://pic4.zhimg.com/v2-f3b1006662944ddaf6c48b844836e3be_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f3b1006662944ddaf6c48b844836e3be_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聊天室成功部署到服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、检测登录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在客户端和服务器之间传送消息需要用到&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//socket.io/get-started/chat/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;socket.io&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#安装socket.io模块
npm install &lt;/span&gt;--save socket.io
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将server.js改动如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = require('express'&lt;span&gt;)();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;).Server(app);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; io = require('socket.io'&lt;span&gt;)(http);

app.use(&lt;/span&gt;'/', express.static(__dirname + '/www'&lt;span&gt;));

io.on(&lt;/span&gt;'connection', &lt;span&gt;function&lt;/span&gt;(socket){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户连接时触发&lt;/span&gt;
  console.log('a user connected'&lt;span&gt;);
});

http.listen(&lt;/span&gt;3000, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  console.log(&lt;/span&gt;'listening on *:3000'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当打开localhost:3000的时候会触发服务器端io的connection事件，会在服务器打印“a user connected”，但是我们想统计一下连接该服务器的用户人数，如果有用户连接就打印“n users connected”，n为用户人数，怎么办呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在server.js设置一个全局数组为user，每当一个用户连接成功就在连接事件中将用户的昵称push进user，打印user.length即可知道已成功连接用户的人数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等一等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在用户连接的时输入昵称登录，我们应该检测一下用户的昵称是否已存在，避免昵称相同的情况发生，在服务器监听一个登录事件来判断该情况，由于一切都发生在用户连接之后，所以触发事件应该写在connection事件的回调函数中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
io.on('connection', (socket)=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 渲染在线人员&lt;/span&gt;
    io.emit('disUser'&lt;span&gt;, usersInfo);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 登录，检测用户名&lt;/span&gt;
    socket.on('login', (user)=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(users.indexOf(user.name) &amp;gt; -1) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 昵称是否存在&lt;/span&gt;
            socket.emit('loginError'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发客户端的登录失败事件&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            users.push(user.name); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;储存用户的昵称&lt;/span&gt;
            usersInfo.push(user); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 储存用户的昵称和头像&lt;/span&gt;
            socket.emit('loginSuc'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发客户端的登录成功事件&lt;/span&gt;
            socket.nickname =&lt;span&gt; user.name;
            io.emit(&lt;/span&gt;'system', {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向所有用户广播该用户进入房间&lt;/span&gt;
&lt;span&gt;                name: user.name,
                status: &lt;/span&gt;'进入'&lt;span&gt;
            });
            io.emit(&lt;/span&gt;'disUser', usersInfo);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 渲染右侧在线人员信息&lt;/span&gt;
            console.log(users.length + ' user connect.'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印连接人数&lt;/span&gt;
&lt;span&gt;        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;system和disUser事件先不管，之后再说&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;区分io.emit(foo)、socket.emit(foo)、socket.broadcast.emit(foo)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
   io.emit(foo); //会触发所有客户端用户的foo事件
   socket.emit(foo); //只触发当前客户端用户的foo事件
   socket.broadcast.emit(foo); //触发除了当前客户端用户的其他用户的foo事件
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来是客户端代码chat-client.js&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; io-client&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接成功会触发服务器端的connection事件&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; socket =&lt;span&gt; io(); 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击输入昵称&lt;/span&gt;
    $('#nameBtn').click(()=&amp;gt;&lt;span&gt; {  
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imgN = Math.floor(Math.random()*4)+1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机分配头像&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;($('#name').val().trim()!==''&lt;span&gt;)
          socket.emit(&lt;/span&gt;'login', {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发服务器端登录事件&lt;/span&gt;
            name: $('#name'&lt;span&gt;).val(),
            img: &lt;/span&gt;'image/user' + imgN + '.jpg'&lt;span&gt;
          }); 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 登录成功，隐藏登录层&lt;/span&gt;
    socket.on('loginSuc', ()=&amp;gt;&lt;span&gt; { 
      $(&lt;/span&gt;'.name'&lt;span&gt;).hide(); 
    })
    socket.on(&lt;/span&gt;'loginError', ()=&amp;gt;&lt;span&gt; {
      alert(&lt;/span&gt;'用户名已存在，请重新输入！'&lt;span&gt;);
      $(&lt;/span&gt;'#name').val(''&lt;span&gt;);
    }); 
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;倘若登录成功，会看到如下页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-c4d26ed2a93142500f3a2a589ac04225_hd.jpg&quot; alt=&quot;&quot; width=&quot;746&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;746&quot; data-rawheight=&quot;590&quot; data-original=&quot;https://pic2.zhimg.com/v2-c4d26ed2a93142500f3a2a589ac04225_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c4d26ed2a93142500f3a2a589ac04225_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录检测完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、系统自动提示用户状态（进入/离开）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该功能是为了实现上图所示的系统提示“XXX进入聊天室”，在登录成功时触发system事件，向所有用户广播信息，注意此时用的是io.emit而不是socket.emit，客户端代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统提示消息&lt;/span&gt;
socket.on('system', (user)=&amp;gt;&lt;span&gt; { 
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;new&lt;/span&gt; Date().toTimeString().substr(0, 8&lt;span&gt;);
  $(&lt;/span&gt;'#messages').append(`&amp;lt;p class='system'&amp;gt;&amp;lt;span&amp;gt;${data}&amp;lt;/span&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;span&amp;gt;${user.name}  ${user.status}了聊天室&amp;lt;span&amp;gt;&amp;lt;/p&amp;gt;`);
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动条总是在最底部&lt;/span&gt;
  $('#messages').scrollTop($('#messages')[0&lt;span&gt;].scrollHeight);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、显示在线用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端监听一个显示在线用户的事件disUser，在以下三个时间段服务器端就触发一次该事件重新渲染一次&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;程序开始启动时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每当用户进入房间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每当用户离开房间&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chat-client.js&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 显示在线人员&lt;/span&gt;
socket.on('disUser', (usersInfo)=&amp;gt;&lt;span&gt; {
  displayUser(usersInfo);
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示在线人员&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayUser(users) {
  $(&lt;/span&gt;'#users').text(''); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次都要重新渲染&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;users.length) {
    $(&lt;/span&gt;'.contacts p'&lt;span&gt;).show();
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    $(&lt;/span&gt;'.contacts p'&lt;span&gt;).hide();
  }
  $(&lt;/span&gt;'#num'&lt;span&gt;).text(users.length);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; users.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $html = `&amp;lt;li&amp;gt;
      &amp;lt;img src=&quot;${users[i].img}&quot;&amp;gt;
      &amp;lt;span&amp;gt;${users[i].name}&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;`;
    $('#users'&lt;span&gt;).append($html);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、支持发送和接收消息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户发送消息时触发服务器端的sendMsg事件，并将消息内容作为参数，服务器端监听到sendMsg事件之后向其他所有用户广播该消息，用的socket.broadcast.emit(foo)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.js&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息事件&lt;/span&gt;
    socket.on('sendMsg', (data)=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img = ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; usersInfo.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(usersInfo[i].name ==&lt;span&gt; socket.nickname) {
                img &lt;/span&gt;=&lt;span&gt; usersInfo[i].img;
            }
        }
        socket.broadcast.emit(&lt;/span&gt;'receiveMsg', {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向除了发送者之外的其他用户广播&lt;/span&gt;
&lt;span&gt;            name: socket.nickname,
            img: img,
            msg: data.msg,
            color: data.color,
            side: &lt;/span&gt;'left'&lt;span&gt;
        });
        socket.emit(&lt;/span&gt;'receiveMsg', {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向发送者发送消息，为什么分开发送？因为css样式不同&lt;/span&gt;
&lt;span&gt;            name: socket.nickname,
            img: img,
            msg: data.msg,
            color: data.color,
            side: &lt;/span&gt;'right'&lt;span&gt;
        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;服务器端接受到来自用户的消息后会触发客户端的receiveMsg事件，并将用户发送的消息作为参数传递，该事件会向聊天面板添加聊天内容，以下为chat-client.js代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击按钮或回车键发送消息&lt;/span&gt;
    $('#sub'&lt;span&gt;).click(sendMsg);
    $(&lt;/span&gt;'#m').keyup((ev)=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ev.which == 13&lt;span&gt;) {
        sendMsg();
      }
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收消息&lt;/span&gt;
    socket.on('receiveMsg', (obj)=&amp;gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将接收到的消息渲染到面板上&lt;/span&gt;
      $('#messages'&lt;span&gt;).append(` 
         &lt;/span&gt;&amp;lt;li class='${obj.side}'&amp;gt;
          &amp;lt;img src=&quot;${obj.img}&quot;&amp;gt;
          &amp;lt;div&amp;gt;
            &amp;lt;span&amp;gt;${obj.name}&amp;lt;/span&amp;gt;
            &amp;lt;p&amp;gt;${obj.msg}&amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/li&amp;gt;
&lt;span&gt;      `);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动条总是在最底部&lt;/span&gt;
      $('#messages').scrollTop($('#messages')[0&lt;span&gt;].scrollHeight);
    }); 


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendMsg() { 
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($('#m').val() == '') {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入消息为空&lt;/span&gt;
        alert('请输入内容！'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }
      socket.emit(&lt;/span&gt;'sendMsg'&lt;span&gt;, {
        msg: $(&lt;/span&gt;'#m'&lt;span&gt;).val()
      });
      $(&lt;/span&gt;'#m').val(''&lt;span&gt;); 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、自定义字体颜色&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得益于html5的input新特性，可以通过type为color的input调用系统调色板&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; $('#color').val();为选中颜色，格式为#FFCCBB &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='color' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='color'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端根据用户选择的颜色渲染内容样式，代码很容易看懂，这里就不赘述了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、支持发送表情&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发送表情其实很简单，将表情图片放在li中，当用户点击li时就将表情的src中的序号解析出来，用[emoji+表情序号]的格式存放在聊天框里，点击发送后再解析为src。就是一个解析加还原的过程，这一过程中我们的服务器代码不变，需要改变的是客户端监听的receiveMsg事件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chat-client.js&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示表情选择面板&lt;/span&gt;
    $('#smile').click(()=&amp;gt;&lt;span&gt; {
      $(&lt;/span&gt;'.selectBox').css('display', &quot;block&quot;&lt;span&gt;);
    });
    $(&lt;/span&gt;'#smile').dblclick((ev)=&amp;gt;&lt;span&gt; { 
      $(&lt;/span&gt;'.selectBox').css('display', &quot;none&quot;&lt;span&gt;);
    });  
    $(&lt;/span&gt;'#m').click(()=&amp;gt;&lt;span&gt; {
      $(&lt;/span&gt;'.selectBox').css('display', &quot;none&quot;&lt;span&gt;);
    }); 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户点击发送表情&lt;/span&gt;
    $('.emoji li img').click((ev)=&amp;gt;&lt;span&gt; {
        ev &lt;/span&gt;= ev ||&lt;span&gt; window.event;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; src =&lt;span&gt; ev.target.src;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; emoji = src.replace(/\D*/g, '').substr(6, 8); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取序号&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; old = $('#m').val(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户输入的其他内容&lt;/span&gt;
        $('#m').val(old+'[emoji'+emoji+']'&lt;span&gt;);
        $(&lt;/span&gt;'.selectBox').css('display', &quot;none&quot;&lt;span&gt;);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端收到之后将表情序号还原为src，更改如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chat-client.js&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收消息&lt;/span&gt;
    socket.on('receiveMsg', (obj)=&amp;gt;&lt;span&gt; {  
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取文字中的表情加以渲染&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; msg =&lt;span&gt; obj.msg;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = ''&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(msg.indexOf('[') &amp;gt; -1) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实更建议用正则将[]中的内容提取出来&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; start = msg.indexOf('['&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; end = msg.indexOf(']'&lt;span&gt;);

        content &lt;/span&gt;+= '&amp;lt;span&amp;gt;'+msg.substr(0, start)+'&amp;lt;/span&amp;gt;'&lt;span&gt;;
        content &lt;/span&gt;+= '&amp;lt;img src=&quot;image/emoji/emoji%20('+msg.substr(start+6, end-start-6)+').png&quot;&amp;gt;'&lt;span&gt;;
        msg &lt;/span&gt;= msg.substr(end+1&lt;span&gt;, msg.length);
      }
      content &lt;/span&gt;+= '&amp;lt;span&amp;gt;'+msg+'&amp;lt;/span&amp;gt;'&lt;span&gt;;
      
      $(&lt;/span&gt;'#messages'&lt;span&gt;).append(`
        &lt;/span&gt;&amp;lt;li class='${obj.side}'&amp;gt;
          &amp;lt;img src=&quot;${obj.img}&quot;&amp;gt;
          &amp;lt;div&amp;gt;
            &amp;lt;span&amp;gt;${obj.name}&amp;lt;/span&amp;gt;
            &amp;lt;p style=&quot;color: ${obj.color};&quot;&amp;gt;${content}&amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/li&amp;gt;
&lt;span&gt;      `);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滚动条总是在最底部&lt;/span&gt;
      $('#messages').scrollTop($('#messages')[0&lt;span&gt;].scrollHeight);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以成功发送表情了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-76ce90e207c142709cb48356701b8fc6_hd.jpg&quot; alt=&quot;&quot; width=&quot;796&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;796&quot; data-rawheight=&quot;601&quot; data-original=&quot;https://pic3.zhimg.com/v2-76ce90e207c142709cb48356701b8fc6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-76ce90e207c142709cb48356701b8fc6_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8、支持发送图片&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是图片按钮样式，发送图片的按钮是type为file的input。这里有一个改变样式的小技巧，那就是将input的透明度设为0，z-index为5，将你想要得样式放在div中，z-index设为1覆盖在input上。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-picture-o&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;img&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;css：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.edit #file &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 32.36px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 29px&lt;/span&gt;;&lt;span&gt;
    opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    z-index&lt;/span&gt;:&lt;span&gt; 5&lt;/span&gt;;
}&lt;span&gt;
.edit #img &lt;/span&gt;{&lt;span&gt;
    z-index&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; -43px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完美&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-567a6eda5dab3a2e5803dd834efb3b5e_hd.jpg&quot; alt=&quot;&quot; width=&quot;134&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;134&quot; data-rawheight=&quot;44&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-567a6eda5dab3a2e5803dd834efb3b5e_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来是点击按钮发送图片，我们用了fileReader对象，这里有一篇&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//blog.csdn.net/qingyjl/article/details/52003567&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;不错的文章&lt;/a&gt;讲解了fileReader，fileReader是一个对象，可以将我们选中的文件已64位输出然后将结果存放在reader.result中，我们选中图片之后，reader.result就存放的是图片的src&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chat-client.js&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户发送图片&lt;/span&gt;
    $('#file').change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = &lt;span&gt;this&lt;/span&gt;.files[0];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上传单张图片&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件读取出错的时候触发&lt;/span&gt;
      reader.onerror = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          console.log(&lt;/span&gt;'读取文件失败，请重试！'&lt;span&gt;); 
      };
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取成功后&lt;/span&gt;
      reader.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; src = reader.result;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取结果&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; img = '&amp;lt;img class=&quot;sendImg&quot; src=&quot;'+src+'&quot;&amp;gt;'&lt;span&gt;;
        socket.emit(&lt;/span&gt;'sendMsg', {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送&lt;/span&gt;
&lt;span&gt;          msg: img,
          color: color,
          type: &lt;/span&gt;'img'  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送类型为img&lt;/span&gt;
&lt;span&gt;        }); 
      };
      reader.readAsDataURL(file); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取为64位&lt;/span&gt;
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于发送的是图片，所以对页面布局难免有影响，为了页面美观客户端在接收其他用户发送的消息的时候会先判断发送的是文本还是图片，根据不同的结果展示不同布局。判断的方法是在客户发送消息的时候传入一个type，根据type的值来确实发送内容的类型。所以上面发送图片代码中触发了sendMsg事件，传入参数多了一个type属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相应的，我们应该在chat-client.js中修改receiveMsg事件监听函数，改为根据传入type做不同操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
chat-&lt;span&gt;client.js
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收消息&lt;/span&gt;
    socket.on('receiveMsg', (obj)=&amp;gt;&lt;span&gt; { 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送为图片&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(obj.type == 'img'&lt;span&gt;) {
        $(&lt;/span&gt;'#messages'&lt;span&gt;).append(`
          &lt;/span&gt;&amp;lt;li class='${obj.side}'&amp;gt;
            &amp;lt;img src=&quot;${obj.img}&quot;&amp;gt;
            &amp;lt;div&amp;gt;
              &amp;lt;span&amp;gt;${obj.name}&amp;lt;/span&amp;gt;
              &amp;lt;p style=&quot;padding: 0;&quot;&amp;gt;${obj.msg}&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/li&amp;gt;
&lt;span&gt;        `); 
        $(&lt;/span&gt;'#messages').scrollTop($('#messages')[0&lt;span&gt;].scrollHeight);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取文字中的表情加以渲染&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面不变&lt;/span&gt;
    }); 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在我们可以发送图片了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-97762c0c1751cba70b79223771526323_hd.jpg&quot; alt=&quot;&quot; width=&quot;764&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;764&quot; data-rawheight=&quot;596&quot; data-original=&quot;https://pic3.zhimg.com/v2-97762c0c1751cba70b79223771526323_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97762c0c1751cba70b79223771526323_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;圆满完成一个功能齐全的聊天室！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源码地址：&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.com/windlany/happy-chat&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;windlany/happy-chat&lt;/a&gt;，本文断断续续写了两天，真是写文章比敲代码还累...其实写一个聊天室并不难，这算是node起步作品吧。有兴趣的可以fork下来根据自己需求改改，觉得不错请给我一个star。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 04 Feb 2018 02:49:00 +0000</pubDate>
<dc:creator>_wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-lanyan/p/8412657.html</dc:identifier>
</item>
</channel>
</rss>