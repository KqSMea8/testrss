<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core阿里大于短信发送SDK修改以及使用 - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8490983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8490983.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　继上次七牛云SDK的问题之后（参考：&lt;a href=&quot;http://www.cnblogs.com/OMango/p/8447480.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/p/8447480.html&lt;/a&gt;），在发送短信的功能上又出现了问题，我们短信服务使用的是阿里大于的服务，之前的平台是.NET Framework的平台，使用阿里官方的SDK并没有出现什么幺蛾子，但是转到.NET Core下后，找遍了阿里官方也并没有找到.NET Core的SDK，不得不说，在这方面.NET Core还有很长的路要走啊，虽然没有SDK，但是功能还是要完成啊，那怎么办呢？只能自己从.NetFrameWork的SDK里进行提取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、修改说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;emmmm，好好看了一遍SDK以及官方文档后，发现topsdk里面还包含了其他的一些功能，但是我只需要短信服务啊，SO，既然准备改造那就把其他的相关功能都去掉了，只留下了短信相关功能，废话不多说先上链接&lt;a href=&quot;https://github.com/Hello-Mango/MTopSdkSMS.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/Hello-Mango/MTopSdkSMS.Core&lt;/a&gt;，这是我已经修改后的代码，也经过测试可以发送短信到手机，dll也已经上传到NUGET(搜索MTopSdkSMS)&lt;/p&gt;
&lt;p&gt;　　修改方案主要是.NET FrmeWork下的HttpRequest类在.NetCore中不是默认带的，所以需要安装Microsoft.AspNetCore.Http，该SDK里还使用了反射的方法，所以还需要安装System.Reflection.Emit.Lightweight，最后一点就是将&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wReq.ServicePoint.Expect100Continue = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ServicePointManager.Expect100Continue = &lt;span&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不修改的话，会报平台不支持的错误,如果大家想自己尝试的话，可以下载官方的SDK源码进行.NET Core的改造，或者可以直接Nuget搜索MTopSdkSMS&lt;a href=&quot;https://github.com/Hello-Mango/MTopSdkSMS.Core&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、具体使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　具体的代码使用方法完全可以参照官方的文档使用，我这边就给出一个简单的封装代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; SMS(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; phoneNo, String template, String _AppKey, String _AppSecret, String _Extend, String _SmsFreeSignName, String _SmsTemplateCode)
        {
            _phoneNo &lt;/span&gt;=&lt;span&gt; phoneNo;
            _template &lt;/span&gt;=&lt;span&gt; template;
            Appsecret &lt;/span&gt;=&lt;span&gt; _AppSecret;
            Appkey &lt;/span&gt;=&lt;span&gt; _AppKey;
            Extend &lt;/span&gt;=&lt;span&gt; _Extend;
            SmsFreeSignName &lt;/span&gt;=&lt;span&gt; _SmsFreeSignName;
            SmsTemplateCode &lt;/span&gt;=&lt;span&gt; _SmsTemplateCode;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;短信身份验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;phoneNo&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;手机号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dicParam&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;短信模板变量，对应模板中自定义字段&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String Send()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;短息通知API请求参数&lt;/span&gt;
            ITopClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultTopClient(url, Appkey, Appsecret);
            AlibabaAliqinFcSmsNumSendRequest req &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlibabaAliqinFcSmsNumSendRequest();
            req.Extend &lt;/span&gt;= Extend;                                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;公共回传参数，在“消息返回”中会透传回该参数；&lt;/span&gt;
            req.SmsType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;短信类型，传入值请填写normal&lt;/span&gt;
            req.SmsFreeSignName = SmsFreeSignName;                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;短信签名&lt;/span&gt;
            req.SmsParam = _template;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;短信模板变量&lt;/span&gt;
            req.RecNum = _phoneNo;                                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;短信接收号码&lt;/span&gt;
            req.SmsTemplateCode = SmsTemplateCode;                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;短信模板ID&lt;/span&gt;
            AlibabaAliqinFcSmsNumSendResponse response = client.Execute&amp;lt;AlibabaAliqinFcSmsNumSendResponse&amp;gt;&lt;span&gt;(req);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.Result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetErrorMsg(response.SubErrCode);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.Result.Success.ToString();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　.NET Core目前来说第三方库上支持相对于其他来说还是比较少，例如oracle目前还都没有关于.NET Core的驱动库，一些简单的碰到只能自己想办法去转换或者其他途径实现，但是后续相信.NET Core会越来越好&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;PS:由于这个只是我个人的修改作品，未经过大量的验证，如果大家发现有什么问题的话，也请联系我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，如有问题， 可邮件（hongjb@yizit.com）咨询.&lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 15:27:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8490983.html</dc:identifier>
</item>
<item>
<title>iOS微信内存监控 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8490905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8490905.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目前iOS主流的内存监控工具是Instruments的Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于App上线后发现内存问题。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;FOOM（Foreground Out Of Memory），是指App在前台因消耗内存过多引起系统强杀。对用户而言，表现跟crash一样。Facebook早在2015年8月提出FOOM检测办法，大致原理是排除各种情况后，剩余的情况是FOOM，具体链接：https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/。&lt;/p&gt;

&lt;p&gt;微信自15年年底上线FOOM上报，从最初数据来看，每天FOOM次数与登录用户数比例接近3%，同期crash率1%不到。而16年年初某东老大反馈微信频繁闪退，在艰难拉取2G多日志后，才发现kv上报频繁打log引起FOOM。接着16年8月不少外部用户反馈微信启动不久后闪退，分析大量日志还是不能找到FOOM原因。微信急需一个有效的内存监控工具来发现问题。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;微信内存监控最初版本是使用Facebook的FBAllocationTracker工具监控OC对象分配，用fishhook工具hook malloc/free等接口监控堆内存分配，每隔1秒，把当前所有OC对象个数、TOP 200最大堆内存及其分配堆栈，用文本log输出到本地。该方案实现简单，一天内完成，通过给用户下发TestFlight，最终发现联系人模块因迁移DB加载大量联系人导致FOOM。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不过这方案有不少缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外fishhook只能hook自身app的C接口调用，对系统库不起作用；&lt;/p&gt;
&lt;p&gt;2、打log间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io频繁等性能问题；&lt;/p&gt;
&lt;p&gt;3、上报的原始log靠人工分析，缺少好的页面工具展现和归类问题。&lt;/p&gt;

&lt;p&gt;所以二期版本以Instruments的Allocations为参考，着重四个方面优化，分别是数据收集、存储、上报及展现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.数据收集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;16年9月底为了解决ios10 nano crash，研究了libmalloc源码，无意中发现这几个接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222241839-939355075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当malloc_logger和__syscall_logger函数指针不为空时，malloc/free、vm_allocate/vm_deallocate等内存分配/释放通过这两个指针通知上层，这也是内存调试工具malloc stack的实现原理。有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用backtrace函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表dsym解析符号。所以还要记录每个image加载时的偏移slide，这样符号表地址=堆栈地址-slide。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222307321-488548272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另外为了更好的归类数据，每个内存对象应该有它所属的分类Category，如上图所示。对于堆内存对象，它的Category名是“Malloc ”+分配大小，如“Malloc 48.00KiB”；对于虚拟内存对象，调用vm_allocate创建时，最后的参数flags代表它是哪类虚拟内存，而这个flags正对应于上述函数指针__syscall_logger的第一个参数type，每个flag具体含义可以在头文件&amp;lt;mach/vm_statistics.h&amp;gt;找到；对于OC对象，它的Category名是OC类名，我们可以通过hook OC方法+[NSObject alloc]来获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222331644-477768206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但后来发现，NSData创建对象的类静态方法没有调用+[NSObject alloc]，里面实现是调用C方法NSAllocateObject来创建对象，也就是说这类方式创建的OC对象无法通过hook来获取OC类名。最后在苹果开源代码CF-1153.18找到了答案，当__CFOASafe=true并且__CFObjectAllocSetLastAllocEventNameFunction!=NULL时，CoreFoundation创建对象后通过这个函数指针告诉上层当前对象是什么类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222448151-1293977479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过上面方式，我们的监控数据来源基本跟Allocations一样了，当然是借助了私有API。如果没有足够的“技巧”，私有API带不上Appstore，我们只能退而求其次。修改malloc_default_zone函数返回的malloc_zone_t结构体里的malloc、free等函数指针，也是可以监控堆内存分配，效果等同于malloc_logger；而虚拟内存分配只能通过fishhook方式。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.数据存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存活对象管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;APP在运行期间会大量申请/释放内存。以上图为例，微信启动10秒内，已经创建了80万对象，释放了50万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了sqlite，改用了更轻量级的平衡二叉树来存储。&lt;/p&gt;

&lt;p&gt;伸展树（Splay Tree），也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过“伸展”操作搬移到离树根更近的地方。大部分情况下，内存申请很快又被释放，如autoreleased对象、临时变量等；而OC对象申请内存后紧接着会更新它所属Category。所以用伸展树管理最适合不过了。&lt;/p&gt;

&lt;p&gt;传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222523967-588348549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆栈存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;据统计，微信运行期间，backtrace的堆栈有成百万上千万种，在捕获最大栈长64情况下，平均栈长35。如果36bits存储一个地址（armv8最大虚拟内存地址48bits，实际上36bits够用了），一个堆栈平均存储长度157.5bytes，1M个堆栈需要157.5M存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后7个地址是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222546422-1882184809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为此，可以用Hash Table来存储这些堆栈。思路是整个堆栈以链表的方式插入到table里，链表结点存放当前地址和上一个地址所在table的索引。每插入一个地址，先计算它的hash值，作为在table的索引，如果索引对应的slot没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash命中，继续处理下一个地址；数据不一致，意味着hash冲突，需要重新计算hash值，直到满足存储条件。举个例子（简化了hash计算）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222604931-712398093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
1）Stack1的G、F、E、D、C、A、依次插入到Hash Table，索引1～6结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1索引入口是6&lt;/p&gt;

&lt;p&gt;2）轮到插入Stack2，由于G、F、E、D、C结点数据跟Stack1前5结点一致，hash命中；B插入新的7号位置，(B, 5)。Stack2索引入口是7&lt;/p&gt;

&lt;p&gt;3）最后插入Stack3，G、F、E、D结点hash命中；但由于Stack3的A的上一个地址D索引是4，而不是已有的(A, 5)，hash不命中，查找下一个空白位置8，插入结点(A, 4)；B上一个地址A索引是8，而不是已有的(B, 5)，hash不命中，查找下一个空白位置9，插入结点(B, 9)。Stack3索引入口是9&lt;/p&gt;

&lt;p&gt;经过这样的后缀压缩存储，平均栈长由原来的35缩短到5不到。而每个结点存储长度为64bits（36bits存储地址，28bits储存parent索引），hashTable空间利用率60%+，一个堆栈平均存储长度只需要66.7bytes，压缩率高达42%。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;性能数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过上述优化，内存监控工具在iPhone6Plus运行占用CPU占用率13%不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量20M左右，都用mmap方式把文件映射到内存。有关mmap好处可自行google之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222645322-45401917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3.数据上报&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现FOOM时，不可能全量上报，而是按某些规则有选择性的上报。&lt;/p&gt;

&lt;p&gt;首先把所有对象按Category进行归类，统计每个Category的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对Category下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些Category，如分配大小TOP N，或者UI相关的（如UIViewController、UIView之类的），它里面分配大小TOP M的堆栈才做上报。上报格式类似这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222707403-1259371939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;4.页面展现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页面展现参考了Allocations，可看出有哪些Category，每个Category分配大小和对象数，某些Category还能看分配堆栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222809441-86879587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了突出问题，提高解决问题效率，后台先根据规则找出可能引起FOOM的Category（如上面的Suspect Categories），规则有：&lt;/p&gt;
&lt;p&gt;● UIViewController数量是否异常&lt;/p&gt;
&lt;p&gt;● UIView数量是否异常&lt;/p&gt;
&lt;p&gt;● UIImage数量是否异常&lt;/p&gt;
&lt;p&gt;● 其它Category分配大小是否异常，对象个数是否异常&lt;/p&gt;

&lt;p&gt;接着对可疑的Category计算特征值，也就是OOM原因。特征值是由“Caller1”、“Caller2”和“Category, Reason”组成。Caller1是指申请内存点，Caller2是指具体场景或业务，它们都是从Category下分配大小第一的堆栈提取。Caller1提取尽量是有意义的，并不是分配函数的上一地址。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222833513-1405286791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所有report计算出特征值后，可以对它们进行归类了。一级分类可以是Caller1，也可以是Category，二级分类是与Caller1/Category有关的特征聚合。效果如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一级分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222900230-1440128394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二级分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301222955553-1164791953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;5.运营策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概300K左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做100%开启。本地最多只保留最近三次数据。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、降低误判&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先回顾Facebook如何判定上一次启动是否出现FOOM：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301223027067-296813508.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.App没有升级&lt;/p&gt;
&lt;p&gt;2.App没有调用exit()或abort()退出&lt;/p&gt;
&lt;p&gt;3.App没有出现crash&lt;/p&gt;
&lt;p&gt;4.用户没有强退App&lt;/p&gt;
&lt;p&gt;5.系统没有升级/重启&lt;/p&gt;
&lt;p&gt;6.App当时没有后台运行&lt;/p&gt;
&lt;p&gt;7.App出现FOOM&lt;/p&gt;

&lt;p&gt;1、2、4、5比较容易判断，3依赖于自身CrashReport组件的crash回调，6、7依赖于ApplicationState和前后台切换通知。&lt;strong&gt;微信自上线FOOM数据上报以来，出现不少误判，主要情况有：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ApplicationState不准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部分系统会在后台短暂唤起app，ApplicationState是Active，但又不是BackgroundFetch；执行完didFinishLaunchingWithOptions就退出了，也有收到BecomeActive通知，但很快也退出；整个启动过程持续5～8秒不等。解决方法是收到BecomeActive通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;群控类外挂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这类外挂是可以远程控制iPhone的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CrashReport组件出现crash没有回调上层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信曾经在17年5月底爆发大量GIF crash，该crash由内存越界引起，但收到crash信号写crashlog时，由于内存池损坏，组件无法正常写crashlog，甚至引起二次crash；上层也无法收到crash通知，因此误判为FOOM。目前改成不依赖crash回调，只要本地存在上一次crashlog（不管是否完整），就认为是crash引起的APP重启。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前台卡死引起系统watchdog强杀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是常见的0x8badf00d，通常原因是前台线程过多，死锁，或CPU使用率持续过高等，这类强杀无法被App捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被watchdog强杀。同时我们从FOOM划分出新的重启原因叫“APP前台卡死导致重启”，列入重点关注。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、成果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;微信自2017年三月上线内存监控以来，解决了30多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM率由17年年初3%，降到目前0.67%，而前台卡死率由0.6%下降到0.3%，效果特别明显。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301223124530-1798119749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301223134216-1777413940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UIGraphicsEndImageContext&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏。另外XCode的Analyze也能扫出这类问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIWebView&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是打开网页，还是执行一段简单的js代码，UIWebView都会占用APP大量内存。而WKWebView不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替UIWebView。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autoreleasepool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常autoreleased对象是在runloop结束时才释放。如果在循环里产生大量autoreleased对象，内存峰值会猛涨，甚至出现OOM。适当的添加autoreleasepool能及时释放内存，降低峰值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;互相引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较容易出现互相引用的地方是block里使用了self，而self又持有这个block，只能通过代码规范来避免。另外NSTimer的target、CAAnimation的delegate，是对Obj强引用。目前微信通过自己实现的MMNoRetainTimer和MMDelegateCenter来规避这类问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大图片处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，以往图片缩放接口是这样写的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301223204478-592158994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但处理大分辨率图片时，往往容易出现OOM，原因是-[UIImage drawInRect:]在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的。解决方法是使用更低层的ImageIO接口，避免中间bitmap产生：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180301223231449-1974339041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;大视图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大视图是指View的size过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个View里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个View绘制，利用TableView的复用机制，减少不必要的渲染和内存占用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐文章&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后推荐几个iOS内存相关的链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;● Memory Usage Performance Guidelines&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;● No pressure, Mon!&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://www.newosxbook.com/articles/MemoryPressure.html&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;腾讯WeTest iOS预审工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了提高IEG苹果审核通过率，腾讯专门成立了苹果审核测试团队，打造出iOS预审工具这款产品。经过1年半的内部运营，腾讯内部应用的iOS审核通过率从平均35%提升到90%+。&lt;/p&gt;

&lt;p&gt;现将腾讯内部产品的过审经验，以线上工具的形式共享给各位。在WeTest腾讯质量开放平台上可以在线使用。&lt;strong&gt;&lt;span&gt;点击&lt;/span&gt; &lt;a href=&quot;http://wetest.qq.com/product/ios?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://wetest.qq.com/product/ios&lt;/span&gt;&lt;/a&gt; &lt;span&gt;即可立即体验！&lt;/span&gt;&lt;/strong&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS预审服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【扫描工具】&lt;/strong&gt;上传IPA包、图片、视频、应用描述即可进行测试； 多维度自动扫描提审材料的被拒风险；1小时内反馈全面的扫描报告。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【专家预审】&lt;/strong&gt;腾讯专家为您遍历App所有功能模块；全面暴露App内容被拒风险；跟进问题直至上线（需提供官方拒绝邮件）。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;【专家咨询】&lt;/strong&gt;资深预审专家一对一服务； 咨询时间灵活可选，按需购买；有的放矢解 决审核问题。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;【ASO优化】&lt;/strong&gt;专业团队多维度深度剖析App的ASO现状；围绕App目标用户群筛选高 度关联的关键词；帮助提升App在苹果应用商店中的曝光率。&lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 14:36:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8490905.html</dc:identifier>
</item>
<item>
<title>记一次内存溢出的分析经历——thrift带给我的痛orz - Janti</title>
<link>http://www.cnblogs.com/superfj/p/8474288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superfj/p/8474288.html</guid>
<description>&lt;h2&gt;说在前面的话&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;朋友，你经历过部署好的服务突然内存溢出吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你经历过没有看过Java虚拟机，来解决内存溢出的痛苦吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你经历过一个BUG，百思不得其解，头发一根一根脱落的烦恼吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我知道，你有过！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我还是要来说说我的故事..................&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;背景：&lt;/h2&gt;
&lt;p&gt;有一个项目做一个系统，分客户端和服务端，客户端用c++写的，用来收集信息然后传给服务端（客户端的数量还是比较多的，正常的有几千个），&lt;/p&gt;
&lt;p&gt;服务端用Java写的（带管理页面），属于RPC模式，中间的通信框架使用的是thrift。&lt;/p&gt;
&lt;p&gt;thrift很多优点就不多说了，它是facebook的开源的rpc框架，主要是它能够跨语言，序列化速度快，但是他有个不讨喜的地方就是它必须用自己IDL来定义接口&lt;/p&gt;
&lt;p&gt;thrift版本：0.9.2.&lt;/p&gt;
&lt;h2&gt;问题定位与分析&lt;/h2&gt;
&lt;h3&gt;步骤一.初步分析&lt;/h3&gt;
&lt;p&gt;客户端无法连接服务端，查看服务器的端口开启状况，服务端口并没有开启。于是启动服务端，启动几秒后，服务端崩溃，重复启动，服务端依旧在启动几秒后崩溃。&lt;/p&gt;
&lt;h3&gt;步骤二.查看服务端日志分析&lt;/h3&gt;
&lt;p&gt;分析得知是因为java.lang.OutOfMemoryError: Java heap space（堆内存溢出）导致的服务崩溃。&lt;/p&gt;
&lt;p&gt;客户端搜集的主机信息，主机策略都是放在缓存中，可能是因为缓存较大造成的，但是通过日志可以看出是因为Thrift服务抛出的堆内存溢出异常与缓存大小无关。&lt;/p&gt;
&lt;h3&gt;步骤三.再次分析服务端日志&lt;/h3&gt;
&lt;p&gt;可以发现每次抛出异常的时候都会伴随着几十个客户端在向服务端发送日志，往往在发送几十条日志之后，服务崩溃。可以假设是不是堆内存设置的太小了？&lt;/p&gt;
&lt;p&gt;查看启动参数配置，最大堆内存为256MB。修改启动配置，启动的时候分配更多的堆内存，改成java -server -Xms512m -Xmx768m。&lt;/p&gt;
&lt;p&gt;结果是，能坚持多一点的时间，依旧会内存溢出服务崩溃。得出结论，一味的扩大内存是没有用的。&lt;/p&gt;&lt;p&gt;**为了证明结论是正确的，做了这样的实验：**&lt;br/&gt;&amp;gt; 内存设置为256MB，在公司服务器上部署了服务端，使用Java VisualVM远程监控服务器堆内存。&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; 模拟客户现场，注册3000个客户端，使用300个线程同时发送日志。&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; 结果和想象的一样，没有出现内存溢出的情况，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201802/1167080-20180226172359885-534234385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&amp;gt; 上图是Java VisualVM远程监控，在压力测试的情况下，没有出现内存溢出的情况，256MB的内存肯定够用的。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤四.回到thrift源码中，查找关键问题&lt;/h3&gt;
&lt;p&gt;服务端采用的是Thrift框架中TThreadedSelectorServer这个类，这是一个NIO的服务。下图是thrift处理请求的模型：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201802/1167080-20180226172513168-1647790480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;**说明：**&lt;br/&gt;&amp;gt;一个AcceptThread执行accept客户端请求操作，将accept到的Transport交给SelectorThread线程，&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;AcceptThread中有个balance均衡器分配到SelectorThread；SelectorThread执行read，write操作，&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;read到一个FrameBuffer（封装了方法名，参数，参数类型等数据，和读取写入，调用方法的操作）交给WorkerProcess线程池执行方法调用。&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;**内存溢出就是在read一个FrameBuffer产生的。**&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤五.细致一点描述thrift处理过程&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;&amp;gt;1.服务端服务启动后，会listen()一直监听客户端的请求，当收到请求accept()后，交给线程池去处理这个请求&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;2.处理的方式是：首先获取客户端的编码协议getProtocol（），然后根据协议选取指定的工具进行反序列化，接着交给业务类处理process（）&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;3.process的顺序是，**先申请临时缓存读取这个请求数据**，处理请求数据，执行业务代码，写响应数据,**最后清除临时缓存**&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; **总结：thrift服务端处理请求的时候，会先反序列化数据，接着申请临时缓存读取请求数据，然后执行业务并返回响应数据，最后请求临时缓存。**&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; 所以压力测试的时候，thrift性能很高，而且内存占用不高，是因为它有自负载调节，使用NIO模式缓存，并使用线程池处理业务，每次处理完请求之后及时清除缓存。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤六.研读FrameBuffer的read方法代码&lt;/h3&gt;
&lt;p&gt;可以排除掉没有及时清除缓存的可能，方向明确，极大的可能是在申请NIO缓存的时候出现了问题，回到thrift框架，查看FrameBuffer的read方法代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43.5&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot; readability=&quot;8&quot;&gt;
public boolean read() {&lt;p&gt;　　　　　　　　&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
            if (this.state_ == AbstractNonblockingServer.FrameBufferState.READING_FRAME_SIZE) {
                if (!this.internalRead()) {
                    return false;
                }&lt;br/&gt;　　　　　　　　 
                if (this.buffer_.remaining() != 0) {
                    return true;
                }

                int frameSize = this.buffer_.getInt(0);
                if (frameSize &amp;lt;= 0) {
                    this.LOGGER.error(&quot;Read an invalid frame size of &quot; + frameSize + &quot;. Are you using TFramedTransport on the client side?&quot;);
                    return false;
                }
　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
                if ((long)frameSize &amp;gt; AbstractNonblockingServer.this.MAX_READ_BUFFER_BYTES) {
                    this.LOGGER.error(&quot;Read a frame size of &quot; + frameSize + &quot;, which is bigger than the maximum allowable buffer size for ALL connections.&quot;);
                    return false;
                }

                if (AbstractNonblockingServer.this.readBufferBytesAllocated.get() + (long)frameSize &amp;gt; AbstractNonblockingServer.this.MAX_READ_BUFFER_BYTES) {
                    return true;
                }

                AbstractNonblockingServer.this.readBufferBytesAllocated.addAndGet((long)(frameSize + 4));
                this.buffer_ = ByteBuffer.allocate(frameSize + 4);
                this.buffer_.putInt(frameSize);
                this.state_ = AbstractNonblockingServer.FrameBufferState.READING_FRAME;
            }

            if (this.state_ == AbstractNonblockingServer.FrameBufferState.READING_FRAME) {
                if (!this.internalRead()) {
                    return false;
                } else {
                    if (this.buffer_.remaining() == 0) {
                        this.selectionKey_.interestOps(0);
                        this.state_ = AbstractNonblockingServer.FrameBufferState.READ_FRAME_COMPLETE;
                    }

                    return true;
                }
            } else {
                this.LOGGER.error(&quot;Read was called but state is invalid (&quot; + this.state_ + &quot;)&quot;);
                return false;
            }
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;**说明：**&lt;br/&gt;&amp;gt;MAX_READ_BUFFER_BYTES这个值即为对读取的包的长度限制，如果超过长度限制，就不会再读了/&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt;这个MAX_READ_BUFFER_BYTES是多少呢，thrift代码中给出了答案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    public abstract static class AbstractNonblockingServerArgs&amp;lt;T extends AbstractNonblockingServer.AbstractNonblockingServerArgs&amp;lt;T&amp;gt;&amp;gt; extends AbstractServerArgs&amp;lt;T&amp;gt; {&lt;br/&gt;　　　　　
        public long maxReadBufferBytes = 9223372036854775807L;

        public AbstractNonblockingServerArgs(TNonblockingServerTransport transport) {
            super(transport);
            this.transportFactory(new Factory());
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;br/&gt;&amp;gt;从上面源码可以看出，默认值居然给到了long的最大值9223372036854775807L。&lt;/p&gt;
&lt;p&gt;所以thrift的开发者是觉得使用thrift程序员不够觉得内存不够用吗，这个换算下来就是1045576TB，这个太夸张了，这等于没有限制啊，所以肯定不能用默认值的。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤七.通信数据抓包分析&lt;/h3&gt;
&lt;p&gt;需要可靠的证据证明一个客户端通信的数据包的大小。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201802/1167080-20180226172938491-910394075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个是我抓到包最大的长度，最大一个包长度只有215B，所以需要限制一下读取大小&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤八：踏破铁鞋无觅处&lt;/h3&gt;
&lt;p&gt;在论坛中，看到有人用http请求thrift服务端出现了内存溢出的情况，所以我抱着试试看的心态，在浏览器中发起了http请求，&lt;/p&gt;
&lt;p&gt;果不其然，出现了内存溢出的错误，和客户现场出现的问题一摸一样。这个读取内存的时候数量过大，超过了256MB。&lt;br/&gt;&amp;gt; 很明显的一个问题，正常的一个HTTP请求不会有256MB的，考虑到thrift在处理请求的时候有反序列化这个操作。&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; 可以做出假设是不是反序列化的问题，不是thrift IDL定义的不能正常的反序列化？&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;gt; 验证这个假设，我用Java socket写了一个tcp客户端，向thrift服务端发送请求，果不其然！java.lang.OutOfMemoryError: Java heap space。&lt;br/&gt;&amp;gt; 这个假设是正确的,客户端请求数据不是用thrift IDL定义的话，无法正常序列化，序列化出来的数据会异常的大！大到超过1个G的都有。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;步骤九. 找到原因&lt;/h3&gt;
&lt;p&gt;某些客户端没有正常的序列化消息，导致服务端在处理请求的时候，序列化出来的数据特别大，读取该数据的时候出现的内存溢出。&lt;/p&gt;
&lt;p&gt;查看维护记录，在别的客户那里也出现过内存溢出导致服务端崩溃的情况，通过重新安装客户端，就不再复现了。&lt;/p&gt;
&lt;p&gt;所以可以确定，客户端存在着无法正常序列化消息的情况。考虑到，客户端量比较大，一个一个排除，再重新安装比较困难，工作量很大，所以可以从服务端的角度来解决问题，减少维护工作量。&lt;/p&gt;
&lt;p&gt;最后可以确定解决方案了，真的是废了很大的劲，不过也是颇有收获&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;问题解决方案&lt;/h2&gt;
&lt;p&gt;非常简单&lt;/p&gt;
&lt;p&gt;在构造TThreadedSelectorServer的时候，增加args.maxReadBufferBytes = 1*1024 * 1024L;也就是说修改maxReadBufferBytes的大小，设置为1MB。&lt;/p&gt;
&lt;p&gt;客户端与服务端通过thrift通信的数据包，最大十几K，所以设置最大1MB，是足够的。代码部分修改完成，版本不做改变**&lt;br/&gt;修改完毕后，这次进行了异常流测试，发送了http请求，使服务端无法正常序列化。&lt;/p&gt;&lt;p&gt;服务端处理结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201802/1167080-20180226173004237-1507645318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;thrift会抛出错误日志，并直接没有读这个消息，返回false,不处理这样的请求，将其视为错误请求。&lt;/p&gt;&lt;p&gt;3.国外有人对thrift一些server做了压力测试，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201803/1167080-20180301212825802-2067352894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用thrift中的TThreadedSelectorServer吞吐量达到18000以上&lt;br/&gt;由于高性能，申请内存和清除内存的操作都是非常快的，平均3ms就处理了一个请求。&lt;br/&gt;所以是推荐使用TThreadedSelectorServer&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;4.修改启动脚本，增大堆内存，分配单独的直接内存。&lt;/p&gt;
&lt;p&gt;修改为java -server -Xms512m -Xmx768m -XX:MaxPermSize=256m -XX:NewSize=256m -XX:MaxNewSize=512m -XX:MaxDirectMemorySize=128M。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;设置持久代最大值 MaxPermSize:256m&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;设置年轻代大小 NewSize:256m&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;年轻代最大值 MaxNewSize:512M&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;最大堆外内存（直接内存）MaxDirectMemorySize：128M&lt;/p&gt;&lt;p&gt;5.综合论坛中，StackOverflow一些同僚的意见，在使用TThreadedSelectorServer时，将读取内存限制设置为1MB，最为合适，正常流和异常流的情况下不会有内存溢出的风险。&lt;/p&gt;&lt;p&gt; 之前启动脚本给服务端分配的堆内存过小，考虑到是NIO，所以在启动服务端的时候，有必要单独分配一个直接内存供NIO使用.修改启动参数。&lt;/p&gt;
&lt;p&gt;增加堆内存大小直接内存，防止因为服务端缓存太大，导致thrift服务没有内存可申请，无法处理请求。&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;总结：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;真的是一次非常酸爽的过程，特此发个博客记录一下，如果有说的不对的对方，欢迎批评斧正！如果觉得写的不错，欢迎给我点个推荐，您的一个推荐是我莫大的动力！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 13:55:00 +0000</pubDate>
<dc:creator>Janti</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superfj/p/8474288.html</dc:identifier>
</item>
<item>
<title>CSS布局(六) 对齐方式 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8490725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8490725.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、水平居中：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;(1). &lt;/strong&gt;&lt;strong&gt;行内元素的水平居中？&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;如果被设置元素为文本、图片等&lt;strong&gt;行内元素时，&lt;/strong&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;在父元素中设置text-align:center实现&lt;span class=&quot;Apple-tab-span&quot;&gt;行内元素水平居中&lt;/span&gt;，&lt;/span&gt;将子元素的display设置为&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5202761.html#anchor3&quot; target=&quot;_blank&quot;&gt;inline-block&lt;/a&gt;，使子元素变成行内元素&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301204710541-1654965690.png&quot; alt=&quot;&quot; width=&quot;989&quot; height=&quot;22&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: gray;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightblue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DEMO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
.parent&lt;/span&gt;{&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;}&lt;span&gt;    
.child&lt;/span&gt;{&lt;span&gt;display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;(2）块状元素的水平居中（定宽）&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;当被设置元素为&lt;strong&gt;定宽块级元素&lt;/strong&gt;时用 text-align：center 就不起作用了。可以通过设置“左右margin”值为“auto”来实现居中的。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301204710541-1654965690.png&quot; alt=&quot;&quot; width=&quot;989&quot; height=&quot;22&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: gray;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightblue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DEMO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        .child&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 0 auto&lt;/span&gt;;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;(3)&lt;/strong&gt;块状元素的水平居中（不定定宽）&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;在实际工作中我们会遇到需要为“不定宽度的块级元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;可以直接给不定宽的块级元素设置text-align：center来实现，也可以给父元素加text-align:center 来实现居中效果。&lt;/p&gt;
&lt;p&gt;当不定宽块级元素的宽度不要占一行时，可以设置display 为 inline 类型或inline-block（设置为 &lt;a title=&quot;忘了的小伙伴，让我们点击链接复习一下吧! &quot; href=&quot;http://www.imooc.com/code/2049&quot;&gt;行内元素&lt;/a&gt; 显示或行内块元素）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301210729454-1374240315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.container&lt;/span&gt;{&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt;center&lt;/span&gt;;&lt;span&gt;background&lt;/span&gt;:&lt;span&gt; beige&lt;/span&gt;}&lt;span&gt;
.container ul&lt;/span&gt;{&lt;span&gt;list-style&lt;/span&gt;:&lt;span&gt;none&lt;/span&gt;;&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;padding&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;display&lt;/span&gt;:&lt;span&gt;inline-block&lt;/span&gt;;}&lt;span&gt;
.container li&lt;/span&gt;{&lt;span&gt;margin-right&lt;/span&gt;:&lt;span&gt;8px&lt;/span&gt;;&lt;span&gt;display&lt;/span&gt;:&lt;span&gt;inline-block&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、垂直居中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;和水平居中一样，这里要讲垂直居中，首先设定两个条件即&lt;/strong&gt;父元素是盒子容器且&lt;span&gt;&lt;strong&gt;高度已经设定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景1：子元素是行内元素，高度是由其内容撑开的&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;这种情况下，需要通过设定父元素的line-height为其高度来使得子元素垂直居中&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301212628846-1718190874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrap line-height&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;span&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;111111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; .wrap&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt;200px &lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
            line-height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 2px solid #ccc&lt;/span&gt;;
        }&lt;span&gt;
.span&lt;/span&gt;{&lt;span&gt;
            background&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
        }
       
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;场景2：&lt;strong&gt;&lt;span&gt;子元素是块级元素但是子元素高度没有设定，&lt;/span&gt;&lt;/strong&gt;在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整，但是还是存在一些解法。&lt;/p&gt;
&lt;p&gt;通过给父元素设定display:table-cell;vertical-align:middle来解决&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;non-height &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;11111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.wrap&lt;/span&gt;{&lt;span&gt;
       width&lt;/span&gt;:&lt;span&gt;200px &lt;/span&gt;;&lt;span&gt;
       height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
       border&lt;/span&gt;:&lt;span&gt; 2px solid #ccc&lt;/span&gt;;&lt;span&gt;
　　　　display&lt;/span&gt;:&lt;span&gt; table-cell&lt;/span&gt;;&lt;span&gt;
　　　　vertical-align&lt;/span&gt;:&lt;span&gt; middle&lt;/span&gt;;
}&lt;span&gt;
 .non-height&lt;/span&gt;{&lt;span&gt;
       background&lt;/span&gt;:&lt;span&gt; green&lt;/span&gt;;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/475683/201504/052009329913003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景3：子元素是块级元素且高度已经设定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算子元素的margin-top或margin-bottom，计算方法为父(元素高度-子元素高度)/2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrap &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;111111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  .wrap&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt;200px &lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 2px solid #ccc&lt;/span&gt;;
        }&lt;span&gt;
.div1&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt;100px &lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
            margin-top&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
            background&lt;/span&gt;:&lt;span&gt; darkblue&lt;/span&gt;;
        }    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/475683/201504/042114443108522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、水平垂直居中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1水平对齐+行高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;text-align + line-height实现单行文本水平垂直居中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
.test&lt;/span&gt;{&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightblue;width: 200px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301214013762-35545258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2水平+垂直对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;anchor2&quot;&gt;1. text-align + vertical-align　　在父元素设置&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5325063.html#anchor2&quot; target=&quot;_blank&quot;&gt;text-align&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5271217.html#anchor2&quot; target=&quot;_blank&quot;&gt;vertical-align&lt;/a&gt;，并将父元素设置为&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5202761.html#anchor9&quot; target=&quot;_blank&quot;&gt;table-cell&lt;/a&gt;元素，子元素设置为&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5202761.html#anchor3&quot; target=&quot;_blank&quot;&gt;inline-block&lt;/a&gt;元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
.parent&lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; table-cell&lt;/span&gt;;&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    vertical-align&lt;/span&gt;:&lt;span&gt; middle&lt;/span&gt;;
}&lt;span&gt;
.child&lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;
}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: gray; width:200px; height:100px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightblue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301214238241-362244515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.若子元素是&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5008341.html&quot; target=&quot;_blank&quot;&gt;图像&lt;/a&gt;，可不使用table-cell，而是其父元素用&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5271217.html#anchor1&quot; target=&quot;_blank&quot;&gt;行高&lt;/a&gt;替代高度，且&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/4986285.html#anchor3&quot; target=&quot;_blank&quot;&gt;字体大小&lt;/a&gt;设为0。子元素本身设置vertical-align:middle&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: gray; width:200px; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;http://sandbox.runjs.cn/uploads/rs/26/ddzmgynp/img1.gif&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;50%&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
.parent&lt;/span&gt;{&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;
.child&lt;/span&gt;{&lt;span&gt;
    vertical-align&lt;/span&gt;:&lt;span&gt; middle&lt;/span&gt;;
}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301214506851-532651430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;anchor4&quot;&gt;3.3相对+绝对定位&lt;/h3&gt;
&lt;p&gt;使用absolute，利用&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5312917.html&quot; target=&quot;_blank&quot;&gt;绝对定位&lt;/a&gt;元素的&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5289143.html#anchor5&quot; target=&quot;_blank&quot;&gt;盒模型特性&lt;/a&gt;，在&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5289143.html#anchor3&quot; target=&quot;_blank&quot;&gt;偏移属性&lt;/a&gt;为确定值的基础上，设置margin:auto&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
.parent&lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;
}&lt;span&gt;
.child&lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 80px&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;
}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightgray; width:200px; height:100px; &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;background-color: lightblue;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试文字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180301214935620-887121937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 13:51:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8490725.html</dc:identifier>
</item>
<item>
<title>用VSCode开发一个基于asp.net core 2.0/sql server linux(docker)/ng5/bs4的项目(2) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8481825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8481825.html</guid>
<description>&lt;p&gt;第一部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8478993.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8478993.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为Domain Model添加约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前一部分, 我们已经把数据库创建出来了. 那么我们先看看这个数据库.&lt;/p&gt;
&lt;p&gt;可以在项目里面建立一个database.sql, 并且建立一个数据库连接的profile(参考上一篇文章), 连接成功后执行下面语句:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; TABLE_NAME &lt;span&gt;FROM&lt;/span&gt; tvdb.INFORMATION_SCHEMA.TABLES &lt;span&gt;WHERE&lt;/span&gt; TABLE_TYPE &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BASE TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228084422625-615313445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右侧结果可以看到建立的table, 其中一个是迁移表, 另外两个是Domain Model所对应的业务表.&lt;/p&gt;
&lt;p&gt;使用下面的sql语句查询表的字段定义:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; information_schema.columns &lt;span&gt;where&lt;/span&gt; table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TvNetworks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; information_schema.columns &lt;span&gt;where&lt;/span&gt; table_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TvShows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228085040845-1194197658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果的CHARACTER_MAXIMUM_LENGTH字段可以看出, 目前name字段的类型都是nvarchar(max):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228085245099-864707631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这可能不是我们想要的, 所以就需要为Domain Model的相应属性添加一些约束.&lt;/p&gt;
&lt;p&gt;打开TvNetwork和TvShow, 为name属性添加约束:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.ObjectModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvNetwork
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TvNetwork()
        {
            TvShows &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Collection&amp;lt;TvShow&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;span&gt;[Required]
        [StringLength(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;50)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;TvShow&amp;gt; TvShows { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.ObjectModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel.DataAnnotations;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvNetwork
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TvNetwork()
        {
            TvShows &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Collection&amp;lt;TvShow&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;span&gt;[Required]
        [StringLength(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;50)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;TvShow&amp;gt; TvShows { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;EF Core其他的约束属性请参考文档, 这里就不介绍了.&lt;/p&gt;
&lt;p&gt;这种对Domain Model进行约束的方法使用的是DataAnnotation, 而我个人更喜欢使用FluetApi, 不过在这篇文章里这个不是重点.&lt;/p&gt;
&lt;p&gt;然后添加migrations:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet ef migrations add AddConstraints
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看一下生成的migration文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228090153926-1082202919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没问题, 可以执行dotnet ef database update了. 执行成功后, 可以看到表的字段约束已经添加成功了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228090346773-66675051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为数据库添加种子数据&lt;/span&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;添加种子数据的方法有很多, 可以写一个方法然后在Startup里面调用. 这里我使用添加migration的方式:&lt;/p&gt;
&lt;p&gt;命令行添加一个空的migration:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet ef migrations add SeedData
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打开这个migration文件, 添加如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore.Migrations;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Migrations
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeeData : Migration
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvNetworks (Name) VALUES ('Netflix')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvNetworks (Name) VALUES ('HBO')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvNetworks (Name) VALUES ('CBS')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvNetworks (Name) VALUES ('NBC')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('House of Cards', (SELECT Id FROM TvNetworks WHERE Name='Netflix'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Altered Carbon', (SELECT Id FROM TvNetworks WHERE Name='Netflix'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Marvel''s Daredevil', (SELECT Id FROM TvNetworks WHERE Name='Netflix'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Game of Thrones', (SELECT Id FROM TvNetworks WHERE Name='HBO'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Silicon Valley', (SELECT Id FROM TvNetworks WHERE Name='HBO'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Veep', (SELECT Id FROM TvNetworks WHERE Name='HBO'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('NCIS', (SELECT Id FROM TvNetworks WHERE Name='CBS'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('The Big Bang Theory', (SELECT Id FROM TvNetworks WHERE Name='CBS'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Criminal Minds', (SELECT Id FROM TvNetworks WHERE Name='CBS'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Friends', (SELECT Id FROM TvNetworks WHERE Name='NBC'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Chicago Fire', (SELECT Id FROM TvNetworks WHERE Name='NBC'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO TvShows (Name, TvNetworkId) VALUES ('Will &amp;amp; Grace', (SELECT Id FROM TvNetworks WHERE Name='NBC'))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.Sql(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETE FROM TvNetworks WHERE Name IN ('Netflix', 'HBO', 'CBS', 'NBC')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后执行 dotnet ef database update. 成功后可以查看到数据:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228092446968-69262120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Controllers文件夹下建立TvController.cs. &lt;/p&gt;
&lt;p&gt;需要注入TvContext, 这时候聚焦到context变量上使用cmd+. 这个快捷键 生成一个field:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228093903550-154356612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后, 就会生成一个field:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228094013704-1110548564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 完成后到代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.Database;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.Models;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Controllers
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; TvContext context;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TvController(TvContext context)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/tvnetworks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IEnumerable&amp;lt;TvNetwork&amp;gt;&amp;gt;&lt;span&gt; GetTvNetworks()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; context.TvNetworks.Include(x =&amp;gt;&lt;span&gt; x.TvShows).ToListAsync();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这部分代码所涉及到的asp.net core的知识请参考我写的这个系列文章: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7637250.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7637250.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行项目: dotnet watch run, 这时我们需要使用postman来测试这个api.&lt;/p&gt;
&lt;p&gt;以前postman是chrome浏览器的一个扩展应用, 由于被墙, 可能会安装不上, 而现在postman是一个独立的应用了, 应该都能下载安装了: &lt;a href=&quot;https://www.getpostman.com/&quot; target=&quot;_blank&quot;&gt;https://www.getpostman.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于以前讲过postman, 所以这里我就不用postman了. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Rest Client&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我使用vscode扩展rest client来测试api. rest client简介部分可以参考这个文章: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8450409.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8450409.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建立一个httptest文件, 打开文件, 使用命令面板 输入查找这个命令:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228095358470-1395170822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择http:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228095447701-663871567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在文件中写下api的uri:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/api/tvnetworks&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后你会发现, 该uri的上方有一个send request 按钮:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228095635355-165308193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击这个按钮, 发送请求.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228095742948-1795963807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管请求返回结果是200, 但是你也可以发现结果并不正确, 看一下终端命令行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228095847772-803254259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实是发生了异常, 因为一个Tvnetwork有个导航属性是多个TvShow, 而一个TvShow还有一个反向导航属性是TvNetwork, 所以dbcontext查询出来在进行json转化的时候, 会无限循环下去, 就引起了self referencing loop.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以web api 不应该把Domain Model直接暴露出去, 应该使用ViewModel或者叫Dto.&lt;/span&gt;..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;建立ViewModel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立ViewModels/TvNetworkViewModel.cs 和 TvShowViewModel.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.ObjectModel;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.ViewModels
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvNetworkViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TvNetworkViewModel()
        {
            TvShows &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Collection&amp;lt;TvShowViewModel&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;TvShowViewModel&amp;gt; TvShows { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.ViewModels
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvShowViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TvNetworkId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意TvShowViewModel里面并没有反向的TvNetWork属性, 这也保证了不会发生上面的自身循环引用异常.&lt;/p&gt;
&lt;p&gt;接下来需要做的就是在Controller里面把Domain Model的属性传递给ViewModel, 没人会去手写这个映射的过程, 所以应该使用AutoMapper等类似的库&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AutoMapper&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先添加AutoMapper, 一共有两个包:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dotnet add package AutoMapper
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别忘了还要执行dotnet restore. &lt;/p&gt;
&lt;p&gt;安装成功后, 在Startup.cs里面注册AutoMapper:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228101214765-580447995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外, AutoMapper还需要知道Domain Model和ViewModel的对应关系和方向.&lt;/p&gt;
&lt;p&gt;建立Mapping/MappingProfile.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AutoMapper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.ViewModels;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Mapping
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MappingProfile : Profile
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MappingProfile()
        {
            CreateMap&lt;/span&gt;&amp;lt;TvNetwork, TvNetworkViewModel&amp;gt;&lt;span&gt;();
            CreateMap&lt;/span&gt;&amp;lt;TvShow, TvShowViewModel&amp;gt;&lt;span&gt;();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在Controller里面需要注入AutoMapper:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AutoMapper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.Database;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Tv.ViewModels;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Tv.Controllers
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TvController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; TvContext context;
        &lt;/span&gt;&lt;span&gt;private readonly IMapper mapper;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TvController(TvContext context, &lt;span&gt;IMapper mapper&lt;/span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
            &lt;/span&gt;&lt;span&gt;this.mapper =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mapper;&lt;/span&gt;
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/tvnetworks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IEnumerable&amp;lt;&lt;span&gt;TvNetworkViewModel&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; GetTvNetworks()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; models = &lt;span&gt;await&lt;/span&gt; context.TvNetworks.Include(x =&amp;gt;&lt;span&gt; x.TvShows).ToListAsync();
            &lt;/span&gt;&lt;span&gt;var vms = mapper.Map&amp;lt;List&amp;lt;TvNetwork&amp;gt;, List&amp;lt;TvNetworkViewModel&amp;gt;&amp;gt;(models);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vms;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;差不多了, 再次测试一下这个api:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228102851667-713649858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没毛病!!!&lt;/p&gt;

&lt;p&gt;按照第一部分的操作安装好angular cli之后 (&lt;a href=&quot;https://github.com/angular/angular-cli&quot; target=&quot;_blank&quot;&gt;https://github.com/angular/angular-cli&lt;/a&gt;), 就可以打开命令行建立angular 客户端项目了. 使用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ng new tv-client
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建一个名字为tv-client的angular项目. 此时, cli会通过npm自动安装依赖的包. &lt;/p&gt;
&lt;p&gt;安装好所有的包之后, 就可以进入该目录 cd tv-client 并用 vscode打开该目录: code+.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228135038084-1066378979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个项目里面, 我们主要是在src/app里面写代码, 也会简单修改一下angular-cli.json文件.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行angular项目&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;可以使用ng server或者npm start命令运行angular项目:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228140020384-695969782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最好还是使用npm start, 因为ng server以后会需要添加一些参数. &lt;/p&gt;
&lt;p&gt;所以npm start, 看看效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228140136896-1946144944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器 http://localhost:4200,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228140220393-2046443258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok, 项目建立成功了.&lt;/p&gt;
&lt;p&gt;由于已经存在种子数据了, 那么就可以查询列表了.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建TvNetwork列表&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;首先把当前目录切换到app下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228135315204-2061566808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据文档, 使用下面命令创建一个名为tv-network-list.ts的component, 并且在app模块进行注册, 如果不存在components文件夹则创建这个文件夹.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g c components/TvNetworkList -m=app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;生成文件如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301203416476-1932622050.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;并且已经在app.module进行了注册:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301203718302-1365899993.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们再创建两个component&lt;strong&gt;.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建TvNetwork表单&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;根据文档, 使用下面命令创建一个名为tv-network-form.ts的component, 并且在app模块进行注册, 如果不存在components文件夹则创建这个文件夹.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g c components/TvNetworkForm -m=app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个命令使用的都是缩写. 完整的写法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng generate component components/TvNetworkForm --module=app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的文件如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228135847477-1771794078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再建立一个home component:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g c components/home -m=app 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么, 如何访问这个form? 这就需要建立路由了, 不过首先先把bootstrap 4 安装上, 项目根目录执行以下命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save bootstrap jquery popper.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 安装好之后, 需要把bootstrap的css文件添加到angular-cli.json文件里:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228140847764-1761739096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面添加导航栏, 请参考bootstrap4文档: &lt;a href=&quot;http://getbootstrap.com/docs/4.0/components/navbar/&quot; target=&quot;_blank&quot;&gt;http://getbootstrap.com/docs/4.0/components/navbar/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改app.component.html如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nav &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-brand&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Tv&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; data-toggle&lt;/span&gt;&lt;span&gt;=&quot;collapse&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt; aria-controls&lt;/span&gt;&lt;span&gt;=&quot;navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt;
    aria-expanded&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; aria-label&lt;/span&gt;&lt;span&gt;=&quot;Toggle navigation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler-icon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;collapse navbar-collapse&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-nav mr-auto&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item active&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Home
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sr-only&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(current)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nav&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行npm start, 结果如下图就说明bootstrap4安装好了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228141315437-2143613317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;建立angular 路由&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;参考官方文档: &lt;a href=&quot;https://angular.io/tutorial/toh-pt5&quot; target=&quot;_blank&quot;&gt;https://angular.io/tutorial/toh-pt5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g m appRouting -flat -m=app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这会建立一个app-routing.module.ts模块, 并且不会创建自己的文件夹, 同样也会注册到app模块.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228142103195-826039294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改app-routing到代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
import { NgModule } from '@angular/core'&lt;span&gt;;
import { RouterModule, Routes } from &lt;/span&gt;'@angular/router'&lt;span&gt;;
import { HomeComponent } from &lt;/span&gt;'./components/home/home.component'&lt;span&gt;;
import { TvNetworkFormComponent } from &lt;/span&gt;'./components/tv-network-form/tv-network-form.component'&lt;span&gt;;
import { TvNetworkListComponent } from &lt;/span&gt;'./components/tv-network-list/tv-network-list.component'&lt;span&gt;;

const ROUTES: Routes &lt;/span&gt;=&lt;span&gt; [
  { path: &lt;/span&gt;'', redirectTo: '/home', pathMatch: 'full'&lt;span&gt; },
  { path: &lt;/span&gt;'home'&lt;span&gt;, component: HomeComponent },
  { path: &lt;/span&gt;'tvnetworks'&lt;span&gt;, component: TvNetworkListComponent },
  { path: &lt;/span&gt;'tvnetworks/new'&lt;span&gt;, component: TvNetworkFormComponent },
  { path: &lt;/span&gt;'**'&lt;span&gt;, component: HomeComponent }
];

@NgModule({
  imports: [ RouterModule.forRoot(ROUTES) ],
  exports: [RouterModule]
})
export class AppRoutingModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在编写angular的ts代码时, 由于安装了angular插件, 所以智能提示和自动补全和自动引用都是相当好的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分别设置了5个路由, 默认路由直接跳转到home, 如果没有匹配路由到话也是跳转到home.&lt;/p&gt;
&lt;p&gt;然后需要在app.component.html里面加上router-outlet, 并修改navbar里面到链接:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nav &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-brand&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Tv&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; data-toggle&lt;/span&gt;&lt;span&gt;=&quot;collapse&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt; aria-controls&lt;/span&gt;&lt;span&gt;=&quot;navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt;
    aria-expanded&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; aria-label&lt;/span&gt;&lt;span&gt;=&quot;Toggle navigation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler-icon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;collapse navbar-collapse&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;navbarSupportedContent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-nav mr-auto&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; routerLinkActive&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/home&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Home
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sr-only&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(current)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; routerLinkActive&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/tvnetworks&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Tv Network
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sr-only&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(current)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; routerLinkActive&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/tvnetworks/new&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Add Tv Network
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;sr-only&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(current)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nav&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看浏览器, 应该是这个效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301204117743-609994279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;建立Service&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了使用asp.net core到web api, 需要在angular客户端建立http的service. 这里我使用HttpClient.&lt;/p&gt;
&lt;p&gt;首先在app.module里面添加引用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
&lt;strong&gt;import { HttpClientModule } from '@angular/common/http';&lt;/strong&gt;


import { AppComponent } from './app.component';
import { TvNetworkFormComponent } from './components/tv-network-form/tv-network-form.component';
import { HomeComponent } from './components/home/home.component';
import { AppRoutingModule } from './/app-routing.module';


@NgModule({
  declarations: [
    AppComponent,
    TvNetworkFormComponent,
    HomeComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    &lt;strong&gt;HttpClientModule&lt;/strong&gt;
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用命令生成service:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g s services/TvNetwork -m=app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228145656829-1862802117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后编辑tv-network.service.ts, 添加一个获得所有tv network的方法, 返回类型是Observable:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import { Injectable } from '@angular/core'&lt;span&gt;;
import { HttpClient, HttpHeaders } from &lt;/span&gt;'@angular/common/http'&lt;span&gt;;

@Injectable()
export class TvNetworkService {

  constructor(
    private http: HttpClient
  ) { }

  &lt;strong&gt;getTvNetworks () {
    &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.http.get&amp;lt;any[]&amp;gt;('api/tvnetworks'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);
  }&lt;/strong&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;随后我们在tv-netowrk-list.component.ts里的ngOnInit方法调用它, 并把结果打印出来:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import { Component, OnInit } from '@angular/core'&lt;span&gt;;
import { TvNetworkService } from &lt;/span&gt;'../../services/tv-network.service'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-tv-network-list'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./tv-network-list.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./tv-network-list.component.css'&lt;span&gt;]
})
export class TvNetworkListComponent implements OnInit {

  tvNetworks: any[];

  constructor(
    private tvNetworkServices: TvNetworkService
  ) { }

  ngOnInit() {
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;.tvNetworkServices.getTvNetworks().subscribe(result =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tvNetworks =&lt;span&gt; result;
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tvNetworks);
    }, err &lt;/span&gt;=&amp;gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; {
      console.error(err);
    });&lt;/strong&gt;
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后让我们运行试试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301205222917-1683099912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到发生了错误404, angular客户端并没有找到这个api. 这是因为angular运行的是自己的web服务器端口4200, 而asp.net core也是运行自己服务器端口为5000.&lt;/p&gt;
&lt;p&gt;那么可以有多种解决办法:&lt;/p&gt;
&lt;p&gt;1. 可以在angular的service的url写成完整的地址, 但是, 由于开发时和生产时的api地址很有可能不一样, 那么这就意味着发布到正式环境之前要把所有services的url地址全部修改一遍, 显然, 这时不可取的. (也许可以定义一个前缀变量, 随着环境改变它的值).&lt;br/&gt;2. 由于angular cli其实使用的是webpack, 那么就可以使用proxy. &lt;/p&gt;
&lt;p&gt;我们就使用proxy, 参考官方文档: &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-proxy&quot; target=&quot;_blank&quot;&gt;https://github.com/angular/angular-cli/wiki/stories-proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在项目根目录建立一个proxy.conf.json文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;/api&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;target&quot;: &quot;http://localhost:5000&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;secure&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这表示所有的以/api开头的请求将会被转发到http://localhost:5000/api这个地址上.&lt;/p&gt;
&lt;p&gt;此外还需要修改package.json里面到npm start部分, 把上面的proxy文件添加为参数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301210157708-1063252102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重新运行angular项目, 这时只能使用 npm start这个命令, 如果想使用ng serve 命令则必须把后边的参数加上.&lt;/p&gt;
&lt;p&gt;重新访问TvNetworks菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301210326091-66270969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次读取api成功了. 那么接下来我们来完成这个列表页面.&lt;/p&gt;
&lt;p&gt;cmd+p, 输入 tv list html 打开tv-network-list.component.html.&lt;/p&gt;
&lt;p&gt;这里需要画一个table, 别忘了使用zencoding.&lt;/p&gt;
&lt;p&gt;表头部分, 按照下面输入然后按Tab:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301210835944-1141172457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Tbody部分:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301210959651-805243177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;thead-dark&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&quot;col&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;#&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&quot;col&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&quot;col&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;*ngFor&lt;/span&gt;&lt;span&gt;=&quot;let t of tvNetworks; let i = index&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{i+1}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{t.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180301211114498-1629195849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Beautiful.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继续编写表单&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;打开tv-network-form.component.html, 请看视频:&lt;/p&gt;

&lt;p&gt;最终代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;添加电视台&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名称&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201802/986268-20180228144657235-1285699230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您跟着这两篇文章做到现在, 肯定可以感觉到vscode到强大和不同, 它绝不仅仅是个编辑器. 我一直在使用vscode编写前台和python等, 现在也习惯使用vscode编写.net core项目了, Awesome.&lt;/p&gt;
&lt;p&gt;今天先写到这, 下一篇是CRUD部分. &lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 13:15:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8481825.html</dc:identifier>
</item>
<item>
<title>Java内部类总结 - 好好De活着</title>
<link>http://www.cnblogs.com/brave7/p/8486034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brave7/p/8486034.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java内部类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、 含义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Java编程语言里，程序是由类(class)构建而成的。在一个类的内部也可以声明类，我们把这&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　样的类叫做内部类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、 作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;实现了更好的封装，我们知道，普通类(非内部类)的访问修饰符不能为private或protected，而内部类可以。当我们将内部类声明为private时，&lt;/span&gt;&lt;span&gt;只有外部类可以访问内部类，很好地隐藏了内部类。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内部类可以继承(extends)或实现(implements)其他的类或接口，而不受外部类的影响。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内部类可以直接访问外部类的字段和方法，即使是用private修饰的，相反的，外部类不能直接访问内部类的成员。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、 原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内部类是一个编译时的概念，编译后会生成两个独立的class文件，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
    　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String outerName = &quot;outer&quot;&lt;span&gt;;
    　　&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inner{
        　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String innerName = &quot;inner&quot;&lt;span&gt;;
    　　}
　　}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;  　  编译后的文件如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262677/201802/1262677-20180228215124634-842388963.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;53&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编译后Outer.Inner被重命名为Outer$Inner，句点(.)被替换成了美元符号($)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、 分类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java内部类可分为成员内部类、局部内部类、匿名内部类、静态内部类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1） 成员内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　成员内部类可以看成是外部类的一个成员，在成员内部类中无法声明静态成员，但static&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　final字段是个例外。我们知道加载类时，&lt;/span&gt;&lt;span&gt;会先初始化静态成&lt;/span&gt;&lt;span&gt;员，如果成员内部类有静态成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　员，那么内部类就会在外部类之前生成，而内部类是为外部类服务的，内部类&lt;/span&gt;&lt;span&gt;在外部类之&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　前就生成可能会脱离掌控。&lt;/span&gt;&lt;span&gt;在实例化成员内部类时，成员内部类会持有一个外部类当前对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　象的引用，这样在成员内&lt;/span&gt;&lt;span&gt;部类中就可以直接访问外部类的成员，即使是private修饰的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　　  import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.System.out;
　　　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
　　　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String outerName = &quot;outer&quot;&lt;span&gt;;
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部类无法直接访问内部类的成员，需要实例化内部类对象&lt;/span&gt;
    　 &lt;span&gt;private&lt;/span&gt; Inner inner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inner(); 
    　 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inner{
       　　 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;  String innerName = &quot;inner&quot;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(){
           　　out.println(outerName); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以直接访问外部类的成员&lt;/span&gt;&lt;span&gt;
        　　}
    　 }
    　 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(){
       　　 out.println(inner.innerName);
        　  inner.show();
    　 }
    　 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
       　　 Outer outer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer();
        　　outer.show();
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化内部类&lt;/span&gt;&lt;span&gt;
        　　Outer.Inner inner &lt;/span&gt;= outer.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inner();
        　　inner.show();
    　　}
　　}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　inner&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　outer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　outer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　  &lt;/span&gt;&lt;span&gt;成员内部类对外部类对象的引用，是通过在this前面加上外部类的名字构成的，&lt;/span&gt;&lt;span&gt;这种形式叫作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　限定-this，&lt;/span&gt;&lt;span&gt;out.println(outerName)&lt;/span&gt;&lt;span&gt;与out.println(Outer.this.outerName)是等价的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2)  局部内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　局部内部类的使用和成员内部类的使用基本一致，只是局部内部类定义在外部类的方法中，就&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　像局部变量一样，并不是外部类的成&lt;/span&gt;&lt;span&gt;员。局部内部类在方法外&lt;/span&gt;&lt;span&gt;是无法访问到的，但它的实例可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以从方法中返回，并且实例在不再被引用之前会一直存在。局部内部类也&lt;/span&gt;&lt;span&gt;可以访问所在方法的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　局部变量、方法参数等，&lt;/span&gt;&lt;span&gt;限制是局部变量或方法参数只有在声明为final时才能被&lt;/span&gt;&lt;span&gt;访问。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.System.out;
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
    　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String outerName = &quot;outer&quot;&lt;span&gt;;
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; show(&lt;span&gt;final&lt;/span&gt; String str){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法参数为final类型&lt;/span&gt;
        　　&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inner{
            　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(){
                　　out.println(outerName&lt;/span&gt;+&lt;span&gt;str);
            　　}
        　　}
        　　Inner inner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inner();
        　　inner.print();
    　　}
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        　　Outer outer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer();
        　　outer.show(&lt;/span&gt;&quot;:lalala&quot;&lt;span&gt;);
    　　}
　　}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　    outer:lalala&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)  匿名内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以把匿名内部类想象成是没有类名的局部内部类，匿名内部类有以下特点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　1、匿名内部类不能有构造器，匿名内部类没有类名，肯定无法声明构造器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　2、匿名内部类必须继承或实现一个接口，指定给new的类型为匿名类的超类型，匿名类不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　  能有显示的extends或implements子句，&lt;/span&gt;&lt;span&gt;也不能有任何修饰符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　3、匿名内部类和成员内部类、局部内部类一样，也不能声明静态成员。&lt;/span&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.System.out;
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
     　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String outerName = &quot;outer&quot;&lt;span&gt;;
     　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; show(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String str){
           　　&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Inner(){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现了Inner接口&lt;/span&gt;
                 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(){
                        　　out.println(outerName&lt;/span&gt;+&lt;span&gt;str);
                  　　}
            　　}.print();
     　　}
     　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
             　　Outer outer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer();
             　　outer.show(&lt;/span&gt;&quot;:lalala&quot;&lt;span&gt;);
        　　}
　　}
　　&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inner{
       　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; print();
　　}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　  outer:lalala&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) 静态内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　静态内部类，有的书上也称为嵌套类，声明它时需要用static修饰符，静态内部类不同于前三&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　种内部类，静态内部类不会持有外部类&lt;/span&gt;&lt;span&gt;当前对象的引用，所以&lt;/span&gt;&lt;span&gt;在静态内部类中无法访问外部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　类的非静态成员，可以这么说，静态内部类不依赖于外部类。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.System.out;
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
    　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String outerName = &quot;outer&quot;&lt;span&gt;;
    　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id = 123&lt;span&gt;;
    　　&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Inner inner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inner();
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Inner{
        　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print1(){
            　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;out.println(outerName); 无法访问外部类的非静态成员&lt;/span&gt;&lt;span&gt;
            　　out.println(id);
        　　}
        　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print2(){
            　　out.println(id);
        　　}
    　　}
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(){
        　　inner.print1();
    　　}
    　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        　　Outer outer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer();
        　　outer.show();
        　　Outer.Inner.print2(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接通过类名访问静态内部类&lt;/span&gt;&lt;span&gt;
    　　}
　　}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;                    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Mar 2018 12:55:00 +0000</pubDate>
<dc:creator>好好De活着</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brave7/p/8486034.html</dc:identifier>
</item>
<item>
<title>基于JDK1.8的LinkedList剖析 - wenbochang</title>
<link>http://www.cnblogs.com/wenbochang/p/8488604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenbochang/p/8488604.html</guid>
<description>&lt;p&gt;之前写了一篇ArrayList，那么今天就写一篇他的姊妹篇，LinkedList。&lt;/p&gt;
&lt;p&gt;众所周知，ArrayList底层数据是数组，可以在O(1)的时间内get到数据，但删除和插入就要O(n)时间复杂度。&lt;/p&gt;
&lt;p&gt;所以出现了链表，链表可以在O(1)的时间内插入，并且不会浪费内存，用多少就链接多少即可。&lt;/p&gt;
&lt;p&gt;我们从以下几个方面介绍LinkedList&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Node节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;add方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;remove方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;get方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;(一)Node节点&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    E item;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Node&amp;lt;E&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     Node&amp;lt;E&amp;gt;&lt;span&gt; prev;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看出每个结点的组成部分有三个，一个是item数据，一个是prev前驱节点，一个是next后驱节点。&lt;/p&gt;
&lt;p&gt;那么就可以知道LinkedList就是一个双向链表，每个节点既有指向后面的链表，也有指向前面的链表。如下图(画的不好，见谅)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335795/201803/1335795-20180301145852000-585432740.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(二)add方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最基本的add方法，其他方法都是这个方法的变体&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    linkLast(e);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接调用了linkLast方法(也就是说，add方法是默认插入到链表的尾端)，然后return 一个 true。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将链表的last节点给l&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     last =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是第一个节点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         first =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接加入到尾节点的后面去&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         l.next =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道add方法是在队列尾部添加元素，还是很容易的。首先用变量 l 指向最后一个节点，然后创建一个节点将它的prev指向 l ，这样newnode成为最后一个节点，使用last指向它，接着使 l 的next指向newnode，这种直接添加在队列尾部的方式还是很好理解的，我们重点看看如何添加在队列的中间位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查插入位置是否合法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    checkPositionIndex(index);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果插入到最后，直接调用linkLast方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        linkLast(element);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则调用linkBefore&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        linkBefore(element, node(index));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接看注释。在调用linkBefore之前，调用了node(index)确定插入的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Node&amp;lt;E&amp;gt; x =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             x =&lt;span&gt; x.next;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Node&amp;lt;E&amp;gt; x =&lt;span&gt; last;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             x =&lt;span&gt; x.prev;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先判断在前半部分还是在后半部分，然后一个for循环查找。时间复杂度O(n), 没办法，链表的缺点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkBefore(E e, Node&amp;lt;E&amp;gt;&lt;span&gt; succ) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert succ != null;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; pred =&lt;span&gt; succ.prev;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;&lt;span&gt;(pred, e, succ);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     succ.prev =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         first =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         pred.next =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     size++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; (三)remove方法&lt;/h3&gt;
&lt;p&gt;看完了添加，删除就显得简单些，无非分为两种，从头部删除，从中间删除，从头部删除和从尾部添加一样简单，从中间删除就是把此结点的前一个结点的next指向此结点的后一个结点，并把后一个结点的prev指向此节点的前一个结点，就是跳过此结点，最终将此结点null交给GC大人解决。为了篇幅，我们不再赘述。&lt;/p&gt;
&lt;h3&gt; (四)get方法&lt;/h3&gt;
&lt;p&gt;由于LinkedList是链表，get方法必须扫描一遍链表，效率极低，所以谨慎使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否超过链表长度或者负数&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    checkElementIndex(index);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node节点我前面分析过了，O(n)复杂度&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从源代码中我们可以清晰的看到，所谓的get方法也就是，调用node方法遍历整个链表，只是其中稍微做了点优化，如果index的值小于size/2从头部遍历，否则从尾部遍历。可见效率一样低下，所以我们以后写程序的时候，如果遇到数据量不大但是需要经常遍历查找的时候使用ArrayList而不是LinkedList，如果数据量非常的大，但是不是很经常的查找时使用LinkedList。&lt;/p&gt;

</description>
<pubDate>Thu, 01 Mar 2018 12:42:00 +0000</pubDate>
<dc:creator>wenbochang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenbochang/p/8488604.html</dc:identifier>
</item>
<item>
<title>AJAX跨域完全讲解 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8490439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8490439.html</guid>
<description>&lt;p&gt;今天在慕课网上学习了AJAX跨域完全讲解：&lt;a href=&quot;https://www.imooc.com/learn/947&quot; class=&quot;uri&quot;&gt;https://www.imooc.com/learn/947&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我在收集AJAX面试题的时候其实就已经有过AJAX跨域的问题的了，当时候知道了为什么会存在跨域，以及跨域解决的方案有哪些，今天随着课程的学习，又加深了AJAX跨域的理解，以此记录下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CZbXdFg.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么会发生产生跨域问题&quot;&gt;为什么会发生产生跨域问题？&lt;/h2&gt;
&lt;p&gt;上面的图也很清晰了，因为浏览器为了安全(同源)，本身就限制了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;当我们发送XMLHttpRequest请求的时候，如果请求的是别的域(主机域名、端口)不同时，那么就会产生跨域问题(客户端无法获取服务端返回的数据)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是：&lt;strong&gt;跨域的问题是发生在XMLHttpRequest请求的，也就是说，不是XMLHttpRequest请求是不会有跨域问题的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;举个很简单的例子：在编写网页的时候，&lt;code&gt;&amp;lt;img = src = www.xxxx.xxxx/ &amp;gt;&lt;/code&gt;，URL不是本域的还是可以正常获取该图片的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解决跨域问题的思路&quot;&gt;解决跨域问题的思路&lt;/h2&gt;
&lt;p&gt;明显地，跨域的问题是由于浏览器限制的，是XMLHttpRequest才会发生的，那么我们可以以这个思路去找找解决思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/bSxh3Dg.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于浏览器的问题，可以使用相关的参数进行启动浏览器，是可以解决跨域的问题，但是通用性是极低的，了解即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;jsonp解决跨域&quot;&gt;JSONP解决跨域&lt;/h2&gt;
&lt;p&gt;JSONP是JSON使用的一种补充方式，不是官方的协议。JSONP是一种解决跨域问题的一种&lt;strong&gt;协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSONP这种解决方案其实现在已经很少用了(复杂一点，需要修改后台代码)，但我们可以适当了解一下。&lt;/p&gt;
&lt;h3 id=&quot;使用步骤&quot;&gt;使用步骤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在后端增加一个控制器，继承AbstractJsonpResponseBodyAdvice类，完整代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@ControllerAdvice&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JsonpAdvice &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractJsonpResponseBodyAdvice {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JsonpAdvice&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated constructor stub&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;callback2&quot;&lt;/span&gt;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端ajax请求：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;

&lt;span class=&quot;co&quot;&gt;// 服务器返回的结果&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; result&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ajax&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; base &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/get1&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;dataType&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;jsonp&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;jsonp&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;callback2&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;//是否需要缓存，如果这里没有配置缓存，那么请求的URL还会有一个参数&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(json)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; json&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意的是，前端AJAX的&lt;code&gt;jsonp: &quot;callback2&quot;,&lt;/code&gt;要和我们的Controller&lt;code&gt;super(&quot;callback2&quot;);&lt;/code&gt;是一致的，不然是不会有效的。&lt;/p&gt;
&lt;p&gt;JSONP原理是动态创建script来进行请求的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6EZ8HYa.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JSONP的弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要对服务器的代码进行改动&lt;/li&gt;
&lt;li&gt;只支持GET方法(原理是动态创建script来进行请求的)&lt;/li&gt;
&lt;li&gt;发送的不是XMLHttpRequest请求(XMLHttpRequest请求有很多好用的特性)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;cors解决跨域问题&quot;&gt;CORS解决跨域问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CORS解决跨域问题(也就是我们服务端被调用方解决跨域的思路）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于CORS是怎么理解的，我就直接摘抄一下：&lt;a href=&quot;https://segmentfault.com/a/1190000012469713#articleHeader8&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000012469713#articleHeader8&lt;/a&gt;的了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VcXyI3x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java中，我们写下面这个过滤器，就可以完全解决跨域的问题了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;package com.imooc;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.servlet.Filter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.FilterChain;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.FilterConfig;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.ServletException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.ServletRequest;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.ServletResponse;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.http.HttpServletRequest;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import javax.servlet.http.HttpServletResponse;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.tomcat.util.buf.StringUtils;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CrosFilter &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Filter {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;init&lt;/span&gt;(FilterConfig filterConfig) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ServletException {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;

    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)
            &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException, ServletException {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;

        HttpServletResponse res = (HttpServletResponse) response;
        
        HttpServletRequest req = (HttpServletRequest) request;
        
        
        &lt;span class=&quot;co&quot;&gt;//带cookie的时候，origin必须是全匹配，不能使用*&lt;/span&gt;
        String origin = req.&lt;span class=&quot;fu&quot;&gt;getHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Origin&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!org.&lt;span class=&quot;fu&quot;&gt;springframework&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;StringUtils&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;(origin)) {
            res.&lt;span class=&quot;fu&quot;&gt;addHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;, origin);
        }
        res.&lt;span class=&quot;fu&quot;&gt;addHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;*&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;// 支持所有自定义头和预检命令(非简单请求会有预检命令)&lt;/span&gt;
        String headers = req.&lt;span class=&quot;fu&quot;&gt;getHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Request-Headers&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!org.&lt;span class=&quot;fu&quot;&gt;springframework&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;util&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;StringUtils&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;(headers)) {
            res.&lt;span class=&quot;fu&quot;&gt;addHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;, headers);         
        }
        
        res.&lt;span class=&quot;fu&quot;&gt;addHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Max-Age&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;3600&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// enable cookie&lt;/span&gt;
        res.&lt;span class=&quot;fu&quot;&gt;addHeader&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access-Control-Allow-Credentials&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;);
        chain.&lt;span class=&quot;fu&quot;&gt;doFilter&lt;/span&gt;(request, response);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;

    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面提到了&lt;strong&gt;非简单请求&lt;/strong&gt;，那什么是非简单请求呢，可以看下面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2MmVTiL.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非简单请求会发出一个预检命令的(当然了，我们上面的Filter已经解决预检命令的问题了):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jTT5VAk.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;spring框架解决&quot;&gt;Spring框架解决&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果使用的是Spring框架的话，那就只需要一个注解就能够解决跨域的问题了&lt;/strong&gt;：&lt;code&gt;@CrossOrigin&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;http服务器层&quot;&gt;HTTP服务器层&lt;/h3&gt;
&lt;p&gt;我们在的商用开发中，一般请求的过程是这样的：&lt;strong&gt;浏览器-&amp;gt;HTTP服务器(Nginx,Apache)-&amp;gt;应用服务器(Tomcat,Weblogic)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面编写的Filter、Spring框架都是在应用服务器上解决的，&lt;strong&gt;我们也是可以通过HTTP服务器(Nginx,Apache)来进行解决跨域问题的&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ex1IOzq.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nginx我用过，Apache我倒是还没用过，下面就简单记录了Nginx和Apache是如何配置的：&lt;/p&gt;
&lt;p&gt;Nginx配置：&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/T1gp4st.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Apache配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/XWNZ7hU.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代理解决跨域问题&quot;&gt;代理解决跨域问题&lt;/h2&gt;
&lt;p&gt;在之前的图我们已经看到了，解决跨域的问题可以在“调用方”中来进行解决。&lt;/p&gt;
&lt;p&gt;“调用方”解决跨域的问题是这个思路的：&lt;strong&gt;让发送出去的请求代理成是本域的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;www.zhongfucheng.top是调用方

www.zhongfucheng.site是被调用方
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它俩是不同域的，但我们可以在nginx或Apache上进行&lt;strong&gt;配置代理：将被调用方www.zhongfucheng.site映射成别的路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，像下面的图，&lt;strong&gt;将8080端口的映射成了ajaxServer，当调用方访问ajaxServer路径时，这样的方法在外部看起来就不像是跨域了，像是访问本地（8081端口），但实际访问别的域（8080端口）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GWsV7LL.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;令我感到最简单的是通过Spring的注解就可以解决跨域的问题了，JSONP的方式已经是很少用的了，因为存在一定的弊端，但了解一下也无妨，毕竟可能面试的时候会问到。当没有用任何框架的时候，写Filter也不麻烦，也只是配置了一下HTTP头信息而已。如果使用Nginx、Apache时，也可以用代理或者配置HTTP头信息都可以解决。看完之后，有没有觉得跨域问题就迎刃而解了。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 01 Mar 2018 12:26:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8490439.html</dc:identifier>
</item>
<item>
<title>智能家居系统结构 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/8490423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/8490423.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/8490423.html 

　　作者：窗户

　　QQ：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;智能家居是指利用先进的计算机技术、网络通信技术、综合布线技术，将与家居生活有关的各种子系统有机地结合在一起，通过统筹管理，让家居生活更加舒适、安全、有效。随着社会全面的信息化、智能化和网络化，智能家居的日益普及将是一种必然。&lt;/p&gt;
&lt;p&gt;智能家居作为一个新生事物，目前处于只有初步概念，尚未有任何标准的阶段。&lt;/p&gt;
&lt;p&gt;本文为智能家居系统提供一个可能的设计模式以及未来发展的行业方向。&lt;/p&gt;

&lt;p&gt;    智能家居的家庭内部结构，需要包含一个嵌入式的智能网关，作为家庭智能家居的核心存在。围绕着智能网关，智能家居可以扩展性的加入各种方式的节点，用于各种对于家用电器/家庭通信设备/安防设备/计费仪表/节能设备/家具等进行控制与数据交互。另外，智能网关需要提供一个人机交互的手段。其内部的关系拓扑结构如下：&lt;/p&gt;
&lt;p&gt;                      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1151747/201803/1151747-20180301200408055-288202042.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                           图1  智能家居内部结构&lt;/p&gt;
&lt;p&gt;                 Fig.1 The internal structure of the smart home&lt;/p&gt;
&lt;p&gt;    考虑到小区可能需要一定的管理，比如包括物业信息传达，交纳费用等，智能家居可以再往上扩展，并以Internet为载体，以便于远程访问。以下为可能的小区拓扑结构：&lt;/p&gt;
&lt;p&gt;                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1151747/201803/1151747-20180301200531488-492073986.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                            图2 小区网络结构&lt;/p&gt;
&lt;p&gt;                 Fig.2 The structure of the community network&lt;/p&gt;
&lt;p&gt;小区网关对内和小区内所有家庭的智能家居网关在同一个局域网内，可以随时和智能网关进行通信。小区网关对外接Internet。这样就可以从外部通过Internet访问该小区内任何一个家庭的智能家居。&lt;/p&gt;
&lt;p&gt;由上，我们可以看出，对于单个家庭的智能家居来说，其智能网关是作为系统正常工作的核心设备存在的，而对于一个小区所有的智能家居来说，小区网关是作为关联所有智能家居系统，提供Internet服务的核心存在。这样，整个小区的智能家居网络结构成一个树形。最顶层是小区网关，第二层是智能网关，第三层是各种类型的节点。树状拓扑结构清晰，控制路径单一，小区网关也可以分为多层，对低层的智能家居节点也一样可以分为多层，根据实际情况而定，但在普通的情况下，三层是比较普遍的。&lt;/p&gt;

&lt;p&gt;智能家居系统中，节点用来控制家庭的各个部分以及反馈各个部分的相关信息，用于家用电器/家庭通信设备/安防设备/计费仪表/节能设备/家具等。&lt;/p&gt;
&lt;p&gt;安防设备中，比如摄像头，一般采用以太网或者WIFI来做为通信手段，而其他安防设备，比如门禁，通信数据量并不大，不一定需要较高速率的传输手段。&lt;/p&gt;
&lt;p&gt;智能计费仪表有些可能带有各自的无线通信模块，电表采用电力载波(PLC)传输比较常见。虽然智能网关一般来说不太会为了和电表通信而加一个电力载波模块，但可以设计一个电力载波转别的通信的硬件来作为电表节点使用。&lt;/p&gt;
&lt;p&gt;家用电器一般采用红外控制，考虑到红外通信的传输距离问题，传输距离最大只有十米，并且无法穿越墙壁等障碍，所以智能网关直接使用红外控制并不是可选方案，我们可以用一个家电控制模块去充当节点，而家电控制模块再通过别的方式与智能网关通信。&lt;/p&gt;
&lt;p&gt;而对于其他设备，如果在设计中要被应用到智能家居系统之中，也可以附着其他节点所已经使用的通信手段来实现。&lt;/p&gt;
&lt;p&gt;对于智能家居系统，考虑到家庭装修的美观以及使用的方便，一般不宜采用有线的方式来作为通信介质，而采用无线的方式来通信。WIFI可以用于大数据量通信，适合用于摄像头。尽管WIFI在通信速率上本可以做为所有节点间的通信手段，但考虑到WIFI用于TCP/IP的通信，而使用这样复杂的协议栈对于处理器要求比较高，另外加上功耗比较高，所以在慢速无线通信的时候，可以采用其他相对简单的无线通信。除了ISM频段，其他频段需要许可证，用于专用的通信，所以只可以在ISM频段下选择非WIFI的另外一种通信方式。&lt;/p&gt;
&lt;p&gt;目前最常用的无线通信方式除了WIFI外主要有Zigbee/蓝牙等。Zigbee和蓝牙尽管都适合低速率传输，但Zigbee有更加强大的网络拓扑功能，而蓝牙目前最主要用来一对一的通信。&lt;/p&gt;

&lt;h2&gt;3.1　Zigbee简介&lt;/h2&gt;
&lt;p&gt;Zigbee(IEEE802.15.4)技术是2000年以来建立起的一种采用跳频技术和扩频技术来实现的无线通信技术，采用2.4G频段，该频段属于ISM。&lt;/p&gt;
&lt;p&gt;IEEE802.15.4标准只是规定了物理层(PHY)和媒体接入控制层(MAC)，但设计PHY和MAC的时候考虑到了之后协议扩展的需要，而zigbee在此基础上再加入了上层协议，包括网络层和应用层。&lt;/p&gt;
&lt;h2&gt;3.2　Zigbee网络&lt;/h2&gt;
&lt;p&gt;除了最简单的一对一通信之外，zigbee实现了各种网络结构，所有的zigbee网络中，都有唯一的一个核心，称之为协调器。除了协调器之外，还有一些其他的成员，根据网络中其他成员与协调器之间关系，可以分为星型网络，以及树型网络，还有最复杂的网格网络。&lt;/p&gt;
&lt;p&gt;星型网络:所有的非协调器网络成员只与协调器之间直接通信，成员之间的通信通过协调器转发。&lt;/p&gt;
&lt;p&gt;树型网络:整个网络拓扑是一个树型，网络中两个网络成员之间通信可能需要别的成员进行数据转发。因为为树型，任何两个非协调器成员之间的通信路径单一。&lt;/p&gt;
&lt;p&gt;网格网络：网络拓扑是一个连通图，但可能不是树型，于是可能存在两个点的通信路径不唯一。&lt;/p&gt;
&lt;p&gt;对于树型网络和网格网络，称参与通信数据转发的非协调器成员叫路由器，而不参与通信数据转发的成员叫节点。&lt;/p&gt;
&lt;h2&gt;3.3　Zigbee的优点以及缺点&lt;/h2&gt;
&lt;p&gt;Zigbee的优点主要有如下几点：&lt;/p&gt;
&lt;p&gt;低功耗：引入休眠和唤醒机制。&lt;/p&gt;
&lt;p&gt;低成本：Zigbee协议栈实现简单，无专利费的门槛。&lt;/p&gt;
&lt;p&gt;网络容量大：当采用网格网络组网的时候，整个网络最大的规模可以到60000以上。一个区域内可以同时存在最多可达100个不同的Zigbee网络&lt;/p&gt;
&lt;p&gt;安全性：采用AES 128位对称加密算法保障用户通信安全，非对称加密计算复杂度底，使用单片机完全可以完成。&lt;/p&gt;
&lt;p&gt;通信可靠：动态组网，网络拓扑结构可能随时自动调整。&lt;/p&gt;
&lt;p&gt;当然Zigbee也有缺点，缺点主要有如下几点：&lt;/p&gt;
&lt;p&gt;传输距离小：Zigbee网络有效传输距离一般10米~75米，这个距离使得覆盖面积较小。用功率放大器可以扩大覆盖范围。&lt;/p&gt;
&lt;p&gt;数据传输速率低：链路层上的速率只有200Kb/s，在此基础上，还有帧头、应答、重传以及信道竞争等等，所以实际的速率是很低的。&lt;/p&gt;
&lt;h2&gt;3.4　为何采用Zigbee&lt;/h2&gt;
&lt;p&gt;Zigbee的通信实现简单，协议栈可以在一个主频只有50MHz，RAM只有8k的处理器上运行，对硬件的要求很低。Zigbee动态组网，随时可以加入新的节点到网络，组网方便。Zigbee对于普通不带路由功能的节点通信采用休眠/唤醒机制，大多数情况下硬件可以处于休眠状态，功耗可以很低，两节5号电池可以使用半年之久。&lt;/p&gt;
&lt;p&gt;考虑到智能家居系统之中，一些节点可能需要电池去供电，功耗是一个很重要的参考因素。大多数的通信在于节点状态汇报，网关发出控制指令等，而这些通信数据量都很低。从而，设计智能家居系统的时候，可以考虑使用zigbee作为智能网关与各个节点之间通信的手段，采用网格网络比星型网络更有优势。在Zigbee网格网络中，路由器因为随时需要通信转发，所以无法休眠，耗电量相对较大，设计时可以考虑使用在一些外部供电的节点上，例如电表抄表、智能插座;而不带路由功能的普通节点可以使用在一些电池供电的手持设备，例如家电控制模块。整个Zigbee网格网络的协调器由智能网关担当。&lt;/p&gt;
&lt;p&gt;如此设计低速无线通信方案，比较实用、经济。&lt;/p&gt;

&lt;p&gt;    作为家庭智能家居的核心，智能网关的硬件软件设计上要满足其跟功能性、扩展性的需要。&lt;/p&gt;
&lt;h2&gt;4.1　智能网关的硬件&lt;/h2&gt;
&lt;p&gt;在处理器的选择上，可以选择基于ARM的处理器芯片，集成视频/音频等处理模块，性价比较高。考虑到网关这里功能复杂，数据处理量比较大，选择支持主频512M以上。&lt;/p&gt;
&lt;p&gt;存储上选择512M DDR，256M nandflash,满足处理以及存放系统程序的需要，另外，需要SD卡插槽，可以用来存储图象等大数据量文件。&lt;/p&gt;
&lt;p&gt;对于摄像头这样的高速设备，以太网口是最佳的传输方式，因为传输稳定，传输速率高，但考虑到家庭装修的美观以及摄像头所放位置的随意，考虑WIFI来作为传输接口。Internet可以通过家用的WIFI路由器连小区网络。&lt;/p&gt;
&lt;p&gt;对于慢速无线，可以选择zigbee作为传输接口。&lt;/p&gt;
&lt;p&gt;智能网关可以作为手持设备，需要一个手触屏作为手持人机交互界面。&lt;/p&gt;
&lt;p&gt;同时需要音频，包括扬声器和话筒，可以满足远程视频通话、提示音、多媒体以及声控等方面的需要。&lt;/p&gt;
&lt;p&gt;电源可以使用外接5V适配器供电。&lt;/p&gt;
&lt;h2&gt;4.2　Linux&lt;/h2&gt;
&lt;p&gt;随着信息技术的发展，Linux使用的场合也越来越多。&lt;/p&gt;
&lt;p&gt;Linux的源代码公开，任何人都可以去下载不同版本的Linux源码，并可以对源码做任意的修改，又因为Linux是目前对于目前对POSIX支持最完备的操作系统，很多代码可以直接在UNIX和Linux之间移植，所以Linux成为了目前世界上除了PC机领域之外使用最广泛的操作系统之一。做为一种重要的操作系统，Linux已经被移植到约20个不同的体系结构，至少支持几百种不同的处理器芯片。服务器领域和嵌入式领域里Linux占据着不可替代的位置。&lt;/p&gt;
&lt;p&gt;在嵌入式领域里，无论是高端市场，还是低端市场，Linux都是作为主流甚至首选通用操作系统而存在。Linux的背后是强大的开源支持，大多数的需求都可以在这些开源支持里找到支持方案。选择Linux还在于其操作系统的强扩展性，新的功能/新的任务可以通过进程的方式临时运行，其镜象只是文件系统上的一组文件，软件升级可能只需要复制几个文件即可。再加上Linux自带的一些强大工具，包括shell/awk/sed等脚本解释工具，以及其他对于网络/文件系统/操作系统设置等方面支持的很多系统的工具，使得项目的设计可以非常灵活。&lt;/p&gt;
&lt;p&gt;作为上层的应用来说，Linux越来越成为大型服务器的首选，而世界各大公司的支持使得Linux非常稳定。&lt;/p&gt;
&lt;p&gt;对于智能网关，因为其功能多样性，需要一个灵活的操作系统作其核心，再者智能家居所提的服务可扩展性的，任何时候都可以加入一个新的设备/新的服务到智能家居系统之中，智能网关在家庭智能家居中充当服务器以及在小区网络中承上启下的角色，使用Linux是适合的。&lt;/p&gt;
&lt;p&gt;而其他广泛应用的通用嵌入式操作系统，Andorid主要用于手机这样的终端手持设备，而winCE则要有版权费用，并且开放的资源不如Linux这么多。&lt;/p&gt;
&lt;h2&gt;4.3　人机交互界面&lt;/h2&gt;
&lt;p&gt;智能网关需要提供人机交互界面，让使用者可以控制整个系统。对于一个成熟的家用产品，面向一般客户群体，美观、易用是设计人机界面的时候需要慎重考虑的。&lt;/p&gt;
&lt;p&gt;人机界面主要包含LCD屏幕显示控制和网络远程访问。&lt;/p&gt;
&lt;p&gt;LCD屏幕显示控制属于图形界面。Linux下对于图形界面的支持比较常用的是X架构，但X架构比较庞大，结构比较复杂，资源开销大，不适合嵌入式的开发。一般对于嵌入式的图形界面开发，可以采用挪威TrollTech 公司出品的QT库来进行开发，这是一个跨平台的图形界面库，支持很多种不同的平台。同时需要考虑多媒体的支持，以满足用户娱乐方面的需要。&lt;/p&gt;
&lt;p&gt;远程访问可以采用web方式，而现在，无论PC机/手机/PAD/掌上电脑等，都带有访问web服务用的浏览器。这样远程控制的时候无需自定义应用层协议，更无需为不同的设备编写不同的客户端软件，只要设备中有浏览器并可以接入网络，就可以远程访问智能网关提供的服务，使用很方便。Linux下有各种不同的web服务器可以选择，包括Apache、Boa、Lighttpd等，Apache功能强大，但一般用来做大型网站，Boa是单线程服务器，很轻型，相对Apache来说更适合作为智能网关的web服务器。内部配置等可以用小型数据库sqlite3，更加适合嵌入式环境。&lt;/p&gt;
&lt;h2&gt;4.4　下层通信程序&lt;/h2&gt;
&lt;p&gt;软件设计的时候可以采用人机交互与具体功能实现逻辑分开。具体功能实现与人机交互程序之间采用进程间通信（IPC）来交互。这样结构比较清晰，架构容易扩展。&lt;/p&gt;
&lt;p&gt;智能网关的软件关系如下：&lt;/p&gt;
&lt;p&gt;                       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1151747/201803/1151747-20180301201136152-325259578.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                  图3 智能网关软件结构&lt;/p&gt;
&lt;p&gt;                     Fig.3 the structure of intelligent gateway software&lt;/p&gt;
&lt;h2&gt;4.5　语音识别&lt;/h2&gt;
&lt;p&gt;人类自然语言是天然的人机交互手段，使用语言作为交互接口可以使得人机交互更加方便/人性化。&lt;/p&gt;
&lt;p&gt;语音识别从属模式识别，采用信号处理手段实现，一般采用提取高频信号作为语音的特征，然后再进行模糊匹配，得到各个音节等，然后再进行语法分析/文字匹配来取得最终的意思。&lt;/p&gt;
&lt;p&gt;目前语音识别技术发展很迅速，技术已经十分成熟，世面上早已存在多款应用于手机的语音识别程序。可以考虑把语音识别系统加入到智能网关中，方便使用。&lt;/p&gt;

&lt;p&gt;小区网络的作用是为了用户可以真正意义上通过Interner实现远程访问。&lt;/p&gt;
&lt;p&gt;小区架构开篇的时候已经提到，在这里，小区内所有家庭的智能家居都作为一个节点接入到小区网络，这个小区网络构成一个局域网，每个智能家居都在这个局域网中有一个唯一的IP地址，而小区网关则作为一个连接外部Internet和内部。&lt;/p&gt;
&lt;p&gt;考虑到Internet访问，对于之前提到的智能网关的设计里提到智能网关采用web界面,当通过小区网关连上Internet网络,一样可以采用web界面。智能网关在这里为每个家庭智能家居的IP地址配备一个账号和密码，当用户输入相应的帐号和密码之后，智能网关可以使用http代理服务器把web服务转接到相应的智能家居上。&lt;/p&gt;
&lt;p&gt;小区网关同时也可以与物业绑定在一起，对内支持小区的各种服务，包括电影、电视剧的播放，小区的建设规划提醒，各种费用的电子账单，以及提供购物、送货等服务。&lt;/p&gt;
&lt;p&gt;另外，对于通信服务，小区网关也可以为小区之内的用户乃至Internet上互相之间视频电话建立桥梁。&lt;/p&gt;

&lt;p&gt;    智能家居目前在国际上尚未达成一致共识，不存在任何标准性的规定，不同的公司有自己设计智能家居的思路与实现。换句话说，目前还尚处于智能家居概念形成的时间。&lt;/p&gt;
&lt;p&gt;概念形成的过程有其好处，可以逐渐淘汰掉一些对于用户实际需求关系不密切的功能，越到以后，越会贴近用户的实际使用需要。时机成熟的时候，可以制定这一行业的系统标准化。&lt;/p&gt;
&lt;p&gt;标准化可以包含如下的几点：&lt;/p&gt;
&lt;p&gt;智能家居的概念意义:定义智能家居所涵盖的范围,对于家居生活的实际意义所在。&lt;/p&gt;
&lt;p&gt;智能家居实现的系统拓扑架构:制定智能家居用于Internet所使用的系统拓扑，制定拓扑结构中每一层的意义。&lt;/p&gt;
&lt;p&gt;智能家居所使用的通信方式：制定包括各个拓扑层次之间的通信方式，包括物理层/链路层/网络层。&lt;/p&gt;
&lt;p&gt;智能家居通信中所使用的应用层通信协议：制定包括智能家居内部节点与网关之间的应用通信协议。&lt;/p&gt;
&lt;p&gt;智能家居所提供的系统配置扩展性要求：制定可以灵活的添加智能家居配置的文件以及添加方式等扩展接口定义。&lt;/p&gt;
&lt;p&gt;而包括硬件参数、设备外形、所使用操作系统等则无需做规定，但可以在标准中建议。这样有助于系统实现的灵活性，因为集成电路技术的不断进步，嵌入式操作系统的多样化，如果标准中规定的太死对于智能家居发展不利。&lt;/p&gt;
&lt;p&gt;定义标准的好处在于对于所有的智能家居厂商有个行为标准，从而可以使得不同的智能家居产品之间接口兼容，可以灵活替换，在这样的基础之上，智能家居这个大市场可以有更多的选择余地。理想下，小区在智能家居市场中选择智能家居产品可以如同像在电子市场选择不同的器件那样自由灵活，选构系统中的不同厂商的不同配件就可以配套成一个完整的智能家居解决方案。&lt;/p&gt;
&lt;p&gt;其中系统配置扩展性的标准化也可以应用于家电厂商，如果家电厂商需要把某个新产品加入到智能家居中应用，也可以按照标准扩展接口定义为该新产品定制一个。自然，对于实现扩展，智能网关需要自带一个扩展接口的解释器，支持动态加载新的家居配置到系统服务中。&lt;/p&gt;

&lt;p&gt;    智能家居是为了提供给使用者舒适方便的家居服务，易用性、智能化是其核心意义所在。智能家居在系统的实现之后，可以再考虑整合不同的服务，引入人工智能，根据使用者的习惯而自动选择家居服务，更加方便的满足使用者的需要。神经元网络是目前比较成熟的人工智能模型，可以以此为基础发展出合适的人工智能实现手段。&lt;/p&gt;

&lt;p&gt;    智能家居系统采用小区网关、智能网关、应用节点三层架构是合理的。小区网关提供Internet接入，可以使用PC机、手机、PAD的各种设备从Internet上接入到智能网关提供的web服务。智能网关和节点之间采用WIFI、Zigbee通信，从而可以控制到各个节电，满足家居的要求。在智能家居发展了一段历程之后，为智能网关制定行业标准可以使得此行业更加规范化，并可以灵活的加入任意厂家的家电、通信设备、家居设备到智能家居系统中来。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Mar 2018 12:21:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/8490423.html</dc:identifier>
</item>
<item>
<title>基于netty框架的Socket传输 - 我心自在</title>
<link>http://www.cnblogs.com/10158wsj/p/8428347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/10158wsj/p/8428347.html</guid>
<description>&lt;p&gt;什么是netty？先看下百度百科的解释：&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;7.258064516129&quot;&gt;        Netty是由&lt;a href=&quot;https://baike.baidu.com/item/JBOSS&quot; target=&quot;_blank&quot;&gt;JBOSS&lt;/a&gt;提供的一个&lt;a href=&quot;https://baike.baidu.com/item/java%E5%BC%80%E6%BA%90&quot; target=&quot;_blank&quot;&gt;java开源&lt;/a&gt;框架。Netty提供异步的、&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8&quot; target=&quot;_blank&quot;&gt;事件驱动&lt;/a&gt;的网络应用程序框架和工具，用以快速开发高性能、高可靠性的&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8&quot; target=&quot;_blank&quot;&gt;网络服务器&lt;/a&gt;和客户端程序。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.690625&quot;&gt;也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF&quot; target=&quot;_blank&quot;&gt;服务端&lt;/a&gt;应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。&lt;/div&gt;
&lt;p&gt;       “快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性&lt;/p&gt;
&lt;p&gt;为什么好多大公司都在使用netty框架？主要是基于netty框架的以下几个特点决定的：&lt;/p&gt;
&lt;p&gt;1）健壮性，2）功能齐全，3）可定制，4）扩展性&lt;/p&gt;
&lt;h2&gt;二、框架优点&lt;/h2&gt;
&lt;p&gt;       传统的RPC性能差，主要是由于客户端和远程调用采用了同步阻塞IO线程，当客户端的并发压力增大后，同步阻塞会由于频繁的等待导致I/O线程堵塞，线程无法高效的工作，IO处理能力自然会降低。影响性能的三个因素：第一，IO模型，IO模型在一定程度上决定了框架的性能。第二、协议，如：HTTP、TCP/IP等，协议选择的不同，性能模型也不同，通常情况下，内部私有协议的性能比较优，这是由于内部设计决定的。第三、线程，数据报文的接收、读取、编码、解码等，线程模型的不同，性能也不同。相比于传统的RPC框架，netty的优点主要体现在以下几个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;API使用简单，封装非常完善，开发门槛低&lt;/li&gt;
&lt;li&gt;功能上强大，预置了多种编码解码功能，多种协议支持&lt;/li&gt;
&lt;li&gt;定制能力强，可以对ChannelHandler对通信框架灵活扩展&lt;/li&gt;
&lt;li&gt;性能高，Reactor线程模型调度，ChannelFuture－Listener，通过Listener机制主动推送结果&lt;/li&gt;
&lt;li&gt;版本成熟稳定，社区活跃，版本更新快，出现的Bug会被很快的修复，同时，有心功能的加入，经历了大规模的商业应用考验，质量的到了充分的验证。已经广泛应用到互联网、大数据、企业应用、电信软件、网络游戏等热门行业，他可以满足不同的商业标准。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;三、Netty架构分析&lt;/h2&gt;
&lt;p&gt;         Netty是一个基于三层网络架构模型的框架，三层网络架构分析包括调度层、链条传递层以及业务逻辑层。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Reactor通信调度层，是一个模型，&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;NIO线程池组件{&lt;/p&gt;
&lt;p&gt;        监听网络读写连接&lt;/p&gt;
&lt;p&gt;        业务调度处理&lt;/p&gt;
&lt;p&gt;NIO，AIO，配合NIO通道NioSocketChannel组件&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;        Netty通过内部select巡查机制，能够实现IO多路复用，通过把多个IO阻塞复用到同一个select的阻塞上，从而能够使系统即使在单线程的情况下，也能够同时处理多个请求。这样就使得netty实现了IO多路复用的优势，与传统多线程相比，大大减少了系统的开销，因为系统不必创建新的线程和销毁线程了，减少了系统的维护难度，节省了资源。&lt;/p&gt;
&lt;p&gt;ByteBuffer池化支持，不用手动切换标志位，实现零拷贝。传统的Socket读写，基本是使用堆内存进行，即jvm事先会把堆内存拷贝到内存中，然后再写入Socket，而netty采用的是DIRECT BUFFERS，不需要经过jvm内存拷贝，在堆外内存直接进行Socket读写，这样就少了一次缓冲区的内存拷贝，从而实现零拷贝。&lt;/p&gt;
&lt;p&gt;       2.Pipleline职责链条传递&lt;/p&gt;
&lt;p&gt;       拦截处理向前向后事件，外部传入的消息包对象，有POJO信息抽象，上层也只需要处理逻辑，类似SpringIOC处理BeanDefince。不同的Handler节点的功能也不同，通常情况下需要编码解码等，它可以完成外部协议到内部POJO对象的转化，这样上层只需要关注业务逻辑，不需要知道底层的协议和线程模型，从而实现解耦。&lt;/p&gt;
&lt;p&gt;      3.构建逻辑业务处理单元&lt;/p&gt;
&lt;p&gt;       底层的协议隔离，上层处理逻辑框架并不需要关心底层协议是什么。Netty框架的分层设计使得开发人员不需要关注协议框架的实现，只需要关注服务层的业务逻辑开发即可，实现了简单化。&lt;/p&gt;
&lt;p&gt;       之前有个项目是基于传统Socket和线程池的技术实现的，但是在高并发的时候发现并发能力不足，压测的时候发现TPS达不到理想值，所以经过考虑，决定使用netty框架来解决此问题。同样，netty框架也分为客户端和服务端，经过整理，先写一个demo初探netty框架，下面是代码的实现过程。&lt;/p&gt;
&lt;p&gt;首先是服务端，服务端包含两个方面，第一、服务端Server的主要作用就是通过辅助引导程序，设置NIO的连接方式处理客户端请求，通过绑定特定端口、设定解码方式以及监听来实现整个线程的处理请求；第二、服务端Handler需要继承ChannelInboundHandlerAdapter类，handler类的主要作用是读取客户端数据，处理业务，抛出异常，响应客户端请求。代码如下：&lt;/p&gt;
&lt;p&gt;服务端Server：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_cd51ef47-e50b-405c-86d9-a83f3bd5e3e8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cd51ef47-e50b-405c-86d9-a83f3bd5e3e8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cd51ef47-e50b-405c-86d9-a83f3bd5e3e8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Server {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger = LogFactory.getLog(Server.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Server(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; port) {

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.port =&lt;span&gt; port;

}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start(){

        ServerBootstrap b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引导辅助程序&lt;/span&gt;
&lt;span&gt;
        EventLoopGroup group &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过nio方式来接收连接和处理请求&lt;/span&gt;

        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

               b.group(group);

               b.channel(NioServerSocketChannel.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置nio类型的channnel&lt;/span&gt;
&lt;span&gt;
               b.localAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InetSocketAddress(port));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置监听端口

               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b.option(ChannelOption.SO_BACKLOG, 2048);&lt;/span&gt;
&lt;span&gt;
               b.childHandler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有连接到达时会创建一个channel&lt;/span&gt;
&lt;span&gt;
                      @Override

                      &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册handler&lt;/span&gt;
&lt;span&gt;
                             ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayDecoder());

                             ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayEncoder());

                             ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StringEncoder(Charset.forName(&quot;UTF-8&quot;&lt;span&gt;)));

                             ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerHandler());

                            

                      }

               });&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.option(ChannelOption.SO_BACKLOG, 2048).childOption(ChannelOption.SO_KEEPALIVE, true);&lt;/span&gt;
&lt;span&gt;
               ChannelFuture f &lt;/span&gt;= b.bind().sync();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置完成,开始绑定server,通过调用sync同步方法阻塞直到绑定成功&lt;/span&gt;
&lt;span&gt;
               logger.info(Server.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getName()+&quot;开始监听：&quot;+&lt;span&gt;f.channel().localAddress());

               f.channel().closeFuture().sync();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用程序会一直等待直到channel关闭&lt;/span&gt;
&lt;span&gt;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {

               e.printStackTrace();

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {

               &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭EventLoopGroup,释放掉所有资源包括创建的线程&lt;/span&gt;
&lt;span&gt;
                      group.shutdownGracefully().sync();

               } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {

                      e.printStackTrace();

               }

        }

}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;服务端Handler &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_e43d0edc-3aad-446c-b96f-7da35585480e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e43d0edc-3aad-446c-b96f-7da35585480e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e43d0edc-3aad-446c-b96f-7da35585480e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServerHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelInboundHandlerAdapter {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=LogFactory.getLog(ServerHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; channelActive(ChannelHandlerContext ctx){

        logger.info(ctx.channel().localAddress().toString()&lt;/span&gt;+&quot;通道活跃....&quot;&lt;span&gt;);

}

@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelInactive(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        logger.error(ctx.channel().localAddress().toString()&lt;/span&gt;+&quot;通道不活跃....&quot;&lt;span&gt;);

}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;

 *

 * 读取客户端传过来的消息

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务处理类&lt;/span&gt;
&lt;span&gt;
        logger.info(&lt;/span&gt;&quot;开始业务处理....&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketController(ctx,msg).run();

}

@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出现异常，关闭连&lt;/span&gt;
&lt;span&gt;
        logger.error(&lt;/span&gt;&quot;服务端出现异常：&quot;+&lt;span&gt;cause.getMessage(),cause);

        ctx.close();

}

@Override

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelReadComplete(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        logger.info(&lt;/span&gt;&quot;服务端完成请求!&quot;&lt;span&gt;);

        ctx.flush();

}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;客户端代码&lt;/p&gt;
&lt;p&gt;    客户端主要是用来向服务端发送数据，同样包含两个方面，第一、Client主要通过设定端口和IP和服务器建立连接，进行数据包的编码；第二、ClientHandler 需要继承 SimpleChannelInboundHandler&amp;lt;ByteBuf&amp;gt;类，针对不同的传输方式，继承不同的类，handler类同样处理业务请求，响应服务端的请求。代码如下：&lt;/p&gt;
&lt;p&gt;客户端Client：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ce8276f7-d2ca-40b0-a66e-0d616d8ddff4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce8276f7-d2ca-40b0-a66e-0d616d8ddff4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce8276f7-d2ca-40b0-a66e-0d616d8ddff4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=LogFactory.getLog(Client.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String host;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Client(String host, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.host =&lt;span&gt; host;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.port =&lt;span&gt; port;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; connect(){
        EventLoopGroup workGroup&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
        Bootstrap bootstrap&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bootstrap();
        bootstrap.group(workGroup);
        bootstrap.channel(NioSocketChannel.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        bootstrap.option(ChannelOption.SO_KEEPALIVE, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        bootstrap.handler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel ch) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                logger.info(&lt;/span&gt;&quot;客户端触发连接......&quot;&lt;span&gt;);
                ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StringEncoder(Charset.forName(&quot;UTF-8&quot;&lt;span&gt;)));
                ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientHandler());
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端开始连接&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            logger.info(&lt;/span&gt;&quot;连接到服务器......&quot;&lt;span&gt;);
            ChannelFuture future&lt;/span&gt;=&lt;span&gt;bootstrap.connect(host,port).sync();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待连接关闭&lt;/span&gt;
&lt;span&gt;            future.channel().closeFuture().sync();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            workGroup.shutdownGracefully();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;客户端Handler：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c1292ad1-c1de-44c4-9ba3-609cf564584f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c1292ad1-c1de-44c4-9ba3-609cf564584f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c1292ad1-c1de-44c4-9ba3-609cf564584f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientHandler &lt;span&gt;extends&lt;/span&gt; SimpleChannelInboundHandler&amp;lt;ByteBuf&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=LogFactory.getLog(ClientHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向服务端发送消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelActive(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.info(ctx.channel().localAddress().toString()&lt;/span&gt;+&quot;客户点活跃...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务端写字符串&lt;/span&gt;
        logger.info(&quot;客户端连接服务端,开始发送数据.....&quot;&lt;span&gt;);
        String string &lt;/span&gt;=&quot;hello server！&quot;&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;发送数据为：&quot;+&lt;span&gt;string);
        ByteBuf buf&lt;/span&gt;=ctx.alloc().buffer(4*&lt;span&gt;string.length());
        buf.writeBytes(string.getBytes());
        ctx.writeAndFlush(buf);
        logger.info(&lt;/span&gt;&quot;发送完毕...&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 读取服务端返回来的消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead0(ChannelHandlerContext arg0, ByteBuf in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.info(&lt;/span&gt;&quot;开始接受服务端数据&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[in.readableBytes()];
        in.readBytes(b);
        String string&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(b);
        logger.info(&lt;/span&gt;&quot;服务端发送的数据为：&quot;+&lt;span&gt;string);
        in.release();
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.info(&lt;/span&gt;&quot;客户端异常：&quot;+&lt;span&gt;cause.getMessage(),cause);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelReadComplete(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.info(&lt;/span&gt;&quot;客户端完成请求....&quot;&lt;span&gt;);
        ctx.flush();    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;服务端启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_5824b7e6-4615-40fa-8772-1d261bb18443&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5824b7e6-4615-40fa-8772-1d261bb18443&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5824b7e6-4615-40fa-8772-1d261bb18443&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServerMain {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Log logger=LogFactory.getLog(ServerMain.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Server server =&lt;span&gt;new&lt;/span&gt; Server(55550&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        logger.info(&lt;/span&gt;&quot;服务端启动.......&quot;&lt;span&gt;);

        server.start();

}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;客户端启动类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2bf4da37-d915-4dab-a393-5453b1f94d0e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2bf4da37-d915-4dab-a393-5453b1f94d0e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2bf4da37-d915-4dab-a393-5453b1f94d0e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Client client = &lt;span&gt;new&lt;/span&gt; Client(&quot;127.0.0.1&quot;, 55550&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnknownHostException, IOException {

        client.connect();

}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;服务端：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1153367/201802/1153367-20180207203009623-782676397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1153367/201802/1153367-20180207203022904-1355087737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;       以上只是一个netty框架初探的小Demo，学习使用netty框架的开始，这里面涉及到了很多的技术以及非常多的组件，比如：Channels、Callbacks、Futures、Events和handlers等等，需要进一步的学习，另外，消息的编码解码、粘包、拆包的方式方法、消息格式的转换以及报文格式大小限制都需要进一步的研究学习。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Mar 2018 12:15:00 +0000</pubDate>
<dc:creator>我心自在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/10158wsj/p/8428347.html</dc:identifier>
</item>
</channel>
</rss>