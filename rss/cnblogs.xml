<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core 已经实现了PHP JIT，现在PHP是.NET上的一门开发语言 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/8097881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/8097881.html</guid>
<description>&lt;p&gt;&lt;span&gt;12月23日，由开源中国联合中国电子技术标准化研究院主办的2017源创会年终盛典在北京万豪酒店顺利举行。在本次大会上，链家集团技术副总裁、PHP 开发组核心成员鸟哥发表了以 “ PHP Next: JIT ”为主题的演讲，分享了 PHP 的下一个性能提升的主要举措：JIT 的进展, 以及下一个大版本的 PHP 可能的特性。 具体内容请看：&lt;/span&gt; &lt;a title=&quot;https://mp.weixin.qq.com/s/bYZLJgKtdRwSX40Xixc5Yw&quot; href=&quot;https://mp.weixin.qq.com/s/bYZLJgKtdRwSX40Xixc5Yw&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/bYZLJgKtdRwSX40Xixc5Yw&lt;/span&gt;&lt;/a&gt; &lt;span&gt;，这里PHP Next  目前正在开发当中，由 Zend 的 Dmitry Stogov 主导,但实际版本号尚未定义,我暂且把它叫做PHP 8.  关键功能 JIT（Just-In-Time）编译，是一种将代码转换为另一种字节码（比如运行它的机器 CPU 的本地代码）的技术。 JIT 可以使程序运行更快。JIT 可以对现有代码提供很大的性能改进，但在某些情况下，你可能会注意到速度提高只有几个百分点，在最坏的情况下，它甚至可能会变慢，因为编译不会生成更快的代码。 我看到这篇文章内容就想起了.NET平台上的开源项目Peachpie。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Peachpie 是一个用于 .NET 平台上的的 PHP 编译器和运行时。作为 PHP 语言的完全重新实现，它允许完全使用 .NET 进行编写，并在 .NET Framework、NET Core 和 Mono 上运行 PHP。Peachpie 可以无缝利用 .NET 对象，另一方面，也可以让 C# 代码直接访问已编译的 PHP 函数、变量和类。Peachpie 项目的目标是将 PHP 代码库迁移至 .NET，从而可通过各自的 API 为 PHP 提供 .NET 和 ASP.NET 运行时。最新版本是0.8，&lt;/span&gt;&lt;a href=&quot;https://www.peachpie.io/2017/11/php-netstandard-2-0.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;支持.NET Standard 2.0&lt;/span&gt;&lt;/a&gt;&lt;span&gt;:&lt;/span&gt; &lt;a title=&quot;https://www.peachpie.io/2017/11/php-netstandard-2-0.html&quot; href=&quot;https://www.peachpie.io/2017/11/php-netstandard-2-0.html&quot;&gt;&lt;span&gt;https://www.peachpie.io/2017/11/php-netstandard-2-0.html&lt;/span&gt;&lt;/a&gt; &lt;span&gt;,Peachpie 也在PHP 7.2发布时第一时间完成支持编译PHP7.2 代码到.NET&lt;/span&gt; &lt;a title=&quot;https://www.peachpie.io/2017/12/php-7-2-on-net.html&quot; href=&quot;https://www.peachpie.io/2017/12/php-7-2-on-net.html&quot;&gt;&lt;span&gt;https://www.peachpie.io/2017/12/php-7-2-on-net.html&lt;/span&gt;&lt;/a&gt; &lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Peachpie 现在还是.NET 基金会下面的项目，具体可以看博客&lt;a title=&quot;https://www.peachpie.io/2017/07/net-foundation-announcement.html&quot; href=&quot;https://www.peachpie.io/2017/07/net-foundation-announcement.html&quot;&gt;https://www.peachpie.io/2017/07/net-foundation-announcement.html&lt;/a&gt;，目前最新版本是0.8，还没有达到在生产环境运行的1.0版本，从他的路线图 &lt;a title=&quot;https://github.com/peachpiecompiler/peachpie/wiki/Peachpie-Roadmap&quot; href=&quot;https://github.com/peachpiecompiler/peachpie/wiki/Peachpie-Roadmap&quot;&gt;https://github.com/peachpiecompiler/peachpie/wiki/Peachpie-Roadmap&lt;/a&gt; 上看已经很接近了。它的各项性能指标上也是非常的优秀 &lt;a title=&quot;https://www.peachpie.io/benchmarks&quot; href=&quot;https://www.peachpie.io/benchmarks&quot;&gt;https://www.peachpie.io/benchmarks&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Peachpie是一个基于Microsoft的&lt;strong&gt;Roslyn&lt;/strong&gt;的现代PHP编译器，并从我们广受欢迎的** Phalanger **项目中获取。它允许PHP在.NET框架内运行，从而为PHP开发人员打开了.NET的大门 - 反之亦然。&lt;/span&gt;&lt;span&gt;该项目的目标是将&lt;strong&gt;遗留的PHP代码编译成可移植的类库&lt;/strong&gt;，使开发人员能够快速，轻松地为Microsoft平台构建&lt;strong&gt;跨平台的&lt;/strong&gt;应用程序和库。直接的结果是，由Peachpie提供支持的PHP应用程序将运行在能够运行.NET的所有设备和操作系统上。&lt;/span&gt;&lt;span&gt;除了授予PHP程序员进行跨平台开发之外，Peachpie允许&lt;strong&gt;与.NET&lt;/strong&gt;完全&lt;strong&gt;兼容&lt;/strong&gt;，这使得开发混合应用程序成为可能，其中部分代码是用C＃编写的，部分用PHP编写的。这些部分将完全兼容，并且可以在.NET框架内无缝地进行通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过Peachpie 已经可以在.NET 平台上运行经典的PHP程序，例如WordPress，CodeIgniter,Drupal, MediaWiki等 。 不过还有一个 bug要修复，具体参见&lt;/span&gt;&lt;a title=&quot;https://github.com/peachpiecompiler/peachpie/issues&quot; href=&quot;https://github.com/peachpiecompiler/peachpie/issues&quot;&gt;&lt;span&gt;https://github.com/peachpiecompiler/peachpie/issues&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Peachpie&quot; src=&quot;http://gunnarpeipman.com/wp-content/uploads/2017/07/peachpie-dotnet.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们来简要体验下使用PHP写.NET程序：&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;1、安装.NET Core SDK&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;.NET Core构建并授权您的应用程序。这是一个通用，跨平台和安全的代码环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、安装Peachpie .NET模板&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们已经为您准备了通用的项目类型。他们隐藏了项目文件的所有复杂性，并附带代码示例。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;dotnet new -i Peachpie.Templates :: *&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201712/510-20171224133222943-6091383.png&quot;&gt;&lt;img width=&quot;441&quot; height=&quot;350&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201712/510-20171224133223318-542540230.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;pre&gt;
一共有三个模板：控制台，web以及类库
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;3、创建网站&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在创建该项目，该命令将创建初始解决方案所需的所有文件。&lt;code&gt;Website&lt;/code&gt;目录将包含您的PHP网站的根目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继续编辑新创建的&lt;code&gt;Website/index.php&lt;/code&gt;文件。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;dotnet new peachpie-web-lang PHP&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;a href=&quot;http://images2017.cnblogs.com/blog/510/201712/510-20171224133223506-435528734.png&quot;&gt;&lt;img width=&quot;440&quot; height=&quot;78&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/510/201712/510-20171224133223756-1271244696.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;4、运行你的项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导航到该&lt;code&gt;Server&lt;/code&gt;目录。这是Web应用程序的入口，作为PHP网站的引导程序工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些命令还原所有的依赖关系，编译项目并启动Web服务器。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;cd server&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;dotnet restore
dotnet run
&lt;/span&gt;
&lt;/pre&gt;
&lt;h5&gt;&lt;span&gt;测试你的网站&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;打开您最喜欢的网络浏览器并输入网址。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;HTTP：//localhost:5004&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
他们已经为Peachpie 上线了商业网站&lt;a title=&quot;http://www.peachpiestudio.com/&quot; href=&quot;http://www.peachpiestudio.com/&quot;&gt;http://www.peachpiestudio.com/&lt;/a&gt; ，为Peachpie的发展提供商业服务支持，你可以在Peachpie编译器平台上找到商业工具和服务，你可以通过Visual Studio/Visual studio code上进行代码的开发。
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;WordPress示例&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;Peachpie使用他们的WordPress版本作为PHP编译为.NET的一个例子。 我们来演示如何跑起来。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从  &lt;a href=&quot;https://github.com/iolevel/peachpie-wordpress&quot;&gt;https://github.com/iolevel/peachpie-wordpress&lt;/a&gt; 下载项目&lt;/li&gt;
&lt;li&gt;将文件解压到某个文件夹&lt;/li&gt;
&lt;li&gt;安装MySQL，wordpress使用mysql数据库&lt;/li&gt;
&lt;li&gt;更改wp-config.php中的数据库连接设置&lt;/li&gt;
&lt;li&gt;打开命令行并转切换到WordPress项目文件的文件夹&lt;/li&gt;
&lt;li&gt;运行以下命令：&lt;br/&gt;dotnet restore&lt;br/&gt;cd app&lt;br/&gt;dotnet run&lt;/li&gt;
&lt;li&gt;等待几分钟，直到应用程序编译并启动&lt;/li&gt;
&lt;li&gt;在您最喜爱的网页浏览器中打开http：// localhost：5004&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 24 Dec 2017 05:33:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/8097881.html</dc:identifier>
</item>
<item>
<title>webpack+babel项目在IE下报Promise未定义错误引出的思考 - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/8076453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/8076453.html</guid>
<description>&lt;h2 id=&quot;低版本浏览器引起的问题&quot;&gt;低版本浏览器引起的问题&lt;/h2&gt;
&lt;p&gt;最近开发一个基于&lt;code&gt;webpack+babel+react&lt;/code&gt;的项目，一般本地是在chrome浏览上面开发，chrome浏览器开发因为支持大部分新的js特性，所以一般不怎么需要polyfill， 比如Promise，string实例的includes方法等。即使在低版本浏览器中，通过&lt;code&gt;babel-runtime&lt;/code&gt;的polyfill也是可以转换的，但是事不竟然，项目在IE9浏览器上报错，错误如下截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/408483/201712/408483-20171224113914209-281655830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，项目中使用了&lt;code&gt;Promise&lt;/code&gt;，但是IE9又不支持该新特性，所以导致报错。&lt;/p&gt;
&lt;p&gt;那么， 问题来了，&lt;code&gt;babel-runtime&lt;/code&gt;不是会自动polyfill项目中的&lt;code&gt;Promise&lt;/code&gt;功能么，为啥没有呢？下面就来一探究竟。&lt;/p&gt;
&lt;h2 id=&quot;babel-runtime真的帮我们转换了么&quot;&gt;babel-runtime真的帮我们转换了么&lt;/h2&gt;
&lt;p&gt;按照&lt;a href=&quot;http://babeljs.io/docs/plugins/transform-runtime/#installation&quot;&gt;babel官网&lt;/a&gt;的介绍，&lt;code&gt;babel-runtime&lt;/code&gt;跟&lt;code&gt;babel-polyfill&lt;/code&gt;一样，都是对不支持的新功能进行polyfill，只是：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;babel-runtime&lt;/strong&gt;: 他不会污染全局环境，会在局部进行polyfill，另外不会转换一些实例方法，如&lt;strong&gt;'abc'.includes('a')&lt;/strong&gt;，其中的includes方法就不会翻译。它一般结合&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;来使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;babel-polyfill&lt;/strong&gt;：简单粗暴，他会污染全局环境，比如在不支持Promise的浏览器会polyfill一个全局的Promise对象供调用；另外，不支持的实例方法也在对应的构造函数原型链上添加要polyfill的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么上面例子中的Promise，babel-runtime真的帮我们转换了么，在项目中测试一下，发下它确实转换了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  let _promise = new Promise()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，在代码中测试一下，查看对应的转换文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/408483/201712/408483-20171224120241896-268828300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在项目中，&lt;code&gt;babel-runtime&lt;/code&gt;真的帮我们进行了polyfill，那为啥还会报上面的&lt;strong&gt;Promise未定义&lt;/strong&gt;的错误呢？？？&lt;/p&gt;
&lt;h2 id=&quot;promise未定义错误真凶&quot;&gt;Promise未定义错误真凶&lt;/h2&gt;
&lt;p&gt;既然&lt;code&gt;babel-runtime&lt;/code&gt;会对经过babel编译的代码进行代码转换，那么可以猜想：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;错误的真正原因是一些代码没有经过babel-runtime编译转换&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先想到的是&lt;strong&gt;node_modules&lt;/strong&gt;模块，因为一些npm包在webpack配置中不需要babel的编译，而这些包可能需要Promise的原生支持功能.&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;vuex&lt;/code&gt;，之前就有人在github上提出过类似的问题&lt;a href=&quot;https://github.com/vuejs-templates/webpack/issues/474&quot;&gt;&lt;code&gt;vuex requires a promise polyfill in this browser&lt;/code&gt;&lt;/a&gt;。因为在它源码里面是这样判断的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assert(typeof Promise !== 'undefined', &quot;vuex requires a Promise polyfill in this browser.&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的情况需要主要，经过排查，在本项目中，没有发现是因为npm包引起的。那么还有一种可能：&lt;strong&gt;webapck本身产生的一些代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过定位错误发生地方，发现确实是webpack自身产生的代码需要Promise。在webpack的官网也找到了&lt;a href=&quot;https://webpack.js.org/guides/migrating/#require-ensure-and-amd-require-are-asynchronous&quot;&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/73696/201710/73696-20171013103648887-464373239.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，在webpack使用异步加载模块时， &lt;code&gt;require.ensure&lt;/code&gt;需要原生支持Promise，因为我们项目是按需加载，所以才导致上面问题的产生。即：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;webpack生成的new Promise相关代码, 超出babel的babel-runtime的控制范围，只有polyfill全局的Promise才能解决此问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决上面的问题， 大部分人会想到使用其他Promise的polyfill库，如&lt;code&gt;babel-polyfill&lt;/code&gt;或者&lt;code&gt;es6-promise&lt;/code&gt;等，这固然是一个解决办法，但是可以结合babel-runtime的转换功能来为全局Promise进行polyfill，不会引入额外的库。代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 将Promise抛出为全局对象&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Promise&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后babel-runtime会将其转化为如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 将Promise抛出为全局对象&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Promise&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，将babel-runtime的Promise的polyfill挂到window下，达到其他Promise的polyfill的效果。&lt;/p&gt;
&lt;h2 id=&quot;在跨浏览器中的选择&quot;&gt;在跨浏览器中的选择&lt;/h2&gt;
&lt;p&gt;本人的大部分后台项目，一般会要求使用人员使用chrome浏览器，只选择&lt;code&gt;babel-runtime&lt;/code&gt;就可以满足需求，因为chrome大部分js新特性都支持，如字符串实例的&lt;strong&gt;includes&lt;/strong&gt;， 虽然babel-runtime不会编译，但是浏览器自己会支持，不会产生问题。但是对于跨浏览器的项目就需要特别考虑了。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于跨浏览器的项目，尤其是低版本的IE时，建议选择&lt;code&gt;babel-polyfill&lt;/code&gt;, 它可以对静态或者实例方法都会转换&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于指定的浏览器的项目如chrome，直接使用&lt;code&gt;babel-runtime&lt;/code&gt;来进行转换，&lt;strong&gt;它不会对实例方法进行转换&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://webpack.js.org/guides/migrating/#require-ensure-and-amd-require-are-asynchronous&quot;&gt;webpack文档&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://segmentfault.com/q/1010000005596587&quot;&gt;babel的polyfill和runtime的区别&lt;/a&gt;&lt;br/&gt;3、&lt;a href=&quot;https://github.com/ToPeas/blog/issues/2&quot;&gt;babel原理和polyfill和runtime的区别&lt;/a&gt;&lt;br/&gt;4、&lt;a href=&quot;http://www.cnblogs.com/pheye/p/7659910.html&quot;&gt;webpack+babel+transform-runtime, IE下提示Promise未定义？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 05:13:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/8076453.html</dc:identifier>
</item>
<item>
<title>ThoughtWorks 2017技术雷达 - 不负春光，努力生长</title>
<link>http://www.cnblogs.com/Wolfmanlq/p/8097663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wolfmanlq/p/8097663.html</guid>
<description>&lt;p&gt;这个雷达以独特的形式记录技术顾问委员会的讨论结果, 为从开发人员到CTO在内的各路利益相关方提供价值。这 些内容只是简要的总结,我们建议您探究这些技术以了解 更多细节。&lt;/p&gt;
&lt;p&gt;这个雷达是图形性质的,把各种技术项目归类为技术、工具、平台和语言及框架,如果某个条目可以出现在多个象 限,我们选择看起来最合适的象限。我们还进一步将这些技 术分为四个环以反映我们目前对其的态度。&lt;/p&gt;
&lt;p&gt;要了解关于雷达的更多背景,请点击:&lt;a href=&quot;https://www.%20thoughtworks.com/radar/faq%20&quot; target=&quot;_blank&quot;&gt;https://www. thoughtworks.com/radar/faq &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;关于技术：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/423536/201712/423536-20171224114338631-2078658975.png&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;439&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关解读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      很多文档都可以被高度可读的代码和测试取代。然而对于演进式架构来说，记录某些设计决策非常重要，这不仅有利于未来的团队成员理解，也有利于外部监督。&lt;span&gt;&lt;strong&gt;轻量级架构决策记录&lt;/strong&gt;&lt;/span&gt;是一种用于捕获重要的架构决策及其上下文和结果 的技术。我们建议将这些详细信息进行版本化，而不是wiki 或网站，这样所记录的内容就可以和代码保持同步。对于大 多数项目，我们没有理由不采用这种技术。&lt;/p&gt;
&lt;p&gt;      过去12个月里，我们注意到对数字化平台这个主题的关注 发生了急剧的增长。希望快速有效推出新数字解决方案的公司，正在建立内部平台，为交付团队提供自助服务，从而访问那些构建和运营自己的解决方案所必需的业务API、工 具、知识和支持。我们发现当这些平台得到跟外部产品同等的重视时，它们的效率是最高的。&lt;strong&gt;&lt;span&gt;将产品管理思维应用于内部平台&lt;/span&gt;&lt;/strong&gt;，意味着与内部消费者（开发人员）建立共情，并在设计上彼此协作。平台的产品经理要建立路线图，确保平台为业务交付价值，为开发者改善体验。一些企业甚至为内部 平台创建了品牌标识，并向同事推销平台的优势。平台产品 经理将负责平台的质量、收集使用指标，并持续改进平台。 将平台作为产品来处理，有助于创造一个蓬勃发展的生态系统，避免构建另一个停滞不前的、未充分利用的面向服务 架构。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;适应度函数借鉴自进化计算，被用来衡量方 案对满足目标的适合度。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      适应度函数借鉴自进化计算，被用来衡量方案对满足目标 的适合度。当定义演进式算法时，算法设计者会寻求更优 解，而适应度函数则定义了在此上下文中“更优”的含义。 《演进式架构》一书定义了&lt;strong&gt;&lt;span&gt;架构适应度函数&lt;/span&gt;&lt;/strong&gt;的概念，为衡量架构特征提供了一个客观全面的方法，包括已有的验证 标准，比如单元测试、业务指标、监控等等。我们相信架构 师能够验证并维持一套自动化的可持续的架构标准，这是 演进式架构的关键。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CI和CD工具可以用来测试服务配置、服务镜 像构建、环境准备以及环境的集成。（为基础设施即代码使用流水线） &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在早期的技术雷达中，我们讨论了Netflix的（Chaos Monkey）。 混沌猴可以随机终止生产系统中的运行实例，并对结果进 行度量，从而帮助验证系统在运行时对生产中断的应对能 力。今天，人们有了一个新兴术语来描述这一技术的广泛应 用：&lt;strong&gt;&lt;span&gt;混沌工程&lt;/span&gt;&lt;/strong&gt;。在生产环境的分布式系统中运行这些试验， 可以帮助我们建立系统在动荡环境下依旧能够按预期工作 的信心。如果想要更好地理解这个技术方向，请参阅&lt;a href=&quot;http://principlesofchaos.org/&quot; target=&quot;_blank&quot;&gt;混沌工程&lt;/a&gt;原则。&lt;/p&gt;
&lt;p&gt;　　受DevOps运动的启发，&lt;strong&gt;&lt;span&gt;DESIGNOPS&lt;/span&gt;&lt;/strong&gt;是一种文化上的转 变，同时包含了一系列的实践。DesignOps可以帮助组织不 断地重新设计产品，而又无需在质量、服务连贯性和团队 的自主性上妥协。DesignOps提倡创建并演进设计的基础 设施，最大限度降低创造新的UI概念及其变体的工作量， 并与最终用户建立快速且可靠的反馈机制。通过使用诸如 Storybook这样促进紧密协作的工具，对前期分析和规范交 接的需求可以被降至最低。使用DesignOps，设计正在从一 种具体的实践演变成每个人工作的一部分。&lt;/p&gt;
&lt;p&gt;      我们已经从引入&lt;a href=&quot;https://www.thoughtworks.com/radar/techniques/microservices&quot; target=&quot;_blank&quot;&gt;微服务架构&lt;/a&gt;中获得了明显的好处，微服务 架构可以让团队裁剪出独立部署的交付物以及可维护的服务。不幸的是，我们还看到许多团队在后端服务之上创建了 前端单体——一个单一，庞大和杂乱无绪的浏览器应用。我 们首选的（经过验证的）方法是将基于浏览器的代码拆分成 &lt;strong&gt;&lt;span&gt;微前端&lt;/span&gt;&lt;/strong&gt;。在这种方法中，Web应用程序被分解为多个特性， 每个特性都由不同的前后端团队拥有。这确保每个特性都 独立于其他特性开发，测试和部署。这样可以使用多种技术 来重新组合特性——有时候是页面，有时候是组件——最终 整合成一个内聚的用户体验。&lt;/p&gt;
&lt;p&gt;      使用持续交付流水线来编排软件的发布流程，已经成为了 主流概念。不过，对基础设施代码进行自动化测试还没有被 广泛理解。CI和CD工具可以用来测试服务配置（如Chef的 cookbook，Puppet的模块，Ansible的playbook）、服务镜像 构建（如Packer）、环境准备（Terraform，CloudFormation 等）以及环境的集成。对&lt;strong&gt;&lt;span&gt;基础设施即代码使用流水线&lt;/span&gt;&lt;/strong&gt;可以让 错误在进入运维环境，包括开发和测试环境之前就被发现。 这些流水线还能确保基础设施工具能始终如一地运行在CI / CD的Agent上，而不是在特定的工作站上。挑战仍然存在，比 如与容器和虚拟机相关的更长的反馈周期，但我们认为这是 一个有价值的技术。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;无服务器架构&lt;/span&gt;&lt;/strong&gt;迅速得到了需要部署云端应用的组织的认 可，并且有着大量可供选择的部署方式。即便是相对传统 和保守的组织，也在使用一部分无服务器技术。虽然可以 使用的合适的模式仍在不断涌现，但大多数时候我们的讨 论都会走向函数即服务(Functions as a Service)（例 如 AWS Lambda，Google Cloud Functions，Azure Functions）。部署无服务器函数毫无疑问能够减少大量传 统方式特有的，涉及服务器和操作系统配置和编排的工作 量。然而serverless也并不是百试不爽的万金油。当前这个 阶段，因为一些特别的需求，你必须做好能回退至容器化， 甚至是实例化部署的准备。与此同时，无服务器架构的其他 组件，比如后端即服务（Backend as a Service），几乎成为 了默认的选择。&lt;/p&gt;
&lt;p&gt;      因为测试驱动开发自身的优势，许多开发团队会在编写代 码时采用这一实践。也有一些团队开始使用容器来打包和部署软件，而通过自动化脚本来构建容器已经是被广为接受的实践。但迄今为止，我们很少看到有团队能将这 两种趋势结合，通过测试来驱动容器脚本的编写。借助 ServerSpec和Goss这样的框架，你可以为独立的或编排 的容器呈现预期的功能，并得到快速反馈。这意味着我们 可以寻求用&lt;strong&gt;&lt;span&gt;TDD开发容器脚本&lt;/span&gt;&lt;/strong&gt;。我们在这方面得到的初步体验是十分积极的。 &lt;/p&gt;
&lt;p&gt;      近年来IT运维所收集到的数据量一直在增加。例如，微服 务的迅速发展意味着更多的应用程序正在生成自己的操作 数据；而像Splunk，Prometheus或ELK堆栈这样的工具让 数据存储和后续处理变得更容易，从而获得运营洞见。毋庸 置疑，随着机器学习工具的普及，运营人员已经开始将统计 模型和经过训练的分类算法纳入其工具包中。虽然这些算 法并不新颖，而且人们已经进行了各种尝试来自动化服务管 理，但是在了解机器和人员如何协作以便早期识别异常和确 定故障来源这个方向，我们还是先行者。尽管&lt;strong&gt;&lt;span&gt;基于算法的IT运维（Algorithmic IT Operations）&lt;/span&gt;&lt;/strong&gt;有过度炒作的风险， 但毫无疑问，机器学习算法的稳步提升将改变未来的数据 中心运营中人类所起到的作用。&lt;/p&gt;
&lt;p&gt;      在银行、数字货币、供应链透明化等多个金融科技领域，区 块链技术已经被炒作成“灵丹妙药”。我们曾经在过去的雷 达中推荐过带有智能合约功能的Ethereum，而最近已经看 到&lt;strong&gt;&lt;span&gt;Ethereum在去中心化应用&lt;/span&gt;&lt;/strong&gt;的其他领域中得到更多的发展。尽管这一技术非常年轻，我们仍然鼓励你在加密货币和 银行之外的领域，使用它构建去中心化应用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在银行、数字货币、供应链透明化等多个金 融科技领域，区块链技术已经被炒作成“灵 丹妙药”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       随着事件流（event streaming）平台（如Apache Kafka）的 兴起，很多人将它们视为消息队列的高级形态，仅用来传输 事件。即便按这种方式使用，事件流仍然具有传统消息队列 无法比拟的优势。然而我们更感兴趣的是，人们如何通过 把平台（特别是Kafka）作为主要存储，把数据保存为不可 变事件，从而&lt;span&gt;&lt;strong&gt;将事件流作为正确数据之源&lt;/strong&gt;&lt;/span&gt;。例如，以Event Sourcing方式设计的服务，可以使用Kafka作为事件存储工 具（event store），其他服务可以消费这些事件。这一技术能 够减少本地持久化和集成之间的重复工作。&lt;/p&gt;
&lt;p&gt;      主要的云服务提供商(Amazon、Microsoft和Google)正 陷入一场激烈的竞争中，以保持核心能力的均势，虽然 他们的产品只是略有差异。这导致一些组织采用&lt;strong&gt;&lt;span&gt;多云 （POLYCLOUD）策略&lt;/span&gt;&lt;/strong&gt;，而不是与一个提供商“全面”合作， 他们正在以最佳组合的方式，将不同类型的工作负载交由不 同的供应商。例如，这可能包括将标准服务放在AWS上，使 用Google进行机器学习，把采用SQL Server的.NET程序部 署在Azure，或者可能使用Ethereum Consortium的区块链 解决方案。这并不等同于致力于供应商间可移植性的“跨云 策略”，后者价格昂贵且会导致迎合大众的想法。多云策略 则专注于使用每个云能提供的最好的服务。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 服务啮合(service mesh)在服务发现、安全、 跟踪、监控与故障处理方面提供了一致性，且 不需要像API网关或ESB这样的共享资产。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      现在越来越多的大型组织在向更加自组织的团队结构转 型，这些团队拥有并运营自己的微服务，但他们如何在不依 赖集中式托管的基础架构下，确保服务之间必要的一致性与 兼容性呢？为了确保服务之间的有效协作，即使是自组织的 微服务也需要与一些组织标准对齐。&lt;strong&gt;&lt;span&gt;服务啮合(SERVICE MESH)&lt;/span&gt;&lt;/strong&gt;在服务发现、安全、跟踪、监控与故障处理方面提供 了一致性，且不需要像API网关或ESB这样的共享资产。服务 啮合的一个典型实现包含轻量级反向代理进程，这些进程 可能伴随每个服务进程一起被部署在单独的容器中。反向 代理会和服务注册表、身份提供者和日志聚合器等进行通 信。通过该代理的共享实现（而非共享的运行时实例），我 们可以获得服务的互操作性和可观测性。一段时间以来，我 们一直主张去中心化的微服务管理方法，也很高兴看到服务 啮合这种一致性模式的出现。随着linkerd和Istio等开源项 目的成熟，服务啮合的实现将更加容易。&lt;/p&gt;
&lt;p&gt;      微服务架构中，众多服务将其资产和功能都通过API暴露出 来，同时也扩大了系统的被攻击面。因此一个零信任—— “永不信任，始终验证”的安全架构势在必行。然而，由于 服务代码复杂性的增加以及在多语言环境中缺少库和语言 的支持，服务之间的安全控制往往会被忽略。为了解决这 个复杂性，我们已经看到将安全性委托给进程外Sidecar的 做法，Sidecar是一个独立的进程或一个容器，它与每个服 务一起部署和调度，并共享相同的执行上下文、主机和身 份。Sidecar实现了安全功能，如对服务间的通信作透明加 密、TLS终止，以及对调用方服务或最终用户的鉴权机制。在 实现自己的&lt;strong&gt;&lt;span&gt;用于端点安全的SIDECAR&lt;/span&gt;&lt;/strong&gt;之前，我们推荐你先 研究一下Istio、linkerd或者Envoy。&lt;/p&gt;
&lt;p&gt;      传统的企业安全方法往往强调锁定事物并减慢变革的步 伐。但众所周知，攻击者对系统实施攻击的时间越长，造成 的损失也就越大。3Rs企业安全：轮换、修复、重建，利用基 础设施自动化和持续交付来消除攻击机会。轮换凭证，一旦 有可用的补丁就立即应用补丁，并且在几分钟或几小时内完 成从已知的安全状态重建系统，这会使攻击者更难获得立 足点。随着现代原生云架构的出现，&lt;strong&gt;&lt;span&gt;3RS安全&lt;/span&gt;&lt;/strong&gt;技术变得可 行。当应用程序部署为容器，并通过完全自动化的流水线进 行构建和测试时，安全补丁只不过是又一次通过一个点击， 就可以通过流水线发布的小版本而已。当然，为了保持良 好的分布式系统实践，开发人员需要设计应用以适应意外 的服务器中断。这就和在环境中实施混沌猴所造成的影响 相似。&lt;/p&gt;
&lt;p&gt;      Kafka已经是流行的消息解决方案，同时，Kafka Streams也 站到了流式架构的最前沿。不幸的是，随着人们将Kafka作 为数据和应用平台的核心，我们看到一些组织没有将Kafka 的生态组件（如连接器、流处理器等）按产品和服务团队划 分，而是将它们集中管制，这用&lt;strong&gt;&lt;span&gt;KAFKA重现了ESB反模式&lt;/span&gt;&lt;/strong&gt;。 这一反模式具有很严重的问题，过多的逻辑、编排、转换被 插入到集中管理的ESB中，使得系统严重依赖于一支中心化 团队。我们特此提出这个问题，希望劝阻这种反模式的更多 实现。&lt;/p&gt;
&lt;h2&gt;关于平台：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/423536/201712/423536-20171224120543256-1158336269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内容解读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      自我们上次在技术雷达中提到&lt;strong&gt;&lt;span&gt;KUBERNETES&lt;/span&gt;&lt;/strong&gt;至今，它已经 成为我们大部分客户将容器部署到服务器集群的默认解决 方案。而能替代它的其他产品不但没有获得如此的客户认 同度，甚至在某些场景中，我们的客户会将他们的“引擎” 都更换成 Kubernetes。Kubernetes已经成为主流公有云平 台上的首选容器编排平台。这些主流公有云平台包括微软的 Azure 容器服务以及 Google Cloud（参见GKE）。此外市面上 还有很多好用的产品，来不断丰富快速扩大的Kubernetes 生态圈。与此同时，那些试图用一层抽象将Kubernetes隐藏 起来的平台尚未成功地证明自己的价值。&lt;/p&gt;
&lt;p&gt;      作为一个开源的跨平台软件开发框架，&lt;strong&gt;&lt;span&gt;.NET CORE&lt;/span&gt;&lt;/strong&gt;被 越来越多地运用到实际项目中。该框架令 .NET 应用能在 Windows、macOS 以及 Linux 系统上进行开发和部 署。.NET Standard 2.0 的发布增加了跨多个 .NET 平台的标准 API 的数量，这使得往.NET Core迁移的路径变得更为 清晰。有关.NET Core对其上类库的支持性问题正在逐渐减 少。一流的跨平台工具已经涌现出来，用于在非 Windows 平台上进行高效的开发工作。运用Docker镜像，能让.NET Core 服务可以轻松地集成到容器环境中。其社区发展的积 极方向以及来自我们实际项目的反馈，都表明.NET Core现 在已经可以广泛地运用了。&lt;/p&gt;
&lt;p&gt;      随着Gatling和Locust等工具的日益成熟，压力测试变得越 来越容易。与此同时，弹性云平台基础设施可以模拟大量客 户端实例来进行压力测试。我们欣喜地看到像 Flood IO 这 样的云平台能越来越深入地应用此类技术。&lt;strong&gt;&lt;span&gt;FLOOD IO&lt;/span&gt;&lt;/strong&gt;是一个基于SaaS的压力测试服务。它可以用来向数百台云端 服务器分发测试脚本并在其上执行。我们的团队发现，通过 重用现有的Gatling测试脚本能很简单地将性能测试迁移到 Flood IO。&lt;/p&gt;
&lt;p&gt;      随着&lt;strong&gt;&lt;span&gt;GOOGLE CLOUD PLATFORM（GCP）&lt;/span&gt;&lt;/strong&gt;在可用地理区 域和服务成熟度方面的扩展，全球的客户在规划云技术策 略时可以认真考虑这个平台了。与其主要竞争对手Amazon Web Services相比，在某些领域， GCP 所具备的功能已经 能与之相媲美。而在其他领域又不失特色——尤其是在可访 问的机器学习平台、数据工程工具和可行的 “Kubernetes 即服务解决方案”（GKE）这些方面。在实践中，我们的团队 对GCP工具和API良好的开发者体验也赞赏有嘉。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;随着Google Cloud Platform在可用地理区 域和服务成熟度方面的扩展，全球的客户在 规划云技术策略时可以认真考虑这个平台了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在微服务或任何其他分布式架构中，最常见的一个需求 是通过身份验证和授权功能来保护服务或 API。 这正是 Keycloak 所解决的问题。&lt;strong&gt;&lt;span&gt;KEYCLOAK&lt;/span&gt;&lt;/strong&gt;是一个开源的身份和 访问管理解决方案，它让保障应用程序和微服务的安全变 得如此简便，以至于几乎不需要编写什么代码。它提供了单 点登录、社交网络登录和一些开箱即用的标准协议——如 OpenID Connect、OAuth 2.0 和 SAML。我们的团队一直在 使用这个工具，并计划继续使用。不过这个平台在安装时需 要做一些工作。由于在初始化和运行时需要通过 API 对其 进行配置，因而必须编写脚本以确保部署是可重复的。&lt;/p&gt;
&lt;p&gt;      在之前的雷达中，我们提到由于Unity在一个成熟平台上 提供了一些抽象和工具，因此它已经成为VR和AR应用程 序开发的首选平台。与它的主要替代品Unreal Engine相 比，Unity更容易访问。随着它最近推出的针对iOS平台的 ARKit 和针对安卓平台的 ARCore，这两个主要的移动平台 都已拥有强大的原生SDK，用来构建增强现实应用。但是， 我们觉得很多团队，特别是那些在构建游戏方面没有丰富 经验的团队，都能从利用类似Unity这样的抽象中受益。这 就是为什么我们要提出&lt;strong&gt;&lt;span&gt;超越游戏的UNITY&lt;/span&gt;&lt;/strong&gt;。这使得不熟悉 上述开发技术的开发人员可以专注于这个SDK，来进行相 关开发。它还为多设备提供了解决方案，特别是在原生SDK 不支持的安卓端。&lt;/p&gt;
&lt;p&gt;      常与WhatsApp被相提并论的&lt;strong&gt;&lt;span&gt;微信&lt;/span&gt;&lt;/strong&gt;，在中国正在成为名副其 实的商业平台。很多人可能还不知道，微信还是最流行的线 上支付平台之一。借助微信内置的内容和会员管理系统，一 些小型企业现已完全依赖微信开展其业务。大型组织可以 通过微信的一些功能把内部系统对接给员工使用。作为覆 盖七成以上中国人的平台，微信是每一个想开辟中国市场的 企业都需要考虑的重要商业因素。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;AZURE SERVICE FABRIC&lt;/span&gt;&lt;/strong&gt;是为微服务和容器打造的分布 式系统平台。它不仅可以与诸如Kubernetes之类的容器编 排工具相媲美，还可以支持老式的服务。它的使用方式花样 繁多，既可以支持用指定编程语言编写的简单服务，也可以 支持 Docker 容器，还可以支持基于 SDK 开发的各种服务。 自几年之前发布以来，它不断增加更多功能，包括提供对 Linux 容器的支持。尽管 Kubernetes 已成为容器编排工具的主角，但 Service Fabric 可以作为 .NET 应用程序的首选。 我们正在 ThoughtWorks 的一些项目中使用这个平台，迄今 为止感觉不错。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;CLOUD SPANNER&lt;/span&gt;&lt;/strong&gt;是一个完全托管的关系型数据库服务。 它在提供高可用性和强大的一致性的同时又不会对延迟做 出妥协。Google 在一个名为 Spanner 的全球分布式数据库 上投入了大量时间之后，最近以 Cloud Spanner 的名称将这 个服务对外发布。 这个平台可以将数据库实例在全球范围 从单个节点规模化到数千个节点，而不必担心数据一致性问 题。 Cloud Spanner 通过高可用的分布式时钟 TrueTime，为读取和快照功能提供了强大的一致性。从 Cloud Spanner 读取数据时可以使用标准 SQL，但是在做写入操作时必须 使用其提供的 RPC API。 尽管并不是所有的服务都需要全球范围规模的分布式数据库，但 Cloud Spanner 的对外发 布极大地改变了我们对数据库的认知。其设计正在影响像 CockroachDb 这样的开源产品。&lt;/p&gt;
&lt;p&gt;      在经过了彻底探索之后，区块链领域的重要参与者R3意识 到区块链并不契合他们的目的，所以他们创造了&lt;strong&gt;&lt;span&gt;CORDA&lt;/span&gt;&lt;/strong&gt;。 Corda是专注于金融领域的分布式账本技术（distributed ledger technology, DLT）平台。 R3具有非常明确的价值主 张，并且知道他们的问题需要务实的技术方法。 这和我们 的经验相符——由于采矿成本较大和运营效率低下，对于某 些商业案例，目前的区块链解决方案可能不是合理的选择。 尽管我们目前在Corda上的开发体验并不非常流畅，而且 v1.0发布后其API并不稳定，我们还是期望看到 DLT 领域能 进一步成熟。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;COSMOS DB&lt;/span&gt;&lt;/strong&gt;是微软于年初发布的全球分布式与多模型数据库服务。虽然大多数新型 NoSQL 数据库都提供可调节 的一致性，但Cosmos DB 却将一致性作为首要特性予以支 持。它提供五种不同的一致性模型。值得强调的是，它还支 持多种数据模型——键值、文档、列族和图——所有这些数 据模型都映射到其内部数据模型，即原子记录序列（atomrecord-sequence, ARS）。Cosmos DB 有趣的一个特点是 能针对其延迟、吞吐、一致性和可用性来提供服务级别协议 （service level agreement, SLA）。其适用性广的特点，给 其他云厂商设置了一个很高的追赶标准。&lt;/p&gt;
&lt;p&gt;      随着近来聊天机器人与语音平台的爆发，涌现出一批工具和 平台——它们能够提供一些服务，从文字中挖掘意图，并管 理会话流，以供人使用。Google所收购的&lt;strong&gt;&lt;span&gt;DIALOGFLOW&lt;/span&gt;&lt;/strong&gt; （原名为API.ai），就是一种这样的”自然语言理解即服务” 的平台。它在该领域中与Facebook的wit.ai以及Amazon Lex等平台展开了竞争。&lt;/p&gt;
&lt;p&gt;      尽管以Kubernetes作为容器编排平台正成为软件开发生 态的主流，但从运维角度看，运行 Kubernetes 集群仍然 很复杂。&lt;strong&gt;&lt;span&gt;GKE（Google Container Engine）&lt;/span&gt;&lt;/strong&gt;是一个托管Kubernetes解决方案，用来部署容器化应用程序。它能降 低运行和维护Kubernets集群的运维成本。我们的团队在使 用GKE获得了良好的体验。平台能完成许多繁重的工作，例如安装安全补丁，监控和自动修复节点，以及管理多集群和 多区域网络。根据我们的经验，Google采用了API优先的方 式来开放平台功能，并使用了诸如用OAuth进行服务授权的 行业标准。这些都能够改善开发人员的体验。尽管其开发团 队已经尽力隔离底层变更对使用者的影响，但要意识到GKE 仍在快速开发中。在过去一段时间里我们还是会时不时地 受到变更所带来的影响。我们期待随着Terraform on GKE 及类似工具的出现，“基础设施即代码”这一实践的成熟度 会不断提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Language Servers将代码补全、调用分析和 重构等能力提取为一种 API，从而让任何编 辑器都能与编程语言的抽象语法树交互。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;KAFKA STREAMS&lt;/span&gt;&lt;/strong&gt;是一个用于构建流式应用的轻量级库。 它的设计目标在于简化流式处理，让它像为异步服务设计 的主流应用编程模型一样易于访问。当需要应用流式处理 模型来解决问题，又不想陷入运行集群（通常会随着功能完 备的流处理框架而引入）的复杂性时，它会是一个很好的选 择。 新的功能包括在Kafka集群中的“恰好一次”（exactly once）流处理。实现方式是在Kafka生产者端引入幂等性， 并且使用新的事务API跨多个分区实现原子写入。&lt;/p&gt;
&lt;p&gt;      大型 IDE 的威力很大程度上源于利用源代码分析出的抽象 语法树（AST）来进一步分析和操作源代码的能力，比如代 码补全，调用分析和重构。语言服务器将这种能力提取到单 独的进程中，从而让任意文本编辑器都可以通过 API 来使 用 AST。微软从他们的 OmniSharp 和 TypeScript 服务器 项目中，提炼并引领了&lt;strong&gt;&lt;span&gt;语言服务器协议（Language Server Protocol, LSP）&lt;/span&gt;&lt;/strong&gt;的拟定。编辑器只要使用LSP 协议就可用于 任何具备 LSP 兼容服务器的编程语言的开发。这意味着我 们可以继续使用自己喜爱的编辑器，同时也不必放弃各种编 程语言的高级编辑功能——这对于很多 Emacs 瘾君子来说 尤其利好。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;LORAWAN&lt;/span&gt;&lt;/strong&gt;是一种低功耗广域网，专为低功耗、远距离和 低比特率的通信场景而设计。它提供了边缘设备与网关设 备之间的通信能力，能够通过后者将数据转发至应用程序 或者后台服务。LoRaWAN通常用于分布式传感器组或物联 网这些必须具备长电池寿命和远距离通信能力特点的设备 上。它解决了在使用一般的WiFi进行低功耗广域网通信时 的两个关键问题：通信距离和功耗。LoRaWAN已有若干实 现，其中值得注意的是一个免费的开源实现——The Things Network。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;随着机器学习从试验性使用转向生产环境， 需要一种可靠的方式来托管和部署这些可远 程访问的模型，并能随着消费者数量的增加 而进行扩展。 (TensorFlow Serving)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;MAPD&lt;/span&gt;&lt;/strong&gt;是一个支持SQL的运行在GPU 上的内存列式分析性 数据库。我们对于数据库负载到底是I/O密集所致还是计算 密集所致有过争论。不过GPU的并行能力，结合 VRAM 的充 足带宽，在某些场景下非常有用。MapD可以透明地将最频 繁使用的数据（比如在group-by、过滤、计算操作以及 join 条件中所涉及的列）存放在VRAM中，而将其余的数据存放 在主内存中。通过这种内存管理方式，MapD无需索引即可 达到相当好的查询性能。尽管还有其他GPU数据库提供商， 随着MapD近期开源了其核心数据库，以及通过GPU开放分 析计划（GPU Open Analytics Initiative）的推广，MapD在 这个领域处于领先地位。如果你的分析任务是计算密集型 的，并能够利用GPU的并行性进行加速，且能纳入主内存 中，我们建议评估MapD。&lt;/p&gt;
&lt;p&gt;      我们很喜欢那些能很好地解决单个问题的简单工 具。&lt;strong&gt;&lt;span&gt;NETLIFY&lt;/span&gt;&lt;/strong&gt;正是这样一个工具。用它可以创建静态网站内容，提交到GitHub，然后网站就能快速、轻松地上线可用了。Netlify提供命令行工具来控制流程，支持 CDN（内容分发网络），可以与Grunt这样的工具协同工 作。更重要的是Netlify支持HTTPS。 &lt;/p&gt;
&lt;p&gt;      机器学习模型已经开始渗入到日常的商业应用中。当有足够 的训练数据可用时，这些算法可以解决那些以前可能需要 复杂的统计模型或试探法的问题。随着机器学习从试验性 使用转向生产环境，需要一种可靠的方式来托管和部署这 些可远程访问的模型，并能随着消费者数量的增加而进行 扩展。&lt;strong&gt;&lt;span&gt;TENSORFLOW SERVING&lt;/span&gt;&lt;/strong&gt;通过将远程gRPC接口暴 露给一个被导出来的模型，解决了上述部分问题。这支持以 多种方式部署训练完成的模型。TensorFlow Serving也接 受一系列的模型来整合持续的训练更新。其作者维护了一 个Dockerfile来简化部署过程。据推测，gRPC 的选择应与 TensorFlow 执行模型保持一致。但是，我们通常都会对需 要代码生成和本地绑定的协议保持警惕。&lt;/p&gt;
&lt;p&gt;      凭借&lt;strong&gt;&lt;span&gt;WINDOWS CONTAINERS&lt;/span&gt;&lt;/strong&gt;，微软正在容器化的道路上 奋起直追。截至本期雷达，微软提供了2个可以在Docker容 器中运行的Windows OS的镜像——Windows Server 2016 Server Core和Windows Server 2016 Nano Server。尽管 Windows Container还有提升的空间，比如缩减镜像文件大 小，增强对生态系统的支持，以及完善相关文档，我们的团 队已经开始在其他容器化技术已经成功应用的场景（如构 建代理）中使用它们了。&lt;/p&gt;
&lt;p&gt;      在中间件中实现业务逻辑和流程编排，特别是要在其中运 用专业技能和专用工具来将中间件作为一个单点来创建，以 实现规模化和控制，对此我们还是心怀顾虑的。API网关市 场竞争十分激烈，那些供应商们持续地向其产品中添加新 的功能，从而体现产品之间的差异化。这一点令上述趋势得 以持续。但这样会产生出&lt;strong&gt;&lt;span&gt;过度庞大的API网关产品&lt;/span&gt;&lt;/strong&gt;。其功能 在本质上就是反向代理，这助长了难以测试和部署的系统 设计。API网关确实可以提供一些处理某些特定问题的实用 程序——例如身份验证和速率限制——但是任何领域业务 逻辑都应该仅出现在应用程序或服务中，而不是网关中。&lt;/p&gt;
&lt;h2&gt;关于工具：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/423536/201712/423536-20171224121702084-1212341747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内容解读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      我们的团队非常喜欢托管的 CI / CD工具——&lt;strong&gt;&lt;span&gt;BUILDKITE&lt;/span&gt;&lt;/strong&gt;， 因为它既简单，搭建速度又快。只需要安装一个轻量级的代 理应用程序来连接构建代理与在Buildkite上所托管的构建 服务，就可以使用私有或云端的机器来执行构建。与使用托 管的代理相比，能在这种级别上对构建代理的配置进行控 制，在多数情况下都是一个优势。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;CIRCLECI&lt;/span&gt;&lt;/strong&gt;是一个持续集成引擎，它既可以在SaaS云服务上 使用，又可以私有部署使用。它已经被我们很多开发团队在 SaaS平台上当作常用CI工具。这些团队需要低摩擦（lowfriction）和易于搭建的构建与部署流水线。CircleCI 2.0的 版本支持构建任务的工作流，并具备扇入（fan-in）和扇出 （fan-out）流模式和手动触发模式，且支持移动开发。它也 允许开发者在本地运行流水线。另外 CircleCI 能很容易地与 诸如Slack及其他通知和报警系统进行集成。就像使用任何 其他承载公司资产的SaaS产品一样，我们建议用户仔细查 看CircleCI的安全实践。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Gopass增加了诸如多用户密码管理、层级式 密码存储、交互式查找、基于时间的一次性 密码（TOTP）,以及二进制存储格式等功能.（gopass）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;GOPASS&lt;/span&gt;&lt;/strong&gt;是一个基于GPG和Git的团队密码管理解决方案。 它的前身是pass，并在此基础上增加了诸如多用户密码管 理、层级式密码存储、交互式查找、基于时间的一次性密码 （TOTP）,以及二进制存储格式等功能。由于它的存储格式 与pass基本兼容，因此可以直接从pass迁移过来。这意味 着只需调用一次存储密钥就能将其集成到迁移的整备工作 流中。&lt;/p&gt;
&lt;p&gt;      从2017年中开始，Chrome 用户有了一个在Headless模式 下运行浏览器的新选择。这非常适合执行那些依赖浏览器 的前端测试，而不必在屏幕上显示操作的结果。而在此之前，这属于 PhantomJS 的地盘，但Headless Chrome正在迅速取代那种用 JavaScript 驱动 WebKit 引擎的方法。测试在 Headless Chrome 浏览器中的运行速度要快得多，而且在行为上更贴近真实的浏览器，但我们的团队也发现它 比 PhantomJS 要占用更多内存。 基于上述优点，针对&lt;strong&gt;&lt;span&gt;前端测试的HEADLESS CHROME&lt;/span&gt;&lt;/strong&gt; 很可能成为这个领域的事 实标准。&lt;/p&gt;
&lt;p&gt;      如果正在寻找用Go和Java编写的高性能 JSON 编码/解码 工具，那就试试开源库&lt;strong&gt;&lt;span&gt;JSONITER&lt;/span&gt;&lt;/strong&gt;，它与Go语言中的标准 JSON编码包相兼容。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最初由Soundcloud开发的监控和时序数 据库工具Prometheus，不仅在进行持续 改进，而且其使用率也获得了一些提升。 （Prometheus）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      最初由Soundcloud开发的监控和时序数据库工具 Prometheus，不仅在进行持续改进，而且其使用率也获 得了一些提升。&lt;strong&gt;&lt;span&gt;PROMETHEUS&lt;/span&gt;&lt;/strong&gt;主要支持基于“拉动” 的HTTP模型，同时也能支持告警，这令其能够成为运维 工具箱中经常得到使用的工具。在本期技术雷达编撰过 程中，Prometheus 2.0正处于预发布阶段，并且还在不 断演进。Prometheus的开发者们正专注于核心时序数 据库以及各种可用的度量指标之上。对于Prometheus 用户来说，Grafana已成为首选的仪表板可视化工具，且 可以购买该工具的技术支持服务。我们的技术团队还发 现，Prometheus在索引和搜索能力上能够作为Elastic Stack很好的补充。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;APEX&lt;/span&gt;&lt;/strong&gt;是一个能够轻松构建、部署和管理AWS Lambda 函 数的工具。有了Apex，就能使用AWS尚未原生支持的包括 Golang、Rust等在内的编程语言来编写函数。这一点是通过 Node.js shim来实现的。它会创建一个子进程，并通过标准 输入和输出来处理各种事件。Apex还有很多不错的特性，可 以改善开发者的体验。我们特别欣赏它能在本地测试函数 的能力，以及在将变更运用到AWS资源之前能对其进行预 演的能力。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;ASSERTJ-SWAGGER&lt;/span&gt;&lt;/strong&gt; 是一个 AssertJ 工具库，能够用来验 证API的实现是否符合其契约规格。当 API 端点的实现发生 了更改但未更新其 Swagger 规格，或未能发布更新后的文 档时，我们的团队就能通过使用 assertj-swagger 来捕获这 些问题。&lt;/p&gt;
&lt;p&gt;      修复 CI 上失败的端到端自动化测试会是一段痛苦的经历， 尤其是在 headless 模式下。而&lt;strong&gt;&lt;span&gt;CYPRESS&lt;/span&gt;&lt;/strong&gt;是一个很有用的 工具，它能帮助开发人员轻易地构建端到端自动化测试，并且把测试的步骤录制在一个 MP4 文件里。这使得开发者可 以通过查看测试视频来修复测试，而不是在headless模式 下去重现问题。Cypress 不仅是一个测试框架，更是一个强 大的测试平台。当前我们已经把其 CLI 集成到了我们项目的 headless CI 里。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;FLOW&lt;/span&gt;&lt;/strong&gt;是一个针对 Javascript 的静态类型检查工具，它可 以为整个代码库逐步增加类型检查。不同于通过定义另一 种语言来实现静态类型检查的 Typescript 语言，Flow 可以 被逐步添加到支持 ECMAScript 第5、第6 以及 第7版的已有 Javascript 代码库中。我们建议把 Flow 添加到持续集成部 署流水线中，并从最关注的代码开始做静态类型检查。使用 Flow 能使代码更清晰，重构更可靠，并在构建过程的早期 就捕获到类型相关的代码缺陷。&lt;/p&gt;
&lt;p&gt;      过去几年间，我们注意到分析笔记本应用（analy tics notebooks）的流行度在持续上升。这些应用都是从 Mathematica应用中获得灵感，能够将文本、数据可 视化和代码活灵活现地融入到一个具备计算能力的文档 中。在上个版本的技术雷达中我们所提到的基于Clojure 的GorillaREPL，就属于此类工具。但随着人们对机器 学习的兴趣不断增加，以及该领域中的从业者们逐渐将 Python作为首选编程语言，大家开始集中关注Python分 析笔记本了。其中&lt;strong&gt;&lt;span&gt;JUPYTER&lt;/span&gt;&lt;/strong&gt;看起来在ThougthWorks团队 中格外引人注目。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;Kong&lt;/span&gt;&lt;/strong&gt;是一个由Mashape公司搭建和支持的开源API网关。该 公司也提供企业级产品，来将Kong与其专有的 API 分析和开 发者门户工具相结合。它们能以各种配置进行部署，来作为 边缘API网关或内部 API 代理。Kong 所基于的 OpenResty 通过其Nginx模块和用于扩展的Lua插件，为其强大和高效 的功能奠定了基础。Kong 既可以使用PostgreSQL进行单一 区域部署，也可以使用 Cassandra 进行多区域配置。我们的 开发人员已经享受到 Kong 的高性能、API 优先的方式 （能使其配置自动化）以及易于容器化部署的种种好处。不 像过度庞大的API网关那样，&lt;strong&gt;&lt;span&gt;KONG API&lt;/span&gt;&lt;/strong&gt; 网关只拥有更少的 功能，但实现了关键的API网关功能，如流量控制、安全性、 日志记录、监控和身份验证。 我们很高兴能在不久的将来 以一个 sidecar 配置的方式对 Kong 进行评估。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;KOPS&lt;/span&gt;&lt;/strong&gt;是用于在生产环境上创建和管理高可用性 Kubernetes集群的命令行工具。 最初它针对AWS，但现在 已经对其他供应商提供了试验性支持。它可以快速地启动并 运行。虽然某些功能（如滚动升级）尚未开发完毕，但其社 区令人印象深刻。&lt;/p&gt;
&lt;p&gt;      谷歌编写的&lt;strong&gt;&lt;span&gt;LIGHTHOUSE&lt;/span&gt;&lt;/strong&gt;工具可用于评估Web应用程 序是否遵守Progressive Web App标准。今年，新发布的 Lighthouse 2.0 向其基本工具集中新增了性能指标和可访 问性检查这些功能。这些新增功能现在已经被纳入 Chrome 标准开发者工具的 audit 选项卡下。Lighthouse 2.0 也是 Chrome headless 模式的另一个受益者。 鉴于该工具可以 由命令行直接执行，或作为Node.js应用程序独立运行，因此 Pa11y及类似工具提供了一种能在持续集成流水线中运行可 访问性检查的替代方案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JavaScript Web 富应用的一个老问题是如 何使这些页面的动态渲染部分可供搜索引擎 检索。无法渲染JavaScript的爬虫机器人可 以被路由到Rendertron服务器来进行渲染。 （Rendertron）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      JavaScript Web 富应用的一个老问题是如何使这些页面 的动态渲染部分可供搜索引擎检索。为此开发人员采用了 各种各样的技巧，包括使用React.js的服务端渲染，外部服 务或预渲染内容。现在谷歌 Chrome 新的 headless 模式 又贡献了一个新的技巧—— &lt;strong&gt;&lt;span&gt;RENDERTRON&lt;/span&gt;&lt;/strong&gt;，即 Chrome 的headless 渲染解决方案。它在一个 Docker 容器中封装 了一个 headless 的 Chrome 实例，可以作为独立的HTTP 服务器来部署。无法渲染JavaScript的爬虫机器人可以被 路由到此服务器来进行渲染。 虽然开发人员也可以部署 自己的 headless Chrome代理并配置相关的路由机制，但 Rendertron 简化了配置和部署过程，并提供了令爬虫机器 人进行检测和路由的中间件示例代码。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;SONOBUOY&lt;/span&gt;&lt;/strong&gt;是一个以非破坏性的方式在任何Kubernetes 群集上运行端到端“合规性测试”的诊断工具。由两位 Kubernetes项目发起者创办的Heptio公司的团队构建了这 个工具，来确保各种Kubernetes发行版和配置都符合最佳 实践，同时遵循开源标准化原则以实现集群互操作性。我们 正在尝试使用Sonobouy作为“基础设施即代码”构建流水 线的一部分，并对Kubernetes安装进行持续监控，以验证整 个集群的行为和健康状况。&lt;/p&gt;
&lt;p&gt;      如果用Spring框架来实现Java服务，那么可以考虑用 &lt;strong&gt;&lt;span&gt;SPRING CLOUD CONTRACT&lt;/span&gt;&lt;/strong&gt;来进行消费者驱动的契约测 试。目前，该工具的生态系统支持根据契约来验证客户端的 调用以及服务器端的实现。与Pact （一个开源的消费者驱 动契约测试工具集）相比，它不支持契约代理，也不支持其它编程语言。不过它能与Spring生态系统完美集成，比如使 用Spring Integration进行消息路由。&lt;/p&gt;
&lt;h2&gt;关于语言和框架：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/423536/201712/423536-20171224122546256-1823740411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内容解读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在往期的雷达中，我们不确定是否应该强烈推荐 &lt;strong&gt;&lt;span&gt;ANGULAR&lt;/span&gt;&lt;/strong&gt;，因为从本质上来说，它是一个新的、整体上 没那么让人兴奋的框架，仅仅是和那个我们曾经喜爱过 的 AngularJS 同名而已。目前已经进化到第5个版本的 Angular，在提供向后兼容性的同时，有了稳定的改进。我 们的一些团队已经在生产环境上应用 Augular，他们很满 意最终的效果。基于这个原因，在这一期雷达中，我们把 Angular 移到了“试验”阶段，来表示我们的一些团队现在 把它当作不二之选。然而我们的大多数团队，仍然会更倾向 于选择React, Vue 或者Ember。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;ASSERTJ&lt;/span&gt;&lt;/strong&gt;是一个提供流式断言接口的Java库，可以很容易 在测试代码中传达测试的意图。AssertJ提供了可读的错误 信息、软断言以及改进过的对集合和异常支持。我们看到一 些团队默认选择使用它，而不是JUnit和Hamcrest组合。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSS网络布局（CSS Grid Layout）是一个二维（two-dimensional）的基于网格的布局系统, 它所提供的机制使用了一组可预测的尺寸调整行为，将布局的可用空间划分为行和列 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      即使CSS没有为创建布局提供明确的支持，但它依然是 网页布局的首选。Flexbox提供了更简单的，一维（onedimensional）的布局, 但开发人员通常还是会采用一些 库和工具包实现更复杂的布局。&lt;strong&gt;&lt;span&gt;CSS网格布局（CSS Grid&lt;/span&gt; &lt;span&gt;Layout）&lt;/span&gt;&lt;/strong&gt;是一个二维（two-dimensional）的基于网格的布局 系统, 它所提供的机制使用了一组可预测的尺寸调整行为， 将布局的可用空间划分为行和列。它不需要任何额外的库, 并能与Flexbox和其他CSS元素集成得很好。然而, 由于IE11 仅支持其部分规范, 所以目前仍然依赖 Windows 7上IE浏览 器的用户需求会被忽略。&lt;/p&gt;
&lt;p&gt;      大多数大型CSS代码库都需要复杂的命名机制来避免全局 命名空间中的冲突。&lt;strong&gt;&lt;span&gt;CSS MODULES&lt;/span&gt;&lt;/strong&gt;通过为每个CSS文件中 的所有class创建局部作用域来解决这些问题。当这个文件 被导入到一个JavaScript模块，其中的CSS class可以通过名 称字符串来引用。然后，在构建工具（Webpack，Browserify 等）中，class名称被替换为自动生成的全局唯一字符串。这 是一个重大的职责转换。以前，人们不得不通过管理全局命 名空间来避免class命名冲突的问题，现在这个职责移交给 构建工具。我们在CSS Modules遇到了一点小麻烦：功能测 试经常会超出局部作用域，因此不能通过CSS文件中定义的 名称来引用class。针对这个问题，我们建议使用ID或是data 属性作为替代方案。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Jest是一个“零配置”的前端测试工具，具有 诸如模拟和代码覆盖之类的开箱即用特性， 主要用于React和其他JavaScript框架。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      我们团队对采用&lt;span&gt;&lt;strong&gt;JEST&lt;/strong&gt;&lt;/span&gt;做前端测试的结果非常满意。它提 供了一种“零配置”的开发体验，并具备诸多开箱即用的功 能，比如 mock 和代码覆盖率。你不仅可以将此测试框架 应用于React.js应用程序，也可以应用于其他 JavaScript 框 架。Jest 经常被夸大的特性之一是 UI 快照测试。快照测试 可以作为测试金字塔上层一个很好的补充，但请记住，单元 测试仍然是坚实的基础。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Wolfmanlq/p/8012847.html&quot; target=&quot;_blank&quot;&gt;Jest系列教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      对Android的完美支持为迅速发展的&lt;span&gt;&lt;strong&gt;KOTLIN&lt;/strong&gt;&lt;/span&gt;语言提供了 额外的推动力，我们也正在密切关注Kotlin / Native（基于LLVM，可以将Kotlin代码编译为原生可执行文件）的进展。在 使用Anko库开发Android应用时，我们已经尝到了空指针安 全、数据类和易于构建DSL的甜头。尽管初始编译速度慢， 且只有IntelliJ才提供一流的IDE支持，但我们仍然建议尝试 一下这种新颖简洁的现代语言。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;&lt;strong&gt;SPRING CLOUD&lt;/strong&gt;&lt;/span&gt;在持续演进的过程中增加了许多有趣的 新特性。例如在spring-cloud-streams项目中，对Kafka Streams绑定的支持让采用Kafka和RabbitMQ通过连接 器构建消息驱动的应用变得相对容易。正在使用该特性的 ThoughtWorks的团队都认同它能在使用像Zookeeper这样 的复杂基础设施时提供便捷性，也对构建分布式系统时需 要解决的常见问题提供支持，例如使用spring-cloud-sleuth 进行跟踪。目前我们已成功将它应用在多个项目中，不过大家仍然需要注意其适用场景。&lt;/p&gt;
&lt;p&gt;      一直以来，Google的Android文档实例缺乏架构和结构。 随着&lt;span&gt;&lt;strong&gt;ANDROID架构组件&lt;/strong&gt;&lt;/span&gt;的发布，这种状况有所改善，这 是一组有主见的库，它们帮助开发者用更好的架构创建 Android 应用程序。 它们解决了Android开发的长期痛点： 处理生命周期，分页，SQLite数据库以及配置变更时的数据 持久化。这些库无须一起使用，你可以选择最需要的集成到 现有项目中。&lt;/p&gt;
&lt;p&gt;      我们在移动增强现实中看到了很多令人激动的活动，其中 大部分来自&lt;strong&gt;&lt;span&gt;ARKIT&lt;/span&gt;&lt;/strong&gt;（Apple提供的原生AR库）/&lt;strong&gt;&lt;span&gt;ARCORE&lt;/span&gt;&lt;/strong&gt; （Google提供的原生AR库）的加持。 这些库将移动AR技术 带入主流，让后者得到大量采用。尽管如此，各大公司在寻 找真实的用户场景（而非一些花哨的Demo）和真正增强用 户体验的解决方案方面还是面临挑战。&lt;/p&gt;
&lt;p&gt;      多应用策略备受争议，尤其现在越来越少的用户愿意再下 载新的应用程序。不同于推出一个新的应用然后为下载量 而努力，许多团队必须通过一个已经被广泛安装的应用来 发布新的功能，这给应用程序的架构带来了挑战。&lt;strong&gt;&lt;span&gt;ATLAS&lt;/span&gt;&lt;/strong&gt; 和&lt;strong&gt;&lt;span&gt;BEEHIVE&lt;/span&gt;&lt;/strong&gt;是分别用于Android和iOS的模块化解决方案。 它们能让多个团队工作于物理隔离的不同模块，并且从一 个门面应用中重新组装或者动态加载这些模块。它们都是 Alibaba的开源项目，因为Alibaba也曾面临同样的下载量减 少和单个应用架构挑战的问题。&lt;/p&gt;
&lt;p&gt;      “你并不需要一个规则引擎”，这常常是选择规则引擎时的 首要法则，因为我们已经见到太多的人基于一些臆想的理 由，将自己绑定在难以测试的黑盒的的规则引擎上——原本 定制化应该是更好的解决方案。虽说如此，在一些规则引擎 确实适用的场合，我们采用 &lt;strong&gt;&lt;span&gt;CLARA RULES&lt;/span&gt;&lt;/strong&gt; 取得了很好的 成功。不同于其他的规则引擎，它使用简单的 Clojure 代码 来表达和执行规则，这意味着规则可以被很好地重构、测试 和版本化。比起追求“业务人员可以直接编辑业务规则”的 错觉，Clara Rules 能够很好地驱动业务专家和开发人员之 间的合作。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;CSS IN JS&lt;/span&gt;&lt;/strong&gt;是一种用JavaScript编写CSS样式的技术，通 过鼓励采用一种通用模式，编写样式以及应用样式的 JavaScript组件，使样式和逻辑的关注点得到统一。该领域 中的新秀——诸如JSS，emotion和styled-components，依 靠工具来将CSS-in-JS代码转化成独立的CSS样式表，从而 适合在浏览器里运行。这是在JavaScript中编写CSS的第二 代方法，与以前的方法不同，它不依赖于内联样式，这意味 着它能支持所有CSS特性，使用npm生态共享CSS以及跨 平台使用组件。我们的团队发现styled-components很适 合像React这样基于组件的框架，并且可以使用jest-styledcomponents做CSS的单元测试。这是个新兴的领域且变化 迅速。用该方法时，在浏览器里人工调试生成的class名称会 需要费些功夫，并且可能不适用于那些前端架构不支持重用 组件并需要全局样式的项目。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;DIGDAG&lt;/span&gt;&lt;/strong&gt;是一个在云中构建、运行、调度和监控复杂数据管 道的工具。你可以使用丰富的开箱即用操作符在YAML中定 义这些管道，也可以通过API构建属于自己的管道。Digdag 具有数据管道解决方案中的大多数常见功能，例如依赖关 系管理、易于复用的模块化工作流、安全的密码管理和多语 言支持。我们最感兴趣的功能是它对多种云平台的支持，这 允许你通过AWS RedShift，S3和Google BigQuery等服务来 移动和连接数据。随着越来越多的云提供商提供相互竞争 的数据处理解决方案，我们认为Digdag（以及类似的工具） 是充分利用这些平台的最佳选择。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;DRUID&lt;/span&gt;&lt;/strong&gt;是一个具有丰富的监控特性的JDBC连接池。它有一 个内置的SQL解析器，提供了对数据库中执行的SQL语句语 义级别的监控。注入或可疑的SQL语句将被拦截，并直接在 JDBC层记录下来。查询也可以基于它们的语义进行合并。 这是一个阿里巴巴开源的项目，它反映了阿里巴巴从自己的 数据库系统中学到的教训。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Android架构组件是一组有主见的类库，能 够帮助开发者用更好的架构创建 Android 应用程序。 (Android架构组件)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;ECHARTS&lt;/span&gt;&lt;/strong&gt;是一个轻量级的图表库，对不同类型的图表和交 互有丰富的支持。ECharts完全基于Canvas API，因此即使 处理100k +数据点也具有令人难以置信的性能，并且还针对 移动用户进行了优化。 凭借其扩展项目ECharts-X，它还可 以支持3D绘图。ECharts 是一个百度开源项目。&lt;/p&gt;
&lt;p&gt;      Go语言能够被编译为裸片上运行的目标程序，这使得嵌入 式系统开发领域对它的兴趣与日俱增 。&lt;strong&gt;&lt;span&gt;GOBOT&lt;/span&gt;&lt;/strong&gt;是一个用于 机器人、物理计算和物联网(IoT)的框架，它基于Go语言编 写，并且支持多个平台。我们在一个对实时性响应没有要求 的实验性机器人项目中使用了GoBot，并且用GoBot创建了 开源的软件驱动。GoBot的HTTP API使其与移动设备的集 成十分容易，从而能创建更丰富的应用。&lt;/p&gt;
&lt;p&gt;      ThoughtWorks的许多移动开发团队对一款可以检测 Android和Java中令人讨厌的内存泄漏工具&lt;span&gt;&lt;strong&gt;LEAKCANARY&lt;/strong&gt;&lt;/span&gt; 感到非常兴奋。LeakCanary与App集成非常简单，同时它也 提供能够清晰回溯内存泄漏原因的通知。把它加到你的工 具包，它可以帮你节省在多个设备上排查内存泄漏的时间。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;PYTORCH&lt;/span&gt;&lt;/strong&gt;是Lua机器学习框架Torch在Python语言下的 完整重写版。比起Tensorflow，它还很新不够成熟，但在 程序员的眼里它却很好用。 因其面向对象的特性和原生 的Python实现，模型可以表达得更加清晰简洁，并可以 在执行过程中调试。尽管最近涌现出了许多这类框架，但 PyTorch拥有Facebook和广泛合作伙伴的支持，包括应该 会继续支持CUDA架构的NVIDIA。ThoughtWorks的团队发 现，PyTorch在模型的设计开发及试验阶段拥有着明显的 优势，但在大规模的生产环境中的训练及实现仍然离不开 TensorFlow。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;SINGLE-SPA&lt;/span&gt;&lt;/strong&gt;是一个JavaScript元框架，它允许我们使用 不同的框架构建微前端，而这些框架可以共存于单个应用 中。 一般来说，我们不建议在单个应用中使用多个框架， 但有时却不得不这么做。 例如当你在开发遗留系统时，你 希望使用现有框架的新版本或完全不同的框架来开发新功 能，single-spa就能派上用场了。鉴于很多JavaScript框架都 昙花一现，我们需要一个解决方案来应对未来框架的变化， 以及在不影响整个应用的前提下进行局部尝试。在这个方向 上，single-spa是一个不错的开始。&lt;/p&gt;
&lt;p&gt;      智能合约编程需要一种比交易处理脚本更具表现力的语 言。在众多为智能合约设计的新编程语言中，&lt;strong&gt;&lt;span&gt;SOLIDITY&lt;/span&gt;&lt;/strong&gt;是最受欢迎的。这是一种面向合约的静态类型语言，其语法类似于JavaScript。 它抽象了智能合约中自我实现的业务逻辑。围绕Solidity的工具链也在快速成长。如今，Solidity是 Ethereum平台的首选编程语言。鉴于已部署智能合约的不 可变性，对依赖的严格测试和审计是至关重要的。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;TENSORFLOW MOBILE&lt;/span&gt;&lt;/strong&gt;使开发人员可以将各种理解和分 类技术融入其iOS或Android应用程序。 考虑到手机上可用 的传感器数量及其可收集的数据范围，这一点尤其有用。预先训练好的TensorFlow模型可以加载到移动应用程序 中，并应用于实时视频帧，文本，语音等输入的处理中。手机 为实现这些计算模型提供了一个令人惊讶的合适的平台。 TensorFlow模型导出和加载的文件格式都是protobuf文件， 这可能会为实现者带来一些问题。 Protobuf的二进制格式 让检查模型很难，并要求你将正确的protobuf库版本链接到 移动应用程序。但是，本地模型的执行，提供了一个很有吸 引力的针对TensorFlow Serving的替代方案，这可以节省远 程执行的通信开销。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们在适合规则引擎的场景采用 Clara Rules 取得了很好的成功。我们喜欢通过它 用简单的 Clojure 代码来表达和执行规则， 这意味着规则可以被很好地重构、测试和版 本化。 (Clara rules) &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;TRUFFLE&lt;/span&gt;&lt;/strong&gt;是一个开发框架。它将现代化的 Web 开发体验 带到了Ethereum平台。Truffle 接管了智能合约编译、库链 接和部署，以及在不同区块链网络中处理制品的工作。我 们喜爱 Truffle 的原因之一就是它鼓励开发者为智能合约编 写测试。这一点非常值得重视，因为智能合约的编写通常 涉及到金钱。得益于其内置的测试框架以及与TestRPC 的 集成，Truffle 可以允许我们使用 TDD 的方式来编写智能合 约。我们期望出现更多像 Truffle 的技术能促进在区块链领 域中的持续集成实践。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;WEEX&lt;/span&gt;&lt;/strong&gt;是一套跨平台移动应用开发方案，采用了Vue.js的组 件化语法。对于那些偏爱Vue.js简洁性的开发者，Weex是 一个开发原生移动应用切实可行的选择，但同时也能胜任 非常复杂的应用。已经有大量的复杂的应用构建于Weex框 架，其中包括中国最流行的两款移动应用程序——天猫和淘 宝。Weex最初由阿里巴巴开发，目前是Apache孵化项目。&lt;/p&gt;

&lt;h2&gt; 写在最后：&lt;/h2&gt;
&lt;p&gt;  关于技术雷达可访问thoughtworks官网获取最新，也可添加订阅：&lt;a href=&quot;https://www.thoughtworks.com/cn/radar&quot; target=&quot;_blank&quot;&gt;https://www.thoughtworks.com/cn/radar&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 04:42:00 +0000</pubDate>
<dc:creator>不负春光，努力生长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wolfmanlq/p/8097663.html</dc:identifier>
</item>
<item>
<title>近期对FTP及Excel数据处理的一些摸索 - 黄舒砚</title>
<link>http://www.cnblogs.com/zpzcy/p/8097734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zpzcy/p/8097734.html</guid>
<description>&lt;p&gt;一个多月没写随笔了，主要是发的东西，自己感觉也很垃圾，说又说回来，谁不是从垃圾变强的，所以不比比，还得努力。come on！！&lt;/p&gt;
&lt;p&gt;Python学习也有段时间了，近期为了解决同事的一个难题，所以我们决定联系Python的同时，帮他解决这个难题。他的难题简单概括来说，每次他需要登录某单位的FTP服务器，下载好几个项目一个月的数据，然后找到其中地源热泵数据，全部复制到本地，然后打开每个项目的文件，一行一行的复制到Excel中，然后再进行数据处理，其中一个项目，一个时间的数据截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1254026/201712/1254026-20171224122222068-761082576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据均是以逗号分割，可想而知，他每次仅仅的粘贴复制是有多费劲。所以我们就小试牛刀，把自己学的Python用上，用代码给他解决这个问题。&lt;/p&gt;
&lt;p&gt;开始的时候也没有接触过FTP这个模块，所以最开始就想怎么能用代码，把想要的数据下载到本地，所以就学习了ftplib这个模块。然后逐层深入，怎么能下载每一天的，以至于到每个项目的每一天，最终的download的模块的所有的代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,sys
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime,timedelta
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ftplib &lt;span&gt;import&lt;/span&gt; FTP            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载ftp模块&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd,xlwt
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; starttime = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入想要下载文件的开始时间（格式：20170101）：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; endtime = parse(input(&quot;请输入想要下载文件的结束时间：\n&quot;))                       &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input_time = int(input(&quot;请输入想要下载前多少天的数据：\n&quot;))&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; base_dir = os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(base_dir)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;sys.path.append(base_dir)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; ftp=FTP()                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置变量&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;ftp.set_debuglevel(2)             #打开调试级别2，显示详细信息&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; ftp.connect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,21)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接的ftp sever和端口&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; ftp.login(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接的用户名，密码&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ftp.cwd(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;目录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + starttime + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进入远程目录&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ftp.nlst())&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;downloadlist = ftp.nlst()               &lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     bufsize=1024                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置的缓冲区大小&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ftp.nlst():
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GHP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; filename &lt;span&gt;and&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0800_001.cmep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; filename:           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要下载的文件&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             file_handle=open(base_dir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + filename,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).write &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以写模式在本地打开文件&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;file_handle=open(filename,&quot;wb&quot;).write&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             ftp.retrbinary(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RETR &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+filename,file_handle,bufsize) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接收服务器上文件并写入本地文件&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;            ftp.set_debuglevel(0)             #关闭调试模式&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(filename + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经下载完成！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             
&lt;span&gt;40&lt;/span&gt;         
&lt;span&gt;41&lt;/span&gt;     ftp.cwd(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您想要的文件已经全部下载完成，欢迎下次使用！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; ftp.quit()                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;退出ftp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;download的执行结果是，是把所有项目某一天的代码全部下载到本地data目录下。下载的结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1254026/201712/1254026-20171224122533537-885323294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时数据下载好了，就想着该如何把数据整理到Excel中了，所以还需要去学习Python中关于Excel的库，我们主要用的xlrd和xlwt，不懂的可以百度。我们就写了把后缀名微cmep的文件，写的Excel里的一个模块handle，在过程中我们发现，对于每一个项目来说，我们同事所想要的数据的行数都不相同，所以老师就给我们一个思路，写一个关于地源热泵每一个项目配置文件，就解决了这个问题。所以我们就动手写了一个json格式的配置文件，代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,sys
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; base_dir = os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(base_dir)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;sys.path.append(base_dir)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; file_list = os.listdir(base_dir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(file_list)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; output_data = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[]}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_list:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     with open(base_dir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; filename) as f:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         lines =&lt;span&gt; f.readlines() 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(lines)&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         line_number =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; nums,line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(lines):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[10] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GJ&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[10] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kWh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                line_number.append(nums)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                
&lt;span&gt;23&lt;/span&gt;         out_filename = filename.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_GHP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSTJEC_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(out_filename)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         data = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:out_filename,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download_line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:line_number}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         output_data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].append(data)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt; with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;settings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f1:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     json.dump(output_data,f1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行write_json.py的这个文件，得出每个项目所需要下载的不同行，然后我们根据这个配置文件，开始把需要的参数写入到Excel文件中，具体代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,sys,json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd,xlwt
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把当前文件所在目录添加到电脑的环境变量&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; base_dir = os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(base_dir)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;sys.path.append(base_dir)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当前文件所在目录data文件夹下的所有文件名以列表的形式存到file_list里&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; file_list = os.listdir(base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(file_list)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开当前文件所在目录的settings.json文件&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;settings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f1:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     settings =&lt;span&gt; json.load(f1)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以写的形式打开一个workbook&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; my_workbook =&lt;span&gt; xlwt.Workbook()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_list:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     year = filename.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-2][:4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     date = filename.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-2][4:8&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从json文件中获取到每个项目的配置文件，然后下载相应的行到Excel里&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; setting &lt;span&gt;in&lt;/span&gt; settings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         project_name = filename.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_GHP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[0].split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSTJEC_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; project_name == setting[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             my_sheet = my_workbook.add_sheet(project_name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; date)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             with open(base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;filename) as f2:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 lines =&lt;span&gt; f2.readlines()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 step =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把所需要的数据写到Excel中&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; nums,line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(lines):
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; nums &lt;span&gt;in&lt;/span&gt; setting[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;download_line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         re_time = line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[6&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         out_file = line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         energy = line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[-2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         unit = line.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[10&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                        my_sheet.write(step,0,out_file)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         my_sheet.write(step,1&lt;span&gt;,re_time)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         my_sheet.write(step,2&lt;span&gt;,energy)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                         my_sheet.write(step,3&lt;span&gt;,unit)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         step += 1
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; my_workbook.save(base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/handle/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + year +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; cmep_to_excel.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行handle文件后，得到写入Excel文件的结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1254026/201712/1254026-20171224122854771-1331158645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;成功的写入了Excel文件，对于我们同事来说，这个是一个皆大欢喜的结果，但是他还需要进行数据处理，所以我们想，索性帮他用代码把数据处理也做了，最后我们就写了一个result的文件，把他想要的两个时间内的数据做差，然后再写入另一个Excel中，下面是代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd,xlwt
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,sys
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; base_dir = os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(base_dir)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;sys.path.append(base_dir)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; file_list = os.listdir(base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/handle/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(file_list)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; my_workbook =&lt;span&gt; xlwt.Workbook()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_list:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     date,project = filename.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)[0],filename.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; project == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cmep_to_excel.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         myworkbook = xlrd.open_workbook((base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/handle/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; filename))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         i =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         o = 1
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; o &amp;lt;&lt;span&gt; len(myworkbook.sheets()):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             frist_sheet =&lt;span&gt; myworkbook.sheets()[i]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             second_sheet =&lt;span&gt; myworkbook.sheets()[o]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             rows_num =&lt;span&gt; second_sheet.nrows
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(rows_num)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             my_sheet = my_workbook.add_sheet(frist_sheet.cell(0,0).value.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_GHP_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在每个表单的头一行添加表头&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             my_sheet.write(0,0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             my_sheet.write(0,1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             my_sheet.write(0,2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             my_sheet.write(0,3,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单位&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             m = 1
&lt;span&gt;35&lt;/span&gt;             n =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; rows_num:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 
&lt;span&gt;38&lt;/span&gt;                 out_file =&lt;span&gt; frist_sheet.cell(n,0).value
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 re_time = frist_sheet.cell(n,1&lt;span&gt;).value
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 energy1 = float(frist_sheet.cell(n,2&lt;span&gt;).value)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 unit = frist_sheet.cell(n,3&lt;span&gt;).value
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 energy2 = float(second_sheet.cell(n,2&lt;span&gt;).value)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 energy_output = energy2 -&lt;span&gt; energy1
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                my_sheet.write(m,0,out_file)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 my_sheet.write(m,1&lt;span&gt;,re_time)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 my_sheet.write(m,2&lt;span&gt;,energy_output)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 my_sheet.write(m,3&lt;span&gt;,unit)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;                 m +=1
&lt;span&gt;52&lt;/span&gt;                 n +=1
&lt;span&gt;53&lt;/span&gt;             i += 2
&lt;span&gt;54&lt;/span&gt;             o += 2
&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;         my_workbook.save(base_dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/handle/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + date + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; result.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后得到他想要的结果文件，以后对于他这趟差事来说，那不是简单到没朋友，自己运行几个代码，所有的东西过程都不用管，结果就有了，大大提升了工作效率，为我们几个同事点一个赞。&lt;/p&gt;
&lt;p&gt;其实还有一个弊端，也就是下次和老师碰的一个点，就是自己把几个模块，整合到一个Python文件中，自己运行一个文件，就把所有过程都跑完，也就是后面需要增加的内容。&lt;/p&gt;

&lt;p&gt;学习Python的时间还是有限，主要自己也不是干这个的，离自己理想还是有很大的差距，昨天晚上憋了4个小时，才把最后的result文件写玩，里面需要改进的地方还有很多，还需要努力。大家也跟一起努力把，你们的赞扬才是我努力的源泉，欢迎转发评论，欢迎批评指正。&lt;/p&gt;

</description>
<pubDate>Sun, 24 Dec 2017 04:31:00 +0000</pubDate>
<dc:creator>黄舒砚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zpzcy/p/8097734.html</dc:identifier>
</item>
<item>
<title>【微服务】之六：轻松搞定SpringCloud微服务-API网关zuul - 千万之路刚开始</title>
<link>http://www.cnblogs.com/hyhnet/p/8097635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyhnet/p/8097635.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通过前面几篇文章的介绍，我们可以轻松搭建起来微服务体系中比较重要的几个基础构建服务。那么，在本篇博文中，我们重点讲解一下，如何将所有微服务的API同意对外暴露，这个就设计API网关的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本系列教程&quot;&gt;本系列教程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hyhnet/p/7998751.html&quot;&gt;【微服务】轻松搞定SpringCloud微服务目录&lt;/a&gt;&lt;br/&gt;本系列为连载文章，阅读本文之前强烈建议您先阅读前面几篇。&lt;/p&gt;
&lt;h2 id=&quot;网关名称解释&quot;&gt;网关名称解释&lt;/h2&gt;
&lt;p&gt;网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。&lt;/p&gt;
&lt;h2 id=&quot;api网关名词解释&quot;&gt;API网关名词解释&lt;/h2&gt;
&lt;p&gt;API Gateway（API GW / API 网关），顾名思义，是出现在系统边界上的一个面向API的、串行集中式的强管控服务，这里的边界是企业IT系统的边界。&lt;br/&gt;在微服务流行之前，API GW的实体就已经诞生了，这时的主要应用场景是OpenAPI，也就是开放平台，面向的是企业外部合作伙伴，对于这个应用场景，相信接触的人会比较多。当在微服务概念流行起来之后，API网关似乎成了在上层应用层集成的标配组件。&lt;/p&gt;
&lt;h2 id=&quot;spring-cloud-zuul-简介&quot;&gt;Spring Cloud Zuul 简介&lt;/h2&gt;
&lt;p&gt;Zuul 是Netflix 提供的一个开源组件,致力于在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。也有很多公司使用它来作为网关的重要组成部分。Spring Cloud 体系收录的该模块，主要用于提供动态路由、监控、安全控制、限流配额等，可以将内部微服务API同意暴露。&lt;/p&gt;
&lt;h2 id=&quot;博文系统架构&quot;&gt;博文系统架构&lt;/h2&gt;
&lt;p&gt;根据我们微服务整体的一个架构设计，本系列博文也主要是对整个微服务架构进行落地示范。通过一组架构比较可以更加深入理解网关的概念。&lt;/p&gt;
&lt;h3 id=&quot;传统互联网架构&quot;&gt;传统互联网架构&lt;/h3&gt;
&lt;p&gt;在没有微服务的架构体系当中，我们一般使用Nginx作为负载分发、反向代理，形成一个API网关的一个构建。架构图如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-a4967e589f2ae477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;微服务下网关模式&quot;&gt;微服务下网关模式&lt;/h3&gt;
&lt;p&gt;在spring cloud 体系当中，我们将内部的服务全部进行隐藏，对外只有一个对外暴露的机制，这就是spring cloud zuul 网关。架构图如下所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-f8825ee11eadcd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们在深入一些，去兼容一些以前公司旧的非微服务系统也可以是这样：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-942f025b0c050593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始起飞&quot;&gt;开始起飞&lt;/h2&gt;
&lt;p&gt;同样，起飞之前，建议阅读前面几篇文章，方便代码理解与使用。&lt;/p&gt;
&lt;h3 id=&quot;创建网关子项目&quot;&gt;创建网关子项目&lt;/h3&gt;
&lt;p&gt;我们在原来的父类项目下创建一个子项目。（可以参考我GitHub代码结构）&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-3b2df1b9ac549313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置pom文件&quot;&gt;配置POM文件&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-zuul&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建配置文件application.yml&quot;&gt;创建配置文件application.yml&lt;/h4&gt;
&lt;p&gt;resources 文件夹下面创建文件application.yml,配置清单如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;co&quot;&gt;#服务注册中心配置&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;eureka:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;client:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;service-url:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;defaultZone:&lt;/span&gt; http://localhost:8081/eureka/
  &lt;span class=&quot;fu&quot;&gt;instance:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;appname:&lt;/span&gt; api-gateway

&lt;span class=&quot;co&quot;&gt;#设置网关端口号&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8080

&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; api-getway&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建程序入口application.java&quot;&gt;创建程序入口application.java&lt;/h4&gt;
&lt;p&gt;为了方便，命名为GatewayApplication&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by Administrator on 2017/12/17.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 网关启动入口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableZuulProxy&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GatewayApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(GatewayApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;mailto:**@EnableZuulProxy*&quot;&gt;**@EnableZuulProxy*&lt;/a&gt;* 注解说明：@&lt;a href=&quot;mailto:EnableZuulProxy简单理解为@EnableZuulServer的增强版&quot;&gt;EnableZuulProxy简单理解为@EnableZuulServer的增强版&lt;/a&gt;，当Zuul与Eureka、Ribbon等组件配合使用时，&lt;a href=&quot;mailto:我们使用@EnableZuulProxy&quot;&gt;我们使用@EnableZuulProxy&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;启动并测试&quot;&gt;启动并测试&lt;/h4&gt;
&lt;p&gt;从上面的配置中，我们已经完成了基本的网关配置，那么我们就来做一个简单的测试。&lt;br/&gt;本次测试选择我微服务项目群中有三个服务：&lt;br/&gt;分别是：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;cloud-hyh-service-1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;cloud-service&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;8071&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;github&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cloud-hyh-discovery-eureka&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;discovery-service&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;8081&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;github&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cloud-hyh-api-gateway-zuul&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;api-gateway&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;8080&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;github&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;启动子服务&quot;&gt;启动子服务&lt;/h5&gt;
&lt;p&gt;分别启动注册中心、测试服务、api网关三个服务。我们可以观察服务注册中心已经可以看到其他两个服务会被注册。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-cdd07b4e400fb263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;访问api测试&quot;&gt;访问API测试&lt;/h5&gt;
&lt;p&gt;我们在cloud-service子项目中，之前已经做过一个测试的API,&lt;/p&gt;
&lt;p&gt;在没有网关之前，我们外部如果想要调用服务的花，就可以通过微服务自身的地址访问。但是有了API网关之后，我们可以将我们的服务地址对外暴露出去。&lt;/p&gt;
&lt;p&gt;访问地址： 网关地址/服务名/访问地址/&lt;br/&gt;&lt;a href=&quot;http://localhost:8080/cloud-service/ribbon/name&quot; class=&quot;uri&quot;&gt;http://localhost:8080/cloud-service/ribbon/name&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试成功&lt;br/&gt;浏览器中返回：&lt;br/&gt;&lt;strong&gt;千万之路刚开始-www.hanyahong.com-beijing该服务器端口8071&lt;/strong&gt;&lt;br/&gt;****&lt;br/&gt;说明：针对API网关还有很多参数需要配置，例如持久化、负载分发等。针对这一块我们后续还会进行专题细致深入。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;本文出处：&lt;a href=&quot;http://www.hanyahong.com/&quot; class=&quot;uri&quot;&gt;http://www.hanyahong.com/&lt;/a&gt;&lt;br/&gt;Github源码：&lt;a href=&quot;https://github.com/hanyahong/spring-cloud-microservice&quot; class=&quot;uri&quot;&gt;https://github.com/hanyahong/spring-cloud-microservice&lt;/a&gt;&lt;br/&gt;转发请注明出处！&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 03:32:00 +0000</pubDate>
<dc:creator>千万之路刚开始</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hyhnet/p/8097635.html</dc:identifier>
</item>
<item>
<title>跃迁|17年回顾、未来愿景、18年目标与价值思考 - 初开</title>
<link>http://www.cnblogs.com/wchukai/p/8097603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wchukai/p/8097603.html</guid>
<description>&lt;p&gt;人生就是如此奇妙，两月前还以为今年过得也就还不错，但没想到年底遇到了一群优秀得令人窒息的小伙伴，坐上了起飞的火箭，竟然变成了一个有理想，有目标，有规划的“三有青年”。&lt;/p&gt;
&lt;p&gt;回首过去工作的两年多，今年的成长超过了过去两年，而最近两月的成长超过了过去的一整年。而明年已然可以预料，这将是跃迁的开始。&lt;/p&gt;

&lt;p&gt;先回顾下这一年。&lt;/p&gt;
&lt;p&gt;1月份，参加了公司组织的TTT培训，系统学习了演讲，但同时也意识到自己表达能力的不足，根本无法完成一场比较完整的演讲。&lt;/p&gt;
&lt;p&gt;2月份，写完了拖了两个月的16年总结，意识到应该再多学点东西，&lt;strong&gt;从广度到深度构建一个个人的知识体系&lt;/strong&gt;，定下了今年的一些小目标。&lt;/p&gt;
&lt;p&gt;3月份，完成了一个从去年开始的大型改版项目，这是工作以来第一次承担一个大项目的设计，选型的工作，可惜经验不足，接手时工作才一年多点，很多都是临阵磨枪去学的，总体来说仅仅是完成了任务，现在回头看很多问题不应该出现。&lt;/p&gt;
&lt;p&gt;4、5月啥记录也没有，写作也断了，一篇技术博客都没写，2月份定下的小目标全部抛在脑后。&lt;/p&gt;
&lt;p&gt;6月底参加了一个写作班，这是第一次付费参加线上课程，又重新开始写作，并且把写作范围扩大到其他领域，不再专注于技术。&lt;/p&gt;
&lt;p&gt;7月底，第一次接触理财，花了9块钱报了个入门班，读了两本理财入门书，《小狗钱钱》和《30岁之前的每一天》，并一眼就看上了&lt;strong&gt;价值投资&lt;/strong&gt;，它就是我未来的投资理念。&lt;/p&gt;
&lt;p&gt;8月份，基于前面的积累，写了一篇文章《认知,构建个人的知识体系(上)》，第一次明确表示要构建一个知识体系，并回答了要&lt;strong&gt;构建一个涵盖自我认知，通用能力，以及专业能力的知识体系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样是8月底，搭上了leon的车，加入一个小圈子，第一次亲眼看到人究竟可以有多么优秀。我们平时常调侃自己的梦想是成为CEO，走上人生巅峰，&lt;strong&gt;但有一天你发现，你所谓的未来的巅峰，不过是人家的起点时，那就是我当时的感受。&lt;/strong&gt; 看到这样的场景，有人会选择无视，放弃，反正是两个世界的，可以不产生交集，而有人会尝试去跟上他们的脚步。我选择了后者，并通过他们的一些分享，来规划自己要做什么。&lt;/p&gt;
&lt;p&gt;还是8月份，开始了一个新的大型项目，接触到了一个全新的技术栈，主动承担了其中一些任务，在技术方面有了更全面的认识。&lt;/p&gt;
&lt;p&gt;9月份到10月份一直处于工作忙碌期，还是抽空略读了《高效能人士的七个习惯》，并对其中的要事第一，积极主动等原则有了一些思考和行动。&lt;/p&gt;
&lt;p&gt;10月底，读完了《穷查理宝典》，除了进一步坚定了自己价值投资的理念之外，让我最震撼的是芒格先生的&lt;strong&gt;多元化思维&lt;/strong&gt;，这让我意识到人与人的差距本质上是思维的差距，应该训练自己的思维能力。我对知识体系的看法也变为了&lt;strong&gt;思维能力，通用能力和专业能力&lt;/strong&gt;三个部分。&lt;/p&gt;
&lt;p&gt;11月份，写了几篇关于思维方式的文章，尤其是那篇关于马太效应的思考，一定程度上能解释自己的一些发展轨迹。虽然现在看来那些文章写得不怎么样，但那时候已经绞尽脑汁了，不过这反而也意味着现在的思维能力又上了一个台阶。&lt;/p&gt;
&lt;p&gt;11月份，加入了早餐王子的理财群，终于开始动手实践一些投资操作，理财这块终于入门了。最重要的是学会了&lt;strong&gt;如何做自我介绍&lt;/strong&gt;，学理财首先从自我介绍开始，当时我惊呆了，自我介绍还可以这么写。我现在公众号上的自我介绍就是从那时开始，并迭代了多次而来的，在这个过程中逐渐找到了自己的未来的定位，完全颠覆认知。&lt;/p&gt;
&lt;p&gt;11月份，王子在一次分享中无意中提到他花了上万找人帮他制定个人目标，大家都很惊讶，花这么多钱。但我意识到，能让人愿意花这么多钱，肯定没那么简单，稍微动了下手去搜索了资料，于是打开了另一个新世界的大门-&lt;strong&gt;个人目标管理&lt;/strong&gt;，并链接到了一个新的圈子。&lt;/p&gt;
&lt;p&gt;11月份，参加了另一群小伙伴组织的线下活动，第一次面对来自各行业的朋友，有很多思维的碰撞，自己以前的社交圈实在是太窄了。&lt;/p&gt;
&lt;p&gt;12月份，开始写自己的一本电子书《大型网站技术原理》，用于构建专业领域的知识体系。&lt;/p&gt;
&lt;p&gt;12月份，开始精读《如何阅读一本书》，在个人的思维能力里面添加了一个词-&lt;strong&gt;理解力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;12月份，参加了被我们亲切称为“老妈子”的永澄老师的目标管理课，又一次颠覆了我的认知。通过这堂课，&lt;strong&gt;我彻底完成了目前的个人定位，初步制定了18年全年目标，规划了3~5年的发展方向，并许下了个人的终生愿景。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;11~12月，加入了写作、理财、目标管理等多个社区，微信好友人数翻了一倍，链接了来自各行各业数百位新朋友，现在的朋友圈完全是不一样的风景。&lt;/p&gt;
&lt;p&gt;以上就是今年的一些关键事情了，大多集中在下半年，特别是后两个月，变化得太快了，用跃迁这个词再合适不过了。&lt;/p&gt;

&lt;p&gt;接下来打开下年初定下的小目标评个分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.工作上承担2个有挑战性的项目，并写好项目总结。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;60分，正好有两个比较大的项目，并且承担了其中的一部分关键任务，但项目总结偷懒了没有写。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2.写深度的博客，不是随笔，一篇/月，包含上面的项目总结。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;90分，年初的目标是写有深度的技术博客，然而上半年根本没写什么，下半年认知升级，不再专注于技术，回头来看，有深度的文章不少，但纯技术的不多。这90分打给自己的多次认知升级的文章，思维能力的提升才是最重要的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.在公司进行技术分享，2次以上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;60分，还是做了三五次分享的，而我的本意是锻炼演讲能力，从最近的复盘来看，并没有达到想要的效果，后面要继续。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4.早睡早起，23：00-06：00。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;60分，上半年把目标全忘了，下半年才逐渐进入状态，对半分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;5.健身，按计划来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;50分，计划是美好的，现实是残酷的，保持住不容易。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;8.出去旅行2次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;90分，跟小伙伴逛的几个地方都不错，只是国庆太忙，少去了一个地方。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;9.撩妹0/1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;0分，尴尬，这个目标还是继续挂着吧，给自己点盼头。&lt;/p&gt;

&lt;p&gt;眼界决定境界，能够看到未来的人，才能更好的定位现在。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（一）终身愿景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;成为一名具备多元化思维，能够洞察事物本质，喜欢讲故事的跨界专家。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这个愿景，我的个人解读如下：&lt;/p&gt;
&lt;p&gt;多元化思维源于《穷查理宝典》，&lt;strong&gt;这是让人拥有大视野，保持好奇心，不愚昧保守，永远与时俱进的源泉。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;洞察力用《教父》的一句话来形容：&lt;strong&gt;花半秒钟就看透事物本质的人,和花一辈子都看不清事物本质的人,注定是截然不同的命运。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在彻底认知到个人的表达能力不足，但又无比重要，而喜欢讲故事是写作、沟通、演讲等表达能力的具象。&lt;/p&gt;
&lt;p&gt;很多人用“单纯”这个词来形容程序员，的确，我们搞软件开发的人太多沉迷于自己的世界，甚至标榜着技术是我们唯一的追求，在这里我觉得完全是一个贬义词，&lt;strong&gt;与其说“单纯”，不如说对外界的“无知”。&lt;/strong&gt; 如果当初某人能懂点法律，有一些思维意识，大概就不会被逼自杀了。所以，&lt;strong&gt;唯有主动跨界，才不会成为井底之蛙，遇到更好的人与机会。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专家则是核心定位，未来我仍会将大部分精力专注于计算机领域，可能会转向人工智能，但大方向不会变。这个选择在于，&lt;strong&gt;现在已经是计算机，以及由此组成的互联网的时代，随着人工智能的崛起，未来仍是计算机的时代，在这个时代，懂计算机的人有着天然的优势。&lt;/strong&gt; 只要抓住这个大趋势，不再仅仅是解决温饱问题，其他各方面的认知也不会落伍。&lt;/p&gt;
&lt;p&gt;有着这样一个终身愿景后，3~10年的愿景也就能回答出来了，看起来是在吹牛，不过人生最大的惊喜莫过于你以为只是吹牛，但后面全都实现了。&lt;/p&gt;
&lt;h2 id=&quot;h2--5-10-&quot;&gt;（二）5~10年愿景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;跨界专家，在金融、计算机、思维认知等多个领域有深入的见解。&lt;/li&gt;
&lt;li&gt;演讲家。&lt;/li&gt;
&lt;li&gt;寻找到个人事业的下一个发展点。&lt;/li&gt;
&lt;li&gt;年收入XXX，非工资性收入超过80%，工作完全不看薪资。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;h2--3-5-&quot;&gt;（三）3~5年愿景&lt;/h2&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1. 跨界知识体系&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;成为技术领域的专家，在网站开发，架构和人工智能上有一个完备的知识体系。&lt;/li&gt;
&lt;li&gt;掌握多种思维模型，能熟练运用于各种场景。&lt;/li&gt;
&lt;li&gt;专业的教练技术，在领导力，管理能力上有足够的积累，能流畅的完成一场演讲。&lt;/li&gt;
&lt;li&gt;在金融投资方面有自己的理解，践行价值投资。&lt;/li&gt;
&lt;li&gt;出版一本书。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h3-2-&quot;&gt;2.扩大社交圈&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;加满微信好友，直接链接一个5000人的高效能朋友圈。&lt;/li&gt;
&lt;li&gt;构建个人品牌，公众号弱连接50000人。&lt;/li&gt;
&lt;li&gt;遇到一个合适的人和强链接几位未来事业的伙伴。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h3-3-&quot;&gt;3. 财务&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;非工资性收入超过50%，不再以提高收入为工作目标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;饭还是要一口一口吃，将3年愿景落地到18年这一年，那核心目标就浮现出来了。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（一）核心目标&lt;/h2&gt;
&lt;p&gt;初步构建一个跨界的知识体系。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（二）核心目标拆解&lt;/h2&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1.思维能力&lt;/h3&gt;
&lt;h4 id=&quot;h4--1-&quot;&gt;（1）理解力&lt;/h4&gt;
&lt;p&gt;完成精读《如何阅读一本书》。&lt;/p&gt;
&lt;h4 id=&quot;h4--2-&quot;&gt;（2）思维模型&lt;/h4&gt;
&lt;p&gt;重读《穷查理宝典》，精读《系统之美》，整理50种思维模型，写好20篇分析。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2.专业能力&lt;/h3&gt;
&lt;h4 id=&quot;h4--1-&quot;&gt;（1）上半年-网站开发知识体系&lt;/h4&gt;
&lt;p&gt;上半年写完电子书《深入大型网站原理》，完成网站开发的知识体系。&lt;/p&gt;
&lt;h4 id=&quot;h4--2-&quot;&gt;（2）下半年-年中规划&lt;/h4&gt;
&lt;p&gt;年中视情况规划架构，java开发和人工智能方面的知识。&lt;/p&gt;
&lt;h3 id=&quot;h3-3-&quot;&gt;3.通用能力&lt;/h3&gt;
&lt;h4 id=&quot;h4--1-&quot;&gt;（1）演讲&lt;/h4&gt;
&lt;p&gt;完成12次演讲型分享，写好逐字稿，制作PPT，并做好复盘。&lt;/p&gt;
&lt;h4 id=&quot;h4--2-&quot;&gt;（2）教练领导力培训&lt;/h4&gt;
&lt;p&gt;年中继续参加教练技术培训，学习相关技巧，进一步提升演讲能力，并完成对应任务。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;通读完书架上未读完的书，在这之前不再买书。&lt;/li&gt;
&lt;li&gt;继续保持早起、健身、写作的习惯。&lt;/li&gt;
&lt;li&gt;年底非工资性收入超过20%。&lt;/li&gt;
&lt;li&gt;朋友圈扩大到1000人。&lt;/li&gt;
&lt;li&gt;与5位小伙伴线下探讨成长与目标。&lt;/li&gt;
&lt;li&gt;完善资产配置，掌握财报分析，完成一个周期的基金定投，投资一部分股票。&lt;/li&gt;
&lt;li&gt;参加5场线下活动。&lt;/li&gt;
&lt;li&gt;完成《终身目标制定计划》系列文章，跟进永澄老师目标管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有耐心看到这一段，没有认为我前面的是在吹牛的小伙伴，这里我再分享一下我对上面规划的个人思考。&lt;/p&gt;
&lt;p&gt;也就是用&lt;strong&gt;价值思维&lt;/strong&gt;的方式来回答，我为什么要制定这些目标，&lt;strong&gt;这些目标的价值是什么&lt;/strong&gt;，有什么用？&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（一）思维认知&lt;/h2&gt;
&lt;p&gt;首先是思维认知，我在很多地方都反复写到人与人之前的差距根本上是思维认知的差距。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1.关于认知&lt;/h3&gt;
&lt;p&gt;一个认知有关的例子是，某人由于长期吸烟，最后导致肺癌，然后感叹说“早知道当初戒烟就好了。”其实他并非不知道，而是没有认知到。&lt;/p&gt;
&lt;p&gt;同样的还有熬夜、酗酒等等，正常人都知道这些有害，但有因此停止熬夜，停止酗酒了吗？都知道运动对身体好，但有固定运动计划的人也不多，这些都是自我认知不够。&lt;/p&gt;
&lt;p&gt;还有一些表面的一些词，比如对未来迷茫，没有目标，执行力不够，拖延症，不自律。还有一些现象，比如沉迷游戏，定下早起目标从来没早起过，想减肥但一直在增肥。这些都是知道，但没有认知到的场景。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2. 关于思维&lt;/h3&gt;
&lt;p&gt;另一个思维方面的例子我想谈谈永澄老师给我们举的例子。&lt;/p&gt;
&lt;p&gt;很多人有定下读书计划，比如一年读100本书。怎么安排读呢？&lt;/p&gt;
&lt;p&gt;一般人的方式是每个月读10本，这样1年下来肯定能读够100本了。但有另外一种方式，就是首先用前3个月时间去学习《如何阅读一本书》，然后4月读10本，5月20本，6月30本，7月40本，读完100本。&lt;/p&gt;
&lt;p&gt;开始我还不信，当我精读完《如何阅读一本书》，别说主题阅读了，连检视阅读都不会，才意识读书这种从小开始做的事情就从来没走对过，前面的很多书真的是白读了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这甚至可以反思到我们现在的教育上面，我们的教育从来没有系统的思维方式的培养，更别提跨界思维能力了。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3-3-&quot;&gt;3.如何提升自己的思维和认知&lt;/h3&gt;
&lt;p&gt;我之前的方式很简单，就是&lt;strong&gt;链接比自己优秀十倍，百倍的朋友&lt;/strong&gt;，俗称抱大腿，看看他们平时如何思考的，在分享些什么，可以跟着学，但主要是跟着做。但如何链接到他们呢？更简单，花钱，付费去加入他们所在的社区，参加他们组织的活动，包括APP“在行”上面也有付费咨询。&lt;/p&gt;
&lt;p&gt;至于一开始看一些书反而会比较艰难，因为思维能力不够，很多书根本看不懂，我之前看《高效能人士的七个习惯》《穷查理宝典》之类的完全一头雾水，以为这是所谓的成功学书籍，都是忽悠人的。要想明白需要经历很多事情，但真有比自己厉害很多的人在给你分享这些时，感受就不一样了，会加速这一过程。&lt;/p&gt;
&lt;p&gt;我工作的前两年就处于这种独自摸索阶段，想明白构建个人知识体系这件事都花了一年，结果今年年底，链接了一群人，各种被颠覆认知，成长得飞快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在经历过几次颠覆认知后，就应该慢慢有自己的一些想法了，可以不用抱大腿了，再抱下去反而会失去思考能力，违背了初衷。比如像我现在这样有了自己的定位和规划，有足够的自驱力做自己的事情，不需要别人给你掌舵了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（二）专业能力&lt;/h2&gt;
&lt;p&gt;我的工作是网站开发，所以专业能力上给自己定下的目标是网站开发方面的知识体系。之所以有这个认知，应该归功于在工作不久就去旁听部门里的面试，然后慢慢转正变为面试官，在我的上一篇关于面试的文章谈到过这个经历。&lt;/p&gt;
&lt;p&gt;因此，虽然我现在工作不到三年，但我很清楚大部分工作三到七年的开发者拥有什么样的能力，一个扎心的事实是，在我眼里，大部分人并没有与年限对等的工作经验，即使工作这么多年，但很多人根本没有一个专业领域的知识体系。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;如果我能够构建这样的知识体系，直接来说，专业能力很容易就超过市面上90%以上的开发者，这样核心的竞争力就有了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用一个耳熟能详的故事来比喻。&lt;/p&gt;
&lt;p&gt;两个人在森林中游玩，看到一头熊跑出来，&lt;br/&gt;其中一个人把跑鞋拿出来了，&lt;br/&gt;另外一个人有点鄙夷对他说：哥们儿，别忙了，你跑不过熊！&lt;br/&gt;那个人信心满满地说：我不用跑得过熊，我只要比你跑得快就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一个行业，你不需要做到最好，只要比这个行业90%的人做得好就不会掉队。&lt;/strong&gt; 当然，首先是这个行业得有前景，看得到未来大趋势。&lt;/p&gt;
&lt;p&gt;至于架构或者人工智能则是未来的发展方向，有了一个在思维能力和专业方向的知识体系储备，在合适的时候直接切入就好了。&lt;/p&gt;
&lt;h2 id=&quot;h2-u901Au7528u80FDu529B&quot;&gt;通用能力&lt;/h2&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1.个人目标管理&lt;/h3&gt;
&lt;p&gt;通用能力中，我现在觉得最重要的是个人目标管理了，也就是前面给自己制定1年，3年，5年，乃至终身目标。没有目标，就没有方向。如果你认为我上面的内容不是在吹牛，想必就能理解这段话了。&lt;/p&gt;
&lt;p&gt;所以我强烈推荐没有目标的小伙伴加入永澄老师的个人目标管理队伍，当然，18年的目标课程已经过了，不过人生很长，可以先逛逛公众号，等19年的课程就好了。&lt;/p&gt;
&lt;p&gt;我自己今年也有一个小目标，&lt;strong&gt;在下半年要跟5名小伙伴一对一的交流成长与目标定位&lt;/strong&gt;，特别是没有目标和不知道成长的小伙伴，希望这不是在吹牛。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2.写作&lt;/h3&gt;
&lt;p&gt;回顾这一年，下半年遇到的人和事都是源于6月份那一场写作课，更早则源于2年前开始写的个人博客，写作的确是这个时代最好的自我投资。&lt;/p&gt;
&lt;h3 id=&quot;h3-3-&quot;&gt;3. 教练技术&lt;/h3&gt;
&lt;p&gt;正如同我们软件开发有开发技术一样，在培训，特别是企业培训方面，对应得技术被称之为教练技术。这个词的确是从体育运动中的各种篮球，足球教练演化而来。&lt;/p&gt;
&lt;p&gt;这是一门涉及领导力，管理能力，演讲，授课等等诸多技巧的课程，所以即使不做职业培训师，在日常工作，交流中，它是最实用的通用技能，没有之一。所以18年的重点就是突破教练技术。&lt;/p&gt;
&lt;h3 id=&quot;h3-u5C3Eu58F0&quot;&gt;尾声&lt;/h3&gt;
&lt;p&gt;写道这里发现自己写嗨了，都5000字了，我的天，强行结束干正事去了。&lt;/p&gt;
&lt;p&gt;放上今年的关键词：&lt;strong&gt;认知升级、多元化思维、写作、知识体系、个人目标管理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，我一向不喜欢打广告，所以各种社区的宣传图就不放了，太多人没有独立思考的能力，全靠头脑发热做事，我今年也交了不少智商税，有心的小伙伴你可以找到我的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我准备起飞了，你要不要来~&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://wchukai.com/&quot;&gt;初开&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发表于：&lt;a href=&quot;http://www.cnblogs.com/wchukai&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&quot;&gt;知识共享-署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt;许可协议发布，转载必须保留署名及链接。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 03:22:00 +0000</pubDate>
<dc:creator>初开</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wchukai/p/8097603.html</dc:identifier>
</item>
<item>
<title>【quickhybrid】H5和Native交互原理 - 撒网要见鱼</title>
<link>http://www.cnblogs.com/dailc/p/8097598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dailc/p/8097598.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Hybrid&lt;/code&gt;架构的核心就是&lt;code&gt;JSBridge&lt;/code&gt;交互，而实现这个交互的前提是弄清楚H5和Native端的交互&lt;/p&gt;
&lt;p&gt;本文主要介绍Native端（Android/iOS）和H5端（泛指前端）的交互原理&lt;br/&gt;（之前也整理过类似的文章，本系列重新梳理）&lt;/p&gt;
&lt;h2 id=&quot;native与h5交互的两种方式&quot;&gt;&lt;code&gt;Native&lt;/code&gt;与&lt;code&gt;H5&lt;/code&gt;交互的两种方式&lt;/h2&gt;
&lt;p&gt;原生和前端的交互有两种方式：&lt;code&gt;url scheme&lt;/code&gt;以及&lt;code&gt;JavaScriptCore&lt;/code&gt;（在Android中是&lt;code&gt;addJavascriptInterface&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;url scheme适用于所有的系统设备（低版本Android和低版本iOS都适用）&lt;/p&gt;
&lt;p&gt;但是url scheme毕竟是通过url拦截实现的，在大量数据传输，以及效率上都有影响&lt;/p&gt;
&lt;p&gt;另一种方法则在低版本中会有这样或那样的问题&lt;/p&gt;
&lt;p&gt;如JavaScriptCore不支持&lt;code&gt;iOS7&lt;/code&gt;以下，addJavascriptInterface在&lt;code&gt;4.2&lt;/code&gt;以前有风险漏洞&lt;/p&gt;
&lt;p&gt;当然了，时至今日，这些低版本造成的影响已经慢慢不再&lt;/p&gt;
&lt;h2 id=&quot;url-scheme交互&quot;&gt;url scheme交互&lt;/h2&gt;
&lt;p&gt;这个是最广为流传的交互方式，起因是因为在hybrid刚出来时，很多低版本都需要兼容，因此几乎都用的这种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一般清空下，url scheme是一种类似于url的链接,是为了方便app直接互相调用设计的&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;具体为,可以用系统的OpenURI打开一个类似于url的链接(可拼入参数),&lt;br/&gt;然后系统会进行判断,如果是系统的url scheme,则打开系统应用,&lt;br/&gt;否则找看是否有app注册这种scheme,打开对应app&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;需要注意的是,这种scheme必须原生app注册后才会生效,如微信的scheme为(weixin://)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;而本文中混合开发交互的url scheme则是仿照上述的形式的一种方式&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;具体为,由前端页面通过某种方式触发scheme(如用iframe.src),&lt;br/&gt;然后Native用某种方法捕获对应的url触发事件,然后拿到当前的触发url,&lt;br/&gt;根据定义好的协议,分析当前触发了那种方法,然后根据定义来执行等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;协议类似于：&lt;code&gt;quickhybrid://xxx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一般这种交互的url没有必要在原生app配置中注册&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注意⚠️： ️&lt;code&gt;iOS10&lt;/code&gt;以后，urlscheme必须符合url规范，否则会报错，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;基本原理：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;H5 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 触发一个url（每一个功能代表的url都不同）&lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; Native端捕获到url

&lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; Native端分析属于哪一个功能并执行 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; Native端调用H5中的方法将执行结果回调给H5&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://quickhybrid.github.io/staticresource/images/JSBridge_baseprinciple.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相比于其它方案的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Android4.2以下,addJavascriptInterface方式有安全漏掉&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;iOS7以下,JavaScriptCore无法使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以如果需要兼容这类型低版本的机型，url scheme方案是不二选择&lt;/p&gt;
&lt;h2 id=&quot;h5直接与native交互&quot;&gt;H5直接与Native交互&lt;/h2&gt;
&lt;p&gt;分别包括Android，iOS中H5和原生互相调用，总结如下：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;H5调Android-原生通过&lt;code&gt;addJavascriptInterface&lt;/code&gt;注册，然后H5直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Android调H5-原生通过&lt;code&gt;loadUrl&lt;/code&gt;来调用H5，&lt;code&gt;4.4&lt;/code&gt;及以上还可以通过&lt;code&gt;evaluateJavascript&lt;/code&gt;调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;H5调iOS-原生通过&lt;code&gt;JavaScriptCore&lt;/code&gt;注册（需&lt;code&gt;ios7&lt;/code&gt;以上），然后H5直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;iOS调H5-通过&lt;code&gt;stringByEvaluatingJavaScriptFromString&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;H5调Android：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，原生webview需要先注册可供前端调用的JS函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; WebSettings webSettings &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;mWebView&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getSettings&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
 &lt;span class=&quot;co&quot;&gt;// Android容器允许JS脚本，必须要&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;webSettings&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setJavaScriptEnabled&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Android容器设置侨连对象&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;mWebView&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addJavascriptInterface&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;getJSBridge&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;JSBridge&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Android4.2版本及以上，本地方法要加上注解@JavascriptInterface，否则会找不到方法。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object &lt;span class=&quot;at&quot;&gt;getJSBridge&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
    Object insertObj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Object&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
        @JavascriptInterface
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;  

        @JavascriptInterface
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;at&quot;&gt;foo2&lt;/span&gt;(final String param)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;foo2:&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; param&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;  

    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;  
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; insertObj&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后H5中即可调用原生中注册的函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 调用方法一&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JSBridge&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 返回:'foo'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 调用方法二&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JSBridge&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;foo2&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 返回:'foo2:test'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在Android&lt;code&gt;4.2&lt;/code&gt;以上(api17后),暴露的api要加上注解&lt;code&gt;@JavascriptInterface&lt;/code&gt;，否则会找不到方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在api17以前,addJavascriptInterface有风险,hacker可以通过反编译获取Native注册的Js对象，&lt;br/&gt;然后在页面通过反射Java的内置静态类，获取一些敏感的信息和破坏&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Android调H5：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;4.4&lt;/code&gt;版本之前&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 即当前webview对象     &lt;/span&gt;
mWebView &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;WebView&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;       
&lt;span class=&quot;va&quot;&gt;mWebView&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;loadUrl&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;javascript: 方法名('参数,需要转为字符串')&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;co&quot;&gt;// ui线程中运行&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;runOnUiThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Runnable&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
        @Override  
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;run&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  
            &lt;span class=&quot;va&quot;&gt;mWebView&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;loadUrl&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;javascript: 方法名('参数,需要转为字符串')&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
            &lt;span class=&quot;va&quot;&gt;Toast&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;makeText&lt;/span&gt;(Activity名.&lt;span class=&quot;at&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;调用方法...&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Toast&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;LENGTH_SHORT&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;show&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;4.4&lt;/code&gt;及以后（包括）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 异步执行JS代码,并获取返回值    &lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;mWebView&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;evaluateJavascript&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;javascript: 方法名('参数,需要转为字符串')&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ValueCallback&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;String&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        @Override
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;onReceiveValue&lt;/span&gt;(String value) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 这里的value即为对应JS方法的返回值&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;4.4之前Native通过loadUrl来调用JS方法,只能让某个JS方法执行,但是无法获取该方法的返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;4.4及之后,通过evaluateJavascript异步调用JS方法,并且能在onReceiveValue中拿到返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;mWebView.loadUrl(&quot;javascript: 方法名('参数,需要转为字符串')&quot;);&lt;br/&gt;函数需在UI线程运行，因为mWebView为UI控件(但是有一个坏处是会阻塞UI线程)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;H5调iOS：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;OC&lt;/code&gt;为例&lt;/p&gt;
&lt;p&gt;首先，需要引入&lt;code&gt;JavaScriptCore&lt;/code&gt;库&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;#import &lt;span class=&quot;kw&quot;&gt;&amp;lt;JavaScriptCore&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;/JavaScriptCore.h&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后原生需要注册API&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//webview加载完毕后设置一些js接口&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;void&lt;/span&gt;)webViewDidFinishLoad&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;(UIWebView &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;)webView&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    [self hideProgress]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    [self setJSInterface]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;void&lt;/span&gt;)setJSInterface&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

    JSContext &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;context &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[_wv &lt;span class=&quot;dt&quot;&gt;valueForKeyPath&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;@&lt;span class=&quot;st&quot;&gt;&quot;documentView.webView.mainFrame.javaScriptContext&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 注册名为foo的api方法&lt;/span&gt;
    context[@&lt;span class=&quot;st&quot;&gt;&quot;foo&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;^&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;//获取参数&lt;/span&gt;
        NSArray &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;args &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [JSContext currentArguments]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        NSString &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [NSString &lt;span class=&quot;dt&quot;&gt;stringWithFormat&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;@&lt;span class=&quot;st&quot;&gt;&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;[args &lt;span class=&quot;dt&quot;&gt;objectAtIndex&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//做一些自己的逻辑&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//返回一个值  'foo:'+title&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; [NSString &lt;span class=&quot;dt&quot;&gt;stringWithFormat&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;@&lt;span class=&quot;st&quot;&gt;&quot;foo:%@&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; title]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
    
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后前端就可以调用了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 调用方法,用top是确保调用到最顶级,因为iframe要用top才能拿到顶级&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;top&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 返回:'foo:test'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;引入官方提供的JavaScriptCore库(iOS7中出现的)，然后可以将api绑定到JSContext上&lt;br/&gt;(然后Html中JS默认通过window.top.*（&lt;code&gt;iframe&lt;/code&gt;中时需加&lt;code&gt;top&lt;/code&gt;）可调用)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;iOS7之前，js无法直接调用Native,只能通过urlscheme方式间接调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;iOS调H5：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 可以取得JS函数执行的返回值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 方法必须是Html页面绑定在最顶层的window上对象的&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 如window.top.foo&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Swift&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;webview&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stringByEvaluatingJavaScriptFromString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;方法名(参数)&quot;&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;// OC&lt;/span&gt;
[webView stringByEvaluatingJavaScriptFromString&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;@&lt;span class=&quot;st&quot;&gt;&quot;方法名(参数);&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Native调用JS方法时,能拿到JS方法的返回值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有iframe时，需要获取顶层窗口的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;返回根目录&quot;&gt;返回根目录&lt;/h2&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;github&lt;/code&gt;上这个框架的实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/quickhybrid/quickhybrid&quot;&gt;quickhybrid/quickhybrid&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 03:18:00 +0000</pubDate>
<dc:creator>撒网要见鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dailc/p/8097598.html</dc:identifier>
</item>
<item>
<title>使用.Net Core+EF7 CodeFirst（2） - 步尘</title>
<link>http://www.cnblogs.com/Onlooker/p/8097588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Onlooker/p/8097588.html</guid>
<description>&lt;p&gt;上一篇的话，说了下怎么使用EF7 实现 CodeFirst去生成数据库，&lt;/p&gt;
&lt;p&gt;其实还有好多问题的，这次一点一点的解决吧，都挺简单，不过零零散散的，，&lt;/p&gt;
&lt;p&gt;1.读取配置文件，获得链接字符串&lt;/p&gt;
&lt;p&gt;2.使用数据库进行增删查改&lt;/p&gt;
&lt;p&gt;3.实体类更新后，数据库也更新&lt;/p&gt;


&lt;p&gt;上一篇我们的链接字符串是这样写的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224095007303-772662346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接写在程序里面是非常非常不好的行为，所以我很简单粗暴的丢到&lt;strong&gt;appsettings.json&lt;/strong&gt;这个配置文件里面去了，，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IncludeScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=.;Database=DBCodeFirst;uid=sa;pwd=12346&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，要愁的是怎么把配置读出来，而且，既然是配置文件，肯定整个项目都要用上，肯定是要封装起来的，&lt;/p&gt;
&lt;p&gt;网上也找了很多啊，各种各样的， 有些大佬还可以直接读取成一个对象，这里我不搞那些骚操作啊，，，emmm，不会告诉你们我看不懂的&lt;/p&gt;
&lt;p&gt;走最简单的，键值对，就像以前读取webconfig文件一样，&lt;/p&gt;
&lt;p&gt;首先需要引用三个包，直接右键编辑&lt;strong&gt;commom.csproj&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Extensions.Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Extensions.DependencyInjection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Extensions.Options.ConfigurationExtensions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224100730068-1610377354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后新建一个类&lt;strong&gt;Config&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Common
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置类
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Config
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 所有的配置数据
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfigurationRoot Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获得数据
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;_Configuration&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetConfig(IConfigurationRoot _Configuration)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             Configuration =&lt;span&gt; _Configuration;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回对应键的值
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;键&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;def&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;默认值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetVal&amp;lt;T&amp;gt;(string key, T def = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(T))
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 def = (T)Convert.ChangeType(Configuration.GetSection(key).Value, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(T));
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                Debug.WriteLine(e.Message);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; def;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后还要进行一下配置，在&lt;strong&gt;Startup.cs&lt;/strong&gt;文件的&lt;strong&gt;Startup&lt;/strong&gt;方法改造一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             IConfigurationRoot config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                  .SetBasePath(Directory.GetCurrentDirectory())
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                   .AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                  .Build();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            Config.SetConfig(config);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方法很简单的，一句话就好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据库连接字符串&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; conStr = Config.GetVal&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为现在的配置文件是json格式，所以，层级结构是肯定会有的，比如说，我现在要读取Logging下的IncludeScopes值，可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;          &lt;span&gt;string&lt;/span&gt; IncludeScopes = Config.GetVal&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging:IncludeScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以此类推，，，这样肯定没其他大佬们直接读取成对象来得快，不过好在简单易懂，以后等我学会了那种高大上的方法再来分享，，现在先就酱紫用着，，&lt;/p&gt;

&lt;p&gt;这一段主要是吐槽，，&lt;/p&gt;
&lt;p&gt;以前我们使用EF，不管是DBFirst还是CodeFirst，亦或者ModelFirst，要使用数据库都是很简单粗暴的new一个上下文对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据库上下文&lt;/span&gt;
2    &lt;span&gt;var&lt;/span&gt; DB=&lt;span&gt;new&lt;/span&gt; DBCodeFirst();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然鹅！！！！！！！当我用CodeFirst把数据库生成以后，喜滋滋的跑过去加一条测试数据，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             DBCodeFirst db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DBCodeFirst();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             db.DT_User.Add(&lt;span&gt;new&lt;/span&gt; DT_User { UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;嘿嘿&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; db.SaveChanges();&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他丫的给我报错，，，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224103436146-1398675932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;翻译过来就是这个，，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
没有数据库提供商已为这个DbContext。&lt;br/&gt;一个供应商可以通过重写dbcontext.onconfiguring方法或使用adddbcontext对应用服务提供商配置。&lt;br/&gt;如果adddbcontext使用，并确保你的DbContext类型构造函数接受dbcontextoptions &amp;lt; tcontext &amp;gt;对象并将其传递给DbContext基构造函数。”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 反正我是没看懂的，，，永远不知道当时我的心情是多么的难受，&lt;/p&gt;
&lt;p&gt;又是一阵百度啊，可算是被我找到解决方法了，，，得这样写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224103954553-949767054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲真，我还没接触到依赖注入，所以这段代码看的是有点懵逼的，&lt;/p&gt;
&lt;p&gt;好像关联的是&lt;strong&gt;Startup&lt;/strong&gt;这个类里面的&lt;strong&gt;ConfigureServices&lt;/strong&gt;方法，哪位大佬有兴致的话可以给我留言讲讲，感激不尽&lt;/p&gt;
&lt;p&gt;不过好歹是可以用数据库了，，下一步是搭一个三层，，一筹莫展ing，，，&lt;/p&gt;
&lt;p&gt;以前是可以直接new上下文，现在不行了，还不知道这个依赖注入能不能在其他层使用，，&lt;/p&gt;
&lt;p&gt;等我把三层整出来之后，再写出来分享吧，，估计是下一篇了&lt;/p&gt;

&lt;p&gt;这个的话首先&lt;a href=&quot;http://www.cnblogs.com/Onlooker/p/8047176.html&quot; target=&quot;_blank&quot;&gt;回顾上一篇&lt;/a&gt;啊，&lt;/p&gt;
&lt;p&gt;在上一篇里面用了两个命令来生成数据库（DBLog我改成Init了，，这个随意，，）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Add-&lt;span&gt;Migration Init
&lt;/span&gt; &lt;span&gt;和
&lt;/span&gt; Update-DataBase Init
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在上下文中加了实体类或者修改了实体类字段，我们肯定是要更新数据库的，&lt;/p&gt;
&lt;p&gt;这个时候，我们在&lt;span&gt;已经生成数据库和&lt;strong&gt;Migrations&lt;/strong&gt;文件夹的前提下，&lt;span&gt;继续使用上面的两个命令&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不过这个时候要稍稍改动：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Add-&lt;span&gt;Migration UpData
和
Update&lt;/span&gt;-DataBase UpData
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得每次使用的时候，最后一个参数名称&lt;span&gt;&lt;strong&gt;千万不能一样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像我第一次使用的名称是&lt;strong&gt;Init &lt;/strong&gt;第一次更新数据库的时候，使用的是&lt;strong&gt;UpData&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以后肯定还会有更多的更新，每次都不能一样，比如：&lt;strong&gt;UpData01、&lt;/strong&gt;UpData02、&lt;strong&gt;UpData03、...&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时&lt;strong&gt;Migrations&lt;/strong&gt;文档会对应的增加内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224110711943-1057863866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库自动生成的&lt;strong&gt;__EFMigrationsHistory&lt;/strong&gt;表中也会有我们的数据库迁移记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/891962/201712/891962-20171224111101396-1820199438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;emmm，差不多就这些吧，，，&lt;/p&gt;
&lt;p&gt;我还得想办法把三层整出来，，，，脸滚键盘.gif&lt;/p&gt;

</description>
<pubDate>Sun, 24 Dec 2017 03:15:00 +0000</pubDate>
<dc:creator>步尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Onlooker/p/8097588.html</dc:identifier>
</item>
<item>
<title>从 Bridge 到 OVS，探索虚拟交换机 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8097439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8097439.html</guid>
<description>&lt;h2 id=&quot;linux-bridge&quot;&gt;Linux Bridge&lt;/h2&gt;
&lt;p&gt;和物理网络一样，虚拟网络要通信，必须借助一些交换设备来转发数据。因此，对于网络虚拟化来说，交换设备的虚拟化是很关键的一环。&lt;/p&gt;
&lt;p&gt;上文「&lt;a href=&quot;http://www.cnblogs.com/bakari/p/8037105.html&quot;&gt;网络虚拟化&lt;/a&gt;」已经大致介绍了 Linux 内核为了满足网络虚拟化的要求，实现了一套虚拟交换设备——Bridge。本文重点介绍下 Bridge 的加强版——Open vSwitch（OVS），并从 Bridge 过渡到 OVS 的缘由讲起，让大家有个全面的认识。&lt;/p&gt;
&lt;p&gt;借助 Linux Bridge 功能，同主机或跨主机的虚拟机之间能够轻松实现通信，也能够让虚拟机访问到外网，这就是我们所熟知的桥接模式，一般在装 VMware 虚拟机或者 VirtualBox 虚拟机的时候，都会提示我们要选择哪种模式，常用的两种模式是桥接和 NAT。&lt;/p&gt;
&lt;p&gt;NAT 也很好理解，可以简单理解为当虚拟机启用了 NAT 模式之后，宿主机便通过 DHCP 为其生成可以访问外网的 IP，当 VM 访问外网的时候，就可以用该 IP 访问，其实就是宿主机为其做了地址转换。更详细的内容请自行搜索了解。&lt;/p&gt;
&lt;p&gt;物理交换机有个重要的功能，就是虚拟局域网（VLAN），是对局域网（LAN）的软件化升级。一般，两台计算机通过一台交换机连接在一起就构成了一个 LAN。&lt;/p&gt;
&lt;p&gt;一个 LAN 表示一个广播域，这意味着这个 LAN 中的任何节点发的数据包，其他节点都能收到，这有两个问题，一个是容易形成广播风暴，造成网络拥塞，另一个是广播包无法隔离，比如节点 B 不想接收节点 A 的包，但节点 A 强行要发，这就有点说不过去了。&lt;/p&gt;
&lt;p&gt;解决这个问题的方案就是 VLAN，VLAN 能够对广播包进行有效隔离，它的做法是从软件上将交换机的端口虚拟出多个子端口，用 tag 来标记，相当于将交换机的端口划分多个 LAN，同一个 LAN 中的节点发出的数据包打上本 LAN 的 tag，这样，其他 LAN 中的节点就无法收到包，达到隔离的目的。&lt;/p&gt;
&lt;p&gt;Bridge 本身是支持 VLAN 功能的，如下图所示，通过配置，Bridge 可以将一个物理网卡设备 eth0 划分成两个子设备 eth0.10，eth0.20，分别挂到 Bridge 虚拟出的两个 VLAN 上，VLAN id 分别为 VLAN 10 和 VLAN 20。同样，两个 VM 的虚拟网卡设备 vnet0 和 vnet 1 也分别挂到相应的 VLAN 上。这样配好的最终效果就是 VM1 不能和 VM2 通信了，达到了隔离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224101134818-1527791519.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux Bridge + VLAN 便可以构成一个和物理交换机具备相同功能的虚拟交换机了。对于网络虚拟化来说，Bridge 已经能够很好地充当交换设备的角色了。&lt;/p&gt;
&lt;h2 id=&quot;ovs&quot;&gt;OVS&lt;/h2&gt;
&lt;p&gt;但是为什么还有很多厂商都在做自己的虚拟交换机，比如比较流行的有 VMware virtual switch、Cisco Nexus 1000V，以及 Open vSwitch。究其原因，主要有以下几点（我们重点关注 OVS）：&lt;/p&gt;
&lt;p&gt;1）方便网络管理与监控。OVS 的引入，可以方便管理员对整套云环境中的网络状态和数据流量进行监控，比如可以分析网络中流淌的数据包是来自哪个 VM、哪个 OS 及哪个用户，这些都可以借助 OVS 提供的工具来达到。&lt;/p&gt;
&lt;p&gt;2）加速数据包的寻路与转发。相比 Bridge 单纯的基于 MAC 地址学习的转发规则，OVS 引入流缓存的机制，可以加快数据包的转发效率。&lt;/p&gt;
&lt;p&gt;3）基于 SDN 控制面与数据面分离的思想。上面两点其实都跟这一点有关，OVS 控制面负责流表的学习与下发，具体的转发动作则有数据面来完成。可扩展性强。&lt;/p&gt;
&lt;p&gt;4）隧道协议支持。Bridge 只支持 VxLAN，OVS 支持 gre/vxlan/IPsec 等。&lt;/p&gt;
&lt;p&gt;5）适用于 Xen、KVM、VirtualBox、VMware 等多种 Hypervisors。&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;除此之外，OVS 还有很多高级特性，详情可以查阅官网自行了解。&lt;/p&gt;
&lt;p&gt;下面简单看下 OVS 的整体架构，如下图所示，OVS 在 Linux 用户态和内核态都实现了相应的模块，用户态主要组件有数据库服务 ovsdb-server 和守护进程 ovs-vswitchd。内核态中实现了 datapath 模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224101241412-2026587570.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中， ovs-vswitchd 和 datapath 共同构成了 OVS 的数据面，控制面由 controller 模块来完成，controller 一般表示的是 OpenFlow 控制器，在 OVS 中，它可以借由第三方来完成，只要支持 OpenFlow 协议即可。&lt;/p&gt;
&lt;p&gt;这里额外提一点，很多的一些产品级的虚拟交换机都是自身集成了控制器，比如 Cisco 1000V 的 Virtual Supervisor Manager(VSM)，VMware 的分布式交换机中的 vCenter，而 OVS 是把这个事交由第三方去做，这么做的意义还是比较大的，可以让自己的产品很好地融入到各种解决方案中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenFlow&lt;/strong&gt;&lt;br/&gt;OpenFlow 是控制面和数据面通信的一套协议，我们常常把支持 OpenFlow 协议的交换机称为 OpenFlow 交换机，控制器称为 OpenFlow 控制器，业界比较知名的 OpenFlow 控制器有 OpenDaylight、ONOS 等。&lt;/p&gt;
&lt;p&gt;OpenFlow 是一个独立的完整的流表协议，不依赖于 OVS，OVS 只是支持 OpenFlow 协议，有了支持，就可以使用 OpenFlow 控制器来管理 OVS 中的流表。OpenFlow 不仅仅支持虚拟交换机，某些硬件交换机也支持 OpenFlow 协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ovs-vswitchd&lt;/strong&gt;&lt;br/&gt;ovs-vswitchd 是 OVS 的核心组件，它和内核模块 datapath 共同构成了 OVS 的数据面。它使用 OpenFlow 协议与 OpenFlow 控制器通信，使用 OVSDB 协议与 ovsdb-server 通信，使用 netlink 和 datapath 内核模块通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ovsdb-server&lt;/strong&gt;&lt;br/&gt;ovsdb-server 是 OVS 轻量级的数据库服务，用于整个 OVS 的配置信息，包括接口、交换内容、VLAN 等，ovs-vswitchd 根据这些配置信息工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenFlow 控制器&lt;/strong&gt;&lt;br/&gt;OpenFlow 控制器可以通过 OpenFlow 协议连接到任何支持 OpenFlow 的交换机，比如 OVS 。控制器通过向交换机下发流表规则来控制数据流向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kernel Datapath&lt;/strong&gt;&lt;br/&gt;datapath 内核模块和 ovs-vswitchd 是相互协作工作的，datapath 负责具体的收发包，而 ovs-vswitchd 通过 controller 下发的流表规则指导 datapath 如何转发包。&lt;/p&gt;
&lt;p&gt;举个例子，datapath 从主机物理网卡 NIC 或者 VM 的 虚拟网卡 vNIC 收到包，如果是第一次收到包，datapath 不知道怎么处理这个包，于是将其丢给 ovs-vswitchd ， ovs-vswitchd 决定该如何处理这个包之后又丢给 datapath，datapath 根据 ovs-vswitchd 的指示执行相应的动作，是丢弃还是从哪个口传出去。同时，ovs-vswitchd 会让 datapath 缓存好这个包的动作，下次再来就可以直接执行动作。&lt;/p&gt;
&lt;p&gt;如果不是第一次收到包，就是按照之前缓存好的动作执行，这样极大地提高了数据处理的速度。&lt;/p&gt;
&lt;p&gt;本文先对 OVS 有个初步印象，下文再详细介绍 OVS 的其他组件。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224101735412-356930698.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 02:20:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8097439.html</dc:identifier>
</item>
<item>
<title>OpenCV探索之路（二十八）：Bag of Features(BoF)图像分类实践 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8097397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8097397.html</guid>
<description>&lt;p&gt;在深度学习在图像识别任务上大放异彩之前，词袋模型Bag of Features一直是各类比赛的首选方法。首先我们先来回顾一下PASCAL VOC竞赛历年来的最好成绩来介绍物体分类算法的发展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094358006-1636907443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上表我们可以发现，在2012年之前，词袋模型是VOC竞赛分类算法的基本框架，几乎所有算法都是基于词袋模型的，可以这么说，词袋模型在图像分类中统治了很多年。虽然现在深度学习在图像识别任务中的效果更胜一筹，但是我们也不要忘记在10年前，Bag of Features的框架曾经也引领过一个时代。那这篇文章就是要重温BoF这个经典框架，并从实践上看看它在图像物体分类中效果到底如何。&lt;/p&gt;
&lt;h2 id=&quot;bag-of-features理论浅谈&quot;&gt;Bag of Features理论浅谈&lt;/h2&gt;
&lt;p&gt;其实Bag of Features 是Bag of Words在图像识别领域的延伸，Bag of Words最初产生于自然处理领域，通过建模文档中单词出现的频率来对文档进行描述与表达。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094418412-1861584910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;词包模型还有一个起源就是纹理检测（texture recognition）,有些图像是由一些重复的基础纹理元素图案所组成，所以我们也可以将这些图案做成频率直方图，形成词包模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094433600-418663463.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;词包模型于2004年首次被引入计算机视觉领域，由此开始大量集中于词包模型的研究，在各类图像识别比赛中也大放异彩，逐渐形成了由下面4部分组成的标准物体分类框架：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;底层特征提取&lt;/li&gt;
&lt;li&gt;特征编码&lt;/li&gt;
&lt;li&gt;特征汇聚&lt;/li&gt;
&lt;li&gt;使用SVM等分类器进行分类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2005年第一届PASCAL VOC竞赛 数据库包含了4类物体：摩托车、自行车、人、汽车，训练集加验证集一共684张图像，测试集包含689张图像，数据规模相对较少。从方法上说，采用“兴趣点-SIFT地城特征描述-向量量化编码直方图-支持向量机”得到了最好的物体分类性能，这种方法也就是我们今天所讲的Bag of Features方法。&lt;/p&gt;
&lt;p&gt;为什么要用BOF模型描述图像？&lt;/p&gt;
&lt;p&gt;SIFT特征虽然也能描述一幅图像，但是每个SIFT矢量都是128维的，而且一幅图像通常都包含成百上千个SIFT矢量，在进行相似度计算时，这个计算量是非常大的，更重要的是，每一幅图提取到的SIFT特征点数目都不一样，所以我们要将这些特征量化（比如生成统计直方图），这样才能进行相似度计算。通行的做法是用聚类算法对这些矢量数据进行聚类，然后用聚类中的一个簇代表BOF中的一个视觉词，将同一幅图像的SIFT矢量映射到视觉词序列生成码本，这样每一幅图像只用一个码本矢量来描述，这样计算相似度时效率就大大提高了。&lt;/p&gt;
&lt;p&gt;搭建Bag-of-Features的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;特征提取（在这里我们使用很稳定的SIFT算子）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094502396-595948650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094520365-1754313830.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;K-means聚类。将第一步提取到的特征向量及进行聚类，得出N个类心。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094532865-1968535858.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094553678-1171225318.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;量化特征，形成词袋&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094613553-749101050.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;统计每一类别的视觉单词出现频率，形成视觉单词直方图&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094632303-348220300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.训练SVM分类器&lt;/p&gt;
&lt;h2 id=&quot;实践篇&quot;&gt;实践篇&lt;/h2&gt;
&lt;p&gt;要编码实现BoF，其实只需严格按照上述讲的步骤进行就可以了，而且OpenCV给我们准备了关于BoF的相关API，所以实现起来的难度进一步降低。现在我们要思考的的是，怎么把opencv所提供的的这些API重新整合在一起，来构成一个分类能力还不错的图像分类器。&lt;/p&gt;
&lt;p&gt;今天还是以票据分类任务为例子讲解BoF模型。&lt;/p&gt;
&lt;p&gt;先观察数据集，我们已经分出了训练集和测试集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094648037-356667374.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一类图片放在不同的文件夹下面，文件夹的名字就是这个类别的label&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094701568-959079759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我们要分类的12种票据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094720662-292386312.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一特征提取&quot;&gt;一、特征提取&lt;/h3&gt;
&lt;p&gt;对底层特征，我们选择的还是最为经典的SIFT特征，用opencv做SIFT特征提取只需要用到几个API就可以了。&lt;/p&gt;
&lt;p&gt;我们还是老套路，先准备好一些提取SIFT特征的数据结构和描述SIFT的一些类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//create Sift feature point extracter
static Ptr&amp;lt;FeatureDetector&amp;gt; detector1(new SiftFeatureDetector());
//create Sift descriptor extractor
static Ptr&amp;lt;DescriptorExtractor&amp;gt; extractor(new SiftDescriptorExtractor);


//To store the keypoints that will be extracted by SIFT
vector&amp;lt;KeyPoint&amp;gt; keypoints;
//To store the SIFT descriptor of current image
Mat descriptor;
//To store all the descriptors that are extracted from all the images
Mat featuresUnclustered;
//The SIFT feature extractor and descriptor
SiftDescriptorExtractor detector;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们对我们的训练样本进行遍历，对每一类的训练图片进行SIFT特征提取，并将提取出来的特征存进featuresUnclustered里，用于接下来的k-means聚类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*第一步，计算目录下所有训练图片的features，放进featuresUnclustered*/
printf(&quot;step1:sift features extracting...\n&quot;);
for (int num = 1; num &amp;lt; MAX_TRAINING_NUM; num++)
{
    
    sprintf(filename, &quot;.\\training\\%d\\train.txt&quot;, num);
    //首先先检查一下该类文件夹下有没有用于train的特征文件，有的话就不需要提取特征点了
    if (_access(filename, 0) == -1)
    {
        printf(&quot;extracting features %d class\n&quot;, num);
        for (int i = 1; i &amp;lt;= MAX_TRAINING_NUM; i++)
        {
            sprintf(filename, &quot;.\\training\\%d\\%d.jpg&quot;, num, i);
            //create the file name of an image
            //open the file
            input = imread(filename, CV_LOAD_IMAGE_GRAYSCALE); //Load as grayscale      
            if (input.empty())
            {
                break;
            }
            //resize:reduce keypoints numbers to accerlate
            resize(input, input, Size(), 0.5, 0.5);
            //detect feature points
            detector.detect(input, keypoints);
            printf(&quot;keypoints:%d\n&quot;, keypoints.size());
            //compute the descriptors for each keypoint
            detector.compute(input, keypoints, descriptor);
            //save descriptor to file
            char train_name[32] = { 0 };
            sprintf(train_name, &quot;.\\training\\%d\\train.txt&quot;, num);
            WriteFeatures2File(train_name, descriptor);
            //put the all feature descriptors in a single Mat object 
            featuresUnclustered.push_back(descriptor);
            //train_features[num][i].push_back(descriptor);

        }
    }
    else
    {
        Mat descriptor;
        load_features_from_file(filename, descriptor);
        featuresUnclustered.push_back(descriptor);
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，我在特征提取阶段把每一类提取到的特征都写进了txt文件中，只是为了以后增加类别时，我们不再需要再次遍历提取特征，而只需读入我们原先存有特征向量的txt文件就可以了，这将大大加快训练速度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int load_features_from_file(const string&amp;amp; file_name,Mat&amp;amp; features)
{
    FILE* fp = fopen(file_name.c_str(), &quot;r&quot;);
    if (fp == NULL)
    {
        printf(&quot;fail to open %s\n&quot;, file_name.c_str());
        return -1;
    }
    printf(&quot;loading file %s\n&quot;, file_name.c_str());

    vector&amp;lt;float&amp;gt; inData;
    while (!feof(fp))
    {
        float tmp;
        fscanf(fp, &quot;%f&quot;, &amp;amp;tmp);
        inData.push_back(tmp);
    }

    //vector to Mat
    int mat_cols = 128;
    int mat_rows = inData.size() / 128;
    features = Mat::zeros(mat_rows, mat_cols, CV_32FC1);
    int count = 0;
    for (int i = 0; i &amp;lt; mat_rows; i++)
    {
        for (int j = 0; j &amp;lt; mat_cols; j++)
        {
            features.at&amp;lt;float&amp;gt;(i, j) = inData[count++];
        }
    }

    return 0;
}

static int WriteFeatures2File(const string&amp;amp; file_name,const Mat&amp;amp; features)
{
    FILE* fp = fopen(file_name.c_str(), &quot;a+&quot;);
    if (fp == NULL)
    {
        printf(&quot;fail to open %s\n&quot;, file_name.c_str());
        return -1;
    }

    for (int i = 0; i &amp;lt; features.rows; i++)
    {
        for (int j = 0; j &amp;lt; features.cols; j++)
        {
            int data = features.at&amp;lt;float&amp;gt;(i, j);
            fprintf(fp, &quot;%d\t&quot;, data);
        }
        fprintf(fp,&quot;\n&quot;);
    }

    fclose(fp);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二特征聚类&quot;&gt;二、特征聚类&lt;/h3&gt;
&lt;p&gt;我们将上一步得到的训练集的所有特征进行聚类，聚类初始化方式选择means++，类心数量选择1000。这里需要说明一下，聚类的类心数量是一个超参数，是一个需要反复调整的参数，如果类心过少，那就表示BOF模型的视觉单词数目很少，即该模型的表达能力很低，很可能在分类任务中不能区分出每一类物体（有点像Deep Learning中说的欠拟合）；但类心过多，就会造成视觉单词过于分散，很可能导致模型在泛化效果不佳（过拟合）。所以，选择一个合理的类心数目很重要。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*第二步，定义好聚类的中心数目，进行聚类，并得到词典dictionary*/
printf(&quot;step2:clusting...\n&quot;);
int dictionarySize = 1000;  //类心数目，即codebook num
//define Term Criteria
TermCriteria tc(CV_TERMCRIT_ITER, 1000, 0.001);  //最大迭代1000次
//retries number
int retries = 1;
//necessary flags
int flags = KMEANS_PP_CENTERS;  //kmeans++初始化
//Create the BoW (or BoF) trainer
BOWKMeansTrainer bowTrainer(dictionarySize, tc, retries, flags);
//cluster the feature vectors
Mat dictionary = bowTrainer.cluster(featuresUnclustered);  //聚类
//store the vocabulary
FileStorage fs(&quot;.\\dictionary1.yml&quot;, FileStorage::WRITE); //将聚类后的结果写入文件
fs &amp;lt;&amp;lt; &quot;vocabulary&quot; &amp;lt;&amp;lt; dictionary;
fs.release();
cout &amp;lt;&amp;lt; &quot;Saving BoW dictionary\n&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个聚类时间还是比较长的，大概需要20分钟。&lt;/p&gt;
&lt;h3 id=&quot;三量化特征形成词典直方图&quot;&gt;三、量化特征，形成词典直方图&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/*第三步，计算每个类别的词典直方图*/
printf(&quot;step3:generating dic histogram...\n&quot;);
//create a nearest neighbor matcher
Ptr&amp;lt;DescriptorMatcher&amp;gt; matcher(new FlannBasedMatcher);
//create Sift feature point extracter
Ptr&amp;lt;FeatureDetector&amp;gt; detector1(new SiftFeatureDetector());
//create Sift descriptor extractor
Ptr&amp;lt;DescriptorExtractor&amp;gt; extractor(new SiftDescriptorExtractor);
//create BoF (or BoW) descriptor extractor
BOWImgDescriptorExtractor bowDE(extractor, matcher);
//Set the dictionary with the vocabulary we created in the first step
bowDE.setVocabulary(dictionary);

cout &amp;lt;&amp;lt; &quot;extracting histograms in the form of BOW for each image &quot; &amp;lt;&amp;lt; endl;
Mat labels(0, 1, CV_32FC1);
Mat trainingData(0, dictionarySize, CV_32FC1);
int k = 0;
vector&amp;lt;KeyPoint&amp;gt; keypoint1;
Mat bowDescriptor1;
Mat img2;
//extracting histogram in the form of bow for each image 
for (int num = 1; num &amp;lt;= MAX_TRAINING_NUM; num++)
{
    for (int i = 1; i &amp;lt;= MAX_TRAINING_NUM; i++)
    {
        sprintf(filename, &quot;.\\training\\%d\\%d.jpg&quot;, num,i);

        //sprintf(filename, &quot;%d%s%d%s&quot;, j, &quot; (&quot;, i, &quot;).jpg&quot;);
        img2 = cvLoadImage(filename, 0);

        if (img2.empty())
        {
            break;
        }

        resize(img2, img2, Size(), 0.5, 0.5);

        detector.detect(img2, keypoint1);

        bowDE.compute(img2, keypoint1, bowDescriptor1);

        trainingData.push_back(bowDescriptor1);

        labels.push_back((float)num);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四训练svm&quot;&gt;四、训练SVM&lt;/h3&gt;
&lt;p&gt;我们使用SVM作为分类器进行训练，训练好的数据以文件的形式存储下来，以后预测时直接读文件就可以还原模型了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*第四步，训练SVM得到分类模型*/
printf(&quot;SVM training...\n&quot;); 
CvSVMParams params;
params.kernel_type = CvSVM::RBF;
params.svm_type = CvSVM::C_SVC;
params.gamma = 0.50625000000000009;
params.C = 312.50000000000000;
params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER, 1000, 0.000001);
CvSVM svm;

bool res = svm.train(trainingData, labels, cv::Mat(), cv::Mat(), params);

svm.save(&quot;.\\svm-classifier1.xml&quot;);

delete[] filename;
printf(&quot;bag-of-features training done!\n&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六预测&quot;&gt;六、预测&lt;/h3&gt;
&lt;p&gt;首先我们需要载入我们训练好的数据（svm-classifier1.xml和dictionary1.yml）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//字典文件、SVM训练文件读入内存
void TrainingDataInit()
{
    FileStorage fs(&quot;.\\dictionary1.yml&quot;, FileStorage::READ);
    Mat dictionary;
    fs[&quot;vocabulary&quot;] &amp;gt;&amp;gt; dictionary;
    fs.release();

    bowDE.setVocabulary(dictionary);

    svm.load(&quot;.\\svm-classifier1.xml&quot;);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再写一个预测函数，用SVM实现线上分类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//实现发票图像的分类，返回值即预测的分类结果
int invoice_classify(Mat&amp;amp; img)
{
    Mat img2 = img.clone();
    resize(img2, img2, Size(), 0.5, 0.5);
    cvtColor(img2, img2, CV_RGB2GRAY);
    SiftDescriptorExtractor detector;
    vector&amp;lt;KeyPoint&amp;gt; keypoint2;
    Mat bowDescriptor2;

    Mat img_keypoints_2;

    detector.detect(img2, keypoint2);

    bowDE.compute(img2, keypoint2, bowDescriptor2);

    int it = svm.predict(bowDescriptor2);

    return it;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在开始测试，写一个测试函数，读入测试集进行预测，计算其准确率&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TestClassify()
{
    int total_count = 0;
    int right_count = 0;
    string tag;
    for (int num = 1; num &amp;lt; 30; num++)
    {
        for (int i = 1; i &amp;lt; 30; i++)
        {
            char path[128] = { 0 };
            sprintf(path, &quot;.\\test\\%d\\%d.jpg&quot;, num, i);
            Mat img = imread(path,0);
            if (img.empty())
            {
                continue;
            }
            int type = invoice_classify(img);
            if (type == -1)
            {
                printf(&quot;reject image %s\n&quot;, path);
                continue;
            }

            total_count++;
            
            if (num == type)
            {
                tag = &quot;CORRECT&quot;;
                right_count++;
            }
            else
            {
                tag = &quot;WRRONG&quot;;
            }
            printf(&quot;[%s]  label: %d   predict: %d, %s\n&quot;, path, num, type, tag.c_str());
        }
    }

    printf(&quot;total image:%d  acc:%.2f\n&quot;, total_count,(float)right_count/total_count);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的流程如下：先建立BoF模型，然后更新训练数据，将训练参数保存至文件。当线上预测时，先将训练参数读入内存，再利用模型对图片进行分类。模拟测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;bof.h&quot;


int main()
{
    BuildDictionary(12,6);
    
    TrainingDataInit();
    TestClassify();

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094757678-1222184700.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预测结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094808131-1810527984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，BoF模型在这种简单分类任务的效果还可以，更重要的是我每一类只用了6张训练样本（小样本集）就可以有这个效果了，如果是采用深度学习做分类，这个估计不行了。&lt;/p&gt;
&lt;h3 id=&quot;再优化&quot;&gt;再优化&lt;/h3&gt;
&lt;p&gt;总体而言，2005年提出来的Bag-of-Features的分类效果并不是很好，尤其是一些比较像的类别，它的区分能力还是不足的。那能不能可以做哪些优化进一步提升分类准确率呢？我觉得可以从以下几点入手试一试：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kmeans类心数目调整&lt;/li&gt;
&lt;li&gt;增加每一类训练图片的数目&lt;/li&gt;
&lt;li&gt;可以加入颜色特征，比如颜色直方图。个人认为这个措施会有较大效果，因为SIFT特征点提取时，图片已经是灰度图了，所以颜色这个很重要的特征并没有用上。&lt;/li&gt;
&lt;li&gt;加入一些全局特征做特征融合，因为SIFT是局部特征，所以如果有一些全局特征作为补充的话，效果会有比较好的提升。&lt;/li&gt;
&lt;li&gt;空间域金字塔思路（CVPR2006）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171224094831428-122178098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的代码可以在&lt;a href=&quot;https://github.com/AstarLight/Bag-of-Features-Framework&quot;&gt;我的github&lt;/a&gt;上获取。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;在今天看来，曾经引领过一个时代的Bag-of-Features在普通分类任务上并没有取得让人满意的效果，但我估计它在场景分类或图像检索上还是会比较出色（比如地标）。现在已经全面进入深度学习的时代了，BoF的概念越来越淡出人们的视野，但BoF模型在某些应用场景还是很有潜力的。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 01:49:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8097397.html</dc:identifier>
</item>
</channel>
</rss>