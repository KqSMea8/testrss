<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python函数小结 - 程非</title>
<link>http://www.cnblogs.com/guo970910/p/9942262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guo970910/p/9942262.html</guid>
<description>&lt;p&gt;&lt;span&gt;函数总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【def】 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 定义一个函数    f()  调用这个函数        f 只是相当于调用一个函数对象，返回的是一个函数的内存地址,要搞清楚这一点，这样会对以后高阶函数的理解有帮助&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def f():
    print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
f()


运行结果：
ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【参数】&lt;/p&gt;
&lt;p&gt;给函数添加参数：1。 普通的参数       2。默认参数    3.不定长参数&lt;/p&gt;
&lt;p&gt;【默认参数】&lt;/p&gt;
&lt;p&gt;一般默认参数放在最后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
def f(name,age=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;):
    print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am {name} I am {age}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(name=name,age=&lt;span&gt;age)
f(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


运行结果：
I am Tom I am &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【不定长参数】&lt;/p&gt;
&lt;p&gt;1 无命名的不定长参数       &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
def add(*&lt;span&gt;args):  #不定参数无命名
    sum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
        sum&lt;/span&gt;+=&lt;span&gt;i
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum
sum &lt;/span&gt;=add(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
print sum


运行结果：
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;



#当你添加的是列表时

def a(&lt;/span&gt;*&lt;span&gt;args):
    print args
a(&lt;/span&gt;*[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;])  #####单个添加到元组####


运行结果：

(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2。有命名的不定长参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
def login(**&lt;span&gt;kwargs):    #有命名
    print kwargs
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; kwargs:
        print i
login(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,age=&lt;span&gt;19&lt;/span&gt;,sex=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;man&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


运行结果：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;man&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
age
name
sex



def b(&lt;/span&gt;**&lt;span&gt;kwargs):
    print kwargs
b(&lt;/span&gt;**{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}) ######键值对方式添加到字典####


运行结果：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【return】 &lt;/p&gt;
&lt;p&gt;结束函数，返回某个对象&lt;/p&gt;
&lt;p&gt;如果未在函数中指定return,那这个函数的返回值为None  &lt;/p&gt;
&lt;p&gt;可以返回多个对象 ，默认放到一个元组中&lt;/p&gt;

&lt;p&gt;【作用域】&lt;/p&gt;
&lt;p&gt;总共可以划分为Legb&lt;/p&gt;
&lt;p&gt;built_in (系统定义)   　　　　global(全局变量)    　　　　enclosing（嵌套变量）   　　      local（局部变量）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
count = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
# count &lt;/span&gt;=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
def &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; count    ##申明全局变量
    count&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;          ##当全局变量不可变时，局部变量不可修改，除非申明全局变量
    # count.append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)    ##当是可变的类型时，内部可以对他进行修改
    print count
&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;()


运行结果：
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 【高阶函数】&lt;/p&gt;
&lt;p&gt;高阶函数是至少满足下列一个条件的函数:&lt;/p&gt;
&lt;p&gt;1.接受一个或多个函数作为输入&lt;/p&gt;
&lt;p&gt;2.输出一个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def f(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n*&lt;span&gt;n
def foo(a,b,fn):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fn(a)+&lt;span&gt;fn(b)  ####fn()就是运行这个f()函数######
print foo(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,f)  ######f就是一个函数的内存地址######

def f():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
def fun():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f
ter&lt;/span&gt;=&lt;span&gt;fun()     #####只是得到f函数的内存地址######
print ter
print ter()   ####只要加上括号就代表运行这个函数，所以就是运行f()这个函数


运行结果：
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&amp;lt;function f at &lt;span&gt;0x00000000026CEBA8&lt;/span&gt;&amp;gt;
&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【递归函数】&lt;/p&gt;
&lt;p&gt;定义：简单的可以概括为：调用自己的函数+结束条件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;######递归求阶乘#####

def f(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; n*f(n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)   #####调用自己，结束条件
print f(&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)

print reduce(lambda a,b:a&lt;/span&gt;*b ,range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;))     #之后会讲到这几个重要的内置函数，现在只是了解会有更简单的方法来实现递归


运行结果：
&lt;/span&gt;&lt;span&gt;5040&lt;/span&gt;
&lt;span&gt;5040&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【斐波那契数列】&lt;/p&gt;
&lt;p&gt;可以很好地解释递归函数，好好理解一下斐波那契数列，后边会以这个数列来讲解生成器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def f(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n&amp;lt;=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; f(n-&lt;span&gt;1&lt;/span&gt;)+f(n-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)

print f(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)


运行结果：
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【内置函数】&lt;/p&gt;
&lt;p&gt;py2内置函数：https://docs.python.org/3.5/library/functions.html#repr&lt;/p&gt;
&lt;p&gt;几个重要的内置函数：&lt;/p&gt;
&lt;p&gt;1。filetr(function,squence) 　　对sequence中的item依次执行function(item)，将执行结果为True的item做成一个filter object的迭代器返回。可以看作是过滤函数。&lt;/p&gt;
&lt;p&gt;2。map(function,squence) 　　对sequence中的item依次执行function(item)，将执行结果组成一个map object迭代器返回.map也支持多个sequence，这就要求function也支持相应数量的参数输入：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3。reduce(function,squence) 　　对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4.。lambda&lt;/em&gt;(function,squence)　　匿名函数的命名规则，用lamdba 关键字标识，冒号（：）左侧表示函数接收的参数（a,b） ,冒号（：）右侧表示函数的返回值（a+b）。因为lamdba在创建时不需要命名，所以，叫匿名函数　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#filter
str &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
def func(s):
    #print s
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; s !=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s
let &lt;/span&gt;=&lt;span&gt; filter(func,str)
print list(let)

#map
str &lt;/span&gt;= [ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
def fun2(s):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alvin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ret &lt;/span&gt;=&lt;span&gt; map(fun2, str)
print(ret)  # map object的迭代器
print(list(ret))  # [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aalvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;balvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;calvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dalvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

#reduce
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; functools import reduce
def add1(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y
print (reduce(add1, range(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;101&lt;/span&gt;)))  ## &lt;span&gt;5050&lt;/span&gt; （注：&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;+...+&lt;span&gt;100&lt;/span&gt;&lt;span&gt;）
print (reduce(add1, range(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;101&lt;/span&gt;), &lt;span&gt;20&lt;/span&gt;))  ## &lt;span&gt;5070&lt;/span&gt; （注：&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;+...+&lt;span&gt;100&lt;/span&gt;+&lt;span&gt;20&lt;/span&gt;&lt;span&gt;）

#lambda
#普通函数
def add(a, b):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b
print add(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
# 匿名函数
add &lt;/span&gt;= lambda a, b: a +&lt;span&gt; b
print add(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)



运行结果：
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aalvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;balvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aalvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;balvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;5070&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【装饰器函数】&lt;/p&gt;
&lt;p&gt;1.闭包的概念：a）有一个内部函数   　　b）引用一个外部变量&lt;/p&gt;
&lt;p&gt;2.装饰器的作用：遵守开放，闭合的原则，在不修改原来的代码的基础上添加要求，调用的时候重新赋值相当于调用原来的函数， 不会影响其他对该函数的调用&lt;/p&gt;
&lt;p&gt;下面是两个例子来帮助理解装饰器，装饰器再python中十分的重要，如果这两个例子不能帮助你理解的话，你可以看一下大牛Yuan先生博客，里面讲的很通彻&lt;/p&gt;
&lt;p&gt;&lt;em&gt;例子1：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;计算函数运行的时间&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import time
def show_time(f):
    def &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(*x,**&lt;span&gt;y):
        start &lt;/span&gt;=&lt;span&gt; time.time()
        f(&lt;/span&gt;*x,**&lt;span&gt;y)
        end &lt;/span&gt;=&lt;span&gt; time.time()
        print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spend time:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(end-&lt;span&gt;start)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;
@show_time    # f&lt;/span&gt;=&lt;span&gt;show_time(f)
def f(&lt;/span&gt;*a,**&lt;span&gt;b):
    sums&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a:
        sums&lt;/span&gt;+=&lt;span&gt;i
    print sums
    time.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
f(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)



运行结果：
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;
spend time:&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子2&lt;/p&gt;
&lt;p&gt;增加难度，再添加一个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import time
def log(flag):
    def show_time(f):            #&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.show_time（f，flag）
        def &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;(*x,**&lt;span&gt;y):
            start &lt;/span&gt;=&lt;span&gt; time.time()
            f(&lt;/span&gt;*x,**&lt;span&gt;y)
            end &lt;/span&gt;=&lt;span&gt; time.time()
            run &lt;/span&gt;= end-&lt;span&gt;start
            print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spend time:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(run)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; flag==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ji:
                    ji.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nspend time:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(run))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; show_time
@log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   #@out    &lt;span&gt;out&lt;/span&gt;(f) # &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.@封装的只能传一个参数，只要满足闭包的定义就能运行，返回值show_time，就相当于@show_time，
def f(&lt;/span&gt;*a,**b):    #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，不用@多加一个参数也可以
    sums&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a:
        sums&lt;/span&gt;+=&lt;span&gt;i
    print sums
    time.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
f(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)



运行结果：

&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;
spend time:&lt;/span&gt;&lt;span&gt;1.00099992752&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【列表生成式】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
print [ i*i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;&lt;span&gt;)]

运行结果：
[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;36&lt;/span&gt;, &lt;span&gt;49&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;, &lt;span&gt;81&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;121&lt;/span&gt;, &lt;span&gt;144&lt;/span&gt;, &lt;span&gt;169&lt;/span&gt;, &lt;span&gt;196&lt;/span&gt;, &lt;span&gt;225&lt;/span&gt;, &lt;span&gt;256&lt;/span&gt;, &lt;span&gt;289&lt;/span&gt;, &lt;span&gt;324&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【生成器（generator）】&lt;/p&gt;
&lt;p&gt;生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅&lt;/p&gt;
&lt;p&gt;生成器一定是迭代器，迭代器不一定是生成器&lt;/p&gt;
&lt;p&gt;生成器的创建：（）或 yield&lt;/p&gt;
&lt;p&gt;下边的斐波那契数列会让你更好的体会生成器，生成器的调用时用next()方法，生成器就是平常不会运行，只有调用的时候才会运行，而且因为python的回收机制，使得生成器在内存中只有自己的一条数据可以更好地对内存进行利用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
s=((x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;2&lt;/span&gt;)))   #&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;
print next(s)


运行结果：
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;


def fib(max):
    n,before,after &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; n&amp;lt;&lt;span&gt;max:
       # print after
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; after   #就成了生成器了
        before,after &lt;/span&gt;= after,before+&lt;span&gt;after
        n&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;=fib(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
print next(a)


运行结果：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 【生成器的send() 方法】&lt;/p&gt;
&lt;p&gt;send()方法是对yeild的前边的变量进行赋值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def f():
    print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    count &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    print count
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
b &lt;/span&gt;=&lt;span&gt; f()
next(b)
ret &lt;/span&gt;=b.send(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   #可以给yeild前边的变量赋值
print ret


运行结果：
aa
bb
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【迭代器】&lt;/p&gt;
&lt;p&gt;定义L: 1.有iter方法 2.有next方法&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;for 内部做的三件事： 1。调用可迭代对象的iter方法，返回一个迭代器对象 2.不断调用next方法 3处理StopIteration异常&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 07:39:00 +0000</pubDate>
<dc:creator>程非</dc:creator>
<og:description>函数总结 【def】 定义一个函数 f() 调用这个函数 f 只是相当于调用一个函数对象，返回的是一个函数的内存地址,要搞清楚这一点，这样会对以后高阶函数的理解有帮助 【参数】 给函数添加参数：1。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guo970910/p/9942262.html</dc:identifier>
</item>
<item>
<title>从零打造在线网盘系统之Hibernate配置O/R映射 - jimisun</title>
<link>http://www.cnblogs.com/jimisun/p/9942068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimisun/p/9942068.html</guid>
<description>&lt;blockquote readability=&quot;11.842105263158&quot;&gt;
&lt;p&gt;欢迎浏览&lt;a href=&quot;https://www.cnblogs.com/jimisun/p/9936579.html&quot;&gt;Java工程师SSH教程从零打造在线网盘系统系列教程&lt;/a&gt;,本系列教程将会使用SSH(Struts2+Spring+Hibernate)打造一个在线网盘系统,本系列教程是从零开始,所以会详细以及着重地阐述SSH三个框架的基础知识,第四部分将会进入项目实战,如果您已经对SSH框架有所掌握,那么可以直接浏览第四章,源码均提供在&lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk&quot;&gt;&lt;strong&gt;GitHub/ssh-network-hard-disk&lt;/strong&gt;&lt;/a&gt;上供大家参阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇学习要求&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主键映射&lt;/li&gt;
&lt;li&gt;普通属性映射&lt;/li&gt;
&lt;li&gt;组件映射&lt;/li&gt;
&lt;li&gt;一对一关联映射&lt;/li&gt;
&lt;li&gt;多对一单向关联映射&lt;/li&gt;
&lt;li&gt;多对一双向关联映射&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主键映射&quot;&gt;主键映射&lt;/h3&gt;
&lt;p&gt;注解配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XML配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;id name=&quot;id&quot; column=&quot;id&quot;&amp;gt;
        &amp;lt;!-- 主键的生成策略 --&amp;gt;
        &amp;lt;generator class=&quot;identity&quot;/&amp;gt;
    &amp;lt;/id&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hiberante主键生成策略 http://www.cnblogs.com/hoobey/p/5508992.html&lt;/p&gt;
&lt;h3 id=&quot;普通属性映射&quot;&gt;普通属性映射&lt;/h3&gt;
&lt;p&gt;注解配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Basic
    @Column(nullable = true)
    private String username;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XML配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;!-- 配置其他的属性 --&amp;gt;
   &amp;lt;property name=&quot;username&quot; column=&quot;username&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件映射&quot;&gt;组件映射&lt;/h3&gt;
&lt;p&gt;注解配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;组件类
    @Embeddable
    public class Name {
        ...
    }
组件属性
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = &quot;firstName&quot;, column = @Column(name = &quot;firstName&quot;))
            @AttributeOverride(name = &quot;lastName&quot;, column = @Column(name = &quot;lastName&quot;))
    })
    private Name name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;XML配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;component name=&quot;name&quot; class=&quot;com.jimisun.domain.Name&quot;&amp;gt;
        &amp;lt;property name=&quot;first&quot; column=&quot;first&quot;/&amp;gt;
        &amp;lt;property name=&quot;last&quot; column=&quot;last&quot;/&amp;gt;
    &amp;lt;component&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一对一关联映射&quot;&gt;一对一关联映射&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AHibernate/2.Hibernate%E6%98%A0%E5%B0%84&quot;&gt;一对一小节完整示例源码下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;XML配置(模拟商品和商品详情)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;商品hbm.xml配置
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-mapping PUBLIC
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-mapping&amp;gt;

    &amp;lt;!-- 配置类和表结构的映射 --&amp;gt;
    &amp;lt;class name=&quot;com.jimisun.domain.Product&quot; table=&quot;products&quot;&amp;gt;
        &amp;lt;!-- 配置id
            见到name属性，JavaBean的属性
            见到column属性，是表结构的字段
        --&amp;gt;
        &amp;lt;id name=&quot;id&quot; column=&quot;id&quot;&amp;gt;
            &amp;lt;!-- 主键的生成策略 --&amp;gt;
            &amp;lt;generator class=&quot;increment&quot;/&amp;gt;
        &amp;lt;/id&amp;gt;

        &amp;lt;!-- 配置其他的属性 --&amp;gt;
        &amp;lt;property name=&quot;name&quot; column=&quot;name&quot; type=&quot;java.lang.String&quot;/&amp;gt;

        &amp;lt;one-to-one name=&quot;productDetail&quot; class=&quot;com.jimisun.domain.ProductDetail&quot; cascade=&quot;all&quot;/&amp;gt;

    &amp;lt;/class&amp;gt;

&amp;lt;/hibernate-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;商品详情hbm.xml
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-mapping PUBLIC
        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-mapping&amp;gt;

    &amp;lt;!-- 配置类和表结构的映射 --&amp;gt;
    &amp;lt;class name=&quot;com.jimisun.domain.ProductDetail&quot; table=&quot;product_details&quot;&amp;gt;
        &amp;lt;!-- 配置id
            见到name属性，JavaBean的属性
            见到column属性，是表结构的字段
        --&amp;gt;
        &amp;lt;id name=&quot;id&quot; column=&quot;id&quot; type=&quot;int&quot;&amp;gt;

            &amp;lt;!-- 主键的生成策略 --&amp;gt;
            &amp;lt;generator class=&quot;foreign&quot;&amp;gt;
                &amp;lt;param name=&quot;property&quot;&amp;gt;product&amp;lt;/param&amp;gt;
            &amp;lt;/generator&amp;gt;
        &amp;lt;/id&amp;gt;

        &amp;lt;!-- 配置其他的属性 --&amp;gt;
        &amp;lt;property name=&quot;detatil&quot; column=&quot;detatil&quot;/&amp;gt;
        
        &amp;lt;one-to-one name=&quot;product&quot; class=&quot;com.jimisun.domain.Product&quot; constrained=&quot;true&quot;/&amp;gt;
        
    &amp;lt;/class&amp;gt;

&amp;lt;/hibernate-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多对一单向关联映射&quot;&gt;多对一单向关联映射&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AHibernate/2.Hibernate%E6%98%A0%E5%B0%84&quot;&gt;多对一单向关联映射完整示例源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们看完了一对一映射我们可以看一下多对一的的映射,这些都是在实际的应用开发中经常用到的,这里提到的单向映射就是单向映射关系,例多个订单和用户之间是多对一的映射关系,但是转换为Java对象来进行表示的时候就是,订单的对象中拥有其所属的用户对象,但是用户对象中并没有包含其拥有的订单,这种单向的映射关系就是单向映射,下面示例是多个订单和用户的单向关联关系表示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;配置多的一方
&amp;lt;many-to-one name=&quot;customer&quot; column=&quot;customer_id&quot; class=&quot;com.jimisun.domain.Customer&quot; cascade=&quot;all&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        Session session = HibernateSessionFactory.getSession();
        Transaction transaction = session.beginTransaction();
        Customer customer = new Customer();
        customer.setName(&quot;bea&quot;);
        Order order = new Order();
        order.setNumber(&quot;1333&quot;);
        order.setCustomer(customer);
        session.save(order);
        transaction.commit();
        Integer id = order.getId();
        Transaction transaction1 = session.beginTransaction();
        Order order1 = session.get(Order.class, id);
        if (order != null) {
            System.out.println(&quot;Customer:&quot; + order.getCustomer().getName());
            System.out.println(&quot;OrderNumber:&quot; + order.getNumber());
        }
        transaction1.commit();
        session.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多对一双向关联映射&quot;&gt;多对一双向关联映射&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jimisun123/ssh-network-hard-disk/tree/master/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AHibernate/2.Hibernate%E6%98%A0%E5%B0%84&quot;&gt;多对一双向关联映射完整示例源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多对一的双向关联其实是和多对一单向关联是相似的,我们只需要在一方(这里是指用户)对象中增加一个集合用来存储其订单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private Set&amp;lt;Order&amp;gt; orders = new HashSet&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再在用户对应的hbm.xml文件中对上述set集合进行配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      &amp;lt;set name=&quot;orders&quot; cascade=&quot;save-update,delete&quot; order-by=&quot;order_number asc&quot; lazy=&quot;true&quot;&amp;gt;
            &amp;lt;key column=&quot;customer_id&quot;/&amp;gt;
            &amp;lt;one-to-many class=&quot;com.jimisun.domain.Order&quot;/&amp;gt;
    &amp;lt;/set&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;本章总结&quot;&gt;本章总结&lt;/h3&gt;
&lt;p&gt;对象关系映射是Hibernate的核心,如何配置映射关系更是必会的技能,所以大家务必要掌握&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 06:56:00 +0000</pubDate>
<dc:creator>jimisun</dc:creator>
<og:description>欢迎浏览Java工程师SSH教程从零打造在线网盘系统系列教程,本系列教程将会使用SSH(Struts2+Spring+Hibernate)打造一个在线网盘系统,本系列教程是从零开始,所以会详细以及着重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimisun/p/9942068.html</dc:identifier>
</item>
<item>
<title>寄存器与代码段 - driveby</title>
<link>http://www.cnblogs.com/KKSJS/p/9939908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KKSJS/p/9939908.html</guid>
<description>&lt;p&gt;汇编语言系列学习笔记：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/KKSJS/p/9901120.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;汇编语言初探&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;寄存器与代码段（本文）&lt;/li&gt;
&lt;li&gt;寄存器与数据段（待完成）&lt;/li&gt;
&lt;li&gt;寄存器与栈段（待完成）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在上一篇博文中主要介绍了学习汇编语言的一些必备知识。其中和这篇文章联系比较紧密的是内存地址单元与 CPU 的概念，不熟悉的可以先行阅读上一篇博文。&lt;/p&gt;
&lt;p&gt;在学习寄存器这两章内容的时候，首先要牢记一个观点：&lt;span&gt;&lt;strong&gt;&lt;span&gt;指令和数据在内存单元中没有任何区别，它们都是一些二进制信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU 在读取内存中二进制信息的时候，将有的信息看作指令，有的信息看作数据。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在接下来的三篇博文中将具体介绍 CPU 到底是根据什么来做出的这种区分的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、寄存器的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;寄存器是位于 CPU 内部的一种带有&lt;span&gt;&lt;strong&gt;&lt;span&gt;存储性质&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;的器件。寄存器在汇编语言中有着举足轻重的地位，&lt;strong&gt;&lt;span&gt;因为程序员可以通过改变寄存器中的内存来实现对 CPU 的控制&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;8086CPU 中总有有 14 种不同种类的寄存器，它们分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&lt;/p&gt;
&lt;p&gt;它们最大能存储 16bit 的数据。&lt;/p&gt;
&lt;p&gt;接下来的几篇文章将逐个的介绍这些寄存器的作用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）通用寄存器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8086CPU 中的通用寄存器有下面四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AX（accumulator）：累加寄存器，常用于运算。&lt;/li&gt;
&lt;li&gt;BX（base）：基址寄存器，常用于地址索引。&lt;/li&gt;
&lt;li&gt;CX（count）：计数寄存器。&lt;/li&gt;
&lt;li&gt;DX（data）：数据寄存器，常用于数据传递。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422608/201811/1422608-20181110171809278-941111805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，一个 16 位寄存器可以存储一个 16 位数据。由于 8086CPU 上一代的寄存器都是 8 位的，为了保证兼容性，一个 16 位通用寄存器通常还能当做两个独立的 8 位寄存器使用。&lt;/p&gt;
&lt;p&gt;比如，AX 可以分为 AH 和 AL，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422608/201811/1422608-20181110172612080-537567321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AX 的低 8 位（0 位 ~ 7 位）构成了 AL 寄存器，高 8 位（8 位 ~ 15 位）构成了 AH 寄存器。&lt;/p&gt;
&lt;p&gt;8086CPU 可以一次性处理这两种不同长度的数据，分别称为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字（word）：16 位&lt;/li&gt;
&lt;li&gt;字节（byte）：8 位&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（二）段寄存器和指针寄存器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8086CPU 中的段寄存器和指针寄存器有下面四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CS（code segment）：代码段寄存器&lt;/li&gt;
&lt;li&gt;DS（data segment）：数据段寄存器&lt;/li&gt;
&lt;li&gt;SS（stack segment）：栈段寄存器&lt;/li&gt;
&lt;li&gt;ES（extra segment）：附加段寄存器&lt;/li&gt;
&lt;li&gt;IP（instruction pointer）：指令指针寄存器&lt;/li&gt;
&lt;li&gt;SP（stack pointer）：栈指针寄存器&lt;/li&gt;
&lt;li&gt;BP（base pointer）：基址指针寄存器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 CS 和 IP 是本文着重要介绍的，其余的将在后面学习到。&lt;/p&gt;
&lt;p&gt;首先想一想 “ 段 ” 这个概念从何而来？这就要从 8086CPU 与内存之间的地址总线宽度说起了。&lt;/p&gt;
&lt;p&gt;8086CPU 的地址总线宽度是 20 位，即一次性可以传送 20 位的地址，理论上能达到 1MB 的寻址能力。但是我们上面介绍的寄存器最高也只有 16 位，无法直接生成 20 位的地址。&lt;/p&gt;
&lt;p&gt;为了不白白的浪费 4 位地址总线，在 8086CPU 中采用一种将两个 16 位地址合成一个 20 位地址的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422608/201811/1422608-20181110181123301-673995176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，在 8086 中是通过一个&lt;span&gt;&lt;strong&gt;地址加法器&lt;/strong&gt;&lt;/span&gt;来完成的这种转换：&lt;span&gt;&lt;strong&gt;物理地址（20 bit） = 段地址（16 bit） × 16 + 偏移地址（16 bit）&lt;/strong&gt;&lt;/span&gt;。其中段地址就存储在段寄存器中。而偏移地址则保存在指针寄存器中。&lt;/p&gt;
&lt;p&gt;这个公式隐含着两个注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为 段地址 × 16 的大小必然是 16 的倍数，所以一个段内存空间的起始地址必然也是 16 的倍数。&lt;/li&gt;
&lt;li&gt;因为偏移地址为 16 位，所以一个段的最大空间只有 2&lt;sup&gt;16&lt;/sup&gt; B = 64 KB。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有一个因果关系要明确：首先是因为 CPU 与内存之间的地址总线的宽度（1MB）高于 CPU 一次性能处理、传输、暂存的最大宽度（64KB），为了不浪费 CPU 的寻址能力，才会有 物理地址（20 bit） = 段地址（16 bit） × 16 + 偏移地址（16bit） 这样的一个转换机制。&lt;/p&gt;
&lt;p&gt;所以我在想，要是做个假设，CPU 中的寄存器都是 20 bit，或者地址总线只有 16 bit 的话，是不是也许就没有段地址这个说法了（这是我个人的思考，如果有不对的地方，烦请指正~）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、代码段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面讲了一些比较常用的寄存器，其中 CS 和 IP 寄存器是两个最为关键的寄存器，它们这两个寄存器中的值组合起来 CS：IP 表示了 CPU 当前要读取指令的地址。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;span&gt;在 8086PC 机中，任意时刻，CPU 将 CS：IP 指向的内容当做指令执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了接下来的讲解，先学习几条会用到的汇编指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mov ax，4E20H：将 4E20H 这个数送入寄存器 AX。&lt;/li&gt;
&lt;li&gt;add ax，1406H：将寄存器 AX 中的数值加上 1406H。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设现在有下面四条汇编指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mov ax，0123H&lt;/li&gt;
&lt;li&gt;mov bx，0003H&lt;/li&gt;
&lt;li&gt;mov ax，bx&lt;/li&gt;
&lt;li&gt;add ax，bx&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的机器指令为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B8H 23H 01H&lt;/li&gt;
&lt;li&gt;BBH 03H 00H&lt;/li&gt;
&lt;li&gt;89H D8H&lt;/li&gt;
&lt;li&gt;01H D8H&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在的一个编程需要是想让 CPU 顺序执行上面四条指令，可以将这四条指令的机器码存放在一组连续的、起始地址为 16 的倍数的一组内存单元中，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422608/201811/1422608-20181110204711961-2076869616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就定义了一个所谓的&lt;span&gt;代码段&lt;/span&gt;，这个代码段从内存的第 20000H 号单元开始，存放了 10 字节的指令。&lt;/p&gt;
&lt;p&gt;要想让 CPU 执行这段代码，首先需要将 CS 的内容置为 2000H，IP 的内容置为 0000H。这样 CPU 就从内存单元的 20000H 处开始执行。&lt;/p&gt;
&lt;p&gt;下面以一张动图来演示 CPU 执行第一条指令时 CPU 与内存的信息交互情况：&lt;/p&gt;
&lt;p&gt;（动图演示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422608/201811/1422608-20181110215447741-2128094291.gif&quot; alt=&quot;&quot;/&gt;　　　　　　　　　　　　　　　　&lt;/p&gt;
&lt;p&gt;这张动图清晰的展示了 CPU 是如何执行处于上面内存代码段中的第一条指令（隐藏了很多的细节）。由于指令的执行过程类似，加上制作动图比较耗费时间，就省略了剩余的三条指令的执行过程（- -！）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本篇博文首先介绍了 CPU 中的寄存器种类，通过一个&lt;span&gt;地址转换公式&lt;/span&gt;引出了两个重要的寄存器 CS 和 IP。有了这两个寄存器的功能做支持，就可以定义一个存放代码的代码段，并让 CPU 去执行这个代码段。&lt;/p&gt;
&lt;p&gt;最后还是引出文章开始的一句话：&lt;span&gt;指令和数据在内存中没有区别，它们都是一些二进制信息，把这些二进制信息看作指令还是数据，是让编程人员通过控制 CPU 中的寄存器来完成的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 06:13:00 +0000</pubDate>
<dc:creator>driveby</dc:creator>
<og:description>文章里附有一张动图，展示了 CPU 执行内存中的一条指令的大致过程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KKSJS/p/9939908.html</dc:identifier>
</item>
<item>
<title>spring mvc(4)处理模型数据 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9940917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9940917.html</guid>
<description>&lt;p&gt;&lt;strong&gt;处理模型数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC 提供了以下几种途径输出模型数据：&lt;/p&gt;
&lt;p&gt;– ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加&lt;/p&gt;
&lt;p&gt;　　模型数据&lt;/p&gt;
&lt;p&gt;– Map 及 Model: 入参为org.springframework.ui.Model、org.springframework.ui.&lt;/p&gt;
&lt;p&gt;　　ModelMap 或 java.uti.Map 时，处理方法返回时，Map&lt;/p&gt;
&lt;p&gt;　　中的数据会自动添加到模型中。&lt;/p&gt;
&lt;p&gt;– @SessionAttributes: 将模型中的某个属性暂存到&lt;/p&gt;
&lt;p&gt;　　HttpSession 中，以便多个请求之间可以共享这个属性&lt;/p&gt;
&lt;p&gt;– @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中&lt;/p&gt;


&lt;p&gt; 注：下面的代码均来自上一篇的注解代码之后的测试代码！！&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ModelAndView&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;控制器处理方法的返回值如果为 ModelAndView, 则其既&lt;/p&gt;
&lt;p&gt;包含视图信息，也包含模型数据信息。&lt;/p&gt;

&lt;p&gt; 添加模型数据:&lt;/p&gt;
&lt;p&gt;– MoelAndView addObject(String attributeName, Object&lt;/p&gt;
&lt;p&gt;attributeValue)&lt;/p&gt;
&lt;p&gt;– ModelAndView addAllObject(Map&amp;lt;String, ?&amp;gt; modelMap)&lt;/p&gt;

&lt;p&gt;设置视图:&lt;/p&gt;
&lt;p&gt;– void setView(View view)&lt;/p&gt;
&lt;p&gt;– void setViewName(String viewName)&lt;/p&gt;

&lt;p&gt;TestRequestMapping.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 　　@RequestMapping(&quot;/testModelAndView&quot;)
     public &lt;span&gt;ModelAndView&lt;/span&gt; testModelAndView(){
           
           String viewName=&quot;success&quot;;
           ModelAndView andView = new ModelAndView(viewName);
           andView.addObject(&quot;time&quot;, new Date());
           return andView;
     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;a href=&quot;springmvc/testModelAndView&quot;&amp;gt;testModelAndView&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;success.jsp;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     time:${requestScope.time}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110222956575-1168788337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：SpringMVC会把ModelAndView的model中数据放入到request域对象中&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; Map 及 Model&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Spring MVC 在内部使用了一个org.springframework.ui.Model 接口存储模型数据&lt;/p&gt;

&lt;p&gt;具体步骤&lt;/p&gt;
&lt;p&gt;– Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。&lt;/p&gt;

&lt;p&gt;– 如果方法的入参为 Map 或 Model 类型，Spring MVC 会将隐含模型的引用传&lt;/p&gt;
&lt;p&gt;　　递给这些入参。在方法体内，开发者可以通过这个入参对象访问到模型中的所有数&lt;/p&gt;
&lt;p&gt;　　据，也可以向模型中添加新的属性数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223059762-2145334479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目标方法可以添加Map类型（实际上是Model或者ModelMap类型）的参数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;TestRequestMapping.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@RequestMapping(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/testMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testMap(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map){
           map.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MrChengs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;indexjsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;springmvc/testMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;testMap&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;success.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
name:${requestScope.name}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223214135-347942175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;@SessionAttributes&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 只能放在类的上面&lt;/p&gt;

&lt;p&gt;若希望在多个请求之间&lt;span&gt;共用某个模型属性数据&lt;/span&gt;，则可以在&lt;/p&gt;
&lt;p&gt;控制器类上标注一个 @SessionAttributes, Spring MVC&lt;/p&gt;
&lt;p&gt;将在模型中对应的属性暂存到 HttpSession 中。&lt;/p&gt;

&lt;p&gt;@SessionAttributes 除了可以通过&lt;span&gt;属性名&lt;/span&gt;指定需要放到会话中的属性外&lt;span&gt;(value)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还可以通过模型属性的&lt;span&gt;对象类型&lt;/span&gt;指定哪些模型属性需要放到会话中&lt;span&gt;(type)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; – @SessionAttributes(&lt;span&gt;types&lt;/span&gt;=User.class) 会将隐含模型中所有类型&lt;/p&gt;
&lt;p&gt;            为 User.class 的属性添加到会话中。&lt;/p&gt;
&lt;p&gt;    – @SessionAttributes(&lt;span&gt;value&lt;/span&gt;={“user1”, “user2”})&lt;/p&gt;
&lt;p&gt;    – @SessionAttributes(types={User.class, Dept.class})&lt;/p&gt;
&lt;p&gt;    – @SessionAttributes(value={“user1”, “user2”},&lt;/p&gt;
&lt;p&gt;            types={Dept.class})&lt;/p&gt;

&lt;p&gt;TestRequestMapping.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SessionAttributes(value=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
@Controller
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/springmvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRequestMapping {
     @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/testSessionAttributes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String  testSessionAttributes(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map){
           User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MrChangs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1287@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           map.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, user);
           
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;index.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;springmvc/testSessionAttributes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;testSessionAttributes&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;success.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
           user requestScope:${requestScope.user}
           &amp;lt;br&amp;gt;
           &amp;lt;br&amp;gt;
           user sessionScope:${sessionScope.user}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223549476-1620501391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223608108-413306156.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;@ModelAttribute&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;模拟修改数据路中的数据，有些不能修改。&lt;/p&gt;
&lt;p&gt;index.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 &amp;lt;!--
      模拟修改操作
      1.原始数据：id=1，name=MrChengs，pw=1234，email=MrChengs@qq.com
      2.密码不能修改
      3.表单回显，模拟操作直接在表单填写对应的额属性值
   --&amp;gt;
   &amp;lt;form action=&quot;springmvc/ModelAttribute&quot; method=&quot;post&quot;&amp;gt;
     &lt;span&gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;1&quot;&amp;gt;&lt;/span&gt;
      &amp;lt;br&amp;gt;
      name:&amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;MrChengs&quot;&amp;gt;
      &amp;lt;br&amp;gt;
      email:&amp;lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;MrChengs@qq.com&quot;&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;submit&quot;&amp;gt;
   &amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//标记的方法会在每个目标方法执行之前被调用


    //1.由@ModelAttribute标记的方法，会把每个目标之前被springmvc调用
    //2.@MOdelAttribute注解也可以来修饰目标方法pojo类型的入参，其value属性值如下作用
    //2.1）springmvc会使用value属性值在implicitModel中查找对应的对象，若存在直接传入到目标方法的入参中
    //2.2）springmvc会把value为key，pojo类型对象为value，存到request中
   
      @ModelAttribute
     public void getUser(@RequestParam(value=&quot;id&quot;,required=false) Integer id,
                Map&amp;lt;String,Object&amp;gt; map){             
           if(id != null){
                User user = new User(1, &quot;MrChengs&quot;, &quot;1234&quot;, &quot;MrChengs@qq.com&quot;);
                System.out.println(&quot;得到一个参数&quot;);


                //注意：这里的key为users，如果改为users等其他字符，等不到结果，程序可以正常的执行
            //解决方法在下面的代码中
                map.put(&quot;users&quot;, user);
           }
     }
     
     @RequestMapping(&quot;/ModelAttribute&quot;)
     public String testModelAttribute(@ModelAttribute(&quot;users&quot;)User user){
           System.out.println(&quot;update:&quot; + user);
           return &quot;success&quot;;
     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在success页面：&lt;/p&gt;
&lt;p&gt;可以使用如下的方法获得打印值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
user：${requestScope.users}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果不添加@ModelAttribut，在测试中代码的值为null&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223810737-2075273854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行过程：&lt;/p&gt;
&lt;p&gt;1.执行@ModelAttribute注解修饰的方法，把数据取出防砸map中，map的key为user&lt;/p&gt;
&lt;p&gt;2.SpringMVC从Map中取出User对象，并把表单请求参数放到赋给给该user对象多的对应属性&lt;/p&gt;
&lt;p&gt;3.SpringMVC把上述对象传入目标方法的参数&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：在MOdelAttribute修饰的方法中，放入map的键需要和入参第一个字母小写的字符串一致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110223843163-1095004534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;SpringMVC确定目标方法POJO类型入参的过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.确定一个key&lt;/p&gt;
&lt;p&gt;2.在implicitModel中查找对应的key对象，若存在，则作为入参传入&lt;/p&gt;
&lt;p&gt;3.在implicitModel中不存在key对象，则查找当前的Handler，是都使用了@SessionAttribute对应的                value值若存在则直接传入到方法的入参中，不存在抛异常&lt;/p&gt;
&lt;p&gt;4.若Handler没由标识的@SessionAttribute注解或者@Session Attribute的value值不包含key，则会通过        反射来创建pojo类型的参数，作为目标方法的参数&lt;/p&gt;
&lt;p&gt;5.SpringMVC会把key和value保存到impliciModel中，进而会保存早request中&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于@SessionAttribute的异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java类：&lt;/p&gt;
&lt;p&gt;注意这里@SessionAttribute（user）和方法中的user同名&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@SessionAttributes(value=&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;user&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
@Controller
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/springmvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRequestMapping {  
 @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ModelAttribute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testModelAttribute(User &lt;strong&gt;&lt;span&gt;user&lt;/span&gt;&lt;/strong&gt;){
           System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; user);
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ModelAttribute方法的user&lt;/p&gt;
&lt;p&gt;没找到就去@SeeionAttribute中找&lt;/p&gt;
&lt;p&gt;所以此时会报错----抛异常&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;1.写ModelAttribute注解下的方法&lt;/p&gt;
&lt;p&gt;2.表明一个modelAttribute，在第一次查找中赋值，不在第二次找SeesionAttribute&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public String testModelAttribute(@ModelAttribute（&quot;acbc&quot;)User user){
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
十月 16, 2018 4:38:06 下午 org.apache.catalina.core.StandardWrapperValve invoke
严重: Servlet.service() for servlet [springDispatcherServlet] in context with path [/Spring_MVC_01] threw exception [Session attribute 'user' required - not found in session] with root cause
org.springframework.web.HttpSessionRequiredException: Session attribute 'user' required - not found in session
     at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter$ServletHandlerMethodInvoker.raiseSessionRequiredException(AnnotationMethodHandlerAdapter.java:791)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; @ModelAttribute&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在方法定义上使用 @ModelAttribute 注解：Spring MVC&lt;/p&gt;
&lt;p&gt;在调用目标处理方法前，会先逐个调用在方法级上标注了&lt;/p&gt;
&lt;p&gt;@ModelAttribute 的方法。&lt;/p&gt;

&lt;p&gt;在方法的入参前使用 @ModelAttribute 注解：&lt;/p&gt;
&lt;p&gt;– 可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数定到对象中，再传入入参&lt;/p&gt;
&lt;p&gt; – 将方法入参对象添加到模型中&lt;/p&gt;

&lt;p&gt; 由@SessionAttributes引发的异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.springframework.web.&lt;span&gt;HttpSessionRequiredExcept：&lt;/span&gt;
Session attribute &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; required - not found &lt;span&gt;in&lt;/span&gt; session
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果在处理类定义处标注了@SessionAttributes(“xxx”)，则尝试从会话中获取该属性，并将其赋给该入参，然后再用&lt;/p&gt;
&lt;p&gt;请求消息填充该入参对象。&lt;span&gt;如果在会话中找不到对应的属&lt;/span&gt;&lt;span&gt;性，则抛出 HttpSessionRequiredException 异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110224113545-1272876883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 如何避免@SessionAttributes引发的异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181110224135371-2026833268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 06:09:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>处理模型数据 Spring MVC 提供了以下几种途径输出模型数据： – ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加 模型数据 – Map</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9940917.html</dc:identifier>
</item>
<item>
<title>网站运维技术与实践之数据分析与报警 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/9940778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/9940778.html</guid>
<description>&lt;p&gt;对于日益积累的监控数据，显然需要有规划地进行存储和分析，做到“故障没来时有预防，故障来临时有提示，故障到来时有解决方案”。&lt;/p&gt;
&lt;p&gt;一、时间序列存储&lt;/p&gt;
&lt;p&gt;对于大多数监控数据，都有一个天然的类似数据库主键的属性，那就是时间。所以，通常情况下，各类监控系统的后台数据库都可以认为是时间序列的数据存储，并由此诞生了一批针对监控数据存储开发的数据库，其中最有代表性是RRDtool和Graphite。&lt;/p&gt;
&lt;p&gt;1.RRDtool(Round-Robin DataBase Tool)&lt;/p&gt;
&lt;p&gt;Round-Robin(循环)在运维人员眼里是一个很熟悉的词汇。负载均衡中最基础的算法就是Round-Robin,意即逐一循环。这个词很形象地描绘了RRD数据库的内部结构。&lt;/p&gt;
&lt;p&gt;RRD数据库是一个固定空间大小的文件，其内部可以看做一个固定刻度的圆形表盘，每个刻度存储一个时间点的数据。表上有一个指针，永远指向最新写入数据的位置。指针随着数据写入转动，转完一圈后，就覆盖掉之前的数据从头继续。&lt;/p&gt;
&lt;p&gt;上面这段描述中，有一点需要单独拿出来支出，即&quot;指针岁随数据写入转动&quot;。这个数据写入，并不等同于运维人员调用rrdtool命令插入数据。这也是RRD数据库和普通数据库一个明显的不同-在指定的时间间隔后，如果RRD每个收到明确的数据插入请求，它依然会自行发起一次“空”数据写入，占据这个刻度空间。这也是我们一般用钟表比喻RRD的原因，指针实际是定时转动的。&lt;/p&gt;

&lt;p&gt;2.Graphite&lt;/p&gt;
&lt;p&gt;相对1999年诞生的RRD，2006年才出生的Graphite通过与Statsd实时监控系统的结合，在最近几年大数据的浪潮中得到迅速普及和发展。&lt;/p&gt;
&lt;p&gt;Graphite项目包括三部分:展示图形的graphite-web，接收和写入数据的carbon，数据存储引擎whisper。这里我们先不谈论graphite-web而专注于数据部分。&lt;/p&gt;
&lt;p&gt;Graphite与RRD一脉相承，事实上，最开始的Graphite就是打算通过额外的Python脚本存取分布式的RRD文件(看起来更类似于Cacti的角色)。&lt;/p&gt;
&lt;p&gt;但最终Graphite没有选择RRD而是自己用Python实现存储引擎whisper，主要原因如下:&lt;/p&gt;
&lt;p&gt;(1)Graphite的设计更倾向于展示数据而不是各种算法&lt;/p&gt;
&lt;p&gt;在实际运用中，类似&quot;网站访问500错误数统计&quot;是Graphite常见的典型需求之一。而在网站一切正常的情况下，500错误肯定是具有偶发性质的。这与RRD数据结构设想的“有规律的定时记录数据”是相互冲突的。&lt;/p&gt;
&lt;p&gt;(2)性能问题&lt;/p&gt;
&lt;p&gt;在Graphite项目开始的时候，RRD在同一时刻，只允许往一个数据库里写入一个数值，而whisper可以合并多个数值批量写入。这样在高负载情况下，同时操作大量文件时，Graphite就不会被“磁盘IOPS“的瓶颈限制住。不过RRDtool现在已经解决了性能问题。但是在在第一点没有解决之前，虽然Python写的whisper性能比C写的rrdtool慢2~5倍，Graphite也会继续使用自己的whisper引擎。&lt;/p&gt;

&lt;p&gt;3.OpenTSDB&lt;/p&gt;
&lt;p&gt;时间序列数据库家族里还有一个新加入的成员:HBase社区的OpenTSDB。OpenTSDB只存储最基本的&amp;lt;timestamp,value&amp;gt;键值对，其余功能都依赖于HBase集群完成。有兴趣的读者可以参阅其官网，地址:http://opentsdb.net。&lt;/p&gt;
&lt;p&gt;总的来说，从RRDtool到Graphite再到OpenTSDB,数据库中内置的数据类型和聚合算法越来越少，数据存储的可靠性和可扩展性越来越强。具体如何选择，就取决于数据量大小和运维团队二次开发能力。&lt;/p&gt;

&lt;p&gt;二、全文搜索引擎ElasticSearch&lt;/p&gt;
&lt;p&gt;前面说到的RRD、Graphite、OpenTSDB等，都只能存储数值型数据，这需要我们提前先整理好数据，因此不足以应对突发性的需求。比如，网站新出现的热门话题，我们需要关注这个话题的相关监控数据，这时候再动手创建数据库，然后写脚本过滤日志，最后导入库中绘图，不过等到这个过程完了，恐怕就晚了。&lt;/p&gt;
&lt;p&gt;或许大家在应对这个问题的时候，都通过搜索引擎知道了Spluck这个工具，可惜的是这不是一个开源软件，它只提供每天索引500MB的免费试用版本。有些运维人员只好先行裁剪数据，只导入所需的部分来进行查询，倒可以算是一种临时抱佛脚的解决办法。&lt;/p&gt;
&lt;p&gt;1.简介&lt;/p&gt;
&lt;p&gt;ElasticSearch是一个分布式的Lucene全文搜索引擎，提供RestFul的API接口，也是最近相当流行的日志存储分析平台。它提供更加强大的搜索和统计功能。&lt;/p&gt;
&lt;p&gt;关于全文搜索的基础原理，不了解的读者可以参考《大规模Web服务开发技术》中的》第九章挑战全文搜索技术 电子书的下载地址为:http://vdisk.weibo.com/s/zmzzSciGaVonL(感恩互联网时代为我们学习提供很多渠道)&lt;/p&gt;
&lt;p&gt;目前ElasticSearch几个著名的客户如下:&lt;/p&gt;
&lt;p&gt;(1)Mozilla,自动构建和测试集群，通过Flume发送ES。&lt;/p&gt;
&lt;p&gt;(2)Sony,采用ES进行娱乐项目的使用数、用户评分、标题和说明等的存储和搜索。&lt;/p&gt;
&lt;p&gt;(3)StumbleUpon，著名社交内容推荐引擎公司，用ES索引HBase数据方便不熟悉Hadoop编程的开发人员完成搜索功能，称上手快，1小时内搞定。&lt;/p&gt;
&lt;p&gt;(4)Infochimps,著名大数据分析服务公司，通过ES索引超过2.5亿个对象，4TB以上的Hadoop数据。&lt;/p&gt;
&lt;p&gt;(5)Ataxo Social Inside,捷克斯洛伐克的一家社交舆情监控分析公司，从网页数据库到后台分析都用ES。&lt;/p&gt;
&lt;p&gt;(6)MetaCPAN和Github，都是代码托管网站，用ES做开源项目代码搜索。&lt;/p&gt;
&lt;p&gt;ElasticSearch中文社区:https://elasticsearch.cn/&lt;/p&gt;
&lt;p&gt;ElasticSearch权威指南下载:http://www.java1234.com/a/javaziliao/shuji/2016/0104/5478.html&lt;/p&gt;

&lt;p&gt;2.安装&lt;/p&gt;
&lt;p&gt;ElaticSearch官网提供了各个版本的deb安装包。因为ES是一个Java项目，没有什么动态库依赖，所以我们可以很容易地根据deb生成rpm安装包。&lt;/p&gt;
&lt;p&gt;ES源代码托管:https://github.com/elastic/elasticsearch/&lt;/p&gt;
&lt;p&gt;也可以选择直接下载代码后运行./bin/elasticsearch即可&lt;/p&gt;
&lt;p&gt;Linux安装教程:https://blog.csdn.net/sinat_28224453/article/details/51134978&lt;/p&gt;
&lt;p&gt;Windows安装教程:https://www.cnblogs.com/zhangchenliang/p/4214408.html&lt;/p&gt;

&lt;p&gt;3.集群&lt;/p&gt;
&lt;p&gt;ES集群的部署可谓是“傻瓜式”的，唯一需要自定义的地方就是/etc/elasticsearch/elasticsearch.yml里的cluster.name。然后，在Discovery可达的范围内，所有的elasticsearch node会自动寻找和自己有相同cluster.name的兄弟，然后按照最朴素的先来后到的规则确定master。到此，集群就完成了。&lt;/p&gt;
&lt;p&gt;在ES集群中，存在多种角色,如下:&lt;/p&gt;
&lt;p&gt;(1)master node：有资格被选举成为master的node。但是和MySQL的master-slave结构不同，ES中master的作用只是负责维护整个cluster的state,也就是nodes和shards的列表，然后通知其他所有的API，也就是常说的CRUD，都是可以直接发给集群里任何一个master node的，这个node会自动根据请求来操作整个集群。&lt;/p&gt;
&lt;p&gt;(2)data node：存储数据的node。ES中，data node上有index和shard两级实际存在的目录。但逻辑上,index一旦创建，其shards数就不能再变更，因为ES的shard方法就是简单的取余；而replica数是可以随时通过API调整的。&lt;/p&gt;
&lt;p&gt;(3)client node：如果一个node 不存储数据，那么它在接收到请求的时候，只能从master上获取shards列表，然后把请求转发给相应的data node，最后再把结果转发回去。但本质上，client node也是cluster的一部分。在这种配置时，通常是cluster内部采用9300端口的transport通信，只留几个client node开放9200端口的HTTP接口对外接收RestFul请求。&lt;/p&gt;
&lt;p&gt;关于ES的基础操作在此就不列举了，感兴趣的可以参照前面的ES权威指南下载地址，下载下来仔细研究，毕竟我这里只是普及和稍微讲讲理论知识和对应的应用场景罢了。&lt;/p&gt;
&lt;p&gt;另外关于数据可视化分析工具，在此说两个，一个是Gnuplot，另外一个是AmCharts。另外声明一下，可视化工具绝非这两个，还有很多，大家可以根据自己的需求百度或Google搜索找找。&lt;/p&gt;

&lt;p&gt;三、报警&lt;/p&gt;
&lt;p&gt;对于运维工作来说，还剩下一个更需要实时性的功能-报警。报警的方式有很多种，最常见的就是电子邮件、短信等。随着通信的发达，很多工具支持像微信告警等手段，比如我上家公司就通过Zabbix加微信联合报警。&lt;/p&gt;
&lt;p&gt;1.SendMail&lt;/p&gt;
&lt;p&gt;邮件发送是产品运维乃至运营工作中的很重要部分。sendEmail和postFix的配置部署也是Linux运维人员的必备技能之一。不过在监控系统中，我们可以用更简洁易用的命令来快速完成工作。&lt;/p&gt;
&lt;p&gt;sendEmail就是这样一个工具。下载地址:http://caspian.dotconf.net&lt;/p&gt;

&lt;p&gt;2.WebSocket&lt;/p&gt;
&lt;p&gt;在工作时间段，运维人员更经常停留在浏览器界面而不是邮件客户端界面，至于手机等设备，离视线更加遥远，所以在这种情况下，我们可以通过浏览器的帮助，使用成本极低的网页报警，同样可以获得很好的效果。&lt;/p&gt;
&lt;p&gt;网页实时刷新，是近年来最流行的技术话题之一。从运维的实际需求出发，我们不用考虑太多并发的性能问题，更需要考虑的是快捷开发，简单上手。就此，这里推荐开发社区的小软件:Juggernaut。下载地址:https://github.com/maccman/juggernaut&lt;/p&gt;

&lt;p&gt;3.手机推送&lt;/p&gt;
&lt;p&gt;运维人员下班之后，尤其是在下班路上，除了传统的短信报警，在移动互联网时代，也有了更加“时髦”的处理方式，那就是:用手机APP来收报警。&lt;/p&gt;
&lt;p&gt;手机推送消息，是很多APP都有的基础功能。我们不需要自己从头研究推送原理，然后实现全套系统，直接使用JPush极光推送，可以极简单地实现这个报警功能。极光推送APP的示例:&lt;/p&gt;
&lt;p&gt;注册账户-&amp;gt;新建应用(纯页面操作，填写应用名称,获取对应的Key和master secret)-&amp;gt;下载Example包-&amp;gt;用adt eclipse打开eclipse项目并生成APK文件&lt;/p&gt;

&lt;p&gt;4.分级和归并&lt;/p&gt;
&lt;p&gt;前面三种工具，以及其他还没有提到的各种信息传送渠道，都只解决了一个问题:把信息传递到运维人员身边。但这个信息是否能有效让运维人员对故障作出判断并解决问题呢?&lt;/p&gt;
&lt;p&gt;实际的工作中，并不缺乏这样的情况:半夜被报警叫醒，只是一个磁盘85%的小问题，支持到明早上上班再解决肯定没问题，于是继续睡觉。结果早上一看，在昨晚半小时重复一次磁盘报警，还夹着一条宕机。&lt;/p&gt;
&lt;p&gt;这就是告警设计的另一个重要方向:如何提高信息的有效传递。归纳起来，就是要”有多又少&quot;-不同意义的信息要多，一点不能遗漏；相同的信息要少，每条都可以引起运维人员的快速响应。&lt;/p&gt;
&lt;p&gt;一般来说，做到这点有两个办法:分级和归并。&lt;/p&gt;
&lt;p&gt;其实分级告警和归并过滤在Nagios报警设计中都有所体现，比如WARNING、CRITICAL和RECOVERY状态的区别，主机和服务的dependency关系，报警的escalations变更等。只要用好Nagios的细节控制，就可以减少很多无谓的报警。&lt;/p&gt;
&lt;p&gt;对于非Nagios体系的监测告警，我们则需要自己动手完成。设计思路上，完全可以参考Nagios项目。实现办法上则可以完全从告警出口处控制。一般我们使用的短信网关，都会采用MySQL作为短信存储。我们可以限制MySQL数据库的权限，自己编写一个简单的HTTP服务作为短信告警的统一接收入口。这样，在HTTP服务接收到信息之后，可以先对MySQL中的近期数据进行查询统计，一旦经过逻辑计算认为应该被归并过滤掉，那么在最后信息入库的时候，直接将SQL中是否发生的列标记为已发送，或者自定义代表被过滤的其他数字-请注意，虽然信息最后被过滤，但千万不能直接丢弃掉。“被过滤”也是一种记录，也有价值。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 06:02:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>对于日益积累的监控数据，显然需要有规划地进行存储和分析，做到“故障没来时有预防，故障来临时有提示，故障到来时有解决方案”。 一、时间序列存储 对于大多数监控数据，都有一个天然的类似数据库主键的属性，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/9940778.html</dc:identifier>
</item>
<item>
<title>网络编程(五) - Thales5</title>
<link>http://www.cnblogs.com/zuanzuan/p/9941914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/9941914.html</guid>
<description>&lt;p&gt;在上一篇文章中我们学习了 基于 TCP 套接字的服务端和客户端通信,并解决了粘包的问题,解决粘包问题的思路很简单,就是确保接受方能够把数据收取干净,发多少,就收多少.&lt;/p&gt;
&lt;p&gt;出现粘包的问题:原因有两个,一个是接收数据量少于发送数据量;一个是因为为了优化 TCP 的传输效率,使用了 Nagle算法,当客户端连续发送时间间隔很短的两个数据包时,在未确认数据发送的时候让发送器把数据送到系统缓存里.任何数据随后继续直到得到明显的数据确认或者直到攒到了一定数量的数据了再发包.&lt;/p&gt;
&lt;p&gt;这是不可避免的,为了优化传输效率,尽量发送大块数据,避免网络中充斥的许多小数据块.知道了解决方法,那么避免粘包就很简单了,只需要在每次发送数据之前先发送真实数据的长度,然后接收方可以根据收到的真实长度收取数据了.&lt;/p&gt;

&lt;p&gt;SOCKET AF_INET套接字主要有两种协议,现在来看 UDP 协议是如何进行网络通信的.&lt;/p&gt;
&lt;h2 id=&quot;基于-udp-连接的套接字&quot;&gt;基于 UDP 连接的套接字&lt;/h2&gt;
&lt;p&gt;tcp 是无连接,不稳点的套接字,但是传输效率较高,所以在某些应用上如实时直播,游戏, DNS 服务器,DHCP 服务器等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from socket import *

serverSock = socket(AF_INET, SOCK_DGRAM)
serverSock.bind(('', 8080))

while True:
    data, client_addr = serverSock.recvfrom(1024)
    print(data)
    serverSock.sendto(data.upper, client_addr)
serverSock.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from socket import *

clientSock = socket(AF_INET, SOCK_DGRAM)

while True:
    msg = input('&amp;gt;&amp;gt;&amp;gt;').strip()
    clientSock.sendto(msg.encode('utf-8'), ('', 8080))
    data, server_addr = clientSock.recvfrom(1024)
    print(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们连续开多个客户端和服务端通信的时候,没有出现阻塞的情况,发出去的消息都可以收回来,这是因为 udp 是无连接的套接字,不用关注一个连接,只要你给我发消息拿到了发送方的 ip 和端口,那么就可以直接和你通信,而且不像 TCP 那样必须先启动服务端才可以, udp 在发送数据的时候,服务端没有启动也可以发送过去,只不过是发到了对方的系统缓存中.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fx41g106kmj31aa0o80xd.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么 udp 可以实现多个客户端同时和客户端通信吗?&lt;/p&gt;
&lt;p&gt;之前几个客户端可以同时和服务端通信是因为服务端的处理能力很大,看起来是同时通信一样,但是如果把客户端加到 1w, 甚至更多就会感觉到明显的时间差了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fx41qyucpxj31kw0wjk1z.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何可以实现真正的并发呢?关键点就在一个通信循环和连接循环互相不干扰,不用因为 i/o 堵塞而耽搁另一个循环要做的事.&lt;/p&gt;

&lt;p&gt;在这里 python 有一个模块为 socketserver 可以实现真正的并发.&lt;/p&gt;
&lt;h2 id=&quot;基于-tcp-协议的并发&quot;&gt;基于 TCP 协议的并发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sockerserver

class MyTCPhandler(socketserver.BaseRequestHandler):
    def handler(self):
        while True:
            try:
                data = self.request.recv(1024)
                if len(data) == 0:
                    break
                print('--&amp;gt;收到客户端的消息:', data)
                self.request.send(data.upper())
            except ConnectResetError:
                break
        self.request.close()
        
if __name__ == '__main__':
    serverSock = socketserver.ThreadingTCPServer(('127.0.0.1', 8081), MyTCPhandler)
    serverSock.serve_forever() # 和客户端进行连接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from socket import *

clientSock = socket(AF_INET, SOCK_STREAM)
clientSock.connect(('127.0.0.1', 8081))

# 通信循环
while True:
    clientSock.send(b'hello')
    data = clientSock.recv(1024)
    print(data)
    
clientSock.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就解决了 TCP 不能实现并发的问题了.&lt;/p&gt;
&lt;h2 id=&quot;基于-udp-协议的并发&quot;&gt;基于 UDP 协议的并发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socketserver

class MyUDPhandler(socketserver.BaseRequestHandler):
    def handler(self):
        data, serverSock = self.request
        serverSock.sendto(data.upper(), self.client_address)
        
if __name__ == '__main__':
    server = socketserver.ThreadingUDPServer(('127.0.0.1', 8081), MyUDPhandler)
    server.serve_forever()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from socket import *

clientSock = socket(AF_INET, SOCK_DGRAM)

while True:
    clientSock.sendto(b'hello', ('127.0.0.1', 8081))
    data, server_addr = client.recvfrom(1024)
    print(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是 UDP 实现并发的模板.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到此,网络编程终于告一段落了,其实我写的是网络编程里面极少的也是较为重要的一部分,还有很多底层协议没了解,像 ping 服务器时发送的 ICMP 包,还有很多,不过我觉得了解了这些其实也就了解了互联网工作的基本方式,其余的待有时间了再来学习.&lt;/p&gt;
&lt;p&gt;如有不对的地方,欢迎指正.&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 05:43:00 +0000</pubDate>
<dc:creator>Thales5</dc:creator>
<og:description>前言 在上一篇文章中我们学习了 基于 TCP 套接字的服务端和客户端通信,并解决了粘包的问题,解决粘包问题的思路很简单,就是确保接受方能够把数据收取干净,发多少,就收多少. 出现粘包的问题:原因有两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/9941914.html</dc:identifier>
</item>
<item>
<title>小程序云开发--云函数操作数据库 - Kindear_chen</title>
<link>http://www.cnblogs.com/masterchd/p/9941752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masterchd/p/9941752.html</guid>
<description>&lt;p&gt;之前学习小程序云开发的时候，发现关于云函数操作数据库的内容在网上非常的少。&lt;/p&gt;
&lt;p&gt;想了想，不如自己出个教程。&lt;/p&gt;
&lt;p&gt;小程序云函数运行的环境是Node.js 8.9 ， Node.js 是运行在服务端的 JavaScript，如果你熟悉Javascript，那么你将会很容易的学会Node.js。&lt;/p&gt;
&lt;p&gt;我们分为增改查3个部分来介绍。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;1.准备&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们在云控制台创建个数据集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111112016460-1536861044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确保自己是处在云开发环境下，本地云函数路径和云端一致，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111112313634-1790854386.png&quot; alt=&quot;&quot;/&gt;右键选中自己的环境，完成云函数的同步与更新&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2.云函数操作数据库--增&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 服务端写法：&lt;/p&gt;
&lt;p&gt;funcadd 云函数写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()
const db = cloud.database()
// 云函数入口函数
exports.main = async (event, context) =&amp;gt; {
  var filedvalue1 = event.data1
  var filedvalue2 = event.data2
  try {
    return await db.collection('mydata').add({
      data:{
        filed1:filedvalue1,
        filed2:filedvalue2
      }
    })
  } catch (e) {
    console.log(e)
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本地调用写法（确保在调用云函数之前在js 文件首部引入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;const db = wx.cloud.database() &lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;   ）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
wx.cloud.callFunction({
      name:'funcadd',
      data:{
        data1:'kindear',
        data2:'真帅'
      },success:function(res){
        console.log(res)
      },fail:function(res){
        console.log(res)
      }
    })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用成功返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111113022818-1058403007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;result._id 是这个记录的唯一标识码，可以设置一个变量记录下来，用作之后的更新删除等操作。&lt;/p&gt;
&lt;p&gt;我们查看数据集合&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111113248105-1614031282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这个数据已经被成功记录。&lt;/p&gt;



&lt;p&gt;&lt;span&gt; 3&lt;em&gt;&lt;strong&gt;.云函数操作数据库--改&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; funcupdate 云函数写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()
const db = cloud.database()
// 云函数入口函数
exports.main = async (event, context) =&amp;gt; {
  var docid = event.docid
  var vdata1 = event.data1
  var vdata2 = event.data2
  try {
    return await db.collection('mydata').doc(docid).update({
      data: {
        filed1:vdata1,
        filed2:vdata2
      }
    })
  } catch (e) {
    console.log(e)
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本地调用写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 wx.cloud.callFunction({
      name:'funcupdate',
      data:{
        docid:'W-eiILdokuiPGKeC',
        data1:'chd',
        data2:'cool'
      },success:function(res){
        console.log(res)
      },fail:function(res){
        console.log(res)
      }
    })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用成功控制台结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111114143968-975311397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt; 4.云函数操作数据库--查&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;集合的查询操作，用云函数能比直接在本地调用查询到更多条的记录，只需要你知道查询的字段名和对应的值就可以，&lt;/p&gt;
&lt;p&gt; funcquery 云函数，这个是根据 id查询的，同样也可以根据vdata1,vdata2 等信息来进行查询操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()
const db = cloud.database()
// 云函数入口函数
exports.main = async (event, context) =&amp;gt; {
  var docid = event.docid
  var vdata1 = event.data1
  var vdata2 = event.data2
  try{
    return await db.collection('mydata').where({
      _id: docid
    }).get()
  }catch(e){
    console.log(e)
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;小程序调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 wx.cloud.callFunction({
      name:'funcquery',
      data:{
        docid:'W-eiILdokuiPGKeC',
        data1:'chd',
        data2:'cool'
      },success:function(res){
        console.log(res)
      },fail:function(res){
        console.log(res)
      }
    })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;控制台信息打印&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/201811/1141382-20181111124754804-1201772474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 04:59:00 +0000</pubDate>
<dc:creator>Kindear_chen</dc:creator>
<og:description>之前学习小程序云开发的时候，发现关于云函数操作数据库的内容在网上非常的少。 想了想，不如自己出个教程。 小程序云函数运行的环境是Node.js 8.9 ， Node.js 是运行在服务端的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/masterchd/p/9941752.html</dc:identifier>
</item>
<item>
<title>Visual Studio 2017上配置OpenGL编程指南第8版开发环境 - 一剑孤心</title>
<link>http://www.cnblogs.com/secret-yijian/p/9941693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secret-yijian/p/9941693.html</guid>
<description>&lt;p&gt;一直想学习一下OpenGL，买了红宝书第8版，却因为工作原因一直没有时间看，最近利用周末尝试了一下配置开发环境，遇到了一些坑点，现在记录下来备用。&lt;/p&gt;
&lt;h2&gt;第一步：打开Visual Studio 2017，建立一个空的C++工程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111113142911-1448598439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第二步：新建triangles.cpp文件，并写入书本例子中的代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/////////////////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; triangles.cpp
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;/////////////////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vgl.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoadShaders.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; VAO_IDs { Triangles, NumVAOs };
&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Buffer_IDs { ArrayBuffer, NumBuffers };
&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt; Attrib_IDs { vPosition = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };

GLuint VAOs[NumVAOs];
GLuint Buffers[NumBuffers];

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; GLuint NumVertices = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; init
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
init(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    glGenVertexArrays(NumVAOs, VAOs);
    glBindVertexArray(VAOs[Triangles]);

    GLfloat vertices[NumVertices][&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
        { &lt;/span&gt;-&lt;span&gt;0.90&lt;/span&gt;, -&lt;span&gt;0.90&lt;/span&gt; }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Triangle 1&lt;/span&gt;
        { &lt;span&gt;0.85&lt;/span&gt;, -&lt;span&gt;0.90&lt;/span&gt;&lt;span&gt; },
        { &lt;/span&gt;-&lt;span&gt;0.90&lt;/span&gt;, &lt;span&gt;0.85&lt;/span&gt;&lt;span&gt; },
        { &lt;/span&gt;&lt;span&gt;0.90&lt;/span&gt;, -&lt;span&gt;0.85&lt;/span&gt; }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Triangle 2&lt;/span&gt;
        { &lt;span&gt;0.90&lt;/span&gt;, &lt;span&gt;0.90&lt;/span&gt;&lt;span&gt; },
        { &lt;/span&gt;-&lt;span&gt;0.85&lt;/span&gt;, &lt;span&gt;0.90&lt;/span&gt;&lt;span&gt; }
    };

    glGenBuffers(NumBuffers, Buffers);
    glBindBuffer(GL_ARRAY_BUFFER, Buffers[ArrayBuffer]);
    glBufferData(GL_ARRAY_BUFFER, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vertices),
        vertices, GL_STATIC_DRAW);

    ShaderInfo shaders[] &lt;/span&gt;=&lt;span&gt; {
        { GL_VERTEX_SHADER, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;triangles.vert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
        { GL_FRAGMENT_SHADER, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;triangles.frag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
        { GL_NONE, NULL }
    };

    GLuint program &lt;/span&gt;=&lt;span&gt; LoadShaders(shaders);
    glUseProgram(program);

    glVertexAttribPointer(vPosition, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, GL_FLOAT,
        GL_FALSE, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, BUFFER_OFFSET(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    glEnableVertexAttribArray(vPosition);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; display
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; 
display(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glBindVertexArray(VAOs[Triangles]);
    glDrawArrays(GL_TRIANGLES, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, NumVertices);
    glFlush();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; 
main(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;**&lt;span&gt; argv)
{
    glutInit(&lt;/span&gt;&amp;amp;&lt;span&gt;argc, argv);
    glutInitDisplayMode(GLUT_RGBA);
    glutInitWindowSize(&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;&lt;span&gt;);
    glutInitContextVersion(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    glutInitContextProfile(GLUT_CORE_PROFILE);
    glutCreateWindow(argv[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (glewInit()) {
        cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unable to initialize GLEW ... exiting&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
        exit(EXIT_FAILURE);
    }

    init();

    glutDisplayFunc(display);

    glutMainLoop();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;第三步：插入代码之后会有很多的报错，下载官方的样例代码，打开项目&lt;strong&gt;属性-&amp;gt;VC++目录&lt;/strong&gt;并引入lib库和头文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111113734290-1143470603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第四步：生成解决方案，这个时候可以发现代码的报错已经没有了，但是控制台会有一些错误的提示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111113842402-1476202013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开项目属性-&amp;gt;链接器-&amp;gt;输入，找到忽略特定默认库，在其中加入libcmtd.lib&lt;/p&gt;
&lt;h2&gt;第五步：解决库冲突问题后仍存在问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114025073-872546940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从源代码的文件夹&lt;strong&gt;libs&lt;/strong&gt;中找到&lt;strong&gt;LoadShaders.cpp&lt;/strong&gt;文件，复制到项目目录下，并添加到解决方案中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114149307-532419636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第六步：添加LoadShaders文件后依然有报错&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114248884-1754636142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开工程目录下的LoadShaders.cpp文件，将如下代码的宏WIN32修改成_WIN32&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114426487-1031616504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第七步：解决对应平台安全代码问题，依然报错&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114836847-1411887120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开项目属性-&amp;gt;链接器-&amp;gt;输入，并在附加依赖项中添加legacy_stdio_definitions.lib&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111114920502-695705685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第八步：添加依赖项legacy_stdio_definitions.lib后依然报错&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115046137-2077118834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候我们在triangles.cpp最上方添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#if&lt;/span&gt; _MSC_VER&amp;gt;=1900&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
_ACRTIMP_ALT FILE&lt;/span&gt;*&lt;span&gt; __cdecl __acrt_iob_func(unsigned);
#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;
FILE&lt;/span&gt;*&lt;span&gt; __cdecl __iob_func(unsigned i) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; __acrt_iob_func(i);
}
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; /* _MSC_VER&amp;gt;=1900 */
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;第九步：解决符号问题后生成工程成功&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115208320-187639264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击运行，而然又报错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115235885-893331896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候需要在glutInit(&amp;amp;argc, argv);前加入代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
glewExperimental = GL_TRUE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115327690-1224946125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次点击运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115418500-712444774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来忘记放入书上的着色器文件了，在工程目录下分别建立着色器文件triangles.frag和triangles.vert&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; triangles.frag&lt;/span&gt;
#version &lt;span&gt;430&lt;/span&gt;&lt;span&gt; core
&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt; vec4 fColor;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
main()
{
    fColor &lt;/span&gt;= vec4(&lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; triangles.vert&lt;/span&gt;
#version &lt;span&gt;430&lt;/span&gt;&lt;span&gt; core
layout(location &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec4 vPosition;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
main()
{
    gl_Position &lt;/span&gt;=&lt;span&gt; vPosition;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;第十步：再次运行工程，终于见到了成功的图形&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1361860/201811/1361860-20181111115725175-1469701092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上述就是在Visual Studio 2017上构建《OpenGL编程指南（原书第8版）》开发环境及运行书本第一个例子的完整过程。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 04:02:00 +0000</pubDate>
<dc:creator>一剑孤心</dc:creator>
<og:description>一直想学习一下OpenGL，买了红宝书第8版，却因为工作原因一直没有时间看，最近利用周末尝试了一下配置开发环境，遇到了一些坑点，现在记录下来备用。 第一步：打开Visual Studio 2017，建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/secret-yijian/p/9941693.html</dc:identifier>
</item>
<item>
<title>线上故障的思考【一线工程师必看】 - 熊二哥</title>
<link>http://www.cnblogs.com/xiong2ge/p/bughandle_standard.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiong2ge/p/bughandle_standard.html</guid>
<description>&lt;p&gt;周末早上，一个哥们突然@我，问是否有线上故障处理和定级的规范或者模板，虽然手头有既有文档，但内容显的太具象了，跟我们的业务有很强的关联性，并不是那么好直接复制到他的团队中。因此，个人对过去的线上故障处理进行了回顾和思考，并进行了简要的归纳，望帮助到需要的同学。文本将按&lt;strong&gt;事中处理、事后总结和事前预防&lt;/strong&gt;的顺序进行介绍，不足之处望大家不吝赐教。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/636325/201811/636325-20181111114548449-892196254.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;换个角度来说，其实故障处理的过程，和小朋友发高烧的处理过程类似。首先mama会带孩子上医院，如果温度高医生会要求打退烧针，类似发布回滚，之后再通常吃对症的药物慢慢恢复疾病。接下来，mama会明确小朋友生病的原因，如吹风受凉，并抱怨程序员爸爸不细心。最后，mama会提出很多的预防计划，比如禁止程序员爸爸带孩子时写代码，6了6了。&lt;/p&gt;

&lt;p&gt;遇到线上故障永远是尽快处理问题，而不是追究谁的责任，有时候快速合理的故障处理，完全可以规避掉大部分的故障危害&lt;/p&gt;
&lt;h2 id=&quot;线上故障处理sop&quot;&gt;1.1线上故障处理SOP&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;a.线上故障第一要务【发布回滚】，因此针对高风险代码，一定要单独发布，便于回滚&lt;/li&gt;
&lt;li&gt;b.线上故障第二要务【周知干系人】，随时通报故障处理进度，让真正了解该问题的干系人尽早参与进来&lt;/li&gt;
&lt;li&gt;c.故障代码revert【通常来说，代码问题只要无法在30分钟内修复，就一定要回退代码，避免其他项目把错误代码带上线，再次带来故障】&lt;/li&gt;
&lt;li&gt;d.修复问题，冷静的完成回归测试后重新上线，如果BUG带来错误数据则需要全面评估数据清洗的风险，避免造成更加严重的次生伤害【很常见】&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;故障定级&quot;&gt;2.1.故障定级&lt;/h2&gt;
&lt;p&gt;简单的可以定位3级【推荐更进一步细化为3-5个层次】，严重性逐步递增：a.线上bug；b.线上故障；c.线上灾难。&lt;/p&gt;
&lt;p&gt;一定要针对不同业务、不同层次、不同持续时间、不同后果细化故障定级，并且要周知所有干系人，确认后执行，以电商平台为例。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同业务：交易、支付、领券属于重要业务，出问题对公司影响很大；C端影响通常要比B端影响大很多&lt;/li&gt;
&lt;li&gt;不同层次：前端的影响会小一些，后端的会大一些，基础的会更大【包括中间件、运维等】&lt;/li&gt;
&lt;li&gt;不同持续时间：如故障持续3分钟，bug一上线就发现，通常故障级别会比较低，持续12小时，可能CTO都危险了，因此出现问题及时通报很重要，瞒报只会无限的扩大风险&lt;/li&gt;
&lt;li&gt;不同后果：影响用户下单100单，产生15个客户投诉，影响商家编辑商品2小时等，这部分的指标一定要和业务、产品沟通确认，他们有这部分最大的发言权。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;用户订单&lt;/td&gt;
&lt;td&gt;5分钟&lt;/td&gt;
&lt;td&gt;损失10万订单&lt;/td&gt;
&lt;td&gt;线上灾难&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;商家商品&lt;/td&gt;
&lt;td&gt;45分钟&lt;/td&gt;
&lt;td&gt;商家45分钟不能编辑和新增商品信息&lt;/td&gt;
&lt;td&gt;线上故障&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;用户评论&lt;/td&gt;
&lt;td&gt;3分钟&lt;/td&gt;
&lt;td&gt;用户3分钟不能编辑和查看评论信息&lt;/td&gt;
&lt;td&gt;线上bug&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;tip:&lt;/p&gt;
&lt;p&gt;【后果数据来源】：通常取前1日、上周同日数据作为参考，根据业务线有差异，此外，互联网业务因变化快去年的数据通常不具参考意义&lt;/p&gt;
&lt;p&gt;【构思角度】：可以从空间、时间、组合空间和时间维度&lt;/p&gt;
&lt;h2 id=&quot;责任人范围&quot;&gt;2.2.责任人范围&lt;/h2&gt;
&lt;p&gt;明确责任人，到底是产品、开发还是测试同学的责任，亦或者是多个干系人共同分担责任。比如由于是产品设计不合理带来的bug，产品同学需要负主要责任，有测试同学参与的项目，测试同学需要和开发同学共担责任，而其他情况，就只能是开发同学自己背锅了。&lt;/p&gt;
&lt;h2 id=&quot;故障复盘&quot;&gt;2.3.故障复盘&lt;/h2&gt;
&lt;p&gt;在故障处理完成后，一定要复盘并由责任人编写Case Study，并根据相关价值决定是否需要团队内分享【一定要避免同样的问题再次发生】&lt;/p&gt;
&lt;h2 id=&quot;故障处罚&quot;&gt;2.4.故障处罚&lt;/h2&gt;
&lt;p&gt;开发人员及其多级Leader、[测试人员]及其多级Leader共同分摊，比如开发小A罚款200元，Leader罚款500元，CTO罚款1000元等。&lt;/p&gt;

&lt;h2 id=&quot;故障预防&quot;&gt;3.1.故障预防&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;a.规范代码规范、数据库设计规范、日志和告警打点规范&lt;/li&gt;
&lt;li&gt;b.规范git分支建立和合并、规范测试流程【全面的单元测试、是否需要测试介入等&lt;/li&gt;
&lt;li&gt;c.规范Review制度，明确审核的责任【至少要识别出代码上线带来的风险，以明确Review的仔细程度】&lt;/li&gt;
&lt;li&gt;d.规范上线流程【每个项目都需要上线计划，包括配置、数据库、代码项目和发布顺序、回滚方案等】&lt;/li&gt;
&lt;li&gt;f.引入灰度发布、预发和监控机制，灰度应用出现问题及时回滚&lt;/li&gt;
&lt;li&gt;e.规范【数据清洗】等高风险行为，高度重视这类操作【容易被忽视】，必须提供完整方案【包括是否备份、如何回滚等】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tip:&lt;/p&gt;
&lt;p&gt;以上内容很多是站在比较理想的角度去思考的，实务中，一定要根据具体业务、成本考量、团队能力等因素进行剪裁和权衡，&lt;strong&gt;㊗️永远都没有线上故障。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;名词解释&quot;&gt;名词解释&lt;/h3&gt;
&lt;p&gt;SOP: Standard Operating Procedure标准操作流程，就是将某一事件的标准操作步骤和要求以统一的格式描述出来，用来指导和规范日常的工作&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 03:56:00 +0000</pubDate>
<dc:creator>熊二哥</dc:creator>
<og:description>周末早上，一个哥们突然@我，问是否有线上故障处理和定级的规范或者模板，虽然手头有既有文档，但内容显的太具象了，跟我们的业务有很强的关联性，并不是那么好直接复制到他的团队中。因此，个人对过去的线上故障处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiong2ge/p/bughandle_standard.html</dc:identifier>
</item>
<item>
<title>windows与unix思想 - jin_hao_chen</title>
<link>http://www.cnblogs.com/megachen/p/9941660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/megachen/p/9941660.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;windows与unix思想 - jin_hao_chen - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;Unix与Windows的思想 + Unix中的哲学是“一切皆文件”，这里的一切皆文件是一个广泛的概念，有一些特殊的设备文件，在/dev目录下 物理设备在Unix中就对应一个特殊的设备文件，比如打印机&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=-duj5vpGTntb85GJoM3iRI972XwWcI-j8zmqDzyfu2w1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife.css?v=g4Oce5UBaUn_FUwadcT09ICEg5NkULQGtUpNhTtrI8U1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/CodingLife/bundle-CodingLife-mobile.css?v=Xay8b9tTSw814nBzbOgvS6rrbcxrobMhvHJHdZAO9vI1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/megachen/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/megachen/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/megachen/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;

&lt;ul&gt;&lt;li&gt;Unix中的哲学是“一切皆文件”，这里的一切皆文件是一个广泛的概念，有一些特殊的设备文件，在/dev目录下
&lt;ul&gt;&lt;li&gt;物理设备在Unix中就对应一个特殊的设备文件，比如打印机就是/dev/lp0，这个设备文件直接与物理设备的串行端口连接，只要向这个设备文件中传入数据，就可以调用打印机。&lt;/li&gt;
&lt;li&gt;而没有与物理设备直接连接的特殊的设备文件，称之为伪设备文件。伪设备文件一般都是成对出现的，就像是打电话一样，通过这种逻辑关系就可以实现与物理设备一样的功能，比如在伪设备的一端发送一串字符串，在另一端就会就收到这个字符串，另一端可能的操作就是将这个字符串原样返回，或者对其进行加密再返回，在或者将其传送到/dev/lp0设备文件中调用打印机打印文件。&lt;/li&gt;
&lt;li&gt;在Unix中命令行中的字符都将会被转换成为文件序列（文件流），这样才能够实现“一切皆文件”的思想，任何东西都可以被抽象成文件流。&lt;/li&gt;
&lt;li&gt;在Unix中，要使用命令行，先启动一个终端，接着启动一个shell，shell和终端通过pty伪终端设备通信，也就是在mac下，我们鼠标点击terminal这个终端应用程序，在进入到终端的程序之后，会默认启动一个shell，但是在windows中却是用户只能启动命令行程序，而不能启动终端，在Windows中我们没有看见过一个terminal程序，只要我们启动了一个shell，如cmd或者powershell，windows会自动为我们启动一个一个的控制台，将他们依附在一起。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;windows中的哲学是“一切皆对象“
&lt;ul&gt;&lt;li&gt;在早期的windows中，其实也是参考着Unix的哲学思想，创建一些特殊的设备文件，比如要打印文件，就将文件输出到DLT设备文件中就行了，windows中的特殊文件与文件系统是分离的，他们是直接在内核中实现了，所有特殊文件的作用是是全局的，不管是在C:还是在E:中，都是可以直接使用PRN名称的，而不像是其他文件一样，需要提供相对路径或者绝对路径。&lt;/li&gt;
&lt;li&gt;后来随着面向对象思想的发展，windows开始采用面向对象的思想进行设计，一提到面向对象，就应该联想到API，所有windows的”一切皆对象“就是”面向API“编程。但是windows有为了兼容老的版本，还是保留了之前”一切皆文件“的特殊设备文件。所以现在的windows就有了一个bug，命名的文件去掉扩展名之后不能使windows为了兼容而保留的特殊设备文件的文件名，比如aux.txt, aux.h, con.txt等等，其他他们在windows中已经用的不多了，在windows都是采用API实现这些了。&lt;/li&gt;
&lt;li&gt;在命令行程序中键入的字符，虽然我们看到的是和在Unix shell中见到的一样，都是字符串，但是在回车之后就完全不听了，在Unix中会将内容转换为文件流，而Windows会将其转换为消息进行传输，也就是调用等效的API，为Console API，也就是说，如果我们现在想要实现一个Powershell，那么一定会疯狂的调用Console API。虽然在Unix中写bash也是调用api的进行系统调用的，但是两者在内部的实现是不同的，在windows中的会将其封装成对象，接着在调用对象的API，而在Unix中则是直接操作的，没有加上对象这一层。为了能够变出跨平台的程序（以桌面程序为例），比如qt等，他们提供了统一的接口，在内部实现上调用了两个操作系统的API。调用Windows的API一般需要获取句柄，接着通过这个句柄调用对应的函数，而在Unix中就是函数，windows的API数量是Unix的好几倍。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2018-11-11 11:45&lt;/span&gt; &lt;a href=&quot;https://www.cnblogs.com/megachen/&quot;&gt;jin_hao_chen&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9941660&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/megachen/p/9941660.html#&quot; onclick=&quot;AddToWz(9941660);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sun, 11 Nov 2018 03:45:00 +0000</pubDate>
<dc:creator>jin_hao_chen</dc:creator>
<og:description>Unix与Windows的思想 + Unix中的哲学是“一切皆文件”，这里的一切皆文件是一个广泛的概念，有一些特殊的设备文件，在/dev目录下 物理设备在Unix中就对应一个特殊的设备文件，比如打印机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/megachen/p/9941660.html</dc:identifier>
</item>
</channel>
</rss>