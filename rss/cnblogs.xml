<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Spark】Spark  Quick Start（快速入门翻译） - 早起的虫儿去吃鸟</title>
<link>http://www.cnblogs.com/yeyeck/p/9652117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyeck/p/9652117.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;strong&gt;本文主要是翻译Spark官网Quick Start。只能保证大概意思，尽量保证细节。英文水平有限，如果有错误的地方请指正，轻喷&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;　　使用 Spark Shell 交互式编程&lt;/h2&gt;
&lt;h3&gt;　　　　基本操作&lt;/h3&gt;
&lt;h3&gt;　　　　更多关于 Dataset 的操作&lt;/h3&gt;
&lt;h3&gt;　　　　缓存&lt;/h3&gt;
&lt;h2&gt;　　独立的应用程序&lt;/h2&gt;
&lt;h2&gt;　　下一步&lt;/h2&gt;
&lt;p&gt;这个指南提供了使用Spark的快速介绍。我们会首先介绍Spark 交互式编程(使用Python或者Scala)的 API， 然后展示如何用Java、Scala 和 Python来编写应用程序。&lt;/p&gt;
&lt;p&gt;为了使用这个指南，您需要先从 &lt;a href=&quot;http://spark.apache.org/downloads.html&quot; target=&quot;_blank&quot;&gt;Spark 网页&lt;/a&gt; 下载打包发布的Spark安装包。由于我们将不会（在指南中）使用HDFS， 您可以下载任意版本的Hadoop安装包。&lt;/p&gt;
&lt;p&gt;需要注意的是，Spark2.0 之前， Spark的主要编程接口是弹性分布式数据集（Resilient Distributed Dataset (RDD)）。Spark2.0 之后， RDD 被 Dataset 取代，Dataset 和 RDD 一样是强类型，但是在底层进行了更多的优化。Spark2.0 之后仍然支持 RDD 接口，并且您可以从&lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html&quot; target=&quot;_blank&quot;&gt;RDD编程指南中&lt;/a&gt; 获取更详细的参考。当然，我们强烈建议您选择使用Dataset， 因为它的性能比RDD更好。 查看 &lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html&quot; target=&quot;_blank&quot;&gt;SQL编程指南&lt;/a&gt; 以得到更多关于Dataset的信息。&lt;/p&gt;
&lt;h2&gt;使用 Spark Shell 交互式编程&lt;/h2&gt;
&lt;h3&gt;基本操作&lt;/h3&gt;
&lt;p&gt;Spark Shell 提供了一个简单的方式去学习 API，同时也提供了一个强大的交互式数据分析工具。它可以基于 Scala（一种在java 虚拟机上运行并因此可以很好地使用已有的java库的编程语言）或 Python 使用。在 Spark 目录下运行以下内容来开始（Sprk Shell）：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./bin/pyspark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./bin/pyspark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你当前环境使用pip下载了 PySpark，可以使用如下下方式调用&lt;/p&gt;

&lt;p&gt;Spark 主要的抽象是一个被叫做 Dataset 的分布式集合。 Dataset 可以通过 Hadoop InputFormat（比如HDFS文件）或者 转换其他 Dataset 中创建。让我们通过 Spark 源目录下的 README 文件内容创建一个新的 Dataset：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scala&amp;gt; val textFile = spark.read.textFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;README.md&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
textFile: org.apache.spark.sql.Dataset[String] &lt;/span&gt;= [value: &lt;span&gt;string&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; textFile = spark.read.text(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;README.md&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以直接从Dataset中， 通过调用一些操作或者转化Dataset以获得一个新的Dataset来获取它的值。请阅读 API 文档（&lt;a href=&quot;http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.Dataset&quot; target=&quot;_blank&quot;&gt;Scala&lt;/a&gt; / &lt;a href=&quot;http://spark.apache.org/docs/latest/api/python/index.html#pyspark.sql.DataFrame&quot; target=&quot;_blank&quot;&gt;Python&lt;/a&gt;）  以获取更多细节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
scala&amp;gt; textFile.count() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该Dataset中的成员数量&lt;/span&gt;
res0: Long = &lt;span&gt;126&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  由于README.md 会随着时间的推移不断改变，所以结果可能会有所不同， 其他输出也有类似情况&lt;/span&gt;
&lt;span&gt;
scala&lt;/span&gt;&amp;gt; textFile.first() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该Dataset的第一个成员&lt;/span&gt;
res1: String = # Apache Spark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; textFile.count()  # 该DataFrame中的行数
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; textFile.first()  # 该DataFrame的第一行
Row(value&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;# Apache Spark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们使用该Dataset来转换成一个新的Dataset。 我们调用 filter 来返回一个新的Dataset， 其中包含这个文件内容的子集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scala&amp;gt; val linesWithSpark = textFile.filter(line =&amp;gt; line.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
linesWithSpark: org.apache.spark.sql.Dataset[String] &lt;/span&gt;= [value: &lt;span&gt;string&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; linesWithSpark = textFile.filter(textFile.value.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以将数据集转换和数据集操作串接在一起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scala&amp;gt; textFile.filter(line =&amp;gt; line.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).count() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; How many lines contain &quot;Spark&quot;?&lt;/span&gt;
res3: Long = &lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; textFile.filter(textFile.value.contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).count()  # How many lines contain &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?
&lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;更多关于Dataset的操作&lt;/h3&gt;
&lt;p&gt;Dataset操作和转换可以用来做更复杂的计算。假设我们想要找到单词数量最多的那行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
scala&amp;gt; textFile.map(line =&amp;gt; line.&lt;span&gt;split&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;).size).reduce((a, b) =&amp;gt; &lt;span&gt;if&lt;/span&gt; (a &amp;gt; b) a &lt;span&gt;else&lt;/span&gt;&lt;span&gt; b)
res4: Long &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这首先将文件中的一行映射成一个整数值，并创建一个新的Dataset。调用该 Dataset 的 reduce 方法以找到最大的单词计数。map 和 reduce 的参数是 Scala 的函数字面量（闭包），并且可以使用任何语言的特性或者 Scala/Java 库。 比如， 我们可以很荣誉地调用任何地方声明地函数（方法）。我们将使用 Math.max() 方法以使这段代码易于理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
scala&amp;gt;&lt;span&gt; import java.lang.Math
import java.lang.Math

scala&lt;/span&gt;&amp;gt; textFile.map(line =&amp;gt; line.&lt;span&gt;split&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;).size).reduce((a, b) =&amp;gt;&lt;span&gt; Math.max(a, b))
res5: Int &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MapReduce是一种常见的数据流格式， 这是由Hadoop推广的。Spark 可以很容易地实现MapReduce流：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
scala&amp;gt; val wordCounts = textFile.flatMap(line =&amp;gt; line.&lt;span&gt;split&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).groupByKey(identity).count()
wordCounts: org.apache.spark.sql.Dataset[(String, Long)] &lt;/span&gt;= [value: &lt;span&gt;string&lt;/span&gt;, count(&lt;span&gt;1&lt;/span&gt;): bigint]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，我们调用 flatMap 来将一个行级（以文本中的一行为一个成员（Item））的 Dataset 转换成一个 单词 级 的Dataset，然后串接调用 groupByKey 和 count 方法 来计算文件中的每个单词的数量作为（String， Long）数据对形式 的Dateset。 为了在我们的shell中统计出单词的数量， 我们可以调用 collect 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
scala&amp;gt;&lt;span&gt; wordCounts.collect()
res6: Array[(String, Int)] &lt;/span&gt;= Array((means,&lt;span&gt;1&lt;/span&gt;), (under,&lt;span&gt;2&lt;/span&gt;), (this,&lt;span&gt;3&lt;/span&gt;), (Because,&lt;span&gt;1&lt;/span&gt;), (Python,&lt;span&gt;2&lt;/span&gt;), (agree,&lt;span&gt;1&lt;/span&gt;), (cluster.,&lt;span&gt;1&lt;/span&gt;), ...)&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; from pyspark.sql.functions import *
&amp;gt;&amp;gt;&amp;gt; textFile.&lt;span&gt;select&lt;/span&gt;(size(&lt;span&gt;split&lt;/span&gt;(textFile.value, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\s+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).name(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numWords&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).agg(max(col(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numWords&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))).collect()
[Row(max(numWords)&lt;/span&gt;=&lt;span&gt;15&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这首先将文件中的一行映射成一个整数值 并取一个为 “numWords” 的别名，同时创建一个新的DataFrame。调用该 Dataset 的 agg 方法以找到最大的单词计数。select 和 agg 的参数都是 &lt;a href=&quot;http://spark.apache.org/docs/latest/api/python/index.html#pyspark.sql.Column&quot; target=&quot;_blank&quot;&gt;Colum&lt;/a&gt;，我们可以使用 df.colName 方法来从一个DataFrame中获得一个 colum。我们同样可以导入 pyspark.sql.functions， 它提供了很多简易的方法从一个已有的 Colum 构建一个新的 Colum。&lt;/p&gt;
&lt;p&gt;MapReduce是一种常见的数据流格式， 这是由Hadoop推广的。Spark 可以很容易地实现MapReduce流：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; wordCounts = textFile.&lt;span&gt;select&lt;/span&gt;(explode(&lt;span&gt;split&lt;/span&gt;(textFile.value, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\s+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).alias(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).groupBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).count()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，我们在 select 方法中使用了 explode 方法来将一个行级（以文本中的一行为一个成员（Item））的 Dataset 转换成一个 单词 级 的Dataset。然后串接调用 groupByKey 和 count 方法 来计算文件中的每个单词的数量作为一个拥有两个Colum：“word” 和 “count” 的DataFrame。 为了在我们的shell中统计出单词的数量， 我们可以调用 collect 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; wordCounts.collect()
[Row(word&lt;/span&gt;=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;online&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, count=&lt;span&gt;1&lt;/span&gt;), Row(word=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;graphs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, count=&lt;span&gt;1&lt;/span&gt;), ...]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;缓存（Caching）&lt;/h3&gt;
&lt;p&gt;Spark同样支持将数据集加入到一个集群中的内存缓存中。当数据被重复访问时，这是非常有用的。比如查询一个小的热点数据集 或者 运行像PageRank 这样的迭代算法。让我们标记我们的 &lt;code&gt;linesWithSpark&lt;/code&gt;  作为缓存数据 来作为一个例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
scala&amp;gt;&lt;span&gt; linesWithSpark.cache()
res7: linesWithSpark.type &lt;/span&gt;= [value: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;]

scala&lt;/span&gt;&amp;gt;&lt;span&gt; linesWithSpark.count()
res8: Long &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;

scala&lt;/span&gt;&amp;gt;&lt;span&gt; linesWithSpark.count()
res9: Long &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Python 版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; linesWithSpark.cache()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; linesWithSpark.count()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; linesWithSpark.count()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Spark来探索和缓存一个100行的文本文件看起来很蠢。有趣的是，这些方法同样可以作用在非常大的数据集中，哪怕它们被分布在数十个或上百个节点中。正如 &lt;a href=&quot;http://spark.apache.org/docs/latest/rdd-programming-guide.html#using-the-shell&quot; target=&quot;_blank&quot;&gt;RDD编程指南&lt;/a&gt; 中描述的那样， 您可以通过连接 bin/spark-shell 到一个集群中来进行以上交互式操作。&lt;/p&gt;
&lt;h2&gt;独立的应用程序&lt;/h2&gt;
&lt;p&gt;假设我们希望使用 Spark API 编写一个独立的 应用程序。  我们将分别使用Scala(带sbt)，Java(带Maven) 和 Python（pip） 编写一个简单的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将在 Scala 中创建一个Spark 应用程序——非常简单。 实际上，它被命名为 SimleApp.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
/* SimpleApp.scala */
import org.apache.spark.sql.SparkSession

object SimpleApp {
  def main(args: Array[String]) {
    val logFile = &quot;YOUR_SPARK_HOME/README.md&quot; // Should be some file on your system
    val spark = SparkSession.builder.appName(&quot;Simple Application&quot;).getOrCreate()
    val logData = spark.read.textFile(logFile).cache()
    val numAs = logData.filter(line =&amp;gt; line.contains(&quot;a&quot;)).count()
    val numBs = logData.filter(line =&amp;gt; line.contains(&quot;b&quot;)).count()
    println(s&quot;Lines with a: $numAs, Lines with b: $numBs&quot;)
    spark.stop()
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这个应用程序需要定义一个 main() 方法 而不是 继承 scala.App. scala.App 的子类可能无法正常地工作。&lt;/p&gt;
&lt;p&gt;这个程序只是统计 Spark README 文件中包含 “a” 的行数和 包含&quot;b&quot; 的行数。 注意， 您需要使用 Spark 的安装位置 来代替 YOUR_SPARK_HOME。与之前Spark Shell中的例子不同的是，Spark Shell 初始化它自己的SparkSession， 而我们初始化一个SparkSeesion作为程序的一部分。&lt;/p&gt;
&lt;p&gt;我们调用 SparkSession.builder 来构造一个 【SparkSession】，然后设置应用的名字， 最后调用 getOrCreate 方法获取一个 【SparkSession】实例。&lt;/p&gt;
&lt;p&gt;我们的应用程序取决于Spark API， 所以我们同样需要一个 sbt 配置文件， build.sbt， 这表示 Spark 是一个依赖组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
name := &quot;Simple Project&quot;

version := &quot;1.0&quot;

scalaVersion := &quot;2.11.8&quot;

libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-sql&quot; % &quot;2.3.1&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了使 sbt 能够正常工作， 我们需要根据经典的目录结构布局 SimpleApp.scala 和 build.sbt。一旦完成这些，我们就可以创建一个包含这个应用程序源代码的JAR包， 然后使用 spark-submit 脚本运行我们的程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Your directory layout should look like this
$ &lt;/span&gt;&lt;span&gt;find&lt;/span&gt;&lt;span&gt; .
.
.&lt;/span&gt;/&lt;span&gt;build.sbt
.&lt;/span&gt;/&lt;span&gt;src
.&lt;/span&gt;/src/&lt;span&gt;main
.&lt;/span&gt;/src/main/&lt;span&gt;scala
.&lt;/span&gt;/src/main/scala/&lt;span&gt;SimpleApp.scala

# Package a jar containing your application
$ sbt package
...
[&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;] Packaging {..}/{..}/target/scala-&lt;span&gt;2.11&lt;/span&gt;/simple-project_2.&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar

# Use spark&lt;/span&gt;-&lt;span&gt;submit to run your application
$ YOUR_SPARK_HOME&lt;/span&gt;/bin/spark-&lt;span&gt;submit \
  &lt;/span&gt;--class &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SimpleApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--master local[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] \
  target&lt;/span&gt;/scala-&lt;span&gt;2.11&lt;/span&gt;/simple-project_2.&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar
...
Lines with a: &lt;/span&gt;&lt;span&gt;46&lt;/span&gt;, Lines with b: &lt;span&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;这个例子将会使用 Maven 编译一个JAR 应用程序，但是很多类似的构建系统都可以工作。&lt;/p&gt;
&lt;p&gt;我们将创建一个简单的Spark应用程序， SimpleApp.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; SimpleApp.java &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.SparkSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.Dataset;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleApp {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    String logFile &lt;/span&gt;= &quot;YOUR_SPARK_HOME/README.md&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Should be some file on your system&lt;/span&gt;
    SparkSession spark = SparkSession.builder().appName(&quot;Simple Application&quot;&lt;span&gt;).getOrCreate();
    Dataset&lt;/span&gt;&amp;lt;String&amp;gt; logData =&lt;span&gt; spark.read().textFile(logFile).cache();

    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; numAs = logData.filter(s -&amp;gt; s.contains(&quot;a&quot;&lt;span&gt;)).count();
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; numBs = logData.filter(s -&amp;gt; s.contains(&quot;b&quot;&lt;span&gt;)).count();

    System.out.println(&lt;/span&gt;&quot;Lines with a: &quot; + numAs + &quot;, lines with b: &quot; +&lt;span&gt; numBs);

    spark.stop();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个程序只是统计 Spark README 文件中包含 “a” 的行数和 包含&quot;b&quot; 的行数。 注意， 您需要使用 Spark 的安装位置 来代替 YOUR_SPARK_HOME。与之前Spark Shell中的例子不同的是，Spark Shell 初始化它自己的SparkSession， 而我们初始化一个SparkSeesion作为程序的一部分。&lt;/p&gt;
&lt;p&gt;为了构建这个程序， 我们同样要编写一个 Maven pom.xml 文件，这个文件将 Spark 列为一个依赖组件。请注意，Spark 构件 被标记为Scala版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;edu.berkeley&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;simple-project&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Simple Project&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Spark dependency &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.spark&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spark-sql_2.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.3.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们根据规范的Maven目录结构列出这些文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ find .
./pom.xml
./src
./src/main
./src/main/java
./src/main/java/SimpleApp.java&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我们可以使用 Maven 打包这个应用程序并且 通过 &lt;code&gt;./bin/spark-submit&lt;/code&gt;. 执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Package a JAR containing your application
$ mvn package
...
[INFO] Building jar: {..}&lt;/span&gt;/{..}/target/simple-project-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar

# Use spark&lt;/span&gt;-&lt;span&gt;submit to run your application
$ YOUR_SPARK_HOME&lt;/span&gt;/bin/spark-&lt;span&gt;submit \
  &lt;/span&gt;--class &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SimpleApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--master local[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] \
  target&lt;/span&gt;/simple-project-&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;.jar
...
Lines with a: &lt;/span&gt;&lt;span&gt;46&lt;/span&gt;, Lines with b: &lt;span&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们将展示如何使用Python API（PySpark）来编写一个应用程序&lt;/p&gt;
&lt;p&gt;如果你正构建一个打包的 PySpark应用程序或库，你可以将它添加到你的 setup.py 文件中， 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install_requires=&lt;span&gt;[
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pyspark=={site.SPARK_VERSION}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为示例，我们将创建一个简单的 Spark 应用程序, SimpleApp.py:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;SimpleApp.py&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyspark.sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SparkSession

logFile &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YOUR_SPARK_HOME/README.md&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Should be some file on your system&lt;/span&gt;
spark = SparkSession.builder.appName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SimpleApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getOrCreate()
logData &lt;/span&gt;=&lt;span&gt; spark.read.text(logFile).cache()

numAs &lt;/span&gt;= logData.filter(logData.value.contains(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).count()
numBs &lt;/span&gt;= logData.filter(logData.value.contains(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).count()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lines with a: %i, lines with b: %i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (numAs, numBs))

spark.stop()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个程序只是统计 Spark README 文件中包含 “a” 的行数和 包含&quot;b&quot; 的行数。 注意， 您需要使用 Spark 的安装位置 来代替 YOUR_SPARK_HOME。与之前Spark Shell中的例子不同的是，Spark Shell 初始化它自己的SparkSession， 而我们初始化一个SparkSeesion作为程序的一部分。和 Scala 和 Java 例子一样， 我们使用 SparkSession 来创建 Dataset 。 对于使用自定义类或者第三方库的应用程序， 我们同样可以通过它的 --py-- files 参数将代码和依赖打包成zip文件（使用 spark-submit --help 查看细节）的形式 添加到 spark-submit。 SimpleApp 足够简单， 所以我们不用指定任何代码依赖组件。&lt;/p&gt;
&lt;p&gt;我们使用 bin/spark-submit 脚本运行这个程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# Use spark-&lt;span&gt;submit to run your application
$ YOUR_SPARK_HOME&lt;/span&gt;/bin/spark-&lt;span&gt;submit \
  &lt;/span&gt;--master local[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] \
  SimpleApp.py
...
Lines with a: &lt;/span&gt;&lt;span&gt;46&lt;/span&gt;, Lines with b: &lt;span&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果您将PySpark通过 pip 安装到了您的环境中（eg. pip install pyspark），根据您的喜好，可以使用常规的Python解释器 或者 使用 spark-submit 来运行您的程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Use the Python interpreter to run your application
$ python SimpleApp.py
...
Lines with a: &lt;/span&gt;&lt;span&gt;46&lt;/span&gt;, Lines with b: &lt;span&gt;23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;下一步&lt;/h2&gt;
&lt;p&gt;祝贺您运行了您的第一个 Spark 应用程序&lt;/p&gt;
&lt;p&gt;　　关于API的深入概述，请从 &lt;a href=&quot;http://spark.apache.org/docs/latest/rdd-programming-guide.html&quot; target=&quot;_blank&quot;&gt;RDD 编程指南&lt;/a&gt; 和 &lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html&quot; target=&quot;_blank&quot;&gt;SQL 编程指南&lt;/a&gt; 开始， 或者 查看编程指南菜单 以了解其他组件&lt;/p&gt;
&lt;p&gt;　　关于使用集群运行应用程序，请移步 &lt;a href=&quot;http://spark.apache.org/docs/latest/cluster-overview.html&quot; target=&quot;_blank&quot;&gt;部署概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　最后， Spark 包含了几个简单的例子， 它们被保存在 example 目录下（Scala， Java， Python， R），你可以按照以下方式运行它们：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# For Scala and Java, use run-&lt;span&gt;example:
.&lt;/span&gt;/bin/run-&lt;span&gt;example SparkPi

# For Python examples, use spark&lt;/span&gt;-&lt;span&gt;submit directly:
.&lt;/span&gt;/bin/spark-submit examples/src/main/python/&lt;span&gt;pi.py

# For R examples, use spark&lt;/span&gt;-&lt;span&gt;submit directly:
.&lt;/span&gt;/bin/spark-submit examples/src/main/r/dataframe.R
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 15 Sep 2018 17:31:00 +0000</pubDate>
<dc:creator>早起的虫儿去吃鸟</dc:creator>
<og:description>本文主要是翻译Spark官网Quick Start。只能保证大概意思，尽量保证细节。英文水平有限，如果有错误的地方请指正，轻喷 快速入门（Quick Start） 使用 Spark Shell 交互式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyeck/p/9652117.html</dc:identifier>
</item>
<item>
<title>链表检测环算法，找到环中的出口节点 - 肥宅成长日记</title>
<link>http://www.cnblogs.com/feizhai/p/9653264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feizhai/p/9653264.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;如何判断一个链表有环&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 &lt;/strong&gt;&lt;span&gt;方法是使用快慢指针，通过一个slow指针（每次都指向下一个），一个quick指针（每次都指向下面两个）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　  因为假设有环的话，quick会追上slow指针&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　  找到环出口就是通过slow指针指向头节点，quick指针指向之前环的交叉点，然后一直以不同速度遍历直到相遇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      这样找到的就是出口节点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　   java实现方法如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; 测评;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main5 {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; node&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; node {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         node next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; node create() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         node first = &lt;span&gt;new&lt;/span&gt; node(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         node node =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt; 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             node.next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; node(i);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             node =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         node node2 =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt; 6&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i == 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 node.next =&lt;span&gt; node2;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 node2 =&lt;span&gt; node2.next;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test_circle() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         node first =&lt;span&gt; create();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快慢指针方法判断是否为环&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         node quick =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         node slow =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt; 1000&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             quick =&lt;span&gt; quick.next.next;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             slow =&lt;span&gt; slow.next;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quick ==&lt;span&gt; slow) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 System.out.println(&quot;这个是一个环&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主要是通过快慢指针来判断，慢指针从first节点触发，快指针从交叉点出发，最后的交点就是出口节点&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test_getNode() {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         node first =&lt;span&gt; create();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快慢指针方法判断是否为环&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         node jiaodian = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         node quick =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         node slow =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt; 1000&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             quick =&lt;span&gt; quick.next.next;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             slow =&lt;span&gt; slow.next;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quick ==&lt;span&gt; slow) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         slow =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(i&amp;lt;1000&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             slow =&lt;span&gt; slow.next;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;             quick =&lt;span&gt; quick.next.next;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(slow ==&lt;span&gt; quick) {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 System.out.println(&quot;出口节点&quot;+&lt;span&gt;slow.val);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;第二个问题就是判断两个链表是否有交点&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　   判断还是很简单的，只要将两个链表遍历到尾节点，如果尾节点相同，这样就证明这两个链表是有交点的&lt;/p&gt;
&lt;p&gt;　　如何找到两个链表相交的节点？&lt;/p&gt;
&lt;p&gt;　　方法：遍历两个链表的长度，然后长链表长度减去短链表长度为K，让长链表减去K，然后两个链表逐个对比&lt;/p&gt;
&lt;p&gt;　　Java代码&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个链表&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         node first1 = &lt;span&gt;new&lt;/span&gt; node(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         node node1 =&lt;span&gt; first1;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         node first2 = &lt;span&gt;new&lt;/span&gt; node(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         node node2 =&lt;span&gt; first2;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(i&amp;lt;5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             node1.next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; node(i);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         i=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(i&amp;lt;5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             node2.next = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; node(i);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         node ban = &lt;span&gt;new&lt;/span&gt; node(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         node node3 =&lt;span&gt; ban;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         i=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(i&amp;lt;5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             node3 = &lt;span&gt;new&lt;/span&gt; node(i+5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         node1.next =&lt;span&gt; ban;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         node2.next =&lt;span&gt; ban;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是判断&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length_1 = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length_2 = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         node1 =&lt;span&gt; first1;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         node2 =&lt;span&gt; first2;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(node1 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             length_1++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             node1 =&lt;span&gt; node1.next;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(node2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             length_2++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             node2 =&lt;span&gt; node2.next;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(length_1&amp;gt;=&lt;span&gt;length_2) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             k = length_1-&lt;span&gt;length_2;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(j&amp;lt;&lt;span&gt;k) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 first1 =&lt;span&gt; first1.next;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             k = length_2 -&lt;span&gt; length_1;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(j&amp;lt;&lt;span&gt;k) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 first2 =&lt;span&gt; first2.next;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(first1 ==&lt;span&gt; first2) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 System.out.println(&quot;共同节点&quot;+&lt;span&gt;first1.val);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             first1 =&lt;span&gt; first1.next;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             first2 =&lt;span&gt; first2.next;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 15 Sep 2018 16:47:00 +0000</pubDate>
<dc:creator>肥宅成长日记</dc:creator>
<og:description>如何判断一个链表有环 方法是使用快慢指针，通过一个slow指针（每次都指向下一个），一个quick指针（每次都指向下面两个） 因为假设有环的话，quick会追上slow指针 找到环出口就是通过slow</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feizhai/p/9653264.html</dc:identifier>
</item>
<item>
<title>结合生活，剖析《生产者消费者模型》-java多线程（一） - PeterWilliam</title>
<link>http://www.cnblogs.com/weipt0106/p/9653215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weipt0106/p/9653215.html</guid>
<description>&lt;p&gt;　　博客园的园友们好，看博客园上各位大佬的文章，已陪伴了我程序员职业的三年，&lt;/p&gt;
&lt;p&gt;如今自己同样希望能把自己从小白到菜鸟的成长过程分享给大家。不定期更新！！！&lt;/p&gt;
&lt;p&gt;首先我本人智商不高，理解问题十分吃力，完全不属于天才的行列，因此学习每一个知识&lt;/p&gt;
&lt;p&gt;都喜欢刨根问底，结合生活，彻彻底底理解知识的本质！&lt;/p&gt;
&lt;p&gt;进入正题，这篇文章，主要站在一个初学者的角度，结合经典的“生产者消费者模型”，写一个java多线程例子！&lt;/p&gt;
&lt;p&gt;首先解释几个概念：&lt;/p&gt;
&lt;p&gt;　　1、#进程：通俗的讲，就是一个程序一次执行的过程。&lt;span&gt;&lt;strong&gt;是系统进行资源分配和调度的一个独立单位。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2、#线程：一个进程的生命周期，由一个或若干个线程完成。&lt;span&gt;&lt;strong&gt;是CPU调度和分派的基本单位。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;3、#并行：&lt;span&gt;&lt;strong&gt;同一时间点或者时间段&lt;/strong&gt;&lt;/span&gt;，可以处理超过一个任务的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　eg:你正在lol，女朋友来电话，于是&lt;/span&gt;你单手操作或者侧头夹住手机，既聊天又打团，这就是你自己并行处理了，&lt;/p&gt;
&lt;p&gt;撩妹和打游戏。这个过程，你就类似于cpu，前提你是多核。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、#并发：主要针对多线程提出的概念。可以在一个时间段，交替执行不同事情的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　eg:你正在lol，女朋友来电话，于是你挂机去接电话，然后打完电话回来面对腾讯的裁决。或者你等着打完团，然后&lt;/p&gt;
&lt;p&gt;面对女友的生气。这就是并发，你交替执行了不同事情。这个过程，你也类似于cpu，可以不用多核。&lt;/p&gt;
&lt;p&gt;二、简单代码实现多线程&lt;/p&gt;
&lt;p&gt;　　2.1模型图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1478903/201809/1478903-20180915235203365-1654980225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释：张全蛋经过自己的努力，进入富士康工厂工作，主要负责生产时下流行的iPhoneXs，然后广大果粉在库存充足的情况下购买iPhoneXs。&lt;/p&gt;
&lt;p&gt;这个过程共涉及以下角色和过程：&lt;/p&gt;
&lt;p&gt;　　1、生产者（张全蛋）。&lt;/p&gt;
&lt;p&gt;　　2、消费者（广大果粉）。&lt;/p&gt;
&lt;p&gt;　　3、产品（iPhoneXs）。&lt;/p&gt;
&lt;p&gt;　　4、生产产品，购买产品。&lt;/p&gt;
&lt;p&gt;2.2 程序展示&lt;/p&gt;
&lt;p&gt;　　2.2.1  产品类&lt;/p&gt;
&lt;p&gt;由于我们此次实验过程，主要涉及生产产品，所以我们可以忽略产品本身具有的属性和方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dcits.weipt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 产品实体类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 因我们此次实验是针对生产产品
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * 所以我们忽略产品本身所具有的方法和属性
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; weipt
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * @date 20180915&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.2.2 工厂类&lt;/p&gt;
&lt;p&gt;工厂类用于生产产品，需要注意的是，在java中，生产一个产品，就是new一个产品类的实体对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dcits.weipt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * 生产产品的工厂类
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 生产一个产品则意味着new一个产品对象
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * 消费一个产品则意味着remove一个对象
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; weipt
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * @date 20180915&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductFactory {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Product&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Product&amp;gt;();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用list保存对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 工厂生产产品的方法
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 单位时间生产3个
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makeProduct() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             list.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Product());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 工厂消费产品的方法
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * 单位时间消费1个&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; moveProduct() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         list.remove(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * 获取产品个数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNum() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.size();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.2.3 生产者&lt;/p&gt;
&lt;p&gt;用于不断调用工厂类，生产产品。每当我们生产一次产品，需要调用notify/notifyAll通知或唤醒消费者来购买。&lt;/p&gt;
&lt;p&gt;但当我们生产超过max，需要调用wait，等待消费者购买，减少库存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dcits.weipt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *生产者实体类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; weipt
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @date 20180915&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Producer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_PRODUCT = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductFactory pf;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Producer(ProductFactory pfIn) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pf =&lt;span&gt; pfIn;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        produce();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * 生产者生产，产品
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; produce() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (pf) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (pf.getNum() &amp;gt;=&lt;span&gt; MAX_PRODUCT) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         System.out.println(&quot;warnning! 库存已满，请稍微再生产！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        pf.wait();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    pf.makeProduct();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     System.out.println(&quot;P---》生产者生产了第【&quot; + pf.getNum() + &quot;】个产品&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    pf.notifyAll();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.2.4 消费者&lt;/p&gt;
&lt;p&gt;用于不断调用工厂类，购买产品。每当我们购买一次产品，需要调用notify/notifyAll通知或唤醒生产者去生产。&lt;/p&gt;
&lt;p&gt;但当库存小于min，需要调用wait，等待生产者，增加库存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dcits.weipt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 消费者实体类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; weipt
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * @date 20180915&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MIN_PRODUCT = 0;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品最小值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; ProductFactory pf;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品工厂对象&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 通过构造方法获取产品对象&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consumer(ProductFactory pfIn) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pf =&lt;span&gt; pfIn;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        consume();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * 消费者从库存中取产品
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; consume() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;synchronized&lt;/span&gt; (pf) {           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为生产者和消费者都是对产品操作，所以对产品进行加锁&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (pf.getNum() &amp;lt;=&lt;span&gt; MIN_PRODUCT) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         System.out.println(&quot;warnning! 库存已空，请稍微再取！&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意顺序，要放到wait之前&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                         pf.wait();                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待其他线程操作，直到收到其他线程的notify
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处我没有写notify，因为库存缺货，就只能等生产者生产，唤醒其他消费者没有用&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     System.out.println(&quot;C---》消费者取走了第【&quot; + pf.getNum() + &quot;】个产品&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     pf.moveProduct();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产品出库&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                     pf.notifyAll();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知生产者可以继续生产&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     Thread.sleep(1000);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止日志打印过多，没有可观性&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.2.5 开始工作&lt;/p&gt;
&lt;p&gt;在main方法中，开启消费者和生产者线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dcits.weipt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 公司领导
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * 用于让整个系统运作起来&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloThread{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         ProductFactory pf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProductFactory();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Producer p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(pf);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Consumer c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(pf);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Thread pt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(p);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Thread ct = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(c);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         pt.start();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们可以开启多个消费者或者多个生产者&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        ct.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到这里，这篇文章就彻底结束了。&lt;/p&gt;
&lt;p&gt;注：如需索要编译好的项目源码可关注公众号mht18391859179（扫描下方二维码），回复：&lt;strong&gt;&lt;span&gt;2018091601&lt;/span&gt;&lt;/strong&gt;  免费领取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1478903/201809/1478903-20180916002142764-118951993.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要交流或者指正，可通过上述公众号，或者email：&lt;span&gt;wpt191@163.com&lt;/span&gt;与本人联系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;笨鸟先飞，终生学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;特别鸣谢：&lt;/p&gt;
&lt;p&gt;　　1、感谢胡**，同志的交流与指导。&lt;/p&gt;
&lt;p&gt;　　2、感谢博客园，csdn，知乎等大牛文章的启迪。&lt;/p&gt;

</description>
<pubDate>Sat, 15 Sep 2018 16:26:00 +0000</pubDate>
<dc:creator>PeterWilliam</dc:creator>
<og:description>博客园的园友们好，看博客园上各位大佬的文章，已陪伴了我程序员职业的三年， 如今自己同样希望能把自己从小白到菜鸟的成长过程分享给大家。不定期更新！！！ 首先我本人智商不高，理解问题十分吃力，完全不属于天</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weipt0106/p/9653215.html</dc:identifier>
</item>
<item>
<title>你也可以手绘二维码（二）纠错码字算法：数论基础及伽罗瓦域GF（2^8） - 云是风的梦</title>
<link>http://www.cnblogs.com/lijinfeng042/p/9653088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijinfeng042/p/9653088.html</guid>
<description>&lt;p&gt;摘要：本文讲解二维码纠错码字生成使用到的数学数论基础知识，伽罗瓦域（Galois Field）GF（2^8），这是手绘二维码填格子理论基础，不想深究可以直接跳过。同时数论基础也是Hash算法，RSA算法等密码学的入门基础。&lt;/p&gt;
&lt;p&gt;二维码生成算法最为核心的就是编码规则和纠错码字的生成。本篇专门讲解纠错涉及到的伽罗瓦域（Galois Field）。本文内容大部分是阅读《密码编码学与网络安全》后参考相关PPT编写，如有遗漏或不严谨地方请参考专业书籍。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;整除因数素数&quot;&gt;整除，因数，素数&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;设 a , b(b≠0) 是两个整数，如果存在另外一个整数 c 使得 a=b·c ,则称 b 整除 a,记为 b|a,且称 b 为 a 的因子。如果 p (p&amp;gt;1) 的因子只有 ±1，±p，称整数 p 是素数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模&quot;&gt;模&lt;/h2&gt;
&lt;p&gt;如果 a 和 n(n≠0) 是两个整数，则定义 a mod n 是 a 除以 n 所得的余数。正整数 n 称为模数。因此对于任意整数 a 可以写出:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;a = qn + r (0&amp;lt;=r&amp;lt;n);q= ⌊a/n⌋&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;a = ⌊a/n⌋ * n + ( a mod n)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;例子： a = 49,n = 8,则 q = 49 mod 8 = floor(49/8) = 6 , r = 49 mod 8 = 1&lt;br/&gt;,49 = 6 * 8 + 1 .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最大公因数&quot;&gt;最大公因数&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有因子中最大的一个。记为 gcd(a,b)。如果 gcd(a,b) = 1 ,则说 a,b 互素，记为 a⊥b。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Euclid 定理：&lt;strong&gt;对任意非负整数 a 和正整数 b，有 gcd(a, b)=gcd(b, a-b)=gcd(b, a mod b)=gcd(a, b mod a)&lt;/strong&gt;,这也是常见的辗转相除法的理论基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;gcd(18,12)&lt;br/&gt;= gcd(12,18-12) = gcd(12,6) = gcd(6,0) = 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;= gcd(12，18 mod 12) = gcd(12,6) = gcd(6,0) = 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;同余&quot;&gt;同余&lt;/h2&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;如果 (a mod n)=(b mod n)，则称两整数 a 和 b 模 n 同余，记为 a ≡ b mod n。模 n 的剩余类集合定义比 n 小的非负整数集合 Z(n)={0,1,2...,(n-1)}，更准确来说集合中每一个整数都代表一个剩余类。我们将模 n 的剩余类表示为 [0],[1],...[n-1],其中 [r] = {a:a 是一个整数，a ≡ n mod r}.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;mod 在此处的含义表示a和b对于给定的模数有等价关系，和说（a- b）是 n 的整数倍一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;例子：49 mod 8 = 17 mod 8 = 1 ,则 49 ≡ 17 mod 8,等价于 8 | (49 - 17 ) = 8 | 32 显然是成立的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模运算&quot;&gt;模运算&lt;/h2&gt;
&lt;p&gt;模运算的结果都限制在模的剩余类里面，运算封闭这是非常重要的一个性质。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;交换律
&lt;ul&gt;&lt;li&gt;(w+x) mod n=(x+w) mod n&lt;/li&gt;
&lt;li&gt;(w×x) mod n=(x×w) mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结合律
&lt;ul&gt;&lt;li&gt;[(w+x)+y] mod n=[w+(x+y)] mod n&lt;/li&gt;
&lt;li&gt;[(w×x)×y] mod n=[w×(x×y)] mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分配律
&lt;ul&gt;&lt;li&gt;[w×(x+y)] mod n=[w×x+w×y] mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单位元
&lt;ul&gt;&lt;li&gt;(0+w) mod n=w mod n&lt;/li&gt;
&lt;li&gt;(1×w) mod n=w mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加法逆元
&lt;ul&gt;&lt;li&gt;对 w∈Zn 存在z∈Zn，使得w+z≡0 mod n，记z=-w。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加法可约律
&lt;ul&gt;&lt;li&gt;如果 (a+b) ≡ (a+c) mod n，则 b≡c mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;乘法可约律
&lt;ul&gt;&lt;li&gt;如果 (a×b) ≡ (a×c) mod n 且 a 有乘法逆元，那么对 (a×b) ≡ (a×c) mod n 两边同乘以 -a，即得 b ≡ c mod n&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的示例是计算Z(4)=｛0，1，2，3｝的模加法和模乘法&lt;/p&gt;
&lt;h4 id=&quot;加法模运算-a-mod-4-b-mod-4-ab-mod-4&quot;&gt;加法模运算 (a mod 4) + (b mod 4) = (a+b) mod 4&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;加法：对每一 x，都有一 y，使得 x+y ≡ 0 mod 4。如对 3，有 1，使得 3+1 ≡ 0 mod 4，称 y 为 x 的负数，也称为加法逆元。&lt;/p&gt;
&lt;h4 id=&quot;乘法模运算-a-mod-4-b-mod-4-ab-mod-4&quot;&gt;乘法模运算 (a mod 4) * (b mod 4) = (a*b) mod 4&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;乘法：对 x，若有 y，使得 x*y ≡ 1 mod 4，如3×3 ≡ 1 mod 4，则称y为x的倒数，也称为乘法逆元。&lt;br/&gt;&lt;strong&gt;并非每一x都有乘法逆元&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;定理：设 a∈Zn，gcd(a, n) = 1，则 a 在 Zn 中有乘法逆元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上表中只有 a = 1,a = 3 满足 gcd(a,4) = 1,从高亮结果可以看到定理的正确性。严格证明略。&lt;/p&gt;
&lt;h2 id=&quot;扩展的欧几里德算法&quot;&gt;扩展的欧几里德算法&lt;/h2&gt;
&lt;p&gt;对于给定的整数 a 和 b ，扩展的欧几里德算法不仅能计算出最大公约数gcd(a,b)，还可以算出另外两个整数 x 和 y 满足方程 a*x + by = d = gcd(a,b)。对于给定的 (a,b) 如何计算(x,y,d),过程如下：（截图《自密码编码学与网络安全 原理与实践 第6版》 ,斯托林斯著）&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fvaaczrhp4j20ql0c0q5n.jpg&quot; alt=&quot;计算步骤关注公众号：ProgramLife042，公众号名称：风之程序人生&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法流程图如下：默认a &amp;gt; b，否则根据性质可以调整过来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319734/201809/319734-20180915235059697-169544190.png&quot; alt=&quot;扩展的欧几里德算法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最常用的方法就是使用一个表格计算：&lt;br/&gt;gcd(1759,550)= gcd(550,1759 mod 550) =gcd(550,109) = gcd(109,5) = 1&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;---&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1759&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;550&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;1759/550=3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;550&lt;/td&gt;
&lt;td&gt;1-3*0=1&lt;/td&gt;
&lt;td&gt;0-3*1=-3&lt;/td&gt;
&lt;td&gt;109&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;550/109=5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-3&lt;/td&gt;
&lt;td&gt;109&lt;/td&gt;
&lt;td&gt;0-5*1=-5&lt;/td&gt;
&lt;td&gt;1-5*(-3)=16&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;109/5=21&lt;/td&gt;
&lt;td&gt;-5&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1-21*(-5)=106&lt;/td&gt;
&lt;td&gt;-3-21*16=-339&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5/4=1&lt;/td&gt;
&lt;td&gt;106&lt;/td&gt;
&lt;td&gt;-339&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-5-1*106= &lt;strong&gt;-111&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;16-1*(-339)=&lt;strong&gt;355&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;直到 Y3 = 1 ,此时 有 d = Y3 = 1，x = Y1 = -111，y = Y2 = 355. 验算如下： 1759 * (-111) + 550 * (355) = -195249 + 195250 = 1 .&lt;/p&gt;

&lt;p&gt;具体就不展开了，感兴趣可以参考相关专业书籍，截图一张说明他们满足公理的关系&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fvakhz4vgfj20ni0kuqak.jpg&quot; alt=&quot;域，群，环关注公众号：ProgramLife042，公众号名称：风之程序人生&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在数学中，有限域（英语：Finite field）或伽罗瓦域（英语：Galois field，为纪念埃瓦里斯特·伽罗瓦命名）是包含有限个元素的域。与其他域一样，有限域是进行加减乘除运算都有定义并且满足特定规则的集合。有限域最常见的例子是当 p 为素数时，整数对 p 取模。有限域的元素个数称为它的序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E5%9F%9F&quot;&gt;这是维基百科的定义，需要请点击查看更多内容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;每个有限域的阶必为素数的幂，即有限域的阶可表示为 pⁿ（p 是素数，n 是正整数），记为 GF(pⁿ)。当 n = 1，GF(p) 就是 mod p，因为一个数 模p后，结果在 [0, p-1] 之间,有限域包含 p个元素。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下期将会讨论具体的 GF(pⁿ) 编码实现过程，敬请期待！&lt;/p&gt;
&lt;p&gt;感兴趣交流可以留言，共同探讨学习，期望得到你的指正。&lt;br/&gt;你也可以关注公众号：ProgramLife042，公众号名称：风之程序人生。查看更多最新内容。&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/66cf5bc0ly1fv6etki980j20760763yz.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 15:57:00 +0000</pubDate>
<dc:creator>云是风的梦</dc:creator>
<og:description>摘要：本文讲解二维码纠错码字生成使用到的数学数论基础知识，伽罗瓦域（Galois Field）GF（2^8），这是手绘二维码填格子理论基础，不想深究可以直接跳过。同时数论基础也是Hash算法，RSA算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijinfeng042/p/9653088.html</dc:identifier>
</item>
<item>
<title>zuul源码分析-探究原生zuul的工作原理 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9653067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9653067.html</guid>
<description>&lt;p&gt;最近在项目中使用了SpringCloud，基于zuul搭建了一个提供加解密、鉴权等功能的网关服务。鉴于之前没怎么使用过Zuul，于是顺便仔细阅读了它的源码。实际上，zuul原来提供的功能是很单一的：通过一个统一的Servlet入口(ZuulServlet，或者Filter入口，使用ZuulServletFilter)拦截所有的请求，然后通过内建的com.netflix.zuul.IZuulFilter链对请求做拦截和过滤处理。ZuulFilter和javax.servlet.Filter的原理相似，但是它们本质并不相同。javax.servlet.Filter在Web应用中是独立的组件，ZuulFilter是ZuulServlet处理请求时候调用的，后面会详细分析。&lt;/p&gt;

&lt;p&gt;zuul的项目地址是https://github.com/Netflix/zuul，它是著名的&quot;开源框架提供商&quot;Netflix的作品，项目的目的是：Zuul是一个网关服务，提供动态路由、监视、弹性、安全性等。在SpringCloud中引入了zuul，配合Netflix的另一个负载均衡框架Ribbon和Netflix的另一个提供服务发现与注册框架Eureka，可以实现服务的动态路由。值得注意的是，zuul在2.x甚至3.x的分支中已经引入了netty，框架的复杂性大大提高。但是当前的SpringCloud体系并没有升级zuul的版本，目前使用的是zuul1.x的最高版本1.3.1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-1.png&quot; alt=&quot;z-s-c-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们需要阅读它的源码的时候可以选择这个发布版本。值得注意的是，由于这些版本的发布时间已经比较久，有部分插件或者依赖包可能找不到，笔者在构建zuul1.3.1的源码的时候发现这几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、&lt;code&gt;nebula.netflixoss&lt;/code&gt;插件的旧版本已经不再支持，所有build.gradle文件中的&lt;code&gt;nebula.netflixoss&lt;/code&gt;插件的版本修改为5.2.0。&lt;/li&gt;
&lt;li&gt;2、2017年的时候Gradle支持的版本是2.x，笔者这里选择了gradle-2.14，选择高版本的Gradle有可能在构建项目的时候出现&lt;code&gt;jetty&lt;/code&gt;插件不支持。&lt;/li&gt;
&lt;li&gt;3、Jdk最好使用1.8，Gradle构建文件中的sourceCompatibility、targetCompatibility、languageLevel等配置全改为1.8。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，如果使用IDEA进行构建，注意配置项目的Jdk和Java环境，所有配置改为Jdk1.8，Gradle构建成功后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-2.png&quot; alt=&quot;z-s-c-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zuul-1.3.1中提供了一个Web应用的Sample项目，我们直接运行zuul-simple-webapp的Gradle配置中的Tomcat插件即可启动项目，开始Debug之旅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-3.png&quot; alt=&quot;z-s-c-3&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;zuulfilter的加载&quot;&gt;ZuulFilter的加载&lt;/h2&gt;
&lt;p&gt;从Zuul的源码来看，ZuulFilter的加载模式可能跟我们想象的大有不同，Zuul设计的初衷是ZuulFilter是存放在Groovy文件中，可以实现基于最后修改时间进行热加载。我们先看看Zuul核心类之一com.netflix.zuul.filters.FilterRegistry(Filter的注册中心，实际上是ZuulFilter的全局缓存)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterRegistry {
    
    // 饿汉式单例，确保全局只有一个ZuulFilter的缓存
    private static final FilterRegistry INSTANCE = new FilterRegistry();
    public static final FilterRegistry instance() {
        return INSTANCE;
    }

    //缓存字符串到ZuulFilter实例的映射关系，如果是从文件加载，字符串key的格式是：文件绝对路径 + 文件名，当然也可以自实现
    private final ConcurrentHashMap&amp;lt;String, ZuulFilter&amp;gt; filters = new ConcurrentHashMap&amp;lt;String, ZuulFilter&amp;gt;();

    private FilterRegistry() {
    }

    public ZuulFilter remove(String key) {
        return this.filters.remove(key);
    }

    public ZuulFilter get(String key) {
        return this.filters.get(key);
    }

    public void put(String key, ZuulFilter filter) {
        this.filters.putIfAbsent(key, filter);
    }

    public int size() {
        return this.filters.size();
    }

    public Collection&amp;lt;ZuulFilter&amp;gt; getAllFilters() {
        return this.filters.values();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上Zuul使用了简单粗暴的方式(直接使用ConcurrentHashMap)缓存了ZuulFilter，这些缓存除非主动调用&lt;code&gt;remove&lt;/code&gt;方法，否则不会自动清理。Zuul提供默认的动态代码编译器，接口是DynamicCodeCompiler，目的是把代码编译为Java的类，默认实现是GroovyCompiler，功能就是把Groovy代码编译为Java类。还有一个比较重要的工厂类接口是FilterFactory，它定义了ZuulFilter类生成ZuulFilter实例的逻辑，默认实现是DefaultFilterFactory，实际上就是利用&lt;code&gt;Class#newInstance()&lt;/code&gt;反射生成ZuulFilter实例。接着，我们可以进行分析FilterLoader的源码，这个类的作用就是加载文件中的ZuulFilter实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterLoader {
    //静态final实例，注意到访问权限是包许可，实际上就是饿汉式单例
    final static FilterLoader INSTANCE = new FilterLoader();

    private static final Logger LOG = LoggerFactory.getLogger(FilterLoader.class);

    //缓存Filter名称(主要是从文件加载，名称为绝对路径 + 文件名的形式)-&amp;gt;Filter最后修改时间戳的映射
    private final ConcurrentHashMap&amp;lt;String, Long&amp;gt; filterClassLastModified = new ConcurrentHashMap&amp;lt;String, Long&amp;gt;();
    //缓存Filter名字-&amp;gt;Filter代码的映射，实际上这个Map只使用到get方法进行存在性判断，一直是一个空的结构
    private final ConcurrentHashMap&amp;lt;String, String&amp;gt; filterClassCode = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    //缓存Filter名字-&amp;gt;Filter名字的映射，用于存在性判断
    private final ConcurrentHashMap&amp;lt;String, String&amp;gt; filterCheck = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();
    //缓存Filter类型名称-&amp;gt;List&amp;lt;ZuulFilter&amp;gt;的映射
    private final ConcurrentHashMap&amp;lt;String, List&amp;lt;ZuulFilter&amp;gt;&amp;gt; hashFiltersByType = new ConcurrentHashMap&amp;lt;String, List&amp;lt;ZuulFilter&amp;gt;&amp;gt;();

    //前面提到的ZuulFilter全局缓存的单例
    private FilterRegistry filterRegistry = FilterRegistry.instance();
    //动态代码编译器实例，Zuul提供的默认实现是GroovyCompiler
    static DynamicCodeCompiler COMPILER;
    //ZuulFilter的工厂类
    static FilterFactory FILTER_FACTORY = new DefaultFilterFactory();
    //下面三个方法说明DynamicCodeCompiler、FilterRegistry、FilterFactory可以被覆盖
    public void setCompiler(DynamicCodeCompiler compiler) {
        COMPILER = compiler;
    }

    public void setFilterRegistry(FilterRegistry r) {
        this.filterRegistry = r;
    }

    public void setFilterFactory(FilterFactory factory) {
        FILTER_FACTORY = factory;
    }
    //饿汉式单例获取自身实例
    public static FilterLoader getInstance() {
        return INSTANCE;
    }
    //返回所有缓存的ZuulFilter实例的总数量
    public int filterInstanceMapSize() {
        return filterRegistry.size();
    }
   
    //通过ZuulFilter的类代码和Filter名称获取ZuulFilter实例
    public ZuulFilter getFilter(String sCode, String sName) throws Exception {
        //检查filterCheck是否存在相同名字的Filter，如果存在说明已经加载过
        if (filterCheck.get(sName) == null) {
            //filterCheck中放入Filter名称
            filterCheck.putIfAbsent(sName, sName);
            //filterClassCode中不存在加载过的Filter名称对应的代码
            if (!sCode.equals(filterClassCode.get(sName))) {
                LOG.info(&quot;reloading code &quot; + sName);
                //从全局缓存中移除对应的Filter
                filterRegistry.remove(sName);
            }
        }
        ZuulFilter filter = filterRegistry.get(sName);
        //如果全局缓存中不存在对应的Filter，就使用DynamicCodeCompiler加载代码，使用FilterFactory实例化ZuulFilter
        //注意加载的ZuulFilter类不能是抽象的，必须是继承了ZuulFilter的子类
        if (filter == null) {
            Class clazz = COMPILER.compile(sCode, sName);
            if (!Modifier.isAbstract(clazz.getModifiers())) {
                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);
            }
        }
        return filter;
    }

    //通过文件加加载ZuulFilter
    public boolean putFilter(File file) throws Exception {
        //Filter名称为文件的绝对路径+文件名(这里其实绝对路径已经包含文件名，这里再加文件名的目的不明确)
        String sName = file.getAbsolutePath() + file.getName();
        //如果文件被修改过则从全局缓存从移除对应的Filter以便重新加载
        if (filterClassLastModified.get(sName) != null &amp;amp;&amp;amp; (file.lastModified() != filterClassLastModified.get(sName))) {
            LOG.debug(&quot;reloading filter &quot; + sName);
            filterRegistry.remove(sName);
        }
        //下面的逻辑和上一个方法类似
        ZuulFilter filter = filterRegistry.get(sName);
        if (filter == null) {
            Class clazz = COMPILER.compile(file);
            if (!Modifier.isAbstract(clazz.getModifiers())) {
                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);
                List&amp;lt;ZuulFilter&amp;gt; list = hashFiltersByType.get(filter.filterType());
                //这里说明了一旦文件有修改，hashFiltersByType中对应的当前文件加载出来的Filter类型的缓存要移除，原因见下一个方法
                if (list != null) {
                    hashFiltersByType.remove(filter.filterType()); //rebuild this list
                }
                filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);
                filterClassLastModified.put(sName, file.lastModified());
                return true;
            }
        }
        return false;
    }
    //通过Filter类型获取同类型的所有ZuulFilter
    public List&amp;lt;ZuulFilter&amp;gt; getFiltersByType(String filterType) {
        List&amp;lt;ZuulFilter&amp;gt; list = hashFiltersByType.get(filterType);
        if (list != null) return list;
        list = new ArrayList&amp;lt;ZuulFilter&amp;gt;();
        //如果hashFiltersByType缓存被移除，这里从全局缓存中加载所有的ZuulFilter，按照指定类型构建一个新的列表
        Collection&amp;lt;ZuulFilter&amp;gt; filters = filterRegistry.getAllFilters();
        for (Iterator&amp;lt;ZuulFilter&amp;gt; iterator = filters.iterator(); iterator.hasNext(); ) {
            ZuulFilter filter = iterator.next();
            if (filter.filterType().equals(filterType)) {
                list.add(filter);
            }
        }
        //注意这里会进行排序，是基于filterOrder
        Collections.sort(list); // sort by priority
        //这里总是putIfAbsent，这就是为什么上个方法可以放心地在修改的情况下移除指定Filter类型中的全部缓存实例的原因
        hashFiltersByType.putIfAbsent(filterType, list);
        return list;
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的几个方法和缓存容器都比较简单，这里实际上有加载和存放动作的方法只有&lt;code&gt;putFilter&lt;/code&gt;，这个方法正是Filter文件管理器FilterFileManager依赖的，接着看FilterFileManager的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterFileManager {

    private static final Logger LOG = LoggerFactory.getLogger(FilterFileManager.class);

    String[] aDirectories;
    int pollingIntervalSeconds;
    Thread poller;
    boolean bRunning = true;
    //文件名过滤器，Zuul中的默认实现是GroovyFileFilter，只接受.groovy后缀的文件
    static FilenameFilter FILENAME_FILTER;

    static FilterFileManager INSTANCE;

    private FilterFileManager() {
    }

    public static void setFilenameFilter(FilenameFilter filter) {
        FILENAME_FILTER = filter;
    }
    //init方法是核心静态方法，它具备了配置，预处理和激活后台轮询线程的功能
    public static void init(int pollingIntervalSeconds, String... directories) throws Exception, IllegalAccessException, InstantiationException{
        if (INSTANCE == null) INSTANCE = new FilterFileManager();
        INSTANCE.aDirectories = directories;
        INSTANCE.pollingIntervalSeconds = pollingIntervalSeconds;
        INSTANCE.manageFiles();
        INSTANCE.startPoller();
    }

    public static FilterFileManager getInstance() {
        return INSTANCE;
    }

    public static void shutdown() {
        INSTANCE.stopPoller();
    }

    void stopPoller() {
        bRunning = false;
    }
    //启动后台轮询守护线程，每休眠pollingIntervalSeconds秒则进行一次文件扫描尝试更新Filter
    void startPoller() {
        poller = new Thread(&quot;GroovyFilterFileManagerPoller&quot;) {
            public void run() {
                while (bRunning) {
                    try {
                        sleep(pollingIntervalSeconds * 1000);
                        //预处理文件，实际上是ZuulFilter的预加载
                        manageFiles();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        //设置为守护线程
        poller.setDaemon(true);
        poller.start();
    }
    //根据指定目录路径获取目录，主要需要转换为ClassPath
    public File getDirectory(String sPath) {
        File  directory = new File(sPath);
        if (!directory.isDirectory()) {
            URL resource = FilterFileManager.class.getClassLoader().getResource(sPath);
            try {
                directory = new File(resource.toURI());
            } catch (Exception e) {
                LOG.error(&quot;Error accessing directory in classloader. path=&quot; + sPath, e);
            }
            if (!directory.isDirectory()) {
                throw new RuntimeException(directory.getAbsolutePath() + &quot; is not a valid directory&quot;);
            }
        }
        return directory;
    }
    
    //遍历配置目录，获取所有配置目录下的所有满足FilenameFilter过滤条件的文件
    List&amp;lt;File&amp;gt; getFiles() {
        List&amp;lt;File&amp;gt; list = new ArrayList&amp;lt;File&amp;gt;();
        for (String sDirectory : aDirectories) {
            if (sDirectory != null) {
                File directory = getDirectory(sDirectory);
                File[] aFiles = directory.listFiles(FILENAME_FILTER);
                if (aFiles != null) {
                    list.addAll(Arrays.asList(aFiles));
                }
            }
        }
        return list;
    }
    //遍历指定文件列表，调用FilterLoader单例中的putFilter
    void processGroovyFiles(List&amp;lt;File&amp;gt; aFiles) throws Exception, InstantiationException, IllegalAccessException {
        for (File file : aFiles) {
            FilterLoader.getInstance().putFilter(file);
        }
    }
   //获取指定目录下的所有文件，调用processGroovyFiles，个人认为这两个方法没必要做单独封装
    void manageFiles() throws Exception, IllegalAccessException, InstantiationException {
        List&amp;lt;File&amp;gt; aFiles = getFiles();
        processGroovyFiles(aFiles);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析完FilterFileManager源码之后，Zuul中基于文件加载ZuulFilter的逻辑已经十分清晰：后台启动一个守护线程，定时轮询指定文件夹里面的文件，如果文件存在变更，则尝试更新指定的ZuulFilter缓存，FilterFileManager的&lt;code&gt;init&lt;/code&gt;方法调用的时候在启动后台线程之前会进行一次预加载。&lt;/p&gt;
&lt;h2 id=&quot;requestcontext&quot;&gt;RequestContext&lt;/h2&gt;
&lt;p&gt;在分析ZuulFilter的使用之前，有必要先了解Zuul中的请求上下文对象RequestContext。首先要有一个共识：每一个新的请求都是由一个独立的线程处理(这个线程是Tomcat里面起的线程)，换言之，请求的所有参数(Http报文信息解析出来的内容，如请求头、请求体等等)总是绑定在处理请求的线程中。RequestContext的设计就是简单直接有效，它继承于&lt;code&gt;ConcurrentHashMap&amp;lt;String, Object&amp;gt;&lt;/code&gt;，所以参数可以直接设置在RequestContext中，zuul没有设计一个类似于枚举的类控制RequestContext的可选参数，因此里面的设置值和提取值的方法都是硬编码的，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public HttpServletRequest getRequest() {
        return (HttpServletRequest) get(&quot;request&quot;);
    }

    public void setRequest(HttpServletRequest request) {
        put(&quot;request&quot;, request);
    }

    public HttpServletResponse getResponse() {
        return (HttpServletResponse) get(&quot;response&quot;);
    }

    public void setResponse(HttpServletResponse response) {
        set(&quot;response&quot;, response);
    }
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来很暴力并且不怎么优雅，但是实际上是高效的。RequestContext一般使用静态方法&lt;code&gt;RequestContext#getCurrentContext()&lt;/code&gt;进行初始化，我们分析一下它的初始化流程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //保存RequestContext自身类型
    protected static Class&amp;lt;? extends RequestContext&amp;gt; contextClass = RequestContext.class;
    //静态对象
    private static RequestContext testContext = null;
    //静态final修饰的ThreadLocal实例，用于存放所有的RequestContext，每个RequestContext都会绑定在自身请求的处理线程中
    //注意这里的ThreadLocal实例的initialValue()方法，当ThreadLocal的get()方法返回null的时候总是会调用initialValue()方法
    protected static final ThreadLocal&amp;lt;? extends RequestContext&amp;gt; threadLocal = new ThreadLocal&amp;lt;RequestContext&amp;gt;() {
        @Override
        protected RequestContext initialValue() {
            try {
                return contextClass.newInstance();
            } catch (Throwable e) {
                throw new RuntimeException(e);
            }
        }
    };


    public RequestContext() {
        super();
    }
    
    public static RequestContext getCurrentContext() {
        //这里混杂了测试的代码，暂时忽略
        if (testContext != null) return testContext;
        //当ThreadLocal的get()方法返回null的时候总是会调用initialValue()方法，所以这里是&quot;无则新建RequestContext&quot;的逻辑
        RequestContext context = threadLocal.get();
        return context;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的ThreadLocal覆盖了初始化方法&lt;code&gt;initialValue()&lt;/code&gt;，ThreadLocal的初始化方法总是在&lt;code&gt;ThreadLocal#get()&lt;/code&gt;方法返回null的时候调用，实际上静态方法&lt;code&gt;RequestContext#getCurrentContext()&lt;/code&gt;的作用就是：如果ThreadLocal中已经绑定了RequestContext静态实例就直接获取绑定在线程中的RequestContext实例，否则新建一个RequestContext实例存放在ThreadLocal(绑定到当前的请求线程中)。了解这一点后面分析ZuulServletFilter和ZuulServlet的时候就很简单了。&lt;/p&gt;
&lt;h2 id=&quot;zuulfilter&quot;&gt;ZuulFilter&lt;/h2&gt;
&lt;p&gt;抽象类com.netflix.zuul.ZuulFilter是Zuul里面的核心组件，它是用户扩展Zuul行为的组件，用户可以实现不同类型的ZuulFilter、定义它们的执行顺序、实现它们的执行方法达到定制化的目的，SpringCloud的&lt;code&gt;netflix-zuul&lt;/code&gt;就是一个很好的实现包。ZuulFilter实现了IZuulFilter接口，我们先看这个接口的定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IZuulFilter {
   
   boolean shouldFilter();

   Object run() throws ZuulException;
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，&lt;code&gt;shouldFilter()&lt;/code&gt;方法决定是否需要执行(也就是执行时机由使用者扩展，甚至可以禁用)，而&lt;code&gt;run()&lt;/code&gt;方法决定执行的逻辑。接着看ZuulFilter的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class ZuulFilter implements IZuulFilter, Comparable&amp;lt;ZuulFilter&amp;gt; {
    //netflix的配置组件，实际上就是基于配置文件提取的指定key的值
    private final AtomicReference&amp;lt;DynamicBooleanProperty&amp;gt; filterDisabledRef = new AtomicReference&amp;lt;&amp;gt;();
    
    //定义Filter的类型
    abstract public String filterType();

    //定义当前Filter实例执行的顺序
    abstract public int filterOrder();
   
    //是否静态的Filter，静态的Filter是无状态的
    public boolean isStaticFilter() {
        return true;
    }

    //禁用当前Filter的配置属性的Key名称
    //Key=zuul.${全类名}.${filterType}.disable
    public String disablePropertyName() {
        return &quot;zuul.&quot; + this.getClass().getSimpleName() + &quot;.&quot; + filterType() + &quot;.disable&quot;;
    }

    //判断当前的Filter是否禁用，通过disablePropertyName方法从配置中读取，默认是不禁用，也就是启用
    public boolean isFilterDisabled() {
        filterDisabledRef.compareAndSet(null, DynamicPropertyFactory.getInstance().getBooleanProperty(disablePropertyName(), false));
        return filterDisabledRef.get().get();
    }

    //这个是核心方法，执行Filter，如果Filter不是禁用、并且满足执行时机则调用run方法，返回执行结果，记录执行轨迹
    public ZuulFilterResult runFilter() {
        ZuulFilterResult zr = new ZuulFilterResult();
        if (!isFilterDisabled()) {
            if (shouldFilter()) {
                Tracer t = TracerFactory.instance().startMicroTracer(&quot;ZUUL::&quot; + this.getClass().getSimpleName());
                try {
                    Object res = run();
                    zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS);
                } catch (Throwable e) {
                    t.setName(&quot;ZUUL::&quot; + this.getClass().getSimpleName() + &quot; failed&quot;);
                    zr = new ZuulFilterResult(ExecutionStatus.FAILED);
                    //注意这里只保存异常的实例，即使执行抛出异常
                    zr.setException(e);
                } finally {
                    t.stopAndLog();
                }
            } else {
                zr = new ZuulFilterResult(ExecutionStatus.SKIPPED);
            }
        }
        return zr;
    }
    
    //实现Comparable，基于filterOrder升序排序，也就是filterOrder越大，执行优先度越低
    public int compareTo(ZuulFilter filter) {
        return Integer.compare(this.filterOrder(), filter.filterOrder());
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意几个地方，第一个是&lt;code&gt;filterOrder()&lt;/code&gt;方法和&lt;code&gt;compareTo(ZuulFilter filter)&lt;/code&gt;方法，子类实现ZuulFilter时候，&lt;code&gt;filterOrder()&lt;/code&gt;方法返回值越大，或者说Filter的顺序系数越大，ZuulFilter执行的优先度越低。第二个地方是可以通过zuul.${全类名}.${filterType}.disable=false通过类名和Filter类型禁用对应的Filter。第三个值得注意的地方是Zuul中定义了四种类型的ZuulFilter，后面分析ZuulRunner的时候再详细展开。ZuulFilter实际上就是使用者扩展的核心组件，通过实现ZuulFilter的方法可以在一个请求处理链中的特定位置执行特定的定制化逻辑。第四个值得注意的地方是&lt;code&gt;runFilter()&lt;/code&gt;方法执行不会抛出异常，如果出现异常，Throwable实例会保存在ZuulFilterResult对象中返回到外层方法，如果正常执行，则直接返回&lt;code&gt;runFilter()&lt;/code&gt;方法的结果。&lt;/p&gt;
&lt;h2 id=&quot;filterprocessor&quot;&gt;FilterProcessor&lt;/h2&gt;
&lt;p&gt;前面花大量功夫分析完ZuulFilter基于Groovy文件的加载机制(在SpringCloud体系中并没有使用此策略，因此，我们持了解的态度即可)以及RequestContext的设计，接着我们分析FilterProcessor去了解如何使用加载好的缓存中的ZuulFilter。我们先看FilterProcessor的基本属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FilterProcessor {

    static FilterProcessor INSTANCE = new FilterProcessor();
    protected static final Logger logger = LoggerFactory.getLogger(FilterProcessor.class);

    private FilterUsageNotifier usageNotifier;


    public FilterProcessor() {
        usageNotifier = new BasicFilterUsageNotifier();
    }

    public static FilterProcessor getInstance() {
        return INSTANCE;
    }

    public static void setProcessor(FilterProcessor processor) {
        INSTANCE = processor;
    }

    public void setFilterUsageNotifier(FilterUsageNotifier notifier) {
        this.usageNotifier = notifier;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像之前分析的几个类一样，FilterProcessor设计为单例，提供可以覆盖单例实例的方法。需要注意的一点是属性usageNotifier是FilterUsageNotifier类型，FilterUsageNotifier接口的默认实现是BasicFilterUsageNotifier(FilterProcessor的一个静态内部类)，BasicFilterUsageNotifier依赖于Netflix的一个工具包&lt;code&gt;servo-core&lt;/code&gt;，提供基于内存态的计数器统计每种ZuulFilter的每一次调用的状态ExecutionStatus。枚举ExecutionStatus的可选值如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、SUCCESS，代表该Filter处理成功，值为1。&lt;/li&gt;
&lt;li&gt;2、SKIPPED，代表该Filter跳过处理，值为-1。&lt;/li&gt;
&lt;li&gt;3、DISABLED，代表该Filter禁用，值为-2。&lt;/li&gt;
&lt;li&gt;4、SUCCESS，代表该FAILED处理出现异常，值为-3。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，使用者也可以覆盖usageNotifier属性。接着我们看FilterProcessor中真正调用ZuulFilter实例的核心方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //指定Filter类型执行该类型下的所有ZuulFilter
    public Object runFilters(String sType) throws Throwable {
        //尝试打印Debug日志
        if (RequestContext.getCurrentContext().debugRouting()) {
            Debug.addRoutingDebug(&quot;Invoking {&quot; + sType + &quot;} type filters&quot;);
        }
        boolean bResult = false;
        //获取所有指定类型的ZuulFilter
        List&amp;lt;ZuulFilter&amp;gt; list = FilterLoader.getInstance().getFiltersByType(sType);
        if (list != null) {
            for (int i = 0; i &amp;lt; list.size(); i++) {
                ZuulFilter zuulFilter = list.get(i);
                Object result = processZuulFilter(zuulFilter);
                //如果处理结果是Boolean类型尝试做或操作，其他类型结果忽略
                if (result != null &amp;amp;&amp;amp; result instanceof Boolean) {
                    bResult |= ((Boolean) result);
                }
            }
        }
        return bResult;
    }
    //执行ZuulFilter，这个就是ZuulFilter执行逻辑
    public Object processZuulFilter(ZuulFilter filter) throws ZuulException {
        RequestContext ctx = RequestContext.getCurrentContext();
        boolean bDebug = ctx.debugRouting();
        final String metricPrefix = &quot;zuul.filter-&quot;;
        long execTime = 0;
        String filterName = &quot;&quot;;
        try {
            long ltime = System.currentTimeMillis();
            filterName = filter.getClass().getSimpleName();
            RequestContext copy = null;
            Object o = null;
            Throwable t = null;
            if (bDebug) {
                Debug.addRoutingDebug(&quot;Filter &quot; + filter.filterType() + &quot; &quot; + filter.filterOrder() + &quot; &quot; + filterName);
                copy = ctx.copy();
            }
            //简单调用ZuulFilter的runFilter方法
            ZuulFilterResult result = filter.runFilter();
            ExecutionStatus s = result.getStatus();
            execTime = System.currentTimeMillis() - ltime;
            switch (s) {
                case FAILED:
                    t = result.getException();
                    //记录调用链中当前Filter的名称，执行结果状态和执行时间
                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
                    break;
                case SUCCESS:
                    o = result.getResult();
                    //记录调用链中当前Filter的名称，执行结果状态和执行时间
                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);
                    if (bDebug) {
                        Debug.addRoutingDebug(&quot;Filter {&quot; + filterName + &quot; TYPE:&quot; + filter.filterType() + &quot; ORDER:&quot; + filter.filterOrder() + &quot;} Execution time = &quot; + execTime + &quot;ms&quot;);
                        Debug.compareContextState(filterName, copy);
                    }
                    break;
                default:
                    break;
            }
            
            if (t != null) throw t;
            //这里做计数器的统计
            usageNotifier.notify(filter, s);
            return o;

        } catch (Throwable e) {
            if (bDebug) {
                Debug.addRoutingDebug(&quot;Running Filter failed &quot; + filterName + &quot; type:&quot; + filter.filterType() + &quot; order:&quot; + filter.filterOrder() + &quot; &quot; + e.getMessage());
            }
             //这里做计数器的统计
            usageNotifier.notify(filter, ExecutionStatus.FAILED);
            if (e instanceof ZuulException) {
                throw (ZuulException) e;
            } else {
                ZuulException ex = new ZuulException(e, &quot;Filter threw Exception&quot;, 500, filter.filterType() + &quot;:&quot; + filterName);
                //记录调用链中当前Filter的名称，执行结果状态和执行时间
                ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);
                throw ex;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面介绍了FilterProcessor中的&lt;code&gt;processZuulFilter(ZuulFilter filter)&lt;/code&gt;方法主要提供ZuulFilter执行的一些度量相关记录(例如Filter执行耗时摘要，会形成一个链，记录在一个字符串中)和ZuulFilter的执行方法，ZuulFilter执行结果可能是成功或者异常，前面提到过，如果抛出异常Throwable实例会保存在ZuulFilterResult中，在&lt;code&gt;processZuulFilter(ZuulFilter filter)&lt;/code&gt;发现ZuulFilterResult中的Throwable实例不为null则直接抛出，否则返回ZuulFilter正常执行的结果。另外，FilterProcessor中通过指定Filter类型执行所有对应类型的ZuulFilter的&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法，我们知道了&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法如果处理结果是Boolean类型尝试做或操作，其他类型结果忽略，可以理解为此方法的返回值是没有很大意义的。参考SpringCloud里面对ZuulFilter的返回值处理一般是直接塞进去当前线程绑定的RequestContext中，选择特定的ZuulFilter子类对前面的ZuulFilter产生的结果进行处理。FilterProcessor基于&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法提供了其他指定filterType的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void postRoute() throws ZuulException {
        try {
            runFilters(&quot;post&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_POST_FILTER_&quot; + e.getClass().getName());
        }
    }

    public void preRoute() throws ZuulException {
        try {
            runFilters(&quot;pre&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());
        }
    }

    public void error() {
        try {
            runFilters(&quot;error&quot;);
        } catch (Throwable e) {
            logger.error(e.getMessage(), e);
        }
    }

    public void route() throws ZuulException {
        try {
            runFilters(&quot;route&quot;);
        } catch (ZuulException e) {
            throw e;
        } catch (Throwable e) {
            throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_ROUTE_FILTER_&quot; + e.getClass().getName());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面提供的方法很简单，无法是指定参数为&lt;strong&gt;post、pre、error、route&lt;/strong&gt;对&lt;code&gt;runFilters(String sType)&lt;/code&gt;方法进行调用，至于这些FilterType的执行位置见下一个小节的分析。&lt;/p&gt;
&lt;h2 id=&quot;zuulservletfilter和zuulservlet&quot;&gt;ZuulServletFilter和ZuulServlet&lt;/h2&gt;
&lt;p&gt;Zuul本来就是设计为Servlet规范组件的一个类库，ZuulServlet就是javax.servlet.http.HttpServlet的实现类，而ZuulServletFilter是javax.servlet.Filter的实现类。这两个类都依赖到ZuulRunner完成ZuulFilter的调用，它们的实现逻辑是完全一致的，我们只需要看其中一个类的实现，这里挑选ZuulServlet：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulServlet extends HttpServlet {

    private static final long serialVersionUID = -3374242278843351500L;
    private ZuulRunner zuulRunner;

    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        String bufferReqsStr = config.getInitParameter(&quot;buffer-requests&quot;);
        boolean bufferReqs = bufferReqsStr != null &amp;amp;&amp;amp; bufferReqsStr.equals(&quot;true&quot;) ? true : false;
        zuulRunner = new ZuulRunner(bufferReqs);
    }

    @Override
    public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {
        try {
            //实际上委托到ZuulRunner的init方法
            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);
            //初始化RequestContext实例
            RequestContext context = RequestContext.getCurrentContext();
            //设置RequestContext中zuulEngineRan=true
            context.setZuulEngineRan();
            try {
                preRoute();
            } catch (ZuulException e) {
                error(e);
                postRoute();
                return;
            }
            try {
                route();
            } catch (ZuulException e) {
                error(e);
                postRoute();
                return;
            }
            try {
                postRoute();
            } catch (ZuulException e) {
                error(e);
                return;
            }

        } catch (Throwable e) {
            error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));
        } finally {
            RequestContext.getCurrentContext().unset();
        }
    }

    void postRoute() throws ZuulException {
        zuulRunner.postRoute();
    }

    void route() throws ZuulException {
        zuulRunner.route();
    }

    void preRoute() throws ZuulException {
        zuulRunner.preRoute();
    }

    void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        zuulRunner.init(servletRequest, servletResponse);
    }
    //这里会先设置RequestContext实例中的throwable属性为执行抛出的Throwable实例
    void error(ZuulException e) {
        RequestContext.getCurrentContext().setThrowable(e);
        zuulRunner.error();
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ZuulServletFilter和ZuulServlet不相同的地方仅仅是初始化和处理方法的方法签名(参数列表和方法名)，其他逻辑甚至是代码是一模一样，使用过程中我们需要了解javax.servlet.http.HttpServlet和javax.servlet.Filter的作用去选择到底使用ZuulServletFilter还是ZuulServlet。上面的代码可以看到，ZuulServlet初始化的时候可以配置初始化布尔值参数buffer-requests，这个参数默认为false，它是ZuulRunner实例化的必须参数。ZuulServlet中的调用ZuulFilter的方法都委托到ZuulRunner实例去完成，但是我们可以从&lt;code&gt;service(servletRequest, servletResponse)&lt;/code&gt;方法看出四种FilterType(pre、route、post、error)的ZuulFilter的执行顺序，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、pre、route、post都不抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;post，error不执行。&lt;/li&gt;
&lt;li&gt;2、pre抛出异常，顺序是：pre-&amp;gt;error-&amp;gt;post。&lt;/li&gt;
&lt;li&gt;3、route抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;error-&amp;gt;post。&lt;/li&gt;
&lt;li&gt;4、post抛出异常，顺序是：pre-&amp;gt;route-&amp;gt;post-&amp;gt;error。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，一旦出现了异常，会把抛出的Throwable实例设置到绑定到当前请求线程的RequestContext实例中的throwable属性。还需要注意在&lt;code&gt;service(servletRequest, servletResponse)&lt;/code&gt;的finally块中调用了&lt;code&gt;RequestContext.getCurrentContext().unset();&lt;/code&gt;，实际上是从RequestContext的ThreadLocal实例中移除当前的RequestContext实例，这样做可以避免ThreadLocal使用不当导致内存泄漏。&lt;/p&gt;
&lt;p&gt;接着看ZuulRunner的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulRunner {

    private boolean bufferRequests;

    public ZuulRunner() {
        this.bufferRequests = true;
    } 

    public ZuulRunner(boolean bufferRequests) {
        this.bufferRequests = bufferRequests;
    } 

    public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {
        RequestContext ctx = RequestContext.getCurrentContext();
        if (bufferRequests) {
            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));
        } else {
            ctx.setRequest(servletRequest);
        }
        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));
    }

    public void postRoute() throws ZuulException {
        FilterProcessor.getInstance().postRoute();
    }

    public void route() throws ZuulException {
        FilterProcessor.getInstance().route();
    }

    public void preRoute() throws ZuulException {
        FilterProcessor.getInstance().preRoute();
    }  

    public void error() {
        FilterProcessor.getInstance().error();
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;postRoute()&lt;/code&gt;、&lt;code&gt;route()&lt;/code&gt;、&lt;code&gt;preRoute()&lt;/code&gt;、&lt;code&gt;error()&lt;/code&gt;都是直接委托到FilterProcessor中完成的，实际上就是执行对应类型的所有ZuulFilter实例。这里需要注意的是，初始化ZuulRunner时候，HttpServletResponse会被包装为com.netflix.zuul.http.HttpServletResponseWrapper实例，它是Zuul实现的javax.servlet.http.HttpServletResponseWrapper的子类，主要是添加了一个属性status用来记录Http状态码。如果初始化参数bufferRequests为true，HttpServletRequest会被包装为com.netflix.zuul.http.HttpServletRequestWrapper，它是Zuul实现的javax.servlet.http.HttpServletRequestWrapper的子类，这个包装类主要是把请求的表单参数和请求体都缓存在实例属性中，这样在一些特定场景中可以提高性能。如果没有特殊需要，这个参数bufferRequests一般设置为false。&lt;/p&gt;

&lt;p&gt;我们做一个很简单的例子，场景是：对于每个POST请求，使用pre类型的ZuulFilter打印它的请求体，然后使用post类型的ZuulFilter，响应结果硬编码为字符串&quot;Hello World!&quot;。我们先为CounterFactory、TracerFactory添加两个空的子类，因为Zuul处理逻辑中依赖到这两个组件实现数据度量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultTracerFactory extends TracerFactory {

    @Override
    public Tracer startMicroTracer(String name) {
        return null;
    }
}

public class DefaultCounterFactory extends CounterFactory {

    @Override
    public void increment(String name) {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们分别继承ZuulFilter，实现一个pre类型的用于打印请求参数的Filter，命名为&lt;code&gt;PrintParameterZuulFilter&lt;/code&gt;，实现一个post类型的用于返回字符串&quot;Hello World!&quot;的Filter，命名为&lt;code&gt;SendResponseZuulFilter&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PrintParameterZuulFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return &quot;pre&quot;;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        return &quot;POST&quot;.equalsIgnoreCase(request.getMethod());
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        if (null != request.getContentType()) {
            if (request.getContentType().contains(&quot;application/json&quot;)) {
                try {
                    ServletInputStream inputStream = request.getInputStream();
                    String result = StreamUtils.copyToString(inputStream, Charset.forName(&quot;UTF-8&quot;));
                    System.out.println(String.format(&quot;请求URI为:%s,请求参数为:%s&quot;, request.getRequestURI(), result));
                } catch (IOException e) {
                    throw new ZuulException(e, 500, &quot;从输入流中读取请求参数异常&quot;);
                }
            } else if (request.getContentType().contains(&quot;application/x-www-form-urlencoded&quot;)) {
                StringBuilder params = new StringBuilder();
                Enumeration&amp;lt;String&amp;gt; parameterNames = request.getParameterNames();
                while (parameterNames.hasMoreElements()) {
                    String name = parameterNames.nextElement();
                    params.append(name).append(&quot;=&quot;).append(request.getParameter(name)).append(&quot;&amp;amp;&quot;);
                }
                String result = params.toString();
                System.out.println(String.format(&quot;请求URI为:%s,请求参数为:%s&quot;, request.getRequestURI(),
                        result.substring(0, result.lastIndexOf(&quot;&amp;amp;&quot;))));
            }
        }
        return null;
    }
}

public class SendResponseZuulFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return &quot;post&quot;;
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        return &quot;POST&quot;.equalsIgnoreCase(request.getMethod());
    }

    @Override
    public Object run() throws ZuulException {
        RequestContext context = RequestContext.getCurrentContext();
        String output = &quot;Hello World!&quot;;
        try {
            context.getResponse().getWriter().write(output);
        } catch (IOException e) {
            throw new ZuulException(e, 500, e.getMessage());
        }
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们引入嵌入式Tomcat，简单地创建一个Servlet容器，Maven依赖为：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-embed-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jasper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jasper-el&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.tomcat&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tomcat-jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.5.34&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加带main方法的类把上面的组件和Tomcat的组件组装起来：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ZuulMain {

    private static final String WEBAPP_DIRECTORY = &quot;src/main/webapp/&quot;;
    private static final String ROOT_CONTEXT = &quot;&quot;;

    public static void main(String[] args) throws Exception {
        Tomcat tomcat = new Tomcat();
        File tempDir = File.createTempFile(&quot;tomcat&quot; + &quot;.&quot;, &quot;.8080&quot;);
        tempDir.delete();
        tempDir.mkdir();
        tempDir.deleteOnExit();
        //创建临时目录,这一步必须先设置,如果不设置默认在当前的路径创建一个'tomcat.8080文件夹'
        tomcat.setBaseDir(tempDir.getAbsolutePath());
        tomcat.setPort(8080);
        StandardContext ctx = (StandardContext) tomcat.addWebapp(ROOT_CONTEXT,
                new File(WEBAPP_DIRECTORY).getAbsolutePath());
        WebResourceRoot resources = new StandardRoot(ctx);
        resources.addPreResources(new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;,
                new File(&quot;target/classes&quot;).getAbsolutePath(), &quot;/&quot;));
        ctx.setResources(resources);
        ctx.setDefaultWebXml(new File(&quot;src/main/webapp/WEB-INF/web.xml&quot;).getAbsolutePath());
        // FixBug: no global web.xml found
        for (LifecycleListener ll : ctx.findLifecycleListeners()) {
            if (ll instanceof ContextConfig) {
                ((ContextConfig) ll).setDefaultWebXml(ctx.getDefaultWebXml());
            }
        }
        //这里添加两个度量父类的空实现
        CounterFactory.initialize(new DefaultCounterFactory());
        TracerFactory.initialize(new DefaultTracerFactory());
        //这里添加自实现的ZuulFilter
        FilterRegistry.instance().put(&quot;printParameterZuulFilter&quot;, new PrintParameterZuulFilter());
        FilterRegistry.instance().put(&quot;sendResponseZuulFilter&quot;, new SendResponseZuulFilter());
        //这里添加ZuulServlet
        Context context = tomcat.addContext(&quot;/zuul&quot;, null);
        Tomcat.addServlet(context, &quot;zuul&quot;, new ZuulServlet());
        //设置Servlet的路径
        context.addServletMappingDecoded(&quot;/*&quot;, &quot;zuul&quot;);
        tomcat.start();
        tomcat.getServer().await();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行main方法，Tomcat正常启动后打印出熟悉的日志如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-4.png&quot; alt=&quot;z-s-c-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，用POSTMAN请求模拟一下请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/z-s-c-5.png&quot; alt=&quot;z-s-c-5&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Zuul虽然在它的Github仓库中的简介中说它是一个提供动态路由、监视、弹性、安全性等的网关框架，但是实际上它原生并没有提供这些功能，这些功能是需要使用者扩展ZuulFilter实现的，例如基于负载均衡的动态路由需要配置Netflix自己家的Ribbon实现。Zuul在设计上的扩展性什么良好，ZuulFilter就像插件一个可以通过类型、排序系数构建一个调用链，通过Filter或者Servlet做入口，嵌入到Servlet(Web)应用中。不过，在Zuul后续的版本如2.x和3.x中，引入了Netty，基于TCP做底层的扩展，但是编码和使用的复杂度大大提高。也许这就是SpringCloud在&lt;code&gt;netflix-zuul&lt;/code&gt;组件中选用了zuul1.x的最后一个发布版本1.3.1的原因吧。&lt;code&gt;springcloud-netflix&lt;/code&gt;中使用到Netflix的zuul(动态路由)、robbin(负载均衡)、eureka(服务注册与发现)、hystrix(熔断)等核心组件，这里立个flag先逐个组件分析其源码，逐个击破后再对&lt;code&gt;springcloud-netflix&lt;/code&gt;做一次完整的源码分析。&lt;/p&gt;
&lt;p&gt;(本文完 c-5-d)&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 最近在项目中使用了SpringCloud，基于zuul搭建了一个提供加解密、鉴权等功能的网关服务。鉴于之前没怎么使用过Zuul，于是顺便仔细阅读了它的源码。实际上，zuul原来提供的功能是很单一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9653067.html</dc:identifier>
</item>
<item>
<title>软能力那点事，你知多少 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9653019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9653019.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在我们日常工作中，常常会听到软能力这一个词汇，尤其是在称赞某个人工作表现不错的时候更是如此。&lt;br/&gt;然而关于软能力是什么，一百个人有一百种解释，就好像一千个人有一千个哈姆雷特。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一软能力是什么&quot;&gt;一、软能力是什么&lt;/h2&gt;
&lt;p&gt;什么是软能力？回答这个问题之前，我们先要了解什么是硬能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;还记得曾经如火如荼的高考吗，大家都是卯足了劲儿，挑灯夜读，为的就是上一所心仪的大学。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应试教育的背景下，考试能力、学习成绩这些就是你的硬能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231012702-978846904.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;金庸小说里，第一次华山论剑，南帝北丐展一阳指、降龙十八掌之绝技，东邪西毒现弹指神通、蛤蟆功之怪诞武艺，最终由中神通王重阳战胜群雄，获得天下第一。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在武侠小说里，武功的高低是你的硬能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915233704221-350196291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬能力&lt;/strong&gt;往往最容易被记住，而且人们也更乐于就某个人物(或事物)的硬能力进行谈论&lt;/p&gt;
&lt;p&gt;为什么？因为相对于软能力来说，硬能力更加简单，更容易被描述。&lt;/p&gt;
&lt;p&gt;那么，软能力究竟应该对应什么？&lt;/p&gt;
&lt;p&gt;在高考评估体系里面，占比重最大的无非是笔试成绩，而一些实用型能力比如沟通能力、组织协调能力却没能被考虑进去(这是国内应试教育一直被诟病的地方)，&lt;br/&gt;它们是组成软能力的重要部分。&lt;/p&gt;
&lt;p&gt;再看看华山论剑的案例，武功再高，如果品行败坏，坏事做尽，是很难获得后人世颂的。&lt;br/&gt;这时，武德便是一种软能力。另外，如果武艺高强却没有人知道，就是隐姓埋名；说不中听的，那就是废柴一个。&lt;/p&gt;
&lt;p&gt;这时候，名号的传播就很重要了，我们知道，大约宋代开始，有一种说书人，其常年以演说卖艺为生。&lt;br/&gt;在现如今，这便是隐形的营销。&lt;/p&gt;
&lt;p&gt;有人说，在当今的世界上，硬能力就是智商，软能力则是情商；&lt;br/&gt;也有人说，在企业里面，硬能力是满足岗位需求的必要技能，软能力是你与团队进行交互协作的能力。&lt;/p&gt;
&lt;p&gt;我觉得，说的都对！&lt;br/&gt;软能力是能够让你变得优秀的关键能力。&lt;/p&gt;
&lt;h2 id=&quot;二软能力-程序猿生存指南&quot;&gt;二、软能力-程序猿生存指南&lt;/h2&gt;
&lt;p&gt;让我们回到 软件开发 这个行当，当你即将成为一名程序猿，或者你已经作为程序猿好多年了之后，你是否清楚：&lt;/p&gt;
&lt;p&gt;作为一名程序猿，应该至少具备什么样的软能力，才能使你从猿猿众生中脱颖而出。&lt;/p&gt;
&lt;p&gt;在《软技能-代码之外的生存指南》一书中，作者约翰 Z. 森梅兹为以自己的经历为例，为我们仔细讲述了程序员除了写代码之外应该具备的各种软能力，&lt;br/&gt;值得一提的是，该作者还是一名出色的健身爱好者及投资客，这可能是令许多人望尘莫及的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231219056-1224600597.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;作为一个软件开发人员，在我的生活中，我经历过许多不同的旅程。
我曾走在阳关大道，也曾误入歧途，还有一些路我至今仍不知是对还是错。
这一路走来，我并没有得到太多的帮助和指导。
我从来没觉得有谁为我披荆斩棘，开辟出一条小路使我可以因循，
也从来没觉得有谁可以告诉我如何成为一名最成功的软件开发人员——
不能只编写代码，还要有精彩的人生。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在阅读完此书后，我将所能记住的软能力归纳如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231237577-1395009808.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，有点多.. 有了这些技能，相信大部分程序猿就能迎娶白富美，走上人生巅峰了吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231244747-111595792.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了简化理解，我们可以将关注点聚焦到下面几个维度上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231249686-2024403579.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来解读一下&lt;/p&gt;
&lt;h3 id=&quot;a.-沟通能力&quot;&gt;A. 沟通能力&lt;/h3&gt;
&lt;p&gt;关于沟通方面的能力是老生常谈了，沟通表达能力强的程序猿总是不一样，&lt;br/&gt;在很多场景下都会占优：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小组选拔带头人&lt;/li&gt;
&lt;li&gt;出差到客户现场露露脸&lt;/li&gt;
&lt;li&gt;介绍对象&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231413234-1954219634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;沟通好的人有一点很关键的是换位思考能力，就是能为沟通的对象着想，让你感觉很舒服。&lt;br/&gt;下面有个案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231420982-1307324241.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;b.-学习能力&quot;&gt;B. 学习能力&lt;/h3&gt;
&lt;p&gt;学习要有方法，才能取得更高的效率及更好的效果。&lt;br/&gt;在《软技能-代码之外的生存指南》一书中提到的 &quot;十步学习法&quot; 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一步：了解全局
第二步：确定范围
第三步：定义目标
第四步：寻找资源
第五步：创建学习计划
第六步：筛选资源
第七步：开始学习，浅尝辄止
第八步：动手操作，边玩边学
第九步：全面学习，学以致用
第十步：乐为人师，融会贯通&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;十步学习法看似有些繁琐，其实却很有逻辑性，是一个循序渐进的过程。&lt;br/&gt;经过归纳后，我们当然可以做一些简化。&lt;/p&gt;
&lt;p&gt;这里以学习&lt;strong&gt;spring cloud&lt;/strong&gt;为例，整个过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231430632-1894489125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，关于学习过程，你可以自己归纳，但不应该是没有章法的。&lt;/p&gt;
&lt;h3 id=&quot;c.-时间管理&quot;&gt;C. 时间管理&lt;/h3&gt;
&lt;p&gt;时间管理，在职场上更多的是工作管理，即&lt;strong&gt;如何有条不紊的将工作逐个完成&lt;/strong&gt;，&lt;br/&gt;既要满足上级，也要让自己不纠结后悔。&lt;/p&gt;
&lt;p&gt;许多关于时间管理的书籍都会提到&lt;strong&gt;番茄工作法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;按照 番茄钟 的方式对工作任务进行拆解排序；
每个番茄钟对应一段25分钟的工作时间；
在每个番茄钟内部不允许有新任务插入，此时只需要将任务放到待办事项；
每个番茄钟结束后，进行5分钟的休息调整，之后进行下一个番茄钟&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在进行事务排序时，推荐使用&lt;strong&gt;四象限法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231532355-656012788.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;番茄工作法是不错的，但并不完美，许多人尽管知道但却很做到极致。&lt;br/&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很难将任务优先级进行排序，万一错了呢？&lt;/li&gt;
&lt;li&gt;很难将任务对应到25分钟内，我其实需要1个小时..&lt;/li&gt;
&lt;li&gt;很难拒绝新来的任务啊，面对主管的催促，运营MM的询问，实在纠结&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231557337-430677823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这些问题，你只能先承受着..，然后不断去尝试优化&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;李笑来在《和时间做朋友》专栏中提出一个观点：&lt;strong&gt;时间是不可管理的！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这说的倒是没错，我们其实都是时间的奴隶(尽管有些消极)。&lt;br/&gt;所以，需要知道失控是一种常态，以一种平稳的心态去看待。&lt;br/&gt;在过程中去找到你真实的现状和能力，持续探索属于自己的控制方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;d.-分解能力&quot;&gt;D. 分解能力&lt;/h3&gt;
&lt;p&gt;分解能力几乎是各个领域里最通用的能力了。&lt;br/&gt;这个世界是结构化的，大到一个庞大的帝国，小到一只蝼蚁，都是由结构组成的。&lt;br/&gt;就连本文都有一个相对不那么模糊的提纲结构。&lt;/p&gt;
&lt;p&gt;在软件世界里也一直推崇&lt;strong&gt;分而治之&lt;/strong&gt;的思想。&lt;br/&gt;技术人只有具备了良好的结构思考力，在应付一个庞大的项目时才能显得得心应手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231811455-968438845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于这种&lt;strong&gt;先总后分&lt;/strong&gt; 的结构化思维方式，也是一直传承以久的。&lt;/p&gt;
&lt;p&gt;这里推荐一本书籍，叫《结构化思考力》，作者李忠秋是专注于该领域的专家。&lt;br/&gt;将这部书多读两遍，相信会有所收获。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915233825543-757135495.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;e.-总结改进&quot;&gt;E. 总结改进&lt;/h3&gt;
&lt;p&gt;总结归纳是一种能力，但更应该成为一种习惯。&lt;br/&gt;总结的目的是为了改进，刷新自我。&lt;/p&gt;
&lt;p&gt;在《高效人士的七个习惯》中，第七条就是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“不断更新 平衡的自我更新原则”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有不少企业将总结改进作为团队管理的核心要领之一，在敏捷化项目管理中，迭代回顾也是重要形式之一。&lt;br/&gt;但是呢，对于大部分程序猿个人来说，做总结改进可能有些痛苦。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;“有那么多时间做总结，还不如多敲点代码！”&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，如果代表了你的心声，那么很遗憾，这只是你给自己找的&lt;strong&gt;关于不愿意进步&lt;/strong&gt;的一个借口。&lt;/p&gt;
&lt;h2 id=&quot;三程序猿成长路线&quot;&gt;三、程序猿成长路线&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;软能力在程序猿的成长中其实扮演了至关重要的角色，但往往只是不被察觉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常，一名程序猿的发展道路有许多种，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231835192-834996102.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，架构师、项目经理、产品经理是出镜率最高的，大多只要是不跨行的程序猿，几乎最后都是如此。&lt;br/&gt;而对于我而言，这几个角色又是特别熟悉不过的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问题：软能力于这些角色又有什么样的关系？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;架构师&quot;&gt;1. 架构师&lt;/h3&gt;
&lt;p&gt;微服务架构很火，架构师的职位也很火，程序猿看到&lt;strong&gt;架构师 21天 快速进阶&lt;/strong&gt;的字眼也很兴奋...&lt;/p&gt;
&lt;p&gt;然而比较遗憾的是，许多关于架构师的培训、书籍都是以&lt;strong&gt;架构技术&lt;/strong&gt;为主，&lt;br/&gt;认为架构师就是技术牛B就好，对于架构师的软能力一概不谈。&lt;/p&gt;
&lt;p&gt;一些初创型的公司中，创始人并不真正了解架构师，却执着于招聘架构师岗位，素不知道他只是需要一个高级码农就可以了..&lt;/p&gt;
&lt;p&gt;下面这个图来自《软件架构师的12项修炼》一书，很好的说明了架构师该具备的软技能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231845771-2078883096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;see? 技术能力只是最基础的部分，沟通、领导力、认知、创新等等却是属于更高阶的能力。&lt;/p&gt;
&lt;h3 id=&quot;项目经理&quot;&gt;2. 项目经理&lt;/h3&gt;
&lt;p&gt;项目经理是一种纯管理类的岗位，在大部分中小型公司里，项目经理更多扮演了一个&quot;打杂&quot;的角色。&lt;br/&gt;为什么？ 我们先来看看项目经理的担子有多重：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标管理&lt;/strong&gt;&lt;br/&gt;要团队的每个人都能理解目标，非强大的沟通能力不可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进度管理&lt;/strong&gt;&lt;br/&gt;天天早会，天天监工，烦不胜烦..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成本管理&lt;/strong&gt;&lt;br/&gt;至少有一点成本预算意识(投资意识)，小心老板对你不满！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人员管理&lt;/strong&gt;&lt;br/&gt;有些人不想干了，得找他谈谈心，或许还有挽留的机会..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;风险管理&lt;/strong&gt;&lt;br/&gt;总是提心吊胆，得有强大的心理素质&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;也确实，好的项目经理身上总是聚集了许多高超的软能力，然而并不是很多程序猿都想当项目经理。&lt;br/&gt;一般来说，没有技术情结或技术不到家的，想快速上位的，可以走这个路线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231855058-67421619.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;产品经理&quot;&gt;3. 产品经理&lt;/h3&gt;
&lt;p&gt;程序猿转型产品经理的案例现在也越来越多了，&lt;br/&gt;这说明什么？ 互联网渗透率在加速的涨，产品经理待遇也在涨..&lt;/p&gt;
&lt;p&gt;具备技术背景的产品经理无疑是有优势的，但只是要小心，不要掉进&lt;strong&gt;技术情结的怪圈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于胜任产品经理一事的能力诉求，我认为下面的一张图可以很好说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201809/242916-20180915231909238-881132061.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【图来自豆瓣：&lt;a href=&quot;https://www.douban.com/note/321706416/&quot; class=&quot;uri&quot;&gt;https://www.douban.com/note/321706416/&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;在上面的图示中，沟通协调能力、逻辑分析、学习能力等等都在前面篇幅中提及。&lt;br/&gt;可见，在转型产品经理一职之前，程序猿要升华的部分仍然是不少！&lt;/p&gt;
&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;笔者在接触软件工作的这些年间，接触过不少程序猿，大部分人天资聪慧，热情助人，以拯救大家为己任。&lt;br/&gt;但是在面临职业生涯瓶颈转折之时，往往会产生许多纠结。&lt;br/&gt;技术出众者往往孤傲，不善于合群；技术平平者，往往能说会道，职场之路畅行无阻！&lt;/p&gt;
&lt;p&gt;在大部分情况下，软能力是获得成功的关键，本文介绍了一些模型，希望对读者能产生一些启示。&lt;br/&gt;谨以此文，献给仍然在挣扎中奋斗的技术人！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&quot;写一手好代码，做一手好菜，爱技术更爱生活，生活可以是诗和远方&quot;&lt;br/&gt;欢迎关注&lt;strong&gt;美码师&lt;/strong&gt;的公众号，跟我一起学习、交流！&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 15:21:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 在我们日常工作中，常常会听到软能力这一个词汇，尤其是在称赞某个人工作表现不错的时候更是如此。 然而关于软能力是什么，一百个人有一百种解释，就好像一千个人有一千个哈姆雷特。 一、软能力是什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9653019.html</dc:identifier>
</item>
<item>
<title>Java设计模式学习记录-观察者模式 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/9614000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/9614000.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;观察者模式也是对象行为模式的一种，又叫做发表-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、 咱们目前用的最多的就是各种MQ(Message Queue)都是基于这个模式的思想来实现的，生产者产生数据放到一个队列中，消费者观察生产者的消息队列的变化，从而接收消息，执行消费者本身的逻辑。&lt;/p&gt;
&lt;h2&gt;观察者模式&lt;/h2&gt;
&lt;h3&gt;概念介绍&lt;/h3&gt;
&lt;p&gt;观察者模式定义了一个一对多的依赖关系，让一个或多个观察者对象监察一个主题对象。这样一个主题对象在状态上的变化能够通知所有的依赖于此对象的那些观察者对象，使这些观察者对象能够自动更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915174528236-1496727001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些观察者之间没有任何关联，可以根据业务需要增加删除观察者，易于系统扩展。&lt;/p&gt;
&lt;h3&gt;举例&lt;/h3&gt;
&lt;p&gt;还是来举实际的例子，来介绍设计模式，毕竟设计模式是一种抽象的东西，需要落到真正的实现中才能体现出它的价值。当我们在网上购物时，看到一件自己比较喜欢的商品，但是最近手头有点紧（已经开始吃土了），所以会先关注一下这个商品，一般的购物网站上都会有&lt;strong&gt;关注&lt;/strong&gt;此商品这么一个功能的。为了就是当商品降价打折或是其他变化的时候能够通知到所有关注此商品的顾客。那么我们就以这个功能为例子来使用观察者模式实现一下。&lt;/p&gt;
&lt;p&gt;抽象主题类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象被观察类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Observable {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;观察者集合，存储关注商品的所有顾客&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Observer&amp;gt; observerList =&lt;span&gt; Lists.newArrayList();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加观察者（当一个顾客选择了关注商品时添加到观察者集合中）
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; observer 观察者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; attach(Observer observer){
        observerList.add(observer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注销观察者（取消关注商品）
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; observer 观察者
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detach(Observer observer){
        observerList.remove(observer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通知观察者的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notice(Object obj);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;商品类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 商品类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Getter &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok get方法&lt;/span&gt;
@AllArgsConstructor &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok 以所有属性为参数的构造方法&lt;/span&gt;
@NoArgsConstructor &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lombok 没有参数的构造方法&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Product &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 商品名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 商品价格&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BigDecimal price;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品名称变更
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; name 商品名称
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知观察者&lt;/span&gt;
&lt;span&gt;        notice(name);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 价格变更
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; price 商品价格
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrice(BigDecimal price){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知观察者&lt;/span&gt;
&lt;span&gt;        notice(price);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通知观察者的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notice(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Objects.nonNull(observerList)&amp;amp;&amp;amp;observerList.size()&amp;gt;0&lt;span&gt;){
            observerList.forEach((Observer observer) &lt;/span&gt;-&amp;gt;&lt;span&gt; observer.update(obj));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽象观察者类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象观察者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;名称观察者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 名称观察者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NameObserver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; String){
            String name &lt;/span&gt;=&lt;span&gt; (String) obj;
            System.out.println(&lt;/span&gt;&quot;您关注的商品名称发生了变化，最新的商品名称是&quot;+&lt;span&gt;name);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;价格观察者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 价格观察者 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PriceObserver &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Observer{


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj 更新对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BigDecimal){
            BigDecimal price &lt;/span&gt;=&lt;span&gt; (BigDecimal)obj;
            System.out.println(&lt;/span&gt;&quot;您关注的商品价格发生了变化，最新的商品价格是：&quot;+&lt;span&gt;price);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Product(&quot;iphoneX&quot;,&lt;span&gt;new&lt;/span&gt; BigDecimal(8999&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;您关注的商品的名称是：&quot;+product.getName()+&quot;，价格是：&quot;+&lt;span&gt;product.getPrice());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建观察者&lt;/span&gt;
        NameObserver nameObserver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameObserver();
        PriceObserver priceObserver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceObserver();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入观察者&lt;/span&gt;
&lt;span&gt;        product.attach(nameObserver);
        product.attach(priceObserver);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生变化，通知观察者&lt;/span&gt;
        product.setName(&quot;iphoneX Max&quot;&lt;span&gt;);
        product.setPrice(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(12999&lt;span&gt;));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
您关注的商品的名称是：iphoneX，价格是：8999&lt;span&gt;
您关注的商品名称发生了变化，最新的商品名称是iphoneX Max
您关注的商品价格发生了变化，最新的商品价格是：&lt;/span&gt;12999
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的运行结果我们就能看出来，当商品名称或价格发生变化时，会通知到相应的观察者，这就是观察者模式的具体应用了。那么通过例子我们也可以看出来观察者模式具体是由哪些角色组成的。&lt;/p&gt;
&lt;h3&gt;观察者模式的结构&lt;/h3&gt;
&lt;p&gt;观察者模式结构如下图 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915220247338-1137018364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在观察者模式中存在如下几种角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象主题角色（Subject）&lt;/strong&gt;：抽象主题角色把所有的观察者对象的引用保存在一个列表里；每个主题都可以有任何数量的观察者。主题提供一个接口，可以加上或撤销观察者对象；主题角色又被称为被观察者角色。可以用抽象类或接口来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象观察者角色（Observer）&lt;/strong&gt;：为所有的具体观察者定义一个接口，在得到通知时更新自己。抽象观察者角色通常是用一个抽象类或一个接口来实现；当然也可以用具体的类来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体主题角色（ConcreteSubject）&lt;/strong&gt;：具体主题保存对具体观察者对象有用的内部状态，在这种状态改变时，给其观察者发出一个具体的通知，具体主题角色又被称为具体被观察者角色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体观察者角色（ConcreteObserver）&lt;/strong&gt;：具体观察者角色用于保存一个指向具体主题对象的引用，和一个与主题的状态相符的状态。具体观察者角色实现抽象观察者角色所要求的更新自己的接口，以便使本身的状态与主题的状态对应。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;观察者模式是一种使用频率比较高的设计模式，凡是涉及到一对一或一对多的对象交互场景都可以使用观察者模式。&lt;/p&gt;
&lt;h3&gt;观察者模式的主要优点&lt;/h3&gt;
&lt;p&gt;1、观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当观察者角色。&lt;/p&gt;
&lt;p&gt;2、观察者模式在观察目标和观察者之间建立一个抽象耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。&lt;/p&gt;
&lt;p&gt;3、观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。&lt;/p&gt;
&lt;p&gt;4、观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。&lt;/p&gt;
&lt;h3&gt;观察者模式的主要缺点&lt;/h3&gt;
&lt;p&gt;1、如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。&lt;/p&gt;
&lt;p&gt;2、如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。&lt;/p&gt;
&lt;p&gt;3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。&lt;/p&gt;
&lt;h3&gt;适用场景&lt;/h3&gt;
&lt;p&gt;1、一个对象的改变将会导致一个或多个对象的改变，不清楚具体有多少对象以及这些被影响的对象是谁的情况。&lt;/p&gt;
&lt;p&gt;2、如果有这样一个影响链的情况下也可以使用，例如A的改变会影响B，B的改变会影响C......，可以使用观察者模式设计一个链式触发机制。&lt;/p&gt;


&lt;p&gt;想了解更多的设计模式请查看&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jimoer/p/9163426.html&quot;&gt;Java设计模式学习记录-GoF设计模式概述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/772743/201809/772743-20180915224244625-861430438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个是我的个人公众号，文章以后也会同步到公众号上去，欢迎关注。&lt;/p&gt;

</description>
<pubDate>Sat, 15 Sep 2018 14:52:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 观察者模式也是对象行为模式的一种，又叫做发表-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、 咱们目前用的最多的就是各种MQ(Message Queue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimoer/p/9614000.html</dc:identifier>
</item>
<item>
<title>Docz 用 MDX 写 React UI 组件文档 - givebest</title>
<link>http://www.cnblogs.com/givebest/p/9652889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/givebest/p/9652889.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;为了提升开发效率，创建一套 UI 组件库是一种较为有效的方式之一：可以减少重复工作、提高可复用，所以现在越来越多团队开始创建自己的 UI 组件库。较早的 Twitter 的 &lt;a href=&quot;http://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt; 虽然只能称为 UI 库，但也大大提升了开发效率。后面 &lt;code&gt;MVVM&lt;/code&gt; 大行其道 ，前端终于可以把 HTML、CSS、JS 放在一起开发包含 UI 、交互真正意义上的组件了，现在有基于 &lt;code&gt;React&lt;/code&gt; 的 &lt;a href=&quot;https://material-ui.com/demos/app-bar/&quot;&gt;Material-UI&lt;/a&gt;、国内阿里金服基于 &lt;code&gt;React&lt;/code&gt; 的 &lt;a href=&quot;https://ant.design/docs/react/introduce-cn&quot;&gt;Ant Design&lt;/a&gt;、饿了么基于 &lt;code&gt;Vue.js&lt;/code&gt; 的 &lt;a href=&quot;https://element.eleme.io/&quot;&gt;Element&lt;/a&gt;、TalkingData 基于 &lt;code&gt;Vue.js&lt;/code&gt; 的 &lt;a href=&quot;https://iviewui.com/&quot;&gt;iView&lt;/a&gt; 等。有了这些 UI 组件，让前端开发变得前所未有的方便，完成一个项目就像是拿一块块的积木(组件)堆成一个完整项目。&lt;/p&gt;
&lt;p&gt;考虑到前期开发 UI 组件的工作量及后期维护成本，我认为在大厂开源 UI 组件库的基础上个性化色彩（一般都提供颜色定制）、增加团队的个性化需求组件、减少不需要的组件是个不错的主意。&lt;/p&gt;
&lt;p&gt;有了团队的 UI 组件库就少不了使用文档，毕竟文档还是比口口相传要靠谱的多。这里介绍一个可以快速创建 React UI 组件库使用、演示文档的项目：&lt;a href=&quot;https://github.com/pedronauck/docz&quot;&gt;Docz&lt;/a&gt;。&lt;a href=&quot;https://github.com/pedronauck/docz&quot;&gt;Docz&lt;/a&gt; 的特色是零配置、简单、快速，它使用 &lt;code&gt;Markdown&lt;/code&gt; 语法的扩展 &lt;a href=&quot;https://github.com/mdx-js/mdx&quot;&gt;MDX&lt;/a&gt; (在 Markdown 里引入 React 组件并渲染出组件)来书写文档，对于熟悉 &lt;code&gt;Markdown&lt;/code&gt; 的开发者是可以直接上手的。下面贴一张官方的图看看有多简单：&lt;br/&gt;&lt;img src=&quot;https://givebest.github.io/images/docz/docz.png&quot; alt=&quot;Docz&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;左边是创建的 &lt;code&gt;MDX&lt;/code&gt; 文档，右边是 Docz 渲染出的组件及组件代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是很方便？那下面简单介绍一下使用步骤。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;h5 id=&quot;在你的项目里安装-docz&quot;&gt;1. 在你的项目里安装 Docz：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;yarn add docz --dev 或者 npm install docz --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建-.mdx-文件并输入&quot;&gt;2. 创建 &lt;code&gt;.mdx&lt;/code&gt; 文件并输入：&lt;/h5&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;---
name: Button
---

import { Playground, PropsTable } from 'docz'
import Button from './'

# Button

&amp;lt;PropsTable of={Button} /&amp;gt;

## Basic usage

&amp;lt;Playground&amp;gt;
 &amp;lt;Button&amp;gt;Click me&amp;lt;/Button&amp;gt;
 &amp;lt;Button kind=&quot;secondary&quot;&amp;gt;Click me&amp;lt;/Button&amp;gt;
&amp;lt;/Playground&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;运行&quot;&gt;3. 运行：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;yarn docz dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就完成了一个简单的 Button 组件的演示、使用文档。&lt;br/&gt;&lt;img src=&quot;https://givebest.github.io/images/docz/docz-preview.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.171875&quot;&gt;
&lt;p&gt;更多详情：&lt;a href=&quot;http://www.docz.site/introduction/getting-started&quot; class=&quot;uri&quot;&gt;http://www.docz.site/introduction/getting-started&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;
&lt;p&gt;零配置方便是方便，但有时想界面个性化点还是很费事的(官方提供 Themes 支持，但现仅有一套官方的默认主题)，下面分享一个通过引入本地 CSS 的方式来改变默认主题的配置。&lt;/p&gt;
&lt;h5 id=&quot;创建配置文件-doczrc.js增加-htmlcontext-内容&quot;&gt;1. 创建配置文件 &lt;code&gt;doczrc.js&lt;/code&gt;，增加 htmlContext 内容。&lt;/h5&gt;
&lt;blockquote readability=&quot;1.0416666666667&quot;&gt;
&lt;p&gt;更多配置：&lt;a href=&quot;https://www.docz.site/documentation/project-configuration&quot; class=&quot;uri&quot;&gt;https://www.docz.site/documentation/project-configuration&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  htmlContext: {
    head: {
      links: [
        { rel: 'stylesheet', href: '/base.css' }
      ]
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;docz-目录下创建-public-文件夹并创建-base.css在-base.css-里写自己的样式覆盖默认的即可&quot;&gt;2. &lt;code&gt;.docz&lt;/code&gt; 目录下创建 &lt;code&gt;public&lt;/code&gt; 文件夹并创建 &lt;code&gt;base.css&lt;/code&gt;，在 &lt;code&gt;base.css&lt;/code&gt; 里写自己的样式覆盖默认的即可。&lt;/h5&gt;
&lt;h4 id=&quot;最后&quot;&gt;最后&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Docz 简单好用，但现在只支持 React。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/storybooks/storybook&quot;&gt;Storybook&lt;/a&gt; 是一个更强大的集组件开发、查看、测试的文档工具，支持：
&lt;ul&gt;&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;React Native&lt;/li&gt;
&lt;li&gt;Vue&lt;/li&gt;
&lt;li&gt;Angular&lt;/li&gt;
&lt;li&gt;Polymer&lt;/li&gt;
&lt;li&gt;Mithril&lt;/li&gt;
&lt;li&gt;Marko&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;Svelte&lt;/li&gt;
&lt;li&gt;Riot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/docsifyjs/docsify&quot;&gt;Docsify&lt;/a&gt;：&lt;a href=&quot;https://docsify.js.org/#/zh-cn/vue?id=%E6%90%AD%E9%85%8D-vuep-%E5%86%99-playground&quot;&gt;搭配 Vuep 写 Playground&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;转载请注明出处-httpsblog.givebest.cnother20180915react-ui-component-docz-mdx.html&quot;&gt;转载请注明出处： &lt;a href=&quot;https://blog.givebest.cn/other/2018/09/15/react-ui-component-docz-mdx.html&quot; class=&quot;uri&quot;&gt;https://blog.givebest.cn/other/2018/09/15/react-ui-component-docz-mdx.html&lt;/a&gt;&lt;/h5&gt;
</description>
<pubDate>Sat, 15 Sep 2018 14:34:00 +0000</pubDate>
<dc:creator>givebest</dc:creator>
<og:description>这里介绍一个可以快速创建 React UI 组件库使用、演示文档的项目：Docz</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/givebest/p/9652889.html</dc:identifier>
</item>
<item>
<title>mybatis 解析配置文件（一）之XML的DOM解析方式 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9652273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9652273.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在之前的文章《mybatis 初步使用（IDEA的Maven项目, 超详细）》中， 讲解了&lt;code&gt;mybatis&lt;/code&gt;的初步使用， 并总结了以下&lt;code&gt;mybatis&lt;/code&gt;的执行流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;通过 Resources 工具类读取 mybatis-config.xml， 存入 Reader；&lt;/li&gt;
&lt;li&gt;SqlSessionFactoryBuilder使用上一步获得的reader创建SqlSessionFactory对象;&lt;/li&gt;
&lt;li&gt;通过 sqlSessionFactory 对象获得SqlSession;&lt;/li&gt;
&lt;li&gt;SqlSession对象通过selectList方法找到对应的“selectAll”语句， 执行SQL查询。&lt;/li&gt;
&lt;li&gt;底层通过 JDBC 查询后获得ResultSet, 对每一条记录， 根据resultMap的映射结果映射到Student中， 返回List。&lt;/li&gt;
&lt;li&gt;最后记得关闭 SqlSession&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;本系列文章深入讲解第 2 步， 解析配置文件。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;java-中-xml-文件解析&quot;&gt;Java 中 XML 文件解析&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mybatis&lt;/code&gt;是基于 &lt;code&gt;XML&lt;/code&gt; 来进行配置的， 因此， 我们首先要知道在&lt;code&gt;Java&lt;/code&gt;中， &lt;code&gt;XML&lt;/code&gt;是如何解析的。&lt;/p&gt;
&lt;h3 id=&quot;解析方式&quot;&gt;解析方式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;XML&lt;/code&gt; 常见的解析方式有以下三种： &lt;code&gt;DOM&lt;/code&gt;、 &lt;code&gt;SAX&lt;/code&gt; 和 &lt;code&gt;StAX&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dom-方式&quot;&gt;1. DOM 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;DOM&lt;/code&gt; 基于树形结构解析， 它会将整个文档读入内存并构建一个 &lt;code&gt;DOM&lt;/code&gt; 树， 基于这棵树的结构对各个节点进行解析。&lt;/p&gt;
&lt;h4 id=&quot;sax-方式&quot;&gt;2. SAX 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SAX&lt;/code&gt; 是基于事件模型的 &lt;code&gt;XML&lt;/code&gt; 解析方式， 它不需要将整个 &lt;code&gt;XML&lt;/code&gt; 文档加载到内存中， 而只需要将一部分 &lt;code&gt;XML&lt;/code&gt; 文档的一部分加载到内存中， 即可开始解析。&lt;/p&gt;
&lt;h4 id=&quot;stax-方式&quot;&gt;3. StAX 方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;StAX&lt;/code&gt; 与 &lt;code&gt;SAX&lt;/code&gt; 类似， 也是把 &lt;code&gt;XML&lt;/code&gt; 文档作为一个事件流进行处理， 但不同之处在于 &lt;code&gt;StAX&lt;/code&gt; 采用的是“拉模式”， 即应用程序通过调用解析器推进解析的过程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;dom-解析-xml&quot;&gt;DOM 解析 XML&lt;/h2&gt;
&lt;p&gt;在加载 &lt;code&gt;mybatis-config.xml&lt;/code&gt; 配置文件与映射文件时， 使用的是 &lt;code&gt;DOM&lt;/code&gt; 解析方式， 并配合使用 &lt;code&gt;XPath&lt;/code&gt; 解析 &lt;code&gt;XML&lt;/code&gt; 配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XPath&lt;/code&gt; 之于 &lt;code&gt;XML&lt;/code&gt; 就好比 &lt;code&gt;SQL&lt;/code&gt; 之于数据库。&lt;/p&gt;
&lt;p&gt;所谓&lt;code&gt;DOM&lt;/code&gt;， 是 &lt;strong&gt;Document Object Model&lt;/strong&gt; 的缩写， 翻译过来就是文档对象模型。&lt;/p&gt;
&lt;p&gt;下面我们就来展示一下该过程。&lt;/p&gt;
&lt;h3 id=&quot;新建-xml-文件&quot;&gt;新建 XML 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;CATALOG&amp;gt;
    &amp;lt;CD id=&quot;1&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Empire Burlesque&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Bob Dylan&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;USA&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;Columbia&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;10.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1985&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;2&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Hide your heart&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Bonnie Tyler&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;UK&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;CBS Records&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1988&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;3&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Greatest Hits&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Dolly Parton&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;USA&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;RCA&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1982&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;4&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Still got the blues&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Gary Moore&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;UK&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;Virgin records&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;10.20&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1990&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
    &amp;lt;CD id=&quot;5&quot;&amp;gt;
        &amp;lt;TITLE&amp;gt;Eros&amp;lt;/TITLE&amp;gt;
        &amp;lt;ARTIST&amp;gt;Eros Ramazzotti&amp;lt;/ARTIST&amp;gt;
        &amp;lt;COUNTRY&amp;gt;EU&amp;lt;/COUNTRY&amp;gt;
        &amp;lt;COMPANY&amp;gt;BMG&amp;lt;/COMPANY&amp;gt;
        &amp;lt;PRICE&amp;gt;9.90&amp;lt;/PRICE&amp;gt;
        &amp;lt;YEAR&amp;gt;1997&amp;lt;/YEAR&amp;gt;
    &amp;lt;/CD&amp;gt;
&amp;lt;/CATALOG&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;CATALOG&lt;/code&gt;中， 有很多&lt;code&gt;CD&lt;/code&gt;， &lt;code&gt;CD&lt;/code&gt;有着自己的子节点。&lt;/p&gt;
&lt;h3 id=&quot;dom-操作相关类&quot;&gt;DOM 操作相关类&lt;/h3&gt;
&lt;p&gt;以上的XML， 其对应的树形结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180915211625110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;文档结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在&lt;code&gt;Java&lt;/code&gt;中， 有很节点类型， 以下有几个主要的接口对应着&lt;code&gt;XML&lt;/code&gt;中的各个属性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt; : DOM最基本的数据类型。 表示文档树中的单个节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Element&lt;/strong&gt;：常见的元素节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attr&lt;/strong&gt;：代表元素的属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text&lt;/strong&gt;：元素或者Att的值（内容）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt;：代表整个XML文档&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;java-读取-xml-文件&quot;&gt;Java 读取 XML 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
    // 获取 DocumentBuilderFactory 
    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();

    builderFactory.setValidating(false);
    builderFactory.setNamespaceAware(false);
    builderFactory.setIgnoringComments(true);
    builderFactory.setIgnoringElementContentWhitespace(false);
    builderFactory.setCoalescing(false);
    builderFactory.setExpandEntityReferences(true);

    // 通过 DocumentBuilderFactory 获取 DocumentBuilder
    DocumentBuilder builder = builderFactory.newDocumentBuilder();

    builder.setErrorHandler(new ErrorHandler() {
        @Override
        public void warning(SAXParseException exception) throws SAXException {
            System.out.println(&quot;warning:&quot;+exception.getMessage());
        }

        @Override
        public void error(SAXParseException exception) throws SAXException {
            System.out.println(&quot;error:&quot;+exception.getMessage());
        }

        @Override
        public void fatalError(SAXParseException exception) throws SAXException {
            System.out.println(&quot;fatalError:&quot;+exception.getMessage());
        }
    });
    
    // 得到Document文件， 就是XML在JVM中的化身
     InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;xml/cds.xml&quot;);
     Document document = builder.parse(is);
    
    // 以下通过 XPath 来获取对应的信息
    XPathFactory xPathFactory = XPathFactory.newInstance();
    XPath xPath = xPathFactory.newXPath();
    // 解析 //CD//TITLE//text() ， 就是获取所有CD节点下TITLE子节点的文字内容 
    XPathExpression expression = xPath.compile(&quot;//CD//TITLE//text()&quot;);
    
    Object result = expression.evaluate(document, XPathConstants.NODESET);
    NodeList nodeList = (NodeList)result;
    for (int i = 0; i &amp;lt; nodeList.getLength(); i++) {
        System.out.println(nodeList.item(i).getNodeValue());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其主要步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; 对象;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; 创建&lt;code&gt;DocumentBuilder&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;DocumentBuilder&lt;/code&gt;， 从文件或流中创建通过&lt;code&gt;Document&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;XPathFactory&lt;/code&gt;对象， 并通过&lt;code&gt;XPathFactory&lt;/code&gt;创建&lt;code&gt;XPath&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;XPath&lt;/code&gt;解析出&lt;code&gt;XPathExpression&lt;/code&gt;对象;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;XPathExpression&lt;/code&gt;在文档中搜索出相应的节点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180915211647827?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以调用相应的 &lt;code&gt;API&lt;/code&gt; 进行获取和设置各个属性， 再次就不过多的进行深入。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 13:26:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>简介 在之前的文章《mybatis 初步使用（IDEA的Maven项目, 超详细）》中， 讲解了mybatis的初步使用， 并总结了以下mybatis的执行流程： 1. 通过 Resources 工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9652273.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/9652134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/9652134.html</guid>
<description>&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;【&lt;a href=&quot;https://files.cnblogs.com/files/lovecindywang/ZHUYE_ARCH_S1E5.pdf&quot; target=&quot;_blank&quot;&gt;下载本文PDF进行阅读&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;一般而言中间件和框架的区别是，中间件是独立运行的用于处理某项专门业务的CS程序，会有配套的客户端和服务端，框架虽然也是处理某个专门业务的但是它不是独立程序，是寄宿在宿主程序进程内的一套类库。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202444632-1262437572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图上绿色部分代表了框架，红色部分代表了管理系统，紫色部分代表了中间件。本文会着重介绍管理系统和中间件部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202416513-1889447067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比较知名的分布式配置服务和管理系统有携程的&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt;（上图）以及&lt;a href=&quot;https://github.com/knightliao/disconf&quot;&gt;https://github.com/knightliao/disconf&lt;/a&gt;。对于比较大型的互联网项目来说，因为业务繁杂，需求多变，往往各种系统都会有大量的配置，覆盖几个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对系统内部技术层面的各种配置，各种池的大小、 队列的大小、日志级别、各种路径、批次大小、处理间隔、重试次数、超时时间等。&lt;/li&gt;
&lt;li&gt;针对业务运营层面的各种配置，活动的周期奖励、黑白名单、弹窗、广告位等。&lt;/li&gt;
&lt;li&gt;针对运维和发布层面的配置，灰度名单、注册中心地址、数据库地址、缓存地址、MQ地址等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为一些基础组件比如SOA框架和发布系统也会用到配置，这个时候就会可能会有鸡生蛋的问题，这里我比较建议把配置系统作为最最底层的系统，其它服务都可以依赖配置系统。一般而言配置管理除了实现最基本的Key-Value的配置读取和配置之外，还会有下面的一些特性和功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能。配置服务的压力会是非常吓人的，在一次服务调用中可能就会有几十次的配置调用，如果服务的整体QPS在500那么配置服务的压力可能在1万的QPS，这样的QPS不走缓存基本是不可能的。好在即使是1万甚至是5万的QPS也不算一个很夸张的无法解决的压力。&lt;/li&gt;
&lt;li&gt;高可用。现在各种开源的配置服务是所谓的分布式配置服务，由可扩展的配置服务集群来承担负载均衡和高可用功能，配置服务一旦挂了可能会让系统瘫痪。你可能会说配置服务一般本地会有缓存，会有本地的配置文件作为后备，会有默认值，但是因为配置是运营运维在实时修改的，如果某个业务的配置没有使用最新的配置走的是错误的默认值的话，系统会处于完全混乱的状态，所以配置服务的稳定性太重要了。&lt;/li&gt;
&lt;li&gt;树形的配置体系。如果只是把所有配置堆在一个列表里，加上项目和分类的话，当配置多达几千项的时候还是会有点多。可以支持树形的层级配置，不拘泥于项目和分类这两个条件。项目下可以有模块，模块下可以有分类，分类下可以有小类，根据自己的需求动态构建配置树。&lt;/li&gt;
&lt;li&gt;好用的客户端。比如可以和SpringBoot以及@Value注解结合起来，非侵入整合配置系统，无需任何代码的改动。&lt;/li&gt;
&lt;li&gt;毫秒级粒度的修改实时生效。可以使用长连接推的方式实现，也可以实现缓存失效的方式实现。&lt;/li&gt;
&lt;li&gt;配置的分层隔离。包括按照环境、集群和项目来提供多套配置相互独立不影响，包括可以以层级的方式做配置继承。&lt;/li&gt;
&lt;li&gt;配置的权限控制。不同类型、环境、集群、项目的配置具有不同的管理权限，比如脱敏只读、只读、读写、导出。&lt;/li&gt;
&lt;li&gt;配置的版本管理。配置的每一次修改都是一个版本，可以为单独的配置或项目进行直接版本回滚。&lt;/li&gt;
&lt;li&gt;丰富的Value形式。配置的Value如果要保存列表的话，保存一个JSON阅读和修改都不方便，可以直接提供List方式的Value，在后台可以单独增删改里面的一项。在比如黑名单的引用上这种方式比较高效，否则更新一个名单每次都要修改整个黑名单。这个功能可以和Redis结合在一起进行实现。Value除了支持字符串可以是JSON和XML形式，系统可以对格式进行格式化，对格式进行校验。Value也可以是非字符串类型的各种数字格式，系统也会根据类型进行校验。&lt;/li&gt;
&lt;li&gt;丰富的配置发布生效形式。比如可以自然生效、立即生效以及定时生效。定时生效的功能适合于在某个时间点需要开启某个配置，比如用于面向用户的推送、活动业务。还有支持灰度自动发布，以一定的时间间隔来对集群里的实例进行发布，避免人工去定期逐一发布单台的麻烦。&lt;/li&gt;
&lt;li&gt;审核审计功能。配置的修改可以由管理员进行审核（也就是修改和发布的权限支持分离），避免配置错误修改。所有配置的修改记录可以查询到谁什么时候因为什么原因修改了什么配置，事后可以审计审查。&lt;/li&gt;
&lt;li&gt;配置生效跟踪和使用率跟踪。可以看到每一个配置项现在哪些客户端在使用，生效的值的版本是哪个。通过这个功能还可以排查现在系统中过去一段时间从没有用过的配置，删除无用的配置。&lt;/li&gt;
&lt;li&gt;动态配置。在API设计的时候我们引入上下文的概念，通过传入一个Map字典作为上下文，比如某个配置按照不同的用户类型、城市需要有不同的值，这个逻辑我们可以不需要在代码里面手工编写，直接通过在后台配置上下文的匹配策略来动态读取到不同的配置值。&lt;/li&gt;
&lt;li&gt;本地快照。对配置进行快照本地保存，在出现故障无法连接服务端的时候使用本地的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里可以看到要实现一个功能完善的配置系统工作量还是相当大的，一个优秀的功能强大的配置系统可以节省很多开发的工作量，因为可配置部分的功能基本就是由配置系统直接实现了，无需在数据库中在搞大量的XXConfig表（不夸张的说，很多业务系统40%的工作量在这个上面，不但需要做这些配置表还需要配以配置后台）。&lt;/p&gt;


&lt;p&gt;微服务的建设中实现远程调用只是实现了20%的工作量（但是确实满足了80%的需求）。服务管理治理这块有大量的工作要做。这也就是实现自己RPC框架的好处，这是第一步，有了这第一步让数据流过我们自己的框架以后我们接可以做更多的事情，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用链跟踪。能否记录整个调用的情况，并且查看这个调用链。下面一节会再说一下这点。&lt;/li&gt;
&lt;li&gt;注册管理。查看服务的注册情况，服务手动上线下线，集群切换，压力分配干预。&lt;/li&gt;
&lt;li&gt;配置管理。配置服务端客户端线程池和队列的配置，超时配置等等。当然，这个也可以在配置系统中进行。&lt;/li&gt;
&lt;li&gt;运维层面的管理。查看和管理方法熔断，进行并发限流配置，服务权限黑白名单配置，安全方面的配置（信息加密，日志脱敏等）。&lt;/li&gt;
&lt;li&gt;Service Store的概念。服务发布需要满足一定要求，有文档（比如可以通过注解方式在代码注释里提供），有信息（开发负责人、运维负责人，服务类型，提供的能力），满足要求后就可以以类似于苹果App Store发布程序的方式发布服务，这样我们就可以在统一的平台上查看服务的维护信息和文档。&lt;/li&gt;
&lt;li&gt;版本控制调用统计。对服务进行灰度升级，按版本路由，不同版本调用分析等等。类似于一些应用统计平台提供的功能（友盟、TalkingData）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我想说的理念是，服务能调用通是第一步，随着服务数量变多，部署方式的复杂化，依赖关系复杂化，版本的迭代，API的变更，开发人员和架构师其实急需有一套地图能够对服务能力的全貌进行整体的了解，运维也需要有系统能对服务进行观察和调配。服务治理的部分完全可以以iOS那套（开发符合时候需要符合标准+发布的时候需要有流程）方式来运作。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202455341-25214706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源的实现有&lt;a href=&quot;https://github.com/dianping/cat&quot;&gt;https://github.com/dianping/cat&lt;/a&gt;以及&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;https://github.com/naver/pinpoint&lt;/a&gt;（上图）等等。对于微服务比较多的（主流程涉及8+微服务）系统，如果没有服务的全链路调用跟踪那么排查故障以及性能问题就会很困难了。一般完善的全链路监控体系不仅仅覆盖微服务，而且功能也会更丰富，实现下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以Log、Agent、Proxy或整合进框架的方式实现，尽可能少的侵入的情况下实现数据的收集。而且确保数据的收集不会影响到主业务，收集服务端宕机的情况下业务不影响。&lt;/li&gt;
&lt;li&gt;调用跟踪。涉及到服务调用、缓存调用、数据库调用，MQ调用，不仅仅可以以树的形式呈现每次调用的类型、耗时、结果，还可以呈现完整的根，也就是对于网站请求呈现出请求的完整信息，对于Job任务呈现出Job的信息。&lt;/li&gt;
&lt;li&gt;JVM的信息（比如对于Java）。呈现每一个进程JVM层次的GC、Threads、Memory、CPU的使用情况。可以进行远程Stack的查看和Heap的快照（没有进程的内存信息，很多时候基于服务器层面粗粒度的资源使用情况的监控，基本不可能分析出根本原因），并且可以设定策略进行定期的快照。虚拟机的信息查看和调用跟踪甚至可以通过快照进行关联，在出现问题的时候能够了解当时虚拟机的状态对于排查问题是非常有好处的。&lt;/li&gt;
&lt;li&gt;依赖关系一览。有的时候我们做架构方案，第一步就是梳理模块和服务之间的依赖关系，只有这样我们才能确定影响范围重构范围，对于微服务做的比较复杂的项目来说，每个人可能只是关注自己服务的上下游，对于上游的上游和下游的下游完全不清楚，导致公司也没有人可以说的清楚架构的全貌。这个时候我们有全链路跟踪系统的话，可以对通过分析过去的调用来绘制出一张依赖关系的架构图。这个图如果对QPS做一些热点的话，还可以帮助我们做一些运维层面的容量规划。&lt;/li&gt;
&lt;li&gt;高级分析建议。比如在全链路压测后定位分析瓶颈所在。定时分析所有组件的执行性能，得出性能衰退的趋势，提早进行问题预警。分析JVM的线程和GC情况，辅助定位High CPU和Memory Leak的问题。退一万步说，即使没有这样的自动化的高级分析，有了调用跟踪的图和组件依赖关系图，至少在出问题的时候我们人能分析出来咋回事。&lt;/li&gt;
&lt;li&gt;Dashboard。非必须，只要数据收集足够全面，如之前文章所示，我们可以用Grafana来进行各种个性化的图表配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源的实现有C实现的&lt;a href=&quot;https://github.com/Qihoo360/Atlas&quot;&gt;https://github.com/Qihoo360/Atlas&lt;/a&gt;以及Go实现的&lt;a href=&quot;https://github.com/flike/kingshard&quot;&gt;https://github.com/flike/kingshard&lt;/a&gt; 等。数据访问中间件是独立部署的数据库的透明代理，本身需要是以集群方式支持高可用，背后还需要对接多套数据库作为一个集群，一般而言会提供如下的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最常用的功能就是读写分离。也包括负载均衡和故障转移的功能，自动在多个从库做负载均衡，通过可用性探测，在主库出现故障的时候配合数据库的高可用和复制做主库的切换。&lt;/li&gt;
&lt;li&gt;随着数据量的增多需要分片功能。分片也就是Sharding，把数据按照一定的维度均匀分散到不同的表，然后把表分布在多个物理数据库中，实现压力的分散。这里写入的Sharding一般而言没有太多的差异，但是读取方面因为涉及到归并汇总的过程，如果要实现复杂功能的话还是比较麻烦的。由于分片的维度往往可能有多个，这方面可以采用多写多个维度的底层表来实现也可以采用维度索引表方式来实现。&lt;/li&gt;
&lt;li&gt;其它一些运维方面的功能。比如客户端权限控制，黑白名单，限流，超时熔断，和调用链搭配起来的调用跟踪，全量操作的审计搜索，数据迁移辅助等等。&lt;/li&gt;
&lt;li&gt;更高级的话可以实现SQL的优化功能。随时进行SQL的Profiler，然后达到一定阈值后提供索引优化建议。类似&lt;a href=&quot;https://github.com/Meituan-Dianping/SQLAdvisor&quot;&gt;https://github.com/Meituan-Dianping/SQLAdvisor&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;其它。极少的代理实现了分布式事务的功能（XA）。还可以实现代理层面的分布式悲观锁的功能。其实细想一下，SQL因为并不是直接扔到数据库执行，这里的可能性就太多了，想干啥都可以。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现上一般需要做下面几件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有一个高性能的网络模型，一般基于高性能的网络框架实现，毕竟Proxy的网络方面的性能不能成为瓶颈。&lt;/li&gt;
&lt;li&gt;有一个MySQL协议的解析器，开源实现很多，拿过来直接用即可。&lt;/li&gt;
&lt;li&gt;有一个SQL语法的解析器，Sharding以及读写分离免不了需要解析SQL，一般流程为SQL解析、查询优化、SQL路由、SQL重写，在把SQL提交到多台数据库执行后进行结果归并。&lt;/li&gt;
&lt;li&gt;Proxy本身最好是无状态节点，以集群方式实现高可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些功能除了Proxy方式的实现还有和数据访问标准结合起来的实现，比如改写JDBC的框架方式实现，两种实现方式各有优缺点。框架方式的实现不局限于数据库类型，性能略高，Proxy方式的实现支持任意的语言更透明，功能也可以做的更强大一些。最近还出现了边车Sidecard方式实现的理念，类似于ServiceMesh的概念，网上有一些资料，但是这种方式到目前为止还没看到成熟的实现。&lt;/p&gt;


&lt;p&gt;类似于数据库的Proxy，这里是以缓存服务作为后端，提供一些集群化的功能。比如以Redis为后端的开源的实现有&lt;a href=&quot;https://github.com/CodisLabs/codis&quot;&gt;https://github.com/CodisLabs/codis&lt;/a&gt;以及饿了么的&lt;a href=&quot;https://github.com/eleme/corvus&quot;&gt;https://github.com/eleme/corvus&lt;/a&gt; 等等。其实不采用Proxy方式做，开发一个缓存客户端在框架层面做也是完全可以的，但是之前也说了这两种方式各有优劣。代理方式的话更透明，如果有Java、Python、Go都需要链接Redis，我们无需开发多套客户端了。一般实现下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式。这是最基本的，通过各种算法把Key分散到各个节点，提供一定的容量规划和容量报警功能。&lt;/li&gt;
&lt;li&gt;高可用。配合Redis的一些高可用方案实现一定程度的高可用。&lt;/li&gt;
&lt;li&gt;运维方面的功能。比如客户端权限控制，黑白名单，限流，超时熔断，全量操作的审计搜索，数据迁移辅助等等。&lt;/li&gt;
&lt;li&gt;跟踪和问题分析。配合全链路监控实现一体化的缓存访问跟踪。以及更智能的分析使用的情况，结合缓存的命中率，Value的大小，压力平衡性提供一些优化建议和报警，尽早发现问题，缓存的崩盘往往是有前兆的。&lt;/li&gt;
&lt;li&gt;完善的管理后台，可以一览集群的用量、性能，以及做容量规划和迁移方案。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果Redis集群特别大的话的确是有一套的自己的Proxy体系会更方便，小型项目一般用不到。&lt;/p&gt;


&lt;p&gt;之前有提到过，Job是我认为的互联网架构体系中三马车的三分之一，扮演了重要的角色。开源实现有&lt;a href=&quot;http://elasticjob.io/&quot;&gt;http://elasticjob.io/&lt;/a&gt;。Job的管理的实现有两种方式，一种是类似于框架的方式，也就是Job的进程是一直启动着的，由框架在合适的时候调用方法去执行。一种是类似于外部服务的方式，也就是Job的进程是按需要在合适的机器启动的。在本文一开始的图中，我画了一个任务调度的中间件，对于后一种方式的实现，我们需要有一套中间件或独立的服务来复杂Job进程的拉起。整个过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找一些机器加入集群作为我们的底层服务器资源。&lt;/li&gt;
&lt;li&gt;Job编译后打包部署到统一的地方。Job可以是各个语言实现的，这没有关系。可以是裸程序，也可以使用Docker来实现。&lt;/li&gt;
&lt;li&gt;在允许Job前我们需要对资源进行分配，估算一下Job大概需要怎么样的资源，然后根据执行频次统一计算得出一个合适的资源分配。&lt;/li&gt;
&lt;li&gt;由中间件根据每一个Job的时间配置在合适的时候把进程（或Docker）拉起执行，执行前根据当前的情况计算分配一个合适的机器，完成后释放资源，下一次执行不一定在同一台机器执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的中间件是更底层的一套服务，一般而言任务框架会提供如下的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式。Job不会受限于单机，可以由集群来提供运行支持，可以随着压力的上升进行集群扩容，任何一台机器的宕机不会成为问题。如果我们采用中间件方式的话，这个功能由底层的中间件来支持了。&lt;/li&gt;
&lt;li&gt;API层面提供丰富的Job执行方式。比如任务式的Job，拉数据和处理分开的Job。拉数据和处理分开的话，我们可以对数据的处理进行分片执行，实现类似Map-Reduce的效果。&lt;/li&gt;
&lt;li&gt;执行依赖。我们可以配置Job的依赖关系实现自动化的Job执行流程分析。业务只管实现拆散的业务Job，Job的编排通过规则由框架分析出来。&lt;/li&gt;
&lt;li&gt;整合到全链路监控体系的监控跟踪。&lt;/li&gt;
&lt;li&gt;丰富的管理后台，提供统一的执行时间、数据取量配置，提供Job执行状态和依赖分析一览，查看执行历史，运行、暂停、停止Job等等管理功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发布管理其实和开发没有太大的关联，但是我觉得这也是整个体系闭环中的一个环节。发布管理可以使用Jenkins等开源实现，在后期可能还是需要有自己的发布系统。可以基于Jenkins再包一层，也可以如最开始的图所示，直接基于通用的任务调度中间件实现底层的部署。一般而言，发布管理有下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;丰富的任务类型和插件，支持各种语言程序的构建和发布。有最基本的发布、回滚、重启、停止功能。&lt;/li&gt;
&lt;li&gt;支持项目的依赖关系设置，实现自动化的依赖路径上的程序自动发布。&lt;/li&gt;
&lt;li&gt;一些运维层面的控制。比如和CMDB结合做权限控制，做发布窗口控制。&lt;/li&gt;
&lt;li&gt;用于集群的发布流程。比如可以一览集群的分组，设置自动的灰度发布方案。&lt;/li&gt;
&lt;li&gt;适合自己公司的发布流程。比如在流程控制上，我们是Dev环境到QA到Stage到Live。其中，QA环境经过QA的确认后可以进入Stage环境，经过开发主管的确认后可以到Stage环境，经过产品经理的确认后可以进入Live环境进行发布。在发布系统上我们可以结合OA做好这个流程的控制。&lt;/li&gt;
&lt;li&gt;在构建的时候，集成单元测试，集成编码规范检查等等，在后台可以方便的看到每一次发布的代码变更，测试执行情况以及代码规范违例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Jenkins等系统在对于1和2做的比较好，对于和公司层面其它系统的结合无能力为，往往处于这个原因我们需要在Jenkins之上包装出来自己的发布系统。&lt;/p&gt;

&lt;p&gt;总结一下，之所以标题说不断耕耘的基础中间件，是指中间件也好框架也好，往往也需要一个小团队来独立维护，而且功能是不断迭代增加，这套体系如果结合的好，就不仅仅是实现功能这个最基本的标准了，而是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运维自动化API化和AI化的很重要的构成。把控是因为我们掌握了数据流，数据都是从我们的中间件穿越过去到达底层的服务、数据库、缓存，有了把控就有了自动化的可能，有了智能监控一体化报警的可能。&lt;/li&gt;
&lt;li&gt;也因为数据流的经过，通过对数据进行分析，我们可以给到开发很多建议，我们可以在这上面做很多标准。这些事情都可以由框架架构团队默默去做，不需要业务研发的配合。&lt;/li&gt;
&lt;li&gt;因为底层数据源的屏蔽，加上服务框架一起，我们实现的是业务系统被框架包围而不是业务系统在使用框架和中间件这么一个形态，那么对于公司层面的一些大型架构改造，比如多活架构，我们可以实现业务系统的改造最小。数据+服务+流程都已经被中间件所包围和感知，业务系统只是在实现业务功能而已，我们可以在业务系统无感知的情况下对数据做动态路由，对服务做动态调用，对流程做动态控制。如下图，是不是有点Mesh的意思？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/103060/201809/103060-20180915202505830-883895301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文很多地方基于思考和YY，开源组件要实现这个理念需要有大量的修改和整合，很多大公司内部都一定程度做了这些事情，但是也因为框架的各种粘连依赖无法彻底开源，这块工作要做好需要大量的时间精力，真的需要不断耕耘和沉淀才能发展出适合自己公司技术栈的各种中间件和管理系统体系。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Sep 2018 12:25:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 朱晔的互联网架构实践心得S1E5：不断耕耘的基础中间件 【下载本文PDF进行阅读】 一般而言中间件和框架的区别是，中间件是独立运行的用于处理某项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/9652134.html</dc:identifier>
</item>
</channel>
</rss>