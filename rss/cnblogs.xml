<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python之文件读写详解 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/8531588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/8531588.html</guid>
<description>&lt;h2 id=&quot;打开文件&quot;&gt;打开文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;函数open()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li&gt;
&lt;p&gt;file：文件路径&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mode: 文件的读写方式，默认‘r’，只读方式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;buffering：设置缓冲策略，0用于二进制文件，1为行缓冲，用于文本模式；默认二进制文件固定大小缓冲，文本文件行缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;encoding：设置编码，默认utf-8;该参数不能用于二进制模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;errors：设置怎么处理文件的编码异常，默认strict,发生错误抛出异常；设置ignore忽略编码异常，可能导致数据丢失，这个参数不能用于二进制模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;newline：设置换行符，默认换行符为'\n','\r','\r\n',写入文件的时候，所有文本中的上述三种都会转换成'\n'换行符；当设置为''时，也启用默认模式；如果设置其它合法值，则使用其他值，一般不用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;closefd=True ：设置文件描述符的状态，当为False时，文件关闭但描述符不关闭，但是打开文件时指定了文件名，那么设置False不会起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件打开方式&quot;&gt;文件打开方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;r:  以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
w:  打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a:  打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
x:  创建一个新文件，将其打开并编写；如果文件已经存在报错；
rb: 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
wb: 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
ab: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
r+: 打开一个文件用于读写。文件指针将会放在文件的开头。
w+: 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a+: 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
rb+:以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
wb+:以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
ab+:以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关闭文件&quot;&gt;关闭文件&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;file&lt;/span&gt;)
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于文件每次打开都需要调用Close函数关闭，可以使用上下文管理器管理文件，其会自动在适当的时候关闭文件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
    f.read()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;文件普通读写&quot;&gt;文件普通读写&lt;/h2&gt;
&lt;p&gt;方法一：read()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(filename) as f:
    f.read()  # 一次性读取全部，在大文件这是不可取的
    f.read(5) # 读取5个字节，如果使用UTF-8编码，5表示5个汉字，也表示5个字母。
    f.read(6) # 同一个f对象，多次读取时在上一次的基础上继续往下，如果超过则有多少读多少&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：readline()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(filename) as f:
    f.readline()  # 按行来读取，每次返回一行，
    f.readline()  # 多次读取在上一行的基础上往下，换行符也会被读取&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法三：readlines()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(filename) as f:
    t = f.readlines()  # 按行读取全部的内容作为一个列表返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法一：write()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(filename,'w',encoding='utf-8') as f:
    t = f.write('ddd') # 将内容写入，必须是字符串格式，不可以是数字，返回的是字符串的个数，包括了换行符\r\n占两个字符（windows）,占一个字符\n(linux)。
    t = f.write('aaa') # 多次写入在原来的基础上继续写入&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：writelines()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(filename,'w',encoding='utf-8') as f:
    f.writelines(['aa','bb'])  # 该方法自动将列表元素拼接起来写入文件，参数时一个可迭代对象，列表、字典、集合都可以
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;writeable()可以判断打开的文件对象f究竟是可读的还是可写的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;f.write(123) 这种是不被允许的，必须转化成二进制或字符串；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;open(filename,'rb',encoding='utf-8') : 以二进制格式打开文件是不能指定编码的，否则报错&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;以二进制格式打开文件，写入的必须是字节文件，同时写入返回的是字节数；以文本模式打开，写入的必须是文本，同时返回的是字符串个数；一个汉字字符串占3个字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;普通字符串转化为字节文件的方法：&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;b'123adf':这种方法只能针对数字和字母，默认使用ascii编码，不能转化汉字；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;'123adf'.encode('utf-8):可以转化字母和汉字；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;bytes('我的',encoding='utf-8'):可以转化字母和汉字,但必须 指定编码格式；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;文件的定位读写&quot;&gt;文件的定位读写&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;tell():获取文件指针的位置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename,&lt;span class=&quot;st&quot;&gt;'r'&lt;/span&gt;,encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
    f.read(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.tell()  &lt;span class=&quot;co&quot;&gt;# 获取指针的位置,返回3，如果读取到换行符，换行符在windows占两个字节&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;seek(offset,from):设置指针的位置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;offset:偏移量，设置负数表示向前偏移，正数表示向后偏移，一个汉字占3个字节，字母占一个字节&lt;/li&gt;
&lt;li&gt;from:偏移的方向&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;0:表示文件开头
1:表示当前位置
2:表示文件末尾&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename,&lt;span class=&quot;st&quot;&gt;'r'&lt;/span&gt;,encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
    f.read(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.seek(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 返回指针定位后的实际位置，默认偏移方向从文件开头算起&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在文本模式下打开文件，偏移方向只能从文件开头算起，参数from只能为0，这是因为文本模式涉及到编码的问题，以二进制格式打开文件就可以设置不同的方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每次打开文件，读操作的指针都是在文件的开头，写操作的指针在文件的末尾，直到文件被关闭；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;几个经典的案例&quot;&gt;几个经典的案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;文件同时读写的情况&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'r+'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 当前指针的位置在开头0&lt;/span&gt;
        a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.read(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 指针到了位置3&lt;/span&gt;
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(a)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())
        h &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.write(&lt;span class=&quot;st&quot;&gt;'hhh'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 从文件的末尾写入，相当于追加数据&lt;/span&gt;
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(h)
        c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.tell()  &lt;span class=&quot;co&quot;&gt;# 指针在文件的末尾&lt;/span&gt;
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(c)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read())  &lt;span class=&quot;co&quot;&gt;# 读取从位置3到文件原来的末尾的数据&lt;/span&gt;
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 当前位置在新的文件末尾和c相同&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;总结：r+模式下，如果同一个文件对象需要读和写，读和写各有一个指针，它们是相互独立的，读写位置各不干扰；但是tell函数获取到的位置优先表示写的位置；即当程序执行时，如果只有读，tell获取的位置是读的位置；如果出现了写，tell获取的位置就一定是写的位置了，无论后面还有没有更多的读操作；同理其他的模式也一样；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;文件同时读写存在偏移的情况&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'r+'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 当前读指针的位置在开头0,写指针还未初始化&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# 读指针到了位置3&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 获取到读指针的位置为3&lt;/span&gt;
    f.seek(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 指针偏移到文件的开头,只能影响一个指针&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# 读指针到了位置3&lt;/span&gt;
    h &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.write(&lt;span class=&quot;st&quot;&gt;'gggg'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 增加一个文件描述符，写指针初始化到文件的末尾，写入数据&lt;/span&gt;
    j &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.tell()  &lt;span class=&quot;co&quot;&gt;# 获取写的位置优先，写指针在文件末尾&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(j)
    f.seek(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 指针偏移到文件的开头，读文件的数据更新，加入了写入的数据&lt;/span&gt;
    j &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.tell()  &lt;span class=&quot;co&quot;&gt;# 获取写指针在文件的开头&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(j)
    h &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.write(&lt;span class=&quot;st&quot;&gt;'vvvv'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 从文件开头写入数据，覆盖原来的数据&lt;/span&gt;
    c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.tell()  &lt;span class=&quot;co&quot;&gt;# 获取写指针在文件的位置4&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(c)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# 读取从位置4往后的4个字符&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 读指针在文件8位置&lt;/span&gt;
    h &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f.write(&lt;span class=&quot;st&quot;&gt;'xxx'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 从文件的末尾写入，相当于追加数据&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.tell())  &lt;span class=&quot;co&quot;&gt;# 当前位置在新的文件末尾&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f.read())  &lt;span class=&quot;co&quot;&gt;# 从8位置读取所有的数据&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;seek()函数只能影响它下面的第一次的读写操作；并且会将上一次写入的数据更新到读缓冲区中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在r+模式下，write()总是从文件的末尾写入，除非受seek函数的影响；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;write()操作被偏移影响后,其后的read操作的指针会被移到write操作的位置；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;文件同时读写存在且存在更新的情况&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'r+'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
        f.read()
        f.seek(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 定位到到文件的开头往右2的位置&lt;/span&gt;
        f.truncate()  &lt;span class=&quot;co&quot;&gt;# 将2位置后所有的数据删除&lt;/span&gt;
        f.write(&lt;span class=&quot;st&quot;&gt;'aaa'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 写入新的数据&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;truncate()：动态删除数据，从当前指针删除后面所有的数据&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他方法&quot;&gt;其他方法&lt;/h2&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;flush():刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入,一般close()函数时先调用flush(),然后再关闭文件描述符。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;fileno:返回一个整型的文件描述符,很少用到；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isatty()：文件是否连接到一个终端的设备；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;truncate()：文件截取，无参数时从当前的指针位置删除后面所有；有参数时从首行首字母截取数据留下来，其余的删除；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 08 Mar 2018 15:41:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/8531588.html</dc:identifier>
</item>
<item>
<title>How to verify Certificate Pinning? - Pieces0310</title>
<link>http://www.cnblogs.com/pieces0310/p/8531567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pieces0310/p/8531567.html</guid>
<description>&lt;p&gt;&lt;span&gt;Some friends of mine they worry about the risk of Man-in-the-middle so they ask me how to verify the potential risk of some Apps.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Take a popular shopping app “X” for example, If “X” does not meet the requirement of  “Certificate Pinning”,  we could definitely use proxy tool like Burp Suite to intercept any confidential between mobile device and servers.&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Run Burp Suite on my laptop and my laptop becomes a proxy server. (Don’t foreget to change policy of firewall to allow connection to its proxy server listening port.)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Download Certificate from Burp Suite and install this cert file into my mobile phone.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Setup the proxy server ip and port in my mobile phone’s wifi settings.(Of course the ip is my laptop’s ip; the port number is the listening port of proxy server on my laptop)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Make sure Burp suite is ready to intercept packets.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Now we could run this app “X” and start to login. Let’s see what data Burp could intercept. To my surprise “nothing” found in intercept tab.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706830/201803/706830-20180308232813631-889826096.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;The “Alert” tab turns orange means something happens. It looks like “X” could meet the requirement of certificate pinning.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706830/201803/706830-20180308232854584-1698878562.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Don’t jump to conclusions too soon. Let’s take a look at account registry. Input some data such as ID, username , password, phone number, e-mail and click “Submit”.  Guess what? Those confidential data being intercepted by Burp suite.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706830/201803/706830-20180308233025074-367121342.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“X” still need to do certificate pinning to avoid the risk of MITM. Now my friends know how to verify certificate pinning by using proxy.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Mar 2018 15:31:00 +0000</pubDate>
<dc:creator>Pieces0310</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pieces0310/p/8531567.html</dc:identifier>
</item>
<item>
<title>8.C++-类的关键字 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8531568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8531568.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;在之前学习的&lt;/span&gt;C++&lt;span&gt;章节里&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可以发现结构体越来越不像&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言里的结构体了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;,&lt;span&gt;里面可以定义函数&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;可以定义&lt;/span&gt;&lt;span&gt;private/public,&lt;/span&gt;&lt;span&gt;结构体名还可以指向父类&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;但是&lt;/span&gt;C++&lt;span&gt;需要兼容&lt;/span&gt;&lt;span&gt;C,&lt;/span&gt;&lt;span&gt;所以&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中便提供了新的关键字&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;用来定义类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关键字&lt;/span&gt;class&lt;span&gt;和&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;用法完全相同&lt;/span&gt;&lt;span&gt;(struct A == class B)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;class&lt;span&gt;与&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;如下图&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;struct&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;所有成员的默认访问级别为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;pubilc&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;class&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;所有成员的默认访问级别为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201803/1182576-20180308232519736-2145040458.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;182&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;在以后的学习里&lt;/span&gt;,&lt;span&gt;就专门使用&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;来定义类了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;接下来做一个类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;小实例&lt;/span&gt;-&lt;span&gt;开发一个用于四则运算的类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-提供&lt;span&gt;setOperator&lt;/span&gt;函数设置运算类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-提供&lt;span&gt;setParameter&lt;/span&gt;函数设置运算参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-提供&lt;span&gt;result&lt;/span&gt;函数进行运算&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;  &lt;span&gt;返回值表示运算的合法性&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;  &lt;span&gt;通过引用参数返回结果&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;通过&lt;/span&gt;operator.h&lt;span&gt;头文件声明类&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;operator.cpp&lt;/span&gt;&lt;span&gt;源文件来实现类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;operator.h&lt;span&gt;文件&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef _OPERATOR_H_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; _OPERATOR_H_

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operator
{
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;   memOp;
  &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; memP1;
  &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; memP2;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; SetOperator(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; Op);
  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetParameter(&lt;span&gt;double&lt;/span&gt; P1,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; P2);
  &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result(&lt;span&gt;double&lt;/span&gt; &amp;amp;&lt;span&gt; val);
};
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;operator.cpp&lt;span&gt;文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operator.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;bool&lt;/span&gt; Operator::SetOperator(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; Op)
{
   &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; err=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Op == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||Op == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||Op == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||Op == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
   {
     memOp&lt;/span&gt;=&lt;span&gt; Op;
     err&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
   }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Operator::SetParameter(&lt;span&gt;double&lt;/span&gt; P1,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; P2)
{
  memP1&lt;/span&gt;=&lt;span&gt;P1;
  memP2&lt;/span&gt;=&lt;span&gt;P2;
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Operator::result(&lt;span&gt;double&lt;/span&gt; &amp;amp;&lt;span&gt; val)
{
  &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; err=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(memOp)
  {
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
  val &lt;/span&gt;= memP1+&lt;span&gt;memP2; 
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
  val &lt;/span&gt;= memP1-&lt;span&gt;memP2;  
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
  val &lt;/span&gt;= memP1*&lt;span&gt;memP2;  
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( (-&lt;span&gt;0.000000001&lt;/span&gt; &amp;lt; memP1) &amp;amp;&amp;amp; (memP2 &amp;lt; &lt;span&gt;0.000000001&lt;/span&gt;&lt;span&gt;) )
    {
          err&lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
      val &lt;/span&gt;= memP1/&lt;span&gt;memP2;
    }
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

  &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
     err&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
  }
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Test.cpp&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operator.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Operator Op;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; val=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;   

    Op.SetOperator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);  
    Op.SetParameter(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Op.result(val))
    {
      printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val=%lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,val);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
     printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CALL ERR\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;编译运行&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201803/1182576-20180308232415260-1915679675.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;C++&lt;span&gt;引进了新的&lt;span&gt;&lt;strong&gt;关键字&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;定义类&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;struct&lt;span&gt;和&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;区别在于&lt;span&gt;&lt;strong&gt;默认访问级别&lt;/strong&gt;&lt;/span&gt;不同&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 08 Mar 2018 15:31:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8531568.html</dc:identifier>
</item>
<item>
<title>iOS - Mac 常用设置 - QianChia</title>
<link>http://www.cnblogs.com/QianChia/p/8531519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianChia/p/8531519.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;方法一：
        
  在 “终端” 中输入下面的命令：
        
    显示：
      $ chflags nohidden ~/Library/
        
    隐藏：
      $ chflags hidden ~/Library/
        
方法二：
        
  打开 Finder，菜单中选择前往按住 option 键就会显示资源库项（每次打开都需要重复操作一次）。
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;在 “终端” 中输入下面的命令：
        
  显示隐藏文件：
    $ defaults write com.apple.finder AppleShowAllFiles -bool true
    或
    $ defaults write com.apple.finder AppleShowAllFiles -bool YES
        
    $ killall Finder      输入这条命令，使得修改立即生效
        
  隐藏隐藏文件：
    $ defaults write com.apple.finder AppleShowAllFiles -bool false
    或
    $ defaults write com.apple.finder AppleShowAllFiles -bool NO
        
    $ killall Finder      输入这条命令，使得修改立即生效
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;在 “终端” 中输入下面的命令：
        
  显示：
    $ defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES
                        
    $ killall Finder      输入这条命令，使得修改立即生效
        
  隐藏：
    $ defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO
        
    $ killall Finder      输入这条命令，使得修改立即生效
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;在 “终端” 中输入下面的命令：

  $ sudo ~/Library/uninstall-devtools –mode=all
        
  ~ 为实际安装的目录，默认情况下 Xcode 安装在 /Developer 目录下，即可执行
  $ sudo /Developer/Library/uninstall-devtools –mode=all
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Safari 是默认支持标签浏览的。但是，我们在页面上点击链接或者在其他应用程序中点击链接的时候，Safari 往往是打开了一个新的窗口，导致页面上的 Safari 窗口过多，不好管理。通过下面这个小窍门，我们可以让 Safari 默认是在一个新标签中打开网页。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在 “终端” 中输入下面的命令：

  $ defaults write com.apple.Safari TargetedClicksCreateTabs -bool true
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;对窗口进行截屏的时候（command-shift-4, 空格），得到的图片周围会自动被加上一圈阴影。如果你不喜欢这个阴影的效果，可以把它关掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在 “终端” 中输入下面的命令：

  去掉阴影：
    $ defaults write com.apple.screencapture disable-shadow -bool true

    $ killall SystemUIServer      输入这条命令，使得修改立即生效

  加上阴影：
    $ defaults write com.apple.screencapture disable-shadow -bool false

    $ killall SystemUIServer      输入这条命令，使得修改立即生效
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;macOS 提供了非常方便的截屏快捷键，可以让我们非常快速的对整个屏幕、部分屏幕或者应用程序窗口进行截屏。不过，这个截屏功能有一个不足之处，就是只能将截屏图片保存到桌面。如果我们截取的图片特别多，就会让桌面显得特别凌乱。那有没有办法来修改截屏图片的默认保存位置呢？有。方法非常简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;修改保存位置：

  在 “终端” 中输入下面的命令：
    $ defaults write com.apple.screencapture location 存放位置

      在输入命令的时候，将 “存放位置” 替换成真正的文件夹就可以了。
      例如，你希望存放到自己用户目录的 ScreenShots 文件夹下，就输入
      $ defaults write com.apple.screencapture location ~/Pictures/ScreenShots/

    $ killall SystemUIServer      输入这条命令，使得修改立即生效

  恢复系统默认设置：
    $ defaults delete com.apple.screencapture location

修改图片格式：

    macOS 系统默认截图文件格式为 png，通过下面的终端（Terminal）命令可以修改截图文件格式为 jpg ：
    $ defaults write com.apple.screencapture type jpg

    $ killall SystemUIServer        输入这条命令，使得修改立即生效

    另外，还可以将命令中的 jpg 修改为 gif 或 pdf，以及改回默认的 png 格式。
    同样别忘了输入上面那条使得修改生效的命令。
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果用户要离开电脑一段时间，可以选择直接把笔记本直接合上。但是这样原先在跑的进程就会挂起或者结束，如果正在下载，那么下载就被暂停（有时还不能恢复），如果正在提供网络服务，那么因为网络断了，别人也连不上你的笔记本。锁屏可以解决这个问题，在 Windows 下用 Win+L 快捷键就锁屏了，但 Mac OS X 下一直没有默认的快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;macOS 默认锁屏快捷键&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;control + shift + Eject
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义锁屏快捷键&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;1）方法一&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1&amp;gt; Finder –&amp;gt; 应用程序 –&amp;gt; 实用工具 –&amp;gt; 钥匙串访问，或者点击 Mac 屏幕右上角的放大镜按钮 Spotlight 搜索“钥匙串”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2&amp;gt; 点击 Mac 顶部菜单栏的 “钥匙串访问”，选择 “偏好设置”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3&amp;gt; 勾选第一项 “在菜单栏中显示钥匙串状态”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;4&amp;gt; Mac 顶部菜单栏会多出一个锁图标，想锁屏的时候点击选择第一项 “锁定屏幕”。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;上述的方法实现了锁屏，但还没能达到快捷键控制锁屏的目标。虽然如此，但它的效果给我们一个锁屏思路。首先，我们要求屏幕保护程序在恢复时必须输入密码，然后锁屏问题就变成启动 屏幕保护程序的问题了。Lock the screen via a keyboard shortcut 这篇文章叙述了具体的实施方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一步，找到 “系统偏好设置” 下的 “安全性与隐私”，在 “通用” 页里勾上 “进入睡眠或开始屏幕保护程序后立即要求输入密码”。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二步，要用快捷键启动屏幕保护程序，相对复杂一点。在 “应用程序” 里找到 “Automator”。新建一个服务，在 “操作” 下的 “实用工具” 里找到 “启动屏幕保护程序”，并把此操作拖动到右边，并且选择 “没有输入” 和位于 “任何应用程序”，如下图所示。然后把服务保存为自己定义的名字。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三步：在 “系统偏好设置” 里找到 “键盘”，然后为刚才定义的服务配置快捷键，我设成了 command + control + l 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2）方法二&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1&amp;gt; Finder –&amp;gt; 应用程序 –&amp;gt; 实用工具 –&amp;gt; 钥匙串访问，或者点击 Mac 屏幕右上角的放大镜按钮 Spotlight 搜索“钥匙串”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2&amp;gt; 点击 Mac 顶部菜单栏的 “钥匙串访问”，选择 “偏好设置”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3&amp;gt; 勾选第一项 “在菜单栏中显示钥匙串状态”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;4&amp;gt; Mac 顶部菜单栏会多出一个锁图标，想锁屏的时候点击选择第一项 “锁定屏幕”。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一步：点击左上角苹角 LOGO 找到 系统偏好设置 –&amp;gt; 安全与隐私 –&amp;gt; 通用 –&amp;gt; 把屏保勾起来，选立即；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二步：桌面与屏幕保护程序 –&amp;gt; 点屏幕保护程度 –&amp;gt; 触发角；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三步：在点击触发角后 –&amp;gt; 出现活跃的屏幕角 –&amp;gt; 点左下角下拉菜单（任意4角都行） –&amp;gt; 启动屏幕保护程序 –&amp;gt; 好；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第四步：把窗口关了，把鼠标拉到左下角（如活跃角设置其他角，就放到对应角）稍等 1 秒等！就完成锁屏咯。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 08 Mar 2018 15:20:00 +0000</pubDate>
<dc:creator>QianChia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianChia/p/8531519.html</dc:identifier>
</item>
<item>
<title>前端综合学习笔记---变量类型、原型链、作用域和闭包 - 叶落偏执</title>
<link>http://www.cnblogs.com/yuanziwen/p/8531498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanziwen/p/8531498.html</guid>
<description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;&lt;span&gt;变量类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ECMAScript 中定义了 6 种原始类型：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Boolean&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;String&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Number&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Null&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Undefined&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Symbol（ES6 新定义）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意：原始类型不包含 Object。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一问：类型判断用到哪些方法？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;typeof xxx&lt;/code&gt;&lt;/span&gt;得到的值有以下几种类型：&lt;span&gt;&lt;code&gt;undefined、&lt;/code&gt;&lt;code&gt;boolean、&lt;/code&gt;&lt;code&gt;number、s&lt;/code&gt;&lt;code&gt;tring、&lt;/code&gt;&lt;code&gt;object、&lt;/code&gt;&lt;code&gt;function&lt;/code&gt;、&lt;code&gt;symbol&lt;/code&gt;&lt;/span&gt; ，比较简单。这里需要注意的有三点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;typeof null&lt;/span&gt;结果是&lt;span&gt;object&lt;/span&gt; ，实际这是&lt;span&gt;typeof&lt;/span&gt;的一个bug，&lt;span&gt;null&lt;/span&gt;是原始值，非引用类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;typeof [1, 2]&lt;/span&gt;结果是&lt;span&gt;object&lt;/span&gt;，结果中没有&lt;span&gt;array&lt;/span&gt;这一项，引用类型除了&lt;span&gt;function&lt;/span&gt;其他的全部都是object &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;typeof Symbol()&lt;/span&gt;用&lt;span&gt;typeof&lt;/span&gt;获取&lt;span&gt;symbol&lt;/span&gt;类型的值得到的是&lt;span&gt;symbol&lt;/span&gt;，这是 ES6 新增的知识点&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;&lt;span&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用于实例和构造函数的对应。例如判断一个变量是否是数组，使用&lt;code&gt;typeof&lt;/code&gt;无法判断，但可以使用&lt;code&gt;[1, 2] &lt;span&gt;instanceof Array&lt;/span&gt;&lt;/code&gt;来判断。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;因为，&lt;code&gt;[1, 2]&lt;/code&gt;是数组，它的构造函数就是&lt;span&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/span&gt;。同理：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Foo(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;new&lt;/span&gt; Foo('bar'&lt;span&gt;)
console.log(foo &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt; Foo) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二问：值类型和引用类型的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;&lt;span&gt;　　值类型 vs 引用类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 除了原始类型，ES 还有引用类型，上文提到的&lt;span&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/span&gt;识别出来的类型中，只有&lt;span&gt;&lt;code&gt;object&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;function&lt;/code&gt;&lt;/span&gt;是引用类型，其他都是值类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据 JavaScript 中的变量类型传递方式，又分为值类型和引用类型，值类型变量包括 &lt;span&gt;Boolean、String、Number、Undefined、Null&lt;/span&gt;，引用类型包括了 &lt;span&gt;Object&lt;/span&gt; 类的所有，如 &lt;span&gt;Date、Array、Function&lt;/span&gt; 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值类型&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 10
&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a
b &lt;/span&gt;= 20&lt;span&gt;
console.log(a)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;
console.log(b)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码中，&lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt;都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用类型&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = {x: 10, y: 20&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a
b.x &lt;/span&gt;= 100&lt;span&gt;
b.y &lt;/span&gt;= 200&lt;span&gt;
console.log(a)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {x: 100, y: 200}&lt;/span&gt;
console.log(b)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {x: 100, y: 200}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码中，&lt;span&gt;&lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt;&lt;/span&gt;都是引用类型。在执行了&lt;span&gt;&lt;code&gt;b = a&lt;/code&gt;&lt;/span&gt;之后，修改&lt;code&gt;b&lt;/code&gt;的属性值，&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;的也跟着变化。因为&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;修改属性时，&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;的值随之改动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再借助题目进一步讲解一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说出下面代码的执行结果，并分析其原因。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
    a &lt;/span&gt;= a * 10&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(b){
    b.value &lt;/span&gt;= 'new'&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = {value: 'old'&lt;span&gt;};
foo(a);
bar(b);
console.log(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
console.log(b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; value: new&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过代码执行，会发现：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;的值没有发生改变&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;而&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;的值发生了改变&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这就是因为&lt;span&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/span&gt;类型的&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;是按值传递的，而&lt;span&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/span&gt;类型的&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;是按共享传递的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    a: &lt;/span&gt;1&lt;span&gt;,
    b: [&lt;/span&gt;1,2,3&lt;span&gt;]
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; obj.a
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; obj.b
a &lt;/span&gt;= 2&lt;span&gt;
b.push(&lt;/span&gt;4&lt;span&gt;)
console.log(obj, a, b)//{a:1,b:[1,2,3,4]},2,[1,2,3,4]&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;虽然&lt;span&gt;&lt;code&gt;obj&lt;/code&gt;&lt;/span&gt;本身是个引用类型的变量（对象），但是内部的&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;一个是值类型一个是引用类型，&lt;span&gt;&lt;code&gt;a&lt;/code&gt;&lt;/span&gt;的赋值不会改变&lt;span&gt;&lt;code&gt;obj.a&lt;/code&gt;&lt;/span&gt;，但是&lt;span&gt;&lt;code&gt;b&lt;/code&gt;&lt;/span&gt;的操作却会反映到&lt;span&gt;&lt;code&gt;obj&lt;/code&gt;&lt;/span&gt;对象上。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;&lt;span&gt;原型和原型链&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三问：如何理解 JavaScript 的原型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这个问题，可以从下面这几个要点来理解和回答，&lt;strong&gt;下面几条必须记住并且理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（&lt;code&gt;null&lt;/code&gt;除外）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有的引用类型（数组、对象、函数），都有一个&lt;code&gt;__proto__&lt;/code&gt;属性，属性值是一个普通的对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有的的函数，都有一个&lt;code&gt;prototype&lt;/code&gt;属性，属性值也是一个普通的对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所有的的引用类型（数组、对象、函数），&lt;code&gt;__proto__&lt;/code&gt;属性值指向它的构造函数的&lt;code&gt;prototype&lt;/code&gt;属性值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过代码解释一下，大家可自行运行以下代码，看结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要点一：自由扩展属性&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; obj = {}; obj.a = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = []; arr.a = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn () {}
fn.a &lt;/span&gt;= 100&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要点二：__proto__&lt;/span&gt;
&lt;span&gt;console.log(obj.__proto__);
console.log(arr.__proto__);
console.log(fn.__proto__);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要点三：函数有 prototype&lt;/span&gt;
&lt;span&gt;console.log(fn.prototype)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值&lt;/span&gt;
console.log(obj.__proto__ ===&lt;span&gt; Object.prototype)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;&lt;span&gt;原型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先写一个简单的代码示例。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
&lt;span&gt;// 构造函数
function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function () {
    alert(this.name)
}
// 创建示例
var f = new Foo('zhangsan')
f.printName = function () {
    console.log(this.name)
}
// 测试
f.printName()
f.alertName()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　执行&lt;span&gt;printName&lt;/span&gt;时很好理解，但是执行&lt;span&gt;alertName&lt;/span&gt;时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身&lt;span&gt;没有&lt;/span&gt;这个属性，那么会去它的&lt;span&gt;__proto__&lt;/span&gt;（即它的构造函数的&lt;span&gt;prototype&lt;/span&gt;）中寻找，因此&lt;span&gt;f.alertName&lt;/span&gt;就会找到&lt;span&gt;Foo.prototype.alertName&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如何判断这个属性是不是对象本身的属性呢？使用&lt;span&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/span&gt;，常用的地方是遍历一个对象的时候。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
&lt;span&gt;var item
for (item in f) {
    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性
    if (f.hasOwnProperty(item)) {
        console.log(item)
    }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;第四问：如何理解 JS 的原型链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;还是接着上面的示例，如果执行&lt;code&gt;f.toString()&lt;/code&gt;时，又发生了什么？&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略 N 行&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;
&lt;span&gt;f.printName()
f.alertName()
f.toString()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为f本身没有&lt;span&gt;toString()&lt;/span&gt;，并且&lt;span&gt;f.__proto__&lt;/span&gt;（即&lt;span&gt;Foo.prototype&lt;/span&gt;）中也没有&lt;span&gt;toString&lt;/span&gt;。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的&lt;span&gt;__proto__&lt;/span&gt;（即它的构造函数的&lt;span&gt;prototype&lt;/span&gt;）中寻找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在&lt;span&gt;&lt;code&gt;f.__proto__&lt;/code&gt;&lt;/span&gt;中没有找到&lt;span&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/span&gt;，那么就继续去&lt;span&gt;&lt;code&gt;f.__proto__.__proto__&lt;/code&gt;&lt;/span&gt;中寻找，因为&lt;span&gt;&lt;code&gt;f.__proto__&lt;/code&gt;&lt;/span&gt;就是一个普通的对象而已嘛！&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;f.__proto__&lt;/span&gt;即&lt;span&gt;Foo.prototype&lt;/span&gt;，没有找到&lt;span&gt;toString&lt;/span&gt;，继续往上找&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;f.__proto__.__proto_&lt;/span&gt;_即&lt;span&gt;Foo.prototype.__proto__&lt;span&gt;，&lt;/span&gt;Foo.prototype&lt;/span&gt;就是一个普通的对象，因此&lt;span&gt;Foo.prototype.__proto__&lt;/span&gt;就是&lt;span&gt;Object.prototype&lt;/span&gt;，在这里可以找到&lt;span&gt;toString&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;因此&lt;span&gt;f.toString&lt;/span&gt;最终对应到了&lt;span&gt;Object.prototype.toString&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回&lt;span&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/span&gt;。最上层是什么 ——&lt;span&gt; &lt;code&gt;Object.prototype.__proto__ === null&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;&lt;span&gt;原型链中的&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 所有从原型或更高级原型中得到、执行的方法，其中的&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;在执行时，就指向了当前这个触发事件执行的对象。因此&lt;span&gt;&lt;code&gt;printName&lt;/code&gt;&lt;/span&gt;和&lt;span&gt;&lt;code&gt;alertName&lt;/code&gt;&lt;/span&gt;中的&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;都是&lt;span&gt;&lt;code&gt;f&lt;/code&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;&lt;span&gt;作用域和闭包&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五问：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就&lt;code&gt;alert&lt;/code&gt;弹出其编号；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;编号1，点击我请弹出1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般不知道这个题目用闭包的话，会写出下面的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; list = document.getElementsByTagName('li'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {
    list[i].addEventListener(&lt;/span&gt;'click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        alert(i &lt;/span&gt;+ 1&lt;span&gt;)
    }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;实际上执行才会发现始终弹出的是&lt;code&gt;6&lt;/code&gt;，这时候就应该通过闭包来解决：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; list = document.getElementsByTagName('li'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {

    list[i].addEventListener(&lt;/span&gt;'click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            alert(i &lt;/span&gt;+ 1&lt;span&gt;)
        }
    }(i), &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;要理解闭包，就需要我们从「执行上下文」开始讲起。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-11&quot;&gt;&lt;span&gt;执行上下文&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个在我另一篇文章里讲过  &lt;a title=&quot;JavaScript作用域&quot; href=&quot;http://www.cnblogs.com/yuanziwen/p/7074580.html&quot; target=&quot;_blank&quot;&gt;点击链接&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先讲一个关于 变量提升 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第六问：说出下面执行的结果（这里我就直接注释输出了）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(a)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 100&lt;span&gt;

fn(&lt;/span&gt;'zhangsan')  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'zhangsan' 20&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(name) {
    age &lt;/span&gt;= 20&lt;span&gt;
    console.log(name, age)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; age
}

console.log(b); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里报错&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Uncaught ReferenceError: b is not defined&lt;/span&gt;
b = 100;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在一段 JS 脚本（即一个&lt;span&gt;&amp;lt;script&amp;gt;&lt;/span&gt;标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为&lt;span&gt;undefined&lt;/span&gt;，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看下上面的面试小题目，为什么&lt;span&gt;a&lt;/span&gt;是&lt;span&gt;undefined&lt;/span&gt;，而b却报错了，实际 &lt;span&gt;JS&lt;/span&gt; 在代码执行之前，要「全文解析」，发现&lt;span&gt;var a&lt;/span&gt;，知道有个&lt;span&gt;a&lt;/span&gt;的变量，存入了执行上下文，而&lt;span&gt;b&lt;/span&gt;没有找到&lt;span&gt;var&lt;/span&gt;关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的&lt;span&gt;a&lt;/span&gt;是有记录的，只不过值暂时还没有赋值，即为&lt;span&gt;undefined&lt;/span&gt;，而b在执行上下文没有找到，自然会报错（没有找到&lt;span&gt;b&lt;/span&gt;的引用）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，一个函数在执行之前，也会创建一个 函数执行上下文 环境，跟 全局上下文 差不多，不过函数执行上下文 中会多出&lt;span&gt;&lt;code&gt;this&lt;/code&gt; &lt;code&gt;arguments&lt;/code&gt;和函数的参数。参数和&lt;/span&gt;&lt;code&gt;&lt;span&gt;argu&lt;/span&gt;ments&lt;/code&gt;好理解，这里的&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;咱们需要专门讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结一下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;范围：一段&lt;span&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/span&gt;、&lt;span&gt;js&lt;/span&gt; 文件或者一个函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全局上下文：变量定义，函数声明&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数上下文：变量定义，函数声明，&lt;code&gt;this&lt;/code&gt;，&lt;code&gt;arguments。&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-12&quot;&gt;&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先搞明白一个很重要的概念 —— &lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; {
    name: &lt;/span&gt;'A'&lt;span&gt;,
    fn: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name)
    }
}
a.fn()  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this === a&lt;/span&gt;
a.fn.call({name: 'B'})  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this === {name: 'B'}&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fn1 =&lt;span&gt; a.fn
fn1()  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this === window&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;this&lt;/code&gt;&lt;/span&gt;执行会有不同，主要集中在这几个场景中&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作为构造函数执行，构造函数中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;作为对象属性执行，上述代码中&lt;span&gt;&lt;code&gt;a.fn()&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;作为普通函数执行，上述代码中&lt;span&gt;&lt;code&gt;fn1()&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用于&lt;span&gt;&lt;code&gt;call &lt;/code&gt;&lt;code&gt;apply &lt;/code&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/span&gt;，上述代码中&lt;span&gt;&lt;code&gt;a.fn.call({name: 'B'})&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第七问：如何理解 JS 的作用域和作用域链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-13&quot;&gt;&lt;span&gt;作用域&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ES6 之前 JS 没有块级作用域。例如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'zhangsan'&lt;span&gt;
}
console.log(name)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的&lt;span&gt;&lt;code&gt;name&lt;/code&gt;&lt;/span&gt;就被暴露出去了，因此，JS 没有块级作用域，只有&lt;span&gt;全局作用域&lt;/span&gt;和&lt;span&gt;函数作用域&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = 100
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 200&lt;span&gt;
    console.log(&lt;/span&gt;'fn'&lt;span&gt;, a)
}
console.log(&lt;/span&gt;'global'&lt;span&gt;, a)
fn()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;全局作用域就是最外层的作用域&lt;/span&gt;，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 张三写的代码中&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; data = {a: 100&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 李四写的代码中&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; data = {x: &lt;span&gt;true&lt;/span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这就是为何 &lt;span&gt;jQuery&lt;/span&gt;、&lt;span&gt;Zepto&lt;/span&gt; 等库的源码，所有的代码都会放在&lt;span&gt;(function(){....})())&lt;/span&gt;中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;附：ES6 中开始加入了块级作用域，使用let定义变量即可，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    let name &lt;/span&gt;= 'zhangsan'&lt;span&gt;
}
console.log(name)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 报错，因为let定义的name是在if这个块级作用域&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-14&quot;&gt;&lt;span&gt;作用域链&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先认识一下什么叫做 自由变量 。如下代码中，&lt;code&gt;console.log(a)&lt;/code&gt;要得到&lt;code&gt;a&lt;/code&gt;变量，但是在当前的作用域中没有定义&lt;code&gt;a&lt;/code&gt;（可对比一下&lt;code&gt;b&lt;/code&gt;）。当前作用域没有定义的变量，这成为 自由变量 。自由变量如何得到 —— 向父级作用域寻找。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = 100
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = 200&lt;span&gt;
    console.log(a)
    console.log(b)
}
fn()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; a = 100
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F1() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = 200
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F2() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = 300&lt;span&gt;
        console.log(a) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自由变量，顺作用域链向父作用域找&lt;/span&gt;
        console.log(b) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自由变量，顺作用域链向父作用域找&lt;/span&gt;
        console.log(c) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本作用域的变量&lt;/span&gt;
&lt;span&gt;    }
    F2()
}
F1()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-15&quot;&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;讲完这些内容，我们再来看一个例子，通过例子来理解闭包。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F1() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 100
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(a)
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f1 =&lt;span&gt; F1()
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 200&lt;span&gt;
f1()　　//100&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自由变量将从作用域链中去寻找，但是 依据的是函数定义时的作用域链，而不是函数执行时，以上这个例子就是闭包。闭包主要有两个应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;函数作为返回值，上面的例子就是&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数作为参数传递，看以下例子&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F1() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 100
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(a)
    }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; F2(f1) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 200&lt;span&gt;
    console.log(f1())
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; f1 =&lt;span&gt; F1()
F2(f1)  //100&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，对应着「作用域和闭包」这部分一开始的点击弹出&lt;code&gt;alert&lt;/code&gt;的代码再看闭包，就很好理解了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Mar 2018 15:17:00 +0000</pubDate>
<dc:creator>叶落偏执</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanziwen/p/8531498.html</dc:identifier>
</item>
<item>
<title>oracle的下载地址以及步骤 - young柠檬味</title>
<link>http://www.cnblogs.com/jiliangqian/p/8531494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiliangqian/p/8531494.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、下载地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.oracle官网：https://www.oracle.com/cn/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;img src=&quot;https://images2018.cnblogs.com/blog/891568/201803/891568-20180308230914410-620526291.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;216&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;点击右上角先选择语音，然后注册一个新账户，如果有oracle直接登录就可以&lt;/p&gt;
&lt;p&gt;3.点击左边的菜单按钮，选择“下载和试用”——“数据库”——“Oracle数据库”&lt;/p&gt;
&lt;p&gt;4.&lt;img src=&quot;https://images2018.cnblogs.com/blog/891568/201803/891568-20180308231310351-1250964761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择与自己电脑相匹配的版本然后点击select all进入下载页面&lt;/p&gt;
&lt;p&gt;5.进入后首先选择“接受协议”&lt;img src=&quot;https://images2018.cnblogs.com/blog/891568/201803/891568-20180308231416449-701649403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后将&lt;img src=&quot;https://images2018.cnblogs.com/blog/891568/201803/891568-20180308231447676-305161122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这2个全部下载，之后会用到的。&lt;/p&gt;

&lt;p&gt;这样就下载好了Oracle 11g数据库的安装包。&lt;/p&gt;

</description>
<pubDate>Thu, 08 Mar 2018 15:16:00 +0000</pubDate>
<dc:creator>young柠檬味</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiliangqian/p/8531494.html</dc:identifier>
</item>
<item>
<title>麻省理工18年春软件构造课程阅读04“代码评审” - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8531425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8531425.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文内容来自&lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/&quot;&gt;MIT_6.031_sp18: Software Construction&lt;/a&gt;课程的Readings部分，采用&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt;协议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们学校（哈工大）大二软件构造课程的大部分素材取自此，也是推荐的阅读材料之一，于是打算做一些翻译工作，自己学习的同时也能帮到一些懒得看英文的朋友。另外，该课程的阅读资料中有许多练习题，但是没有标准答案，所给出的答案均为译者所写，有错误的地方还请指出。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/&quot;&gt;李秋豪&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;审校：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;V1.0 Thu Mar 8 22:58:41 CST 2018&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;本次课程的目标&quot;&gt;&lt;span&gt;本次课程的目标&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;代码评审：阅读并讨论别人写的代码。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;好代码的书写原则：你在代码评审的过程中应遵循的标准，不管编程目的或编程语言是什么。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;代码评审&quot;&gt;&lt;span&gt;代码评审&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;代码评审是一种系统的对别人代码的研究，和论文审校很类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码评审有两个主要目的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;提升代码质量。&lt;/strong&gt; 找出存在及潜在的bug，分析代码的清晰度以及代码是否严格遵循了当前工程的标准。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;提升程序员的水平。&lt;/strong&gt; 代码评审是提升程序员水平的一个重要方法，通过它可以学习到语言新的特性、工程上新的设计以及一些新的实现方法。特别是在开源项目中，很多交流都是在代码评审这种环境下进行的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;代码评审已经在开源项目中运用很深了，例如Apache 和 &lt;a href=&quot;http://blog.humphd.org/vocamus-1569/?p=1569&quot;&gt;Mozilla&lt;/a&gt;. 同样的，代码评审在工业界也应用很广，在Google，如果你的代码没有另一个程序员的评审签字，你是没办法将它提交的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在本课程中，我们会在“Problem sets”环节上进行一系列的代码评审，详细的信息可参考 &lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/general/code-review.html&quot;&gt;Code Reviewing document&lt;/a&gt; 。（译者注：这是MIT要求学生之间相互进行代码评审并打分。我们学校没有进行这项活动）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;风格标准&quot;&gt;&lt;span&gt;风格标准&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;大多数公司或者大的项目都会要求代码风格具有统一的标准。这些标准可能会非常细化，例如缩进应该是几个空格，花括号应该怎么对齐。这些问题上的争论通常会导致 &lt;a href=&quot;http://www.outpost9.com/reference/jargon/jargon_23.html#TAG897&quot;&gt;神圣的战争&lt;/a&gt; （译者注：例如vim和emacs哪一个更好），毕竟它们关乎于个人的口味或者审美观。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在本门课程中，我们对代码风格没有一个统一的要求。如果你是刚开始写Java，我们推荐你遵循 &lt;a href=&quot;http://google.github.io/styleguide/javaguide.html&quot;&gt;Google Java Style&lt;/a&gt; ，它在工业界运用的很广，可读性也不错，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isOdd&lt;/span&gt;(n)) {    
    n = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;*n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在关键词(&lt;code&gt;if&lt;/code&gt;)后面留空格，但是在函数调用(&lt;code&gt;isOdd&lt;/code&gt;)后不留空格&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在行的末尾写&lt;code&gt;{&lt;/code&gt; ，而 &lt;code&gt;}&lt;/code&gt; 自己单独一行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无论是空块还是只有一行，都要用&lt;code&gt;{&lt;/code&gt;…&lt;code&gt;}&lt;/code&gt;包括起来&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;不过，我们不会要求你遵循花括号的放置风格，毕竟每个程序员都有自己的口味。但是要注意，一旦遵循某一种风格后就要一直这样写，不要一会这样一会那样。同时，应该优先遵守所在项目规定的风格，如果你在进行代码评审的时候擅自改动别人的代码风格，你的搭档会恨死你的；）总之，团队合作优先。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，有一些代码风格是跟我们这门课程的三个目标息息相关的（译者注：远离bug、易读性、可改动性），它们可不止花括号放在哪这么简单。这篇阅读的剩下部分将探讨这些规则，而你在进行代码评审或是自己写代码的时候也应该注意这些规则。但是，代码评审可不仅仅是看别人的代码风格，我们在后续的课程还会讲到很多别的事情，例如规格说明、抽象数据类型、并发编程和线程安全等等，这些都是代码评审的原材料。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;难闻的smelly例子-1&quot;&gt;&lt;span&gt;难闻的（Smelly）例子 #1&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;程序员通常会将差代码描述为“难闻的”（bad smell）。“代码卫生”（Code hygiene）则是另一个描述这方面的词。现在让我从一个“难闻的”代码开始吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;59&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;90&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dayOfMonth;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来的几节都会围绕这一代码段展开。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;别写重复的代码dont-repeat-yourself&quot;&gt;&lt;span&gt;别写重复的代码（Don’t Repeat Yourself）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;重复的代码很不安全。如果你在两个地方放置了相似的代码，那么一个最基本的风险就是如果一处出现了bug，另一处也非常可能有bug。而修复的时候经常只会修复一个地方而忽略了另一个地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;避免重复就像你过马路的时候要避免被车撞一样。赋值-粘贴在编程中是一个很大的诱惑，而你在使用它的时候，“皮肤应该感觉到危险而震颤”。（译者注：这描述也是醉了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别重复代码（&lt;a href=&quot;http://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;Don’t Repeat Yourself&lt;/a&gt;,）简称为DRY，现在已经成为了编程人员的一句咒语。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译者注（来自维基百科）：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19.901538461538&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一次且仅一次&lt;/strong&gt;（&lt;strong&gt;once and only once&lt;/strong&gt;，简称&lt;strong&gt;OAOO&lt;/strong&gt;）又称为&lt;strong&gt;Don't repeat yourself&lt;/strong&gt;（不要重复你自己，简称&lt;strong&gt;DRY&lt;/strong&gt;）或&lt;strong&gt;一个规则，实现一次&lt;/strong&gt;（&lt;strong&gt;one rule, one place&lt;/strong&gt;）是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B&quot;&gt;面向对象编程&lt;/a&gt;中的基本原则，程序员的行事准则。旨在软件开发中，减少重复的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DRY的原则是──系统中的每一部分，都必须有一个单一的、明确的、权威的代表──指的是（由人编写而非机器生成的）代码和测试所构成的系统，必须能够表达所应表达的内容，但是不能含有任何重复代码。当DRY原则被成功应用时，一个系统中任何单个元素的修改都不需要与其逻辑无关的其他元素发生改变。此外，与之逻辑上相关的其他元素的变化均为可预见的、均匀的，并如此保持同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其起源已经不可考，一般认为这个原则最初由Andy Hunt和Dave Thomas在他们的书&lt;a href=&quot;http://book.douban.com/subject/1417047/&quot;&gt;The Pragmatic Programmer&lt;/a&gt;中提出。因为&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B&quot;&gt;极限编程&lt;/a&gt;方法的创始者之一&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%82%AF%E7%89%B9%C2%B7%E8%B2%9D%E5%85%8B&quot;&gt;肯特·贝克&lt;/a&gt;总结和宣传而使其广为人知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;违反&lt;strong&gt;DRY&lt;/strong&gt;原则的解决方案通常被称为&lt;strong&gt;WET&lt;/strong&gt;，其有多种全称，包括“write everything twice”（在每个地方写两次）、“we enjoy typing”（我们就是喜欢打字）或“waste everyone's time”（浪费大家的时间）。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;上面 &lt;code&gt;dayOfYear&lt;/code&gt; 这个例子充满了重复的代码，你能够试着将它们修复吗？&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在 &lt;code&gt;dayOfYear()&lt;/code&gt; 有一种重复是数值的重复，请问在 &lt;code&gt;dayOfYear()&lt;/code&gt; 一共出现了几次四月份的天数？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正如上面所提到的，重复的代码会给修复带来麻烦，如果我们的日历讲二月份改为30天而不是28天，这段代码一共要修改几处？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一种重复是代码 &lt;code&gt;dayOfMonth+=&lt;/code&gt;的重复。假设你建立了一个数组：&lt;code&gt;int[] monthLengths = new int[] { 31, 28, 31, 30, ..., 31}&lt;/code&gt; ，以下哪一种语句架构能够帮助你DRY，使得 &lt;code&gt;dayOfMonth+=&lt;/code&gt; 仅出现一次呢？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;[x] &lt;code&gt;for (int m = 1; m &amp;lt; month; ++m) { ... }&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;switch (month) { case 1: ...; break; case 2: ...; break; ... }&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;while (m &amp;lt; month) { ...; m += 1; }&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;[ ] &lt;code&gt;if (month == 1) { ... } else { ... dayOfYear(month-1, dayOfMonth, year) ... }&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;仅在需要的地方注释&quot;&gt;&lt;span&gt;仅在需要的地方注释&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一个好的开发者应该在代码中明智的添加注释。好的注释会使得代码易于修改，远离bug（因为一些重要的设想已经写出来了），并且减小了改动的难度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种重要的注释就是规格说明，通常出现在方法或者类的前部，一般会描述出类或方法的行为、参数、返回值、用法/例子等等。在Java中，规格说明通常按照Javadoc的标准来写：以 &lt;code&gt;/**&lt;/code&gt; 开始，中间用 &lt;code&gt;@&lt;/code&gt;-标出参数和返回值，最后以&lt;code&gt;*/&lt;/code&gt;结尾。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Compute the hailstone sequence.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * See http://en.wikipedia.org/wiki/Collatz_conjecture#Statement_of_the_problem&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;starting number of sequence; requires n &amp;gt; 0.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the hailstone sequence starting at n and ending with 1.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *         For example, hailstone(3)=[3,10,5,16,8,4,2,1].&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;fu&quot;&gt;hailstoneSequence&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) {
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另一种重要的注释就是标出是从哪引用的别的代码。这在实际编程中是非常重要的，当你从别的网站上引用代码的时候。同时，本门课程的要求 &lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/general/collaboration.html&quot;&gt;6.031 collaboration policy&lt;/a&gt; 也是这样规定的。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// read a web page into a string&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// see http://stackoverflow.com/questions/4328711/read-url-to-string-in-few-lines-of-java-code&lt;/span&gt;
String mitHomepage = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Scanner(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; URL(&lt;span class=&quot;st&quot;&gt;&quot;http://www.mit.edu&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;openStream&lt;/span&gt;(), &lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;useDelimiter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;A&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中的一个原因就是避免版权纠纷。你在Stack Overflow上引用的代码可能是用的公共版权协议，但是在别处的代码就未必了。另一个原因在于很多网站上的代码可能已经“过期”了，它可能不在符合现有的语言标准或者有更好的解决方案。例如这个&lt;a href=&quot;https://stackoverflow.com/questions/4328711/read-url-to-string-in-few-lines-of-java-code?answertab=oldest#tab-top&quot;&gt;回答&lt;/a&gt;就已经不适合现在的Java写法了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一些注释是不必要的。例如直接将代码行为翻译为英语（好像读者完全不懂Java一样）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (n != &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// test whether n is 1   (don't write comments like this!)&lt;/span&gt;
   ++i; &lt;span class=&quot;co&quot;&gt;// increment i&lt;/span&gt;
   l.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(n); &lt;span class=&quot;co&quot;&gt;// add n to l&lt;/span&gt;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是不易理解的代码应该被注释（例如实现一些特定的算法）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sum = n*(n&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)/&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// Gauss's formula for the sum of 1...n&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// here we're using the sin x ~= x approximation, which works for very small x&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; moonDiameterInMeters = moonDistanceInMeters * apparentAngleInRadians;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;阅读小练习-1&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;仅在需要的地方注释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面哪一些注释是合理的？（独立思考每一个注释，就当其它注释不存在一样）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** @param month month of the year, where January=1 and December=12  [C1] */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) {      &lt;span class=&quot;co&quot;&gt;// we're in February  [C2]&lt;/span&gt;
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// add in the days of January that already passed  [C3]&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;59&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// month is 3 here  [C4]&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;90&lt;/span&gt;;
    }
    ...
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dayOfMonth; &lt;span class=&quot;co&quot;&gt;// the answer  [C5]&lt;/span&gt;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] C1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] C2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] C3&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] C4&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] C5&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;快速报错失败fail-fast&quot;&gt;&lt;span&gt;快速报错/失败（Fail-fast）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;快速报错是指代码应该尽可能快的将其中的bug暴露出来。因为问题暴露的越早（越接近），其修复工作也会越容易。正如我们在&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8486545.html&quot;&gt;第一篇阅读资料&lt;/a&gt;里看到的，静态检查比动态检查更早报错，动态检查比产生错误的结果（这也可能会影响接下来的计算）更早报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显， &lt;code&gt;dayOfYear&lt;/code&gt; 这个函数并没有快速报错——如果你输入一个顺序不对的参数，它只会静悄悄的返回一个错误的值。事实上，依照 &lt;code&gt;dayOfYear&lt;/code&gt; 参数的设计方法，一个不是美国本土的用户很可能输入一个顺序不对的参数。所以， &lt;code&gt;dayOfYear&lt;/code&gt; 需要静态或者动态检查来检测这种错误。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-2&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;快速报错&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;59&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;90&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        dayOfMonth += &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dayOfMonth;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设现在的日期是2019年二月9号，&lt;code&gt;dayOfYear&lt;/code&gt; 返回的正确答案应该是40。以下输入分别会导致什么结果呢？（静态错误、动态错误、不报错返回正确答案、不报错返回错误的答案）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不报错返回正确答案&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不报错返回错误的答案&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不报错返回错误的答案&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;February&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;静态错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不报错返回错误的答案&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2019&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不报错返回错误的答案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更快速的报错&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下哪一种措施会使得我们的报错更加快速呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(String month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) { 
    &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更快报错——静态错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month &amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; || month &amp;gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更快报错——动态错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month &amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; || month &amp;gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException();
    }
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更快报错——动态错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; Month { JANUARY, FEBRUARY, MARCH, ..., DECEMBER };
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(Month month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更快报错——静态错误&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
        ...
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) {
        ...
    }
    ...
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;) {
        ...
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;month out of range&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;更快报错——动态错误&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;避免幻数&quot;&gt;&lt;span&gt;避免幻数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有一个笑话说的是计算机科学家只认识1和0这两个数字，有时候加上一个2.（译者注：好冷。。他的意思是尽量不要经常在代码中写1和0以外的常数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了这几个数以外的常数都被称为“ &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)#Unnamed_numerical_constants&quot;&gt;幻数&lt;/a&gt;”，因为它们就好像不知道从哪突然冒出来一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决幻数的一个办法就是写注释，但是另一个更好的办法是声明一个具有合理名字的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的&lt;code&gt;dayOfYear&lt;/code&gt; 就充满了幻数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;月份2,.....,12如果用 &lt;code&gt;FEBRUARY&lt;/code&gt;, …, &lt;code&gt;DECEMBER&lt;/code&gt;.会更加容易理解&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;days-of-months&lt;/code&gt; 30, 31, 28等等 如果用存储在数据结构中的数会更加容易理解，例如列表或者数组e.g. &lt;code&gt;MONTH_LENGTH[month]&lt;/code&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;前面的59和90实际上是程序员自己加起来算出的！&lt;strong&gt;它们不仅没有注释，而且正确性依赖于程序员算术的正确性！&lt;/strong&gt; 永远不要在代码用硬编码你自己计算的数值，让程序去做所有的数值计算工作，例如&lt;code&gt;MONTH_LENGTH[JANUARY] + MONTH_LENGTH[FEBRUARY]&lt;/code&gt;即易于理解又不会计算错误。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;阅读小练习-3&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;避免幻数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在以下代码中，你觉得2大概代表什么意思？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (month == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) { &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当你要靠猜测的时候，会发生什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设你正在阅读 turtle图形库中的一段代码，你对此并不熟悉：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;turtle.&lt;span class=&quot;fu&quot;&gt;rotate&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;仅仅通过这段代码，你觉得3表达了什么意思？&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 3可能代表顺时针3度&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 3可能代表逆时针3度&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[x] 3可能代表顺时针3弧度&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 3可能代表顺时针3圈&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用名字而非数字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考下面这段代码，它尝试画出一个正边形：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;; ++i) {
    turtle.&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;);
    turtle.&lt;span class=&quot;fu&quot;&gt;turn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt;);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这些幻数使得这段代码脱离了我们定下的三个目标：远离bug、易读性、易改动性（safe from bugs (SFB), not easy to understand (ETU) and not ready for change (RFC)）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于下面这些重写的代码，你认为它们有哪些改进？（SFB, ETU, and/or RFC三个方面考虑）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; five = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; thirtySix = &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; seventyTwo = &lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; five; ++i) {
    turtle.&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(thirtySix);
    turtle.&lt;span class=&quot;fu&quot;&gt;turn&lt;/span&gt;(seventyTwo);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] numbers = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] { &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt; }; 
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; numbers[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]; ++i) {
    turtle.&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(numbers[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
    turtle.&lt;span class=&quot;fu&quot;&gt;turn&lt;/span&gt;(numbers[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; x; ++i) {
    turtle.&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;);
    turtle.&lt;span class=&quot;fu&quot;&gt;turn&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;360.0&lt;/span&gt; / x);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 没有提升（或者变差了）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;[ ] 远离bug（译者注：其实这里也有一定的远离bug，如果把最后画出来不是一个正边形当做bug的话。不过这里的bug应该是指for循环中可能会添加修改x的代码，而x又是循环量）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] 易读性&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] 易改动性&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; degreesInACircle = &lt;span class=&quot;fl&quot;&gt;360.0&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numSides = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sideLength = &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; numSides; ++i) {
    turtle.&lt;span class=&quot;fu&quot;&gt;forward&lt;/span&gt;(sideLength);
    turtle.&lt;span class=&quot;fu&quot;&gt;turn&lt;/span&gt;(degreesInACircle / numSides);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;每一个变量有且只有一个目的&quot;&gt;&lt;span&gt;每一个变量有且只有一个目的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在 &lt;code&gt;dayOfYear&lt;/code&gt; 这个例子中， &lt;code&gt;dayOfMonth&lt;/code&gt; 被用来做不同意义的值：一开始它是这个月的第几天，最后它是返回的结果（是今年的第几天）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要重利用参数，也不要重利用变量。在现在的计算机中，变量不是一个稀缺的资源。当你需要的时候就声明一个（命名一个易理解的名字），不需要它的时候就停止使用。如果你的变量在前面几行代表一个意思，在后面又代表另一个意思，你的读者会很困惑的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，这不仅仅是一个易理解的问题，它也和我们的“远离bug”以及“可改动性”有关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别地，方法的参数不应该被修改（这和“易改动性”相关——在未来如果这个方法的某一部分想知道参数传进来的初始值，那么你就不应该在半路修改它）。所以应该使用&lt;code&gt;final&lt;/code&gt;关键词修饰参数（这样Java编译器就会对它进行静态检查，防止重引用），然后在方法内部声明其他的变量使用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;dayOfYear&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; month, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dayOfMonth, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year) {
    ...
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;难闻的例子-2&quot;&gt;&lt;span&gt;“难闻的”例子 #2&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在 &lt;code&gt;dayOfYear&lt;/code&gt; 中有一个bug——它没有正确处理闰年。为了修复它，我们写了一个判断闰年的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; y) {
    String tmp = String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(y);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;') {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;') &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/*R1*/&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/*R2*/&lt;/span&gt;
    }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;' &amp;amp;&amp;amp; tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;') {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/*R3*/&lt;/span&gt;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;')&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/*R4*/&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/*R5*/&lt;/span&gt;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个代码中有bug吗？它的代码风格有什么问题（根据前面说过的）？&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-4&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你判断2016年时会发生什么：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2016&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你判断2017年时会发生什么：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2017&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2050&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你判断2050年时会发生什么：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2050&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10016&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你判断10016年时会发生什么：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10016&lt;/span&gt;)&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;916&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你判断916年时会发生什么：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;幻数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个方法了幻数一共出现了几次（重复的也按多次算）？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DRY&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设你写了一个帮助方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isDivisibleBy&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; number, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; factor) { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; number % factor == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; }&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接着 &lt;code&gt;leap()&lt;/code&gt; 使用这个 &lt;code&gt;isDivisibleBy(year, ...)&lt;/code&gt;方法重写，并且正确的使用 &lt;a href=&quot;http://en.wikipedia.org/wiki/Leap_year#Algorithm&quot;&gt;leap year algorithm&lt;/a&gt;中描述的算法，这时该方法中会出现几个幻数？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用好的名称&quot;&gt;&lt;span&gt;使用好的名称&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;好的方法名和变量名都是比较长而且能自我解释的。这种时候注释通常都不必要，因为名字就已经解释了它的用途。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，你可以这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; tmp = &lt;span class=&quot;dv&quot;&gt;86400&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// tmp is the number of seconds in a day (don't do this!)&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; secondsPerDay = &lt;span class=&quot;dv&quot;&gt;86400&lt;/span&gt;;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通常来说， &lt;code&gt;tmp&lt;/code&gt;, &lt;code&gt;temp&lt;/code&gt;, 和 &lt;code&gt;data&lt;/code&gt; 这样变量名是很糟糕的（最懒的程序员的标志）。每一个局部变量都是暂时的（temporary），每一个变量也都是数据（data）。所以这些命名都是无意义的。我们应该使用更长、更有描述性的命名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一种语言都有它自己的命名传统。在Python中，类通常是大写的，变量通常是小写，并且单词是用“_”来区分开的（words_are_separated_by_underscores）。在Java中：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;methodsAreNamedWithCamelCaseLikeThis （方法）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;variablesAreAlsoCamelCase （译者注：&lt;a href=&quot;https://baike.baidu.com/item/%E9%AA%86%E9%A9%BC%E5%91%BD%E5%90%8D%E6%B3%95/7794053?fr=aladdin&amp;amp;fromid=7560610&amp;amp;fromtitle=%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E6%B3%95&quot;&gt;驼峰命名法&lt;/a&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CONSTANTS_ARE_IN_ALL_CAPS_WITH_UNDERSCORES （常量）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ClassesAreCapitalized （类）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;packages.are.lowercase.and.separated.by.dots （包）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;ALL_CAPS_WITH_UNDERSCORES 是用来表示 &lt;code&gt;static final&lt;/code&gt; 这样的常量，所有在方法内部声明的方法，包括用&lt;code&gt;final&lt;/code&gt;修饰的，都使用camelCaseNames.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法的名字通常都是动词，例如 &lt;code&gt;getDate&lt;/code&gt; 或者 &lt;code&gt;isUpperCase&lt;/code&gt;, 而变量和类的名字通常都是名词。尽量选用简洁的命名，&lt;strong&gt;但是要避免缩写&lt;/strong&gt;：例如, &lt;code&gt;message&lt;/code&gt; 而不是 &lt;code&gt;msg&lt;/code&gt;, &lt;code&gt;word&lt;/code&gt;而不是 &lt;code&gt;wd&lt;/code&gt;. 因为看你代码的程序员可能是非英语母语的！这些缩写可能在他们看来很难懂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外要避免使用一个字母当变量的名字，除了在一些传统上根据能看懂的情况。例如x和y在用于坐标系的时候就很清晰，i和j用于变量的循环变量的时候就很清晰。但是如果你的代码充斥了像 &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, 和 &lt;code&gt;h&lt;/code&gt;这样的单字母变量，读者会很难理解它们的用途的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-5&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更好的方法名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;leap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; y) {
    String tmp = String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(y);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;' || tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;') {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;') &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;' &amp;amp;&amp;amp; tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) == '&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;') {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;'||tmp.&lt;span class=&quot;fu&quot;&gt;charAt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)=='&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;')&lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面哪一个方法名比 &lt;code&gt;leap&lt;/code&gt;这个名字 更合适?&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;leap&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;isLeapYear&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;IsLeapYear&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;is_divisible_by_4&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更好的方法名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面哪一个变量名比 &lt;code&gt;tmp&lt;/code&gt; 更合适?&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;leapYearString&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;yearString&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;temp&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;secondsPerDay&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;s&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用空白符帮助读者&quot;&gt;&lt;span&gt;使用空白符帮助读者&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;注意使用前后一致的空格缩进。&lt;code&gt;leap&lt;/code&gt;就是一个典型的反面例子。&lt;code&gt;dayofYear&lt;/code&gt;就好的多。事实上， &lt;code&gt;dayOfYear&lt;/code&gt;很好的将各个行用缩进进行了分隔，它们开始来很适合人们阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在代码行中添加一些一致的空格有利于人们的阅读。&lt;code&gt;leap&lt;/code&gt;这个例子就将很多代码“杂糅”在一起——记得加一些空格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外要注意的是，永远不要使用&lt;code&gt;Tab&lt;/code&gt;&lt;strong&gt;字符&lt;/strong&gt; （译者注：即&lt;code&gt;\t&lt;/code&gt;）来进行缩进，只能使用空格字符。&lt;strong&gt;这里强调的是不要使用&lt;code&gt;\t&lt;/code&gt;字符，不是说键盘上的这个按键&lt;/strong&gt;（译者注：很多编辑器和IDE都会自动把&lt;code&gt;Tab&lt;/code&gt;&lt;strong&gt;按键&lt;/strong&gt;作为设置好几个连续的空格输入）。因为不同的工具在显示&lt;code&gt;\t&lt;/code&gt;字符的时候长度不一样，有的是8个空格，有的是4个空格，有的是2个空格，所以在你用“git diff”或者其他的编辑器看同一份代码很可能就会显示的不一样。永远将你用的文本编辑器设置为按下&lt;code&gt;Tab&lt;/code&gt;键输入空格而非&lt;code&gt;\t&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;难闻的例子-3&quot;&gt;&lt;span&gt;“难闻的”例子 #3&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面是本次阅读的第三个例子，它呈现了我们剩下要讲的要点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; LONG_WORD_LENGTH = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String longestWord;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;countLongWords&lt;/span&gt;(List&amp;lt;String&amp;gt; words) {
   &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
   longestWord = &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;
   &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (String word: words) {
       &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (word.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;gt; LONG_WORD_LENGTH) ++n;
       &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (word.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;gt; longestWord.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()) longestWord = word;
   }
   System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(n);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;不要使用全局变量&quot;&gt;&lt;span&gt;不要使用全局变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;避免使用全局变量，现在我们把这个词拆开具体分析：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;“变量”，说明它的值是可以修改的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;“全局的”，说明它可以从程序的任何地方访问&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://c2.com/cgi/wiki?GlobalVariablesAreBad&quot;&gt;为什么全局变量是不好的&lt;/a&gt; 列出了一系列全局变量的缺点，可以参考一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Java中，全局变量被声明为 &lt;code&gt;public static&lt;/code&gt; 。 &lt;code&gt;public&lt;/code&gt; 修饰符代表它可以从任何地方访问，而 &lt;code&gt;static&lt;/code&gt;代表这个变量只会有一个实例化的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，如果我们加上另一个关键词&lt;code&gt;final&lt;/code&gt; ： &lt;code&gt;public static final&lt;/code&gt;,并且这个变量的类型是不可更改的（immutable，译者注：参考&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8494132.html&quot;&gt;第二篇阅读“Java基础”&lt;/a&gt;），那么这个对象就变成了一个“全局常量”。一个全局常量可以在任何位置读取，但是永远不会被赋予新的值或对象，所以风险也就没有了。全局常量是很常见的，而且很有用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常来说，我们应该使用参数传递和返回值而非全局变量，或者将它们放到你调用的方法的所属类中。我们会在后面的阅读中介绍很多这样的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;在快照图中的各种变量&quot;&gt;&lt;span&gt;在快照图中的各种变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在我们画快照图的时候，区别不同种类的变量是很重要的（译者注：参考&lt;a href=&quot;http://www.cnblogs.com/liqiuhao/p/8494132.html&quot;&gt;第二篇阅读“Java基础”&lt;/a&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;方法里面的局部变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个实例化对象中的实例化变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个类中的静态变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当方法被调用的时候，局部变量产生，当方法返回时，局部变量消失。如果一个方法被多次同时调用（例如递归），这些方法里面的局部变量互相独立，彼此不会影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个对象用&lt;code&gt;new&lt;/code&gt;实例化后，对象中实例化的变量产生，当这个对象被垃圾回收时，这个变量消失。每一个实例化对象都有它自己的实例化变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序启动时（更准确点说是包含该静态变量的类被加载的时候），静态变量就产生了，它会一直存活到程序结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面这个例子中使用到了上面三种变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Payment {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; value;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; taxRate = &lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        Payment p = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Payment&lt;/span&gt;();
        p.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;;
        taxRate = &lt;span class=&quot;fl&quot;&gt;0.05&lt;/span&gt;;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(p.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; * (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; + taxRate));
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面这个快照图描述了各个变量之间的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201803/1072319-20180308230213802-1790562735.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局部变量&lt;code&gt;p&lt;/code&gt;和&lt;code&gt;args&lt;/code&gt;显示在一个&lt;strong&gt;栈帧&lt;/strong&gt;中，它们在&lt;code&gt;main&lt;/code&gt;函数被调用的时候动态生成，&lt;code&gt;main&lt;/code&gt;函数返回时它们也会跟着消失。而&lt;code&gt;println&lt;/code&gt;是在&lt;code&gt;main&lt;/code&gt;函数调用它的时候生成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例化变量 &lt;code&gt;value&lt;/code&gt; 会在每一个&lt;code&gt;Payment&lt;/code&gt;类型的对象中出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;静态变量 &lt;code&gt;taxRate&lt;/code&gt; 出现在&lt;code&gt;Payment&lt;/code&gt;类型的对象之外，因为它是属于&lt;code&gt;Payment&lt;/code&gt;这个类的。任何数量的 &lt;code&gt;Payment&lt;/code&gt; 类型的对象都可以被创建或销毁（同时它们含有的实例化变量 &lt;code&gt;value&lt;/code&gt; 也会跟着一起创建和销毁），但是在整个程序中有且仅有一个&lt;code&gt;Payment&lt;/code&gt;类，所以这里也有且仅有一个&lt;code&gt;Payment.taxRate&lt;/code&gt; 变量。 &lt;code&gt;System.out&lt;/code&gt; 是另一个在这段代码中使用到的静态变量，所以在快照图中也将它显示出来了。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;阅读小练习-6&quot;&gt;&lt;span&gt;阅读小练习&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;辨识出全局变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面第三个例子中，哪一些是全局变量？&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;countLongWords&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;n&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;LONG_WORD_LENGTH&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[x] &lt;code&gt;longestWord&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;word&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;[ ] &lt;code&gt;words&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;final&lt;/code&gt;的效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;code&gt;final&lt;/code&gt;关键词是避开使用全局变量风险的一个办法。如果我们在第三个例子中分别对以下变量使用&lt;code&gt;final&lt;/code&gt;关键词会发什么什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;n&lt;/code&gt; -&amp;gt; 程序运行前报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;LONG_WORD_LENGTH&lt;/code&gt; -&amp;gt; 成为常量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;longestWord&lt;/code&gt; -&amp;gt; 程序运行前报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;word&lt;/code&gt; -&amp;gt; 成为常量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;words&lt;/code&gt; -&amp;gt; 成为常量&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;方法应该返回结果而不是打印它&quot;&gt;&lt;span&gt;方法应该返回结果，而不是打印它&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;countLongWords&lt;/code&gt; 并不具备可更改性。它最后向控制台输出结果, &lt;code&gt;System.out&lt;/code&gt;.这意味着如果你想在另一个地方使用它，其中结果可能会做其他的用途，例如参与运算而不是显示出来，程序就得重写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常来说，只有最高层的代码才会处理与人/控制台的交互。唯一的例外是debug的时候，你需要将一些关键值打印出来。但是这一部分代码不会是你设计的一部分，只有在debug的时候才能出现。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;代码评审是一种广泛应用的软件质量提升方法。它可以检测出代码中的各种问题，但是作为一个初学课程，这篇阅读材料只提及了下面几个好代码通用的原则：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不要重复你的代码(DRY)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;仅在需要的地方做注释&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;快速失败/报错&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;避免使用幻数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个变量有且仅有一个目的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用好的命名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;避免使用全局变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回结果而非打印它&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用空白符提升可读性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面把今天学的内容和我们的三个目标联系起来：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;远离bug.&lt;/strong&gt; 通常来说，代码评审使用人的审查来发现bug。DRY使得你只用在一处地方修复bug，避免bug的遗漏。注释使得原作者的假设很清晰，避免了别的程序员在更改代码的时候引入新的bug。快速报错/失败使得bug能够尽早发现，避免程序一直错更多。避免使用全局变量使得修改bug更容易，因为特定的变量只能在特定的区域修改。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;易读性.&lt;/strong&gt; 对于隐晦或者让人困惑的bug，代码评审可能是唯一的发现方法，因为阅读者需要尝试理解代码。使用明智的注释、避免幻数、变量目的单一化、选择好的命名、使用空白字符都可以提升代码的易读性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可更改性.&lt;/strong&gt; DRY的代码更具有可更改性，因为代码只需要在一处进行更改。返回结果而不是打印它使得代码更可能被用作新的用途。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 08 Mar 2018 15:03:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8531425.html</dc:identifier>
</item>
<item>
<title>网络协议笔记-网络层-ARP协议 - 高飞剑</title>
<link>http://www.cnblogs.com/ymkfnuiwgij/p/8531430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ymkfnuiwgij/p/8531430.html</guid>
<description>&lt;p&gt;【2-地址解析协议ARP】&lt;/p&gt;
&lt;p&gt;【2.1-基本概念】&lt;/p&gt;
&lt;p&gt;　　地址解析协议ARP的作用是根据主机的IP地址，找出该主机的硬件地址。&lt;/p&gt;
&lt;p&gt;【2.2-为什么要使用ARP】&lt;/p&gt;
&lt;p&gt;　　在数据传输过程中，网络层使用的IP地址，但是在实际传输的时候，数据是从网络的数据链路上传送数据帧的（就是数据链路层所做的工作，七层网络结构中，数据从上往下移动），所以最终还是需要使用网络的硬件地址。因为七层网络结构中每一层都是黑盒的，所以在讨论数据在网络层传输的时候，就忽略了对数据链路层的讨论。&lt;/p&gt;
&lt;p&gt;【2.3-ARP的简要工作原理】&lt;/p&gt;
&lt;p&gt;　　每一台主机都有一个ARP高速缓存表，用来存储主机所在局域网上所有主机和路由器的IP地址到硬件地址的映射表。当网络层传输数据时，指明数据的目的IP地址，然后通过目的IP地址在ARP高速缓存表中找到该主机的硬件地址，即目的主机的硬件地址，然后把网络层的IP数据报加上源硬件地址和目的硬件地址，封装成MAC帧（数据链路层的数据传输单位）在数据链路上进行数据传输。&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;2.4-ARP怎么获取本网络其他主机的IP地址硬件地址的映射关系&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;　　假设主机A要向本网络中的主机B发送IP数据报，首先主机A在自己的ARP高速缓存表中根据主机B的IP地址找对应的硬件地址，如果找到了，就这个硬件地址写到MAC帧，然后通过局域网把这个MAC帧发送到这个硬件地址。如果没有找到，主机A就向自己所在的局域网广播ARP请求分组，这个请求分组中的信息是这样的，“主机A的IP的地址，主机A的硬件地址，目的主机B的IP地址”；接着这个网络上的所有主机都收到这个请求，都各自检查请求中目的主机的IP地址是不是自己，如果不是，就不做任何响应，如果是，就先把主机A的IP地址和硬件地址的映射关系在自己的ARP高速缓存表中保存一下，然后向主机A发送单播响应信息，信息内容是这样的，“主机B（自己）的IP地址，主机B（自己）的硬件地址”；主机A收到主机B的单播响应信息之后，就把映射关系缓存在自己的ARP高速缓存表中，最后把主机B的硬件地址写到MAC帧中，通过局域网把MAC帧发送到主机B的硬件地址。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;假设主机B的硬件地址换了，主机A中保存的映射关系不就变成错误的了吗？&lt;/strong&gt;&lt;/span&gt; 解决办法就是，本机的ARP高速缓存表有个过期时间，一定时间内容会清空，重新更新这个高速缓存表。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;当目的主机B和主机A不在同一个网络中怎么办？&lt;/strong&gt;&lt;/span&gt;如果是这样，那么主机A的ARP高速缓存表中保存的就是两个网络之间的路由器的硬件地址，主机A根据路由器地址解析出路由器的硬件地址，然后把MAC帧发送给路由器，然后就不管了，由路由器再做ARP的解析去把数据最终发送到目的主机B的硬件地址去。个人理解也可以把这个路由器当成一个主机。&lt;/p&gt;
</description>
<pubDate>Thu, 08 Mar 2018 15:01:00 +0000</pubDate>
<dc:creator>高飞剑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ymkfnuiwgij/p/8531430.html</dc:identifier>
</item>
<item>
<title>Java并发编程笔记4-线程池 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/8531281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/8531281.html</guid>
<description>&lt;p&gt;我们使用线程的时候就去创建一个线程，但是就会有一个问题：&lt;/p&gt;
&lt;p&gt;　　如果并发的线程数量非常多，而且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会导致大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。&lt;/p&gt;

&lt;p&gt;那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？&lt;/p&gt;
&lt;p&gt;线程池正好能解决这样的问题。正如名称所称的那样，线程池管理一个工作者线程的同构池。线程池是与工作队列紧密绑定的。所谓工作队列，其作用是持有所有等待执行的任务。&lt;/p&gt;
&lt;p&gt;工作者线程的生活从此轻松起来：它从工作队列中获取下一个任务，执行它，然后回来等待另外一个线程。&lt;/p&gt;
&lt;p&gt;这类似于企业应用程序中事务监听器(transaction monitor)的角色：它将课运行事务的数量控制在一个合理的水平中，不会因过渡滥用事务而耗尽有限资源。&lt;/p&gt;
&lt;p&gt;　　线程池中执行任务线程，这方法有很多“每任务每线程”无法笔记的优势。重用存在的线程，而不是创建新的线程，这可以在处理多请求时抵消线程创建，消亡产生的开销。还有一个好处就是，在请求到达时，工作者线程通常已经存在&lt;/p&gt;
&lt;p&gt;，用于创建线程的等待时间并不会延迟任务的执行，因此提高响应性。通过适当地调整线程池的大小，你可以得到足够多的线程以保持处理器忙碌，同时可以还防止过多的线程互相竞争资源，导致应用程序耗尽内存或者失败。&lt;/p&gt;

&lt;p&gt;每任务每线程例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ServerSocket serverSocket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(80&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Socket socket =&lt;span&gt; serverSocket.accept();
            Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    handleRequest(socket);
                }
            };
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(Socket socket) {
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到这个例子是一个粗制滥造的并发服务端，来一个用户就创建一个线程，你根本就不知道有多少用户来，要创建多少个线程。这样频繁创建线程就会导致大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，&lt;/p&gt;
&lt;p&gt;过渡滥创建线程而耗尽有限资源。&lt;/p&gt;

&lt;p&gt;由于这原因，java中给我们提供Executor框架。通过Executors中的某个静态工厂方法来创建一个线程池：&lt;/p&gt;
&lt;p&gt;　　1.newFixedThreadPool 创建一个定长的线程池，每当提交一个任务就创建一个线程，知道达到池的最大长度，这时线程池会保持长度不再变化(如果一个线程由于非预期的Exception而结束，线程池会补充一个新的线程)。&lt;/p&gt;
&lt;p&gt;　　下面用newFixedThreadPool 创建一个定长的线程池来改造上面的例子，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newFixedThreadPool参数为线程池的大小&lt;/span&gt;
        Executor executor = Executors.newFixedThreadPool(100&lt;span&gt;);
        
        ServerSocket serverSocket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(80&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Socket socket =&lt;span&gt; serverSocket.accept();
            Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    handleRequest(socket);
                }
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接将任务丢进线程池来执行任务&lt;/span&gt;
&lt;span&gt;            executor.execute(task);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(Socket socket) {
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就不会发生过渡滥创建线程而耗尽有限资源。&lt;/p&gt;


&lt;p&gt;　　2.newSingleThreadExecutor创建一个单线程化的executor,他只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它。executor会保证任务依照任务队列所规定的顺序(FIFO,LIFO,优先级)执行。&lt;/p&gt;


&lt;p&gt;　　3.newCachedThreadPool创建一个可缓存的线程池，如果当前线程的长度超过了处理的需要，它可以灵活的回收空闲的线程，当需求增加时，它可以灵活的增加新的线程，并不会对池的长度做任何限制。但是认为改线程池的长度没有任何限制，有可能会把资源耗尽，&lt;/p&gt;
&lt;p&gt;这需要自己很好的把控了。&lt;/p&gt;

&lt;p&gt;　　4.newScheduledThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。&lt;/p&gt;

&lt;p&gt;Executor的生命周期：&lt;/p&gt;
&lt;p&gt;　　Executor实现通常知识为执行任务而创建线程。但是JVM会在所有(非后台的，nondaemon)线程全部终止后才退出。因此，如果无法正确关闭Executor，将会阻止JVM的结束。&lt;/p&gt;
&lt;p&gt;因为Executor是异步地执行任务，所以在任何时间里，所有之前提交的任务状态都不能立即可见。这些任务中，有些可能已经完成，有些可能正在运行，其他的还可能在队列中等待执行。关闭应用程序时，程序会出现很多中情况：从平缓关闭&lt;/p&gt;
&lt;p&gt;到最突然的关闭，以及介于这两种阶段情况之间的各种可能。Executor是为应用服务提供服务的，他们理应可以关闭，无论是平缓还是突然。&lt;/p&gt;
&lt;p&gt;注意：关闭操作还会影响到记录应用程序任务状态的反馈信息。&lt;/p&gt;

&lt;p&gt;Executor就是一个接口，源码如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308195317920-2021936768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们可以进入Executors这个类的源码，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308195551573-788054553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到newFixedThreadPool 创建一个定长的线程池，返回的是一个ExecutorService，但是我们上面例子接收的是Executor，为什么Executor也可以接收呢？我们继续进入ExecutorService源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308195829392-317743629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到原来ExecutorService继承了Executor。ExecutorService扩展了Executor，并且添加了一些用于声明周期管理的方法。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202427209-781505157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202515708-130269647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202540746-1738310405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202552576-149471111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202605073-362904063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308202642630-117115384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; ExecutorService暗示了生命周期有3种状态：运行、关闭、终止。ExecutorService最初创建后的初始状态是运行状态。&lt;/p&gt;
&lt;p&gt;shutdown方法会启动一个平缓的关闭过程：停止接受新的任务，同时等待已经提交的任务完成，包括尚未开始执行的任务。&lt;/p&gt;
&lt;p&gt;shutdownNow方法会启动要给强制的关闭过程：尝试取消所有运行中的任务和排在队列中尚未开始执行的任务is。&lt;/p&gt;
&lt;p&gt;isShutdown方法：判断线程池(即ExecutorService)是否关闭。&lt;/p&gt;
&lt;p&gt;isTerminated方法：是线程池(即ExecutorService)是否进入终止状态。&lt;/p&gt;
&lt;p&gt;　　在关闭后提交到ExecutorService中的任务，会被拒绝执行处理器(rejected execution handler）处理。拒绝执行处理器是ExecutorService的一种实现，ThreadPoolExecutor提供的，ExecutorService接口中的方法并不提供拒绝执行处理器。拒绝执行处理器可能只是&lt;/p&gt;
&lt;p&gt;简单的放弃任务，也可能会引起execute抛出一个未检查的RejectedExecutionException。一旦所有任务全部完成后，ExecutorService会转入终止状态。&lt;/p&gt;

&lt;p&gt;awaitTermination方法：等待ExecutorService到达终止状态。&lt;/p&gt;

&lt;p&gt;通常shutdown会紧随awaitTermination之后，这样可以产生同步地关闭ExecutorService的效果。&lt;/p&gt;

&lt;p&gt;上面的Executor的例子的程序是没办法关闭线程池，会一直跑下去，那么我们如何写一个支持关闭的webserver呢？&lt;/p&gt;
&lt;p&gt;明显我们现在要用ExecutorService来改造上面的Executor的例子。伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService executorService =&lt;span&gt; Executors.newCachedThreadPool();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newFixedThreadPool参数为线程池的大小&lt;/span&gt;
&lt;span&gt;
        ServerSocket serverSocket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServerSocket(80&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就不再像上面的例子一样无限的接受任务了，要根据我的线程池是否处于关闭状态来决定&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;executorService.isShutdown()){
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Socket socket =&lt;span&gt; serverSocket.accept();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                executorService.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        handleRequest(socket);
                    }
                });
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RejectedExecutionException e){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拒绝服务不是因为我线程池关闭导致的，我们要在这里打印一下日志&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;executorService.isShutdown()){
                    System.out.println(&lt;/span&gt;&quot;接受任务被拒绝&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用一个公共的方法去关闭线程池&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stop(){
        executorService.shutdown();
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleRequest(Socket socket) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求&lt;/span&gt;
        Request req =&lt;span&gt; readRequest(socket);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果请求已经关闭&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isShutdownRequest(req)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭线程池&lt;/span&gt;
&lt;span&gt;            stop();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求转发&lt;/span&gt;
&lt;span&gt;            dispatchRequest(req);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过改造，这服务端变的优雅多了。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;延时的，并具有周期性的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在newScheduledThreadPool出来之前我们一般会用Timer和TimerTask来做。Timer在JDK里面，是很早的一个API了。&lt;/p&gt;
&lt;p&gt;但是Timer存在一些缺陷，Timer只创建唯一的线程来执行所有Timer任务。如果一个timer任务的执行很耗时，会导致其他TimerTask的时效准确性出问题。例如一个TimerTask每10秒执行一次，&lt;/p&gt;
&lt;p&gt;而另外一个TimerTask每40ms执行一次，重复出现的任务会在后市的任务完成后快速连续的被调用4次，要么完全“丢失”4次调用。&lt;/p&gt;
&lt;p&gt;Timer的另外一个问题在于，如果TimerTask抛出未检查的异常会终止timer线程。这种情况下，Timer也不会重新回复线程的执行了；它错误的认为整个Timer都被取消了。此时&lt;/p&gt;
&lt;p&gt;已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。&lt;/p&gt;

&lt;p&gt;现在我们看一下Timer的例子，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shedule {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TimerTask task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                    e.printStackTrace();
                }
            }
        };

        TimerTask task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
            }
        };

        Timer timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer();
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动一个调度任务，1S钟后执行&lt;/span&gt;
        timer.schedule(task,1000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动一个调度任务，3S钟后执行&lt;/span&gt;
        timer.schedule(task1,3000&lt;span&gt;);


    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面程序我们预想是第一个任务执行后，第二个任务3S后执行的，即输出一个1000，一个3000.&lt;/p&gt;
&lt;p&gt;实际运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308214452511-1414597006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 实际运行结果并不如我们所愿。世界结果，是过了4S后才输出第二个任务，即4001约等于4秒。那部分时间时间到哪里去了呢？那个时间是被我们第一个任务的sleep所占用了。&lt;/p&gt;
&lt;p&gt;现在我们在第一个任务中去掉Thread.sleep（）；这一行代码，运行是否正确了呢？如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shedule {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TimerTask task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
               
            }
        };

        TimerTask task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
            }
        };

        Timer timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer();
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动一个调度任务，1S钟后执行&lt;/span&gt;
        timer.schedule(task,1000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动一个调度任务，3S钟后执行&lt;/span&gt;
        timer.schedule(task1,3000&lt;span&gt;);


    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308214939246-1773597697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到确实是第一个任务过了1S后执行，第二个任务在第一个任务执行完后过3S执行了。&lt;/p&gt;
&lt;p&gt;这就说明了&lt;strong&gt;Timer只创建唯一的线程来执行所有Timer任务。如果一个timer任务的执行很耗时，会导致其他TimerTask的时效准确性出问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt; Timer存在一些缺陷，因此你应该考虑使用ScheduledThreadPoolExecutor作为替代品。你可以通过构造函数或者通过newScheduledThreadPool工厂方法创建一个ScheduledThreadPoolExecutor。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shedule {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TimerTask task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                    e.printStackTrace();
                }
            }
        };

        TimerTask task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
            }
        };

        Timer timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer();
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TimeUnit.MILLISECONDS指定毫秒为单位&lt;/span&gt;
        executorService.schedule(task,1000&lt;span&gt;, TimeUnit.MILLISECONDS);
        executorService.schedule(task1,&lt;/span&gt;3000&lt;span&gt;, TimeUnit.MILLISECONDS);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308215809806-1990656333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到运行结果符合预期。&lt;/p&gt;
&lt;p&gt;可以看到&lt;strong&gt;如果一个timer任务的执行很耗时(例如Thread.sleep)，ScheduledThreadPoolExecutor并不会导致其他TimerTask的时效准确性出问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还可以看到，这两个&lt;/strong&gt;TimerTask互不干扰。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;互相干扰还有一个反面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果TimerTask抛出未检查的异常会终止timer线程。这种情况下，Timer也不会重新回复线程的执行了；它错误的认为整个Timer都被取消了。此时&lt;/p&gt;
&lt;p&gt;　　　　已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shedule {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TimerTask task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
               &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException();
            }
        };

        TimerTask task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
            }
        };

        Timer timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer();
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();

        timer.schedule(task,&lt;/span&gt;1000&lt;span&gt;);
        timer.schedule(task1,&lt;/span&gt;3000&lt;span&gt;);
        

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果第一TimerTask出现未知异常，第二个TimerTask还能运行起来吗？&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308220445880-334556304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;明显第一TimerTask出现未知异常，第二个TimerTask不能运行起来了。这就说明&lt;/p&gt;
&lt;p&gt;如果TimerTask抛出未检查的异常会终止timer线程。这种情况下，Timer也不会重新回复线程的执行了；它错误的认为整个Timer都被取消了。此时&lt;/p&gt;
&lt;p&gt;已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ScheduledThreadPoolExecutor可以解决此问题，例子如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shedule {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TimerTask task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException();
            }
        };

        TimerTask task1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(System.currentTimeMillis()&lt;/span&gt;-&lt;span&gt;start);
            }
        };

        Timer timer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Timer();
        start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TimeUnit.MILLISECONDS指定毫秒为单位&lt;/span&gt;
        executorService.schedule(task,1000&lt;span&gt;, TimeUnit.MILLISECONDS);
        executorService.schedule(task1,&lt;/span&gt;3000&lt;span&gt;, TimeUnit.MILLISECONDS);


    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308220919374-1137197201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到第一个线程挂了，第二个线程并没有受到影响。这就说明了&lt;strong&gt;ScheduledThreadPoolExecutor可以解决了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果TimerTask抛出未检查的异常会终止timer线程。这种情况下，Timer也不会重新回复线程的执行了；它错误的认为整个Timer都被取消了。此时&lt;/p&gt;
&lt;p&gt;　　　　已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了的问题&lt;/p&gt;

&lt;p&gt;还要注意一点，Timer是和系统时间挂钩的，如果当前服务器的时间一改，Timer就不那么靠谱了。&lt;/p&gt;


&lt;p&gt;还要注意的是ThreadPoolExecutor。&lt;/p&gt;
&lt;p&gt;源码如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308221540686-932372623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到new一个FixedThreadPool/newSingleThreadExecutor/newCachedThreadPool/newScheduledThreadPool实际上返回的都是是new ThreadPoolExecutor()。&lt;/p&gt;
&lt;p&gt;我们再看一下ThreadPoolExecutor源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180308222412943-1464359536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到ThreadPoolExecutor配置的非常灵活，如果我们用普通的一个FixedThreadPool/newSingleThreadExecutor/newCachedThreadPool/newScheduledThreadPool没办法满足你的需求了，你可以用&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor灵活的指定参数来完成你的需求。这适合精确的任务执行。还不如说我们的任务被拒绝(RejecedExecutionHandler)后，我们可以用ThreadPoolExecutor灵活处理&lt;/p&gt;

</description>
<pubDate>Thu, 08 Mar 2018 14:31:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/8531281.html</dc:identifier>
</item>
<item>
<title>Hibernate【缓存】知识要点 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8531284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8531284.html</guid>
<description>&lt;p&gt;Hibernate中对象的状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;临时/瞬时状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;游离状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;学习Hibernate的对象状态是&lt;strong&gt;为了更清晰地知道Hibernate的设计思想，以及是一级缓存的基础&lt;/strong&gt;...当然啦，也就一点点知识&lt;/p&gt;
&lt;h2 id=&quot;临时瞬时状态&quot;&gt;临时/瞬时状态&lt;/h2&gt;
&lt;p&gt;当我们&lt;strong&gt;直接new出来的对象就是临时/瞬时状态的&lt;/strong&gt;..&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;该对象还没有被持久化【没有保存在数据库中】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不受Session的管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507155432248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;持久化状态&quot;&gt;持久化状态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当保存在数据库中的对象就是持久化状态了&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;当调用session的save/saveOrUpdate/get/load/list等方法的时候，对象就是持久化状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在数据库有对应的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;受Session的管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当对对象属性进行更改的时候，会反映到数据库中!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507155701246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来测试一下：&lt;strong&gt;当对对象属性进行更改的时候，会反映到数据库中!&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        session.&lt;span class=&quot;fu&quot;&gt;save&lt;/span&gt;(idCard);
        idCard.&lt;span class=&quot;fu&quot;&gt;setIdCardName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是测试持久化对象&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507155938113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;游离状态&quot;&gt;游离状态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当Session关闭了以后，持久化的对象就变成了游离状态了...&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不处于session的管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库中有对应的记录&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507160440421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Hibernate有一级缓存和二级缓存之分，这里主要讲解一级缓存&lt;/p&gt;
&lt;h2 id=&quot;什么是一级缓存&quot;&gt;什么是一级缓存？&lt;/h2&gt;
&lt;p&gt;Hibenate中一级缓存，也叫做session的缓存，&lt;strong&gt;它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Session的缓存由hibernate维护，&lt;strong&gt;用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么要是使用缓存&quot;&gt;为什么要是使用缓存？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;减少对数据库的访问次数！从而提升hibernate的执行效率！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;我们来看一下Hibernate是怎么减少对数据库访问的次数的。&lt;/p&gt;
&lt;p&gt;现在我的User表有这么一条记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507163030013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;co&quot;&gt;//把数据放进cache&lt;/span&gt;
        User user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;//发现要修改的字段和cache一样，不执行&lt;/span&gt;
        user.&lt;span class=&quot;fu&quot;&gt;setUserName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;你好2&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507163244081?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507163332920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取数据也是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507163539459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;缓存相关的方法&quot;&gt;缓存相关的方法&lt;/h2&gt;
&lt;p&gt;和缓存有关常用的方法有三个：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;//清除缓存，那么下面获取的时候，就不能从缓存里面拿了&lt;/span&gt;
        session.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在有缓存的情况下，修改同一条记录的数据，以最后的为准...因此只有一条update&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

        user.&lt;span class=&quot;fu&quot;&gt;setUserName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是第一&quot;&lt;/span&gt;);
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setUserName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是第二&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507164907260?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我让&lt;strong&gt;强制让它和数据库同步&lt;/strong&gt;的话，就有两条update了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        User user = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

        user.&lt;span class=&quot;fu&quot;&gt;setUserName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是第一&quot;&lt;/span&gt;);
        session.&lt;span class=&quot;fu&quot;&gt;flush&lt;/span&gt;();
        user = (User) session.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setUserName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是第二&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507165058418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般地，我们在&lt;strong&gt;批处理的时候会用&lt;/strong&gt;，因为&lt;strong&gt;缓存也是有大小的，如果1000条数据插入进去都要缓存，那么Hibernate可能就崩了&lt;/strong&gt;...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;每隔一定记录数，先与数据库同步 flush()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再清空缓存 clear()&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是：&lt;strong&gt;不同的Session是不会共享缓存的！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iterator与list&quot;&gt;Iterator与list&lt;/h2&gt;
&lt;p&gt;我们使用HQL查询全部数据的时候，&lt;strong&gt;可以使用list()得到所有的数据，也可以使用iterator()得到一个迭代器，再遍历迭代器&lt;/strong&gt;...那它们有什么区别呢？&lt;/p&gt;
&lt;p&gt;。。。。当时看视频的时候说是下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507171837940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我在测试的时候：&lt;strong&gt;List也可以获取缓存的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507171927100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然啦，Iterator也是可以获取缓存的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507172026569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;在获取数据的时候还是使用list()方便！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;懒加载就是当使用数据的时候才去获取数据、执行对应的SQL语句&lt;/strong&gt;...&lt;strong&gt;当还没用到数据的时候，就不加载对应的数据!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要目的就是为了&lt;strong&gt;提高Hibernate的性能，提高执行效率&lt;/strong&gt;！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;get: 及时加载，只要调用get方法立刻向数据库查询&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;load:默认使用懒加载，当用到数据的时候才向数据库查询。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;懒加载再次体验&quot;&gt;懒加载再次体验&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        User user = (User) session.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(User.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);

        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;________&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(user);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507184812421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在对应的&lt;strong&gt;配置文件用通常lazy属性来设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭懒加载：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;class&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;IdCard&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; table=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;IdCard&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lazy=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507185047318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;lazy有三个属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;true 使用懒加载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;false 关闭懒加载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extra (在集合数据懒加载时候提升效率)【只有在set、list等集合标签中使用】&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在真正使用数据的时候才向数据库发送查询的sql；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果调用集合的size()/isEmpty()方法，只是统计，不真正查询数据！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;懒加载异常&quot;&gt;懒加载异常&lt;/h2&gt;
&lt;p&gt;当Session关闭后，就不能使用懒加载了，否则会报出异常&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
Exception in thread &lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt; org.&lt;span class=&quot;fu&quot;&gt;hibernate&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;LazyInitializationException&lt;/span&gt;: could not initialize proxy - no Session&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170507185806446?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报出了这个异常，我们有4种方法解决：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方式1： 先使用一下数据
&lt;ul&gt;&lt;li&gt;dept.getDeptName();&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方式2：强迫代理对象初始化
&lt;ul&gt;&lt;li&gt;Hibernate.initialize(dept);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方式3：关闭懒加载
&lt;ul&gt;&lt;li&gt;设置lazy=false;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方式4： 在使用数据之后，再关闭session！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面我们已经讲解过了一级缓存，&lt;strong&gt;一级缓存也就是Session缓存，只在Session的范围内有效&lt;/strong&gt;...作用时间就在Session的作用域中，&lt;strong&gt;范围比较小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hibernate为我们提供了二级缓存功能：&lt;strong&gt;二级缓存是基于应用程序的缓存，所有的Session都可以使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hibernate提供的二级缓存有默认的实现，且是一种&lt;strong&gt;可插配的缓存框架&lt;/strong&gt;！如果用户想用二级缓存，&lt;strong&gt;只需要在hibernate.cfg.xml中配置即可&lt;/strong&gt;； 不想用，直接移除，不影响代码。&lt;/li&gt;
&lt;li&gt;如果用户觉得hibernate提供的框架框架不好用，&lt;strong&gt;自己可以换其他的缓存框架或自己实现缓存框架都可以&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170508165832948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hibernate二级缓存：&lt;strong&gt;存储的是常用的类&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;配置二级缓存&quot;&gt;配置二级缓存&lt;/h2&gt;
&lt;p&gt;既然二级缓存是Hibernate自带的，那么我们可以&lt;strong&gt;在hibernate.properties文件中找到对应的信息&lt;/strong&gt;..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170508170321970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;hibernate.cache.use_second_level_cache false【二级缓存默认不开启，需要手动开启】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hibernate.cache.use_query_cache true 【开启查询缓存】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;choose a cache implementation 【二级缓存框架的实现】&lt;/li&gt;
&lt;li&gt;hibernate.cache.provider_class org.hibernate.cache.EhCacheProvider&lt;/li&gt;
&lt;li&gt;hibernate.cache.provider_class org.hibernate.cache.EmptyCacheProvider&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hibernate.cache.provider_class org.hibernate.cache.HashtableCacheProvider 默认实现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;hibernate.cache.provider_class org.hibernate.cache.TreeCacheProvider&lt;/li&gt;
&lt;li&gt;hibernate.cache.provider_class org.hibernate.cache.OSCacheProvider&lt;/li&gt;
&lt;li&gt;hibernate.cache.provider_class org.hibernate.cache.SwarmCacheProvider&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过配置文件我们可以发现，二级缓存默认是不开启的，需要我们手动开启，以下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1)开启二级缓存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2)指定缓存框架&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3)指定哪些类加入二级缓存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;开启二级缓存&quot;&gt;&lt;strong&gt;开启二级缓存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在hibernate.cfg.xml文件中开启二级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- a.  开启二级缓存 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hibernate.cache.use_second_level_cache&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;指定缓存框架&quot;&gt;&lt;strong&gt;指定缓存框架&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;指定Hibernate自带的二级缓存框架就好了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- b. 指定使用哪一个缓存框架(默认提供的) --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hibernate.cache.provider_class&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;org.hibernate.cache.HashtableCacheProvider&lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;指定哪些类加入二级缓存&quot;&gt;&lt;strong&gt;指定哪些类加入二级缓存&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- c. 指定哪一些类，需要加入二级缓存 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;class-cache&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; usage=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;read-write&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng.aa.Monkey&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;class-cache&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; usage=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;read-only&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng.aa.Cat&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;我们知道一级缓存是Session的缓存，那么我们在&lt;strong&gt;测试二级缓存的时候使用两个Session来测试就好了&lt;/strong&gt;。如果第二个Session拿到的是缓存数据，那么就证明二级缓存是有用的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package zhongfucheng.aa;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.hibernate.SessionFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.hibernate.Transaction;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.hibernate.cfg.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.hibernate.classic.Session;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; App5 {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {


        &lt;span class=&quot;co&quot;&gt;//获取加载配置管理类&lt;/span&gt;
        Configuration configuration = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Configuration();
        &lt;span class=&quot;co&quot;&gt;//加载类对应的映射文件！&lt;/span&gt;
        configuration.&lt;span class=&quot;fu&quot;&gt;configure&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;addClass&lt;/span&gt;(Animal.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//创建Session工厂对象&lt;/span&gt;
        SessionFactory factory = configuration.&lt;span class=&quot;fu&quot;&gt;buildSessionFactory&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//得到Session对象&lt;/span&gt;
        Session session1 = factory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//使用Hibernate操作数据库，都要开启事务,得到事务对象&lt;/span&gt;
        Transaction transaction = session1.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//开启事务&lt;/span&gt;
        transaction.&lt;span class=&quot;fu&quot;&gt;begin&lt;/span&gt;();
        Monkey monkey = (Monkey) session1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Monkey.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;40283f815be67f42015be67f43240001&quot;&lt;/span&gt; );
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(monkey.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-----------------------&quot;&lt;/span&gt;);



        Session session2 = factory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        Transaction transaction2 = session2.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;();
        transaction2.&lt;span class=&quot;fu&quot;&gt;begin&lt;/span&gt;();
        Monkey monkey2 = (Monkey) session1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Monkey.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;40283f815be67f42015be67f43240001&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(monkey2.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());


        &lt;span class=&quot;co&quot;&gt;//提交事务&lt;/span&gt;
        transaction.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        transaction2.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//关闭Session&lt;/span&gt;
        session1.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        session2.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();


    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的是缓存数据！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170508173204744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;缓存策略&quot;&gt;缓存策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我们在把Animal类放进二级缓存的时候，用法为只读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170508181114768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，只能读取，不能写入，我们来看看写入会怎么样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
  monkey2.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;小猴子&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;抛出了异常....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170508181231520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;usage的属性有4种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;class-cache usage=&quot;read-only&quot;/&amp;gt;&lt;/code&gt; 放入二级缓存的对象，只读;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;class-cache usage=&quot;nonstrict-read-write&quot;/&amp;gt;&lt;/code&gt; 非严格的读写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;class-cache usage=&quot;read-write&quot;/&amp;gt;&lt;/code&gt; 读写； 放入二级缓存的对象可以读、写；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;class-cache usage=&quot;transactional&quot;/&amp;gt;&lt;/code&gt; (基于事务的策略)&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;集合缓存&quot;&gt;集合缓存&lt;/h2&gt;
&lt;p&gt;如果我们在数据库查询的数据是集合...&lt;strong&gt;Hibernate默认是没有为集合数据设置二级缓存的&lt;/strong&gt;...因此还是需要去读写数据库的信息&lt;/p&gt;
&lt;p&gt;接下来，我们就看看把集合设置为二级缓存是什么做的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在hibernate.cgf.xml中配置对象中的集合为二级缓存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 集合缓存[集合缓存的元素对象，也加加入二级缓存] --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;collection-cache&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; usage=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;read-write&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; collection=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cn.itcast.b_second_cache.Dept.emps&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;测试代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testCache&lt;/span&gt;() {
        Session session1 = sf.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        session1.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// a. 查询一次&lt;/span&gt;
        Dept dept = (Dept) session1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Dept.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;);
        dept.&lt;span class=&quot;fu&quot;&gt;getEmps&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;// 集合&lt;/span&gt;
        session1.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        session1.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;// 第二个session&lt;/span&gt;
        Session session2 = sf.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        session2.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// a. 查询一次&lt;/span&gt;
        dept = (Dept) session2.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Dept.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// 二级缓存配置好； 这里不查询数据库&lt;/span&gt;
        dept.&lt;span class=&quot;fu&quot;&gt;getEmps&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();
        
        session2.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        session2.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;查询缓存&quot;&gt;查询缓存&lt;/h2&gt;
&lt;p&gt;list()和iterator()会把数据放在一级缓存，但一级缓存只在Session的作用域中有效...如果想&lt;strong&gt;要跨Session来使用，就要设置查询缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在配置文件中还看到了&lt;strong&gt;查询缓存这么一条配置&lt;/strong&gt;..&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;    #hibernate.cache.use_query_cache true      【开启查询缓存】&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，&lt;strong&gt;默认的查询数据是不放在二级缓存中的&lt;/strong&gt;，如果我们想要把查询出来的数据放到二级缓存，就需要&lt;strong&gt;在配置文件中开启&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 开启查询缓存 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hibernate.cache.use_query_cache&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在使用程序查询的时候，也要调用setCacheable()方法，设置为查询缓存。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;listCache&lt;/span&gt;() {
        Session session1 = sf.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        session1.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// HQL查询  【setCacheable  指定从二级缓存找，或者是放入二级缓存】&lt;/span&gt;
        Query q = session1.&lt;span class=&quot;fu&quot;&gt;createQuery&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;from Dept&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;setCacheable&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(q.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;());
        session1.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        session1.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        
        
        Session session2 = sf.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        session2.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();
        q = session2.&lt;span class=&quot;fu&quot;&gt;createQuery&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;from Dept&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;setCacheable&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(q.&lt;span class=&quot;fu&quot;&gt;list&lt;/span&gt;());  &lt;span class=&quot;co&quot;&gt;// 不查询数据库： 需要开启查询缓存&lt;/span&gt;
        session2.&lt;span class=&quot;fu&quot;&gt;getTransaction&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        session2.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 08 Mar 2018 14:31:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8531284.html</dc:identifier>
</item>
</channel>
</rss>