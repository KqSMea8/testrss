<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>flask连接sqlalchemy数据库,实现简单的登录跳转功能 - 不爱贞子爱爽子</title>
<link>http://www.cnblogs.com/shuangzikun/p/taotao_python_flask_login.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuangzikun/p/taotao_python_flask_login.html</guid>
<description>&lt;p&gt; 环境：python2.7&lt;/p&gt;
&lt;p&gt;python库：flask,flask_wtf,wtforms,sqlalchemy&lt;/p&gt;
&lt;p&gt;原理：运行app-连接数据库-打开登录页面-输入登录信息（错误-&amp;gt;提示错误信息；正确跳转新的search页面）&lt;/p&gt;
&lt;p&gt;贴上代码：&lt;/p&gt;
&lt;p&gt;web.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt; web查询接口测试&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 需要登录-&amp;gt;输入关键字-&amp;gt;查询&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sqlalchemy &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;from&lt;/span&gt; sqlalchemy.orm &lt;span&gt;import&lt;/span&gt;&lt;span&gt; scoped_session, sessionmaker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##-----------连接数据库 type=mysql   user:password  localhost&lt;/span&gt;
db_connect_string = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql://root:root@127.0.0.1:3306/flask?charset=utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ssl_args &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ssl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home//ssl/client-cert.pem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/shouse/ssl/client-key.pem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ca&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/shouse/ssl/ca-cert.pem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
            }
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##创建引擎&lt;/span&gt;
engine = create_engine(db_connect_string, connect_args =&lt;span&gt;ssl_args)
SessionType &lt;/span&gt;= scoped_session(sessionmaker(bind=engine, expire_on_commit=&lt;span&gt;False))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##构建连接数据库函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_session():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SessionType
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###创建自动事务函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; contextlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; contextmanager
@contextmanager
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; session_scope():
    db &lt;/span&gt;=&lt;span&gt; get_session()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; db
        db.commit()
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        db.rollback()
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
    &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        db.close()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###-------创建数据库字段&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sqlalchemy.ext.declarative &lt;span&gt;import&lt;/span&gt;&lt;span&gt; declarative_base
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sqlalchemy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Column, Integer, String, ForeignKey, UniqueConstraint, Index
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sqlalchemy.orm &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sessionmaker, relationship
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sqlalchemy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; create_engine

Base &lt;/span&gt;=&lt;span&gt; declarative_base()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建单表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt; &lt;span&gt;
#&lt;/span&gt;&lt;span&gt;##账户表account&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account(Base):
    &lt;/span&gt;&lt;span&gt;__tablename__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;account&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    id &lt;/span&gt;= Column(Integer, primary_key=&lt;span&gt;True)
    name &lt;/span&gt;= Column(String(32&lt;span&gt;))
    pwd &lt;/span&gt;= Column(String(16&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##用户表account&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Users(Base):
    &lt;/span&gt;&lt;span&gt;__tablename__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;users&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    id &lt;/span&gt;= Column(Integer, primary_key=&lt;span&gt;True)
    name &lt;/span&gt;= Column(String(32&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;__table_args__&lt;/span&gt; =&lt;span&gt; (
        UniqueConstraint(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uix_id_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    )
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##地址account&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Address(Base):
    &lt;/span&gt;&lt;span&gt;__tablename__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    id &lt;/span&gt;= Column(Integer, primary_key=&lt;span&gt;True)
    address &lt;/span&gt;= Column(String(32&lt;span&gt;))
    phone &lt;/span&gt;=  Column(String(32&lt;span&gt;))
    user_id &lt;/span&gt;= Column(Integer, ForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;users.id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##创建表&lt;/span&gt;
&lt;span&gt;Base.metadata.create_all(engine)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#-----------------------------------分割线-------------------------------------##&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#####开始web脚本部分&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; flask
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask_wtf &lt;span&gt;import&lt;/span&gt;&lt;span&gt; FlaskForm
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; wtforms &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;from&lt;/span&gt; wtforms.fields &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (StringField, PasswordField,)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; wtforms.validators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DataRequired, Length
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, render_template, redirect,session
app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; os &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
d &lt;/span&gt;= path.dirname(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###定义SECRET_KEY保证安全性&lt;/span&gt;
app.config[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SECRET_KEY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;my web_test!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##定义登录表单字段&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;user, password,submit&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;再渲染到html页面&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginForm(FlaskForm):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Text Field类型，文本输入框，必填，用户名长度为4到25之间&lt;/span&gt;
    username = StringField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, validators=[DataRequired(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.请输入用户名！！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),Length(min=4, max=25,message=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入4-25个字符！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Text Field类型，密码输入框，必填，必须同confirm字段一致&lt;/span&gt;
    password = PasswordField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, validators=&lt;span&gt;[
        DataRequired(u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.请输入密码！！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        Length(min&lt;/span&gt;=4, max=25,message=u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入4-25个字符！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    ])
    submit &lt;/span&gt;= SubmitField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;####定义搜索页面字段&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;key, submit&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SearchForm(FlaskForm):
    key &lt;/span&gt;= StringField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,validators=&lt;span&gt;[
        DataRequired(),
        Length(min&lt;/span&gt;=4, max=255&lt;span&gt;)
    ])
    submit &lt;/span&gt;= SubmitField(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##定义登录控制器    允许访问的方式 get/post&lt;/span&gt;
@app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; LoginFormViews():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##示例登陆类&lt;/span&gt;
    form  =&lt;span&gt; LoginForm()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; flask.request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###get请求就显示表单页面，渲染字段-&amp;gt;login.html&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; render_template(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,form=&lt;span&gt;form)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print form.image.data   验证通过&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; form.validate_on_submit():
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##开始check 用户名和密码&lt;/span&gt;
            username  =&lt;span&gt;  form.username.data
            password &lt;/span&gt;=&lt;span&gt; form.password.data
            with session_scope() as db:
                list &lt;/span&gt;= db.query(Account).filter(Account.name==username, Account.pwd==&lt;span&gt;password).first()
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; list:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; list
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###把用户名记入session/cookies&lt;/span&gt;
                    session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; username
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print form.errors&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;##把错误信息返回到页面&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; render_template(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,form=form,error=&lt;span&gt;form.errors)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######search控制器&lt;/span&gt;
@app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; SearchFormViews():
    form  &lt;/span&gt;=&lt;span&gt; SearchForm()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; flask.request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###判断是否登录&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; session.has_key(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;return 'Logged in as %s' % session['username']&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; render_template(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;search.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,form=&lt;span&gt;form)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print form.image.data&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; form.validate_on_submit():
            key &lt;/span&gt;=&lt;span&gt; form.key.data
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###开始查询 字段&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print form.errors&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;##把错误信息返回到页面&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; render_template(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;search.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,form=form,error=&lt;span&gt;form.errors)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#####注销控制器&lt;/span&gt;
@app.route(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/logout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; logout():
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; flask.request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###开始注销当前用户&lt;/span&gt;
        session.pop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,None)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    app.run(host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, debug=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同一目录下新建templates文件夹存放静态文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1304696/201801/1304696-20180106154919518-663969994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;_formhelpers.html  配置文件，用来循环表单字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% macro render_field(field) %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;height:24px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.label }}:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {{ field(**kwargs)|safe }}
  {% if field.errors %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=errors &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:red&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% for error in field.errors %}
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ error }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'
    {% endfor %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {% endif %}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endmacro %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;login.html  登录文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin: 0 auto;width:200px; height: 40px; line-height: 40px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录系统&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    {% from &quot;_formhelpers.html&quot; import render_field %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;='/test/login' &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;='post' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='LoginFormViews' &lt;/span&gt;&lt;span&gt;enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{ form.hidden_tag() }}
        {#{ form.csrf_token }#} 
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{ render_field(form.username) }}
        {{ render_field(form.password) }}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   {{ form.submit }}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;search.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Form&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin: 0 auto;width:200px; height: 40px; line-height: 40px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;搜索({{session['username']}})&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;b &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/test/logout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;注销&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    {% from &quot;_formhelpers.html&quot; import render_field %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;='/test/news_form' &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;='post' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='NewsFormViews' &lt;/span&gt;&lt;span&gt;enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{ form.hidden_tag() }}
        {#{ form.csrf_token }#} 
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{ render_field(form.key) }}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   {{ form.submit }}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下次讲讲表单字段的使用，本次只是用了2种类型的字段，以及错误的提示信息。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 07:58:00 +0000</pubDate>
<dc:creator>不爱贞子爱爽子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuangzikun/p/taotao_python_flask_login.html</dc:identifier>
</item>
<item>
<title>Dubbo（三） 安装Zookeeper 单机-集群 - 望星辰大海</title>
<link>http://www.cnblogs.com/tohxyblog/p/8214419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tohxyblog/p/8214419.html</guid>
<description>&lt;h3 id=&quot;h3--zookeeper&quot;&gt;一、下载zookeeper&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;zookeeper下载地址：&lt;a href=&quot;https://www.apache.org/dyn/closer.cgi/zookeeper/&quot;&gt;https://www.apache.org/dyn/closer.cgi/zookeeper/&lt;/a&gt;&lt;br/&gt;&lt;a title=&quot;点击下载&quot; href=&quot;https://www.apache.org/dyn/closer.cgi/zookeeper/&quot;&gt;点击下载&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://www.droptb.com/rec/article/images/201712/png/20171204191455_476.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h3--&quot;&gt;二、启动配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;选择合适版本下载后解压到自己需要安装的目录，&lt;br/&gt;进入zookeeper目录下的conf子目录, 创建zoo.cfg:&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;h4--&quot;&gt;单机模式：&lt;/h4&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# tickTime: zookeeper中使用的基本时间单位, 毫秒值.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# dataDir: 数据目录. 可以是任意目录.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# clientPort: 监听client连接的端口号.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# dataLogDir: log目录, 同样可以是任意目录. 如果没有设置该参数, 将使用和dataDir相同的设置.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L6&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;tickTime=2000&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L7&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;dataDir=E:/zookeeper-3.3.6/build&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L8&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;clientPort=2181&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;h4--&quot;&gt;伪集群模式：&lt;/h4&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;tickTime=2000&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;initLimit=10&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;syncLimit=5&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;dataDir=E:/zookeeper-3.3.6/build&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L4&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# 第二三台机器另取端口&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L5&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;clientPort=2181&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L7&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;server.1=localhost:2887:3887&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L8&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;server.2=localhost:2888:3888&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L9&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;server.3=localhost:2889:3889&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# initLimit: zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower. initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# syncLimit: 该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code class=&quot;lang-xml&quot;&gt;&lt;span class=&quot;pln&quot;&gt;# server.X=A:B:C 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口. 由于配置的是伪集群模式, 所以各个server的B, C参数必须不同.&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此外： 各server的dataDir目录下的myid文件中的数字与上面配置文件中的X对应.（可以新建text文件，写好数字后去掉后缀！）&lt;/p&gt;
&lt;h3 id=&quot;h3--zookeeper&quot;&gt;三、启动zookeeper&lt;/h3&gt;

</description>
<pubDate>Sat, 06 Jan 2018 07:45:00 +0000</pubDate>
<dc:creator>望星辰大海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tohxyblog/p/8214419.html</dc:identifier>
</item>
<item>
<title>Java源码解读(一)——HashMap - 夜の魅</title>
<link>http://www.cnblogs.com/yuhanghzsd/p/8214358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuhanghzsd/p/8214358.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　HashMap作为常用的一种数据结构,阅读源码去了解其底层的实现是十分有必要的。在这里也分享自己阅读源码遇到的困难以及自己的思考。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashMap的源码介绍已经有许许多多的博客，这里只记录了一些我看源码过程中的疑问，一些基础知识不再讲解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一：Hash值的来源和使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;&amp;lt;&amp;lt; 无符号右移&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;strong&gt;    这里是put()方法，里面有一个调用hash(key)就是得到hash值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　如果key为null，则返回0。否则则返回 key的&lt;span&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/span&gt;（hashCode 异或 hashCode无符号右移16位），既二次散列，这么做的原因是为了尽可能的分散到桶（数组）各个位置，避免数据扎堆放在一个桶里面。提高HashMap运算效率。其中HashCode()是本地方法，不同的jvm会有不同的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　例 hashcode ：  0001 1000 0001 0001 1111 0001 0110 0000  ^ 0000 0000 0000 0000&lt;/strong&gt; 0001 1000 0001 0001 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　相当于hashCode()的高16位异或低16位。这样就相当于32位数据都参与到了Hash运算。这样使得hash更加散列，尽可能的桶寻址更分散。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　&lt;span&gt;　这里有专门的传送门http://blog.csdn.net/anxpp/article/details/51234835。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其实按照我的理解，无符号&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;得到了key的hash值，又是如何运用的哪？下&lt;/strong&gt;&lt;/span&gt;面的代码不需要看那么多，如果有闲心可以看一看~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 在putVal()方法中第9行代码，if ((p = tab[i = (n - 1) &amp;amp; hash]) == null),通过（n-1 &amp;amp; hash）与运算得到下标位置，这就是根据hash值得到了桶(数组)的位置。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &amp;amp;操作同时也保证了不会数组越界，(n-1)是桶(数组)界限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;Hash算法本质上就是三步：&lt;/strong&gt;取key的hashCode值、高位运算、取模运算&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;table 是否为空，初始化或者加倍表的大小。&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;&lt;em&gt;&lt;strong&gt;  //i = (n - 1) &amp;amp; hash ,计算出来下标，这个下标为空，说明没有被占用，直接newNode.
 8         //没有发生Hash碰撞
 9         if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断table[i]的首个元素是否和key一样，如果相同直接覆盖value,相同 e = p;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;15&lt;/span&gt;                 ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该链为链表
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历table[i]，判断链表长度是否大于TREEIFY_THRESHOLD(默认值为8)，
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入链表&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否转为红黑树&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                            treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;33&lt;/span&gt;                         ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     p = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入下一个节点&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         ++&lt;span&gt;modCount;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度是否超过当前允许的最大值，重新设置大小&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            resize();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        afterNodeInsertion(evict);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　如果对hashCode感兴趣的话，可以开这个门https://www.cnblogs.com/dolphin0520/p/3681042.html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二 HashMap的扩容resize()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　看代码就是一个循序渐进的过程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;　我们知道桶(数组)的下标是根据(n-1)&amp;amp;hash得到的，当HashMap扩容后(n-1)就会发生变化啊，这样不就会扩容后寻不到&lt;strong&gt;下标&lt;/strong&gt;了吗？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;没错，这是一个很简单的问题，但是我看的时候没有看全就回家了，在地铁上想了一路怎么解决，然后猜测是扩容后会重新把所有数据在计算一遍。回到家后，我就去看代码对这个想法进行验证。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　确实如此，所以我觉得扩容真心费劲。这里贴一下resize()方法。比较长~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　从第30行就开始处理数据，使其根据新的容量(n-1)重新分配下标。当然，分配也不是漫无目的的：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　在第56，57行代码中中:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;  Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;//没有改变索引位置的记录loHead【链表】，loTail 当前链表的尾节点
  Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;//改变索引位置的记录hiHead【链表】，hiTail 当前链表的尾节点&lt;br/&gt;　一个原来数据重新分配后，只有两个位置可以去~&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;原封不动的还在原来下标&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;newTab[j]&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;换新的下标，但是位置是固定的&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;newTab[j + oldCap]&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;这是什么原因导致的那?&lt;br/&gt;　　我们知道，HashMap的桶(数组)扩容是扩容为原来的两倍 &lt;/strong&gt;&lt;/span&gt;(newCap = oldCap &amp;lt;&amp;lt; 1)。也就是说，原来的&lt;strong&gt;(n-1)是1111,现在成了1 1111 ，而key的hash是不会变的。&lt;/strong&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;　　两者再次进行&amp;amp;运算，要么，多一个高位1。要么不变。例如：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/703717/201801/703717-20180106145328737-705091819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;每次扩容都会将全部元素计算一遍，所以扩容的开销还是很大的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　一篇传送门，如果不是很懂，可以看这里~http://blog.csdn.net/bnmb888/article/details/77164485&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 2&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0 : oldTab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到原数组（哈希桶）长度&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldThr = threshold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来所能容纳的key-value对极限，阈值。&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的长度，新的阈值。&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超过了hashMap最大（哈希桶）容量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }   
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左移，小于最大值且&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                      oldCap &amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 newThr = oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold 左移一位&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold 哈希桶长度为0，且初始化HashMap时设置了长度&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             newCap =&lt;span&gt; oldThr;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
&lt;span&gt;24&lt;/span&gt;                       (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                         ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;, newTab, j, oldCap);
&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order(保持次序) 
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成“原索引+oldCap”,即newTab[j + oldCap]&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                         *  示例1：
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                             e.hash=10   0000 1010
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                             oldCap=16-1 0000 1111&lt;br/&gt;　　　　　　　　　　　　　　　　　　 newCap=32-1 0001 1111
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                               &amp;amp;old=0    0000 1010       比较高位的第一位 &lt;br/&gt;　　　　　　　　　　　　　　　　　　　  &amp;amp;new=0   0000 1010
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            结论：元素位置在扩容后数组中的位置没有发生改变    放入 loHead
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 　　　　　　　　　　
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                             示例2：
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                             e.hash=17   0001 0001
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                             oldCap=16-1 0000 1111&lt;br/&gt;　　　　　　　　　　　　　　　　　　 newCap=32-1 0001 1111
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                              &amp;amp;old =0    0000 0001      比较高位的第一位 &lt;br/&gt;　　　　　　　　　　　　　　　　　　　&amp;amp;new =1     0001 0001
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                            结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是[原下标位置+原数组长度]  放入 hiHead
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                         * 
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有改变索引位置的记录loHead【链表】，loTail 当前链表的尾节点&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变索引位置的记录hiHead【链表】，hiTail 当前链表的尾节点&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                             next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 索引还是原索引&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如：oldCap 是 16，即二进制 1 0000 ，（1111），相与，可以判断e.hash的高位是否是0。为0则进入if语句&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;loHead链表首位为null&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;                                     loHead = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表首位放入e&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                                     loTail.next = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依次放入节点，保持次序。&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;                                 loTail = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录当前节点位置&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引改为 【原索引+oldCap】&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                                     hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;                                     hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                                 hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;                         } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原索引位置放入整个loHead链表&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                             loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                             newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原索引+oldCap位置放入整个hiHead链表&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                             hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;                             newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三 HashMap的红黑树操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　J&lt;strong&gt;DK1.8以后，当HashMap的链表过长时(&lt;span&gt;TREEIFY_THRESHOLD = 8&lt;/span&gt;;)，会将链表转化为红黑树。在putVal()方法中有介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;　　当链表(&lt;/em&gt;&lt;/strong&gt;UNTREEIFY_THRESHOLD = 6&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;&lt;em&gt;)会将其拆分，但是仅仅是在resize()的时候会有这一步操作，remove并不会。&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;38行：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;　((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;该方法描述为:调整树结构，树太小拆分掉。 仅从调整大小的时候调用;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个方法是寻找树节点　&lt;/strong&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt; 　　　　final TreeNode&amp;lt;K,V&amp;gt; getTreeNode(int h, Object k) {&lt;/p&gt;
&lt;p&gt;            //当前节点的父节点是否为null， 不为null，寻找根结点（root()）,为null，当前即为根结点 &lt;/p&gt;
&lt;p&gt;            return ((parent != null) ? root() : this).find(h, k, null);&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; find(&lt;span&gt;int&lt;/span&gt; h, Object k, Class&amp;lt;?&amp;gt;&lt;span&gt; kc) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是调用这个方法的对象
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getTreeNode(int h, Object k), p是root对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             TreeNode&amp;lt;K,V&amp;gt; p = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ph, dir; K pk;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 TreeNode&amp;lt;K,V&amp;gt; pl = p.left, pr =&lt;span&gt; p.right, q;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash值，对于任何给定的object，hash值是相同的&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt; h) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前节点hash值大于寻找的哈希值，寻找左孩子&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                     p =&lt;span&gt; pl;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt; h)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前节点hash值小于寻找的哈希值，寻找右孩子&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                     p =&lt;span&gt; pr;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((pk = p.key) == k || (k != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; k.equals(pk)))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash值相同，key值相同，返回该节点p&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pl == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值不同，左孩子为null(红黑树的叶子节点)，p改为右孩子。红黑树中，为null说明已经到达叶子节点，所以转向pr&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                     p =&lt;span&gt; pr;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pr == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key值不同，右孩子为null(红黑树的叶子节点)，p改为左孩子。&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                     p =&lt;span&gt; pl;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc != &lt;span&gt;null&lt;/span&gt; ||  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义的比较（实现comparable接口的类&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                           (kc = comparableClassFor(k)) != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object k（map的key）是否实现了comparable接口，是的话返回该实现类&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                          (dir = compareComparables(kc, k, pk)) != 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在kc类中 调用k.compareTo(pk),自定义方法，根据返回值决定去左孩子还是右孩子&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                     p = (dir &amp;lt; 0) ?&lt;span&gt; pl : pr;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((q = pr.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash值相同，key值不同且左孩子右孩子都存在，递归find右孩子&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hash值相同，key值不同且左孩子右孩子都存在，右孩子没有找到，find左孩子&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                     p =&lt;span&gt; pl;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否到叶子节点，红黑树叶子节点均为null&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;更多的HashMap知识，以后有空会继续更新。Java源码所写的注释，上传到了GitHub。&lt;/strong&gt;会持续更新注释内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;https://github.com/coldwindYBMC/Java_source&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　https://i.cnblogs.com/EditPosts.aspx?postid=8214358&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 06 Jan 2018 07:25:00 +0000</pubDate>
<dc:creator>夜の魅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuhanghzsd/p/8214358.html</dc:identifier>
</item>
<item>
<title>Python 项目实践三（Web应用程序）第五篇 - GodChao</title>
<link>http://www.cnblogs.com/majianchao/p/8214197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/majianchao/p/8214197.html</guid>
<description>&lt;p&gt; 接着上节继续学习，在这一节，我们将建立一个用户注册和身份验证系统，让用户能够注册账户，进而登录和注销。我们将创建一个新的应用程序，其中包含与处理用户账户相关的所有功能。我们还将对模型Topic稍做修改，让每个主题都归属于特定用户。&lt;/p&gt;
&lt;p&gt;一 创建用户账号&lt;/p&gt;
&lt;p&gt;1 应用程序users&lt;/p&gt;
&lt;p&gt;我们首先使用命令startapp来创建一个名为users的应用程序：(ll_env)learning_log$ python manage.py startapp users&lt;/p&gt;
&lt;p&gt;1.1 将应用程序users添加到settings.py中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
INSTALLED_APPS = (
--snip--
# 我的应用程序
'learning_logs',
'users',
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，Django将把应用程序users包含到项目中。&lt;/p&gt;
&lt;p&gt;1.2 包含应用程序users的URL&lt;/p&gt;
&lt;p&gt;接下来，我们需要修改项目根目录中的urls.py，使其包含我们将为应用程序users定义的URL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from django.conf.urls import include, url
from django.contrib import admin
urlpatterns = [
url(r'^admin/', include(admin.site.urls)),
url(r'^users/', include('users.urls', namespace='users')),
url(r'', include('learning_logs.urls', namespace='learning_logs')),
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3 登录页面&lt;/p&gt;
&lt;p&gt;我们首先来实现登录页面的功能。为此，我们将使用Django提供的默认登录视图，因此URL模式会稍有不同。在目录learning_log/users/中，新建一个名为urls.py的文件，并在其中添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&quot;&quot;&quot;为应用程序users定义URL模式&quot;&quot;&quot;
from django.conf.urls import url
from django.contrib.auth.views import login
from . import views

app_name='users'
urlpatterns = [
        # 登录页面
        url(r'^login/$', login, {'template_name': 'users/login.html'},name='login'),
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4 模板login.html&lt;/p&gt;
&lt;p&gt;以下是模板login.html，你应将其存储到目录learning_log/users/templates/users/中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
{% extends &quot;learning_logs/base.html&quot; %}

{% block content %}

  {% if form.errors %}
  &amp;lt;p&amp;gt;Your username and password didn't match. Please try again.&amp;lt;/p&amp;gt;
  {% endif %}
  
  &amp;lt;form method=&quot;post&quot; action=&quot;{% url 'users:login' %}&quot;&amp;gt;
  {% csrf_token %}
  {{ form.as_p }}
  &amp;lt;button name=&quot;submit&quot;&amp;gt;log in&amp;lt;/button&amp;gt; 
  &amp;lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;{% url 'learning_logs:index' %}&quot; /&amp;gt;
  &amp;lt;/form&amp;gt;
  
 {% endblock content %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.5 链接到登录界面&lt;/p&gt;
&lt;p&gt;下面在base.html中添加到登录页面的链接，让所有页面都包含它。用户已登录时，我们不想显示这个链接，因此将它嵌套在一个{% if %}标签中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;p&amp;gt;
  &amp;lt;a href=&quot;{% url 'learning_logs:index' %}&quot;&amp;gt;Learning Log&amp;lt;/a&amp;gt; -
  &amp;lt;a href=&quot;{% url 'learning_logs:topics' %}&quot;&amp;gt;Topics&amp;lt;/a&amp;gt;
  {% if user.is_authenticated %}
    Hello, {{ user.username }}.
  {% else %}
    &amp;lt;a href=&quot;{% url 'users:login' %}&quot;&amp;gt;log in&amp;lt;/a&amp;gt;
  {% endif %}
&amp;lt;/p&amp;gt;
{% block content %}{% endblock content %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.6 使用登录界面&lt;br/&gt;请访问http://localhost:8000/admin/，如果你依然是以管理员的身份登录的，请在页眉上找到注销链接并单击它。注销后，访问http://localhost:8000/users/login/，你将看到类似于图19-4所示的登录页面。输入你在前面设置的用户名和密码，将进入页面index。。在这个主页的页眉中，显示了一条个性化问候语，其中包含你的用户名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106130213159-90214395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 注册和注销界面&lt;/p&gt;
&lt;p&gt;和上面方法大概相同，就不在赘述，效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106133211159-714653291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106133237190-1158361406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二 让用户拥有自己的数据&lt;/p&gt;
&lt;p&gt;用户应该能够输入其专有的数据，因此我们将创建一个系统，确定各项数据所属的用户，再限制对页面的访问，让用户只能使用自己的数据。在本节中，我们将修改模型Topic，让每个主题都归属于特定用户。这也将影响条目，因为每个条目都属于特定的主题。我们先来限制对一些页面的访问。&lt;/p&gt;
&lt;p&gt;1 使用@login_required 限制访问&lt;/p&gt;
&lt;p&gt;Django提供了装饰器@login_required，让你能够轻松地实现这样的目标：对于某些页面，只允许已登录的用户访问它们。装饰器（decorator）是放在函数定义前面的指令，Python在函数运行前，根据它来修改函数代码的行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
--snip--
from django.core.urlresolvers import reverse
from django.contrib.auth.decorators import login_required
from .models import Topic, Entry
--snip--
@login_required
def topics(request):
&quot;&quot;&quot;显示所有的主题&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们首先导入了函数login_required()。我们将login_required()作为装饰器用于视图函数topics()——在它前面加上符号@和login_required，让Python在运行topics()的代码前先运行login_required()的代码。login_required()的代码检查用户是否已登录，仅当用户已登录时，Django才运行topics()的代码。如果用户未登录，就重定向到登录页面。&lt;/p&gt;
&lt;p&gt;2 全面限制对项目“学习笔记”的访问&lt;/p&gt;
&lt;p&gt;在项目“学习笔记”中，我们将不限制对主页、注册页面和注销页面的访问，并限制对其他所有页面的访问。&lt;br/&gt;在 下 面的learning_logs/views.py 中， 对除index() 外的每个视图都应用了装饰器@login_required：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
@login_required
def topics(request):
--snip--
@login_required
def topic(request, topic_id):
--snip--
@login_required
def new_topic(request):
--snip--
@login_required
def new_entry(request, topic_id):
--snip--
@login_required
def edit_entry(request, entry_id):
--snip--
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3 将数据关联到用户&lt;/p&gt;
&lt;p&gt;现在，需要将数据关联到提交它们的用户。我们只需将最高层的数据关联到用户，这样更低层的数据将自动关联到用户。例如，在项目“学习笔记”中，应用程序的最高层数据是主题，而所有条目都与特定主题相关联。只要每个主题都归属于特定用户，我们就能确定数据库中每个条目的所有者。&lt;/p&gt;
&lt;p&gt;下面来修改模型Topic，在其中添加一个关联到用户的外键。这样做后，我们必须对数据库进行迁移。最后，我们必须对有些视图进行修改，使其只显示与当前登录的用户相关联的数据。&lt;/p&gt;
&lt;p&gt;4 确定当前有哪些用户&lt;/p&gt;
&lt;p&gt;我们迁移数据库时，Django将对数据库进行修改，使其能够存储主题和用户之间的关联，下面来查看已创建的所有用户的ID。为此，启动一个Django shell会话，并执行如下命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106141548206-1291836677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 迁移数据库&lt;/p&gt;
&lt;p&gt;知道用户ID后，就可以迁移数据库了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106141823534-1881710822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在可以执行迁移了。为此，在活动的虚拟环境中执行下面的命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106142011253-820904275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证迁移是否成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1080659/201801/1080659-20180106142330706-2082649926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来的保护用户主题，保护页面，将新主题关联到当前用户等就不再详细说了！今天先学到这里！&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 06:43:00 +0000</pubDate>
<dc:creator>GodChao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/majianchao/p/8214197.html</dc:identifier>
</item>
<item>
<title>SLAM入门之视觉里程计(4)：基础矩阵的估计 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/8214032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/8214032.html</guid>
<description>&lt;p&gt;在上篇文章中，介绍了三位场景中的同一个三维点在不同视角下的像点存在着一种约束关系：&lt;strong&gt;对极约束&lt;/strong&gt;，&lt;strong&gt;基础矩阵&lt;/strong&gt;是这种约束关系的代数表示，并且这种约束关系独立与场景的结构，只依赖与相机的内参和外参（相对位姿）。这样可以通过通过匹配的像点对计算出两幅图像的基础矩阵，然后分解基础矩阵得到相机的相对位姿。&lt;/p&gt;
&lt;h2 id=&quot;通过匹配点对估算基础矩阵&quot;&gt;通过匹配点对估算基础矩阵&lt;/h2&gt;
&lt;p&gt;基础矩阵表示的是图像中的像点&lt;span class=&quot;math inline&quot;&gt;\(p_1\)&lt;/span&gt;到另一幅图像对极线&lt;span class=&quot;math inline&quot;&gt;\(l_2\)&lt;/span&gt;的映射，有如下公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ l_2 = Fp_1 \]&lt;/span&gt;&lt;br/&gt;而和像点&lt;span class=&quot;math inline&quot;&gt;\(P_1\)&lt;/span&gt;匹配的另一个像点&lt;span class=&quot;math inline&quot;&gt;\(p_2\)&lt;/span&gt;必定在对极线&lt;span class=&quot;math inline&quot;&gt;\(l_2\)&lt;/span&gt;上，所以就有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p_2^Tl_2 = p_2^TFp_1 = 0 \]&lt;/span&gt;&lt;br/&gt;这样仅通过匹配的点对，就可以计算出两视图的基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;。&lt;br/&gt;基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;是一个&lt;span class=&quot;math inline&quot;&gt;\(3\times3\)&lt;/span&gt;的矩阵，有9个未知元素。然而，上面的公式中使用的齐次坐标，齐次坐标在相差一个常数因子下是相等，&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;也就只有8个未知元素，也就是说，只需要8对匹配的点对就可以求解出两视图的基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;。下面介绍下&lt;strong&gt;8点法 Eight-Point-Algorithm&lt;/strong&gt;计算基础矩阵的过程。&lt;/p&gt;
&lt;p&gt;假设一对匹配的像点&lt;span class=&quot;math inline&quot;&gt;\(p_1=[u_1,v_1,1]^T,p_2=[u_2,v_2,1]^T\)&lt;/span&gt;，带入式子中，得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ [u_1,v_1,1]\left[\begin{array}{ccc}f_1&amp;amp;f_2&amp;amp;f_3\\f_4&amp;amp;f_5&amp;amp;f_6\\f_7&amp;amp;f_8&amp;amp;f_9\end{array}\right] \left[\begin{array}{c}u_2\\v_2\\1\end{array}\right] = 0 \]&lt;/span&gt;&lt;br/&gt;把基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的各个元素当作一个向量处理&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f = [f_1,f_2,f_3,f_4,f_5,f_6,f_7,f_8,f_9] \]&lt;/span&gt;&lt;br/&gt;那么上面式子可以写为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ [u_1u_2,u_1v_2,u_1,v_1u_2,v_1v_2,v_1,u_2,v_2,1]\cdot f = 0 \]&lt;/span&gt;&lt;br/&gt;对于其他的点对也使用同样的表示方法。这样将得到的所有方程放到一起，得到一个线性方程组(&lt;span class=&quot;math inline&quot;&gt;\((u^i,v^i)\)&lt;/span&gt;表示第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个特征点）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{array}{ccccccccc} u_1^1u_2^1&amp;amp;u_1^1v_2^1&amp;amp;u_1^1&amp;amp;v_1^1u_2^1&amp;amp;v_1^1v_2^1&amp;amp;v_1^1&amp;amp;u_2^1&amp;amp;v_2^1&amp;amp;1\\ u_1^2u_2^2&amp;amp;u_1^2v_2^2&amp;amp;u_1^2&amp;amp;v_1^2u_2^2&amp;amp;v_1^2v_2^2&amp;amp;v_1^2&amp;amp;u_2^2&amp;amp;v_2^2&amp;amp;1\\ u_1^3u_2^3&amp;amp;u_1^3v_2^3&amp;amp;u_1^3&amp;amp;v_1^3u_2^1&amp;amp;v_1^3v_2^1&amp;amp;v_1^3&amp;amp;u_2^3&amp;amp;v_2^3&amp;amp;1\\ \cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots&amp;amp;\cdots \\ u_1^8u_2^8&amp;amp;u_1^8v_2^8&amp;amp;u_1^8&amp;amp;v_1^8u_2^8&amp;amp;v_1^8v_2^8&amp;amp;v_1^8&amp;amp;u_2^8&amp;amp;v_2^8&amp;amp;1 \end{array} \right] \left[ \begin{array}{c} f_1\\f_2\\f_3\\f_4\\f_5\\f_6\\f_7\\f_8\\f_9 \end{array} \right]=0 \]&lt;/span&gt;&lt;br/&gt;求解上面的方程组就可以得到基础矩阵各个元素了。当然这只是理想中的情况，由于噪声、数值的舍入误差和错误的匹配点的影响，仅仅求解上面的线性方程组得到的基础矩阵非常的不稳定，因此在8点法的基础上有各种改进方法。&lt;/p&gt;
&lt;h3 id=&quot;图像坐标归一化-normalizing-transformation&quot;&gt;图像坐标归一化 Normalizing transformation&lt;/h3&gt;
&lt;p&gt;将上面公式中由匹配的点对坐标组成的矩阵记为系数矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Af = 0 \]&lt;/span&gt;&lt;br/&gt;系数矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;是利用8点法求基础矩阵的关键，所以Hartey就认为，利用8点法求基础矩阵不稳定的一个主要原因就是&lt;strong&gt;原始的图像像点坐标组成的系数矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;不好造成的&lt;/strong&gt;，而造成&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;不好的原因是&lt;strong&gt;像点的齐次坐标各个分量的数量级相差太大&lt;/strong&gt;。基于这个原因，Hartey提出一种改进的8点法，&lt;strong&gt;在应用8点法求基础矩阵之前，先对像点坐标进行归一化处理，即对原始的图像坐标做同向性变换&lt;/strong&gt;，这样就可以减少噪声的干扰，大大的提高8点法的精度。&lt;/p&gt;
&lt;p&gt;预先对图像坐标进行归一化有以下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能够提高运算结果的精度&lt;/li&gt;
&lt;li&gt;利用归一化处理后的图像坐标，对任何尺度缩放和原点的选择是不变的。归一化步骤预先为图像坐标选择了一个标准的坐标系中，消除了坐标变换对结果的影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;归一化操作分两步进行，首先对每幅图像中的坐标进行平移（每幅图像的平移不同）使图像中匹配的点组成的点集的形心（Centroid）移动到原点；接着对坐标系进行缩放是的点&lt;span class=&quot;math inline&quot;&gt;\(p=(x,y,w)^T\)&lt;/span&gt;中的各个分量总体上有一样的平均值，各个坐标轴的缩放相同的，最后选择合适的缩放因子使点&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;到原点的平均距离是&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{2}\)&lt;/span&gt;。 概括起来变换过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对点进行平移使其形心位于原点。&lt;/li&gt;
&lt;li&gt;对点进行缩放，使它们到原点的平均距离为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{2}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对两幅图像独立进行上述变换&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/439761/201801/439761-20180106135017768-420737829.png&quot;/&gt;&lt;br/&gt;上图左边是原始图像的坐标，右边是归一化后的坐标，&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;是归一化的变换矩阵，可记为如下形式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H = S\left[\begin{array}{ccc} 1&amp;amp;0&amp;amp;-\bar{\mu} \\0&amp;amp;1&amp;amp;-\bar{\nu}\\0&amp;amp;0&amp;amp;\frac{1}{S} \end{array}\right] \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\bar{\mu},\bar{\nu}\)&lt;/span&gt;是图像像点坐标两个分量的平均值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \bar{\mu} = \frac{1}{N}\sum_{i=1}^{N}\mu_i,\bar{\nu} = \frac{1}{N}\sum_{i=1}^{N}\nu_i \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;表示尺度，其表达式为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ S = \frac{\sqrt{2\cdot N}}{\sqrt{\sum_{i=1}^{N}(\mu_i-\bar{\mu})^2 + (\nu_i-\bar{\nu})^2}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样，首先对原始的图像坐标进行归一化处理，再利用8点法求解基础矩阵，最后将求得的结果解除归一化，得到基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;，总结如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对图像1进行归一化处理，计算一个只包含平移和缩放的变换&lt;span class=&quot;math inline&quot;&gt;\(H_1\)&lt;/span&gt;，将图像1中的匹配点集&lt;span class=&quot;math inline&quot;&gt;\({p_i^1}\)&lt;/span&gt;变换到新的点集&lt;span class=&quot;math inline&quot;&gt;\(\hat{p_i^1}\)&lt;/span&gt;，新点集的形心位于原点&lt;span class=&quot;math inline&quot;&gt;\((0,0)^T\)&lt;/span&gt;，并且它们到原点的平均距离是&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{2}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对图像2，计算变换矩阵&lt;span class=&quot;math inline&quot;&gt;\(H_2\)&lt;/span&gt;进行相同的归一化处理&lt;/li&gt;
&lt;li&gt;使用8点法利用变换后的点集估计基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(\hat{F}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;根据变换&lt;span class=&quot;math inline&quot;&gt;\(F = H_2^T\hat{F}H_1\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用归一化的坐标虽然能够在一定程度上消除噪声、错误匹配带来的影响，但还是不够的。&lt;/p&gt;
&lt;h3 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h3&gt;
&lt;p&gt;仅仅对图像坐标进行归一化处理，能在一定程度上提高计算的精度，但在实践中还是不够的。8点法中，只使用8对匹配的点对估计基础矩阵，但通常两幅图像的匹配的点对远远多于8对，可以利用更多匹配的点对来求解上面的方程。&lt;br/&gt;由于基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;在一个常量因子下是等价的，这样可以给基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的元素组成的向量&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;施加一个约束条件&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \parallel f \parallel = 1 \]&lt;/span&gt;&lt;br/&gt;这样由&lt;span class=&quot;math inline&quot;&gt;\(K \ge 8\)&lt;/span&gt;个匹配的点对，组合成一个矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q_{K\times9}\)&lt;/span&gt;，求解上面方程就变成了求解如下问题的最小二乘解&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \min_{\parallel f \parallel = 1}\parallel Qf \parallel ^2 \]&lt;/span&gt;&lt;br/&gt;其中，矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;的每一行来自一对匹配点；&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;是基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;元素构成的待求解的向量，根据2-范数的定义&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \parallel Qf \parallel^2 = (Qf)^T(Qf)=f^T(Q^TQ)f \]&lt;/span&gt;&lt;br/&gt;将上式的中间部分提取出来得到矩阵&lt;span class=&quot;math inline&quot;&gt;\(M=Q^TQ\)&lt;/span&gt;,这是一个&lt;span class=&quot;math inline&quot;&gt;\(9\times9\)&lt;/span&gt;的矩阵。基于拉格朗日-欧拉乘数优化定理，在&lt;span class=&quot;math inline&quot;&gt;\(\parallel f \parallel = 1\)&lt;/span&gt;约束下，&lt;span class=&quot;math inline&quot;&gt;\(Qf=0\)&lt;/span&gt;的最小二乘解，为矩阵&lt;span class=&quot;math inline&quot;&gt;\(M=Q^TQ\)&lt;/span&gt;的最小特征值对应的特征向量。所以可以对矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;进行奇异值分解（SVD）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Q = U\Sigma V^T\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(K\times9\)&lt;/span&gt;的矩阵；&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(K\times K\)&lt;/span&gt;的正交阵；&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(K \times 9\)&lt;/span&gt;的对角矩阵，对角线的元素是奇异值；&lt;span class=&quot;math inline&quot;&gt;\(V^T\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(9 \times 9\)&lt;/span&gt;的正交阵，每一个列向量对应着&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;中的奇异值。所以，最小二乘解就是&lt;span class=&quot;math inline&quot;&gt;\(V^T\)&lt;/span&gt;的第9个列向量，也就是可由向量&lt;span class=&quot;math inline&quot;&gt;\(f=V_9\)&lt;/span&gt;构造基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;。&lt;br/&gt;基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;还有一个重要的性质，这里可以作为进一步的约束条件。那就是基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的秩为2，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Rank(F) = 2 \]&lt;/span&gt;&lt;br/&gt;上述使用列向量&lt;span class=&quot;math inline&quot;&gt;\(V_9\)&lt;/span&gt;构造的基础矩阵的秩通常不为2，需要进一步的优化。在估计基础矩阵时，设其最小奇异值为0，对上面方法取得的基础矩阵进行SVD分解&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F = SVD = S\left[\begin{array}{ccc} v_1&amp;amp;0&amp;amp;0\\0&amp;amp;v_2&amp;amp;0\\0&amp;amp;0&amp;amp;v_3 \end{array}\right]D \]&lt;/span&gt;&lt;br/&gt;其最小特征值&lt;span class=&quot;math inline&quot;&gt;\(v_3\)&lt;/span&gt;被设为0，以使得&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的秩为2.这样得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F = SVD = S\left[\begin{array}{ccc} v_1&amp;amp;0&amp;amp;0\\0&amp;amp;v_2&amp;amp;0\\0&amp;amp;0&amp;amp;0 \end{array}\right]D \]&lt;/span&gt;&lt;br/&gt;上述&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;就是最终得到的基础矩阵。&lt;/p&gt;
&lt;p&gt;对上面进行总结，使用最小二乘法估算基础矩阵的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对取得两幅图像的匹配点进行归一化处理，转换矩阵分别是&lt;span class=&quot;math inline&quot;&gt;\(H_1,H_2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;有对应的匹配点(&lt;span class=&quot;math inline&quot;&gt;\(K\ge8\)&lt;/span&gt;)构造系数矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对矩阵&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;进行SVD分解,&lt;span class=&quot;math inline&quot;&gt;\(Q=U\Sigma V^T\)&lt;/span&gt;，由向量&lt;span class=&quot;math inline&quot;&gt;\(f=V_9\)&lt;/span&gt;构造矩阵&lt;span class=&quot;math inline&quot;&gt;\(\hat{F}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对得到的矩阵&lt;span class=&quot;math inline&quot;&gt;\(\hat{F}\)&lt;/span&gt;进行秩为2的约束，即对&lt;span class=&quot;math inline&quot;&gt;\(\hat{F}\)&lt;/span&gt;进行SVD分解，&lt;span class=&quot;math inline&quot;&gt;\(\hat{F}=S\cdot diag(v_1,v_2,v_3) \cdot V^T\)&lt;/span&gt;，令&lt;span class=&quot;math inline&quot;&gt;\(v_3=0\)&lt;/span&gt;得到基础矩阵的估计&lt;span class=&quot;math inline&quot;&gt;\(F'=S\cdot diag(v_1,v_2,0) \cdot V^T\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对上一步得到的解进行反归一化处理，得到基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F=H_2^TF'H_1\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;随机采样一致性-ransac&quot;&gt;随机采样一致性 RANSAC&lt;/h3&gt;
&lt;p&gt;基于匹配点对估算两视图的基础矩阵，唯一的已知条件就是匹配的点对坐标。在实践中，点对的匹配肯定是存在误差的，主要有两种类型的误差：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不精确的测量点位置引起的系统误差，通常服从高斯分布&lt;/li&gt;
&lt;li&gt;错误匹配引起的误差，这些不匹配的点被称为外点，通常不服从高斯分布&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于基础矩阵的估算，不匹配的点能够造成很大的误差，即使是只有一对错误的匹配都能使估算值极大的偏离真实值。因此，需要找到一种方法，从包含错误点（外点）的匹配点对集合中，筛选出正确的匹配点（内点）。&lt;/p&gt;
&lt;p&gt;RANSAC(Random Sample Consensus)随机采样一致性从一组含有外点的数据集中，通过迭代的方式估计出符合该数据集的数学模型的参数。因此，它也可以用来检测出数据集中的外点。&lt;br/&gt;RANSAC有两个基本的假设：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据集中包含的内点，内点的分布符合一个数学模型；而数据集中的外点不复合该数学模型&lt;/li&gt;
&lt;li&gt;能够一组内点（通常很少）集合能够估计出其符合的数据模型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RANSAC的具体思想是：给定&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个数据点组成的集合&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;，假设集合中大多数的点都是可以通过一个模型来产生的，且最少通过&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点可以拟合出模型的参数，则可以通过以下的迭代方式拟合该参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从集合&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;中随机选择&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点&lt;/li&gt;
&lt;li&gt;使用这&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点估计出一个模型&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;中剩余的点，计算每个点与模型&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;的距离，距离超过阈值则认为是外点；不超过阈值则认为是内点，并记录该模型&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;所对应的内点的个数&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将上面步骤重复&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次，选择最大&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;所对应的模型&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;作为最终结果。&lt;br/&gt;在迭代次数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的选择是一个关键，可以通过理论的方式计算出&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的取值。在选择&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点估计模型时，要保证选择的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的个点都是内点的概率足够的高。假设，从数据集中选择一个点为内点的概率为&lt;span class=&quot;math inline&quot;&gt;\(\varpi\)&lt;/span&gt;，则选择的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点都是内点的概率为&lt;span class=&quot;math inline&quot;&gt;\(\varpi^n\)&lt;/span&gt;;则&lt;span class=&quot;math inline&quot;&gt;\(1-\varpi^n\)&lt;/span&gt;表示选择的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点至少有一个是外点，用包含外点估算的模型显然是不正确的，则迭代&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次均得不到正确模型的概率为&lt;span class=&quot;math inline&quot;&gt;\((1-\varpi^n)^k\)&lt;/span&gt;。设&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次迭代中至少有一次选择的点都是内点的概率，也就是估计出了正确的模型，则&lt;span class=&quot;math inline&quot;&gt;\(1-p\)&lt;/span&gt;就表示&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次跌点都得到正确的模型，所以有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 1-p = 1-\varpi^n)^k \]&lt;/span&gt;&lt;br/&gt;两边同时取对数，则有&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ k = \frac{log(1-p)}{log(1-\varpi^n)} \]&lt;/span&gt;&lt;br/&gt;一般要求&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;大于95%即可。&lt;/p&gt;
&lt;p&gt;使用RANSAC估算基础矩阵时，首先需要确定判断点是内点还是外点的依据。通过上一篇的&lt;em&gt;两视图的对极几何&lt;/em&gt;可知，像点总是在对极线，因此可以选择&lt;strong&gt;像点到对极线的距离作为判断该点是内点还是外点的依据&lt;/strong&gt;，设点到对极的距离的阈值为&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;。则使用RANSAC的方法估算基础矩阵的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从匹配的点对中选择8个点，使用8点法估算出基础矩阵&lt;span class=&quot;math inline&quot;&gt;\(F_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计算其余的点对到其对应对极线的距离&lt;span class=&quot;math inline&quot;&gt;\(d_n\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(d_n\le d\)&lt;/span&gt;则该点为内点，否则为外点。记下符合该条件的内点的个数为&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;迭代k次，或者某次得到内点的数目&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;占有的比例大于等于95%，则停止。选择&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;最大的基础矩阵作为最终的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RANSAC能够不依赖于任何额外信息的情况下，将数据划分为内点和外点。但也有其相应的缺点，RANSAC并不能保证得到正确的结果，需要提高迭代的次数；另一个是，内点外点的判断需要设置阈值。&lt;/p&gt;
&lt;h2 id=&quot;opencv-计算基础矩阵&quot;&gt;OpenCV 计算基础矩阵&lt;/h2&gt;
&lt;p&gt;上面写了那么多基础矩阵的计算方法，在OpenCV中也就是一个函数的封装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Mat cv::findFundamentalMat(InputArray points1,
InputArray     points2,
int     method = FM_RANSAC,
double     param1 = 3.,
double     param2 = 0.99,
OutputArray     mask = noArray() 
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;points1&lt;/code&gt;,&lt;code&gt;points2&lt;/code&gt;是匹配点对的像素坐标，并且能够一一对应。&lt;code&gt;method&lt;/code&gt;表是使用那种方法，默认的是&lt;code&gt;FM_RANSAC&lt;/code&gt;也就是RANSAC的方法估算基础矩阵。&lt;code&gt;param1&lt;/code&gt;表示RANSAC迭代过程中，判断点是内点还是外点的阈值（到对极线的像素距离）；&lt;code&gt;param2&lt;/code&gt;表示内点占的比例，以此来判断估计出的基础矩阵是否正确。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//////////////////////////////////////////////////////
    // 
    // 利用已经匹配的点对，使用RANSAC的方法，估计两视图的基础矩阵
    //
    //////////////////////////////////////////////////////
    
    // 1. 对齐匹配的点对
    vector&amp;lt;KeyPoint&amp;gt; alignedKps1, alignedKps2;
    for (auto i = 0; i &amp;lt; good_matches.size(); i++)
    {
        alignedKps1.push_back(keypoints1[good_matches[i].queryIdx]);
        alignedKps2.push_back(keypoints2[good_matches[i].trainIdx]);
    }
    // 2. 取得特征点的像素坐标
    vector&amp;lt;Point2f&amp;gt; ps1, ps2;
    for (auto i = 0; i &amp;lt; alignedKps1.size(); i++)
    {
        ps1.push_back(alignedKps1[i].pt);
        ps2.push_back(alignedKps2[i].pt);
    }
    // 3. RANSAC 计算基础矩阵F
    Mat F;
    F = findFundamentalMat(ps1, ps2, FM_RANSAC);
    cout &amp;lt;&amp;lt; &quot;基础矩阵F:&quot; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; F &amp;lt;&amp;lt; endl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要将匹配的点对放在两个数组中，并且一一对应（匹配的点在两个数组中的下标是一样的），然后再取得匹配点的像素坐标，最后调用&lt;code&gt;findFundamentalMat&lt;/code&gt;使用RANSAC方法估计基础矩阵。&lt;/p&gt;
&lt;p&gt;通过两视图的对极几何可知，所有的对极线相交于对极点，可以以此来验证估计的基础矩阵是否正确。在OpenCV中也封装了计算对极线的方法&lt;code&gt;computeCorrespondEpilines&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vector&amp;lt;Vec3f&amp;gt; linesl;
    computeCorrespondEpilines(ps1, 1, F, linesl);

    for (auto it = linesl.begin(); it != linesl.end(); it++)
    {
        line(img1, Point(0, -(*it)[2] / (*it)[1]), Point(img1.cols, -((*it)[2] + (*it)[0] * img1.cols) / (*it)[1]), Scalar(255, 255, 255));
    }
    imshow(&quot;第一幅图像的对极线&quot;, img1);

    vector&amp;lt;Vec3f&amp;gt; lines2;
    computeCorrespondEpilines(ps2, 2, F, lines2);
    for (auto it = lines2.begin(); it != lines2.end(); it++)
    {
        line(img2, Point(0, -(*it)[2] / (*it)[1]), Point(img2.cols, -((*it)[2] + (*it)[0] * img2.cols) / (*it)[1]), Scalar(255, 255, 255));
    }
    imshow(&quot;第二幅图像的对极线&quot;, img2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码执行的结果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/439761/201801/439761-20180106134951909-1902452825.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出所有的对极线都相交于一点，该点就是对极点。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 05:51:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/8214032.html</dc:identifier>
</item>
<item>
<title>[原创]用C#实现微信“跳一跳”小游戏的自动跳跃助手 - Kingthy</title>
<link>http://www.cnblogs.com/kingthy/p/jumperhelper.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingthy/p/jumperhelper.html</guid>
<description>&lt;h2&gt;一、前言：&lt;/h2&gt;
&lt;p&gt;前段时间微信更新了新版本后，带来的一款H5小游戏“跳一跳”在各朋友圈里又火了起来，类似以前的“打飞机”游戏，这游戏玩法简单，但加上了积分排名功能后，却成了“装逼”的地方，于是很多人花钱花时间的刷积分抢排名。后来越来越多的聪明的“程序哥们”弄出了不同方式不同花样的跳一跳助手（外挂？），有用JS实现的、有JAVA实现的、有Python实现的，有直接物理模式的、有机械化的、有量尺子的等等，简直是百花齐放啊……&lt;/p&gt;
&lt;p&gt;赶一下潮流，刚好有点时间，于是花了一个下午时间，我也弄了一个C#版本的简单实现。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/25430/201801/25430-20180106123923940-54627849.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;664&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、实现：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单的实现流程：&lt;/strong&gt; 连接手机 -&amp;gt; 获取跳一跳游戏界面 -&amp;gt; 获取位置（棋子位置和要跳跃的落脚点位置) -&amp;gt; 点击棋子跳跃&lt;/p&gt;
&lt;h3&gt;1、连接手机&lt;/h3&gt;
&lt;p&gt;电脑要连接并操作安卓手机，一般是通过ADB协议连接手机并进行操作。连接手机前要求手机已开启USB调试模式，可通过USB线或者TCP方式连接手机。正常只要电脑安装了adb sdk tools之类的工具包，就会自带有adb命令，所以C#要能操作手机，简单实现就是直接利用现成的adb命令。&lt;/p&gt;
&lt;p&gt;手机通过USB线接入电脑后，在CMD窗口输入以下adb devices命令，如果显示有device列表则表示手机已连接成功可以对手机进行操作了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
C:\Users\k&amp;gt;adb devices
List of devices attached
e832acb device
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2、获取游戏界面&lt;/h3&gt;
&lt;p&gt;获取手机界面的截图可通过以下adb命令获取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
adb shell screencap -p [filename]　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数 ：&lt;/p&gt;
&lt;p&gt;- p 表示截图保存格式为PNG图像格式。&lt;/p&gt;
&lt;p&gt;filename： 截图保存的路径地址（手机路径），如果不输入则将截图数据直接输出到当前控制台会话，否则会将截图保存到相关路径地址（必须有写权限）&lt;/p&gt;
&lt;p&gt;为避免文件保存到手机后还要再执行adb pull（拉文件到本地电脑）的操作，所以选择不带filename参数的命令。在C#代码里通过Process这个类进行adb命令的调用执行，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; startInfo = &lt;span&gt;new&lt;/span&gt; ProcessStartInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shell screencap -p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
startInfo.CreateNoWindow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
startInfo.ErrorDialog &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
startInfo.RedirectStandardOutput &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
startInfo.UseShellExecute &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; process =&lt;span&gt; Process.Start(startInfo);
process.Start();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; memoStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
process.StandardOutput.BaseStream.CopyTo(memoStream);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但由于adb client的原因，在它输出的截图数据流中会对'\n'(0A)这个字符替换为''\r\n'(0D0A)这两个字符，并且在测试中还发现不同的手机替换次数还不相同的，有可能替换一次，也有可能替换二次！所以为解决这个问题，先计算在最开始的10字节里的数据出现了多少次'\r'(0D)字符后再出现‘\n'(0A)字符，因为正常的PNG文件，在文件头的第4，第5个字节位置里会有'\r\n'(0D0A)标志，所以检查出来的出现次数就表示'\n'(0A)被adb client替换了多少次，之后再对整个接收到的数据流进行'\n'(0A)还原（删除无用的'\r'(0D)字符）。&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;统计'\n'被替换了次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Find0DCount(MemoryStream stream)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            stream.Position &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(stream.Position &amp;lt; &lt;span&gt;10&lt;/span&gt; &amp;amp;&amp;amp; stream.Position &amp;lt;&lt;span&gt; stream.Length)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b =&lt;span&gt; stream.ReadByte();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                {
                    count&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(b == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    count &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&amp;gt;&amp;gt;对接受到的截图数据流进行'\n'字符还原&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; Find0DCount(memoStream);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
                memoStream.Position &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (memoStream.Position !=&lt;span&gt; memoStream.Length)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; memoStream.ReadByte();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b1 =&lt;span&gt; memoStream.ReadByte();
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(b1 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; memoStream.Position !=&lt;span&gt; memoStream.Length)
                        {
                            c&lt;/span&gt;++&lt;span&gt;;
                            b1 &lt;/span&gt;=&lt;span&gt; memoStream.ReadByte();
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b1 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(c ==&lt;span&gt; count)
                            {
                                newStream.WriteByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;)&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                            }
                            newStream.WriteByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)b1);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;c; i++) newStream.WriteByte((&lt;span&gt;byte&lt;/span&gt;)&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                            newStream.WriteByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)b1);
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
                        newStream.WriteByte((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)b);
                    }
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Bitmap(newStream);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3、获取棋子与跳跃落脚点位置&lt;/h3&gt;
&lt;p&gt;将获取到的手机界面截图显示到软件窗体上的PictureBox控件上，可用鼠标的左右键分别点击图片位置标示棋子位置和需要跳的落脚点位置，鼠标点击的坐标位置即表示手机界面的坐标位置。由于手机界面截图在PictureBox控件显示时为了能一屏全图显示，对图片做了缩放处理，且图片缩放后如果图片的宽度小于PictureBox控件的宽度，PictureBox会将图片居中后显示。所以鼠标点击的坐标位置还需要进行坐标转换才可以映射为手机界面里的绝对坐标位置。&lt;/p&gt;
&lt;p&gt;转换计算方法：先计算PictureBox控件的图片缩放值和图片显示的左边距，然后再对鼠标点击坐标进行缩放计算。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Point CalPoint(Point p)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.cbZoom.Checked &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.pictureBox1.Image != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; zoom = (&lt;span&gt;double&lt;/span&gt;)&lt;span&gt;this&lt;/span&gt;.pictureBox1.Height / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pictureBox1.Image.Height;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width = (&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;this&lt;/span&gt;.pictureBox1.Image.Width *&lt;span&gt; zoom);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; left = &lt;span&gt;this&lt;/span&gt;.pictureBox1.Width / &lt;span&gt;2&lt;/span&gt; - width / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Point((&lt;span&gt;int&lt;/span&gt;)((p.X - left) / zoom), (&lt;span&gt;int&lt;/span&gt;)(p.Y /&lt;span&gt; zoom));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如全靠手动鼠标点击坐标位置来玩游戏，这和直接在手机里手动玩游戏是没有什么区别的，区别只在于能够跳跃精准些（跳跃力度能自动计算出，下面会讲），所以程序还要能够实现自动化，就是要能够自动找出棋子与跳跃落脚点的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A、找棋子的坐标位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;棋子的位置非常的好找，对游戏界面里的棋子（图2黄色块）进行放大可以发现棋子底部有一块区域（图3白色块）的颜色值是固定的R(54)G(60)B(102)颜色，如下两图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/25430/201801/25430-20180106113626471-883004997.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(图2）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/25430/201801/25430-20180106113750221-2119780550.jpg&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图3）&lt;/p&gt;

&lt;p&gt;根据棋子的这一颜色特点在获取到手机界面截图时，对图片象素进行扫描，查找R(54)G(60)B(102)这一颜色，找到的坐标位置就是棋子的位置。为了能快速扫描图片，不采用效率较低下的GetPixel方法获取颜色值，而采用LockBits方法锁定图片数据到内存，再采用指针移动获取象素颜色，由于采用了指针，代码需要开启unsafe定义。且棋子正常情况下不会在最顶部和最底部出现，所以不需要对整张界面图片扫描，只扫描20%-63%区域的数据，并且从底部开始找起。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B、找跳跃的落脚点位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写此助手只是无聊时的产出物，所以我只是简单实现。游戏中如果连续跳到了目标物的中间位置时，新目标物的中间部分会出现一个白色圈（如上图2的红色块），如果再跳中此位置，会进行加分。根据这一特点，程序找出那一白色圈圈的位置即可做为落脚点位置，白色圈的颜色值为R(254)G(254)B(254)，如果没有此白色圈位置，则手动鼠标选择落脚点位置。实现此功能后，程序基本上也能实现90%左右的自动化跳跃了。&lt;/p&gt;

&lt;p&gt;查找代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Point FindPointImpl(Bitmap bitmap, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; Point comboPoint)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; standPColor = Color.FromArgb(&lt;span&gt;54&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;102&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; comboPColor = Color.FromArgb(&lt;span&gt;245&lt;/span&gt;, &lt;span&gt;245&lt;/span&gt;, &lt;span&gt;245&lt;/span&gt;&lt;span&gt;);

            Point standPoint &lt;/span&gt;=&lt;span&gt; Point.Empty;
            comboPoint &lt;/span&gt;=&lt;span&gt; Point.Empty;

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y1 = (&lt;span&gt;int&lt;/span&gt;)(bitmap.Height * &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y2 = (&lt;span&gt;int&lt;/span&gt;)(bitmap.Height * &lt;span&gt;0.63&lt;/span&gt;&lt;span&gt;);

            PixelFormat pf &lt;/span&gt;=&lt;span&gt; PixelFormat.Format24bppRgb;

            BitmapData bitmapData &lt;/span&gt;= bitmap.LockBits(&lt;span&gt;new&lt;/span&gt; Rectangle(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, y1, bitmap.Width, y2), ImageLockMode.ReadOnly, pf);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (y2 &amp;gt;&lt;span&gt; y1)
                    {
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;* p = (&lt;span&gt;byte&lt;/span&gt;*)bitmapData.Scan0 + (y2 - y1 - &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; bitmapData.Stride;
                        w &lt;/span&gt;=&lt;span&gt; bitmap.Width;
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; endColorCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (w &amp;gt; &lt;span&gt;40&lt;/span&gt;&lt;span&gt;)
                        {
                            ICColor&lt;/span&gt;* pc = (ICColor*)(p + w * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (standPoint == Point.Empty &amp;amp;&amp;amp;&lt;span&gt;
                                pc&lt;/span&gt;-&amp;gt;R == standPColor.R &amp;amp;&amp;amp; pc-&amp;gt;G == standPColor.G &amp;amp;&amp;amp; pc-&amp;gt;B ==&lt;span&gt; standPColor.B)
                            {
                                standPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(w - &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, y2);
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comboPoint != Point.Empty) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (comboPoint ==&lt;span&gt; Point.Empty)
                            {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pc-&amp;gt;R == comboPColor.R &amp;amp;&amp;amp; pc-&amp;gt;G == comboPColor.G &amp;amp;&amp;amp; pc-&amp;gt;B ==&lt;span&gt; comboPColor.B)
                                {
                                    endColorCount&lt;/span&gt;++&lt;span&gt;;
                                }
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                {
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (endColorCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                                    {
                                        comboPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(w + &lt;span&gt;5&lt;/span&gt;, y2 - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (standPoint != Point.Empty) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                    }
                                    endColorCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                }
                            }
                            w&lt;/span&gt;--&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comboPoint ==&lt;span&gt; Point.Empty)
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (endColorCount &amp;gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
                            {
                                comboPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(w + &lt;span&gt;5&lt;/span&gt;, y2 - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (standPoint != Point.Empty &amp;amp;&amp;amp; comboPoint != Point.Empty) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        y2&lt;/span&gt;--&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; standPoint;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                bitmap.UnlockBits(bitmapData);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;4、棋子跳跃&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;要能跳跃，首先需要知道一个蓄力时间，就是按住棋子多久的时间，此蓄力时间的计算公式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
蓄力时间 = 距离 * 力度系数
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;“&lt;span&gt;距离&lt;/span&gt;”就是棋子位置与跳跃落脚点位置的距离，根据上面的方法得出这两个位置的坐标点后，根据直角三角形的勾股定理即可求出，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        public double&lt;span&gt; Distance
        {
            get&lt;span&gt;
            {
                if (!this.CanDo) return -1&lt;span&gt;;
                int w = Math.Abs(this.P2.X - this&lt;span&gt;.P1.X);
                int h = Math.Abs(this.P2.Y - this&lt;span&gt;.P1.Y);
                return Math.Sqrt((double)(w * w) + (h *&lt;span&gt; h));
            }
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“&lt;span&gt;力度系数&lt;/span&gt;”  是一个常量值，具体怎么定义没去细查，我采用的计算公式是： “&lt;span&gt;&lt;strong&gt;力度系数&lt;/strong&gt; = 1495 / 手机分辨率的宽度值&lt;/span&gt;”， 如我的手机分辨率是1080*1920，则力度系数就是 1495 / 1080 = 1.3842....&lt;/p&gt;
&lt;p&gt;算出了蓄力时间后通过以下adb命令发送到手机即可模拟点击操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
adb shell input swipe &amp;lt;x1&amp;gt; &amp;lt;y1&amp;gt; &amp;lt;x2&amp;gt; &amp;lt;y2&amp;gt; [duration(ms)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x1, y1 就是棋子的坐标位置&lt;/p&gt;
&lt;p&gt;x2, y2 还是棋子的坐标位置&lt;/p&gt;
&lt;p&gt;duration 蓄力时间值，由距离*力度系数得出。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Do()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.CanDo) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startInfo = &lt;span&gt;new&lt;/span&gt; ProcessStartInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shell input swipe {0} {1} {0} {1} {2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.P1.X, &lt;span&gt;this&lt;/span&gt;.P1.Y, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Time));
            startInfo.CreateNoWindow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            startInfo.ErrorDialog &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            startInfo.UseShellExecute &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; process =&lt;span&gt; Process.Start(startInfo);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; process.Start();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;三、结束语&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;程序实现很简单，都是通过adb命令与手机进行交互操作。如果你认为对你有帮助麻烦赞下即可：）积分别玩太过哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/25430/201801/25430-20180106124017893-138699313.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可执行文件下载地址：&lt;a title=&quot;JumperHelper.rar&quot; href=&quot;https://files.cnblogs.com/files/kingthy/JumperHelper.rar&quot; target=&quot;_blank&quot;&gt;JumperHelper.rar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码仓库：&lt;a href=&quot;https://github.com/kingthy/JumperHelper&quot; target=&quot;_blank&quot;&gt;https://github.com/kingthy/JumperHelper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;声明：本软件、代码和文章属于本人原创，转载请通知并注明原处！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 04:42:00 +0000</pubDate>
<dc:creator>Kingthy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingthy/p/jumperhelper.html</dc:identifier>
</item>
<item>
<title>跟我一起，利用bitcms内容管理系统从0到1学习小程序开发：一、IIS下SSL环境搭建 - 逐月</title>
<link>http://www.cnblogs.com/zhuyue/p/8213319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuyue/p/8213319.html</guid>
<description>&lt;p&gt;&lt;strong&gt;缘起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、从事互联网十来年了，一直想把自己的从事开发过程遇到的问题给写出来，分享给大家。可是可是这只是个种想法，想想之后就放下了，写出来的类文章是少之又少。古人说无志之人常立志,有志之人立长志。今天，就从学习小程序开始，记录在学习过程中的遇到点点滴滴，先做“无志之人常立志”吧。&lt;/p&gt;
&lt;p&gt;强调的是，微信小程序开发，我也是从0到1的过程，肯定会有错误或遗漏，还望给指导指导，让我的学习知识更完善，再此先谢过了。&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://bitcms.net/&quot; target=&quot;_blank&quot;&gt;bitcms开源内容管理系统&lt;/a&gt;也发布了，运营对一个程序老猿来说，确实是个艰巨的任务。自己的想法很多，园子里的朋友也给了不少建议。&lt;/p&gt;
&lt;p&gt;总结下来有二：一是bitcms内容管理系统不能是一个孤岛，要有围绕bitcms周边要有相应的应用。像短信接口，公众号接口，支付接口等。这些都是平常工作开发中常用到的，现在只需时间来整理优化后放出来；二是要推广。某度、某3、某条等付费推广，对屌丝作者我来说，想想都是奢饰。那只剩下一条路了，自己写应用技术软文，来慢慢浇灌吧。本小程序学习系列学习笔记，应该也算是一个吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面来进入正题：IIS下SSL环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚接触小程序的时候发现后台服务必须是https的时候。心想，腾讯这是要干吗，这是要增加接入门槛吗？随后对https的深入了解，慢慢发现腾讯的苦衷，互联网的安全，并不是只是程序员要考虑的，安全要从基础运行环境的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、SSL证书申请&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供SSL证书申请服务的有很多，大部分云服务提供商基本上都可以，价格也是从千到万应有尽有。作为屌丝，咱们肯定不是他们的菜。还好，有免费DV可以0元申请。对于安全要求不高，只是接入https的完全可以满足使用。对不差钱或对数据安全要求高的，推荐申请收费SSL证书。如有土豪愿意给我提供收费版SSL证书，请联系我，先谢过了。&lt;/p&gt;
&lt;p&gt;下面是景安申请免费DV SSL证书的截图。申请填写域名信息并验证通过后，就可以下载证书了。下载证书后有个生成的个证书密码一个记下。证书导入IIS的时候需要使用这个密码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、申请证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106103709878-564649960.png&quot; alt=&quot;&quot; width=&quot;742&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、绑定域名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106104308003-210518218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、下载证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106105638878-338287034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106105955440-1838361154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载的证书，景安的证书还是比较全的，apache,iis等都有，readme.txt是证书密码文本，放入一个压缩包内，避免丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装证书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器环境是：windows server 2008 r2 + IIS7&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、安装证书&lt;/strong&gt;，打开IIS，如下图。找到服务器证书，打开 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106111307299-1793526971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、导入证书&lt;/strong&gt;，选择证书包里的iIS下证书文件，输入下载证书时的证书密码，请可以确定提交了。证书安装完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106111624878-409861492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、网站设置&lt;/strong&gt;，添加网站或已有网站添加新绑定。绑定类型选择https，SSl证书选择刚才安装的证书，提交搞定。刚开始添加https绑定的时候，挺纳闷为什么主机名不让填写。后来果资料得知：原来IIS7一个服务器只允许一个https绑定。像bitcms.net主域名绑定https，不受影响。如果https绑定的是一个二级域名，只有修改IIS配置文件了&lt;/p&gt;
&lt;p&gt;用记事本打开文件：C:\Windows\system32\inetsrv\config\applicationHost.config 注：如果系统盘不在C盘，请参照修改路径&lt;/p&gt;
&lt;p&gt;找到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;site &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bitcms.net&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; serverAutoStart&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     &amp;lt;application path=&quot;/&quot; applicationPool=&quot;bitcms.net&quot;&amp;gt;
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;virtualDirectory &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; physicalPath&lt;/span&gt;&lt;span&gt;=&quot;D:\www\bitcms.net&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;binding &lt;/span&gt;&lt;span&gt;protocol&lt;/span&gt;&lt;span&gt;=&quot;https&quot;&lt;/span&gt;&lt;span&gt; bindingInformation&lt;/span&gt;&lt;span&gt;=&quot;*:443:&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;site&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;site &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bitcms.net&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; serverAutoStart&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     &amp;lt;application path=&quot;/&quot; applicationPool=&quot;bitcms.net&quot;&amp;gt;
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;virtualDirectory &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; physicalPath&lt;/span&gt;&lt;span&gt;=&quot;D:\www\bitcms.net&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;binding &lt;/span&gt;&lt;span&gt;protocol&lt;/span&gt;&lt;span&gt;=&quot;https&quot;&lt;/span&gt;&lt;span&gt; bindingInformation&lt;/span&gt;&lt;span&gt;=&quot;*:443:bitcms.net&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bindings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;site&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106123315299-2145173823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、网站SSL设置&lt;/strong&gt;，打开SSL设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106123325768-901425237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;勾选要求SSL，客户证书，勾选接受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106123338393-1876400131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、301跳转设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过上面证书安装和网站设置，SSL网站基本上算是已经布置完成了。但是有一点不完美的地方，就是你在浏览器地址栏里输入域名如：bitcms.net，还是打不开网站，必须加上https://，这体验太不好了吧。那再设置一个301跳转，就完美了。下面就开始设置301跳转。如果您的证书使用的是二级域名，301跳转就不用设置了。&lt;/p&gt;
&lt;p&gt;新建一个网站，物理路径最好单独设置一个文件夹。 添加普通http绑定，如下图绑定bitcms.net和www.bitcms.net两个域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106123350112-1193187530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开HTTP重定向，设置如下图。将请求重写向到此目标填写：&lt;span&gt;https//bitcms.net$S$Q&lt;span&gt;，是域名后加&lt;/span&gt;$S$Q&lt;span&gt;。重定向行为勾选第一个，状态代码选择永久（301)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/41840/201801/41840-20180106123402862-1600053092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、杂记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，IIS环境下安装SSL证书已经完成。下面说说我在设置过程中遇到的坑。&lt;/p&gt;
&lt;p&gt;1、网站SSL设置的时候客户证书，想当然的选择”必须“的啊，结果网站打开，浪费了很多时间在上面。&lt;/p&gt;
&lt;p&gt;2、设置301重定向的坑。大家也看这个服务器上的另一个网站也设置了301，请把两个301物理路径些向一个地址，结果填写重定向些目标的时候，修改一个，另一个也跟着变。这应该是IIS BUG吧。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 04:35:00 +0000</pubDate>
<dc:creator>逐月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuyue/p/8213319.html</dc:identifier>
</item>
<item>
<title>Spring之DAO二 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8213370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8213370.html</guid>
<description>&lt;p&gt;上一篇算是把JdbcDaoSupport的使用演示了一下，这篇主要是演示MappingSqlQuery、SqlUpdate、SqlFunction的使用以及Spring的事务管理。&lt;/p&gt;
&lt;p&gt;一、MappingSqlQuery的使用&lt;/p&gt;
&lt;p&gt;在上一篇获取所有User的方法QueryAllUser()中，使用getJdbcTemplate().queryForList()返回的是List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型，需要遍历转换成Java对象，那问题来了，查询的不止这一个方法，可能以后会有条件查询的方法，那每次都要把从数据库返回的List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型的List转一遍，当然也可以专门写一个转换的方法，这样每次传List&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;类型的参数，然后返回List&amp;lt;User&amp;gt;类型的值。其实还有一种方式，就是使用MappingSqlQuery。MappingSqlQuery是一个抽象类，需要实现它的方法mapRow()。下面的代码就是定义了类UserMappingSqlQuery，继承了抽象类MappingSqlQuery，实现了它的mapRow()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_94328214-19a9-403b-afb8-cecfb22972e0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94328214-19a9-403b-afb8-cecfb22972e0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94328214-19a9-403b-afb8-cecfb22972e0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.object.MappingSqlQuery;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Model.User;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserMappingSqlQuery &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MappingSqlQuery {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object mapRow(ResultSet rs, &lt;span&gt;int&lt;/span&gt; rowNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        User user=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUserId((Integer)rs.getInt(&lt;/span&gt;&quot;id&quot;&lt;span&gt;));
        user.setName((String)rs.getString(&lt;/span&gt;&quot;name&quot;&lt;span&gt;));
        user.setMoney((Float)rs.getFloat(&lt;/span&gt;&quot;money&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面定义之后就是该怎么使用了。还是UserDAO类中，重写List&amp;lt;User&amp;gt; QueryAllUser()方法。代码中主要是为了尝试使用参数，所有增加了一个过滤条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_0c8d234e-d7d1-4ea2-b72f-90aecc0d5968&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c8d234e-d7d1-4ea2-b72f-90aecc0d5968&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c8d234e-d7d1-4ea2-b72f-90aecc0d5968&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; QueryAllUser() {
        
        String sql&lt;/span&gt;=&quot;select id,name,money from tb_user where name=?&quot;&lt;span&gt;;
        UserMappingSqlQuery userQuery&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserMappingSqlQuery();
        userQuery.setDataSource(getDataSource());
        userQuery.setSql(sql);
        userQuery.setParameters(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.VARCHAR));
        userQuery.compile();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; userQuery.execute(&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; String(&quot;cuiywA&quot;&lt;span&gt;)});
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;执行QueryAllUser(),打印出查询的list。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_434504b0-c275-4e85-8936-bc65cd5e6212&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_434504b0-c275-4e85-8936-bc65cd5e6212&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_434504b0-c275-4e85-8936-bc65cd5e6212&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
        List&amp;lt;User&amp;gt; list=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(&lt;/span&gt;&quot;name:&quot;+u.getName()+&quot; money: &quot;+&lt;span&gt;u.getMoney());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180106093403362-1886790416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 二、SqlUpdate的使用&lt;/p&gt;
&lt;p&gt;上面熟悉了查询的用法，SqlUpdate主要是用来更新。下面定义了UserSqlUpdate继承SqlUpdate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_72ea6f31-6de7-4d47-959c-771d9f6608fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_72ea6f31-6de7-4d47-959c-771d9f6608fb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_72ea6f31-6de7-4d47-959c-771d9f6608fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.Spring.Dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.sql.DataSource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.SqlParameter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.object.SqlUpdate;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserSqlUpdate &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SqlUpdate{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserSqlUpdate(DataSource ds, String sql) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(ds, sql);
        declareParameter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.FLOAT) );
        declareParameter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter(java.sql.Types.VARCHAR) );
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; updateUserMoney(String name,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; money)
    {
        compile();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; update(&lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;new&lt;/span&gt; Float(money),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(name)});
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面的构造函数传两个参数，这两个参数我都放在上下文xml中。dataSource还是上一博客中配置的数据库信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_c3582aae-2cd6-4b22-b679-04164f08651f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c3582aae-2cd6-4b22-b679-04164f08651f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c3582aae-2cd6-4b22-b679-04164f08651f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;userSqlUpdate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;Cuiyw.Spring.Dao.UserSqlUpdate&quot;&amp;gt;
&amp;lt;constructor-arg type=&quot;java.lang.String&quot; index=&quot;1&quot;&amp;gt;
&amp;lt;value&amp;gt;update tb_user set money=? where name=?&amp;lt;/value&amp;gt;
&amp;lt;/constructor-arg&amp;gt;
&amp;lt;constructor-arg ref=&quot;dataSource&quot; index=&quot;0&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ad1a644e-00e4-454a-bcc8-04323b9e266d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ad1a644e-00e4-454a-bcc8-04323b9e266d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ad1a644e-00e4-454a-bcc8-04323b9e266d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        UserSqlUpdate userSqlUpdate=(UserSqlUpdate)factory.getBean(&quot;userSqlUpdate&quot;&lt;span&gt;);
        userSqlUpdate.updateUserMoney(&lt;/span&gt;&quot;cuiywA&quot;,666); 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在updateUserMoney()前后遍历数据库的user,发现以及修改了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180106103615471-178353236.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;三、SqlFunction的使用&lt;/p&gt;
&lt;p&gt; SqlFunction返回单一行的查询结果，默认返回int，也可以重载返回其他类型。下面的我是直接在main函数中使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_323cb6f3-7140-4477-ae8c-73304c08b971&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_323cb6f3-7140-4477-ae8c-73304c08b971&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_323cb6f3-7140-4477-ae8c-73304c08b971&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
        BasicDataSource dataSource=(BasicDataSource)factory.getBean(&quot;dataSource&quot;&lt;span&gt;);
        SqlFunction sf&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; SqlFunction(dataSource,&quot;select count(1) from tb_user;&quot;&lt;span&gt;);
        sf.compile();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=&lt;span&gt;sf.run();
        System.out.println(&lt;/span&gt;&quot;User Count:&quot;+count);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180106104632924-346447932.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;四、Spring事务管理&lt;/p&gt;
&lt;p&gt; 什么是事务这些就不说了，事务最常见的例子就是转账，我定义User有money字段就是为了事务而定义的。实现事务在spring中有好几种方式，这里只简单介绍基于jdbc的声明式事务。&lt;/p&gt;
&lt;p&gt;这里在IUserDAO中定义了两个接口，一个是存取款，一个是转账,并在UserDAO中实现。理想情况一个加一个减，但是加入减的成功了，加的失败了，那转账就是错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_c298caed-95ea-4e98-8cc5-8f5268e156a4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c298caed-95ea-4e98-8cc5-8f5268e156a4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c298caed-95ea-4e98-8cc5-8f5268e156a4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Boolean outInMoney(&lt;span&gt;int&lt;/span&gt; toUserId,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; money)
    {
        String sql&lt;/span&gt;=&quot;update  tb_user set money=money+? where id=? &quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row=getJdbcTemplate().update(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{money,toUserId});
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(row&amp;gt;0&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean transfer(&lt;span&gt;int&lt;/span&gt; fromUserId, &lt;span&gt;int&lt;/span&gt; toUserId, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; transferMoney) {
        Boolean out&lt;/span&gt;= outInMoney(fromUserId,-&lt;span&gt;transferMoney);
        Boolean in&lt;/span&gt;=&lt;span&gt;outInMoney(toUserId,transferMoney);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; out&amp;amp;&lt;span&gt;in;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;spring使用DataSourceTransactionManager作为jdbc的事务管理者，被管理对象使用TransactionProxyFactoryBean配置。&lt;/p&gt;
&lt;p&gt;1.配置DataSourceTransactionManager&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_2638f7d7-6168-4a92-9351-cd68173a0028&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2638f7d7-6168-4a92-9351-cd68173a0028&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2638f7d7-6168-4a92-9351-cd68173a0028&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.配置TransactionProxyFactoryBean&lt;/p&gt;
&lt;p&gt;这里transactionAttributes是来配置哪些方法使用事务管理，这里只配置了transfer方法，使用*，表达所有的方法，prop的值可以是PROPAGATION（事务的传播行为），ISOLATIONf(事务的隔离级别) -Exception(发生哪些异常回滚事务) +Exception(发生哪些事务不回滚)&lt;/p&gt;
&lt;p&gt;PROPAGATION类型:&lt;/p&gt;
&lt;p&gt;PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。&lt;br/&gt;PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;br/&gt;PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。&lt;br/&gt;PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起。&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt; &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常。 &lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;PROPAGATION_NESTED--如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;Exception:&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;- 表示抛出该异常时需要回滚&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;+表示即使抛出该异常事务同样要提交&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;-ApplicationException ：表示抛出ApplicationException 时，事务需要回滚。但不是说只抛出ApplicationException 异常时，事务才回滚，如果程序抛出RuntimeException和Error时，事务一样会回滚，即使这里没有配置。因为Spring中默认对所有的RuntimeException和Error都会回滚事务&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1cd88231-ff84-4bef-b240-ad011c85438b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1cd88231-ff84-4bef-b240-ad011c85438b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1cd88231-ff84-4bef-b240-ad011c85438b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 配置业务层代理 --&amp;gt;
&amp;lt;bean id=&quot;userDaoProxy&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&amp;gt;
    &amp;lt;!-- 配置目标对象 --&amp;gt;
    &amp;lt;property name=&quot;target&quot; ref=&quot;userDao&quot;/&amp;gt;
    &amp;lt;!-- 注入事务管理器 --&amp;gt;
    &amp;lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&amp;gt;
    &amp;lt;!-- 注入事务的属性 --&amp;gt;
    &amp;lt;property name=&quot;transactionAttributes&quot;&amp;gt;
        &amp;lt;props&amp;gt;
            &amp;lt;prop key=&quot;transfer&quot;&amp;gt;PROPAGATION_REQUIRED&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 3.这里先理想情况的转账一个，可以看到cuiywA账号减100，cuiywB账号加100.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_214dd752-40d4-4ec5-b59f-26594aae0fc0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_214dd752-40d4-4ec5-b59f-26594aae0fc0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_214dd752-40d4-4ec5-b59f-26594aae0fc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        List&amp;lt;User&amp;gt; list=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(&lt;/span&gt;&quot;name:&quot;+u.getName()+&quot; money: &quot;+&lt;span&gt;u.getMoney());
        }
        userDao.transfer(&lt;/span&gt;1, 2, 100&lt;span&gt;);
        list&lt;/span&gt;=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(&lt;/span&gt;&quot;name:&quot;+u.getName()+&quot; money: &quot;+&lt;span&gt;u.getMoney());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180106113247893-2009621977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.异常转账&lt;/p&gt;
&lt;p&gt;模拟异常这里在转账时增加一个错误1/0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_a5b187b1-f242-4d6a-9ac6-3f6902899727&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5b187b1-f242-4d6a-9ac6-3f6902899727&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5b187b1-f242-4d6a-9ac6-3f6902899727&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Boolean transfer(&lt;span&gt;int&lt;/span&gt; fromUserId, &lt;span&gt;int&lt;/span&gt; toUserId, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; transferMoney) {
        Boolean out&lt;/span&gt;= outInMoney(fromUserId,-&lt;span&gt;transferMoney);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=1/0&lt;span&gt;;
        Boolean in&lt;/span&gt;=&lt;span&gt;outInMoney(toUserId,transferMoney);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; out&amp;amp;&lt;span&gt;in;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这里遇到了一个坑，配置之后还是按照前面的factory.getBean(&quot;userDao&quot;)，但始终不成功，找了好久，觉得配置的userDaoProxy并没有用到，这不科学啊，又百度了一下，发现还真是。在获取bean时不应时userDao了，而是TransactionProxyFactoryBean对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_3b0f1db8-0f22-4ac2-9171-15b54f887286&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3b0f1db8-0f22-4ac2-9171-15b54f887286&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3b0f1db8-0f22-4ac2-9171-15b54f887286&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
        IUserDAO userDao=(IUserDAO)factory.getBean(&quot;userDaoProxy&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e6434de8-c1b8-46e6-bc00-b0241d9be438&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e6434de8-c1b8-46e6-bc00-b0241d9be438&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e6434de8-c1b8-46e6-bc00-b0241d9be438&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
          ApplicationContext context=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IUserDAO userDao&lt;/span&gt;=(IUserDAO)factory.getBean(&quot;userDaoProxy&quot;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;User&amp;gt; list=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(&lt;/span&gt;&quot;name:&quot;+u.getName()+&quot; money: &quot;+&lt;span&gt;u.getMoney());
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
          userDao.transfer(&lt;/span&gt;1, 2, 100&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
        {}
        list&lt;/span&gt;=&lt;span&gt;userDao.QueryAllUser(); 
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(User u:list)
        {
            System.out.println(&lt;/span&gt;&quot;name:&quot;+u.getName()+&quot; money: &quot;+&lt;span&gt;u.getMoney());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180106121739159-462658572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面在转账的地方增加了try-catch,主要是为了看执行转账之后的金额是否与之前的一致。上面截图可以看到是一致的，事务是有回滚的。事务管理还有其他方式，以后会一一介绍。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Jan 2018 04:33:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8213370.html</dc:identifier>
</item>
<item>
<title>对于单个模型（长方体为例）进行面投影时的消隐 - feiquan</title>
<link>http://www.cnblogs.com/feiquan/p/8213875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feiquan/p/8213875.html</guid>
<description>&lt;div readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;作者：feiquan

出处：http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/feiquan/&lt;/span&gt;
&lt;span&gt;
版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。

大家写文都不容易，请尊重劳动成果&lt;/span&gt;~ 这里谢谢大家啦(*/ω＼*)
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;　　 创建类Point_3V来存放三维点，Line_2V来存放二维点，Line来存放三维线，Line_2V来存放二维线，face_2V来存放二维面，face来存放三维面，cube来定义一个矩形。以上的二维都是用来平行投影时使用的，三维则是存放在三维空间中真实存在的矩形的信息，且这几个三维类之间使用了类的继承来实现。&lt;/p&gt;&lt;div readability=&quot;286&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3V_Point三维点&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point_3V{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y,z;
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; v;

    Point_3V(){
        x&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;y=&lt;span&gt;0&lt;/span&gt;;z=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Point_3V(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; c){
        x&lt;/span&gt;=a;y=b;z=&lt;span&gt;c;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Point_3V(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; a,CPoint p){
        x&lt;/span&gt;=a;y=p.x;z=&lt;span&gt;p.y;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Point_3V(CPoint p,&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; a){
        x&lt;/span&gt;=p.x;y=p.y;z=&lt;span&gt;a;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Point(&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt; b,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; c){
        x&lt;/span&gt;=a;y=b;z=&lt;span&gt;c;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; set_Point(Point_3V p){
        x&lt;/span&gt;=p.x;y=p.y;z=&lt;span&gt;p.z;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Point(Point_3V *&lt;span&gt;p){
        x&lt;/span&gt;=p-&amp;gt;x;y=p-&amp;gt;y;z=p-&amp;gt;&lt;span&gt;z;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;投影一个三维点,返回投影点&lt;/span&gt;
&lt;span&gt;    CPoint reflect_Point_3V(Point_3V v,CPoint move){
        CPoint p2;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;  a,b;
        a&lt;/span&gt;=&lt;span&gt;this&lt;/span&gt;-&amp;gt;x-v.x/v.z*&lt;span&gt;this&lt;/span&gt;-&amp;gt;z+&lt;span&gt;move.x;
        b&lt;/span&gt;=&lt;span&gt;this&lt;/span&gt;-&amp;gt;y-v.y/v.z*&lt;span&gt;this&lt;/span&gt;-&amp;gt;z+&lt;span&gt;move.y;
        
        p2.SetPoint((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;)a,(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)b);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p2;
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维线&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Line_2V{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; :
    CPoint start,end;
    Line_2V(){
        start.SetPoint(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        end.SetPoint(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }
    Line_2V(CPoint x,CPoint y ){
        start&lt;/span&gt;=x;end=&lt;span&gt;y;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fill(CDC *&lt;span&gt;p){
        p&lt;/span&gt;-&amp;gt;&lt;span&gt;MoveTo(start);
        p&lt;/span&gt;-&amp;gt;&lt;span&gt;LineTo(end);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于点填充线(不会开辟新空间)&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Line :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Point_3V 
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; :
    Point_3V &lt;/span&gt;*&lt;span&gt;start;
    Point_3V end;
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; v;
    Line(){
        start&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Line(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt; c ,Point_3V e ):Point_3V(a,b,c),start(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),end(e){
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Line( &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s_x,&lt;span&gt;int&lt;/span&gt; s_y,&lt;span&gt;int&lt;/span&gt; s_z,&lt;span&gt;int&lt;/span&gt; e_x,&lt;span&gt;int&lt;/span&gt; e_y,&lt;span&gt;int&lt;/span&gt; e_z):Point_3V(s_x,s_y,s_z),start(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),end(e_x,e_y,e_z){
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    Line(Line &lt;/span&gt;*&lt;span&gt;p){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;start=p-&amp;gt;&lt;span&gt;start;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;end=p-&amp;gt;&lt;span&gt;end;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三维线投影&lt;/span&gt;
    Line_2V reflect_Line(Point_3V v,CPoint move,&lt;span&gt;bool&lt;/span&gt; draw,CDC  *&lt;span&gt;p){
        CPoint s&lt;/span&gt;=start-&amp;gt;&lt;span&gt;reflect_Point_3V(v,move);
        CPoint e&lt;/span&gt;=&lt;span&gt;end.reflect_Point_3V(v,move);
        Line_2V temp(s,e);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(draw)temp.fill(p);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Line(&lt;span&gt;int&lt;/span&gt; s_x,&lt;span&gt;int&lt;/span&gt; s_y,&lt;span&gt;int&lt;/span&gt; s_z,&lt;span&gt;int&lt;/span&gt; e_x,&lt;span&gt;int&lt;/span&gt; e_y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; e_z){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;start-&amp;gt;&lt;span&gt;set_Point(s_x,s_y,s_z);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;end.set_Point(e_x,e_y,e_z);
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; set_Line(Point_3V s,Point_3V e){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;x=&lt;span&gt;s.x;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;y=&lt;span&gt;s.y;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;z=&lt;span&gt;s.z;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;v=&lt;span&gt;s.v;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;start-&amp;gt;&lt;span&gt;set_Point(s);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;end.set_Point(e);
    }
};

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; face_2V{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; :
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逆时针&lt;/span&gt;
&lt;span&gt;    Line_2V a,b,c,d;
    face_2V(){

    }
    face_2V(Line_2V i,Line_2V j,Line_2V k,Line_2V l ){
        a&lt;/span&gt;=i;b=j;c=k;d=&lt;span&gt;l;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; B(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt; c1_fill,&lt;span&gt;int&lt;/span&gt; c2,CDC *&lt;span&gt;p){
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;种子填充&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; center=p-&amp;gt;&lt;span&gt;GetPixel(x,y);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(center!=c1_fill&amp;amp;&amp;amp;center!=&lt;span&gt;c2){
            p&lt;/span&gt;-&amp;gt;&lt;span&gt;SetPixel(x,y,c1_fill);
            B(x&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,y,c1_fill,c2,p);B(x-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,y,c1_fill,c2,p);
            B(x,y&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,c1_fill,c2,p);B(x,y-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,c1_fill,c2,p);
        }
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fill(&lt;span&gt;int&lt;/span&gt; c1_fill,&lt;span&gt;int&lt;/span&gt; c2,CDC *&lt;span&gt;p){
        a.fill(p);b.fill(p);c.fill(p);d.fill(p);
        B(((a.start.x&lt;/span&gt;+c.start.x)/&lt;span&gt;2&lt;/span&gt;),((a.start.y+c.start.y )/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), c1_fill, c2,p);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于点填充面(不会开辟新空间)&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; face :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Line{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; :
    Point_3V &lt;/span&gt;*p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逆时针&lt;/span&gt;
    Line *l1,l2,l3,l4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l1只能是指针,为了是其与点公用一个存储空间&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; v;
    face(){
        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        l1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Line[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    face(Point_3V &lt;/span&gt;*q[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;start=q[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;end=*q[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        l1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Line[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        l2.set_Line(p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
        l3.set_Line(p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
        l4.set_Line(p[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;],p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    }
    face(Point_3V a,Point_3V b,Point_3V c,Point_3V d){
        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        l1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Line[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        p[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=a;p[&lt;span&gt;0&lt;/span&gt;]=b,p[&lt;span&gt;0&lt;/span&gt;]=c,p[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;d;
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        l2.set_Line(p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
        l3.set_Line(p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
        l4.set_Line(p[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;],p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    }
    face( face &lt;/span&gt;*&lt;span&gt;p1){
        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        l1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Line[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;start=p1-&amp;gt;&lt;span&gt;start;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;end=p1-&amp;gt;&lt;span&gt;end;

        p[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=p1-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=p1-&amp;gt;p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] );
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    face(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s_x,&lt;span&gt;int&lt;/span&gt; s_y,&lt;span&gt;int&lt;/span&gt; s_z,&lt;span&gt;int&lt;/span&gt; e_x,&lt;span&gt;int&lt;/span&gt; e_y,&lt;span&gt;int&lt;/span&gt; e_z,Line p2,Line p3,Line p4):Line(s_x,s_y,s_z,e_x,e_y,e_z),l1(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;),l2(p2),l3(p3),l4(p4){
        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Point_3V[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        l1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Line[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        v&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Point(Point_3V q[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;){
            p[i]&lt;/span&gt;=&lt;span&gt;q[i];
        }
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; set_Line(){
        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        l2.set_Line(p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
        l3.set_Line(p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
        l4.set_Line(p[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;],p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Face(Point_3V q[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;){
            p[i]&lt;/span&gt;=&lt;span&gt;q[i];
        }
        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        l2.set_Line(p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
        l3.set_Line(p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
        l4.set_Line(p[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;],p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; set_Face(Point_3V q1,Point_3V q2,Point_3V q3,Point_3V q4){
        p[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;q1;
        p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;q2;
        p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]=&lt;span&gt;q3;
        p[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;q4;

        l1&lt;/span&gt;-&amp;gt;set_Line(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        l2.set_Line(p[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
        l3.set_Line(p[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
        l4.set_Line(p[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;],p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三维向量的向量积&lt;/span&gt;
&lt;span&gt;    Point_3V xiangliangji( Point_3V a ,Point_3V b){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;矩阵形式,和i,j,k是否为偶数或奇数有关,切记&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; Point_3V(a.y*b.z-a.z*b.y,-(a.x*b.z-a.z*b.x),a.x*b.y-a.y*&lt;span&gt;b.x);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三维向量的点乘&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt;&lt;span&gt; diancheng( Point_3V a ,Point_3V b){
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; temp=a.x*b.x+a.y*b.y+a.z*&lt;span&gt;b.z;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求一个面的法向量,输入一个面按逆时针方向的所有点的数组&lt;/span&gt;
    Point_3V n( face *&lt;span&gt;one_face){
        Point_3V a,b,n;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(one_face-&amp;gt;p!=&lt;span&gt;NULL){
            a.set_Point(one_face&lt;/span&gt;-&amp;gt;p[&lt;span&gt;1&lt;/span&gt;].x-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;].x,one_face-&amp;gt;p[&lt;span&gt;1&lt;/span&gt;].y-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;].y,one_face-&amp;gt;p[&lt;span&gt;1&lt;/span&gt;].z-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].z);
            b.set_Point(one_face&lt;/span&gt;-&amp;gt;p[&lt;span&gt;2&lt;/span&gt;].x-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;].x,one_face-&amp;gt;p[&lt;span&gt;2&lt;/span&gt;].y-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;].y,one_face-&amp;gt;p[&lt;span&gt;2&lt;/span&gt;].z-one_face-&amp;gt;p[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].z);
            n&lt;/span&gt;=&lt;span&gt;xiangliangji(a,b);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断一个面是否可见,如果一个面可见,则这个面上的四个点也可见&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; view_face(face *&lt;span&gt;one_face, Point_3V v){
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; cos,a_mo,b_mo;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求一个面的法向量&lt;/span&gt;
&lt;span&gt;            Point_3V fa;
            fa&lt;/span&gt;=&lt;span&gt;n(one_face);

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a_temp=pow((&lt;span&gt;double&lt;/span&gt;)fa.x,&lt;span&gt;2&lt;/span&gt;)+pow((&lt;span&gt;double&lt;/span&gt;)fa.y,&lt;span&gt;2&lt;/span&gt;)+pow((&lt;span&gt;double&lt;/span&gt;)fa.z,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            a_mo&lt;/span&gt;=&lt;span&gt;sqrt(a_temp);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b_temp=pow(v.x,&lt;span&gt;2&lt;/span&gt;)+pow(v.y,&lt;span&gt;2&lt;/span&gt;)+pow(v.z,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            b_mo&lt;/span&gt;=&lt;span&gt;sqrt(b_temp);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; fz=&lt;span&gt;diancheng(fa,v);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; fm=a_mo*&lt;span&gt;b_mo;
            cos&lt;/span&gt;=fz/&lt;span&gt;fm;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cos&amp;lt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
                one_face&lt;/span&gt;-&amp;gt;v=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断这个多边形体的各个点是否可见&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;&lt;span&gt;4&lt;/span&gt;;j++&lt;span&gt;){
                    one_face&lt;/span&gt;-&amp;gt;p[j].v=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3V面投影&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; reflect_Face(Point_3V v,CPoint move,&lt;span&gt;bool&lt;/span&gt; draw_Line,&lt;span&gt;bool&lt;/span&gt; fill_face,&lt;span&gt;int&lt;/span&gt; c1_fill,&lt;span&gt;int&lt;/span&gt; c2,CDC  *&lt;span&gt;p){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(view_face(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,v)){
            Line_2V l2_1&lt;/span&gt;=l1-&amp;gt;&lt;span&gt;reflect_Line(v,move,draw_Line,p);
            Line_2V l2_2&lt;/span&gt;=&lt;span&gt;l2.reflect_Line(v,move,draw_Line,p);
            Line_2V l2_3&lt;/span&gt;=&lt;span&gt;l3.reflect_Line(v,move,draw_Line,p);
            Line_2V l2_4&lt;/span&gt;=&lt;span&gt;l4.reflect_Line(v,move,draw_Line,p);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(fill_face){
                face_2V f2(l2_1,l2_2,l2_3,l2_4);
                f2.fill(c1_fill,c2,p);
            }
        }
    }

};


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多边形 p+f-l=2&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; cube{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isCube;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; :
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; point_num,face_num,line_num;
    Point_3V p[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];
    Line l[&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;];
    face f[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];
    cube(){
        point_num&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        face_num&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        line_num&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    cube(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; point_nums,&lt;span&gt;int&lt;/span&gt; line_nums,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; face_nums){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(point_nums+face_nums-line_nums==&lt;span&gt;2&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公式&lt;/span&gt;
            point_num=&lt;span&gt;point_nums;
            face_num&lt;/span&gt;=&lt;span&gt;face_nums;
            line_num&lt;/span&gt;=&lt;span&gt;line_nums;
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;p=new Point_3V[point_num];

            l=new Line[line_num];

            f=new face[face_num];&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

            isCube&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        cube();
        isCube&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_Point(Point_3V *&lt;span&gt;point){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;point_num;i++&lt;span&gt;){
            p[i]&lt;/span&gt;=&lt;span&gt;point[i];
        }

    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_cube(Point_3V *&lt;span&gt;point){
        set_Point(point);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上下 左右 前后 &lt;/span&gt;
        f[&lt;span&gt;0&lt;/span&gt;].set_Face(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;3&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;
        f[&lt;span&gt;1&lt;/span&gt;].set_Face( p[&lt;span&gt;7&lt;/span&gt;],p[&lt;span&gt;6&lt;/span&gt;],p[&lt;span&gt;5&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下 &lt;/span&gt;
&lt;span&gt;
        f[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;].set_Face(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;],p[&lt;span&gt;5&lt;/span&gt;],p[&lt;span&gt;1&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;
        f[&lt;span&gt;3&lt;/span&gt;].set_Face(p[&lt;span&gt;3&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;],p[&lt;span&gt;6&lt;/span&gt;],p[&lt;span&gt;7&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右 &lt;/span&gt;
&lt;span&gt;

        f[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;].set_Face(p[&lt;span&gt;1&lt;/span&gt;],p[&lt;span&gt;5&lt;/span&gt;],p[&lt;span&gt;6&lt;/span&gt;],p[&lt;span&gt;2&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前&lt;/span&gt;
        f[&lt;span&gt;5&lt;/span&gt;].set_Face(p[&lt;span&gt;0&lt;/span&gt;],p[&lt;span&gt;3&lt;/span&gt;],p[&lt;span&gt;7&lt;/span&gt;],p[&lt;span&gt;4&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后 &lt;/span&gt;
&lt;span&gt;    }
    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; reflect_Cube(Point_3V v,CPoint move,&lt;span&gt;bool&lt;/span&gt; draw_Line,&lt;span&gt;bool&lt;/span&gt; fill_face,&lt;span&gt;int&lt;/span&gt; *c1_fill,&lt;span&gt;int&lt;/span&gt; c2,CDC  *&lt;span&gt;p){
        f[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],c2,p);
        f[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],c2,p);

        f[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;],c2,p);
        f[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;],c2,p);

        f[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;],c2,p);
        f[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;].reflect_Face(v,move,draw_Line,fill_face,c1_fill[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;],c2,p);
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fill( &lt;span&gt;int&lt;/span&gt;&lt;span&gt; p){
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(p){
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;: {point_num=&lt;span&gt;2&lt;/span&gt;+line_num-face_num;} &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已知其它两个，求点&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:{line_num=point_num+face_num-&lt;span&gt;2&lt;/span&gt;;}&lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已知其它两个，求线&lt;/span&gt;
        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:{face_num=&lt;span&gt;2&lt;/span&gt;+line_num-point_num;}&lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已知其它两个，求面&lt;/span&gt;
&lt;span&gt;        }
    }

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; CMy1View::OnDraw(CDC*&lt;span&gt; pDC)
{
    CMy1Doc&lt;/span&gt;* pDoc =&lt;span&gt; GetDocument();
    ASSERT_VALID(pDoc);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pDoc)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 在此处为本机数据添加绘制代码&lt;/span&gt;
&lt;span&gt;
    Point_3V  p[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;]=&lt;span&gt;{ 
        Point_3V(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
        Point_3V(&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
        Point_3V(&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
        Point_3V(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
        Point_3V(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
        Point_3V(&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
        Point_3V(&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
        Point_3V(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偏移量&lt;/span&gt;
&lt;span&gt;    CPoint move;
    move.SetPoint(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;视点&lt;/span&gt;
    Point_3V v(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1.2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; color[&lt;span&gt;6&lt;/span&gt;]={RGB(&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),RGB(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),RGB(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;),RGB(&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;),RGB(&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;),RGB(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;&lt;span&gt;)};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cube&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; point_num=&lt;span&gt;8&lt;/span&gt;,face_num=&lt;span&gt;12&lt;/span&gt;,line_num=&lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
    cube cb(point_num,face_num,line_num);
    cb.set_cube(p);
    cb.reflect_Cube(v,move,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,color,&lt;span&gt;0&lt;/span&gt;,pDC);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线框模式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cb.reflect_Cube(v,move,true,true,color,0,pDC);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充模式&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 　　　　　　　　　　　　　线框                                                      填充&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;l  创建类Point_3V来存放三维点，Line_2V来存放二维点，Line来存放三维线，Line_2V来存放二维线，face_2V来存放二维面，face来存放三维面，cube来定义一个矩形。以上的二维都是用来平行投影时使用的，三维则是存放在三维空间中真实存在的矩形的信息，且这几个三维类之间使用了类的继承来实现。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;l  矩形点的输入顺序应该按照逆时针来输入，这是因为每个面的法向量有两种结果，但是使用背面检测法，只有朝向立方体的外部才为正方向，所以按照逆时针得出这个面上两个不共线的向量，然后求出两者的叉积就可以正确得出面的法向量。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;    cube(8点，12棱，6面)-&amp;gt; reflect_Cube(进行立方体的投影)-&amp;gt; f[i].reflect_Face(进行    每个面的投影) -&amp;gt; view_face（判断这个面是否可见，如果可见则将这个面上的4点设置为可    见;如果不可见则判断下个面是否可见） -&amp;gt;l2.reflect_Line(进行一个面4条线条线的投 影)-&amp;gt; end.reflect_Point_3V（进行这条线的两个点投影）-&amp;gt;判断是否画线(如果为真，画   线；否则不画)&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;l  在创建每一个三维真实的点，线，面时默认不可见，由于使用了，类的继承，所以比如要创建线时，要保证这条线的起点是从基类三维点继承过来的信息，所以应该使用指针，那么在线的构造函数中就应该为这个指针动态的创建一个空间，否则程序执行时，会无法访问这个指针的空间。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;l  在进行编程时，数学功底要扎实，我在进行两个向量的叉积运算时，未考虑到矩阵奇、偶列的符号不同，所以导致结果为下图所示，最后通过断点测试才知道这个原因。&lt;/p&gt;&lt;p align=&quot;left&quot;&gt;    不同颜色的面使用了数组中存放不同的颜色信息来实现，填充方式使用了种子填充，种子的位置使用了四边形的中心坐标。&lt;/p&gt;&lt;p&gt;&lt;span&gt;建议大家在使用种子填充时，使用VC6.0,不要用VS，VS会报错：（&lt;strong&gt;大家如果有好的方法来解决这个问题，请联系我：2283320260@qq.com&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;</description>
<pubDate>Sat, 06 Jan 2018 04:24:00 +0000</pubDate>
<dc:creator>feiquan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feiquan/p/8213875.html</dc:identifier>
</item>
<item>
<title>合并流以及已知文件流长度和未知文件长度的文件流读取方法 - 我心自在</title>
<link>http://www.cnblogs.com/10158wsj/p/8213810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/10158wsj/p/8213810.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　项目中有一个这样的需求，上传文件的时候需要多张文件一起上传，而且每张文件都有自己的文件信息，因为文件信息需要匹配验证，在处理过程中需要传输流的时候前半段固定长度为文件信息，后半段是文件流，而且还是多张批量的情况，经过不断摸索最终想出一个方案：那就是采用合并流，示意图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;批次信息&lt;/strong&gt;&lt;strong&gt;[256]+&lt;/strong&gt;&lt;strong&gt;文件信息流&lt;/strong&gt;&lt;strong&gt;1[1024]+&lt;/strong&gt;&lt;strong&gt;文件流&lt;/strong&gt;&lt;strong&gt;1+&lt;/strong&gt;&lt;strong&gt;文件信息流&lt;/strong&gt;&lt;strong&gt;2[1024]+&lt;/strong&gt;&lt;strong&gt;文件流&lt;/strong&gt;&lt;strong&gt;2+&lt;/strong&gt;&lt;strong&gt;文件信息流&lt;/strong&gt;&lt;strong&gt;3[1024]+&lt;/strong&gt;&lt;strong&gt;文件流&lt;/strong&gt;&lt;strong&gt;3…….&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面256是固定长度的一个流，里面是文件数量等信息，文件批量上传的时候就可以根据文件数量来循环文件的个数了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，1024固定长度信息中必须包含每个文件的大小（字节数），如果不知道大小的话，下一个循环的时候就会出现错误。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;合并流介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;        合并流，顾名思义，就是将多个流合并到一起形成一个完整的流，然后再根据需要截取需要的信息，原理很简单，下面是API：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SequenceInputStream getSequenceStream(String  fileInfoString,String filePath){

   　　 FileInputStream fs&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        ByteArrayInputStream bais&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        SequenceInputStream sis&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件信息流&lt;/span&gt;

              &lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; fileInfoString.getBytes();

              &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] info = Arrays.copyOf(b,1024&lt;span&gt;);

              bais&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(info);     

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件流&lt;/span&gt;
&lt;span&gt;
              File file&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath);

              fs&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file);

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并流&lt;/span&gt;
&lt;span&gt;
              sis&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SequenceInputStream(bais,fs);

             } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {

             　　 e.printStackTrace();

             }

             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sis;

        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面代码就是合并流的过程，非常简单，我们可以根据固定的1024长度得到文件信息，这个长度的设置可以根据实际需求来调整，或者是直接利用String类的length方法获取，没有固定的值。利用这个原理，我们就可以将多个文件合并成一个流传到我们需要的地方了，我们这个项目是吧文件写入大数据平台根据文件的具体大小存入Hbase或者HDFS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合并流搞定之后，接下来我们就是截取合并流了，这里就出现了一个问题，文件信息我们可以根据前面的固定长度截取读出来进行解析，因为他是转化String类型很容易，但是文件流呢，虽然我们知道他的大小，但是如何快速的把他读出来并写入磁盘呢？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;第一种方案:&lt;/strong&gt;&lt;strong&gt;直接读写&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;        这种方案就是我们根据文件信息中告诉我们的流大小，然后开辟相应的缓冲区，把它一次性的写入我们的磁盘，下面是代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; [] getBytes(BufferedInputStream bis,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; fileSize){

                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                         ByteArrayOutputStream bos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();

                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)fileSize;

                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readCount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经成功读取的字节&lt;/span&gt;

                         &lt;span&gt;int&lt;/span&gt; len=0&lt;span&gt;;

                         &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; []buf=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[count];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                      buf=new byte[count];&lt;/span&gt;
&lt;span&gt;
                         logger.info(&lt;/span&gt;&quot;Hbase可读文件大小：&quot;+&lt;span&gt;count);

                         &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(readCount&amp;lt;&lt;span&gt;count){

                                  len&lt;/span&gt;=bis.read(buf, readCount, count-&lt;span&gt;readCount);

                                  readCount&lt;/span&gt;+=&lt;span&gt;len;

                         }

                         bos.write(buf);

                         bos.flush();

                         buffer &lt;/span&gt;=&lt;span&gt; bos.toByteArray();

                         bos.close();

                 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {

                         e.fillInStackTrace();

                 }

                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过测试，这种方案是可行的，但是我们做的是大数据的项目，客户对效率的要求非常高，从压力测试来看效率非常低，另外，如果文件很大的话，这样的buffer开辟的区域会占用很大的内存，所以这种方案，虽然功能上可行，但是不可取，没有效率。下面是测试效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1153367/201801/1153367-20180106114113128-1135387242.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方案功能可行，但是效率不行，问题的根源就在于读流的方法没有效率，没有发挥出read方法的功效，而且开辟的缓冲区根据文件的大小而不同，如果一个批次文件太多的话，很容易把内存占满，发生内存溢出。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;第二种方案：循环读写&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;        这种方案是前一种方案的改进，我们根据文件大小利用循环读完固定长度的流，首先解释一下为什么要这样写while循环，要从read这个方法说起，从源码分析来看，read这个方法一次性本来就不可已读完整个流的，所以为了保证所有的流都读完，只能这样写。下面是方法：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------改进的方法-----------------------------&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; [] getBytess(BufferedInputStream bis,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; fileSize){

                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                   　　ByteArrayOutputStream bos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();

                      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)fileSize;

                      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readCount=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经成功读取的字节&lt;/span&gt;
                      &lt;span&gt;int&lt;/span&gt; len=0&lt;span&gt;;
                      &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; []buf=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4096&lt;span&gt;];&lt;br/&gt;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( count&amp;gt;0&lt;span&gt;){
                         len&lt;/span&gt;=bis.read(buf,0&lt;span&gt;,count);
                         bos.write(buf);
                         count&lt;/span&gt;-=&lt;span&gt;len;
                         }
                         bos.flush();
                         buffer &lt;/span&gt;=&lt;span&gt; bos.toByteArray();
                         bos.close();
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;
                 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.fillInStackTrace();
                 }
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;
        }                                        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        这样的尝试貌似可行，但是在测试的过程中又出现问题了，这种方案流是能读完，但是偶尔会读多，为什么呢？问题出现在while循环里，因为最后一次的循环可能不是文件剩下的那么多，比如1028个字节的流，它第一次会读1024，第二次读的就不是剩下的8个字节了，而且还是1024，原因就在于read这个方法，除非到-1他能读完，但是我们又不能读到-1，所以这种方法还需要改进，其实很简单，加判断就可以了，下面是改进的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; [] getBytes(BufferedInputStream bis,&lt;span&gt;long&lt;/span&gt; fileSize) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{

                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                 ByteArrayOutputStream bos&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                 bos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
                 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)fileSize;
                 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len=0&lt;span&gt;;
                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; []buf=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4096&lt;span&gt;];

                 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(count&amp;gt;0&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;lt;&lt;span&gt;buf.length){
                        len&lt;/span&gt;=bis.read(buf,0&lt;span&gt;,count);
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        len&lt;/span&gt;=&lt;span&gt;bis.read(buf);
                    }
                        bos.write(buf,&lt;/span&gt;0&lt;span&gt;,len);
                         count&lt;/span&gt;-=&lt;span&gt;len;
                 }
                 bos.flush();
                 buffer &lt;/span&gt;=&lt;span&gt; bos.toByteArray();
                 bos.close();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;经过测试后这种方法不仅可行而且对效率也没有影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1153367/201801/1153367-20180106115025081-1247138889.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从效果来看，效率提升了不止一倍。最后附上一次性读完流的代码，这种方式可以把整个流读完。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; [] getBytes(BufferedInputStream bis) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{

                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                 ByteArrayOutputStream bos&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                 bos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
                 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len=0&lt;span&gt;;

                 &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; []buf=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[1024&lt;span&gt;];

                 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((len=bis.read(buf))!=-1&lt;span&gt;){

                         bos.write(buf, &lt;/span&gt;0&lt;span&gt;, len);

                 }

                 bos.flush();

                 buffer&lt;/span&gt;=&lt;span&gt;bos.toByteArray();

                 bos.close();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 06 Jan 2018 03:57:00 +0000</pubDate>
<dc:creator>我心自在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/10158wsj/p/8213810.html</dc:identifier>
</item>
</channel>
</rss>