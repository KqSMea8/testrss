<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>菜鸟之旅——学习线程（2） - 愉悦的绅士</title>
<link>http://www.cnblogs.com/nbclw/p/8441317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbclw/p/8441317.html</guid>
<description>&lt;p&gt;　　前面两篇回顾线程和线程池的使用方法，微软在.NET4.5推出了新的线程模型-Task。本篇将简单的介绍Task的使用方法。&lt;/p&gt;

&lt;p&gt;　　Task与线程或者说线程池关系紧密，可以说是基于线程池实现的，虽说任务最终还是要抛给线程去执行，但是Task仍然会比线程、线程池的开销要小，并且提供了可靠的API来控制线任务执行。&lt;/p&gt;
&lt;p&gt;　　使用Task来执行的任务最终会交给线程池来执行，若该任务需要长时间执行，可以将其标记为LongRunning，这是便会单独去请求创建线程来执行该任务。&lt;/p&gt;

&lt;h2&gt;　创建&lt;/h2&gt;
&lt;p&gt;　　Task的创建也存在两种方式，使用new或者使用静态工厂方式来创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Task t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task(Menthod1);
            t.Start();

            Task.Factory.StartNew(Menthod2);
            
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod2()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面说到使用Task执行任务最终还是需要线程池来执行，若不想让线程池来执行，可以添加LongRunning标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Task t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task(Menthod1, TaskCreationOptions.LongRunning);
        t.Start();

        Task.Factory.StartNew(Menthod2, TaskCreationOptions.LongRunning);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　TaskCreationOptions还有很多枚举值，用来控制任务的更多属性。&lt;/p&gt;
&lt;h2&gt;　参数与返回值&lt;/h2&gt;
&lt;p&gt;　　使用Task也可以传入参数（object类型）与返回值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Task.Factory.StartNew(Menthod1, &lt;/span&gt;&lt;span&gt;233&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int result = Task.Factory.StartNew(new Func&amp;lt;object, int&amp;gt;(Menthod3), 233).Result;&lt;/span&gt;
            Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; t = Task.Factory.StartNew(&lt;span&gt;new&lt;/span&gt; Func&amp;lt;&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(Menthod3), &lt;span&gt;233&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; t.Result;

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod1(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Menthod3(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;6000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程3的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;obj&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这里为了获取返回值，阻塞了主线程，这里请注意一下。&lt;/p&gt;
&lt;h2&gt;　等待Task&lt;/h2&gt;
&lt;p&gt;　　可以使用Task实例的Wait方法来实现等待任务结束，也可以向多线程一样，使用WaitAll和WaitAny一样来等待多个任务结束，不过操作更为简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        t.Wait();
        Task.WaitAll(t1, t2 ...);
        Task.WaitAny(t1, t2 ...);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　取消Task&lt;/h2&gt;
&lt;p&gt;　　任务也是可以事先取消的，不过需要使用CancellationTokenSource：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task.Factory.StartNew(Menthod1);

            CancellationTokenSource cancelTokenSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
            Task.Factory.StartNew(Menthod2, cancelTokenSource.Token);
            cancelTokenSource.Cancel();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码就可以将线程2给取消掉，当然，Cancel方法可以自己找个合适的地方调用。&lt;/p&gt;

&lt;h2&gt;　继续Task&lt;/h2&gt;
&lt;p&gt; 　　在Task中，可以实现在一个任务结束后开启另一个新的任务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Task t &lt;/span&gt;=&lt;span&gt; Task.Factory.StartNew(Menthod1);
            t.ContinueWith(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Action&amp;lt;Task&amp;gt;&lt;span&gt;(Menthod4));

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod4(Task t)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程4的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里因为使用了委托，也可以使用lambda表达式，更简单一些调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Task t =&lt;span&gt; Task.Factory.StartNew(Menthod1);
        t.ContinueWith(task &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程4的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务t的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task.Id);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　使用传统线程方式来进行多线程编程的时候，对线程的控制总是不到位，产生一些奇奇怪怪的问题；或是代码写得很杂乱；或是开发人员乱用线程，比方说无限制的创建线程、将线程池线程占满，等等。&lt;/p&gt;
&lt;p&gt;　　Task的出现，实现对传统线程操作的封装，提供可靠高效的API来控制线程，极大的方便多线程编程，所以可以用到Task的地方尽量使用Task；当然，这里仍会产生线程安全的问题，同样需要进行线程同步，与上一篇处理方式类似。&lt;/p&gt;
&lt;p&gt;　　Task的内容还有很多，更深层的运行原理、封装还等着我们去了解，现在只把我用到的东西分享出来，希望能帮助到需要的人。&lt;/p&gt;
&lt;p&gt;　　线程的学习就先告一段落了，敬请期待新的内容吧。&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 15:37:00 +0000</pubDate>
<dc:creator>愉悦的绅士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nbclw/p/8441317.html</dc:identifier>
</item>
<item>
<title>JSON入门看这一篇就够了 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8445746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8445746.html</guid>
<description>&lt;p&gt;JSON：&lt;strong&gt;JavaScript Object Notation&lt;/strong&gt; 【JavaScript 对象表示法】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON 是存储和交换文本信息的语法。类似 XML。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON采用完全独立于任何程序语言的文本格式，使JSON成为理想的数据交换语言S&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;提到JSON，我们就应该和XML来进行对比。XML也是一种存储和交换文本信息的手段。那么JSON好在哪里呢？？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSON 比 XML 更小、更快，更易解析&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;javaScript原生支持JSON，解析速度会很快&lt;/li&gt;
&lt;li&gt;XML解析成DOM对象的时候，浏览器【IE和fireFox】会有差异&lt;/li&gt;
&lt;li&gt;使用JSON会更简单&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170518132651669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更加容易创建JavaScript对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'city'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'北京'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'上海'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'广州'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'深圳'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;city&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;p&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;city&lt;/span&gt;[i]&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;br/&amp;gt;&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;客户端与服务端的交互数据无非就是两种&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是乎，JSON所表示的数据要么就是对象，要么就是数据&lt;/p&gt;
&lt;p&gt;JSON语法是javaScript语法的子集，&lt;strong&gt;javaScript用[]中括号来表示数组，用{}大括号来表示对象，JSON亦是如此&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;json数组&quot;&gt;JSON数组：&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; employees &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Bill&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Gates&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;George&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Bush&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;firstName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Thomas&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lastName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Carter&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    ]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;json对象&quot;&gt;JSON对象&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;dt&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我爱学习&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;当然啦，数组可以包含对象，在对象中也可以包含数组&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;javaScript原生支持JSON的，&lt;strong&gt;我们可以使用eval()函数来解析JSON，把JSON文本数据转换成一个JavaScript对象。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//在写JOSN的时候，记得把带上逗号&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; txt &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;{a:123,&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;
                    &lt;span class=&quot;st&quot;&gt;&quot;b:'zhongfucheng'}&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//使用eval解析JSON字符串，需要增添()&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; aa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;eval&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;(&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; txt &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;)&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(aa)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170407091040539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用Strus2的时候，Struts2自带了组件能够让JavaBean对象、集合转成是JSON，不用我们自己拼接...这是非常方便的。&lt;/li&gt;
&lt;li&gt;使用SpringMVC的时候，SpringMVC也支持将JavaBean转成JSON&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，我们不一定使用框架来做开发呀。因此，我们还得&lt;strong&gt;学习使用第三方库来将JavaBean对象、集合转成JSON&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入开发包&quot;&gt;导入开发包&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;commons-io-2.0.1.jar&lt;/li&gt;
&lt;li&gt;commons-lang-2.5.jar&lt;/li&gt;
&lt;li&gt;commons-collections-3.1.jar&lt;/li&gt;
&lt;li&gt;commons-beanutils-1.7.0.jar&lt;/li&gt;
&lt;li&gt;ezmorph-1.0.3.jar&lt;/li&gt;
&lt;li&gt;json-lib-2.1-jdk15.jar&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事例代码&quot;&gt;事例代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package cn.itcast.javaee.js.bean2json;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import net.sf.json.JSONArray;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.*;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 使用第三方工具，将JavaBean对象/List或Set或Map对象转成JSON &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@author &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;AdminTC&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestBean2Json {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;javabean2json&lt;/span&gt;() {
        City city = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;);
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(city);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;list2json&lt;/span&gt;() {
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;珠海&quot;&lt;/span&gt;));
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(cityList);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;珠海&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;set2json&lt;/span&gt;() {
        Set&amp;lt;City&amp;gt; citySet = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;City&amp;gt;();
        citySet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广州&quot;&lt;/span&gt;));
        citySet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;珠海&quot;&lt;/span&gt;));
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(citySet);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;id&quot;:1,&quot;name&quot;:&quot;广州&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;珠海&quot;}]&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;javabeanlist2json&lt;/span&gt;() {
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;中山&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;佛山&quot;&lt;/span&gt;));
        Province province = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Province&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;广东&quot;&lt;/span&gt;,cityList);
        
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(province);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          [&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;id&quot;:1,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;name&quot;:&quot;广东&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;              &quot;cityList&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;中山&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;佛山&quot;}],&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          ]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;          */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;map2json&lt;/span&gt;() {
        
        List&amp;lt;City&amp;gt; cityList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;City&amp;gt;();
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;中山&quot;&lt;/span&gt;));
        cityList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;City&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;佛山&quot;&lt;/span&gt;));
        
        Map&amp;lt;String,Object&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;String,Object&amp;gt;();
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;total&quot;&lt;/span&gt;,cityList.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());&lt;span class=&quot;co&quot;&gt;//表示集合的长度&lt;/span&gt;
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;rows&quot;&lt;/span&gt;,cityList);&lt;span class=&quot;co&quot;&gt;//rows表示集合&lt;/span&gt;
        
        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(map);
        String jsonJAVA = jSONArray.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
        &lt;span class=&quot;co&quot;&gt;//[{&quot;total&quot;:2,&quot;rows&quot;:[{&quot;id&quot;:1,&quot;name&quot;:&quot;中山&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;佛山&quot;}]}]&lt;/span&gt;
        
        jsonJAVA = jsonJAVA.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,jsonJAVA.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;()-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(jsonJAVA);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;把要解析成JSON 的javaBena对象、集合放进下面这段代码即可！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        JSONArray jSONArray = JSONArray.&lt;span class=&quot;fu&quot;&gt;fromObject&lt;/span&gt;(map);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;无论放进去什么，返回的都是数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170518132718061?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，可以关注微信公众号:Java3y&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 12 Feb 2018 14:37:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8445746.html</dc:identifier>
</item>
<item>
<title>.net下使用socket.io随笔记录 - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8443395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8443395.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前公司在互联网产品上需要程序与前端部分要进行一个实时交互，在进行一定程度上的选型后，决定使用&lt;a href=&quot;https://socket.io/&quot; target=&quot;_blank&quot;&gt;socket.io&lt;/a&gt;框架进行一个实践，算是公司的一个新的 尝试，也算是给自己增加增长见闻，由于我是做后端以及桌面程序开发，所以前端部分就不细聊，主要是针对桌面程序如何连接socket.io进行一个尝试&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、基本逻辑图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/465472/201802/465472-20180211222553185-1326709745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本地应用程序：部署在局域网内（可以联通外网），主要负责相关数据获取&lt;/p&gt;
&lt;p&gt;　　Web浏览器端：跟本地应用程序不是处于同一个网络，请求发起方&lt;/p&gt;
&lt;p&gt;　　中转服务（重点）：中转服务集成认证功能，必须经过认证的客户端才允许进行连接，并且对于客户端要有唯一指定的ID进行连接操作&lt;/p&gt;
&lt;p&gt;　　整体思路如以上的流程图，由Web浏览器端开始发起请求，Web浏览器端通过连接中转服务，将信息发送给指定的本地应用程序，应用程序处理完成后，将结果通过原路径进行一个反馈&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、客户端程序开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　客户端SDK采用&lt;a href=&quot;https://github.com/Quobject/SocketIoClientDotNet&quot; data-pjax=&quot;#js-repo-pjax-container&quot;&gt;SocketIoClientDotNet&lt;/a&gt;，这是一个github上开源的，可以连接socket.io的客户端，支持.net 3.5及以上，可以方便的帮助我们进行连接socket.io的开发&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 Socket  socket = IO.Socket(&quot;ws://192.168.7.4:3000&quot;, new IO.Options()
            {
                Reconnection = true,
                Cookies = new Dictionary&amp;lt;string, string&amp;gt;() { { &quot;companyId&quot;, GlobalStatic.COMPANY.COMPANY_ID }, { &quot;userId&quot;, GlobalStatic.UserDomain.user.USER_ID } },
                Timeout = 60000,
                ReconnectionDelay = 1000,

                Transports = new List&amp;lt;string&amp;gt;() { &quot;websocket&quot; },
                Path =&quot;heart&quot;
            });

            socket.On(Socket.EVENT_CONNECT, () =&amp;gt;
            {

                JObject jObject = JObject.Parse(Newtonsoft.Json.JsonConvert.SerializeObject(new
                {
                    companyId = GlobalStatic.COMPANY.COMPANY_ID,
                    token = GlobalStatic.TOKEN,
                    hostId = GlobalStatic.HOST_ID,
                    hostName = GlobalStatic.HOST_NAME,
                    printerNames = GlobalStatic.HOSTINFO.PrinterName,
                    source = &quot;assistant&quot;,
                    userId = GlobalStatic.UserDomain.user.USER_ID
                }));
                socket.Emit(&quot;authentication&quot;, jObject);
                Debug.WriteLine(&quot;authentication&quot;);
            });
            socket.On(Socket.EVENT_DISCONNECT, (data) =&amp;gt;
            {
                Debug.WriteLine(&quot;心跳断开连接&quot; + data);
                flag = false;
                OnConnectionStatus?.Invoke(flag);
                socket.Disconnect();
            });
            socket.On(&quot;authenticated&quot;, (obj) =&amp;gt;
            {
                flag = true;
                OnConnectionStatus?.Invoke(flag);
                Debug.WriteLine(&quot;心跳认证成功：&quot; + obj);
            });
            socket.On(&quot;unauthorized&quot;, (obj) =&amp;gt;
            {
                Debug.WriteLine(&quot;心跳认证失败&quot; + obj);
                socket.Disconnect();
            });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SocketIoClientDotNet注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;emit的数据必须为字符串或者JObject（Newtonsoft.Json中的）&lt;/li&gt;
&lt;li&gt;从实际情况来看，内部每个On的监听都是维护了一个线程，所有如果是不想要阻塞的话，那在on的方法中还需要自己起线程去完成&lt;/li&gt;
&lt;li&gt;如果不在options中设置AutoConnect=false的话，那实例化socket成功之后就会进行connect动作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;三、关于SocketIoClientDotNet坑的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在实际的使用过程中，偶然发现在程序开了很久 之后，线程数会一直增多，尝试调节各种参数都毫无作用，最后只能无奈的跟踪源码部分，在Thread文件夹下找到Heartbeat_net35.cs文件中，发现run方法里的while一直无法跳出去，并且注册DoWork越来越多，如下所示，导致线程越来越多，目前解决办法是将该代码注释掉，还没发现什么问题，如果有哪位知道这段代码作用的话，望告知，谢谢&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using System;
using System.ComponentModel;
using System.Threading;

namespace Quobject.EngineIoClientDotNet.Thread
{
    public class Heartbeat
    {
        private volatile bool gotHeartbeat = false;
        private BackgroundWorker heartBeatTimer= new BackgroundWorker();
        private CancellationTokenSource ts;

        private Heartbeat()
        {
            ts = new CancellationTokenSource();
        }

        public static Heartbeat Start(Action onTimeout, int timeout)
        {
            Heartbeat heartbeat = new Heartbeat();
            heartbeat.Run(onTimeout, timeout);
            return heartbeat;            
        }

        public void OnHeartbeat()
        {
            gotHeartbeat = true;
        }

        private void Run(Action onTimeout, int timeout)
        {
            heartBeatTimer = new BackgroundWorker();

            heartBeatTimer.DoWork += (s, e) =&amp;gt;
            {
               while (!ts.IsCancellationRequested)
               {
                    System.Threading.Thread.Sleep(timeout);
                    if (!gotHeartbeat &amp;amp;&amp;amp; !ts.IsCancellationRequested)
                    {
                        onTimeout();
                        break;
                    }
                }
            };

            heartBeatTimer.RunWorkerAsync();
        }

        public void Stop()
        {
            ts.Cancel();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docket等互联网相关&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出, &lt;a href=&quot;http://www.cnblogs.com/OMango/p/8443395.html&quot;&gt;原文链接&lt;/a&gt; 如有问题， 可邮件（hongjb@yizit.com）咨询.&lt;/p&gt;



</description>
<pubDate>Mon, 12 Feb 2018 14:13:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8443395.html</dc:identifier>
</item>
<item>
<title>AMDP + XLSX Workbench 报表开发模式 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/8422711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/8422711.html</guid>
<description>&lt;p&gt;本文介绍了我和同事通过使用AMDP + XLSX Workbench缩短报表开发周期、分离数据查询处理逻辑和前端展示工作的经验。欢迎讨论。&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近接到了一套人力资源报表的开发需求，需要以EXCEL表格的方式输出，且包含大量sheet页，每个sheet相当于一个独立的报表。&lt;/p&gt;
&lt;p&gt;这种情况下，如果让同一个人开发所有内容，将会花费较长的开发周期，因此，要将程序分解成若干个部分，最好每个报表（sheet）都是一个独立的子模块，让不同的人同时开发。&lt;/p&gt;
&lt;p&gt;对于这类报表，我们之前的做法是，使用OLE输出EXCEL文件，在report程序中，使用逻辑数据库获取数据，引入常用的OLE方法，为每个sheet创建一个include文件，实现不同sheet的代码分离。&lt;/p&gt;
&lt;p&gt;代码类似这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;REPORT&lt;/span&gt;&lt;span&gt; zhr_report .

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;***********************************************************************&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; INCLUDES&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;***********************************************************************&lt;/span&gt;
&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_top.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//数据定义&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_s01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//选择屏幕```````````&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; z_ole_excel_hr.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//通用EXCEL操作子程序&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_m01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//事件&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_f01.   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//通用模块&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex01.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet1&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report ex02.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet2&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex03.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet3&lt;/span&gt;

&lt;span&gt;INCLUDE&lt;/span&gt; zhr_report_ex04.  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//Sheet4&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;INCLUDE &lt;span&gt;zhr_report_ex05&lt;/span&gt;.  &lt;span&gt;&quot;&lt;span&gt;//Sheet5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212200519874-1852854270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过将通用的OLE方法封装到一个包含文件中，并使sheet页的处理放到不同的包含文件，可以使对它们的同时编辑成为可能。但是，这种做法也是有问题的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;包含文件不是单独的程序，这意味着只要有一个include文件中有语法错误，语法检查时就会给出提示，从而无法激活整个程序。&lt;/li&gt;
&lt;li&gt;命名空间相同，这意味着定义子程序或FORM名时，很容易发生冲突&lt;/li&gt;
&lt;li&gt;只能通过增加包含文件实现程序的横向扩展，较难实现程序的纵向扩展。通用部分一旦确定，再想修改会比较困难。&lt;/li&gt;
&lt;li&gt;OLE的性能较差。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决这些问题，我们引入了AMDP + XLSX Workbench的报表开发模式。&lt;/p&gt;
&lt;p&gt;改进后的模式示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180210153705920-1446687735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: AMDP + XSLX Workbench 报表开发模式&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/8422711.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/8422711.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;名词解释&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;AMDP&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;全称ABAP-Managed Database Procedure，一种ABAP on HANA的实现方式，提供了在ABAP中运行SQL Script的可能，并且与ABAP中的类和数据类型有良好的集成。之前的有关AMDP的文章：&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/7976533.html&quot;&gt;ABAP中的AMDP（ABAP-Managed Database Procedures ）&lt;/a&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;XLSX Workbench&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;一种可视化表单生成工具，相比复杂的OLE，可以用少量代码+一些拖拽和配置来生成EXCEL报表，性能更好。按XLSX Workbench的文档介绍，它有九大特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无需ABAP编程技能&lt;/li&gt;
&lt;li&gt;可视化设计方式&lt;/li&gt;
&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;支持后台处理&lt;/li&gt;
&lt;li&gt;强大的表单格式特性支持&lt;/li&gt;
&lt;li&gt;支持公式&lt;/li&gt;
&lt;li&gt;支持图片&lt;/li&gt;
&lt;li&gt;支持图表&lt;/li&gt;
&lt;li&gt;支持树&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;官方文档：&lt;a href=&quot;https://sites.google.com/site/sapxlwb/home&quot; target=&quot;_blank&quot;&gt;https://sites.google.com/site/sapxlwb/home&lt;/a&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;代码例子&lt;/h2&gt;
&lt;p&gt;注意，本部分内容会假设读者已经有使用AMDP的XLSX Workbench的初步经验（至少是能输出Hello World的水平）。如果不是这样的话，可能会对其中的某些内容感到困惑。&lt;/p&gt;
&lt;p&gt;1，首先，创建一个接口ZIF_XLSX_REPORT。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INTERFACE&lt;/span&gt;&lt;span&gt; zif_xlsx_report

  &lt;/span&gt;&lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt; .

  &lt;/span&gt;&lt;span&gt;METHODS&lt;/span&gt;&lt;span&gt; get_data&lt;/span&gt;&lt;span&gt;CHANGING&lt;/span&gt;&lt;span&gt;
      !data            &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; sflight_t
    &lt;span&gt;RAISING&lt;/span&gt;
      cx_amdp_error .

&lt;/span&gt;&lt;span&gt;ENDINTERFACE&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口包含一个get_data方法，方法有一个参数&lt;span&gt;data，它数据类型，即为将要输出给XLSX Workbench表单的的数据类型。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2，为接口创建实现类。&lt;/p&gt;
&lt;p&gt; 为接口创建一个实现类，在方法ZIF_XLSX_REPORT~GET_DATA中调用AMDP类方法，进行数据处理后，将得到的数据填充进chaging参数data中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CLASS&lt;/span&gt; zcl_xlsx_report1 &lt;span&gt;DEFINITION&lt;/span&gt;

  &lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt;
  FINAL
  &lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PUBLIC&lt;/span&gt;&lt;span&gt; .

  &lt;/span&gt;&lt;span&gt;PUBLIC&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.

    &lt;/span&gt;&lt;span&gt;INTERFACES&lt;/span&gt;&lt;span&gt; zif_xlsx_report .
  &lt;/span&gt;&lt;span&gt;PROTECTED&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.
  &lt;/span&gt;&lt;span&gt;PRIVATE&lt;/span&gt; &lt;span&gt;SECTION&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;ENDCLASS&lt;/span&gt;&lt;span&gt;.



&lt;/span&gt;&lt;span&gt;CLASS&lt;/span&gt; ZCL_XLSX_REPORT1 &lt;span&gt;IMPLEMENTATION&lt;/span&gt;&lt;span&gt;.


&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &amp;lt;SIGNATURE&amp;gt;---------------------------------------------------------------------------------------+&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | Instance Public Method ZCL_XLSX_REPORT1-&amp;gt;ZIF_XLSX_REPORT~GET_DATA&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; +-------------------------------------------------------------------------------------------------+&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | [&amp;lt;--&amp;gt;] DATA                           TYPE        SFLIGHT_T&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; | [!CX!] CX_AMDP_ERROR&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt; +--------------------------------------------------------------------------------------&amp;lt;/SIGNATURE&amp;gt;&lt;/span&gt;
  &lt;span&gt;METHOD&lt;/span&gt;&lt;span&gt; zif_xlsx_report~get_data.


    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用AMDP类的方法&lt;/span&gt;

    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据处理&lt;/span&gt;


  &lt;span&gt;ENDMETHOD&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;ENDCLASS&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，在report程序中调用各个实现类。&lt;/p&gt;

&lt;p&gt;这是关键的一步：在report程序中动态地获取全部实现类，并依次实例化、调用其接口方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;CONSTANTS&lt;/span&gt;: c_interface &lt;span&gt;TYPE&lt;/span&gt; seoclsname VALUE &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZIF_XLSX_REPORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;TRY&lt;/span&gt;&lt;span&gt;.

      &lt;/span&gt;&lt;span&gt;DATA&lt;/span&gt;(gt_classes) = cl_sic_configuration=&amp;gt;&lt;span&gt;get_classes_for_interface( c_interface ).

    &lt;/span&gt;&lt;span&gt;CATCH&lt;/span&gt;&lt;span&gt; cx_class_not_existent .

  &lt;/span&gt;&lt;span&gt;ENDTRY&lt;/span&gt;&lt;span&gt;.


  &lt;/span&gt;&lt;span&gt;LOOP&lt;/span&gt; &lt;span&gt;AT&lt;/span&gt; gt_classes &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;DATA&lt;/span&gt;&lt;span&gt;(gs_class).

    &lt;/span&gt;&lt;span&gt;TRY&lt;/span&gt;&lt;span&gt; .

        &lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;OBJECT&lt;/span&gt; go_ref &lt;span&gt;TYPE&lt;/span&gt; (gs_class-&lt;span&gt;clsname).

      &lt;/span&gt;&lt;span&gt;CATCH&lt;/span&gt;&lt;span&gt; cx_sy_create_object_error.

    &lt;/span&gt;&lt;span&gt;ENDTRY&lt;/span&gt;&lt;span&gt;.

    &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; go_ref &lt;span&gt;IS&lt;/span&gt;&lt;span&gt; BOUND.

          go_ref&lt;/span&gt;-&amp;gt;get_data( &lt;span&gt;CHANGING&lt;/span&gt; data =&lt;span&gt; g_data_structure ).

    &lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

  &lt;/span&gt;&lt;span&gt;ENDLOOP&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;由于XLSX Workbench中的一个表单在同一时间只能由一个人编辑，对于多sheet页的表格，无法让两个人并行开发表单。但是，因为表单独立于ABAP 程序，二者只需要通过约定好的内表结构（在示例中是SFLIGHT_T）通信。因此，可以在约定好通信结构的前提下，由一个人进行XLSX Workbench中表单的组件编辑、上下文绑定等工作，另一个（或多个）人进行数据逻辑处理工作。如果在引入了HANA开发人员，还可以把主要逻辑下推至HANA，从而使多人同时在不同层级上开发同一个套表，以提高总体开发速度。&lt;/li&gt;
&lt;li&gt;将每个sheet页写成一个类，所有类继承同一个接口，在report程序中动态地调用，可以将报表主程序的代码稳定下来，实现程序的解耦。不同的类之间也是个例的，可以方便地进行单独的单元测试，而不会在语法检查时受到其他人的开发内容的干扰。&lt;/li&gt;
&lt;li&gt;相比于本文开头提到的INCLUDE的方式，使用面向对象的新开发模式不仅提供了更好的横向扩展能力（只要增加新的实现类和结构字段即可实现数据处理逻辑和报表内容的扩展），而且也提供了更好的纵向扩展能力，可以通过面向对象的强大特性——继承——来实现对报表中相似部分进行抽象整合。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 align=&quot;left&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;总结了几点我们在实际开发中的经验，以供参考。&lt;/p&gt;
&lt;h3&gt;AMDP与SELECT-OPTIONS&lt;/h3&gt;
&lt;p&gt;细心的读者可能已经注意到上文的示例代码中并未处理选择屏幕这一关键问题。在Open SQL中我们可以很方便地直接使用range table。而在AMDP中使用它话需要一点点额外的代码：&lt;/p&gt;
&lt;p&gt;可以通过CL_SHDB_SELTAB=&amp;gt;COMBINE_SELTABS( )来将选择屏幕的输入条件转换为AMDP中的SQL Script中的WHERE条件字符串，并使用APPLY_FILTER函数应用这一条件，具体的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212211244062-1981454659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/994049/201802/994049-20180212211253890-893579063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（引用自 &lt;a href=&quot;https://blogs.sap.com/2015/03/30/handling-of-select-options-parameters-within-amdp/&quot; target=&quot;_blank&quot;&gt;Handling of SELECT-OPTIONS parameters within AMDP&lt;/a&gt;）&lt;/p&gt;
&lt;h3&gt;异常处理&lt;/h3&gt;
&lt;p&gt;在本文介绍的开发模式下，HANA视图、XLSX Workbench表单和ABAP类是可以并行开发的，这意味着开发阶段的HANA视图可能处于不稳定的状态。ABAP开发者应注意在AMDP方法中显式地声明异常、并在调用它是进行处理。不然会很容易遇到程序dump的情况:)&lt;/p&gt;
&lt;p&gt;具体的异常可见：&lt;a href=&quot;http://www.cnblogs.com/hhelibeb/p/7976533.html#_label4&quot;&gt;AMDP异常&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;自建结构/表命名&lt;/h3&gt;
&lt;p&gt;无论是AMDP方法还是XLSX Workbench表单，在实践中都需要自建结构/表来接收数据。在开发内容分离的情况下，&lt;strong&gt;作为通信定义的结构/表类型的命名尤其重要&lt;/strong&gt;。应当有一套合理的规则来为它们以及其中的字段命名。特别是XLSX Workbench表单的参数结构，在表单复杂的情况下，参数结构同样会是复杂的深度结构。如果命名不当的话，将会给开发和沟通带来相当的负担。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: AMDP + XSLX Workbench 报表开发模式&quot; href=&quot;http://www.cnblogs.com/hhelibeb/p/8422711.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/8422711.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 13:38:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/8422711.html</dc:identifier>
</item>
<item>
<title>Go基础之--接口 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8445614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8445614.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;在Go语言中，一个类只要实现了接口要求的所有函数，我们就说这个类实现了该接口&lt;/p&gt;
&lt;p&gt;interface类型可以定义一组方法，用来表示一个对象的行为特征，interface不能包含任何变量，接口是引用类型。&lt;/p&gt;
&lt;p&gt;举个简单的例子，一个动物的接口，动物有吃的能力，有叫的能力，等等，这里省略，假如动物就只有吃和叫的能力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;

type Animal interface {
    Eat()
    Talk()
}

type Dog struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;dog eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;dog talking....&quot;&lt;span&gt;)
}

type Cat struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Cat) Eat(){
    fmt.Println(&lt;/span&gt;&quot;cat eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Cat) Talk(){
    fmt.Println(&lt;/span&gt;&quot;cat talking....&quot;&lt;span&gt;)
}



func main(){
    var d Dog

    var a Animal
    a &lt;/span&gt;= &amp;amp;&lt;span&gt;d
    a.Eat()
    a.Talk()

    var c Cat
    a &lt;/span&gt;= &amp;amp;&lt;span&gt;c
    a.Eat()
    a.Talk()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个例子中，Cat和Dog实现了Animal的所有方法，所以Cat和Dog都是动物&lt;/p&gt;
&lt;p&gt;小结一下：&lt;br/&gt;Go中的接口不需要显示的实现，只要一个对象实现了接口类型中的所有方法，那么这个对象就实现了这个接口，当然如果一个对象实现了多个interface类型的方法，那么这个对象就实现了多个接口&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;用于理解接口的一个例子&lt;/h2&gt;
&lt;p&gt;我们都知道现在的手机有很多支付方式，如：微信支付，支付宝支付，银联支付等等，这里可以通过一个实现支付接口的例子来理解接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
//&lt;span&gt; 定义一个支付的接口
type Pay interface {
    pay(userId int64,money float32) error
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个struct
type AliPay struct {

}
&lt;/span&gt;//&lt;span&gt; 这里给AliPay添加一个支付方法，实现了Pay接口中的pay方法
func (a &lt;/span&gt;*&lt;span&gt;AliPay) pay(userId int64,money float32) error{
    fmt.Println(&lt;/span&gt;&quot;1.连接到阿里支付的服务器&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;2.连接到对应的用户&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;3.检查余额&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;4.扣钱&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;5.返回支付是否成功&quot;&lt;span&gt;)

    return nil
}

&lt;/span&gt;//&lt;span&gt; 微信支付
type WeChatPay struct {

}

&lt;/span&gt;//&lt;span&gt; 这里也是实现了Pay接口中的pay方法
func (w &lt;/span&gt;*&lt;span&gt;WeChatPay) pay(userId int64,money float32) error{
    fmt.Println(&lt;/span&gt;&quot;1.连接到微信支付的服务器&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;2.连接到对应的用户&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;3.检查余额&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;4.扣钱&quot;&lt;span&gt;)
    fmt.Println(&lt;/span&gt;&quot;5.返回支付是否成功&quot;&lt;span&gt;)

    return nil
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个手机struct,并通过字典方式存储自己开通的支付方式
type Phone struct {
   PayMap map[string]Pay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) OpenWeChatPay(){
    weChatPay :&lt;/span&gt;= &amp;amp;&lt;span&gt;WeChatPay{}
    p.PayMap[&lt;/span&gt;&quot;weChatPay&quot;] =&lt;span&gt; weChatPay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) OpenAliPay(){
    AliPay :&lt;/span&gt;= &amp;amp;&lt;span&gt;AliPay{}
    p.PayMap[&lt;/span&gt;&quot;aLiPay&quot;] =&lt;span&gt; AliPay
}

func (p &lt;/span&gt;*&lt;span&gt;Phone) PayMoney(name string,money float32)(err error){
    pay,ok:&lt;/span&gt;=&lt;span&gt; p.PayMap[name]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok{
        err &lt;/span&gt;= fmt.Errorf(&quot;不支持【%s】支付方式&quot;&lt;span&gt;,name)
        return
    }
    err &lt;/span&gt;= pay.pay(1024&lt;span&gt;,money)
    return
}


func main(){
    &lt;/span&gt;//&lt;span&gt; 这里切记 字典类型的数据是需要初始化的
    phone :&lt;/span&gt;= &amp;amp;&lt;span&gt;Phone{
        PayMap:make(map[string]Pay,&lt;/span&gt;10&lt;span&gt;),
}

    &lt;/span&gt;//&lt;span&gt; 这里是用于开通自己有哪些支付方式
    &lt;/span&gt;//&lt;span&gt;phone.OpenWeChatPay()
    phone.OpenAliPay()


    err :&lt;/span&gt;= phone.PayMoney(&quot;weChatPay&quot;,100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        &lt;/span&gt;//&lt;span&gt; 如果微信支付失败了，用支付宝支付
        fmt.Printf(&lt;/span&gt;&quot;支付失败，失败原因：%v\n&quot;&lt;span&gt;,err)
        fmt.Println(&lt;/span&gt;&quot;使用支付宝支付&quot;&lt;span&gt;)
        err &lt;/span&gt;= phone.PayMoney(&quot;aLiPay&quot;,100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
            fmt.Printf(&lt;/span&gt;&quot;支付失败，失败原因：%v\n&quot;&lt;span&gt;,err)
            return
        }
    }
    fmt.Println(&lt;/span&gt;&quot;支付成功，欢迎再次光临&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然可以把上面中关于开通支付方式的两个方法，用一个通用的方法实现，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
func (p *&lt;span&gt;Phone) OpenPay(name string,pay Pay){
    &lt;/span&gt;//&lt;span&gt; 可以把上面两个方法更改为这一个方法
    p.PayMap[name] &lt;/span&gt;=&lt;span&gt; pay
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;空接口&lt;/h2&gt;
&lt;p&gt;空接口没有任何方法，所有的类型都实现了空接口,空接口什么类型都可以存，如下例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main


import &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;

func main()  {
    &lt;/span&gt;//&lt;span&gt; 通过这个例子我们可以发现我们定义的一个空接口可以存任何类型的变量
    var a interface{}
    var b &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; = 10&lt;span&gt;
    a &lt;/span&gt;=&lt;span&gt; b
    fmt.Println(a)

    var c string &lt;/span&gt;= &quot;hello&quot;&lt;span&gt;
    a &lt;/span&gt;=&lt;span&gt; c
    fmt.Println(a)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;接口的嵌套&lt;/h2&gt;
&lt;p&gt;一个接口可以嵌套在另外的接口里面，同时一个接口也可以嵌套多个接口&lt;br/&gt;通过下面的例子来理解接口嵌套的概念&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import &lt;/span&gt;&quot;fmt&quot;

//&lt;span&gt; 这里定义一个Eater接口
type Eater interface {
    Eat()
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个Talker接口
type Talker interface {
    Talk()
}

&lt;/span&gt;//&lt;span&gt; 这里定义个动物的接口，同时嵌套了Eater和Talker接口
type Animal interface {
    Eater
    Talker
}

&lt;/span&gt;//&lt;span&gt; 这里定义一个Dog的struct，并实现talk方法和eat方法，这样就实现了动物的接口
type Dog struct {

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;talk....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;eating....&quot;&lt;span&gt;)
}

func main() {
    d :&lt;/span&gt;= &amp;amp;&lt;span&gt;Dog{}
    var a Animal
    a &lt;/span&gt;=&lt;span&gt; d
    a.Eat()
    a.Talk()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;类型断言&lt;/h2&gt;
&lt;p&gt;如果我们反向想要知道这个接口变量里面实际存储的是哪个类型的对象，可以用下面方法：&lt;br/&gt;通过下面这个例子理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;
)

type Animal interface {
    Eat()
    Talk()
}

type Dog struct{

}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Eat(){
    fmt.Println(&lt;/span&gt;&quot;dog eating.....&quot;&lt;span&gt;)
}

func (d &lt;/span&gt;*&lt;span&gt;Dog) Talk(){
    fmt.Println(&lt;/span&gt;&quot;dog talking....&quot;&lt;span&gt;)
}

type Cat struct{

}

func (c &lt;/span&gt;*&lt;span&gt;Cat) Eat(){
    fmt.Println(&lt;/span&gt;&quot;cat eating.....&quot;&lt;span&gt;)
}

func (c &lt;/span&gt;*&lt;span&gt;Cat) Talk(){
    fmt.Println(&lt;/span&gt;&quot;cat talking....&quot;&lt;span&gt;)
}

func justify(a Animal){
    &lt;/span&gt;//&lt;span&gt; 进行强制转换，如果转换失败则提示错误
    dog,ok :&lt;/span&gt;= a.(*&lt;span&gt;Dog)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok{
        fmt.Println(&lt;/span&gt;&quot;convert to dog failed&quot;&lt;span&gt;)
        return
    }
    dog.Eat()
}

func main()  {
    &lt;/span&gt;//&lt;span&gt; 分别实例化一个Dog和Cat,并通过justify来进行判断
    d :&lt;/span&gt;= &amp;amp;&lt;span&gt;Dog{}
    var a Animal
    a &lt;/span&gt;=&lt;span&gt; d
    a.Eat()
    justify(a)

    c :&lt;/span&gt;= &amp;amp;&lt;span&gt;Cat{}
    a &lt;/span&gt;=&lt;span&gt; c
    justify(a)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再写一个例子，用于判断函数中传入的参数的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;
)
&lt;/span&gt;//&lt;span&gt; 这里通过...interface{}表示传入的是可变参数
func justify(items ...interface{}){
    for index,v :&lt;/span&gt;=&lt;span&gt; range items{
       &lt;/span&gt;//&lt;span&gt;v.(type)表示获取变量的类型
        switch v.(type){
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is int\n&quot;&lt;span&gt;,index)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; float32:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is float32\n&quot;&lt;span&gt;,index)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; string:
            fmt.Printf(&lt;/span&gt;&quot;第%d个参数is string\n&quot;&lt;span&gt;,index)
        }
    }
}

func main() {
    var a float32
    var b string
    var c &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;
    justify(a,b,c)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于猫和狗代码例子中justify方法还可以更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func justify2(a Animal){
    switch t:&lt;/span&gt;=&lt;span&gt;a.(type){
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; *&lt;span&gt;Dog:
        t.Eat()
        fmt.Printf(&lt;/span&gt;&quot;t is Dog\n&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; *&lt;span&gt;Cat:
        t.Eat()
        fmt.Printf(&lt;/span&gt;&quot;t is Cat\n&quot;&lt;span&gt;)
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;判断一个变量是否实现了指定的接口&lt;/h2&gt;
&lt;p&gt;在最开始的时候写了一个关于理解接口的例子，如果我们现在想要判断一个变量是否实现了指定的支付的接口，可以通过如下代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
weChat := &amp;amp;&lt;span&gt;WeChatPay{}
&lt;/span&gt;//&lt;span&gt; 这里需要一个空接口
var tmp interface{} &lt;/span&gt;=&lt;span&gt; weChat
_,ok :&lt;/span&gt;=&lt;span&gt; tmp.(Pay)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ok{
    fmt.Println(&lt;/span&gt;&quot;weChat is implement Pay interface&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Feb 2018 13:35:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8445614.html</dc:identifier>
</item>
<item>
<title>spring security 4 filter 顺序及作用 - snowater</title>
<link>http://www.cnblogs.com/snowater/p/8443100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowater/p/8443100.html</guid>
<description>&lt;p&gt;Spring Security 有两个作用：认证和授权&lt;/p&gt;
&lt;h2&gt;一、Srping security 4 filter 别名及顺序&lt;/h2&gt;
&lt;p&gt;spring security 4 标准filter别名和顺序，因为经常要用就保存到自己博客吧  &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/4.2.4.RELEASE/reference/html/ns-config.html#ns-custom-filters&quot; target=&quot;_blank&quot;&gt;点击访问官网链接&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;strong&gt;Table 6.1. Standard Filter Aliases and Ordering&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;table-contents&quot;&gt;
&lt;table summary=&quot;Standard Filter Aliases and Ordering&quot; align=&quot;left&quot;&gt;&lt;colgroup&gt;&lt;col class=&quot;col_1&quot;/&gt;&lt;col class=&quot;col_2&quot;/&gt;&lt;col class=&quot;col_3&quot;/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Alias&lt;/th&gt;
&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Filter Class&lt;/th&gt;
&lt;th align=&quot;left&quot; valign=&quot;top&quot;&gt;Namespace Element or Attribute&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CHANNEL_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ChannelProcessingFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/intercept-url@requires-channel&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;SECURITY_CONTEXT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SecurityContextPersistenceFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;CONCURRENT_SESSION_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ConcurrentSessionFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;session-management/concurrency-control&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;HEADERS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;HeaderWriterFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/headers&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CSRF_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;CsrfFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/csrf&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;LOGOUT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;LogoutFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/logout&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;X509_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;X509AuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/x509&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;PRE_AUTH_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;AbstractPreAuthenticatedProcessingFilter&lt;/code&gt;Subclasses&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;CAS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;CasAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;FORM_LOGIN_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;UsernamePasswordAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/form-login&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;BASIC_AUTH_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;BasicAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/http-basic&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SERVLET_API_SUPPORT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SecurityContextHolderAwareRequestFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/@servlet-api-provision&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;JAAS_API_SUPPORT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;JaasApiIntegrationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/@jaas-api-provision&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;REMEMBER_ME_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;RememberMeAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/remember-me&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;ANONYMOUS_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;AnonymousAuthenticationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http/anonymous&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SESSION_MANAGEMENT_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SessionManagementFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;session-management&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;EXCEPTION_TRANSLATION_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;ExceptionTranslationFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;FILTER_SECURITY_INTERCEPTOR&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;FilterSecurityInterceptor&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;http&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;SWITCH_USER_FILTER&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;SwitchUserFilter&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
&lt;p&gt;N/A&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

























&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;二、Spring security filter作用&lt;/h2&gt;
&lt;h3&gt;2.1 默认filter链&lt;/h3&gt;
&lt;p&gt;在程序启动时会打印出如下日志，该日志打印出了默认的filter链和顺序，其中SecurityContextPersistenceFilter为第一个filter，FilterSecurityInterceptor为最后一个filter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
2018-02-11 15:24:17,204  INFO DefaultSecurityFilterChain - Creating filter chain: 
org.springframework.security.web.util.matcher.AnyRequestMatcher@1, 
[org.springframework.security.web.context.SecurityContextPersistenceFilter@3cf3957d, 
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@7ff34bd, 
org.springframework.security.web.header.HeaderWriterFilter@4dad11a2, 
org.springframework.security.web.authentication.logout.LogoutFilter@5be6ee89, 
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@5426eed3, 
org.springframework.security.web.savedrequest.RequestCacheAwareFilter@5da2a66c, 
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@23169e35, 
org.springframework.security.web.session.SessionManagementFilter@5b1627ea, 
org.springframework.security.web.access.ExceptionTranslationFilter@70b913f5, 
org.springframework.security.web.access.intercept.FilterSecurityInterceptor@2dfe7327]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 默认filter链作用&lt;/h3&gt;
&lt;p&gt;默认有10条过滤链，下面逐个看下去。&lt;/p&gt;
&lt;h4&gt;2.2.1 /index.html at position 1 of 10 in additional filter chain; firing Filter: 'SecurityContextPersistenceFilter'&lt;/h4&gt;
&lt;p&gt;SecurityContextPersistenceFilter 两个主要职责：&lt;/p&gt;
&lt;p&gt;a.请求到来时，通过HttpSessionSecurityContextRepository接口从Session中读取SecurityContext，如果读取结果为null，则创建之。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; requestResponseHolder.getRequest();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; requestResponseHolder.getResponse();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpSession httpSession = request.getSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从session中获取SecurityContext&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         SecurityContext context =&lt;span&gt; readSecurityContextFromSession(httpSession);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;No SecurityContext was available from the HttpSession: &quot;
&lt;span&gt;11&lt;/span&gt;                         + httpSession + &quot;. &quot; + &quot;A new one will be created.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未读取到SecurityContext则新建一个SecurityContext&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             context =&lt;span&gt; generateNewContext();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         SaveToSessionResponseWrapper wrappedResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SaveToSessionResponseWrapper(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 response, request, httpSession != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, context);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        requestResponseHolder.setResponse(wrappedResponse);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isServlet3) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             requestResponseHolder.setRequest(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Servlet3SaveToSessionRequestWrapper(
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    request, wrappedResponse));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获得SecurityContext之后，会将其存入SecurityContextHolder，其中SecurityContextHolder默认是ThreadLocalSecurityContextHolderStrategy实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((strategyName == &lt;span&gt;null&lt;/span&gt;) || &quot;&quot;&lt;span&gt;.equals(strategyName)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set default&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             strategyName =&lt;span&gt; MODE_THREADLOCAL;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (strategyName.equals(MODE_THREADLOCAL)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             strategy = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadLocalSecurityContextHolderStrategy();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下内容省略&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ThreadLocalSecurityContextHolderStrategy中的ContextHolder定义如下，注意这是一个ThreadLocal变量，线程局部变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SecurityContext&amp;gt; contextHolder = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SecurityContext&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.请求结束时清空SecurityContextHolder，并将SecurityContext保存到Session中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             SecurityContext contextAfterChainExecution =&lt;span&gt; SecurityContextHolder
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                    .getContext();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Crucial removal of SecurityContextHolder contents - do this before anything
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; else.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.clearContext();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            repo.saveContext(contextAfterChainExecution, holder.getRequest(),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    holder.getResponse());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            request.removeAttribute(FILTER_APPLIED);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 logger.debug(&quot;SecurityContextHolder now cleared, as request processing completed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.2 /index.html at position 2 of 10 in additional filter chain; firing Filter: 'WebAsyncManagerIntegrationFilter'&lt;/h4&gt;
&lt;p&gt;提供了对securityContext和WebAsyncManager的集成，其会把SecurityContext设置到异步线程中，使其也能获取到用户上下文认证信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilterInternal(HttpServletRequest request,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            HttpServletResponse response, FilterChain filterChain)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         WebAsyncManager asyncManager =&lt;span&gt; WebAsyncUtils.getAsyncManager(request);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         SecurityContextCallableProcessingInterceptor securityProcessingInterceptor =&lt;span&gt; (SecurityContextCallableProcessingInterceptor) asyncManager
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                .getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (securityProcessingInterceptor == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecurityContextCallableProcessingInterceptor());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        filterChain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.3 /index.html at position 3 of 10 in additional filter chain; firing Filter: 'HeaderWriterFilter'&lt;/h4&gt;
&lt;p&gt;用来给http response添加一些Header，比如X-Frame-Options、X-XSS-Protection*、X-Content-Type-Options。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilterInternal(HttpServletRequest request,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            HttpServletResponse response, FilterChain filterChain)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         HeaderWriterResponse headerWriterResponse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeaderWriterResponse(request,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 response, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.headerWriters);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            filterChain.doFilter(request, headerWriterResponse);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向response header中添加header&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            headerWriterResponse.writeHeaders();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.4 /index.html at position 4 of 10 in additional filter chain; firing Filter: 'LogoutFilter'&lt;/h4&gt;
&lt;p&gt;处理退出登录的Filter，如果请求的url为/logout则会执行退出登录操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否需要logout，判断request url是否匹配/logout&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (requiresLogout(request, response)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Authentication auth =&lt;span&gt; SecurityContextHolder.getContext().getAuthentication();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;Logging out user '&quot; +&lt;span&gt; auth
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         + &quot;' and transferring to logout destination&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行一系列的退出登录操作&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (LogoutHandler handler : handlers) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                handler.logout(request, response, auth);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 退出成功，执行logoutSuccessHandler进行重定向等操作&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            logoutSuccessHandler.onLogoutSuccess(request, response, auth);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.5 /index.html at position 5 of 10 in additional filter chain; firing Filter: 'UsernamePasswordAuthenticationFilter'&lt;/h4&gt;
&lt;p&gt;表单认证是最常用的一个认证方式，一个最直观的业务场景便是允许用户在表单中输入用户名和密码进行登录，而这背后的UsernamePasswordAuthenticationFilter，在整个Spring Security的认证体系中则扮演着至关重要的角色。&lt;/p&gt;
&lt;p&gt;UsernamePasswordAuthenticationFilter是继承自AbstractAuthenticationProcessingFilter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否需要执行登录认证，判断request url 是否能匹配/login&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;requiresAuthentication(request, response)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             logger.debug(&quot;Request is to process authentication&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        Authentication authResult;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UsernamePasswordAuthenticationFilter 实现该方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             authResult =&lt;span&gt; attemptAuthentication(request, response);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (authResult == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类未完成认证，立即返回&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            sessionStrategy.onAuthentication(authResult, request, response);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在认证过程中抛出异常&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InternalAuthenticationServiceException failed) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            logger.error(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &quot;An internal error occurred while trying to authenticate the user.&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    failed);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            unsuccessfulAuthentication(request, response, failed);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException failed) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication failed&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            unsuccessfulAuthentication(request, response, failed);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Authentication success&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (continueChainBeforeSuccessfulAuthentication) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        successfulAuthentication(request, response, chain, authResult);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在UsernamePasswordAuthenticationFilter中实现了类attemptAuthentication，不过该类只实现了一个非常简化的版本，如果真的需要通过表单登录，是需要自己继承UsernamePasswordAuthenticationFilter并重载attemptAuthentication方法的。&lt;/p&gt;
&lt;p&gt;在AbstractAuthenticationProcessingFilter的doFilter方法中一开始是判断是否有必要进入到认证filter，这个过程其实是判断request url是否匹配/login，当然也可以通过filterProcessesUrl属性去配置匹配所使用的pattern。&lt;/p&gt;
&lt;h4&gt;2.2.6 /index.html at position 6 of 10 in additional filter chain; firing Filter: 'RequestCacheAwareFilter'&lt;/h4&gt;
&lt;p&gt;将request存到session中，用于缓存request请求，可以用于恢复被登录而打断的请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest request, ServletResponse response,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从session中获取与当前request匹配的缓存request，并将缓存request从session删除&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         HttpServletRequest wrappedSavedRequest =&lt;span&gt; requestCache.getMatchingRequest(
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                (HttpServletRequest) request, (HttpServletResponse) response);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;// 如果requestCache中缓存了request，则使用缓存的request&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         chain.doFilter(wrappedSavedRequest == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; request : wrappedSavedRequest,
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;                response);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处从session中取出request，存储request是在ExceptionTranslationFilter中。具体可以参考&lt;a href=&quot;https://blog.coding.net/blog/Explore-the-cache-request-of-Security-Spring&quot; target=&quot;_blank&quot;&gt;探究 Spring Security 缓存请求&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;2.2.7 /index.html at position 7 of 10 in additional filter chain; firing Filter: 'SecurityContextHolderAwareRequestFilter'&lt;/h4&gt;
&lt;p&gt;此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         chain.doFilter(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestFactory.create((HttpServletRequest) req,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                (HttpServletResponse) res), res);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.8 /index.html at position 8 of 10 in additional filter chain; firing Filter: 'SessionManagementFilter'&lt;/h4&gt;
&lt;p&gt;和session相关的过滤器，内部维护了一个SessionAuthenticationStrategy，两者组合使用，常用来防止&lt;code&gt;session-fixation protection attack&lt;/code&gt;，以及限制同一用户开启多个会话的数量&lt;/p&gt;
&lt;p&gt;与登录认证拦截时作用一样，持久化用户登录信息，可以保存到session中，也可以保存到cookie或者redis中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (request.getAttribute(FILTER_APPLIED) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        request.setAttribute(FILTER_APPLIED, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;securityContextRepository.containsContext(request)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Authentication authentication =&lt;span&gt; SecurityContextHolder.getContext()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    .getAuthentication();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (authentication != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;trustResolver.isAnonymous(authentication)) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The user has been authenticated during the current request, so call the
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; session strategy&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    sessionAuthenticationStrategy.onAuthentication(authentication,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                            request, response);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SessionAuthenticationException e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The session strategy can reject the authentication&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    logger.debug(
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             &quot;SessionAuthenticationStrategy rejected the authentication object&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            e);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    SecurityContextHolder.clearContext();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    failureHandler.onAuthenticationFailure(request, response, e);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Eagerly save the security context to make it available for any possible
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-entrant
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; requests which may occur before the current request completes.
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SEC-1396.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                securityContextRepository.saveContext(SecurityContextHolder.getContext(),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                        request, response);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; No security context or authentication present. Check for a session
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (request.getRequestedSessionId() != &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                         &amp;amp;&amp;amp; !&lt;span&gt;request.isRequestedSessionIdValid()) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         logger.debug(&quot;Requested session ID &quot;
&lt;span&gt;48&lt;/span&gt;                                 + request.getRequestedSessionId() + &quot; is invalid.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (invalidSessionStrategy != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                        invalidSessionStrategy
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                                .onInvalidSessionDetected(request, response);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.9 /index.html at position 9 of 10 in additional filter chain; firing Filter: 'ExceptionTranslationFilter'&lt;/h4&gt;
&lt;p&gt;异常拦截，其处在Filter链后部分，只能拦截其后面的节点并且只处理AuthenticationException与AccessDeniedException两个异常。&lt;/p&gt;
&lt;p&gt;AuthenticationException指的是未登录状态下访问受保护资源，AccessDeniedException指的是登陆了但是由于权限不足（比如普通用户访问管理员界面）。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         HttpServletRequest request =&lt;span&gt; (HttpServletRequest) req;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         HttpServletResponse response =&lt;span&gt; (HttpServletResponse) res;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接执行后面的filter，并捕获异常&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            chain.doFilter(request, response);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             logger.debug(&quot;Chain processed normally&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从异常堆栈中提取SpringSecurityException&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             Throwable[] causeChain =&lt;span&gt; throwableAnalyzer.determineCauseChain(ex);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             RuntimeException ase =&lt;span&gt; (AuthenticationException) throwableAnalyzer
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     .getFirstThrowableOfType(AuthenticationException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, causeChain);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ase == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 ase =&lt;span&gt; (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         AccessDeniedException.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, causeChain);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ase != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理异常&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                handleSpringSecurityException(request, response, chain, ase);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rethrow ServletExceptions and RuntimeExceptions as-is&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ServletException) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (ServletException) ex;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ex &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) ex;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wrap other Exceptions. This shouldn't actually happen
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; as we've already covered all the possibilities for doFilter&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(ex);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个catch代码中通过从异常堆栈中捕获到Throwable[]，然后通过handleSpringSecurityException方法处理异常，在该方法中只会去处理AuthenticationException和AccessDeniedException异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AuthenticationException) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 认证异常，由sendStartAuthentication方法发起认证过程&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             logger.debug(&quot;Authentication exception occurred; redirecting to authentication entry point&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            sendStartAuthentication(request, response, chain, (AuthenticationException) exception);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AccessDeniedException) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问权限异常&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (authenticationTrustResolver.isAnonymous(SecurityContextHolder.getContext().getAuthentication())) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 logger.debug(&quot;Access is denied (user is anonymous); redirecting to authentication entry point&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匿名用户重定向到认证入口点执行认证过程&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 sendStartAuthentication(request, response, chain, &lt;span&gt;new&lt;/span&gt; InsufficientAuthenticationException(&quot;Full authentication is required to access this resource&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拒绝访问，由accessDeniedHandler处理，response 403&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 logger.debug(&quot;Access is denied (user is not anonymous); delegating to AccessDeniedHandler&quot;&lt;span&gt;, exception);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                accessDeniedHandler.handle(request, response, (AccessDeniedException) exception);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SEC-112: Clear the SecurityContextHolder's Authentication, as the existing Authentication is no longer considered valid
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将SecurityContext中的Authentication置为null&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         SecurityContextHolder.getContext().setAuthentication(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在调用认证前先将request保存到session&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        requestCache.saveRequest(request, response);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         logger.debug(&quot;Calling Authentication entry point.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重定向到认证入口点执行认证&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        authenticationEntryPoint.commence(request, response, reason);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.10 /index.html at position 10 of 10 in additional filter chain; firing Filter: 'FilterSecurityInterceptor'&lt;/h4&gt;
&lt;p&gt; 这个filter用于授权验证。FilterSecurityInterceptor的工作流程引用一下，可以理解如下：FilterSecurityInterceptor从SecurityContextHolder中获取Authentication对象，然后比对用户拥有的权限和资源所需的权限。前者可以通过Authentication对象直接获得，而后者则需要引入我们之前一直未提到过的两个类：SecurityMetadataSource，AccessDecisionManager。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;         FilterInvocation fi = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterInvocation(request, response, chain);
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;        invoke(fi);
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     
&lt;span&gt;  6&lt;/span&gt;     
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; invoke(FilterInvocation fi) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((fi.getRequest() != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; observeOncePerRequest) {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; filter already applied to this request and user wants us to observe
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; once-per-request handling, so don't re-do security checking&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; first time this request being called, so perform security checking&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fi.getRequest() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;             InterceptorStatusToken token = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.beforeInvocation(fi);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果后面还有filter则继续执行&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存securityContext&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.finallyInvocation(token);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;.afterInvocation(token, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; InterceptorStatusToken beforeInvocation(Object object) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         Assert.notNull(object, &quot;Object was null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; debug =&lt;span&gt; logger.isDebugEnabled();
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;getSecureObjectClass().isAssignableFrom(object.getClass())) {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &quot;Security invocation attempted for object &quot;
&lt;span&gt; 40&lt;/span&gt;                             +&lt;span&gt; object.getClass().getName()
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                             + &quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot;
&lt;span&gt; 42&lt;/span&gt;                             +&lt;span&gt; getSecureObjectClass());
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取配置的权限属性&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         Collection&amp;lt;ConfigAttribute&amp;gt; attributes = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obtainSecurityMetadataSource().getAttributes(object);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (attributes == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; attributes.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rejectPublicInvocations) {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                         &quot;Secure object invocation &quot;
&lt;span&gt; 52&lt;/span&gt;                                 +&lt;span&gt; object
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                                 + &quot; was denied as public invocations are not allowed via this interceptor. &quot;
&lt;span&gt; 54&lt;/span&gt;                                 + &quot;This indicates a configuration error because the &quot;
&lt;span&gt; 55&lt;/span&gt;                                 + &quot;rejectPublicInvocations property is set to 'true'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 logger.debug(&quot;Public object - authentication not attempted&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PublicInvocationEvent(object));
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no further work post-invocation&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             logger.debug(&quot;Secure object: &quot; + object + &quot;; Attributes: &quot; +&lt;span&gt; attributes);
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (SecurityContextHolder.getContext().getAuthentication() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            credentialsNotFound(messages.getMessage(
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                     &quot;AbstractSecurityInterceptor.authenticationNotFound&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     &quot;An Authentication object was not found in the SecurityContext&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                    object, attributes);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Authentication，如果没有进行认证则认证后返回authentication&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         Authentication authenticated =&lt;span&gt; authenticateIfRequired();
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attempt authorization&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用voter决策是否拥有资源需要的权限&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accessDecisionManager.decide(authenticated, object, attributes);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AccessDeniedException accessDeniedException) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 捕获到异常继续上抛&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthorizationFailureEvent(object, attributes, authenticated, accessDeniedException));
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; accessDeniedException;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             logger.debug(&quot;Authorization successful&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (publishAuthorizationSuccess) {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             publishEvent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthorizedEvent(object, attributes, authenticated));
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attempt to run as a different user&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;         Authentication runAs = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.runAsManager.buildRunAs(authenticated, object,
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                attributes);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (runAs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 logger.debug(&quot;RunAsManager did not change Authentication object&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no further work post-invocation&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterceptorStatusToken(SecurityContextHolder.getContext(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                    attributes, object);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 logger.debug(&quot;Switching to RunAs Authentication: &quot; +&lt;span&gt; runAs);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;             SecurityContext origCtx =&lt;span&gt; SecurityContextHolder.getContext();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            SecurityContextHolder.getContext().setAuthentication(runAs);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; need to revert to token.Authenticated post-invocation&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InterceptorStatusToken(origCtx, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, attributes, object);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;https://blog.coding.net/blog/Explore-the-cache-request-of-Security-Spring&lt;/p&gt;
&lt;p&gt;http://blog.didispace.com/xjf-spring-security-4/&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/benjamin_whx/article/details/39204679&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 10:31:00 +0000</pubDate>
<dc:creator>snowater</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowater/p/8443100.html</dc:identifier>
</item>
<item>
<title>安卓微信页面的调试 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/8445031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/8445031.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;在开发移动端页面时，一般都得保证在微信页面中能够正常访问，虽说微信内置浏览器统一了各个不同安卓机的WebView，但在不同的机子上，还是会出现不一样的兼容问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调试页面，有几个维度要考虑：&lt;/strong&gt;能够访问页面、审查元素查看页面输出、抓包查看请求模拟登陆、断点调试、性能测试、在模拟器上调试、在真机上调试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;一、能够访问页面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在开发安卓微信页面时，刚开始一般是会在PC上进行，等到开发后期的自测阶段再转到安卓模拟器上、转到各种真机上自测，上线了如果出问题还需要在真机上调试测试。&lt;/p&gt;
&lt;p&gt;能够访问页面，当然简单，但难在能够访问页面，并能为接下去的调试页面打好基础。&lt;/p&gt;
&lt;p&gt;很多公司会有内外网之分，开发环境是在内网，外网访问不到，就需要使用代理工具作一个中转。&lt;/p&gt;
&lt;p&gt;某个活动页的开发环境地址是， &lt;span&gt;local.abc.com/wx/page-spring&lt;/span&gt;  ，测试机上估计也会有对应的一个地址&lt;span&gt;  test.abc.com/wx/page-spring&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了访问这个页面，在PC的开发机上会设置HOST： &lt;span&gt;127.0.0.1  local.abc.com     12.70.0.1  test.abc.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样的移动端手机为了能够访问，也需要设置HOST，但大部分机型都需要进行ROOT，不可取&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Fiddler工具，手机设置代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 首先，使手机和PC处在同一个局域网中，查看PC的IP（目前为 11.22.33.44）&lt;/p&gt;
&lt;p&gt;2. 开启Fiddler，在 options 中设置 Allow remote computers to connect ， 如果是HTTPS的页面，还需要设置允许HTTPS的解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110334374-2093061355.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110340265-1398964802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 如果是HTTPS，就先在手机上安装Fiddler的证书，在手机浏览器中访问IP:port 然后按照提示进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212110737046-1544685031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 在手机的Wi-Fi连接上设置代理，设置成 IP:port&lt;/p&gt;
&lt;p&gt;不同手机修改方式不一样，但也类似，一般在更多或者高级修改网络里头&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111308796-591555408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，就可以在手机上直接用域名进行访问页面了。&lt;/p&gt;
&lt;p&gt;但在手机上设置代理还是稍微麻烦了一点，还可以使用Fiddler的开放端口功能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Fiddler工具，开放端口直连&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;省略上面的第四步，改为使用Fiddler开放一个端口（比如8877），在命令行中执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111857609-600921564.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212111849952-1481712176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在FiddlerScript脚本面板中添加替换规则，请求前匹配IP:port来进行host转换，然后保存应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212112131640-117194888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在PC上访问 &lt;span&gt;11.22.33.44:8877/wx/page-spring&lt;/span&gt;  试看是否正常转换，再在手机上访问这个链接即可&lt;/p&gt;

&lt;p&gt;另外，有些页面需要绑定微信oAuth授权，这些页面上线之后（比如为  &lt;span&gt;www.abc.com/wx/page-spring&lt;/span&gt;），如果想在PC上直接访问调试，就会出问题了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212112754937-735078720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Fiddler，请求前设置Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信授权其实是绑定了OpenID，并和我们自己的系统中做了对应，那我们只要拿到这个登陆cookie就能实现模拟登陆了&lt;/p&gt;
&lt;p&gt;在Fiddler中，有很多种为请求设置cookie的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 获取Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用上面的方法，让手机访问的请求能被Fiddler捕获，取某条请求，获取其中的Cookie（比如这个PHPSESSID）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212113442937-1922220762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Fiddler为请求设置Cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以打断点，在PC上访问链接，然后在Raw或相应的Tab修改Cookie，再返回即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212113741671-1102983779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114010531-1094219764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114236499-312685848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 手动打断点是有点麻烦的，也可以直接使用FiddlerScript简单地替换设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114430468-260717381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然也可以使用AutoResponder来直接匹配处理来访问这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212114711921-1518390383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 二、审查元素查看页面输出&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;遇到样式的兼容性问题时，需要通过审查元素来调试。第一个调试基础是查看页面的元素和基本的日志输出。&lt;/p&gt;
&lt;p&gt;这类工具有很多，最常见的要属Chrome的开发者调试工具，在PC上我们可以直接通过设备模拟来使用原生支持的DevTools，在真机上我们可以使用它的远程调试功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Chrome设备模拟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个就很常见了，这里不多说&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212134939406-494583165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Chrome远程调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;远程调试，代名词，其实只是在PC上调试手机中访问的页面，通过USB连接进行调试。&lt;/p&gt;
&lt;p&gt;PC的Chrome DevTools不仅能识别到手机端的Chrome浏览器，其他一些WebView浏览器也支持（比如微信内置X5浏览器 ，小米浏览器，华为浏览器等）&lt;/p&gt;
&lt;p&gt;手机USB连接电脑，在手机开发者人员设置中开启 允许USB调试，在电脑控制面板设备管理上看到设备驱动安装成功（可以直接使用刷机精灵来帮助安装驱动）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144323093-2062244905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在Chrome中访问 &lt;a href=&quot;chrome://inspect/#devices&quot; target=&quot;_blank&quot;&gt;chrome://inspect/#devices &lt;/a&gt;，在手机上访问某个页面，在这里就能识别出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212135941015-865947968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图按顺序为 手机Chrome、小米浏览器、微信X5浏览器 打开的页面&lt;/p&gt;
&lt;p&gt;以微信中的 CSS Triggers页面为例来审查， 点击 inspect将弹出一个类似 DevTools的调试窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212140622265-1641999200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很多时候只能看到一个空白的页面，那是因为在远程调试的时候，Chrome要先请求下载调试工具包（为什么不跟随浏览器安装包来打包呢？可能是觉得打包之后体积太大，而且这个调试工具包是有版本控制的，各个环境不一致），需要FQ才行。&lt;/p&gt;
&lt;p&gt;首次调试某个（手机）浏览器环境需要获取，后续则直接使用离线的缓存。&lt;/p&gt;
&lt;p&gt;科学上网工具自行解决  ，能访问这个域名就行 &lt;a href=&quot;%20https://chrome-devtools-frontend.appspot.com/#&quot; target=&quot;_blank&quot;&gt; https://chrome-devtools-frontend.appspot.com/#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里提供一个host，可能后面会失效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 216.239.38.126 chrome-devtools-&lt;span&gt;frontend.appspot.com
&lt;/span&gt;216.58.203.244 chrome-devtools-frontend.appspot.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就能开始审查了，功能和DevTools基本一致（跟随Chrome版本）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212141419374-1206949654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过要注意的是，UC浏览器是识别不出的，需要使用PC的UC浏览器开发版和移动端的UC浏览器开发版才能调试，方法类似&lt;/p&gt;
&lt;p&gt;其他的WebView也不一定能识别，需要WebView本身开启支持了调试&lt;/p&gt;
&lt;p&gt;小米浏览器默认是支持的，微信X5在去年的时候也是默认支持的，不过最近需要手动开启了，在微信里访问 &lt;a href=&quot;http://debugx5.qq.com/&quot; target=&quot;_blank&quot;&gt;http://debugx5.qq.com/&lt;/a&gt; ， 然后打开 Inspector调试功能，重新访问页面即可&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212142224359-1076910824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 搭建 &lt;a href=&quot;https://github.com/nupthale/weinre&quot; target=&quot;_blank&quot;&gt;Weinre&lt;/a&gt; 调试环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Weinre，原理是往页面插入一段脚本，不支持断点调试功能&lt;/p&gt;
&lt;p&gt;使用NPM安装之后，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i -&lt;span&gt;g weinre

weinre &lt;/span&gt;--boundHost localhost --httpPort 9876
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212143803827-739858357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将这串脚本放到要调试的页面中即可，详细用法可查看 &lt;a href=&quot;https://github.com/nupthale/weinre&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;功能虽然比较简单，但这是最通用的调试方法，基本大部分环境下都能使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144225062-982698246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 4. 使用微信开发者工具进行调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信开发者工具的调试分为两种，一种是基于Weinre的网络连接调试，另一种是基于USB线缆连接的调试。安卓可以使用两种，iOS只能使用前者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用简单的调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要手机与PC同处于一个局域网，在手机中设置代理，然后在微信里打开某个页面进行调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212144913156-194315421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212145032109-526405459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212145138687-570824018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用方法类似普通的Weinre，不过有个缺陷，就是不支持HTTPS，所以访问HTTPS的页面会出现白屏&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用USB调试X5内核&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方法可以调试微信浏览器、QQ浏览器 或其他使用了X5内核的相关页面，可以进行脚本的断点调试&lt;/p&gt;
&lt;p&gt;同样的，需要先保证X5打开了可调试的选项，打开页面后开始调试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212150157343-1378451773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在页面列表中选择inspect审查即可，同样地会调用开发者工具集成的Chrome DevTools，所以初次也需要爬墙找调试工具包&lt;/p&gt;
&lt;p&gt;调试情况与Chrome的远程调试类似，差的是微信开发工具里调试功能的稍微旧了些，好的是它可以识别一些Chrome识别不到的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 5. 使用 &lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot; target=&quot;_blank&quot;&gt;spy-debugger&lt;/a&gt;   进行调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对Weinre来说，除了使用微信开发者工具的集成之外，还有另一个稍好的方案&lt;/p&gt;
&lt;p&gt;spy-debugger本质上也是基于weinre进行开发调试的，除此之外它还支持HTTPS页面，支持简单的网络抓包以及文件映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm i spy-debugger -g

spy-debugger&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装之后启动，同局域网下手机设置好代理（默认端口为 9888）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151450093-1294482966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151413827-1976038007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可见对HTTPS页面做了一定的支持（需要先 &lt;a href=&quot;https://github.com/wuchangming/spy-debugger&quot; target=&quot;_blank&quot;&gt;按步骤&lt;/a&gt; 设置好证书）&lt;/p&gt;
&lt;p&gt;另外也提供了基础的抓包功能（默认使用AnyProxy，还可以自行设置），也是蛮实用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212151755796-516923645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 使用 &lt;a href=&quot;https://github.com/Tencent/vConsole&quot; target=&quot;_blank&quot;&gt;VConsole&lt;/a&gt; 进行调试 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面所说都只是为了能够审查页面的元素，以便做一些基础的调试。&lt;/p&gt;
&lt;p&gt;不过，似乎都是在PC上操作的，那有没有能直接在手机上用的工具呢？&lt;/p&gt;
&lt;p&gt;近段时间发现这个小工具，如果电脑不在身边，对移动端的调试还是蛮有帮助的&lt;/p&gt;
&lt;p&gt;在新版QQ浏览器中，已经集成了这个选项，使用手机QQ浏览器访问 &lt;a href=&quot;http://debugx5.qq.com&quot; target=&quot;_blank&quot;&gt;http://debugx5.qq.com&lt;/a&gt; ，设置为开启即可在右下方看到功能入口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153534249-1333861391.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153620202-1818743433.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212153623390-2045823486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击后可以看到几个面板，能够满足基本的页面审查、请求查看、命令执行，需要的话也可以自己添加插件&lt;/p&gt;
&lt;p&gt;而在微信内置浏览器中访问页面时，则需要手动引入 VConsole.js 这个文件，然后调用一下即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vConsole = &lt;span&gt;new&lt;/span&gt; VConsole();
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、抓包查看请求模拟登陆&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 很多时候我们希望获取某个页面所发起的请求和响应，对数据进行分析。抓包工具有很多，在Windows上有Fiddler，在Mac上有Charles，在手机上也有其他工具&lt;/p&gt;
&lt;p&gt; Fiddler的功能用法是很强大的，但大部分人只知道基本的功能，还有很多东西未曾了解。比如其中的自定义脚本FiddlerScript部分，可以实现很多扩展&lt;/p&gt;
&lt;p&gt;本文不展开来讲，推荐好好看一下&lt;a href=&quot;https://book.douban.com/subject/25835263/&quot; target=&quot;_blank&quot;&gt;《Fiddler调试指南》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大部分其他工具可以查看请求或返回，但无法进行自定义修改。这是Fiddler和Charles的独到之处&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212155153593-885536868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，使用Fiddler就得使用电脑，如果只是想直接在手机上看看请求的话，还有两个工具可以推荐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 使用 &lt;a href=&quot;http://kaywu.xyz/2016/02/28/PacketCapture/&quot; target=&quot;_blank&quot;&gt;Packet Capture&lt;/a&gt; 进行抓包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安卓机子中，安装之后，在它的设置项里配置一下证书&lt;/p&gt;
&lt;p&gt;点击绿色按钮开启监听，它会监听到所有APP的各种协议，也可以选择监听某一个APP&lt;/p&gt;
&lt;p&gt;比如，这里监听了我在微信里访问博客园，查看捕获的列表可以看到相关的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160340374-984384560.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160403249-801881534.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212160447843-1777019288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;2. 使用 &lt;a href=&quot;https://github.com/JZ-Darkal/AndroidHttpCapture&quot; target=&quot;_blank&quot;&gt;HttpInterceptor&lt;/a&gt; 抓包工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对前者来说，这个东西功能算是多了点&lt;/p&gt;
&lt;p&gt;它内置了一个WebView浏览器，可以直接在里头访问连接分析页面，也可以设置代理，设置host（免ROOT），修改返回数据等&lt;/p&gt;
&lt;p&gt;如果PC上的开发环境设置了host ，PC的IP是 11.22.33.44，那么就可以在这里的host 设置为PC的IP，即可通过域名进行访问&lt;/p&gt;
&lt;p&gt;如果想监听其他APP（比如微信里的页面），则设置代理为 127.0.0.1:8888 即可（有点Fiddler的影子了），注意不用的时候（或者此进程被杀死）把代理关掉，否则访问不了网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162002343-1015602494.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162255124-1968051462.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162342812-1352358412.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162422296-1073593133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 点击预览可以看到捕获的请求列表，然后点击进去可以看到请求和返回的数据详情&lt;/p&gt;
&lt;p&gt; 如果想修改返回数据，可以在这里进行设置。比如结合上述的 VConsole 来使用，可以在不借助电脑的情况下就能做一些基本的调试功能&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/688270/201802/688270-20180212162538202-433865339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、断点调试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 断点调试，包括JS的调试，以及DOM节点元素的树结构、属性改变的调试，它在调试过程中是很重要的，一般来说都需要使用到开发者工具。&lt;/p&gt;
&lt;p&gt;在这个维度上看，调试方法要属Chrome的设备模拟和远程调试&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、性能测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 某些时候还需要对页面进行性能的测试，从加载时的时间线性能，到运行时的流畅度性能，再到页面占用的内容性能等角度来分析&lt;/p&gt;
&lt;p&gt;要比较准确地显示地考量这些指标，一般都需要在真机上进行调试，也少不了开发者工具&lt;/p&gt;
&lt;p&gt;一般设计到这一环时，Chrome远程调试就是必须的了。&lt;/p&gt;
&lt;p&gt;本文先不展开，后续会有关于Chrome DevTools 的调试整理，敬请期待~&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、在真机上调试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 关于移动端页面的测试，有三个层次：&lt;/p&gt;
&lt;p&gt;1. 在PC上用浏览器设备模拟测试&lt;/p&gt;
&lt;p&gt;2. 在PC上用模拟器模拟测试&lt;/p&gt;
&lt;p&gt;3. 使用真机模拟测试&lt;/p&gt;
&lt;p&gt;浏览器的设备模拟多是从样式上来模拟，安卓模拟器有了一些硬件上的倾向性，在真机上最为可靠&lt;/p&gt;
&lt;p&gt;然而现在大多数的手机浏览器都自带了工具栏，而华为手机上自带了虚拟键盘，导致一个页面的高度不统一。也许在设备模拟页面上正常了，在真机却被挤压元素被覆盖了。&lt;/p&gt;
&lt;p&gt;所以说，有机会的话都要搜集常见的机型来进行真机测试，或者至少要进行模拟器的测试。&lt;/p&gt;


&lt;p&gt;以调试安卓微信页面为基础，本文列举了几个常见的调试工具和相应的使用方法&lt;/p&gt;
&lt;p&gt;并不是每个方法都保证可行，所以在调试过程中会有很多的备选方案&lt;/p&gt;
&lt;p&gt;要说最重要的，应该就是Fiddler和DevTools的结合了，DevTools解决不了的再找Weinre&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 09:03:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/8445031.html</dc:identifier>
</item>
<item>
<title>菜鸟之旅——学习线程（1） - 愉悦的绅士</title>
<link>http://www.cnblogs.com/nbclw/p/8397657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbclw/p/8397657.html</guid>
<description>&lt;p&gt;　　上一篇主要介绍了进程和线程的一些基本知识，现在回归正题，我们来学一下线程的使用，本篇主要是使用新建线程和线程池的方式。&lt;/p&gt;

&lt;p&gt;　　先来介绍简单的线程使用：使用new方法来创建线程，至于撤销线程，我们不必去管（我也不知道怎么去管XD），因为CLR已经替我们去管理了。　&lt;/p&gt;
&lt;h2&gt;　创建&lt;/h2&gt;
&lt;p&gt;　　先来看一个简单的使用线程的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod1);
            Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod2);
            t1.Start();
            t2.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod2(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以用过new的方式创建一个线程，然后使用Start()的方法来运行该线程，线程则会在其生命周期去执行Method1方法，执行方法肯定需要时间的，但是Method1的方法过于简单，我们使用Thread.Sleep的方法来进行停顿，这个方法可以暂时将当前的线程睡眠一段时间（毫秒为单位），因为主线程只是创建并运行t1子线程，运行任务的不是主线程，所以主线程可以继续往后执行程序。&lt;/p&gt;
&lt;p&gt;　　我们还可以向线程执行的方法传入一个参数，例如线程2，在t2执行Start方法时，传入想要传入的参数，然后就可以在运行的时候使用了；不过参数是有限制的，在子线程的方法只能接受object的类型的参数，则在使用的时候需要显式转换类型，还有就是只能接受一个参数，多个参数也不会支持。&lt;/p&gt;
&lt;h2&gt;　线程与Lambda表达式&lt;/h2&gt;
&lt;p&gt;　　线程的new也支持Lambda表达式，若是执行方法比较简单，或者在某些场景下，我们可以将线程执行的代码使用Lambda内置到新建里面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt;&lt;span&gt;
            {
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            t1.Start();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里这样子写还有一个好处，就是这里可以直接使用主方法里面的变量，当然，这也会产生线程安全的问题。&lt;/p&gt;
&lt;h2&gt;　线程同步&lt;/h2&gt;
&lt;p&gt;　　一个进程中的多个线程都是可以访问其进程的其他资源，多线程若不加以控制也是并发执行的，若在多线程的执行方法中包含操作全局变量、者静态变量或是使用I/O设备的时候，很容易的就会产生线程安全的问题，从而导致不可预估的错误。这里就需要进行线程同步了，下面介绍一些线程同步的方式。&lt;/p&gt;
&lt;h3&gt;　　Join：&lt;/h3&gt;
&lt;p&gt;　　我们有时候开启了n各子线程来进行辅助计算，但是又想主线程等待所有子线程计算完毕在接着执行，或者线程之间的关系更复杂，其中涉及了线程的阻塞与激活，那么就可以使用Join()的方法来阻塞主线程，实现一种最简单的线程同步：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod1);
            Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod2);
            t1.Start();
            t1.Join();

            t2.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            t2.Join();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod2(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的调用阻塞的过程：先是t1开始，阻塞2秒，再接着t2执行，阻塞4秒，共计阻塞6秒，貌似没有发挥出来多线程的优势，但是也有可能在t2运行之前必须运行完t1，所以，Join()的调用需要视情况而定，Join()就是阻塞当前线程到当前位置，直到阻塞线程结束后，当前线程继续运行。&lt;/p&gt;
&lt;h3&gt;　　同步事件：&lt;/h3&gt;
&lt;p&gt;　　除了Join()来实现线程间的阻塞与激活，还有同步事件来进行处理；&lt;span&gt;同步事件有两种：AutoResetEvent和 ManualResetEvent。它们之间唯一不同的地方就是在激活线程之后，状态是否自动由终止变为非终止。AutoResetEvent自动变为非终止，就是说一个AutoResetEvent只能激活一个线程。而ManualResetEvent要等到它的Reset方法被调用，状态才变为非终止，在这之前，ManualResetEvent可以激活任意多个线程：先来看&lt;span&gt;ManualResetEvent&lt;/span&gt;的使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; ManualResetEvent muilReset = &lt;span&gt;new&lt;/span&gt; ManualResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod1);
            t1.Start();
            Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod2);
            t2.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Thread t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod3);
            t3.Start();
            muilReset.WaitOne();

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod1()
        {
            muilReset.WaitOne();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod2(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            muilReset.WaitOne();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod3()
        {
            Thread.Sleep(3&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程3的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;激活线程...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            muilReset.Set();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　上面例子我们将主线程、线程1、线程2阻塞，使用线程3在3秒钟之后激活全部线程，显示成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　线程3的ID：&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
　　激活线程...
　　&lt;/span&gt;--------------------&lt;span&gt;
　　线程2的ID：&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
　　obj：&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;
　　--------------------&lt;span&gt;
　　主线程的ID：&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
　　--------------------&lt;span&gt;
　　线程1的ID：&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
　　--------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若是使用AutoResetEvent则只能激活主线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　线程3的ID：&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
　　激活线程...
　　&lt;/span&gt;--------------------&lt;span&gt;
　　主线程的ID：&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
　　--------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注：&lt;strong&gt;ManualResetEvent会给所有引用的线程都发送一个信号（多个线程可以共用一个ManualResetEvent，当ManualResetEvent调用Set()时，所有线程将被唤醒），而AutoResetEvent只会随机给其中一个发送信号（只能唤醒一个）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里的线程同步还可以使用委托与事件（推荐使用事件）来实现线程间的简单通讯，比如在某一线程执行到某一结点后，通过事件向另一个或者多个线程发送更多的信息。&lt;/p&gt;
&lt;h3&gt;　　Monitor：&lt;/h3&gt;
&lt;p&gt;　　上述的例子是各个子线程之间没有使用公共资源（公共变量、I/O设备等），它们只存在执行顺序上的先后；我们来找一个使用公共变量的例子试一试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; ids = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
            {
                Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod);
                t.Start();
            }

            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod()
        {&lt;/span&gt;
&lt;span&gt;            ids.Add(Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(ids.Count);
            Console.WriteLine(ids[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ids.Clear();&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这里新建100个子线程，然后使用一个静态公共变量List输出线程的Id，以上述方法运行时，有时会报出错误：索引超出范围。必须为非负值并小于集合大小！说明当前子线程输出Id时，该集合被Clear掉了，这就是一个很简单的线程安全问题，所以需要使用Monitor来进行锁住代码块，MSDN推荐定义一个私有的初始化不会再变的object变量作为一个排他锁，因为排他锁变了就没意义了，下面代码就可以变为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; locker = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; ids = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
            {
                Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Menthod);
                t.Start();
            }

            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod()
        {
            Monitor.Enter(locker);
            ids.Add(Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(ids.Count);
            Console.WriteLine(ids[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            ids.Clear();
            Monitor.Exit(locker);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当有一个线程进入锁住的代码块是，是在外面加锁，这样剩下的线程只能等待当前线程执行完毕后释放锁，这样的话就保证了List变量在取值时不会被其他线程清除掉；尽管List是一个线程安全类，就是多线程操作该类时只有一个线程操作的类，但是这里仍然避免不了线程安全的问题，因为仍然控制不了操作的顺序，在清除后读取肯定会报错。&lt;/p&gt;
&lt;h3&gt;　　lock：&lt;/h3&gt;
&lt;p&gt;　　调用Monitor执行只能有一个线程运行的代码块时，仍有可能会抛出异常，但是有时候又不能终止进程，使用try{}catch{}包起来是个解决方式，那干脆再封装一次Monitor的方法，于是lock便出现了，则上述的例子可以改写为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod()
        {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (locker)
            {
                ids.Add(Thread.CurrentThread.ManagedThreadId);
                Console.WriteLine(ids.Count);
                Console.WriteLine(ids[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                ids.Clear();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Menthod()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Monitor.Enter(locker);
                ids.Add(Thread.CurrentThread.ManagedThreadId);
                Console.WriteLine(ids.Count);
                Console.WriteLine(ids[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                ids.Clear();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {

            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                Monitor.Exit(locker);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当线程进入lock代码块时，将会调用Monitor.Enter()方法，退出代码块会调用Monitor.Exit()方法。&lt;span&gt;另外，Monitor还提供了三个静态方法Monitor.Pulse()，Monitor.PulseAll()和Monitor.Wait() ，用来实现一种唤醒机制的同步。关于这三个方法的用法，可以参考MSDN，我这里也在学习中，就先不讲述了。虽说lock没有Monitor功能强大，但是使用确实方便，这里取舍就看实际需求了。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 　　补充&lt;/h3&gt;
&lt;p&gt;　　线程同步的方式还有很多，比如Mutex。还有很多的方法，以后用到的时候在研究吧。&lt;br/&gt;　　&lt;strong&gt;Mutex&lt;/strong&gt;：Mutex不具备Wait，Pulse，PulseAll的功能，因此，我们不能使用Mutex实现类似的唤醒的功能；不过Mutex有一个比较大的特点，Mutex是跨进程的，因此我们可以在同一台机器甚至远程的机器上的多个进程上使用同一个互斥体。&lt;/p&gt;


&lt;h2&gt;　目的&lt;/h2&gt;
&lt;p&gt;　　上一篇内容提到，线程是由线程ID、程序计数器、寄存器集合和堆栈组成，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一些在运行中必不可少的资源；这就意味着线程在进行创建与撤销的时候，都需要分配与清空一些资源，总归需要付出一定量的时空消耗；在一些大量使用线程（CPU密集、I/O密集）的进程里面，使用传统的new方法会频繁的创建、撤销线程，虽说线程的管理是由CLR来进行的，但是总归是影响性能，为了减少创建与撤销的时空消耗，便引入了线程池的概念：将线程实体池化，就是事先创建一定量的线程实体，然后放到一个容器中，做统一管理，没有任务时，线程处于空闲状态（差不多就是就绪状态），来任务后选择一个空闲线程来执行，执行完毕后自动关闭线程（没有被撤销，只是置为空闲状态）。&lt;/p&gt;
&lt;h2&gt;　CLR线程池&lt;/h2&gt;
&lt;p&gt;　　CLR线程池是.NET框架中很重要的一部分，不光能被开发人员使用，自身的很多功能也是由线程池实现；我们在将任务委托给线程池的时候，是将该任务放到线程池的任务队列上，若线程池内存在空闲线程，则会将该任务委托给该线程，等待调度到CPU执行，若是没有空闲的线程且线程池所管理的线程数量还没有达到上限的时候，线程池便会创建新的Thread实体，否则，该任务会在队列中等待。&lt;/p&gt;
&lt;p&gt;　　数量上限：在CLR 2.0 SP1之前的版本中，线程池中 默认最大的线程数量 = 处理器数 * 25, CLR 2.0 SP1之后就变成了 默认最大线程数量 = 处理器数 * 250，线程上限可以改变，通过使用ThreadPool.GetMax+Threads和ThreadPool.SetMaxThreads方法，可以获取和设置线程池的最大线程数。&lt;/p&gt;
&lt;h2&gt;　使用&lt;/h2&gt;
&lt;p&gt;　　线程池的使用更简单一些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            ThreadPool.QueueUserWorkItem(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitCallback(Menthod1));
            ThreadPool.QueueUserWorkItem(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; WaitCallback(Menthod2), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod1(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod2(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里QueueUserWorkItem方法需要传入一个QueueUserWorkItem委托（带object类型的参数，无返回值），所以我们需要线程执行的任务需要带一个object的参数，并且QueueUserWorkItem方法加入时存在一个重载，可以在这里传入一个参数。&lt;/p&gt;
&lt;p&gt;　　当然这里也可以使用Lambda表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        ThreadPool.QueueUserWorkItem(&lt;span&gt;new&lt;/span&gt; WaitCallback((&lt;span&gt;object&lt;/span&gt; obj)=&amp;gt;&lt;span&gt;{
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程3的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;obj：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, obj);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 　线程同步&lt;/h2&gt;
&lt;p&gt;　　使用线程池并发执行任务同样会遇到线程安全的问题，一样需要进行同步，在涉及线程使用公共资源，Monitor、lock等方法与上述线程使用一样，同样能达到理想的效果，就不重复介绍了；但是对于控制执行顺序上，这个没有使用new线程来的自由。&lt;/p&gt;
&lt;h3&gt;　　同步事件：&lt;/h3&gt;
&lt;p&gt;　　在线程池中，没有Join方法，若想控制线程的执行顺序，我推荐使用主线程等待线程池任务执行完毕，阻塞主线程的方式，这里可以使用WaitHandle：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            List&lt;/span&gt;&amp;lt;WaitHandle&amp;gt; handles = &lt;span&gt;new&lt;/span&gt; List&amp;lt;WaitHandle&amp;gt;&lt;span&gt;();

            AutoResetEvent autoReset1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            ThreadPool.QueueUserWorkItem(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitCallback(Menthod1), autoReset1);
            handles.Add(autoReset1);

            AutoResetEvent autoReset2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            ThreadPool.QueueUserWorkItem(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitCallback(Menthod2), autoReset2);
            handles.Add(autoReset2);

            WaitHandle.WaitAll(handles.ToArray());

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod1(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程1的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            AutoResetEvent handle &lt;/span&gt;=&lt;span&gt; (AutoResetEvent)obj;
            handle.Set();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Menthod2(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;4000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程2的ID：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            AutoResetEvent handle &lt;/span&gt;=&lt;span&gt; (AutoResetEvent)obj;
            handle.Set();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这里，给线程池每个相关的线程都创建一个AutoResetEvent，在执行完毕之后分别把属于自己的AutoResetEvent变为非终止，WaitHandle使用WaitAll方法阻塞主线程、等待所有的AutoResetEvent事件变为true，另外WaitHandle还有一个WaitAny方法阻塞，不过是只要其中一个线程结束，就会继续运行，不再阻塞。&lt;/p&gt;
&lt;p&gt;　　注：&lt;/p&gt;
&lt;p&gt;　　1、WaitHandle同样可以用于new创建线程的同步事件；&lt;/p&gt;
&lt;p&gt;　　2、WaitHandle等待方法（WaitAll、WaitAny）的数组长度的数目必须少于或等于 64 个，为了解决此限制，有网友封装了一个类，比较好用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2ad622e7-3c83-4c05-bcd2-a2f75ee60432&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2ad622e7-3c83-4c05-bcd2-a2f75ee60432&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2ad622e7-3c83-4c05-bcd2-a2f75ee60432&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MutipleThreadResetEvent : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ManualResetEvent done;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; total;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; current;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;total&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要等待执行的线程总数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; MutipleThreadResetEvent(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; total)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; total;
            current &lt;/span&gt;=&lt;span&gt; total;
            done &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ManualResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 唤醒一个等待的线程
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetOne()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Interlocked 原子操作类 ,此处将计数器减1&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Interlocked.Decrement(&lt;span&gt;ref&lt;/span&gt; current) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当所以等待线程执行完毕时，唤醒等待的线程&lt;/span&gt;
&lt;span&gt;                done.Set();
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 等待所有线程执行完毕
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; WaitAll()
        {
            done.WaitOne();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 释放对象占用的空间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            ((IDisposable)done).Dispose();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MutipleThreadResetEvent&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;　　1、线程有前台线程和后台线程之分，使用new创建的线程默认为前台线程（可以使用IsBackground属性来进行更改），线程池里面都是后台线程&lt;/p&gt;
&lt;p&gt;　　　前台线程：前台线程是不会被立即关闭的，它的关闭只会发生在自己执行完成时，不受外在因素的影响。假如应用程序退出，造成它的前台线程终止，此时CLR仍然保持活动并运行，使应用程序能继续运行，当它的的前台线程都终止后，整个进程才会被销毁。&lt;/p&gt;
&lt;p&gt;　　　后台线程：后台线程是可以随时被CLR关闭而不引发异常的，也就是说当后台线程被关闭时，资源的回收是立即的，不等待的，也不考虑后台线程是否执行完成，就算是正在执行中也立即被终止。&lt;/p&gt;
&lt;p&gt;　　2、线程被系统调度到CPU执行时存在优先级：这里的优先级不是优先执行，而是被调度到CPU执行的概率高；使用new创建线程与线程池的优先级默认都是Normal，不过前者可以通过Priority属性来设置优先级。优先级有5个级别：Highest、AboveNormal、Normal、BelowNormal和Lowest。&lt;/p&gt;
&lt;p&gt;　　3、线程存在Suspend与Resume这两个过时的方法，但不是代表不能使用，只是微软不推荐你用，MSDN给出的原因是：&lt;em&gt;请不要使用 Suspend 和 Resume 方法来同步线程活动。 没有办法知道当你暂停执行线程什么代码。 如果在安全权限评估期间持有锁，您挂起线程中的其他线程 AppDomain 可能被阻止。 如果执行类构造函数时，您挂起线程中的其他线程 AppDomain 中尝试使用类被阻止。 可以很容易发生死锁&lt;/em&gt;。你可以无视这个警告继续使用这两个方法进行线程同步，若觉得不怎么靠谱，那么可以在线程代码加入判断来保证执行正确性，或者使用控制同步事件（AutoResetEvent等）来实现线程同步。&lt;/p&gt;
&lt;p&gt;　　4、线程池的线程很珍贵，因为数量是有限的，所以不适合执行长时间的作业任务，适合执行短期并且频繁的作业任务，若想执行长时间的作业任务，建议使用new创建新线程的方式。毕竟线程池设计的初衷就是为了解决频繁创建与撤销线程而造成的资源浪费。&lt;/p&gt;

</description>
<pubDate>Mon, 12 Feb 2018 09:01:00 +0000</pubDate>
<dc:creator>愉悦的绅士</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nbclw/p/8397657.html</dc:identifier>
</item>
<item>
<title>iOS学习——布局利器Masonry框架源码深度剖析 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/8431899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/8431899.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　iOS开发过程中很大一部分内容就是界面布局和跳转，iOS的布局方式也经历了 &lt;span&gt;&lt;strong&gt;显式坐标定位方式 --&amp;gt; autoresizingMask --&amp;gt; iOS 6.0推出的自动布局（Auto Layout）&lt;/strong&gt;&lt;/span&gt;的逐步优化，至于为什么推出自动布局，肯定是因为之前的方法不好用（哈哈 简直是废话），具体如何不好用以及怎么变化大家可以瞅瞅 &lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/pucker/article/details/41832939&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这篇文章&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;iOS6.0推出的自动布局实际上用&lt;span&gt;&lt;strong&gt;布局约束（Layout Constraint）&lt;/strong&gt;&lt;/span&gt;来实现，通过布局约束（Layout Constraint）可以确定两个视图之间精确的位置的相对距离，为此，iOS6.0推出了&lt;/span&gt;&lt;span&gt;&lt;span&gt;NSLayoutConstraint&lt;/span&gt;来定义约束，使用方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[NSLayoutConstraint constraintWithItem:view1
　　attribute:NSLayoutAttributeLeft
　　relatedBy:NSLayoutRelationEqual
　　toItem:view2
　　attribute:NSLayoutAttributeRight
　　multiplier:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
　　constant:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;翻译过来就是:view1的左侧，在，view2的右侧，再多10个点，的地方。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;4约束的限制&quot;&gt;&lt;span&gt;布局约束的添加规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;（1）对于两个同层级 view 之间的约束关系，添加到它们的父 view 上&lt;br/&gt;（2）对于两个不同层级 view 之间的约束关系，添加到他们最近的共同父 view 上&lt;br/&gt;（3）对于有层次关系的两个 view 之间的约束关系，添加到层次较高的父 view 上&lt;br/&gt;（4）对于比如长宽之类的，只作用在该 view 自己身上的话，添加到该 view 自己上&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体关于NSLayoutConstraint的详细使用方法参见：&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/5da3d2fe5dee&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;NSLayoutConstraint-代码实现自动布局&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;。今天我们文章的主角——Masonry框架实际上是在NSLayoutConstraint的基础上进行封装的，这一点在后面的源码分析中我们详细解释。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当我&lt;span&gt;们需要对控件的top,bottom,left,right进行约束就特别麻烦，在OC中有一个库&lt;code&gt;Masonry&lt;/code&gt;对&lt;code&gt;NSLayoutConstraint&lt;/code&gt;进行了封装，简化了约添加约束的方式和流程&lt;/span&gt;。用Masonry框架进行布局非常简单，主要特点是采用链式语法进行布局，这一点使得我们在使用和代码布局上更为方便，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;利用Masonry进行布局的前提条件之一是 布局视图必须先被添加到父视图中&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;简单示例如下代码，关于Masonry框架的使用并不是本文的重点，详情可以参见：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20141219/10702.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Masonry介绍与使用实践：快速上手Autolayout&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。如果你的项目是Swift语言的，那么就得使用&lt;span&gt;&lt;strong&gt;SnapKit布局框架&lt;/strong&gt;&lt;/span&gt;了，SnapKit其实就是Masonry的Swift版本，两者虽然实现语言不同，但是实现思路大体一致。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
UIView *sv1 = [UIView &lt;span&gt;new&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用Masonry进行布局的前提条件之一是 布局视图必须先被添加到父视图中&lt;/span&gt;
&lt;span&gt;[sv addSubview:sv1];
[sv1 mas_makeConstraints:&lt;/span&gt;^(MASConstraintMaker *&lt;span&gt;make) {
    make.edges.equalTo(sv).with.insets(UIEdgeInsetsMake(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;));
     
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等价于
    make.top.equalTo(sv).with.offset(10);
    make.left.equalTo(sv).with.offset(10);
    make.bottom.equalTo(sv).with.offset(-10);
    make.right.equalTo(sv).with.offset(-10);
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 也等价于
    make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(10, 10, 10, 10));
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　Masonry框架是在NSLayoutConstraint的基础上进行封装的，其涉及到的内容也是非常繁多。在进行源码剖析时我们从我们经常用到的部分出发，一层一层进行解析和研究。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.1 调用流程分析&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们先大体了解一下调用 &lt;span class=&quot;cnblogs_code&quot;&gt;mas_makeConstraints&lt;/span&gt; 进行布局时的流程步骤，其实另外两个 &lt;span class=&quot;cnblogs_code&quot;&gt;mas_updateConstraints&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;mas_remakeConstraints&lt;/span&gt; 的流程也基本上是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;- (NSArray *)mas_makeConstraints:(&lt;span&gt;void&lt;/span&gt;(^)(MASConstraintMaker *))block&lt;/span&gt; 是Masonry框架中&lt;/span&gt;&lt;span&gt;UIview + MASAdditions&lt;/span&gt;（&lt;span&gt;UIview分类）中的方法，所以一般的控件视图都可以直接调用该方法，该方法传入一个block函数作为参数（返回值为void,参数为&lt;code&gt;MASContraintMaker&lt;/code&gt;的实例对象make）&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要布局方法 &lt;span class=&quot;cnblogs_code&quot;&gt;- (NSArray *)mas_makeConstraints:(&lt;span&gt;void&lt;/span&gt;(^)(MASConstraintMaker *))block&lt;/span&gt; 的源码和解析如下，主要工作是创建一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;约束创建器，并将其传到block中（其实就是block中的make创建器）进行创建约束并返回&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; MAS_VIEW (MASAdditions)

&lt;/span&gt;- (NSArray *)mas_makeConstraints:(&lt;span&gt;void&lt;/span&gt;(^)(MASConstraintMaker *&lt;span&gt;))block {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭AutoresizingMask的布局方法是我们进行Auto Layout布局的前提步骤&lt;/span&gt;
    self.translatesAutoresizingMaskIntoConstraints =&lt;span&gt; NO;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个约束创建器&lt;/span&gt;
    MASConstraintMaker *constraintMaker =&lt;span&gt; [[MASConstraintMaker alloc] initWithView:self];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在block中配置constraintMaker对象，即将constraintMaker传入block中（其实就是我们在block中用来添加约束的make）进行约束配置&lt;/span&gt;
&lt;span&gt;    block(constraintMaker);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;约束安装并以数组形式返回&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [constraintMaker install];
}

...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;约束安装方法 &lt;span class=&quot;cnblogs_code&quot;&gt;[constraintMaker install];&lt;/span&gt; 的源代码如下，这部分的代码很简单，主要就是对当前约束创建器中的约束进行更新，因为除了我们这个 &lt;span class=&quot;cnblogs_code&quot;&gt;mas_makeConstraints&lt;/span&gt; 方法中会调用该方法之外， &lt;span class=&quot;cnblogs_code&quot;&gt;mas_updateConstraints&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;mas_remakeConstraints&lt;/span&gt; 中都会调用该方法进行约束的安装，所以在该约束安装方法中考虑了约束的删除和是否有更新等情况的处理。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;install方法主要就是对下面这个约束数组进行维护&lt;/span&gt;
@property (nonatomic, strong) NSMutableArray *&lt;span&gt;constraints;

&lt;/span&gt;- (NSArray *&lt;span&gt;)install {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否有要删除的约束，有则逐个删除&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (self.removeExisting) {
        NSArray &lt;/span&gt;*installedConstraints =&lt;span&gt; [MASViewConstraint installedConstraintsForView:self.view];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (MASConstraint *constraint &lt;span&gt;in&lt;/span&gt;&lt;span&gt; installedConstraints) {
            [constraint uninstall];
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新约束&lt;/span&gt;
    NSArray *constraints =&lt;span&gt; self.constraints.copy;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (MASConstraint *constraint &lt;span&gt;in&lt;/span&gt;&lt;span&gt; constraints) {
        constraint.updateExisting &lt;/span&gt;=&lt;span&gt; self.updateExisting;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;约束安装（&lt;strong&gt;&lt;span&gt;这个才是真正的添加约束的方法&lt;/span&gt;&lt;/strong&gt;）&lt;/span&gt;
&lt;span&gt;        [constraint install];
    }
    [self.constraints removeAllObjects];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; constraints;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面这段代码中真正添加约束的方法其实是 &lt;span class=&quot;cnblogs_code&quot;&gt;[constraint install];&lt;/span&gt; ，这里我们要分析一下这个install到底调用的是哪个方法的install？因为这里有好几个类（MASConstraint、MASViewConstraint、MASCompositeConstraint）有install方法。&lt;span&gt;要知道具体调用的是哪一个类的install方法，我们就要弄清楚这里的约束constraint到底是什么类型&lt;/span&gt;，这就需要我们了解约束创建器（MASConstraintMaker）中的约束数组constraints中添加的到底是什么类型的约束，经过分析（分析过程在后面会讲到）我们发现这里添加的约束是MASViewConstraint类型的，根据面向对象的多态特性，所以我们这里调用的其实就是MASViewConstraint的install方法，该方法关键代码（代码太长，只放关键性代码）如下，&lt;strong&gt;&lt;span&gt;我们可以看到其实就是通过iOS系统自带的自动布局约束布局类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;NSLayoutConstraint进行布局&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)install {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (self.hasBeenInstalled) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    ...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASLayoutConstraint其实就是在NSLayoutConstraint基础上添加了一个属性而已
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@interface MASLayoutConstraint : NSLayoutConstraint&lt;/span&gt;
&lt;span&gt;    
    MASLayoutConstraint &lt;/span&gt;*&lt;span&gt;layoutConstraint
        &lt;/span&gt;=&lt;span&gt; [MASLayoutConstraint constraintWithItem:firstLayoutItem
                                        attribute:firstLayoutAttribute
                                        relatedBy:self.layoutRelation
                                           toItem:secondLayoutItem
                                        attribute:secondLayoutAttribute
                                       multiplier:self.layoutMultiplier
                                         constant:self.layoutConstant];
    layoutConstraint.priority &lt;/span&gt;=&lt;span&gt; self.layoutPriority;
    layoutConstraint.mas_key &lt;/span&gt;=&lt;span&gt; self.mas_key;
    
    ...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加约束&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (existingConstraint) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; just update the constant&lt;/span&gt;
        existingConstraint.constant =&lt;span&gt; layoutConstraint.constant;
        self.layoutConstraint &lt;/span&gt;=&lt;span&gt; existingConstraint;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        [self.installedView addConstraint:layoutConstraint];
        self.layoutConstraint &lt;/span&gt;=&lt;span&gt; layoutConstraint;
        [firstLayoutItem.mas_installedConstraints addObject:self];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　&lt;span&gt;通过上面的分析和研究，我们基本上已经把Masonry框架中主要布局方法的主流程了解清楚了。因为这是第一次学习iOS第三方框架的源码，在这个学习过程中也走了很多弯路，最开始是从最基本的类开始看，后来发现越看越不懂，不知道这个属性的定义在什么时候用到，是什么含义（(ノへ￣、)捂脸。。。）。后来通过摸索才知道&lt;span&gt;&lt;strong&gt;源码学习应该直接从用到的方法着手，然后一步一步深入分析源码中每一步的目的和意义，顺藤摸瓜，逐个击破&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 2.2 Masonry框架中的链式语法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　下面的代码是比较常用的几种Masonry的布局格式，我们可以看到都是通过点语法的链式调用进行布局的。之前在学习Java和Android的过程中接触过链式语法，在Java中要实现这种链式语法很简单，无非就是每个方法的返回值就是其本身，因为Java的方法调用是通过点语法调用的，所以很容易实现。但是在OC中，方法调用都是通过  &lt;span class=&quot;cnblogs_code&quot;&gt;[clazz method:parm];&lt;/span&gt;  的形式进行调用的，那么Masonry框架中是怎么实现的呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
make.top.equalTo(sv).with.offset(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

make.left.right.mas_equalTo(sv).mas_offset(&lt;/span&gt;&lt;span&gt;0.0f&lt;/span&gt;&lt;span&gt;);

make.top.left.bottom.and.right.equalTo(sv).with.insets(UIEdgeInsetsMake(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　同样的学习方法，我们来看一下源码中各个属性或方法是怎么实现的，&lt;span&gt;&lt;strong&gt;最重要的原因就是getter方法和Objective-C 里面，调用方法是可以使用点语法的，但这仅限于没有参数的方法&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;23.5&quot;&gt;&lt;span&gt;首先，我们在用Masonry进行布局的时候最先用&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MASConstraintMaker调用一个方位属性（在MASConstraintMaker中定义了许多方位属性进行初始化调用，具体有哪些如下MASConstraintMaker.h文件中所示），用点语法调用，例如 &lt;span class=&quot;cnblogs_code&quot;&gt;make.top&lt;/span&gt; ，这时候其实是调用了其getter方法，然后在getter方法中对该约束的代理进行设置（见下MASConstraintMaker.m文件中标红注释处）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraintMaker.h文件&lt;/span&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; MASConstraintMaker : NSObject

@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;left;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;top;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;right;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;bottom;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;leading;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;trailing;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;width;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;height;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;centerX;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;centerY;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;baseline;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;gt;= 80000) || (__TV_OS_VERSION_MIN_REQUIRED &amp;gt;= 9000) || (__MAC_OS_X_VERSION_MIN_REQUIRED &amp;gt;= 101100)&lt;span&gt;

@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;firstBaseline;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;lastBaseline;

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;gt;= 80000) || (__TV_OS_VERSION_MIN_REQUIRED &amp;gt;= 9000)&lt;span&gt;

@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;leftMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;rightMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;topMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;bottomMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;leadingMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;trailingMargin;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;centerXWithinMargins;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;centerYWithinMargins;

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;edges;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;size;
@property (nonatomic, strong, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) MASConstraint *&lt;span&gt;center;
...

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraintMaker.m文件&lt;/span&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; MASConstraintMaker

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个方法返回的也是MASConstraint对象，实际上是MASViewConstraint、MASCompositeConstraint类型的对象，见最后的函数中标红的注释&lt;/span&gt;
- (MASConstraint *&lt;span&gt;)top {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将对应的系统自带的约束布局的属性NSLayoutAttributeTop传入&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过渡方法&lt;/span&gt;
- (MASConstraint *&lt;span&gt;)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终的调用&lt;/span&gt;
- (MASConstraint *)constraint:(MASConstraint *&lt;span&gt;)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    MASViewAttribute &lt;/span&gt;*viewAttribute =&lt;span&gt; [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];
    MASViewConstraint &lt;/span&gt;*newConstraint =&lt;span&gt; [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];
    
　　...

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加约束&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;constraint) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;strong&gt;&lt;span&gt;设置约束的代理是self&lt;/span&gt;&lt;/strong&gt;
        newConstraint.&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt; self;
        [self.constraints addObject:newConstraint];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;strong&gt;返回MASViewConstraint类型的对象&lt;/strong&gt;&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newConstraint;
}

...

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后通过&lt;strong&gt;&lt;span&gt;第一步的初始化之后返回的就是一个MASViewConstraint对象了，后面的点语法主要就在于MASViewConstraint中的属性和方法&lt;/span&gt;&lt;/strong&gt;了，在MASViewConstraint的.h和.m文件中我们都没有找到top等方位相关的属性或方法，但是我们发现MASViewConstraint是继承自MASConstraint的，然后我们发现在MASConstraint中定义了大量的方位相关方法（如下代码所示），所以类似 &lt;span class=&quot;cnblogs_code&quot;&gt;make.top.left&lt;/span&gt; 前面一个top是调用MASConstraintMaker的方法，后面一个left则是通过点语法调用MASConstraint的方法。但是为什么这些方法可以进行点语法调用呢？&lt;span&gt;&lt;strong&gt;&lt;span&gt;原因就是在Objective-C 里面，调用方法是可以使用点语法的，但这仅限于没有参数的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt; MASViewConstraint : MASConstraint &amp;lt;NSCopying&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraint.h文件&lt;/span&gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; MASConstraint : NSObject

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *    Creates a new MASCompositeConstraint with the called attribute and reciever
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
- (MASConstraint *&lt;span&gt;)left;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)top;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)right;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)bottom;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)leading;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)trailing;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)width;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)height;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)centerX;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)centerY;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)baseline;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;gt;= 80000) || (__TV_OS_VERSION_MIN_REQUIRED &amp;gt;= 9000) || (__MAC_OS_X_VERSION_MIN_REQUIRED &amp;gt;= 101100)

- (MASConstraint *&lt;span&gt;)firstBaseline;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)lastBaseline;

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;gt;= 80000) || (__TV_OS_VERSION_MIN_REQUIRED &amp;gt;= 9000)

- (MASConstraint *&lt;span&gt;)leftMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)rightMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)topMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)bottomMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)leadingMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)trailingMargin;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)centerXWithinMargins;
&lt;/span&gt;- (MASConstraint *&lt;span&gt;)centerYWithinMargins;

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

...

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraint.m文件&lt;/span&gt;
- (MASConstraint *&lt;span&gt;)top {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会调用MASViewConstraint中的addConstraintWithLayoutAttribute：方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASViewConstraint.m文件&lt;/span&gt;
- (MASConstraint *&lt;span&gt;)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    NSAssert(&lt;/span&gt;!self.hasLayoutRelation, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Attributes should be chained before defining the constraint relation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理的方法，之前我们说过设置的代理是MASConstraintMaker对象make，所以调用的实际上是MASConstraintMaker添加约束的方法，这就是我们再上面第一步讲到的方法&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; [self.&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; constraint:self addConstraintWithLayoutAttribute:layoutAttribute];
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraintMaker.m文件&lt;/span&gt;
- (MASConstraint *)constraint:(MASConstraint *&lt;span&gt;)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    MASViewAttribute &lt;/span&gt;*viewAttribute =&lt;span&gt; [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];
    MASViewConstraint &lt;/span&gt;*newConstraint =&lt;span&gt; [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;strong&gt;当传入的constraint不为空时，即此调用不是第一个，make.toip.left在left时的调用&lt;/strong&gt;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ([constraint isKindOfClass:MASViewConstraint.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;]) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;则用MASCompositeConstraint作为返回值，即组约束&lt;/span&gt;
        NSArray *children =&lt;span&gt; @[constraint, newConstraint];
        MASCompositeConstraint &lt;/span&gt;*compositeConstraint =&lt;span&gt; [[MASCompositeConstraint alloc] initWithChildren:children];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置代理&lt;/span&gt;
        compositeConstraint.&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt; self;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新设置&lt;/span&gt;
&lt;span&gt;        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;strong&gt;&lt;span&gt;返回 MASCompositeConstraint对象&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; compositeConstraint;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;constraint) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置代理&lt;/span&gt;
        newConstraint.&lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt; self;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置约束&lt;/span&gt;
&lt;span&gt;        [self.constraints addObject:newConstraint];
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newConstraint;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.3 链式语法中传参方法的调用 &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　在上一小节我们提到了链式语法的主要原因在于在Objective-C 里面，调用方法是可以使用点语法的，但这仅限于没有参数的方法，但是&lt;/span&gt;&lt;span&gt;类似mas_equalTo、mas_offset等带参数传递的方法依旧可以用链式语法又是怎么一回事呢&lt;/span&gt;&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;span&gt;&lt;strong&gt;最关键的一环就是 block&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;block就是一个代码块，但是它的神奇之处在于在内联(inline)执行的时候还可以传递参数。同时block本身也可以被作为参数在方法和函数间传递&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。block作为参数传递很常见，就是在我们的Masonry框架中添加约束的方法 &lt;/span&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;- (NSArray *)mas_makeConstraints:(&lt;span&gt;void&lt;/span&gt;(^)(MASConstraintMaker *))block&lt;/span&gt;&lt;span&gt; 中就是讲一个block作为参数进行传递的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同样在MASConstraint中，我们可以看到mas_equalTo、mas_offset等带参方法的定义如下，我们可以看到，方法的定义中并没有参数，但是返回值是一个带参的block，并且该block还返回一个MASConstraint对象（MASViewConstraint或者MASCompositeConstraint对象），所以方法的定义和使用都没有什么问题，和上一小节分析的内容差不多。最主要的区别就是这里返回值为带参数的block，并且该block的参数可以通过我们的方法进行传值。关于带参block作为返回值得用法可以参见 &lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://blog.csdn.net/aas319/article/details/53205064&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;此链接的文章&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (MASConstraint * (^&lt;span&gt;)(MASEdgeInsets insets))insets;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGFloat inset))inset;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGSize offset))sizeOffset;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGPoint offset))centerOffset;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGFloat offset))offset;

&lt;/span&gt;- (MASConstraint * (^)(NSValue *&lt;span&gt;value))valueOffset;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGFloat multiplier))multipliedBy;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(CGFloat divider))dividedBy;

&lt;/span&gt;- (MASConstraint * (^&lt;span&gt;)(MASLayoutPriority priority))priority;

&lt;/span&gt;- (MASConstraint * (^)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))priorityLow;

&lt;/span&gt;- (MASConstraint * (^)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))priorityMedium;

&lt;/span&gt;- (MASConstraint * (^)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))priorityHigh;

&lt;/span&gt;- (MASConstraint * (^)(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; attr))equalTo;

&lt;/span&gt;- (MASConstraint * (^)(&lt;span&gt;id&lt;/span&gt; attr))greaterThanOrEqualTo;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASConstraint.m文件&lt;/span&gt;
- (MASConstraint * (^)(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;))mas_equalTo {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ^&lt;span&gt;id&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; attribute) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多态调用子类MASViewConstraint或者MASCompositeConstraint的对应方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.equalToWithRelation(attribute, NSLayoutRelationEqual);
    };
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MASViewConstraint.m中对应的方法，MASCompositeConstraint其实也类似，只是循环调用每一个子约束的该方法&lt;/span&gt;
- (MASConstraint * (^)(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;, NSLayoutRelation))equalToWithRelation {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ^&lt;span&gt;id&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; attribute, NSLayoutRelation relation) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入的参数是一个数组 则逐个约束解析后以组形式添加约束&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ([attribute isKindOfClass:NSArray.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;]) {
            NSAssert(&lt;/span&gt;!self.hasLayoutRelation, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Redefinition of constraint relation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            NSMutableArray &lt;/span&gt;*children = NSMutableArray.&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;id&lt;/span&gt; attr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attribute) {
                MASViewConstraint &lt;/span&gt;*viewConstraint =&lt;span&gt; [self copy];
                viewConstraint.layoutRelation &lt;/span&gt;=&lt;span&gt; relation;
                viewConstraint.secondViewAttribute &lt;/span&gt;=&lt;span&gt; attr;
                [children addObject:viewConstraint];
            }
            MASCompositeConstraint &lt;/span&gt;*compositeConstraint =&lt;span&gt; [[MASCompositeConstraint alloc] initWithChildren:children];
            compositeConstraint.&lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt; = self.&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;;
            [self.&lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; constraint:self shouldBeReplacedWithConstraint:compositeConstraint];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; compositeConstraint;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单一约束 则直接赋值&lt;/span&gt;
            NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;amp;&amp;amp; [attribute isKindOfClass:NSValue.&lt;span&gt;class&lt;/span&gt;], &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Redefinition of constraint relation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            self.layoutRelation &lt;/span&gt;=&lt;span&gt; relation;
            self.secondViewAttribute &lt;/span&gt;=&lt;span&gt; attribute;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
        }
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;12.836206896552&quot;&gt;
&lt;p&gt;&lt;span&gt;进过上面的原理分析，大体理解了其调用和实现眼里，接下来，我们通过下面的这句代码在容器中的演变过程来进行整体感受一下，下面的演变过程来自：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/p/f3fa4938bf67&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Masonry源码学习&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;，原文&lt;span&gt;有几处有点小问题修改过，大家参考的时候注意甄别和判断。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
make.top.right.bottom.left.equalTo(superview)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;make.top&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;生成对象A:MASViewConstraint(view.top)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将A的delegate设为make&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将A放入make的constraints中，此时make.constraints = [A]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回A&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;make.top.right&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;生成对象B:MASViewConstraint(view.right)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用A和B生成MASCompositeConstraint对象C，将C的delegate设为make&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将make.constraints中替换成C，此时make.constraints = [C]，C.childConstraints = [A,B]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;make.top.right.bottom&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;生成对象D:MASViewConstraint(view.bottom)，将D的delegate为C&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将D放入C.childConstraints中，此时C.childConstraints = [A,B,D]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;make.top.right.bottom.left&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;生成对象E:MASViewConstraint(view.left)，E的delegate为C&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将E放入C.childConstraints中，此时C.childConstraints = [A,B,D,E]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;make.top.right.bottom.left.equalTo(superview)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;会依次调用A,B,D,E的equalTo(superView)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在上面的过程中可以看到：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对make.constraints的添加和替换元素的操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对MASCompositeConstraint对象的添加元素的操作（当.equalTo(@[view1,view2])时就有替换操作了，在里面没体现出）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个constraint的delegate为它的父容器，因为需要父容器来执行添加和替换约束的操作。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201802/926487-20180212162017406-1777336068.png&quot; alt=&quot;&quot; width=&quot;843&quot; height=&quot;452&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　盗用&lt;span&gt;&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ludashi/p/5591572.html&quot;&gt;&lt;span&gt;iOS开发之Masonry框架源码解析&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;中的一张图，这张图将Masonry框架的架构阐述的很清晰，Masonry框架主要分为4个部分：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;View+MASAdditions：最左边的红色框的这个类，这是Masonry框架最主要的一个类，主要是最下面的四个添加和修改约束的方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;MASConstraintMaker：中间绿色框中的这个类，这是Masonry框架中的过渡类，链接最左边和最右边之间的关系，也是链式语法的发起点和添加约束的执行点。&lt;code&gt;MASConstraintMaker&lt;/code&gt;类就是一个工厂类，负责创建和安装&lt;code&gt;MASConstraint&lt;/code&gt;类型的对象（依赖于&lt;code&gt;MASConstraint&lt;/code&gt;接口，而不依赖于具体实现）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;核心类：最右边的黄色框的这个类群，这是Masonry框架中的核心基础类群，这个类群又分为两个部分：&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;约束类群：黄色框上面三个类，其中MASConstraint是一个抽象类，不可被实例化。我们可以将MASConstraint是对NSLayoutConstriant的封装，看做是一个接口或者协议。MASViewConstraint和MASCompositeConstraint都继承自MASConstraint，其中MASViewConstraint用于定义一个单独的约束，而MASCompositeConstraint则用于定义一组约束条件，例如定义size、insert等参数时返回的其实都是MASCompositeConstraint。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;属性类群：主要是指MASViewAttribute&lt;span&gt;，主要是对&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;NSLayoutAttribute的扩展，方便我们进行约束定义和修改&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;附属类群：还有一些工具类没有在这张图中进行展示，例如NSArray+MASAdditions、NSLayoutConstraint+MASDebugAdditions、MASLayoutConstraint等，都定义了一些工具和简化方法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 12 Feb 2018 08:46:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/8431899.html</dc:identifier>
</item>
<item>
<title>如何使用 scikit-learn 为机器学习准备文本数据 - 云加社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8444576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8444576.html</guid>
<description>&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;文本数据需要特殊处理，然后才能开始将其用于预测建模。&lt;/p&gt;
&lt;p&gt;我们需要解析文本，以删除被称为标记化的单词。然后，这些词还需要被编码为整型或浮点型，以用作机器学习算法的输入，这一过程称为特征提取（或矢量化）。&lt;/p&gt;
&lt;p&gt;scikit-learn 库提供易于使用的工具来对文本数据进行标记和特征提取。&lt;/p&gt;
&lt;p&gt;在本教程中，您可以学到如何使用 scikit-learn 为 Python 中的预测建模准备文本数据。&lt;/p&gt;
&lt;p&gt;完成本教程后，您可以学到：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;如何使用 CountVectorizer 将文本转换为文字计数向量。&lt;/li&gt;
&lt;li&gt;如何使用 TfidfVectorizer 将文本转换为词频向量。&lt;/li&gt;
&lt;li&gt;如何使用 HashingVectorizer 将文本转换为唯一的整数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让我们开始吧。&lt;/p&gt;
&lt;img src=&quot;https://ask.qcloudimg.com/http-save/10006/2736/5cc52bna6o.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div readability=&quot;162.66228817808&quot;&gt;
&lt;h2&gt;词袋模型（ Bag-of-Words Model ）&lt;/h2&gt;
&lt;p&gt;使用机器学习算法时，我们不能直接使用文本。&lt;/p&gt;
&lt;p&gt;相反，我们需要将文本转换为数字。&lt;/p&gt;
&lt;p&gt;我们可能想对文档进行分类，每一类文档都是“输入”，而类别标签是我们预测算法的“输出”。算法将数字向量作为输入，因此我们需要将文档转换为固定长度的数字向量。&lt;/p&gt;
&lt;p&gt;在机器学习中，Bag-of-Words 模型（BoW）是一种简单而有效的让计算机“理解”文本文档的模型。&lt;/p&gt;
&lt;p&gt;这个模型非常简单，它移除了单词的诸如词序、语法等顺序信息，只关注文档中该单词的出现情况。&lt;/p&gt;
&lt;p&gt;上面这一步可以通过为每个单词分配一个唯一的编码来完成。我们所看到的任何文档都可以被编码为一个固定长度的矢量，其长度为文档中全部已知单词的词汇量。矢量中每个位置的值可以用编码文档中每个单词的出现个数或频率填充。&lt;/p&gt;
&lt;p&gt;在词袋模型中，我们只关心编码方案，而编码方案描述了文档中出现了什么单词，以及这些单词在编码文档中出现的频率，而没有任何关于顺序的信息。&lt;/p&gt;
&lt;p&gt;有很多方法来扩展这个简单的方法，例如，我们可以想办法更好地解释一个单词的含义，或是更好地规定向量中每个单词的编码方式。&lt;/p&gt;
&lt;p&gt;scikit-learn 库提供了3种不同的方案供我们使用，下面简要地介绍一下。&lt;/p&gt;
&lt;h2&gt;使用 CountVectorizer 计算字数&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html&quot; target=&quot;_blank&quot;&gt;CountVectorizer&lt;/a&gt; 提供了一个简单的方法，既可以标记文本文档的集合, 也可以生成每个已知单词的索引, 还可以使用这一套索引对新文档进行编码。&lt;/p&gt;
&lt;p&gt;下面是一种使用方法：&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;实例化一个 &lt;em&gt;CountVectorizer&lt;/em&gt; 类。&lt;/li&gt;
&lt;li&gt;调用 &lt;em&gt;fit()&lt;/em&gt; 函数以从一个或多个文档中建立索引。&lt;/li&gt;
&lt;li&gt;根据需要在一个或多个文档中调用 &lt;em&gt;transform()&lt;/em&gt; 函数，将每个文档编码为一个向量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终会返回一个已编码的向量, 其长度为索引的个数，该向量还携带有文档中每个单词出现的次数信息。&lt;/p&gt;
&lt;p&gt;包含很多零的向量被称为稀疏向量。Python 的 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html&quot; target=&quot;_blank&quot;&gt;scipy.sparse&lt;/a&gt; 包中提供了一种处理稀疏向量的有效方法。&lt;/p&gt;
&lt;p&gt;调用 transform() 返回的向量是稀疏向量，这里可以通过调用 toarray() 函数将它们转换回 numpy 数组以便查看并更好地理解这个过程。&lt;/p&gt;
&lt;p&gt;下面是使用 CountVectorizer 标记，构建索引，然后编码文档的示例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sklearn.feature_extraction.text import CountVectorizer

# 下面是一个文本文档的列表

text &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The quick brown fox jumped over the lazy dog.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

# 实例化 CountVectorizer 类

vectorizer &lt;/span&gt;=&lt;span&gt; CountVectorizer()

# 标记并建立索引

vectorizer.fit(text)

# 查看结果

print(vectorizer.vocabulary_)

# 编码文档

vector &lt;/span&gt;=&lt;span&gt; vectorizer.transform(text)

# 查看编码后的向量

print(vector.shape)

print(type(vector))

print(vector.toarray())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，如下一行是用来帮助我们访问这个索引并查看标记的结果的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
print(vectorizer.vocabulary_)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，所有的单词默认都是小写字母，标点符号也被忽略了。标记的许多方面都是可以配置的，您可以查看&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html&quot; target=&quot;_blank&quot;&gt;API文档&lt;/a&gt;中的所有选项。&lt;/p&gt;
&lt;p&gt;运行示例之后，首先输出的是索引，然后输出的是编码文档的结构。我们可以看到索引中有8个词，因此编码向量长度为 8。&lt;/p&gt;
&lt;p&gt;从接下来输出的类型中可以看出，编码向量是一个稀疏向量。而最后的输出是编码向量的数组版本，其表达的含义是，索引值为 7 的单词出现次数为 2，其余单词出现次数为 1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;over&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;brown&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quick&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;the&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lazy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;jumped&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}

(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scipy.sparse.csr.csr_matrix&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

[[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重要的是，同一个矢量化器可以用在包含词汇表中没有包括的单词的文档上。不过，没有包括的词会被忽略，并且不会在结果向量中计数。&lt;/p&gt;
&lt;p&gt;举个例子，下面是使用上述向量化器对另一个文档进行编码的例子。这个文本文档包含两个词，一个词包含在索引中，另一个不包含在索引中。&lt;/p&gt;
&lt;h2&gt;将另一个文档编码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
text2 = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the puppy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

vector &lt;/span&gt;=&lt;span&gt; vectorizer.transform(text2)

print(vector.toarray())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行这个例子，会输出编码的稀疏向量的数组版本，从这个输出中可以看出，在词汇中出现的单词的没有被忽略，而另一个不在词汇中的单词被忽略了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[[&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这之后，编码向量就可以直接使用到机器学习算法中了。&lt;/p&gt;
&lt;h2&gt;使用 TfidfVectorizer 统计词频&lt;/h2&gt;
&lt;p&gt;单词计数是一个非常好、非常简单的起点。&lt;/p&gt;
&lt;p&gt;不过，简单计数也存在不足。例如，简单计数中像“ &lt;em&gt;the&lt;/em&gt; ” 这样的词会出现很多次，在编码的向量中，这样的单词计数会很大，却没有太大意义。&lt;/p&gt;
&lt;p&gt;除了统计个数外的另一种方法是计算词频，到目前为止，最流行的方法是&lt;a href=&quot;https://en.wikipedia.org/wiki/Tf%252525252525E2%25252525252580%25252525252593idf&quot; target=&quot;_blank&quot;&gt;TF-IDF&lt;/a&gt;。TF-IDF 是 Term Frequency - Inverse Document Frequency 的首字母缩写词，它是分配给每个单词的结果分数的组成部分。&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;词频（Term Frequency）：该值表示给定单词在这份文档中出现的频率。&lt;/li&gt;
&lt;li&gt;逆向文件频率（Inverse Document Frequency）：该值用于降低其他文档中普遍出现的单词的最终评分。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;没有进入数学，TF-IDF是词频分数，可以突出个性化的单词，例如在只在这份文档中频繁出现，但其他文档中较少出现的单词。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html&quot; target=&quot;_blank&quot;&gt;TfidfVectorizer&lt;/a&gt; 将标记文件、建立索引、求出逆文档频率权重，并允许您编码新的文件。或者，如果您已经有了一个已经训练过的 CountVectorizer，您可以将其与 &lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfTransformer.html&quot; target=&quot;_blank&quot;&gt;TfidfTransformer&lt;/a&gt; 一起使用，以计算逆文档频率并开始编码文档。&lt;/p&gt;
&lt;p&gt;TfidfVectorizer 的实例化、拟合和转换方法和 CountVectorizer 类似。&lt;/p&gt;
&lt;p&gt;下面的示例展示了如何是使用 TfidfVectorizer 训练 3 个小文档的索引和逆文档频率，并编码其中一个文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sklearn.feature_extraction.text import TfidfVectorizer

# 下面是一个文本文档的列表

text &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The quick brown fox jumped over the lazy dog.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The dog.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The fox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

# 实例化过程

vectorizer &lt;/span&gt;=&lt;span&gt; TfidfVectorizer()

# 标记并建立索引

vectorizer.fit(text)

# 输出以查看结果

print(vectorizer.vocabulary_)

print(vectorizer.idf_)

# 编码文档

vector &lt;/span&gt;=&lt;span&gt; vectorizer.transform(text0)

# 查看编码后的向量

print(vector.shape)

print(vector.toarray())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从文档中学习 8 个单词的得到索引，并且每个单词在输出向量中被分配唯一的整数索引值。&lt;/p&gt;
&lt;p&gt;计算每个单词的逆文档频率，将最低分数 1.0 分配给最常见的词：索引值为 7 的“&lt;em&gt;the”&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;最后，第一个文档被编码为一个8元素的稀疏数组，我们可以从结果中的其他单词中查看诸如“&lt;em&gt;the&lt;/em&gt;”，“&lt;em&gt;fox&lt;/em&gt;”和“&lt;em&gt;dog&lt;/em&gt;”等不同值的最终评分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lazy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quick&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;the&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;over&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;brown&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;jumped&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}

[ &lt;/span&gt;&lt;span&gt;1.69314718&lt;/span&gt; &lt;span&gt;1.28768207&lt;/span&gt; &lt;span&gt;1.28768207&lt;/span&gt; &lt;span&gt;1.69314718&lt;/span&gt; &lt;span&gt;1.69314718&lt;/span&gt; &lt;span&gt;1.69314718&lt;/span&gt;

&lt;span&gt;1.69314718&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. ]

(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)

[[ &lt;/span&gt;&lt;span&gt;0.36388646&lt;/span&gt; &lt;span&gt;0.27674503&lt;/span&gt; &lt;span&gt;0.27674503&lt;/span&gt; &lt;span&gt;0.36388646&lt;/span&gt; &lt;span&gt;0.36388646&lt;/span&gt; &lt;span&gt;0.36388646&lt;/span&gt;

&lt;span&gt;0.36388646&lt;/span&gt; &lt;span&gt;0.42983441&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将评分标准化为 0 到 1 之间的值。在这之后，编码过的文档向量即可直接用于大多数机器学习算法中了。&lt;/p&gt;
&lt;h2&gt;使用 HashingVectorizer 建立散列表&lt;/h2&gt;
&lt;p&gt;统计个数和计算频率两种方法虽然非常实用，但是也由其局限性导致词汇量可能变得非常大。&lt;/p&gt;
&lt;p&gt;词汇量过大又将导致需要非常大的矢量来编码文档，从而对内存产生很大的要求，同时拖慢算法的速度。&lt;/p&gt;
&lt;p&gt;这里有一个巧妙的解决方法，即建立单词的单向散列表，进而将每个单词转换为整数。这么做的优点是不需要专门建立索引，并且你可以将定长向量的长度定为任意值。缺点是散列是一个单向函数，所以没有办法将编码转换回单词（不过这一步对于许多监督学习任务可能并不重要）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.HashingVectorizer.html&quot; target=&quot;_blank&quot;&gt;HashingVectorizer&lt;/a&gt; 类实现了此方法，使其可用于一致地散列单词，然后根据需要标记和编码文件。&lt;/p&gt;
&lt;p&gt;下面的示例演示了用于编码单个文档的 HashingVectorizer。&lt;/p&gt;
&lt;p&gt;选择长度为 20 的定长向量。这个长度对应于散列函数的范围，不过例如 20 这样的小值可能导致散列表冲突。回想计算机科学课里相关的知识，这里可以使用试探法，根据估计的词汇量的大小和碰撞概率来挑选哈希长度。&lt;/p&gt;
&lt;p&gt;请注意，这个矢量化器不需要调用 &lt;em&gt;fit()&lt;/em&gt; 函数来训练数据文档。实例化之后，它可以直接用于编码文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sklearn.feature_extraction.text import HashingVectorizer

# 下面是一个文本文档的列表

text &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The quick brown fox jumped over the lazy dog.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

# 实例化 HashingVectorizer

vectorizer &lt;/span&gt;= HashingVectorizer(n_features=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)

# 编码文档

vector &lt;/span&gt;=&lt;span&gt; vectorizer.transform(text)

# 查看编码后的向量

print(vector.shape)

print(vector.toarray())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行上述示例代码，样例文档将被编码为包含 20 个元素的稀疏数组。&lt;/p&gt;
&lt;p&gt;编码文档的值默认将字数标准化到 -1 和 1 之间，这里也可以通过更改默认配置使其进行简单的整数计数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;)

[[ &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0.33333333&lt;/span&gt;

   &lt;span&gt;0&lt;/span&gt;.         -&lt;span&gt;0.33333333&lt;/span&gt;  &lt;span&gt;0.33333333&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0.33333333&lt;/span&gt;

   &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;.         -&lt;span&gt;0.33333333&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;.          &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.

  &lt;/span&gt;-&lt;span&gt;0.66666667&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;.        ]]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;进一步探究&lt;/h2&gt;
&lt;p&gt;如果您想进行深入研究，下面提供更多有关该主题的资源。&lt;/p&gt;
&lt;h3&gt;自然语言处理&lt;/h3&gt;
&lt;h3&gt;sciki-learn&lt;/h3&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;在本教程中，你可以了解如何使用scikit-learn为机器学习准备文本文档。&lt;/p&gt;
&lt;p&gt;这些例子只是抓住了表面，但是，这些类有很多配置细节影响着文档的标记，这些都是值得深究的。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 12 Feb 2018 08:43:00 +0000</pubDate>
<dc:creator>云加社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8444576.html</dc:identifier>
</item>
</channel>
</rss>