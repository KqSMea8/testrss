<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>FreeRTOS--堆内存管理 - 林特斯9527</title>
<link>http://www.cnblogs.com/LinTeX9527/p/8007541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LinTeX9527/p/8007541.html</guid>
<description>&lt;p&gt;因为项目需要，最近开始学习FreeRTOS，一开始有些紧张，因为两个星期之前对于FreeRTOS的熟悉度几乎为零，经过对FreeRTOS官网的例子程序的摸索，和项目中问题的解决，遇到了很多熟悉的身影，以前在Linux平台编程的经历给了我一些十分有用的经验，后悔当初没能在第一家公司待下去，浪费了大好时光。好吧，现在还是潜下心来搞搞FreeRTOS吧。&lt;/p&gt;
&lt;p&gt;后续都是一系列FreeRTOS相关的随笔，先把&lt;strong&gt;FreeRTOS“圣经”&lt;/strong&gt;--&lt;code&gt;Mastering the FreeRTOS Real Time kernel -- A Hands On Tutorial Guide 20161204&lt;/code&gt;好好研读，接连的几个随笔都是我从这本“圣经”中翻译出来的。翻译难免有所疏漏、词不达意，大家凑合着看吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从FreeRTOS V9.0.0开始FreeRTOS应用程序可以完全用静态分配内存，而没有必要引入堆内存管理。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;章节引言和范围&quot;&gt;章节引言和范围&lt;/h2&gt;
&lt;h3 id=&quot;前提&quot;&gt;前提&lt;/h3&gt;
&lt;p&gt;FreeRTOS是以C源文件的形式提供的，因此成为一名合格的C语言编程人员是使用FreeRTOS的必要条件，因而这个章节假定读者熟悉以下概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C语言项目是如何构建的，包含不同的编译和链接过程&lt;/li&gt;
&lt;li&gt;堆和栈分别是什么&lt;/li&gt;
&lt;li&gt;标准C库的&lt;code&gt;malloc()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;动态内存分配以及它和freertos的关系&quot;&gt;动态内存分配以及它和FreeRTOS的关系&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从FreeRTOS V9.0.0开始内核对象既可以在编译的时候静态分配，也可以在运行时动态分配。&lt;/strong&gt;本书随后的章节将会介绍以下内核对象：&lt;strong&gt;tasks&lt;/strong&gt;, &lt;strong&gt;queues&lt;/strong&gt;, &lt;strong&gt;semaphores&lt;/strong&gt; 和 &lt;strong&gt;event groups&lt;/strong&gt;。为了尽可能让FreeRTOS易于使用，这些内核对象并不是在编译时静态分配的，而是在运行时动态分配的。内核对象创建时FreeRTOS分配RAM而在内核对象删除时释放内存。这样的策略减少了设计和计划上的努力，简化了API，并且减少了RAM的占用。&lt;/p&gt;
&lt;p&gt;动态内存分配是C语言编程的概念，而不是针对FreeRTOS或者多任务编程的概念。它和FreeRTOS是相关的，因为内核对象是动态分配的，并且通用编译器提供的动态内存分配方案对于实时应用程序并不总是适合的。&lt;/p&gt;
&lt;p&gt;内存可以使用标准C库的&lt;code&gt;malloc()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;函数来分配，但有可能不适合，或者恰当，因为下几点原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在小型嵌入式系统中并不总是可用的&lt;/li&gt;
&lt;li&gt;它们的实现可能非常的大，占据了相当大的一块代码空间&lt;/li&gt;
&lt;li&gt;他们几乎都不是线程安全的&lt;/li&gt;
&lt;li&gt;它们并不是确定的，每次调用这些函数执行的时间可能都不一样&lt;/li&gt;
&lt;li&gt;它们有可能产生碎片&lt;/li&gt;
&lt;li&gt;它们有可能打乱链接器的配置&lt;/li&gt;
&lt;li&gt;如果允许堆空间的生长方向覆盖其他变量占据的内存，它们会成为&lt;strong&gt;debug&lt;/strong&gt;的灾难&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;动态内存分配的可选项&quot;&gt;动态内存分配的可选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从FreeRTOS V9.0.0开始内核对象既可以在编译时静态分配也可以在运行时动态分配&lt;/strong&gt;。如今FreeRTOS把内存分配放在可移植层。这是认识到不同的嵌入式操作有不同的动态内存管理方法和时间要求，因此单个的动态内存分配算法将只适合于应用程序的一个子集。同样，从核心代码库中移除动态内存分配使得应用程序编写者提供自己的特定的实现，如果适合的话。&lt;/p&gt;
&lt;p&gt;当FreeRTOS需要RAM的时候，并不是调用&lt;code&gt;malloc()&lt;/code&gt;，而是调用&lt;code&gt;pvPortMalloc()&lt;/code&gt;。当需要释放RAM的时候，并不是调用&lt;code&gt;free()&lt;/code&gt;，而是调用&lt;code&gt;vPortFree()&lt;/code&gt;。&lt;code&gt;pvPortMalloc()&lt;/code&gt;和标准C库的&lt;code&gt;malloc()&lt;/code&gt;有同样的函数原型，&lt;code&gt;vPortFree()&lt;/code&gt;和标准C库的&lt;code&gt;free()&lt;/code&gt;有同样的函数原型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pvPortMalloc()&lt;/code&gt; 和 &lt;code&gt;vPortFree()&lt;/code&gt;都是公共函数，因此能够被应用代码调用。&lt;/p&gt;
&lt;p&gt;FreeRTOS对于&lt;code&gt;pvPortMalloc()&lt;/code&gt;和&lt;code&gt;vPortFree()&lt;/code&gt;提供了5种实现，后续章节会讲到。FreeRTOS应用程序可以使用其中的一种，或者使用自己的实现。5种实现分别在&lt;code&gt;heap_1.c&lt;/code&gt;, &lt;code&gt;heap_2.c&lt;/code&gt;, &lt;code&gt;heap_3.c&lt;/code&gt;, &lt;code&gt;heap_4.c&lt;/code&gt; 和 &lt;code&gt;heap_5.c&lt;/code&gt;文件中，都存在于文件夹 &lt;code&gt;FreeRTOS/Source/portable/MemMang&lt;/code&gt; 下。&lt;/p&gt;
&lt;h3 id=&quot;范围&quot;&gt;范围&lt;/h3&gt;
&lt;p&gt;本章节致力于让读者深入理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FreeRTOS何时分配RAM&lt;/li&gt;
&lt;li&gt;FreeRTOS 提供的5种内存分配方案&lt;/li&gt;
&lt;li&gt;选用哪一种内存分配方案&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;内存分配方案示例&quot;&gt;内存分配方案示例&lt;/h2&gt;
&lt;h3 id=&quot;heap_4-其他几种暂不去了解&quot;&gt;&lt;strong&gt;&lt;code&gt;Heap_4&lt;/code&gt;&lt;/strong&gt; （其他几种暂不去了解）&lt;/h3&gt;
&lt;p&gt;和&lt;strong&gt;&lt;code&gt;heap_1&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;heap_2&lt;/code&gt;&lt;/strong&gt; 一样，&lt;strong&gt;&lt;code&gt;heap_4&lt;/code&gt;&lt;/strong&gt;也是把数组切割成更小的块。和前面一样，数组是静态声明的，由宏&lt;code&gt;configTOTAL_HEAP_SIZE&lt;/code&gt;指定大小，所以这就使得即便数组中的内存还没有被分配出去就让应用程序显得消耗了大量的RAM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Heap_4&lt;/code&gt;&lt;/strong&gt;使用了最先适应算法来分配内存。和&lt;code&gt;heap_2&lt;/code&gt;不同，&lt;code&gt;heap_4&lt;/code&gt;把临近的空闲的存储空间拼凑成一个更大的内存块，这就减少了内存碎片化的风险。&lt;/p&gt;
&lt;p&gt;最先适应算法确保了&lt;code&gt;pvPortMalloc()&lt;/code&gt;使用第一块空闲的足够大的内存来满足要申请的字节数。考虑下面的情景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;堆里有3块空闲内存块，它们的大小分别是5个字节，200个字节，100个字节&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;pvPortMalloc()&lt;/code&gt;来申请20个字节的RAM&lt;br/&gt;满足字节数要求的第一块空闲RAM块是200个字节的RAM块，因此&lt;code&gt;pvPortMalloc()&lt;/code&gt;把大小为200个字节的RAM块分割成两块，一块是20个字节，一块是180个字节，然会返回一个指向20个字节的指针。新的180个字节大小的RAM块将在后续的&lt;code&gt;pvPortMalloc()&lt;/code&gt;调用中可用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Figure 7 演示了 &lt;code&gt;heap_4&lt;/code&gt; 最先适应算法如何拼接内存，同样也演示了内存的分配和释放：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/666431/201712/666431-20171209000202593-1332841229.jpg&quot; alt=&quot;Figure 7&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;A&lt;/code&gt;演示了创建3个任务之后的数组的样子，一大块空的块存在于数组的顶端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;演示了删除1个任务之后的数组，一大块空的块存在于数组的顶端。被删除的那个任务占据的TCB和栈存储空间现在是空的，并且它们拼接成一个大的空的块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;演示了FreeRTOS创建了一个Queue。队列是通过&lt;code&gt;xQueueCreate()&lt;/code&gt; API 创建的，它是调用&lt;code&gt;pvPortMalloc()&lt;/code&gt; 来分配存储空间的。由于&lt;code&gt;heap_4&lt;/code&gt;采用最先适应算法，&lt;code&gt;pvportMalloc()&lt;/code&gt;将会使用第一块大的足够容纳队列的RAM块来分配，在Figure 7中就采用之前删除任务的那一块。然而队列并不完全消耗那个空闲的区块，所以那个RAM块会分成两个部分，未使用的部分将会由后续的&lt;code&gt;pvPortMalloc()&lt;/code&gt;占用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt;演示了应用程序直接调用&lt;code&gt;pvPortMalloc()&lt;/code&gt;而不是间接地由FreeRTOS API调用之后的情形。用户分配的区块足够小，能够放在第一个空闲的区块中，这个区块就是队列占用的区块和后面的TCB占用的区块之间的那一块。&lt;br/&gt;删除任务释放的内存，现在被分割成3个区块，第一个区块是队列，第二个区块是用户分配的，第三个区块还是空的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt; 演示了队列删除之后，存储空间也自动释放了。现在用户分配的区块两边都是空闲区块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F&lt;/code&gt; 演示了用户分配的存储空间释放的情形。这个区块现在和两边的空闲区块拼接成了一个更大的空闲区块。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;Heap_4&lt;/code&gt;并不是确定性的，但是要比标准库函数实现的&lt;code&gt;malloc()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;运行的更快。&lt;/p&gt;
&lt;h3 id=&quot;设定heap_4数组的起始地址&quot;&gt;设定&lt;code&gt;Heap_4&lt;/code&gt;数组的起始地址&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;此章节包含更高阶的信息，仅仅为了使用&lt;code&gt;Heap_4&lt;/code&gt;是没有必要阅读和理解此章节的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些时候应用程序开发者需要指定&lt;code&gt;heap_4&lt;/code&gt;数组的起始地址位于某个特定的内存。例如，FreeRTOS 任务的栈是从堆中分配的，就有可能有必要保证堆是分配在快速的内存中，而不是慢速的外存。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;heap_4&lt;/code&gt;数组是在&lt;code&gt;heap_4.c&lt;/code&gt;源文件中声明的，它的起始地址是由链接器自动确定的。然而，如果在文件&lt;code&gt;FreeRTOSConfig.h&lt;/code&gt;中把编译时配置选项&lt;code&gt;configAPPLICATION_ALLOCATED_HEAP&lt;/code&gt;设为常量&lt;code&gt;1&lt;/code&gt;，那么数组必须由使用FreeRTOS的应用声明。如果把数组声明为应用的一部分，那么应用编写者可以指定数组的起始地址。&lt;/p&gt;
&lt;p&gt;如果把文件&lt;code&gt;FreeRTOSConfig.h&lt;/code&gt;中的&lt;code&gt;configAPPLICATION_ALLOCATED_HEAP&lt;/code&gt;设定为&lt;strong&gt;1&lt;/strong&gt;，那么应用程序源文件中必须声明一个名字为&lt;code&gt;ucHeap&lt;/code&gt;的&lt;code&gt;uint8_t&lt;/code&gt;类型的数组，它的大小有&lt;code&gt;configTOTAL_HEAP_SIZE&lt;/code&gt;设定。&lt;/p&gt;
&lt;p&gt;把变量放在某个内存地址的语法取决于使用了哪种编译器，下面演示了两种编译器的用法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Listing 2演示的是GCC编译器声明数组并把数组放在名字为&lt;code&gt;.my_heap&lt;/code&gt;的段中。&lt;/li&gt;
&lt;li&gt;Listing 3演示的是IAR编译器把数组放在内存绝对地址&lt;strong&gt;0x20000000&lt;/strong&gt;上。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;uint8_t ucHeap [configTOTAL_HEAP_SIZE] &lt;strong&gt;attribute&lt;/strong&gt; (( section(&quot;.my_heap&quot;) ));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Listing 2&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;uint8_t ucHeap [configTOTAL_HEAP_SIZE] @ 0x20000000;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Listing 3&lt;/p&gt;
&lt;h2 id=&quot;和堆相关的实用函数&quot;&gt;和堆相关的实用函数&lt;/h2&gt;
&lt;h3 id=&quot;xportgetfreeheapsize-api&quot;&gt;&lt;strong&gt;&lt;code&gt;xPortGetFreeHeapSize()&lt;/code&gt;&lt;/strong&gt; API&lt;/h3&gt;
&lt;p&gt;这个函数可以获取调用时堆中空闲内存的大小，以字节为单位。使用它可以优化堆的大小。例如，当内核对象都创建完毕后调用&lt;code&gt;x&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 16:07:00 +0000</pubDate>
<dc:creator>林特斯9527</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LinTeX9527/p/8007541.html</dc:identifier>
</item>
<item>
<title>15. 使用Apache Curator管理ZooKeeper - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8007605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8007605.html</guid>
<description>&lt;p&gt;Apache ZooKeeper是为了帮助解决复杂问题的软件工具，它可以帮助用户从复杂的实现中解救出来。 然而，ZooKeeper只暴露了原语，这取决于用户如何使用这些原语来解决应用程序中的协调问题。 社区已经在ZooKeeper数据模型及其API之上开发了高级框架。 Apache Curator是一个高级的包装类库和框架，使得ZooKeeper非常简单易用。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;Curator最初由Netflix开发，现在是一个Apache项目。 项目页面位于http://curator.apache.org/。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-curator组件&quot;&gt;一 Curator组件&lt;/h3&gt;
&lt;p&gt;Curator是ZooKeeper的高级类库；它使处理ZooKeeper变得更容易，并扩展了核心ZooKeeper的功能。 Curator在高层次上由以下部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client：Curator客户端是ZooKeeper的Java客户端的一个包装器。 它是Curator堆栈中的一个低级API，并且抽象出ZooKeeper客户端的功能。&lt;/li&gt;
&lt;li&gt;Framework：Curator框架是一个具有高级功能的高级API，如自动连接管理，操作重试等等。 它在很大程度上简化了ZooKeeper的使用。&lt;/li&gt;
&lt;li&gt;Recipe：Curator Recipe提供ZooKeeper Recipe的实现； 这些实现可以直接用于分布式应用程序来解决协调问题。&lt;/li&gt;
&lt;li&gt;Extensions：Curator Recipe包实现了常见的Recipe。 为了避免这个包的膨胀，使用一个单独的扩展包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了前面的组件外，Curator还附带一些ZooKeeper有用的工具。 Curator堆栈如下图所示：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-f819c42dc01c1919.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;The Curator stack&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Curator JARs可以在Maven Central的仓库中找到。 Curator可以很容易地包含在Maven，Gradle，Ivy，SBT等构建脚本中。&lt;/p&gt;
&lt;p&gt;各种Maven artifacts在http://mvnrepository.com/artifact/org.apache.curator上列出。&lt;/p&gt;
&lt;h3 id=&quot;二-curator客户端&quot;&gt;二 Curator客户端&lt;/h3&gt;
&lt;p&gt;Curator Client是ZooKeeper Java客户端的一个包装器。它使客户端访问ZooKeeper更简单，更不易出错。&lt;/p&gt;
&lt;p&gt;Curator客户端提供以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接管理：管理与ZooKeeper服务器的连接&lt;/li&gt;
&lt;li&gt;操作重试实用程序：这是重试操作的机制&lt;/li&gt;
&lt;li&gt;测试ZooKeeper服务器：这是用于测试ZooKeeper服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Curator客户端连接ZooKeeper服务器的&lt;code&gt;MyCuratorClient.java&lt;/code&gt;的代码片段如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void myCuratorClient() throws Exception
{
  CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null,new RetryOneTime(1));
  client.start();
  try
  {
    client.blockUntilConnectedOrTimedOut();
    String path = client.getZooKeeper().create(&quot;/test_znode&quot;, &quot;&quot;.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
  }
  finally
  {
    client.close();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CuratorZooKeeperClient&lt;/code&gt;构造方法用于连接到ZooKeeper服务器。 它需要连接字符串或ZooKeeper主机端口对列表，会话和连接超时时间，可选的观察器对象以及要使用的重试策略。 重试策略是客户端在重试连接时尝试各种重试机制的机制。在前面的例子中，使用了一个客户端只会重试一次的策略。&lt;/p&gt;
&lt;p&gt;Curator客户端支持以下重试策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BoundedExponentialBackoffRetry：通过增加重试之间的休眠时间直到最大上限重试指定的次数&lt;/li&gt;
&lt;li&gt;ExponentialBackoffRetry：通过增加重试之间的休眠时间来重试指定的次数&lt;/li&gt;
&lt;li&gt;RetryNTimes：重试n次&lt;/li&gt;
&lt;li&gt;RetryOneTime：只重试一次&lt;/li&gt;
&lt;li&gt;RetryUntilElapsed：一直重试，直到超过指定时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一旦客户端启动，&lt;code&gt;blockUntilConnectedOrTimedOut&lt;/code&gt;方法直到ZooKeeper连接服务器成功或者连接超时。连接成功之后，创建&lt;code&gt;/testznode&lt;/code&gt;的znode。&lt;code&gt;getZooKeeper()&lt;/code&gt;方法将连接的实例返回给托管的ZooKeeper服务器。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Note&lt;br/&gt;Curator API文档可在http://curator.apache.org/apidocs/index.html察看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Curator客户端是一个低层次的API，它提供了对管理员客户端API的抽象。开发人员应该使用Curator框架，而不是直接在他们的应用程序中使用&lt;code&gt;CuratorZookeeperClient&lt;/code&gt;类作为最佳实践。&lt;/p&gt;
&lt;h3 id=&quot;三-curator框架&quot;&gt;三 Curator框架&lt;/h3&gt;
&lt;p&gt;Curator框架（org.apache.curator.framework）是一个高层次的API，很大程度上简化了ZooKeeper的使用。 它提供的一些功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动连接管理：此功能自动且透明地处理客户端需要重新建立与ZooKeeper服务器的连接和/或重试操作的场景。&lt;/li&gt;
&lt;li&gt;简单而灵活的API：使用一组新式且流畅的接口来应用ZooKeeper原始的API。&lt;/li&gt;
&lt;li&gt;Recipe：这个功能实现了常见的ZooKeeper Recipe。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;CuratorFramework&lt;/code&gt;使用&lt;code&gt;CuratorFrameworkFactory&lt;/code&gt;进行分配。 它提供了工厂方法以及构造器创建实例。&lt;code&gt;CuratorFramework&lt;/code&gt;实例完全是线程安全的。在使用&lt;code&gt;CuratorFramework&lt;/code&gt;开发应用程序时，开发人员应该为每个ZooKeeper集群创建和共享一个&lt;code&gt;CuratorFramework&lt;/code&gt;实例。&lt;code&gt;CuratorFramework&lt;/code&gt;使用fluent风格接口。&lt;/p&gt;
&lt;p&gt;以下展示的是ZooKeeper客户端使用&lt;code&gt;CuratorFramework&lt;/code&gt;的代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void myCuratorFrameworkClient()
throws Exception
{
  CuratorFramework client =
  CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));
  client.start();
  try
  {
    String path = client.create().withMode(
    CreateMode.PERSISTENT).forPath(
    &quot;/test_znode&quot;, &quot;&quot;.getBytes());
  }
  finally
  {
    client.close();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;newClient()&lt;/code&gt;工厂方法创建一个新的客户端实例，默认会话超时和默认连接超时。 它需要一个连接字符串，是ZooKeeper主机-端口对列表和要使用的重试策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CuratorFramework&lt;/code&gt;有一个命名空间的概念。 通过这个，可以在使用构造器方法创建&lt;code&gt;CuratorFramework&lt;/code&gt;实例时设置命名空间。 当其中一个API被调用时，该框架将该命名空间预加载到所有路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();
CuratorFramework client = builder.connectString (server.getConnectString()).namespace(&quot;MyApp&quot;).retryPolicy(new RetryOneTime(1)).build();
client.create().forPath(&quot;/test_znode&quot;, data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，尽管znode的名称被指定为&lt;code&gt;/test_znode&lt;/code&gt;，但是创建的实际znode是&lt;code&gt;/MyApp/test_znode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Curator框架还提供了一个名为&lt;code&gt;CuratorTempFramework&lt;/code&gt;的有限功能框架接口，用于通过不可靠的网络（如WAN）进行临时连接。 在这个框架中，如果会话保持空闲一段时间，ZooKeeper连接将被关闭。&lt;/p&gt;
&lt;h3 id=&quot;四-curator-recipe&quot;&gt;四 Curator recipe&lt;/h3&gt;
&lt;p&gt;Curator为ZooKeeper提供了一系列随时可用的recipe。 Curator实现的recipe的详细列表和描述可以从http://curator.apache.org/curator-recipes/index.html的项目页面中获取。&lt;/p&gt;
&lt;p&gt;在这里，将简略地介绍一下ZooKeeper的recipe：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;领导者选举：Curator为领导选举提供了两种算法：领导者锁定（leader latch）和领导者选择（ leader selector）。两种算法在连接到Zookeeper集群的多个竞争者中选择一个“领导者”。&lt;br/&gt;在领导者锁定中，如果一组n个参与者与竞争领导，则将n个参与者中的一个随机分配为领导，而在领导选择中，按照到达该Zookeeper服务器的请求的顺序来选择领导。 当领导者解除领导时，选择集群中的n个参与者的另一个竞争者。&lt;/li&gt;
&lt;li&gt;锁：Curator实现以下不同类型的分布式锁：
&lt;ul&gt;&lt;li&gt;共享重入锁：这种类型的锁提供全局同步的全分布锁。&lt;/li&gt;
&lt;li&gt;共享锁：这是非重入共享重入锁。&lt;/li&gt;
&lt;li&gt;共享重入读/写锁：这是一个可跨JVM使用的重入读/写互斥锁。&lt;/li&gt;
&lt;li&gt;共享信号量：这是一个计数信号量（semaphore），可以跨JVM使用。&lt;/li&gt;
&lt;li&gt;多锁共享：这是用来管理多个锁作为一个单一的实体。 &lt;code&gt;acquire()&lt;/code&gt;调用获取所有的锁。 如果呼叫失败，所有获得的路径被释放。 &lt;code&gt;release()&lt;/code&gt;调用释放所有托管的锁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;屏障（Barrier）：这是屏障和双重屏障的具体实现。&lt;/li&gt;
&lt;li&gt;计数器：提供了一种机制来管理共享计数器的共享整数。它还给出了分布式原子增量的分布式原子长整型，分布式原子整型和分布式原子值的机制。&lt;/li&gt;
&lt;li&gt;缓存：缓存是通过路径缓存，节点缓存和树缓存recipe实现的，分别保存ZK路径的znode，本地缓存节点和所有本地缓存的子节点的状态变化数据。&lt;/li&gt;
&lt;li&gt;队列：这提供了分布式队列实现。 支持以下不同类型的队列：
&lt;ul&gt;&lt;li&gt;分布式队列：这是一个简单的分布式队列，其中放入队列中的条目是在FIFO中排序的。&lt;/li&gt;
&lt;li&gt;分布式ID队列：这是一个分布式队列的版本，允许一些标识符与队列项相关联。&lt;/li&gt;
&lt;li&gt;分布式优先级队列:这是ZooKeeper的分布式优先级队列的实现。在内部，它使用一个分布式队列，其中可以将优先级指定给项目。&lt;/li&gt;
&lt;li&gt;分布式延迟队列：这是使用时间作为优先级的分布式优先级队列的变体。当将条目添加到队列时，会给出一个延迟值。直到超过延迟时间，该项目将被发送给消费者。&lt;/li&gt;
&lt;li&gt;简单的分布式队列：这是ZooKeeper分布式&lt;code&gt;org.apache.zookeeper.recipes.queue.DistributedQueue&lt;/code&gt;队列的一部分替代实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;节点：这提供了一个persistent ephemeral节点的recipe；这是一个ephemeral的节点，即使在连接和会话中断的情况下也会试图保持在ZooKeeper中。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;五-curator实用程序&quot;&gt;五 Curator实用程序&lt;/h3&gt;
&lt;p&gt;Curator类库也为ZooKeeper提供了一些有用的工具。 其中一些如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Test server：这是一个可用于本地进程ZooKeeper服务器的测试&lt;/li&gt;
&lt;li&gt;Test cluster：这是一个内部运行的用于ZooKeeper服务器ensemble的测试&lt;/li&gt;
&lt;li&gt;ZKPaths：提供了各种使用ZooKeeper znode路径的静态方法&lt;/li&gt;
&lt;li&gt;EnsurePath：确保在使用之前创建特定znode路径的实用程序&lt;/li&gt;
&lt;li&gt;BlockingQueueConsumer：一个类似于Java中的&lt;code&gt;BlockingQueue&lt;/code&gt;的队列消费者&lt;/li&gt;
&lt;li&gt;Reaper：删除没有子节点的路径和没有数据的节点的实用程序&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;六-curator扩展&quot;&gt;六 Curator扩展&lt;/h3&gt;
&lt;p&gt;Curator扩展包除了包含在recipe包中那些外，还包括额外的recipe。 扩展包中的recipe具有&lt;code&gt;curator-x-name&lt;/code&gt;的命名约定。&lt;/p&gt;
&lt;p&gt;Curator目前提供以下扩展功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Service discovery：这是一个使用ZooKeeper作为服务发现机制的系统。&lt;/li&gt;
&lt;li&gt;Service discovery server：这是一个使用REST服务进行非Java和遗留程序的Curator服务发现。 它公开RESTful Web服务来注册，删除和查询服务。&lt;/li&gt;
&lt;li&gt;Curator RPC proxy：该模块实现了一个代理，将非Java环境与Curator框架和recipe桥接在一起。 它使用Apache Thrift，使大量的语言和环境使用Curator的功能，并统一ZooKeeper跨语言/环境的用法。&lt;/li&gt;
&lt;li&gt;ZKClient bridge：这个扩展是Curator和ZKClient之间的桥梁（&lt;a href=&quot;https://github.com/sgroschupf/zkclient&quot; class=&quot;uri&quot;&gt;https://github.com/sgroschupf/zkclient&lt;/a&gt;）。 使用ZKClient编写的应用程序在不改变现有代码的情况下使用Curator类库会非常有用。 ZKClient bridge不作为Curator分发的一部分进行打包。 它可以在它自己的Maven中心存储库中的&lt;code&gt;curator-x-zkclient-bridge&lt;/code&gt;中找到。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到目前为止，我们已经了解Curator类库及其各种组件。Curator为ZooKeeper API实现了一个非常好的，可靠的扩展，将ZooKeeper的许多复杂性抽象出来。 强烈建议开发人员使用Curator在Java语言的ZooKeeper开发分布式应用程序。 不仅如此，Curator的强大功能也可以从Java以外的语言编写的应用程序中使用。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 16:05:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8007605.html</dc:identifier>
</item>
<item>
<title>JAVA基础-JDBC二（常用的开源工具） - 阿拉巴洞</title>
<link>http://www.cnblogs.com/0813lichenyu/p/8007522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0813lichenyu/p/8007522.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;　　在实际的开发应用中，我们常常会对数据库进行大量的高并发的访问，而最原始的连接和操作方式并不能满足这种大量的访问&lt;br/&gt;，程序员为了追求更方便、更快捷、更科学安全的开发。第三方的工具类和Dao层的框架就应运而生了。DBCP连接池、和C3P0连&lt;br/&gt;接池就是2个常见的开源数据库连接池。&lt;br/&gt;　　在与数据库进行交互的过程中，获得连接”和“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况&lt;br/&gt;我们采用连接池技术，来共享连接Connection。这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池。用的&lt;br/&gt;时候从连接池里拿出来，用完了在给他放回去，下次使用时还可以接着用。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1234932/201712/1234932-20171208231956577-1590173180.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　同数据库的链接规范（JDBC）一样,java为数据库连接池也提供了一套规范（接口）- javax.sql.DataSource，各个厂商需要&lt;br/&gt;让自己的连接池实现这个接口。这样就方便了应用程序的扩展和我们的使用。&lt;/p&gt;
&lt;h2&gt;（一）DBCP连接池&lt;/h2&gt;
&lt;p&gt;　　DBCP连接池他是一个开源的连接池，属于Apache家族的一员，为Tomcat的内置连接池（自己的土，自己的地...）&lt;br/&gt;1、导入炸包&lt;br/&gt;　　使用第三方工具类的第一件事就是导入jar包，然后Build Patch一下，为了方便jar包的管理（另一方面满足于强迫症患者的&lt;br/&gt;整理欲望）一般都在工程下新建一个lib文件夹用来存放炸包。&lt;br/&gt;　　需要导入的jar包：&lt;br/&gt;　　* commons-dbcp-1.4.jar&lt;br/&gt;　　* commons-pool-1.5.6.jar&lt;/p&gt;
&lt;h2&gt;2、DBCP连接池的使用&lt;/h2&gt;
&lt;p&gt;　　连接数据库的操作是一个频繁使用，代码重复的操作，可以将其抽取成一个工具类。&lt;br/&gt;　　Java为数据库连接池也提供了一套规范接口：DataSource，它是java中提供的连接池，作为 DriverManager 工具的替代项。&lt;br/&gt;而DBCP包则提供了DataSource接口的实现类 - BasicDataSource类。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;  栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JdbcUtils {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个连接池&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BasicDataSource bd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicDataSource();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具类，私有他的无参构造&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcUtils() {
&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用静态代码块进行连接池的属性配置 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态代码块是随着类的加载而加载的且只加载一次（节省资源）&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
* 必须设置的项
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置mySQL的驱动&lt;/span&gt;
bd.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要连接数据库的URL&lt;/span&gt;
bd.setUrl(&quot;jdbc:mysql://localhost:3306/mydb&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置用户名&lt;/span&gt;
bd.setUsername(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据库密码&lt;/span&gt;
bd.setPassword(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
* 选择设置的项，不设置的话会有默认值跟着
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化连接数&lt;/span&gt;
bd.setInitialSize(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大连接数&lt;/span&gt;
bd.setMaxActive(15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大空闲连接数&lt;/span&gt;
bd.setMaxIdle(6&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小空闲连接数&lt;/span&gt;
bd.setMinIdle(3&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 获取连接池对象
* &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; bd 连接池
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DataSource getDataSource() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bd;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;（二）C3P0连接池&lt;/h2&gt;
&lt;p&gt;　　C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有&lt;br/&gt;Hibernate，Spring等。（百度百科）&lt;br/&gt;　　C3P0连接池有自动回收空闲连接的功能，而DBCP没有自动回收空闲连接的功能。&lt;br/&gt;1、导入jar包&lt;br/&gt;　　同DBCP的使用步骤一样，第一步要导入相关的jar包：&lt;br/&gt;　　c3p0-0.9.1.2.jar&lt;br/&gt;2、C3P0连接池的使用&lt;br/&gt;　　通过查看帮助文档（doc目录下的index.html文件里边有个快速入门）发现C3P0可以通过手动或者配置文件的方式使用。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; 　　 * 通过手动进行配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得C3P0连接池对象&lt;/span&gt;
ComboPooledDataSource source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ComboPooledDataSource();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置驱动&lt;/span&gt;
source.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置连接库的路径&lt;/span&gt;
source.setJdbcUrl(&quot;jdbc:mysql:///mydb&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置用户名&lt;/span&gt;
source.setUser(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置密码&lt;/span&gt;
source.setPassword(&quot;root&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过连接池创建一个QueryRunner对象&lt;/span&gt;
QueryRunner runner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(source);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试&lt;/span&gt;
String sql = &quot;SELECT * FROM users&quot;&lt;span&gt;;
List&lt;/span&gt;&amp;lt;Object[]&amp;gt; list = runner.query(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayListHandler());
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object[] objects : list) {
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object object : objects) {
System.out.print(object &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
}
System.out.println();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　* 通过配置文件进行配置&lt;br/&gt;　　C3P0连接池支持.xml和属性文件.properties的文件配置，当然了他对其配置文件的名字和里边的文件也有一定的要求（搞一个别&lt;br/&gt;的名他就不认识了），XML配置文件的名字一定是c3p0-config.xml，属性配置文件的名字一定是c3p0.properties.默认情况下C3P0连接&lt;br/&gt;池就会找类加载路径下的c3p0-config.xml进行解析。c3p0-config.xml配置文件除了一些链接数据库的一些必要属性外也可以配置一些&lt;br/&gt;连接池其他的属性：最小池里的数量，最大池里的数量等。具体的属性配置可以百度或者阅读开发文档。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　栗子：&lt;br/&gt;  * c3p0-config.xml配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c3p0-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql:///mydb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;default-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;c3p0-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;  * C3P0的工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; C3p0Utils {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个c3p0连接池&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ComboPooledDataSource source;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个连接对象&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Connection connection;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; C3p0Utils() {
&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化连接池&lt;/span&gt;
source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ComboPooledDataSource();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得一个连接&lt;/span&gt;
connection =&lt;span&gt; source.getConnection();
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;e.printStackTrace();
}
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Connection getConnection() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过代码演示可以看到通过配置文件的方式还是非常方便的，后期维护的话只要改相关的配置文件就可以了，xml作为配置文件便于&lt;br/&gt;我们的阅读，所以推荐使用c3p0-config.xml配置文件。&lt;/p&gt;

&lt;p&gt;　　使用原生的JDBC进行开发，你会发现代码冗余过多，使用麻烦，极度不爽。而工具类的出现就是为了简化我们的开发。DBUtils是&lt;br/&gt;apache commons组件一个成员，使用DBUtils工具类首先要导入相关的jar包 - commons-dbutils-1.6.jar。&lt;br/&gt;　　DBUtils封装并简化了JDBC操作，减少了相关代码的书写、它一共有3个核心的部分组成：&lt;br/&gt;　　* QueryRunner提供对sql语句操作的API。&lt;br/&gt;　　* ResultSetHandler接口提供了执行完sql语句后怎样封装结果集。&lt;br/&gt;　　* DbUtils工具类提供了关闭相关资源和处理事物的方法。&lt;br/&gt;1、QueryRunner核心类&lt;br/&gt;　　* new QueryRunner() ，无参构造，使用无参构造时，调用update，query方法时需要传入Connection对象&lt;br/&gt;　　* update(Connection conn, String sql, Object... params) ，用来完成表数据的增加、删除、更新操作。&lt;br/&gt;　　* query(Connection conn, String sql, ResultSetHandler&amp;lt;T&amp;gt; rsh, Object... params) ，用来完成表数据的查询操作。&lt;br/&gt;------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;br/&gt;　　* new QueryRunner(DataSource ds) ，带参构造，使用带参构造时调用update，query方法无需要传入Connection对象&lt;br/&gt;　　* update(String sql, Object... params) ，用来完成表数据的增加、删除、更新操作。&lt;br/&gt;　　* query(String sql, ResultSetHandler&amp;lt;T&amp;gt; rsh, Object... params) ，用来完成表数据的查询操作。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　栗子：&lt;br/&gt;  * 无参构造的update方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 增加操作
* &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SQLException
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; method01() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过工具类获得连接&lt;/span&gt;
Connection connection =&lt;span&gt; JdbcUtilsConfig.getConnection();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得QueryRunner对象&lt;/span&gt;
QueryRunner runner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编写sql语句&lt;/span&gt;
String insert = &quot;INSERT INTO sort(sname,sprice,sdesc) VALUES(?,?,?)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行update方法，也可以将数据存到Object数组里然后传入数组，返回值为影响的行数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; update = runner.update(connection, insert, &quot;家具&quot;, 1000, &quot;很好用&quot;&lt;span&gt;);
System.out.println(update);
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 更新操作
* 
* &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SQLException
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; method02() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过工具类获得连接&lt;/span&gt;
Connection connection =&lt;span&gt; JdbcUtilsConfig.getConnection();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得QueryRunner对象&lt;/span&gt;
QueryRunner runner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编写sql语句&lt;/span&gt;
String s = &quot;UPDATE sort SET sname=?,sprice=?,sdesc=? WHERE sid=4&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行update方法&lt;/span&gt;
runner.update(connection, s, &quot;花卉&quot;, 100, &quot;买给你爱的人&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;安静的关闭&lt;/span&gt;
&lt;span&gt;DbUtils.closeQuietly(connection);
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 删除操作
* 
* &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SQLException
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; method03() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过工具类获得连接&lt;/span&gt;
Connection connection =&lt;span&gt; JdbcUtilsConfig.getConnection();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个QueryRunner对象，用来完成SQL语句的执行&lt;/span&gt;
QueryRunner qr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行SQL语句&lt;/span&gt;
String sql = &quot;DELETE FROM zhangwu WHERE name = ?&quot;&lt;span&gt;;
Object[] params &lt;/span&gt;= { &quot;股票收入&quot;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; line =&lt;span&gt; qr.update(connection, sql, params);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结果集的处理，影响的行数&lt;/span&gt;
System.out.println(&quot;line=&quot; +&lt;span&gt; line);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　* 有参构造的query方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过工具类获得连接池对象&lt;/span&gt;
DataSource dataSource =&lt;span&gt; C3p0Utils.getDataSource();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过连接池创建一个QueryRunner对象&lt;/span&gt;
QueryRunner runner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(dataSource);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编写sql语句&lt;/span&gt;
String sql = &quot;SELECT * FROM users&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行query方法传入ArrayListHandler返回集合&lt;/span&gt;
List&amp;lt;Object[]&amp;gt; list = runner.query(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayListHandler());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历集合&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object[] objects : list) {
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object object : objects) {
System.out.print(object &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
}
System.out.println();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、ResultSetHandler结果集处理类&lt;br/&gt;　　* ArrayHandler 将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录的值。&lt;br/&gt;　　* ArrayListHandler 将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。&lt;br/&gt;　　* BeanHandler 将结果集中第一条记录封装到一个指定的javaBean中。&lt;br/&gt;　　* BeanListHandler 将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中。&lt;br/&gt;　　* ColumnListHandler 将结果集中指定的列的字段值，封装到一个List集合中。&lt;br/&gt;　　* ScalarHandler 它是用于单数据。例如sql中的聚合函数SUM(),Count()等。&lt;br/&gt;　　* MapHandler 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据，可以配合工具类&lt;br/&gt;BeanUtils.populate(Bean bean, Map map);一起使用方便数据的封装。&lt;br/&gt;　　* MapListHandler 将结果集第一行封装到Map集合中,Key 列名, Value 该列数据,Map集合存储到List集合。&lt;/p&gt;&lt;p&gt;　　常用Handler举例:&lt;br/&gt;  *BeanHandler的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品详情查询
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pid
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; product
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Product findByPid(String pid) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过连接池创建QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3p0Utils.getDataSourse());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入的商品ID编写sql语句&lt;/span&gt;
        String sql = &quot;SELECT * FROM product WHERE pid=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入sql语句和BeanHandler结果集返回商品Bean&lt;/span&gt;
        Product product = queryRunner.query(sql, &lt;span&gt;new&lt;/span&gt; BeanHandler&amp;lt;Product&amp;gt;(Product.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;), pid);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  * ScalarHandler的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 商品总数查询
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; totalCount
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer findAdmintotalCount() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        QueryRunner queryRunner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3p0Utils.getDataSourse());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pflag字段为是否下架&lt;/span&gt;
        String sql = &quot;SELECT COUNT(*) FROM product WHERE pflag=?&quot;&lt;span&gt;;
        Long totalCount &lt;/span&gt;= (Long) queryRunner.query(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScalarHandler(),Product.UN_FLAG);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Long转换成Integer类型返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalCount.intValue();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  * BeanListHandler的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据类别查询商品
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cid 商品ID
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; beginPage 起始页
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pageSize 每页显示的条数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; list
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Product&amp;gt; findPageByCid(String cid, Integer beginPage, Integer pageSize) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        QueryRunner queryRunner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryRunner(C3p0Utils.getDataSourse());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分页查询&lt;/span&gt;
        String sql = &quot;SELECT * FROM product WHERE cid=? AND pflag=? LIMIT ?,?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BeanListHandler里泛型要写你查询实体Bean类型，传入参数为Bean.class&lt;/span&gt;
        List&amp;lt;Product&amp;gt; list = queryRunner.query(sql, &lt;span&gt;new&lt;/span&gt; BeanListHandler&amp;lt;Product&amp;gt;(Product.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;), cid, Product.UN_FLAG,
                beginPage, pageSize);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回结合&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、DbUtils工具类&lt;br/&gt;　　此类提供了关闭相关资源和处理事物的方法：&lt;br/&gt;　　* DbUtils.closeQuietly() 安静的关闭资源。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 15:39:00 +0000</pubDate>
<dc:creator>阿拉巴洞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0813lichenyu/p/8007522.html</dc:identifier>
</item>
<item>
<title>【MySQL疑难杂症】如何将树形结构存储在数据库中（方案一、Adjacency List） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/7992709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/7992709.html</guid>
<description>&lt;p&gt;　　今天来看看一个比较头疼的问题，如何在数据库中存储树形结构呢？&lt;/p&gt;
&lt;p&gt;　　像mysql这样的关系型数据库，比较适合存储一些类似表格的扁平化数据，但是遇到像树形结构这样有深度的人，就很难驾驭了。&lt;/p&gt;
&lt;p&gt;　　举个栗子：现在有一个要存储一下公司的人员结构，大致层次结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171208075002066-467711169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（画个图真不容易。。）&lt;/p&gt;
&lt;p&gt;　　那么怎么存储这个结构？并且要获取以下信息：&lt;/p&gt;
&lt;p&gt;　　1.查询小天的直接上司。&lt;/p&gt;
&lt;p&gt;　　2.查询老宋管理下的直属员工。&lt;/p&gt;
&lt;p&gt;　　3.查询小天的所有上司。&lt;/p&gt;
&lt;p&gt;　　4.查询老王管理的所有员工。&lt;/p&gt;

&lt;p&gt;方案一、(Adjacency List)只存储当前节点的父节点信息。&lt;/p&gt;
&lt;p&gt;　　CREATE TABLE Employees(&lt;br/&gt;　　eid int,&lt;br/&gt;　　ename VARCHAR(100),&lt;br/&gt;        position VARCHAR(100),&lt;br/&gt;　　parent_id int&lt;br/&gt;　　)&lt;/p&gt;
&lt;p&gt;　　记录信息简单粗暴，那么现在存储一下这个结构信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171206122527238-22221215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好的，现在开始进入回答环节：&lt;/p&gt;
&lt;p&gt;　　1.查询小天的直接上司：&lt;/p&gt;
&lt;p&gt; 　　SELECT e2.eid,e2.ename FROM employees e1,employees e2 WHERE e1.parent_id=e2.eid AND e1.ename='小天';&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171206123531800-1704084680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.查询老宋管理下的直属员工：&lt;/p&gt;
&lt;p&gt;　　SELECT e1.eid,e1.ename FROM employees e1,employees e2 WHERE e1.parent_id=e2.eid AND e2.ename='老宋';&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171206134257675-1536893060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.查询小天的所有上司。&lt;/p&gt;
&lt;p&gt;　　这里肯定没法直接查，只能用循环进行循环查询，先查直接上司，再查直接上司的直接上司，依次循环，这样麻烦的事情，还是得先建立一个存储过程：&lt;/p&gt;
&lt;p&gt;　　睁大眼睛看仔细了，接下来是骚操作环节：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
CREATE DEFINER=`root`@`localhost` FUNCTION `getSuperiors`(`uid` &lt;span&gt;int&lt;/span&gt;) RETURNS varchar(1000&lt;span&gt;) CHARSET gb2312
BEGIN
    DECLARE superiors VARCHAR(&lt;/span&gt;1000) DEFAULT ''&lt;span&gt;;
    DECLARE sTemp INTEGER DEFAULT uid;
    DECLARE tmpName VARCHAR(&lt;/span&gt;20&lt;span&gt;);

    WHILE (sTemp&lt;/span&gt;&amp;gt;0&lt;span&gt;) DO
        SELECT parent_id into sTemp FROM employees where eid &lt;/span&gt;=&lt;span&gt; sTemp;
        SELECT ename into tmpName FROM employees where eid &lt;/span&gt;=&lt;span&gt; sTemp;
        IF(sTemp&lt;/span&gt;&amp;gt;0&lt;span&gt;)THEN
            SET superiors &lt;/span&gt;= concat(tmpName,','&lt;span&gt;,superiors);
        END IF;
    END WHILE;
        SET superiors &lt;/span&gt;= LEFT(superiors,CHARACTER_LENGTH(superiors)-1&lt;span&gt;);
    RETURN superiors;
END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一段存储过程可以查询子节点的所有父节点，来试验一下　&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171208212316062-363509535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好的，骚操作完成。&lt;/p&gt;
&lt;p&gt;　　显然，这样。获取子节点的全部父节点的时候很麻烦。。&lt;/p&gt;
&lt;p&gt;　　4.查询老王管理的所有员工。&lt;/p&gt;
&lt;p&gt;　　思路如下：先获取所有父节点为老王id的员工id，然后将员工姓名加入结果列表里，在调用一个神奇的查找函数，即可进行神奇的查找：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE DEFINER=`root`@`localhost` FUNCTION `getSubordinate`(`uid` int) RETURNS varchar(2000) CHARSET gb2312&lt;br/&gt;BEGIN   &lt;br/&gt;DECLARE str varchar(1000);  &lt;br/&gt;DECLARE cid varchar(100);&lt;br/&gt;DECLARE result VARCHAR(1000);&lt;br/&gt;DECLARE tmpName VARCHAR(100);&lt;br/&gt;SET str = '$';   &lt;br/&gt;SET cid = CAST(uid as char(10));   &lt;br/&gt;WHILE cid is not null DO   &lt;br/&gt;SET str = concat(str, ',', cid); &lt;br/&gt;SELECT group_concat(eid) INTO cid FROM employees where FIND_IN_SET(parent_id,cid);         &lt;br/&gt;END WHILE;&lt;br/&gt;SELECT GROUP_CONCAT(ename) INTO result FROM employees WHERE FIND_IN_SET(parent_id,str);&lt;br/&gt;RETURN result;   &lt;br/&gt;END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看神奇的结果：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1043143/201712/1043143-20171208215809609-35443566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然搞出来了，但说实话，真是不容易。。。&lt;/p&gt;
&lt;p&gt;　　这种方法的优点是存储的信息少，查直接上司和直接下属的时候很方便，缺点是多级查询的时候很费劲。所以当只需要用到直接上下级关系的时候，用这种方法还是不错的，可以节省很多空间。后续还会介绍其它存储方案，并没有绝对的优劣之分，适用场合不同而已。&lt;/p&gt;
&lt;p&gt;　　本篇至此告一段落，欢迎大家继续关注。&lt;/p&gt;

</description>
<pubDate>Fri, 08 Dec 2017 15:34:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/7992709.html</dc:identifier>
</item>
<item>
<title>Python测试开发之函数 - 大王king</title>
<link>http://www.cnblogs.com/bettywang/p/8007482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bettywang/p/8007482.html</guid>
<description>&lt;p&gt;对于初学者而言，感觉函数还是不是很好理解，尤其是当写一个脚本，或者是写一个算法，认为可能for循环就已经可以解决的问题为什么还要用函数来实现呢？&lt;/p&gt;
&lt;p&gt;今天就来说一下函数的优点，其实函数的最大优点就是可重用，一个函数实现后可以被其他不同的脚本来调用，这也就是体现了代码的重用性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数的定义：def 函数名():，在定义函数时，一定要用关键字def开头，然后紧接着是函数名，括号里是要传的的参数，当然也可不传，最后面是个冒号：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　def add(x,y):&lt;/p&gt;
&lt;p&gt;　　　　    return x+y&lt;/p&gt;
&lt;p&gt;　　这就是一个最简单的函数&lt;/p&gt;
&lt;p&gt;　　2.函数的返回值：Python中自定义的函数如果有return，则返回实际的结果，如果没有返回值，则返回None，这是Python与其他语言的区别之一&lt;/p&gt;
&lt;p&gt;　　3.函数的调用：在定义好一个函数后，如果要实现函数的功能，一定要对其进行引用，不然函数体是不会被执行的，调用的方法也很简单，就是函数名和需要的参数即可&lt;/p&gt;
&lt;p&gt;　　例如上边add函数的调用： add(2,3)即可返回5&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208224925312-1449265746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：此处如果传入两个字符串也是OK的，这也是Python的特殊之处，他会根据传入的值来进行相应操作，如果传入的是两个数字，则进行相加，如果是两个字符串则进行拼接，但是此处必须传入的类型一致，否则会报错，所以可以根据你的需要进行处理，如果要做特定的实现可以用isinstance来判断一下类型，来达到自己想要的效果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208225224327-109737613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208225430952-2140282177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.函数的传参：函数的参数分为按值传递和按地址传递。按值传递是将不可变的参数传递给函数，按地址传递是将可变的参数传递给函数。此处的可变参数与不可变参数是相对内存地址而言的，如果传入的是字符串、元祖、数字，是不可变对象，就是按值传递，为什么说是不可变的，例如如果将a=1这样一个变量传递给函数，那么就是说将1的内存地址传给函数，那么计算机给1分配过内存地址后就不会在变化，所以说在函数体内对a做的任何操作都不会影响函数体外a的值，来看一个例子就会比较好理解了：&lt;/p&gt;
&lt;p&gt;a =1&lt;/p&gt;
&lt;p&gt;def print_sth(s):&lt;br/&gt;s=s+1&lt;br/&gt;return s&lt;/p&gt;
&lt;p&gt;print print_sth(a)&lt;br/&gt;print a&lt;/p&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208230244109-1571135690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们来看一下原理：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208230358171-1568692633.png&quot; alt=&quot;&quot;/&gt;这就是按值传递的原理，当函数体内对a进行加1操作，实际是指向另一个内存地址了，用id()就可以查看内存地址&lt;/p&gt;
&lt;p&gt;　　5.看了按值传递的原理，按引用传递应该就好理解了，按引用传递就是传递一些可变参数，例如list、dict等，先来看一下他们的内存地址的变化：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208230734062-724908715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到当你在对一个list进行操作时，它指向的内存地址实际是没有变化的，所以说当传递可变参数时，函数体内对变量的操作是会影响函数体外的变量的，看一个例子就更明白了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208230959624-1210886023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在对函数的按值传递和按引用传递参数应该非常了解了吧。&lt;/p&gt;
&lt;p&gt;　　6.可变参数的表示：*args表示传入的是一个元祖，**args表示传入的是一个字典，在实际使用中当不确定要传入多少个参数时，就可以使用这种方法：&lt;/p&gt;
&lt;p&gt;　　def func(a,*args):&lt;/p&gt;
&lt;p&gt;　　　　for i in args:&lt;/p&gt;
&lt;p&gt;　　　　　　a +=i&lt;/p&gt;
&lt;p&gt;　　　　return a&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208231507077-419128949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　你会发现，你传递几个参数都不会出问题，这就是可变参数的好处，然后看一下**args吧：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/823210/201712/823210-20171208232056484-1211491551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　看完这些，你是否对函数有了很大理解，现在应该感觉函数可以实现很多你想要实现的功能吧，这可不仅仅是几个for循环就能实现的哦，赶快学学函数吧，这也是后面写好代码的基础。&lt;/p&gt;




</description>
<pubDate>Fri, 08 Dec 2017 15:26:00 +0000</pubDate>
<dc:creator>大王king</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bettywang/p/8007482.html</dc:identifier>
</item>
<item>
<title>利用python web框架django实现py-faster-rcnn demo实例 - JiangWu</title>
<link>http://www.cnblogs.com/deeplearning1314/p/8007300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deeplearning1314/p/8007300.html</guid>
<description>&lt;p&gt;&lt;strong&gt;操作系统、编程环境及其他：&lt;/strong&gt; window7  cpu  python2.7  pycharm5.0  django1.8x&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：本blog要解决的问题是利用Python的web框架，将faster-rcnn的demo程序以网页形式展现出来，简而言之是基于B-S架构的编程，直观地以网页形式展示目标检测的功能。由于本人才疏学浅，暂时未能习得Django精髓与Python编程精髓，虽然功能实现了，但以本人的要求来看，实现还是略为粗糙的，编程基本功正在加强中。这也是我一直追求的模样，我希望成为一个兼具理论和技能的研究生。本blog不具备较强的理论性，东拼西凑的Django上传、显示图片机制，以及一些为图省事拍脑袋想出的编程小技巧，但至少本blog具备较强的实践性。理论部分待我空下来了，系统学习Django框架后另行补充。我会回头来学好Django，大概是导师某天带着我去看一个老师写的Django工程，我被密密麻麻的代码震撼了，这大抵是原因。最后，如果读者在复现实验时认为本文有疏漏不对的地方，请在博客园私信联系我改正，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感谢&lt;/strong&gt;：特别感谢负责的导师，本人陋习太多，正在改正，比如拖延症、强迫症···如果不是导师一次次催我，一次次耐心地为我讲解代码、工作机制，以及上面提到的带着我求助Django编程方面比较专业的老师，我可能要花更久的时间来做好这项小任务。真诚地感谢这种督促，我会更加努力，少说话，多做事，丰富个人的学习和生活。除此之外，我还要感谢同济大学的俊杰兄，在python编程方面给了我很多指导，甚至为一个未曾谋面的我请教其师兄相关Django的问题。只记得那天完成这个小任务，我内心很有成就感，慢慢加油吧。毕竟是个小任务，不在此一一感谢那些在乎我关心我的人了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;上一篇blog被多个技术网站转载并且未署名和来源，部分评论我看不到恢复不了，如有问题交流请在博客园上评论区联系我，如果看到了我一般会回，共同提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不说太多废话了，切入正题！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要完成上述提及的小任务，主要需要以下几个步骤：Django环境的搭建、弄懂Django文件上传机制、对faster rcnn demo程序的适应性修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在讲解前，首先看下本文任务实现的效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先启动服务器，返回一个网址： &lt;a href=&quot;http://127.0.0.1:8000/&quot;&gt;http://127.0.0.1:8000/&lt;/a&gt; 即本主机地址 （模拟网页，本机同时是服务器、后台和用户）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215605187-2128337066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们可以登录上面给出的地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215619577-1194969366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们输入相关内容，点击ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215635406-1816249665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等待网页返回处理后的结果（实例图片是俺美丽的女朋友）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215657874-2097608135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到此时的后台程序是在执行相关代码的&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215711531-678809096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果看完了，接着我们开始介绍，如果想复现实验，请按本人写作顺序看懂后依次进行。&lt;/p&gt;

&lt;p&gt;一、Django环境的搭建&lt;/p&gt;
&lt;p&gt;提供一个网址： &lt;a href=&quot;https://code.ziqiangxuetang.com/django/django-tutorial.html&quot;&gt;https://code.ziqiangxuetang.com/django/django-tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以本人Windows7系统为例看Django环境搭建2.1.2部分应该就会了，建议选Django1.8版本便于学习，这个网址的作者也是这么建议的。&lt;/p&gt;
&lt;p&gt;建议自主学习本网址Django视图与网址部分，半小时就能理解。大致能对新建Django工程、工程目录下都有什么文件、以及主要的一些文件如views.py、urls.py的作用有个清晰的理解，这些内容还是静静地看这个网址的讲解，后面我也会提及一部分，但是为避免出错不会过分提及。以下是本人安装Django的笔记，大略可以参考一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215746468-1657327066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、本文Django工程上传文件机制&lt;/p&gt;
&lt;p&gt;参考blog链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/fnng/p/3740274.html&quot;&gt;http://www.cnblogs.com/fnng/p/3740274.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上述网址中是基于deepin linux 2013、python 2.7、Django 1.6.2环境来实现的，根据本人window7 Django1.8因此需要做部分修改，结合参考blog具体以下面所讲为主。&lt;/p&gt;
&lt;p&gt;（1）创建项目与应用&lt;/p&gt;
&lt;p&gt;这部分内容在”一”中所给网址中讲解的非常清楚，我的django工程地址：E:\deep learning\py-faster-rcnn-master\tools\，首先cmd模式下cd到你想放置的路径，然后输入django-admin.py startproject mysite2 创建一个名为mysite2的Django工程，接着cd到mysite2的路径   cd mysite2，在项目下创建一个disk应用   python manage.py startapp disk，这时，可以在相应位置看到新建的Django工程，以及可以看到类似于下面的Django工程目录结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215947015-1141841520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208215954812-1854176482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220005656-290381820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）设计model（数据库）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220035718-1575978291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面执行上传图片操作时，会将图片传至upload文件夹内。&lt;/p&gt;
&lt;p&gt;（3）数据库同步&lt;/p&gt;
&lt;p&gt;cmd模式下cd 到Django工程mysite2（第一级的mysite2）下，依次敲入以下命令（由于本人版本不同所以与上述blog中略有不同），按提示操作python manage.py  syncdb，python manage.py  makemigration，python manage.py  migrate，正常情况下，cmd窗口应该会显示以下内容：（忽略我这里设置的路径，我刚开始默认存在c盘的，为了方便工作我后来直接拷贝整个Django工程到e盘相关路径下也是能正常工作的）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220153781-439379734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时可以在mysite2中看到一些和数据库有关的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220208468-423983593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220218749-1097644393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）创建视图函数    按下面截图要求修改views.py视图函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220247968-1988993390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）创建模板文件&lt;/p&gt;
&lt;p&gt;先在mysite2/disk/目录下创建templates文件夹，接着在mysite2/disk/templates/目录下创建register.html 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220313343-485466393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220320781-1140547606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不用按参考blog中提到的设置模板路径，Django1.8版能够自动找到&lt;/p&gt;
&lt;p&gt;（6）设置URL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220353843-159665431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）启动服务&lt;/p&gt;
&lt;p&gt;Cmd模式下cd到Django工程mysite2（第一级mysite2）的路径，输入命令Python manage.py  runserver  启动服务器，有可能会抛出相应错误，具体解决办法见参考blog，正常成功情况下应显示如下界面，并能上传图片到自己新建的upload文件夹。(upload文件夹需要新建，路径参考下面截图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220428327-662513199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220434702-1454535346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220445218-431867047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，本文任务实现了一小部分，需要弄明白这里Django文件上传的机制。Django最主要的几个文件大概是urls.py、views.py、html、models.py文件，在这里我简要介绍一下上述代码的执行过程（读者可先不进行此步实验、文末我会给出完整的代码云盘链接）&lt;/p&gt;
&lt;p&gt;首先，我们来看urls.py文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220507249-439482762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重点看我标注的这一句，urls文件指明了当用户访问登录返回的网址时需要执行的函数，这句表示当用户访问&lt;a href=&quot;http://127.0.0.1:8000/&quot;&gt;http://127.0.0.1:8000/&lt;/a&gt; 时要执行views.py中定义的register函数&lt;/p&gt;
&lt;p&gt;接着我们看一下html文件内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220524968-134723487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学过html一些概念的人应该能读懂这段，但是这里有句{{uf.as_p}}让人很难理解意思，uf是建立的user数据库，具体理论我说不清，但是这里是填充一些内容的，怎么知道的呢？当显示登录界面时，请在浏览器工具栏—工具----查看源代码可以看到网页信息如下，比较上下区别，就可以弄懂啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220539187-136411124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接下来关注views.py视图函数，这里面定义了一些Django工程中的核心函数，我们后续也是要将demo代码添加进来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220602437-1147131675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里我主要想讲解一下这段代码的执行顺序，当我们输入网址登录网页时，这时request.method还不是post方式，所以执行的是else下的代码，返回了一个html文件，并且在原始文件中{{uf.as_p}}填充了uf的一些输入要求，比如type，这可以在上面的源文件中看到。render_to_response() 的第一个参数必须是要使用的模板名称。 如果要给定第二个参数，那么该参数必须是为该模板创建 Context 时所使用的字典。之后，当我们输入了username、选择的图片后点击OK，这时变成post方式，执行if语句，返回httpresponse对象，显示upload ok，这时文件夹upload里就会保存刚才上传的图片。至此upload的form表单方式上传文件机制介绍完了，实际上还有更简单的文件上传机制，比如文件流的方式，只是当时我没调通，所以没有细究。除此以外，将选择的图片经过demo处理后需要再在网页上显示处理结果，这里我投机取巧找到一个文件流的显示方式，具体见代码，返回了一个httpresponse对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220627906-1357247555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上只是为了讲解Django的文件上传显示机制，具体全部代码、代码执行过程以及本人投机取巧的地方将在后面代码注解中给出。&lt;/p&gt;
&lt;p&gt;三、本文faster rcnn demo程序的适应性局部修改与关键地方讲解&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;现在服务器、后台能够接受到用户传来的图片，所以我们很自然的想到下一步任务就是把&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;demo&lt;/span&gt;&lt;span&gt;的关键处理代码拷贝到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Django&lt;/span&gt;&lt;span&gt;工程下的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;views.py&lt;/span&gt;&lt;span&gt;文件。拷贝过来，当然需要修改一些地方，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;faster_rcnn&lt;/span&gt;&lt;span&gt;的模块调用要理顺。首先需要将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;E:\deep learning\py-faster-rcnn-master\tools&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;_init_paths.py&lt;/span&gt;&lt;span&gt;文件修改成如下图，并拷贝到如下路径，主要是为了使添加上述代码后的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;views.py&lt;/span&gt;&lt;span&gt;执行时能找到&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;faster_rcnn&lt;/span&gt;&lt;span&gt;的相关文件，为方便处理，我直接给出了相应模块、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;py&lt;/span&gt;&lt;span&gt;文件的完整路径。其中&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;osp.join&lt;/span&gt;&lt;span&gt;函数是个拼接路径函数，路径的正确格式也是我打断点调试才知道的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220852062-2028243122.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220901546-1286870550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，让我们来看最后的完整地views.py文件，具体代码关键注解部分请看文末给出的完整代码云盘链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220938671-1728121591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220946765-1352602609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208220955999-462256233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208221005031-1600577693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208221012327-1527406096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208221021765-881988911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1196287/201712/1196287-20171208221029437-1206738043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于views.py，我想在这里补充一下我投机取巧的地方，一是一些关键地方，比如模型文件、图片等的路径我直接给出了完整路径，并且代码修改的很粗糙。另外，利用form表单上传图片我在后台不知道如何取相应的图片，所以我采用的方法是：由于我知道图片会保存在upload文件夹里，每次将不同名字的图片保存后，我首先将图片改名成000001.jpg，这样就能被demo处理，处理完后生成test.png后清空upload文件夹里的图片，保存处理后的test.png显示在网页上。&lt;/p&gt;
&lt;p&gt;四、其他需要补充讲解的部分&lt;/p&gt;
&lt;p&gt;Django工程是可以在pycharm中打断点调试的！！！这大大方便了编程，我之前查了好久，然后被导师一查就查到了，不得不佩服啊！！！具体debug调试可参考blog：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Rocky_/p/6187275.html&quot;&gt;https://www.cnblogs.com/Rocky_/p/6187275.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在views.py打断点，用户在前端选择图片点ok后可以在pycharm中看到变量值。本文Django工程代码链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1sldYaWP&quot;&gt;https://pan.baidu.com/s/1sldYaWP&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;提取密码：y0os&lt;/p&gt;

&lt;p&gt;结语：写blog一为总结、二为让后人少走弯路，国内Django方面的知识貌似传播的不太成熟，很少有系统的讲解。如果读者觉得有疏漏的地方，麻烦在博客园下留言。如果觉得有用，请祝福本人及关心我的人快乐向上、家人健康、学习进步、生活愉快、恋情美满！！！加油！！！&lt;/p&gt;


</description>
<pubDate>Fri, 08 Dec 2017 14:14:00 +0000</pubDate>
<dc:creator>JiangWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deeplearning1314/p/8007300.html</dc:identifier>
</item>
<item>
<title>Serverless无服务应用架构纵横谈 - windfic</title>
<link>http://www.cnblogs.com/windfic/p/7941998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/windfic/p/7941998.html</guid>
<description>&lt;p&gt;&lt;span&gt;Serverless无服务应用架构纵横谈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、Serverless是啥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自从互联网兴起以来，Server就成了网络的核心部件。所以围绕Server的生意圈，也发展得如火如荼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从最早的电信托管，到虚拟机，到现在的Serverless，形成了几大阵容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、IaaS（基础设施即服务：Infrastructure as a Service）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、PaaS（平台即服务：Platform as a Service）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、SaaS（软件即服务：Software as a Service）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IaaS是包硬不包软，面对集成商，PaaS是包硬包软不包工，面对开发者，SaaS是全包，面对消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201712/569097-20171201133733727-522783597.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三大阵营都在不断演进中，互相取长补短，甚至模糊了彼此的界限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PaaS最新的发展就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、BaaS（后端即服务：Backend as a Service）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Faas（函数即服务：Functions as a Service）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两种架构被称为Severless&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;BaaS与FaaS这两种架构被称为Severless，并非对开发者而言，是对服务商而言，没有一直运行的定制服务存在，不占用服务商的计算资源。&lt;/span&gt;&lt;span&gt;同共享单车有些类似，是计算机分时租赁方式，按次按时计价。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BaaS并不存放客户代码，只提供通用的逻辑，产品的逻辑都需要在富客户端完成。&lt;/span&gt;&lt;span&gt;这些通用的逻辑为所有客户共享，因而不浪费服务商的计算资源，也就可以做到按API调用次数计算费用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以前叫我们把二层的富客户端都改成三层瘦客户端，现在搞个共享数据库，又叫我们改成富客户端。横竖赚钱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201712/569097-20171201135836977-589725889.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;而FaaS存放客户代码，当访问时，调入相关资源，开始运行，运行完成后，卸载所有开销。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嘶~~~，听起来耳熟。靠，这不就是PHP吗？！我是不是发现了什么~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、Serverless凭啥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看来BaaS和FaaS都是新瓶装旧酒，那么Serverless凭啥流行，又是不是未来？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Facebook 于2013年花费了 8500 万美元收购了主流的BaaS平台 Parse 。由于 Parse 一直以来未能为 Facebook 提供预期的营收，Facebook 决定一年后将其正式关闭，并将其代码开源。Facebook这不差钱的行为，直接为整个行业蒙上了阴影。可以说直接逼死了某些跟风者。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;搭个共享数据库赚钱的想法基本破灭后，行业都纷纷压宝FaaS。那么FaaS的前景如何?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然FaaS是BaaS的“升级版”，并且与流行的微服务架构相吻合。但是无法改变它有强制所有程序按PHP方式运行这样一个可怕的设定。&lt;/span&gt;&lt;span&gt;而这个无奈的设定所解决的是导致先行者AppEngine举步维艰的病根，那就是大量进程占用服务商过多的资源而不怎么赚钱。&lt;/span&gt;&lt;span&gt;所以FaaS这个扭曲版AppEngine对于服务商来说是一剂良药，但是未必会是行业的未来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这些年随着Docker平台的发展，启停一个容器的成本已经接近于启停一个进程。将AppEngine平台上的侦听进程都去掉，用一个统一的WebServer来侦听路由，当访问到来时，启动容器，运行，停止容器。这和PHP的做法一模一样，不过是把PHP.exe换成了Docker容器罢了。&lt;/span&gt;&lt;span&gt;&lt;span&gt;同一个思路，换一个环境，马上从落后变成了先进。可以你想像，FaaS是降低成本的利器，也一定会占有一部分低端市场。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是，PHP也没有像FaaS一样强制要求所有服务达到函数这个级别，一步到位的确有点匪夷所思。函数也非FaaS最好的包装形式，不如像PHP直接对应到一个文件上。在我看来，现有FaaS平台的行为模式，只适合推广PHP，能够与PHP生态很好地对接，而其它语言则有不可调和的矛盾。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看了一下开源框架Fission的源码，想出一个兼容其它语言的方案，以Python语言为例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要求Flask程序实现2个接口，原有的程序不加任何修改即可在FaaS框架下运行了，/register接口载入所有Route，并返回所有绑定规则，FaaS框架只需要把Route表合并就可以一次性创建所有Route。不必要一条一条调用fission function create与fission route add了。Http 请求来时调用/specialize接口，根据endpoint（即函数名）载入代码，实现FaaS功能。把框架接口开放给程序，能够实现最大的兼容现有框架，如果不放心，可以调用/specialize?endpoint=echo&amp;amp;echo=hello，来验证程序是否支持FaaS平台即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, request

app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

userfunc &lt;/span&gt;=&lt;span&gt; None

@app.route(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/register&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; register():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引入所有Routes，并返回所有Rules&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; .main &lt;span&gt;import&lt;/span&gt;&lt;span&gt; main as main_blueprint
    app.register_blueprint(main_blueprint) 
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsonify(app.url_map._rules_by_endpoint)
    

@app.route(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/specialize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, methods=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; load():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特化载入，只载入单个endpoint&lt;/span&gt;
    body =&lt;span&gt; request.get_json()
    name &lt;/span&gt;= body[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;endpoint&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; userfunc
    userfunc &lt;/span&gt;=&lt;span&gt; imp.load_source(name)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、Serverless有啥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Serverless平台一般分为如下三类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 公有云&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;everless&lt;/span&gt;&lt;span&gt;平台：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. AWS Lambda、B. Microsoft Azure Functions、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. Google Cloud Functions、D. Webtask、E. Syncano&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 私有云Severless框架：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. &lt;a href=&quot;http://fission.io/&quot; target=&quot;_blank&quot;&gt;Fission&lt;/a&gt; （Kubernetes）、B. &lt;a href=&quot;https://fabric8.io/&quot; target=&quot;_blank&quot;&gt;Funktion&lt;/a&gt; （Kubernetes）、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. &lt;a href=&quot;http://kubeless.io/&quot; target=&quot;_blank&quot;&gt;Kubeless&lt;/a&gt; （Kubernetes）、D. &lt;a href=&quot;http://www.galacticfog.com/&quot; target=&quot;_blank&quot;&gt;Gestalt&lt;/a&gt; （DC/OS）、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E. &lt;a href=&quot;http://openwhisk.incubator.apache.org/&quot; target=&quot;_blank&quot;&gt;IBM OpenWhisk&lt;/a&gt; （Docker）、F. &lt;a href=&quot;http://www.iron.io/&quot; target=&quot;_blank&quot;&gt;Iron Functions&lt;/a&gt; （Docker，Swarm， Kubernetes）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Serverless平台的包装框架：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A. &lt;a href=&quot;https://serverless.com/&quot; target=&quot;_blank&quot;&gt;Serverless&lt;/a&gt;（&lt;span&gt;Node，&lt;/span&gt;大多数平台）、B. &lt;a href=&quot;http://apex.run/&quot; target=&quot;_blank&quot;&gt;Apex&lt;/a&gt;（&lt;span&gt;Go，&lt;/span&gt;AWS）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C. &lt;a href=&quot;https://www.zappa.io/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Zappa&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（Python，AWS）、D. &lt;/span&gt;&lt;a href=&quot;https://github.com/aws/chalice&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Chalice&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（Python，AWS）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;E. &lt;a href=&quot;https://claudiajs.com/&quot; target=&quot;_blank&quot;&gt;Claudia.js&lt;/a&gt;（&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;，AWS）F. &lt;/span&gt;&lt;a href=&quot;https://github.com/jorgebastida/gordon&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Gordon&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;span&gt;（Python，AWS）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、Serverless干啥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、AWS Lambda的包装框架Zappa，可以使用Flask,Django等框架。功能看下图可知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201712/569097-20171201153431789-1840570181.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Fission是一个Serverless开源框架。可以看看它都干了啥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fission是基于Kubernetes的，而Kubernetes是基于Docker的容器集群管理系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes的内容太丰富，简单说来，实体对象有若干节点（Node）包含若干Pod，Pod又包含若干容器（Container），通过Pod上的标签（Label）组合成服务（Service）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;zwnr&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/569097/201712/569097-20171203101509522-674447216.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;zwnr&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt; Master包含如下组件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;apiserver：&lt;/strong&gt;作为kubernetes系统的入口，封装了核心对象的增删改查操作。它维护的REST对象将持久化到etcd。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;etcd&lt;/strong&gt;：分布式强一致性的key/value存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scheduler：&lt;/strong&gt;负责集群的资源调度，为新建的pod分配机器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;controller-manager：&lt;/strong&gt;负责执行各种控制器，目前有两类：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;endpoint-controller：&lt;/strong&gt;定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;replication-controller：&lt;/strong&gt;定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Slave Node（称为Minion）包含如下组件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;kubelet：&lt;/strong&gt;负责管控docker容器，如启动/停止、监控运行状态等。它会定期从etcd获取分配到本机的pod，并根据pod信息启动或停止相应的容器。同时，它也会接收apiserver的HTTP请求，汇报pod的运行状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy：&lt;/strong&gt;负责为pod提供代理。它会定期从etcd获取所有的service，并根据service信息创建代理。当某个客户pod要访问其他pod时，访问请求会经过本机proxy做转发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker&lt;/strong&gt;：docker容器引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Fission简单说来，就是一个Web应用，Go语言编写，使用gorilla框架。不过它的模板引擎替换成了Kubernetes中的Service。使用k8s.io/client-go/kubernetes接口来操控（k8s就是Kubernetes）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;zwnr&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201712/569097-20171201214824276-16617020.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

</description>
<pubDate>Fri, 08 Dec 2017 13:16:00 +0000</pubDate>
<dc:creator>windfic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/windfic/p/7941998.html</dc:identifier>
</item>
<item>
<title>SolrJ 复杂查询 高亮显示 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8007144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8007144.html</guid>
<description>[unable to retrieve full-text content]SolrJ 复杂查询 高亮显示 上一章搭建了Solr服务器和导入了商品数据，本章通过SolrJ去学习Solr在企业中的运用。笔者最先是通过公司的云客服系统接触的Solr，几百万的留言秒秒钟就查询并高亮显示，不同的广告员还可以只检索自己所属国家的留言。瞬间就跪拜在Solr的石榴裙下。现在看来其实就是 </description>
<pubDate>Fri, 08 Dec 2017 13:08:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8007144.html</dc:identifier>
</item>
<item>
<title>自动微分方法(auto diff) - Wanna_Go</title>
<link>http://www.cnblogs.com/wxshi/p/8007106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxshi/p/8007106.html</guid>
<description>&lt;p&gt;学习机器学习的同学在学习过程中会经常遇到一个问题，那就是对目标函数进行求微分，线性回归这类简单的就不说、复杂的如神经网络类那些求导过程的&lt;code&gt;酸爽&lt;/code&gt;。像我还是那种比较粗心的人往往有十&lt;code&gt;导&lt;/code&gt;九错，所以说自动求导就十分有必要了，本文主要介绍几种求导的方式。假设我们的函数为&lt;span class=&quot;math inline&quot;&gt;\(f(x,y)=x^2y+y+2\)&lt;/span&gt;，目标是求出偏导&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{x}}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{y}}\)&lt;/span&gt;。求导的方式主要分为以下几种&lt;/p&gt;
&lt;h3 id=&quot;手动求导法manual-differentiation&quot;&gt;手动求导法(Manual Differentiation)&lt;/h3&gt;
&lt;p&gt;首先准备一张纸和一支笔，根据上学时候学到的求导法则，开始计算。最终得到的结果&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{x}}=2xy\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{y}}=x^2+1\)&lt;/span&gt;&lt;br/&gt;上面这个小例子比较简单，口算即可得到答案，但如果方程比较复杂那就难说了。幸好有自动求导的方法，例如符号求导方法。&lt;/p&gt;
&lt;h3 id=&quot;符号求解法symbolic-differentiation&quot;&gt;符号求解法(Symbolic Differentiation)&lt;/h3&gt;
&lt;p&gt;符号求导是根据一些求导法则，进行求导。例如我们大学高数学习的&lt;span class=&quot;math inline&quot;&gt;\((uv)\prime=u'v+v'u\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\((u+v)'=u'+v'\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\((\frac{u}{v})'=\frac{u'v-v'u}{v^2}\)&lt;/span&gt;等等，下图是&lt;span class=&quot;math inline&quot;&gt;\(g(x,y)=5+xy\)&lt;/span&gt;的符号求导工作流程。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/702365/201712/702365-20171208205536296-10021585.png&quot;/&gt;&lt;br/&gt;原公式在图的左边，求导公式在图的右半部分，求导的过程是先求叶子节点，自下向上。最终对节点进行见之得到求导结果&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{g}}{\partial{x}}=y\)&lt;/span&gt;，这个例子固然简单，但是对于一个更复杂的公式，那么求导符号图将会十分的庞大(表达式膨胀)，另外对于一些变化的公式（&lt;code&gt;硬代码&lt;/code&gt;）这种方法就无能为力了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fun(a,b):
    z=0
    for i in range(100):
        z = a * np.cos(z + i) + z * np.sin(b - i)
    return z&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数值求导法numerical-differentiation&quot;&gt;数值求导法(Numerical Differentiation)&lt;/h3&gt;
&lt;p&gt;导数的定义是当自变量的增量趋于零时，因变量的增量与自变量的增量之商的极限。&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;是一个无穷小的数，所以我们可以计算在x=3,y=4这一点对x的偏导数，&lt;span class=&quot;math inline&quot;&gt;\(f'(x=3,y)=\frac{f(3+\varepsilon,4)-f(3,4)}{\varepsilon}\)&lt;/span&gt;，对应的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x, y):
    return x**2*y + y + 2 
def derivative(f, x, y, x_eps, y_eps):
    return (f(x + x_eps, y + y_eps) - f(x, y)) / (x_eps + y_eps) 
df_dx = derivative(f, 3, 4, 0.00001, 0)
df_dy = derivative(f, 3, 4, 0, 0.00001) 
&amp;gt;&amp;gt;print(df_dx) 
24.000039999805264 
&amp;gt;&amp;gt;print(df_dy)  
10.000000000331966 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的结果我们发现，得出的结果不是十分的精确，并且在对x和y求偏导的整个过程中，至少需要计算3次&lt;span class=&quot;math inline&quot;&gt;\(f()\)&lt;/span&gt;，也就是说如果有1000个参数，那么至少需要计算1001次&lt;span class=&quot;math inline&quot;&gt;\(f()\)&lt;/span&gt;，在神经网络中，参数巨多，这样计算效率会比较差。不过这种方法常被用到进行检验得到的求导结果是否正确。&lt;/p&gt;
&lt;h3 id=&quot;前向自动求导法forward-mode-autodiff&quot;&gt;前向自动求导法(Forward-Mode Autodiff)&lt;/h3&gt;
&lt;p&gt;前向求导是依赖于数值求导和符号求导的一种求解方法，给定公式&lt;span class=&quot;math inline&quot;&gt;\(a+{\varepsilon}b\)&lt;/span&gt;，这种被称作&lt;code&gt;dual number&lt;/code&gt;,其中&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;是实数，&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;是一个无穷小的数，并且&lt;span class=&quot;math inline&quot;&gt;\({\varepsilon}^2=0\)&lt;/span&gt;，举个栗子，&lt;span class=&quot;math inline&quot;&gt;\(42 + 24\varepsilon\)&lt;/span&gt;，我们可以把它看成&lt;code&gt;42.00000000...24&lt;/code&gt;的数值.我们可以通过这种方法&lt;code&gt;(42.0,24.0)&lt;/code&gt;来表示，dual number满足以下的运算法则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.&lt;span class=&quot;math inline&quot;&gt;\(\lambda(a+b\varepsilon) = a\varepsilon + b{\lambda}\varepsilon\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;2.&lt;span class=&quot;math inline&quot;&gt;\((a+b\varepsilon)+(c+d\varepsilon) = (a+c)+(b+d)\varepsilon\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;3.&lt;span class=&quot;math inline&quot;&gt;\((a+b\varepsilon)\times(c+d\varepsilon) = ac+(ad+bc)\varepsilon+(bd){\varepsilon}^2=ac+(ad+bc)\varepsilon\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一点就是&lt;span class=&quot;math inline&quot;&gt;\(h(a+b\varepsilon)=h(a)+b{\times}h'(a)\varepsilon\)&lt;/span&gt;。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/702365/201712/702365-20171208205401046-1701261197.png&quot;/&gt;&lt;br/&gt;上图给出了使用前向求导方法计算出&lt;span class=&quot;math inline&quot;&gt;\(f(x,y)\)&lt;/span&gt;在x=3，y=4这一点&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{x}}(3,4)\)&lt;/span&gt;的偏导，同理求出&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{y}}(3,4)\)&lt;/span&gt;,图中的思路很清晰就不赘述。前向求导方法相对数值求导来说准确率较高，当和数值求导方法一样如果参数过多的时候效率会比较差，因为这种方法需要遍历整个图。&lt;/p&gt;
&lt;h3 id=&quot;逆向自动求导法reverse-mode-atuodiff&quot;&gt;逆向自动求导法(Reverse-Mode Atuodiff)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TensorFlow&lt;/code&gt;采用的是逆向自动求导方法，该方法首先正向遍历整个图，计算出每个节点的值；然后逆向(从上到下)遍历整个图，计算出节点的偏导值，步骤如下图所示；节点内蓝色的数值表示正向计算出的结果，为了方便表达，我们从下到上，从左到右依次标注为&lt;span class=&quot;math inline&quot;&gt;\(n_1\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(n_7\)&lt;/span&gt;，可以看到最后的值&lt;span class=&quot;math inline&quot;&gt;\(n_7\)&lt;/span&gt;(顶部节点)为42。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/702365/201712/702365-20171208205424249-73510226.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在逆向求导过程中使用链式求导方法：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{x}}=\frac{\partial{f}}{\partial{n_i}}{\times}\frac{\partial{n_i}}{\partial{x}}\)&lt;/span&gt;&lt;br/&gt;先看节点&lt;span class=&quot;math inline&quot;&gt;\(n_7\)&lt;/span&gt;，作为输出节点&lt;span class=&quot;math inline&quot;&gt;\(f=n_7\)&lt;/span&gt;，所以导数值为&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{n_7}}=1\)&lt;/span&gt;,&lt;br/&gt;接着向下计算&lt;span class=&quot;math inline&quot;&gt;\(n_5\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{n_5}}=\frac{\partial{f}}{\partial{n_7}}{\times}\frac{\partial{n_7}}{\partial{n_5}}\)&lt;/span&gt;，上一步计算出&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{n_7}}=1\)&lt;/span&gt;，现在我们只需要计算&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{n_7}}{\partial{n_5}}\)&lt;/span&gt;，从图中我们知道&lt;span class=&quot;math inline&quot;&gt;\(n_7=n_5+n_6\)&lt;/span&gt;，可以得出&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{x}}=1\)&lt;/span&gt;。所以&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{f}}{\partial{n_5}}=1\)&lt;/span&gt;，接下来的步骤可以看上面的图，这里就不赘述了。&lt;br/&gt;逆向自动求导法这种方法十分强大且准确率较高，尤其是有却多的输入。这种发方法仅需要正向和逆向遍历一次即可，这种方法更强大的地方在于能够解决&lt;code&gt;符号求解法&lt;/code&gt;中&lt;code&gt;硬代码&lt;/code&gt;的问题。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 12:55:00 +0000</pubDate>
<dc:creator>Wanna_Go</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxshi/p/8007106.html</dc:identifier>
</item>
<item>
<title>移动端经常出现的兼容问题 - 空一座旧城，守一个旧人</title>
<link>http://www.cnblogs.com/yinxingen/p/8006995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yinxingen/p/8006995.html</guid>
<description>&lt;h2 id=&quot;移动端-经常出现的兼容问题&quot;&gt;移动端 经常出现的兼容问题&lt;/h2&gt;
&lt;h3 id=&quot;安卓浏览器看背景图片有些设备会模糊&quot;&gt;1.安卓浏览器看背景图片，有些设备会模糊&lt;/h3&gt;
&lt;p&gt;因为手机分辨率太小，如果按照分辨率来显示网页，字会非常小，安卓手机devicePixoRadio比较乱，有1.5的，有2的也有3的。想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况下都是2倍的），或者指定background-size:contain;都可以&lt;/p&gt;
&lt;h3 id=&quot;防止手机中页面放大和缩小&quot;&gt;2.防止手机中页面放大和缩小&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;meta name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;viewport&quot;&lt;/span&gt; content&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;上下拉动滚动条时卡顿慢&quot;&gt;3.上下拉动滚动条时卡顿、慢&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
body&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;overflow&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;scrolling&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;touch&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    overflow&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;scrolling&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;touch&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Android3+和iOSi5+支持CSS3的新属性为overflow-scrolling&lt;/p&gt;
&lt;h3 id=&quot;长时间按住页面出现闪退&quot;&gt;4.长时间按住页面出现闪退&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;element&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;touch&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;callout&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;none&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;iphone及ipad下输入框默认内阴影&quot;&gt;5.iphone及ipad下输入框默认内阴影&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;element&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;appearance&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;none&lt;span class=&quot;op&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;ios和android下触摸元素时出现半透明灰色遮罩&quot;&gt;6.ios和android下触摸元素时出现半透明灰色遮罩&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;element&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;tap&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;highlight&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;rgba&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置alpha值为0就可以去除本透明灰色遮罩，备注：transparent的属性值在android下无效。&lt;/p&gt;
&lt;h3 id=&quot;active兼容处理-即-伪类active失效&quot;&gt;7.active兼容处理 即 伪类：active失效&lt;/h3&gt;
&lt;p&gt;方法一：body添加ontouchstart&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;body ontouchstart&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：js给document绑定touchstart或touchend事件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;style&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
a&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;#&lt;span class=&quot;dv&quot;&gt;000&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
a&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;active&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;#fff&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;a href=foo&amp;gt;bar&amp;lt;/a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListentener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'touchstart'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{},&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
)
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;px边框&quot;&gt;8.1px边框&lt;/h3&gt;
&lt;p&gt;在移动端中，如果给元素设置一个像素的边框的话，那么在手机上看起来是会比一个像素粗的。&lt;/p&gt;
&lt;p&gt;解决方法：使用伪类元素模拟边框，使用transform缩放&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    .&lt;span class=&quot;at&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;::&lt;/span&gt;after&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; block&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; 1px&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; #&lt;span class=&quot;dv&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; absolute&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;scaleY&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;webkit-mask兼容处理&quot;&gt;9.webkit mask兼容处理&lt;/h3&gt;
&lt;p&gt;某些低端手机不支持css3mask，可以选择性的进降级处理&lt;br/&gt;比如可以使用js判断来引用不同class：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'WebkitMask'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;documnet&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;documentElement&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;style&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'支持 mask'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'不支持 mask'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;旋转屏幕是字体大小调整的问题&quot;&gt;10.旋转屏幕是，字体大小调整的问题&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;html&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;body&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;form&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fieldset&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h1&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h2&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h3&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h4&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h5&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;h6&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;text&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;size&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;adjust&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;transiton闪屏&quot;&gt;11.transiton闪屏&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//设置内联的元素在3D空间如何呈现：保留3D&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;transform&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;style&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;preserve&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;3D&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//设置进行转换的元素的背面在面对用户时是否课件：隐藏&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;webkit&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;backface&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;visibility&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;hidden&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;圆角bug&quot;&gt;12.圆角bug&lt;/h3&gt;
&lt;p&gt;某些Android手机圆角失效 background-clip:padding-box;&lt;/p&gt;
&lt;h3 id=&quot;click的300ms延迟问题&quot;&gt;13.click的300ms延迟问题&lt;/h3&gt;
&lt;p&gt;在移动端中，click事件是生效的，但是，点击之后会有300ms的延迟响应&lt;/p&gt;
&lt;p&gt;原因：safari是最早做出这个机制的，因为在移动端里，浏览器需要等待一段时间来判断此次用户操作是单击还是双击，所以就有click300ms的延迟机制，Android也很快就有了&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不用click，用自定义事件tap&lt;/p&gt;
tap是需要自定义的：如果用户执行了touchstart在很短的时间又触发了touchend,且两次的距离很小，而且不能&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;引入fastclick库来解决&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;响应式图片&quot;&gt;14.响应式图片&lt;/h3&gt;
&lt;p&gt;在移动端中，图片的处理应该是很谨慎的，假设有一张图片本身的尺寸是X宽，设置和包裹它的div一样宽，如果是div宽度小于图片宽度没有问题，但是如果div宽度大于图片的宽度，图片被拉伸失真&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;解决方法：让图片最大只能是自己的宽度&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    img&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        max&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; block&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; auto&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;点透bug的产生&quot;&gt;15.点透bug的产生&lt;/h3&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;haorooms&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;点头事件测试&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;a href=&quot;www.jb51.net&quot;&amp;gt;www.jb51.net&amp;lt;/a&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;div是绝对定位的蒙层，并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#haorooms'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'tap'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#haorooms'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;hide&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们点击蒙层时div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。&lt;/p&gt;
&lt;p&gt;原因：&lt;br/&gt;touchstart早于touchend早于click。即click的触发是由延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏。此时click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接。&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;1.尽量都使用touch事件来替换click事件。例如用touchend事件（推荐）&lt;br/&gt;2.用fastclick&lt;br/&gt;3.用preventDefault阻止a标签的click&lt;br/&gt;4.延迟一定的事件（300ms+）来处理事件（不推荐）&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 12:17:00 +0000</pubDate>
<dc:creator>空一座旧城，守一个旧人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yinxingen/p/8006995.html</dc:identifier>
</item>
</channel>
</rss>