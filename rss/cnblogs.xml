<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes 架构（下）- 每天5分钟玩转 Docker 容器技术（121） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8308334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8308334.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节我们讨论了 Kubernetes 架构 Master 上运行的服务，&lt;/span&gt;&lt;span&gt;本节讨论 Node 节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Node 是 Pod 运行的地方，Kubernetes 支持 Docker、rkt 等容器 Runtime。 Node上运行的 Kubernetes 组件有 kubelet、kube-proxy 和 Pod 网络（例如 flannel）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180118073411959-299225303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kubelet 是 Node 的 agent，当 Scheduler 确定在某个 Node 上运行 Pod 后，会将 Pod 的具体配置信息（image、volume 等）发送给该节点的 kubelet，kubelet 根据这些信息创建和运行容器，并向 Master 报告运行状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;kube-pro&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;xy&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;service 在逻辑上代表了后端的多个 Pod，外界通过 service 访问 Pod。service 接收到的请求是如何转发到 Pod 的呢？这就是 kube-proxy 要完成的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个 Node 都会运行 kube-proxy 服务，它负责将访问 service 的 TCP/UPD 数据流转发到后端的容器。如果有多个副本，kube-proxy 会实现负载均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pod 网络&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pod 要能够相互通信，Kubernetes Cluster 必须部署 Pod 网络，flannel 是其中一个可选方案。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;完整的架构&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;图&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;结合实验环境，我们得到了如下的架构图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180118073500709-1127648200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可能会问：为什么 k8s-master 上也有 kubelet 和 kube-proxy 呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是因为 Master 上也可以运行应用，即 Master 同时也是一个 Node。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;几乎所有的 Kubernetes 组件本身也运行在 Pod 里，执行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
kubectl get pod --all-namespaces -o wide
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180118073535974-1574165081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 的系统组件都被放到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-system&lt;/span&gt;&lt;/code&gt;&lt;span&gt; namespace 中。这里有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-dns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 组件，它为 Cluster 提供 DNS 服务，我们后面会讨论。&lt;/span&gt;&lt;code&gt;&lt;span&gt;kube-dns&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是在执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubeadm init&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时（第 ⑤ 步）作为附加组件安装的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kubelet 是唯一没有以容器形式运行的 Kubernetes 组件，它在 Ubuntu 中通过 Systemd 运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201801/775365-20180118073601943-1602842958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了帮助大家更好地理解 Kubernetes 架构，下节我们将部署一个应用来展示各个组件是如何协作的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171205-1512465642434079417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 22:26:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8308334.html</dc:identifier>
</item>
<item>
<title>内核知识第九讲,32位下的分页管理,36位下的分页管理.以及64位下的分页管理 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8315085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8315085.html</guid>
<description>&lt;h2&gt;一丶熟悉WinDbg的常见命令.&lt;/h2&gt;
&lt;p&gt;dd 虚拟地址      显示内存.&lt;/p&gt;
&lt;p&gt;!dd 加上!,        ! dd 物理地址     专门用于显示物理地址的.&lt;/p&gt;
&lt;p&gt;!PTE  虚拟地址:   微软给你计算出PDE,和PTE的虚拟地址的位置.(自动查表并且进行操作)&lt;/p&gt;
&lt;p&gt;例如随便求一个虚拟地址:&lt;/p&gt;
&lt;p&gt;DD命令的使用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119015323584-1697492622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然, db则是一个字节一个字节显示, dQ则是八个字节显示.&lt;/p&gt;
&lt;p&gt;!dd, 物理内存显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119015439943-157718482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;!PTE 查询页目录表和页表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119015522615-1747568604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微软给的是虚拟地址,我们只需要再次进行DD 这个虚拟地址即可.&lt;/p&gt;
&lt;h2&gt;二丶寻址结构图&lt;/h2&gt;
&lt;p&gt;昨天我们讲解的是32为下4M+4K的做表方式.  一个页目录表.一个页表 (PDE,PTE),虚拟地址当作下表进行寻址动作.&lt;/p&gt;
&lt;p&gt;然后还有一个寻址结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119020728771-785534776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1. 首先第一步,虚拟地址是段加偏移的方式  例如: CS:00401000&lt;/p&gt;
&lt;p&gt; 2.而后,段CS,当作选择子去GDT表中查表.找到线性地址. 因为GDT微软不使用.所以GDT表中的段首地址是0,所以 0 + 我们的偏移,找到线性地址. 图中(linAddr)&lt;/p&gt;
&lt;p&gt; 3.而后线性地址,拆分成索引.去查询页目录表. 而后继续查询页表.而后从页表中取出物理地址,加上虚拟地址的偏移.则是一个完整的物理地址.&lt;/p&gt;
&lt;p&gt;　　PS: 因为GDT没有使用,所以如果不开启分页保护.这个线性地址就是物理地址.但是现在开了,所以要查询物理地址,看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119021521240-616469778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;0-15是段选择子,0-31是虚拟地址. 段选择子去GDT查表.加上我们的虚拟地址就是物理地址. 而是否开启分页保护,就是修改CR0的标志位.上一篇已经讲过了.&lt;/p&gt;
&lt;p&gt;这里查表,拆分成了索引.但是昨天我们只学习了4M+4K的查表方法.虚拟地址的前20位做索引. 查询.&lt;/p&gt;
&lt;p&gt;但是32位下还有别的做表方式.&lt;/p&gt;
&lt;h2&gt;三丶32位下的PDE,PTE表,以及通用查表方法(通用: 指的是大同小异)&lt;/h2&gt;
&lt;p&gt;看一下32位下的做表的图:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119021837646-2142963636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;32位系统下,PDE有1024项,每一项是4个字节,其中存储了页表的位置.&lt;/p&gt;
&lt;p&gt;这个就是我们昨天就爱了各国的.&lt;/p&gt;
&lt;p&gt;1.首先从CR3中取出页目录表(PDE)&lt;/p&gt;
&lt;p&gt;2.虚拟地址作为下表查询PDE.&lt;/p&gt;
&lt;p&gt;3.根据查询的PDE表项.找出PTE的位置.&lt;/p&gt;
&lt;p&gt;4.根据索引.查询PTE的位置.&lt;/p&gt;
&lt;p&gt;5.根据PTE中的内容.加上我们的虚拟地址的后12位,就得出了这个线性地址在物理地址的位置.&lt;/p&gt;
&lt;p&gt;实战演练:&lt;/p&gt;
&lt;p&gt;查询GDT虚拟地址的物理地址.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.获取GDT的虚拟地址, 获取CR3的值.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119022253521-2147424046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VA =  8003F00&lt;/p&gt;
&lt;p&gt;CR3 = 39000&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查分虚拟地址.当作下表.查询页目录表的位置&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;8003f000 保留低12位 = 8003f&lt;/p&gt;
&lt;p&gt;查分为索引.&lt;/p&gt;
&lt;p&gt;8003f = 10000000000000111111&lt;/p&gt;
&lt;p&gt;对2进制分割. 分为前10位.后10位.从右往左分割. 前10位索引当作 PDE的下表. 后10位的索引当作PTE的下表.&lt;/p&gt;
&lt;p&gt;1000000000           0000111111 &lt;/p&gt;
&lt;p&gt;PDE = 1000000000 ,转为16进制 = 0x200&lt;/p&gt;
&lt;p&gt;PTE = 0000111111   ,转为16进制 = 0x3f&lt;/p&gt;
&lt;p&gt;由此得出下表.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.根据下表进行查表.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CR3是PDE的首地址. 所以我们直接用WinDbg进行查表即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119022839553-826175334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式:&lt;/p&gt;
&lt;p&gt;　　物理地址 * 索引 *4, 为什么*4,因为PDE的一个表项是4个字节&lt;/p&gt;
&lt;p&gt;由此得出页表的位置(PTE)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.查询页表(PTE)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们从PDE表项中,取出前20位,然后加上12位,继续进行查表.&lt;/p&gt;
&lt;p&gt;为什么这样做.上一篇已经介绍了表格式了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119023100849-1102211535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.根据PTE的内容.找出物理地址的位置.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上图,我们已经找到物理地址了.&lt;/p&gt;
&lt;p&gt;取出前20位,加上虚拟地址的后12位偏移.则是物理地址了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119023217553-2138288572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找出了所在的物理地址了.&lt;/p&gt;
&lt;p&gt;此时我们dd 虚拟地址.查看是否两块内存是一样的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119023328943-1413167479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 至此.我们的查表已经完成.&lt;/p&gt;
&lt;p&gt;但是.我们这样查询是错误的.为什么?&lt;/p&gt;
&lt;p&gt;首先查询方法是正确的.类似于上面.我们已经正确的查询到了物理地址. 但为什么又说是错误的.&lt;/p&gt;
&lt;p&gt;原因:&lt;/p&gt;
&lt;p&gt;　　操作系统在做分页管理的时候.不一定是4M+4k的这种表来做的. 有可能有更大的表.&lt;/p&gt;
&lt;p&gt;所以我们要看标志位进行查表&lt;/p&gt;
&lt;h2&gt;四丶标志位介绍.&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119023720068-315311182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上图介绍了标志位为什么.表项做多大的.&lt;/p&gt;
&lt;p&gt;1. 如果PSE和PS位都为1.那么这个表就做成4MB的.&lt;/p&gt;
&lt;p&gt;2.如果PS位为0.PSE位无效那么这个表就做成4kb的.&lt;/p&gt;
&lt;p&gt;3.如果PAE为1,PS位为1,则表项做成2MB的.&lt;/p&gt;

&lt;p&gt;我们要看标志位进行查表.&lt;/p&gt;
&lt;p&gt;PAE位 (物理地址扩展): 存放在CR4寄存器的第五位.&lt;/p&gt;
&lt;p&gt;PSE位 (页尺寸扩展): 存放在CR4寄存器的第4位.&lt;/p&gt;
&lt;p&gt;PS位:  存放在PDE(页目录表的第7位)&lt;/p&gt;
&lt;p&gt;上面所说的.都是从左往右的位.&lt;/p&gt;
&lt;p&gt;比如:　&lt;/p&gt;
&lt;p&gt;　　CR4寄存器的值 = 0x34500&lt;/p&gt;
&lt;p&gt;拆分:&lt;/p&gt;
&lt;p&gt;　　0011 0100 0110 0000 0000   第4位.第五位都是0.&lt;/p&gt;
&lt;p&gt;索引我们要根据位来看看到底是什么表.&lt;/p&gt;

&lt;h2&gt;五丶32位表项.&lt;/h2&gt;
&lt;p&gt;从上面我们得知了第一种表现.是4KB的表项做法.每一个都是1024项的.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4kb表项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119024842709-769744058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是我们上图做的.查表的是否根据上图去查表的.&lt;/p&gt;
&lt;h3&gt;4MB的页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119024932928-792561198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就很简单了.发现了没有.上面少了一个页表. 我们从PDE中查表的时候.查出来直接就是物理地址了.&lt;/p&gt;
&lt;p&gt;而且虚拟地址的偏移是22位了.所以最后我们加的是前10位.&lt;/p&gt;
&lt;p&gt;而且下图也有说.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119025231193-707053312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还把各种标志位的作用都说了.&lt;/p&gt;
&lt;p&gt;查表方法同上面一样. 只不过最后加偏移的是否是 从PDE表中的所在物理地址的位置取出10位.然后加上我们的偏移即可.&lt;/p&gt;
&lt;p&gt;例如我们从上面随便找个PDE的表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119025432146-1067738075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设 PDE中的0003b163是物理地址.我们只需要取出前10位.然后加上我们的偏移即可.&lt;/p&gt;
&lt;p&gt;0000 0000 00 + offset = 物理地址.&lt;/p&gt;

&lt;h2&gt;六丶开启PAE,36位表项.&lt;/h2&gt;
&lt;p&gt;在我们可以映射4G内存的是否. 内存发展速度大于CPU.此时已经8G内存了.如果访问&lt;/p&gt;
&lt;p&gt;此时CPU厂家.就加了4根地址总线.以支持8G的访问.&lt;/p&gt;
&lt;p&gt;而因为为了支持.所以表项变成了512个项了. 每一项8个字节了.&lt;/p&gt;
&lt;h3&gt;36位下4KB的分页&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119030040662-2068789581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上图,我们可以看出.加了一个新表.&lt;/p&gt;
&lt;p&gt;我们的虚拟地址索引的高2位要做为这个 新表的索引去查询. &lt;/p&gt;
&lt;p&gt;最后我们的12位偏移,要加上PTE中物理地址的24位才是我们的物理内存的位置.&lt;/p&gt;
&lt;p&gt;而这种做表方法.只能说也是映射4G内存.只不过可以映射多个4G内存了.&lt;/p&gt;
&lt;p&gt;查表方法和上面一样.&lt;/p&gt;
&lt;p&gt;首先字节改变了. 每一项8个字节,而后最后我们是12位加上24位.得出物理地址.&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 36位下2MB的分页&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119030439178-2006237998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 也是同上.只不过少了一个PTE.查表动作少了一次而已.&lt;/p&gt;
&lt;p&gt;.只不过计算的是否.要根据36位地址来计算.&lt;/p&gt;
&lt;p&gt;看下图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119030657506-905152120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2MB的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119030741131-1515297865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一张图,告诉了我们.我们进行查表的时候. 4KB的怎么加.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;　　我们以前查表是  !dd 3f000000 ,正好32位.而看上图.4KB的告诉了我们.&lt;/p&gt;
&lt;p&gt;32位 - 35位当作基址查询.(4位) 要加上. 比如 !dd 00003f000000 正好满足36的地址进行查寻.&lt;/p&gt;
&lt;p&gt;2MB的图是一样的.&lt;/p&gt;

&lt;h2&gt;七丶64位系统下的表项&lt;/h2&gt;
&lt;p&gt;64位CPU下的的表项.同32为系统的表项是一样的. 只不过变的更大了.&lt;/p&gt;
&lt;p&gt;4kb的表项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119031904099-1400535351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和32位下一样.加了几张表.各种位都变大了.&lt;/p&gt;
&lt;p&gt;2MB的分页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119032017412-92370064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 64位扩展的2MB分页&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119032112021-180232712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;64位下映射1GB的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180119032215021-575837148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CR3. 当我们3环调用0环回调的是否.CR3是ring3的.&lt;/p&gt;

&lt;h2&gt;八丶为什么学习这些表.以及学这些表的作用&lt;/h2&gt;
&lt;p&gt;为什么学习. 因为到了0环.就是对抗了. 就比谁对操作系统了解.&lt;/p&gt;
&lt;p&gt;比如我们熟悉上面的这些表的设计. 而且根据GDT,找出线性地址.根据线性地址找出对应的物理地址.&lt;/p&gt;
&lt;p&gt;那么我们完全可以进行手动操作物理内存. 实现ReadProcessMemory和WriteProcessMemeory.&lt;/p&gt;
&lt;p&gt;当然不会怎么简单.但是我们能操作内存了. 是不是就不用调用API了.我们自己实现了 内存读写功能.&lt;/p&gt;
&lt;p&gt;举例子:&lt;/p&gt;
&lt;p&gt;　　假设游戏有保护.保护了API. 不让你读写内存. 给你HOOK了.各种检测. 但是我们不调用. 我们自己写一个.它怎么检测.&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 19:29:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8315085.html</dc:identifier>
</item>
<item>
<title>【C#系列】浅谈委托和事件 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8300103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8300103.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118230416334-1265169458.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;本篇文章更适合具有一定开发经验，一定功底，且对底层代码有所研究的朋友！！！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本篇文章主要采用理论和代码实例相结合方式来论述委托和事件，涉及到一些边界技术，如软件架构的OCP原则(开-闭原则)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件架构解耦，设计模式(Sender-Order)和事件驱动模型，&lt;/span&gt;&lt;span&gt;有一定难度和深度，不适合初级者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一部份   委托&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于委托内容，主要围绕下图来论述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180119074307224-1458467598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;一   委托是什么(what)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）委托产生的背景之一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.我们先来假设这样一个情景需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   设计一个系统，使其满足如下条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （1）当前，只有中国人和英国人使用该系统；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （2）向系统输入用户名和相应的语言，将产生相应语言的问候语；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118100121178-1387760203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  （3）后期，可能会有其他国家语言加入该系统&lt;span&gt;(系统变化的部分&lt;/span&gt;) ；&lt;/p&gt;
&lt;p&gt; 2.技术方案实现&lt;/p&gt;
&lt;p&gt;关于技术方案实现，我们可以采用下图中的三种方式之一。&lt;/p&gt;
&lt;p&gt;为了更好地叙述委托，我们分别实现三种技术方案，并找出它们的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118195533271-87638373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.1 一般实现&lt;/p&gt;
&lt;p&gt;Code（控制台程序）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('70dc0a1b-d379-45fd-83d0-4e2427d38836')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_70dc0a1b-d379-45fd-83d0-4e2427d38836&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_70dc0a1b-d379-45fd-83d0-4e2427d38836&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('70dc0a1b-d379-45fd-83d0-4e2427d38836',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_70dc0a1b-d379-45fd-83d0-4e2427d38836&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Console.WriteLine(GetGreetingContens(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Console.WriteLine(GetGreetingContens(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alan_beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Console.WriteLine(GetGreetingContens(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Linda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Russian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据用户名和语言，获取问候语&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetGreetingContens(&lt;span&gt;string&lt;/span&gt; UserName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Language)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;New 一个GreetToUsers对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然，你也可以使用switch开发语句来代替如下的if......else......&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; greetToUsers.ChinesePeople(UserName);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; greetToUsers.EnglishPeople(UserName);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抱歉,当前系统只支持汉语与英语（Sorry, the current system only supports Chinese and English.）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; Result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118102930568-216809380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118110743131-897859983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2用接口实现&lt;/p&gt;
&lt;p&gt;如上，我们分析了方案一中的问题，为了更好地解决方案一存在的问题，我们采用面向接口编程的形式来实现。&lt;/p&gt;
&lt;p&gt;2.2.1  什么是面向接口编程？&lt;/p&gt;
&lt;p&gt;面向接口编程，主要是解决软件架构设计中“动静问题”，即封装不变(静)，剥离变化(抽出变化)。&lt;/p&gt;
&lt;p&gt; Code:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cbda05cd-27cc-416a-a345-70c43b20e7ba')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_cbda05cd-27cc-416a-a345-70c43b20e7ba&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cbda05cd-27cc-416a-a345-70c43b20e7ba&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cbda05cd-27cc-416a-a345-70c43b20e7ba',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cbda05cd-27cc-416a-a345-70c43b20e7ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             GreetToChineseUsers greetToChinesUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToChineseUsers();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             GreetToEnglishUsers greetToEnglishUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToEnglishUsers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             GreetToOtherUsers greetToOtherUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToOtherUsers();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinse Users&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             IGreetToUsers iGreetToChineseUsers =&lt;span&gt; greetToChinesUsers;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Console.WriteLine(iGreetToChineseUsers.CountryPeople(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English Users&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             IGreetToUsers iGreetToEnglishUsers =&lt;span&gt; greetToEnglishUsers;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Console.WriteLine(iGreetToEnglishUsers.CountryPeople(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alan_beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Other Users&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             IGreetToUsers iGreetToOtherUsers =&lt;span&gt; greetToOtherUsers;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             Console.WriteLine(iGreetToOtherUsers.CountryPeople(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Linda&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Russian&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;              
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;系统输出问候语(变化的部分，语言为变化因子)&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGreetToUsers 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; CountryPeople(&lt;span&gt;string&lt;/span&gt; UserName,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Language);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;汉语用户类&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToChineseUsers:IGreetToUsers
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;  CountryPeople(&lt;span&gt;string&lt;/span&gt; UserName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Language)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;英语用户类&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToEnglishUsers : IGreetToUsers
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CountryPeople(&lt;span&gt;string&lt;/span&gt; UserName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Language)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他用户类&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToOtherUsers : IGreetToUsers
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CountryPeople(&lt;span&gt;string&lt;/span&gt; UserName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Language)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118114627553-1296961633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;(1)如上，我们将变化因子&quot;语言&quot;剥离出来，形成接口，以后只要每增加一个语言，只需实现接口即可，满足了OCP原则，基本解决了方案一中存在的问题；&lt;/p&gt;
&lt;p&gt;(2)如上代码只是为了演示面向接口编程这个功能，并不完善，感兴趣的读者，可自行完善（如将语言定义为枚举类型等）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118115202615-594759680.png&quot; alt=&quot;&quot; width=&quot;61&quot; height=&quot;74&quot;/&gt;方案二中的代码，细心的读者会发现，Main方法中new了三个对象，假若以后系统有300门语言，那岂不New 300个类，这样的话，也不利于代码维护呀，怎么解决这个问题呢？(&lt;span&gt;提示一下，采用设计模式抽象工厂即可解决该问题&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;2.3 &lt;span&gt;用委托实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这里，没接触过委托的读者，先跳过这部分，往下读，看完&lt;span&gt;（三）怎样使用委托(How to use)&lt;/span&gt;后，再来看本部分。&lt;/p&gt;
&lt;p&gt; Code&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4dfa6a2e-1db9-4ff9-971c-1e7fe38e3ddd')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_4dfa6a2e-1db9-4ff9-971c-1e7fe38e3ddd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4dfa6a2e-1db9-4ff9-971c-1e7fe38e3ddd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4dfa6a2e-1db9-4ff9-971c-1e7fe38e3ddd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4dfa6a2e-1db9-4ff9-971c-1e7fe38e3ddd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据语言判断，传递哪个方法的参数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入用户名------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; UserName =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入语言------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; Language =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------输出结果------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;               Console.WriteLine(GetGreetingContents(UserName, greetToUsers.ChinesePeople));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                Console.WriteLine(GetGreetingContents(UserName, greetToUsers.EnglishPeople));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;               Console.WriteLine(GetGreetingContents(UserName, greetToUsers.OtherPeople));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;           Console.Read();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetGreetingContents(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName,DelegateGetGreeting delegateGetGreeting)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegateGetGreeting(UserName);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义委托&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; Result&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118201859115-916934128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.3 分析上述三种实现方案的关系&lt;/p&gt;
&lt;p&gt;通过上诉三种方式的比较，我们容易得出委托的如下结论：&lt;/p&gt;
&lt;p&gt;(1)抽象方法，屏蔽方法细节，调用只需传递方法名字即可；&lt;/p&gt;
&lt;p&gt;(2)能够实现程序的解耦，松耦合（在方案一中，GetGreetingContens方法体内new了GreetToUsers对象，强耦合）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118222000678-1611590289.png&quot; alt=&quot;&quot; width=&quot;996&quot; height=&quot;566&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3)委托一般扮演中间者的角色，这功能在委托事件中体现非常明显(&lt;span&gt;第二部分 事件 &lt;/span&gt;将详细论述)&lt;/p&gt;
&lt;p&gt;如我们在租房子时，可以直接找房东(技术实现的一般方法，强耦合，让租房者和房东直接联系)，也可找中介(技术实现的委托，松耦合，租房者通过中介来与房东联系)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118223632209-730599794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.4 委托背景概述&lt;/p&gt;
&lt;p&gt;委托的重要产生背景，就是事件驱动模型(关于什么是事件和事件驱动，在本文&lt;span&gt;第二部份 事件&lt;/span&gt;&lt;span&gt; 论述)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二） 委托定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 用delegate关键字定义委托（注意，委托是没有方法体的，类似接口里面的方法），在定义委托前，必须明确两个问题：&lt;/p&gt;
&lt;p&gt;1.委托将要绑定的方法；&lt;/p&gt;
&lt;p&gt;2.委托的形参类型，形参个数和委托的返回值必须与将要绑定的方法的形参类型，形参个数和返回值一致；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）相关概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;委托涉及的相关概念有函数指针，类型安全性、事件、Lambda表达式等&lt;/p&gt;
&lt;p&gt;1.函数指针：在C++中，指针的一个类别，主要指向函数（变量指针，主要指向变量地址），可以把C#中的委托理解为函数指针；&lt;/p&gt;
&lt;p&gt;2.类型安全性：在C++中，我们都知道指针是类型不安全的(返回值，返回类型和什么时候返回，这些都是未知的)，而委托是类型安全的；&lt;/p&gt;
&lt;p&gt;3.事件：可以把事件理解为委托的一种特例(在&lt;span&gt;本文第二部份 事件&lt;/span&gt;&lt;span&gt; 论述&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;4.Lambda表达式：委托与Lambd表达式相结合，实现高效编程，与Jquery的“较少代码&lt;span&gt;做更多的事&lt;/span&gt;”类似，委托与Lambda，Linq相结合，使较短代码就能实现比较复杂的功能(在本篇文章中不讲解Lambda与Lambda树，将在后续文章中讲解)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（四）委托组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大致分为两部分：声明委托和注册方法(也叫绑定方法)&lt;/p&gt;
&lt;p&gt;1.声明委托&lt;/p&gt;
&lt;p&gt;用delegate声明；&lt;/p&gt;
&lt;p&gt;2.绑定方法&lt;/p&gt;
&lt;p&gt;绑定具体方法，传递方法名称；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（五） 委托种类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;委托种类，一般分为多播委托和单播委托&lt;/p&gt;
&lt;p&gt;1.单播委托：绑定单个方法&lt;/p&gt;
&lt;p&gt;2.绑定多个方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（六） 委托操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.绑定方法&lt;/p&gt;
&lt;p&gt;2.解绑方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二  委托能解决什么问题(Can do)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.避免核心方法中存在大量的if....else....语句(或swich开关语句)；&lt;/p&gt;
&lt;p&gt;2.满足程序设计的OCP原则；&lt;/p&gt;
&lt;p&gt;3.使程序具有扩展性；&lt;/p&gt;
&lt;p&gt;4.绑定事件；&lt;/p&gt;
&lt;p&gt;5.结合Lambda表达式，简化代码，高效编程；&lt;/p&gt;
&lt;p&gt;6.实现程序的松耦合(解耦)，这个在事件(event)中体现比较明显；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三  怎么使用委托(How to use)（本篇文章不谈匿名委托，匿名委托具体内容，将在Lambda章节讲解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）委托的基本构成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通常地，使用委托的步骤与使用类的步骤是一样的。大致分为两步：定义委托和绑定方法（传递方法）&lt;/p&gt;
&lt;p&gt;1.定义委托&lt;/p&gt;
&lt;p&gt;用delegate关键字定义委托（注意，委托是没有方法体的，类似接口里面的方法），在定义委托前，必须明确两个问题：&lt;/p&gt;
&lt;p&gt;(1).委托将要绑定的方法；&lt;/p&gt;
&lt;p&gt;(2).委托的形参类型，形参个数和委托的返回值必须与将要绑定的方法的形参类型，形参个数和返回值一致；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;  委托返回类型  委托名(形参)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：如上我们委托将要表示系统输出的问候语&lt;/p&gt;
&lt;p&gt;a.委托将要绑定的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GreetContents;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.由如上方法可看出，方法的返回类型为string,方法有一个string类型的形参，在定义委托时，与其保持一致即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义委托&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt; UserName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.绑定方法&lt;/p&gt;
&lt;p&gt;使用委托时，将方法名字作为参数传递给委托即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; GetGreetingContents(UserName, greetToUsers.ChinesePeople)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（二）委托绑定方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.绑定单个方法&lt;/p&gt;
&lt;p&gt;绑定单个方法，将单个方法名字传给委托即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1b707de4-6f4d-45f3-878a-b263cd4696ca')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_1b707de4-6f4d-45f3-878a-b263cd4696ca&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1b707de4-6f4d-45f3-878a-b263cd4696ca&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1b707de4-6f4d-45f3-878a-b263cd4696ca',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b707de4-6f4d-45f3-878a-b263cd4696ca&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据语言判断，传递哪个方法的参数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入用户名------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; UserName =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入语言------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; Language =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------输出结果------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            DelegateGetGreeting DGG;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定单个方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.ChinesePeople;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                Console.WriteLine(GetGreetingContents(UserName, DGG));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.EnglishPeople;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                Console.WriteLine(GetGreetingContents(UserName, DGG));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.OtherPeople;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                Console.WriteLine(GetGreetingContents(UserName, DGG));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另一种不太规范写法：不用GetGreetingContents(string UserName,DelegateGetGreeting delegateGetGreeting)方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c5a503a6-8e0c-4f0f-a0d8-66a72c14389d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c5a503a6-8e0c-4f0f-a0d8-66a72c14389d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c5a503a6-8e0c-4f0f-a0d8-66a72c14389d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c5a503a6-8e0c-4f0f-a0d8-66a72c14389d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c5a503a6-8e0c-4f0f-a0d8-66a72c14389d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据语言判断，传递哪个方法的参数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入用户名------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; UserName =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------请输入语言------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; Language =&lt;span&gt; Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;------------输出结果------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            DelegateGetGreeting DGG;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定单个方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.ChinesePeople;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                Console.WriteLine(DGG(UserName));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Language == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;English&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.EnglishPeople;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                Console.WriteLine(DGG(UserName));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 DGG =&lt;span&gt; greetToUsers.OtherPeople;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                Console.WriteLine(DGG(UserName));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;之所以不规范，主要是在项目中，不利于代码的模块化。&lt;/p&gt;
&lt;p&gt;2.绑定多个方法（多播委托）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：绑定多个方法时，委托范围类型必须为void类型，否则只返回最后一个绑定的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 绑定多个方法，采用 += 绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c0951df7-80ba-4dec-8de7-5c79a536294f')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_c0951df7-80ba-4dec-8de7-5c79a536294f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c0951df7-80ba-4dec-8de7-5c79a536294f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c0951df7-80ba-4dec-8de7-5c79a536294f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c0951df7-80ba-4dec-8de7-5c79a536294f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              
&lt;span&gt;10&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            DelegateGetGreeting DGG;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定多个方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             DGG =&lt;span&gt; greetToUsers.ChinesePeople;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             DGG +=&lt;span&gt; greetToUsers.EnglishPeople;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             DGG(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义委托&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;    
&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3.解绑方法&lt;/p&gt;
&lt;p&gt;解载绑定的方法，采用 -= 解绑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d1dbc447-185a-41ab-a50e-898114bb4bd0')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d1dbc447-185a-41ab-a50e-898114bb4bd0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d1dbc447-185a-41ab-a50e-898114bb4bd0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d1dbc447-185a-41ab-a50e-898114bb4bd0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d1dbc447-185a-41ab-a50e-898114bb4bd0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              
&lt;span&gt;10&lt;/span&gt;             GreetToUsers greetToUsers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            DelegateGetGreeting DGG;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定多个方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             DGG =&lt;span&gt; greetToUsers.ChinesePeople;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             DGG +=&lt;span&gt; greetToUsers.EnglishPeople;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解绑ChinesePeople方法&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             DGG-=&lt;span&gt; greetToUsers.ChinesePeople;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             DGG(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义委托&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（三）委托机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 将如下代码通过反汇编工具.NET Reflector反汇编&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('62317589-784e-4a9e-a843-90afa8d9148f')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_62317589-784e-4a9e-a843-90afa8d9148f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62317589-784e-4a9e-a843-90afa8d9148f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('62317589-784e-4a9e-a843-90afa8d9148f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62317589-784e-4a9e-a843-90afa8d9148f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             GreetToUsers GTU = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             DelegateGreet DG = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelegateGreet();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DG.delegateGetGreeting = GTU.ChinesePeople;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             DG.delegateGetGreeting +=&lt;span&gt; GTU.ChinesePeople;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             DG.delegateGetGreeting +=&lt;span&gt; GTU.EnglishPeople;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             DG.GreetUser(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DelegateGreet
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托变量为public,破坏了类的封装性&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DelegateGetGreeting delegateGetGreeting;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虽然Event论定义为public，但其还是私有变量，只能通过+=，或-=访问
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public event DelegateGetGreeting EventGreet;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GreetUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;EventGreet?.Invoke(UserName);&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            delegateGetGreeting(UserName);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  
&lt;span&gt;65&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;反汇编&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180119015529365-1561991452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 分析:&lt;/p&gt;
&lt;p&gt;1.三个核心方法：BeginInvoke,EndInvoke和Invoke&lt;/p&gt;
&lt;p&gt;(1)使用Invoke完成一个委托方法的封送，就类似于使用SendMessage方法来给界面线程发送消息，是一个同步方法。也就是说在Invoke封送的方法被执行完毕前，Invoke方法不会返回，从而调用者线程将被阻塞。&lt;/p&gt;
&lt;p&gt;(2使用BeginInvoke方法封送一个委托方法，类似于使用PostMessage进行通信，这是一个异步方法。也就是该方法封送完毕后马上返回，不会等待委托方法的执行结束，调用者线程将不会被阻塞。但是调用者也&lt;/p&gt;
&lt;p&gt;可以使用EndInvoke方法或者其它类似WaitHandle机制等待异步操作的完成。&lt;/p&gt;
&lt;p&gt;总结：但是在内部实现上，Invoke和BeginInvoke都是用了PostMessage方法，从而避免了SendMessage带来的问题。而Invoke方法的同步阻塞是靠WaitHandle机制来完成的。&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;最近浏览一篇文章，也讲得不错：http://blog.csdn.net/goodshot/article/details/6157529&lt;/p&gt;
&lt;p&gt;要想深入了解，请参照《CLR Via C#》，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二部分  事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于事件(event),将会从如下四个角度来分析.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.什么是事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.事件能解决什么问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.怎么使用事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.事件机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180118232543771-131566618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一  什么是事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 谈到委托，必提事件，事件本质是对委托的封装，对外提供add_EventName(对应+=)和remove_EventName(对应-=)访问，从而实现类的封装性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.种类&lt;/p&gt;
&lt;p&gt;强类型事件和弱类型事件&lt;/p&gt;
&lt;p&gt;2.一些用处&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)WebForm控件的Click事件。做过WebForm开发的朋友，可能对事件是非常熟悉的，如拖一个Button，双击，就自动在后台生成Button的Click事件，如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理：在Windows运用程序中，Button类提供了Click事件，其本质就是委托，当我们触发Click事件时，调用的处理程序方法需要参数，其参数就是由委托类型来定义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180119000530693-1941781522.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2)设计模式发布/订阅。事件是基于委托的，为委托提供了一种发布/订阅机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180119000732803-913759854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 事件能解决哪些问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.将公有的委托变量定义为私有变量，从而满足类的封装性原则；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.具有委托具有的作用；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三 如何使用事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.声明委托&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt; UserName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.声明事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与委托声明一样，只不过多了一个关键字event&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; DelegateGetGreeting EventGreet;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.时间注册方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事件注册方法与委托注册方法是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DelegateGreet DG= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelegateGreet();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DG.delegateGetGreeting = GTU.ChinesePeople;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册方法&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; DG.EventGreet+=&lt;span&gt; GTU.ChinesePeople;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; DG.EventGreet += GTU.EnglishPeople;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.调用事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用定义事件的方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
DG.GreetUser(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('859fab00-4d8b-408e-b3ef-17c526aeb39b')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_859fab00-4d8b-408e-b3ef-17c526aeb39b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_859fab00-4d8b-408e-b3ef-17c526aeb39b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('859fab00-4d8b-408e-b3ef-17c526aeb39b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_859fab00-4d8b-408e-b3ef-17c526aeb39b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateDemo
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              
&lt;span&gt;10&lt;/span&gt;             GreetToUsers GTU = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GreetToUsers();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             DelegateGreet DG= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelegateGreet();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DG.delegateGetGreeting = GTU.ChinesePeople;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             DG.EventGreet+=&lt;span&gt; GTU.ChinesePeople;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             DG.EventGreet +=&lt;span&gt; GTU.EnglishPeople;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             DG.GreetUser(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DelegateGreet
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DelegateGetGreeting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托变量为public,破坏了类的封装性
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public DelegateGetGreeting delegateGetGreeting;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虽然Event论定义为public，但其还是私有变量，只能通过+=，或-=访问&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; DelegateGetGreeting EventGreet;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GreetUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             EventGreet?&lt;span&gt;.Invoke(UserName);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;delegateGetGreeting(UserName);&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本问候类和方法&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GreetToUsers
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Chinese People&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChinesePeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserName;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;English People&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EnglishPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; GreetContents = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + UserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            Console.WriteLine(GreetContents);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非英非汉&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OtherPeople(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorrry,当前系统只支持汉语与英语&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;    
&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;四 事件机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 事件的本质就是委托，向外提供两个访问方法add_EventName(对应+=)和remove-EventName(对应-=)，我们通过.NET Reflector反汇编工具来查看，到底是不是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180119014636771-132839996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;【01】C#高级编程（第七版）  （Christian Nagel,Bill Evjen和Jay Glynn 编著，李铭 译，黄静 审校）&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 18 Jan 2018 18:09:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8300103.html</dc:identifier>
</item>
<item>
<title>Hyperledger Fabric Model——超级账本组成模型 - Aberic</title>
<link>http://www.cnblogs.com/aberic/p/8312829.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aberic/p/8312829.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;超级账本组成模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲述Hyperledger Fabric的关键设计特性，并细述如何实现了一个全面的、可定制的企业级区块链解决方案：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;资产定义&lt;/strong&gt;——资产这里理解为任何具有货币价值的东西，它们都可以通过网络进行交易，无论是超市商品到古董车再到货币期货都属于资产。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;智能合约&lt;/strong&gt;——链码(chaincode)即Fabric的智能合约，分为系统链码和用户链码。链码的执行由事务排序划分，限制了节点类型间的信任和验证级别，并优化了网络的可伸缩性和性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;账本特征&lt;/strong&gt;——账本不可变的、共享的并且为每个通道（channel）编码了整个事务历史，还包含了类似sql的查询功能，用于高效的审计和解决争议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐私通道&lt;/strong&gt;——多通道（channel）交易的设计方案可以确保竞争的企业和受监管的行业在一个公共网络上交换资产时的高度隐私及保密性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员安全&lt;/strong&gt;——Hyperledger Fabric只允许被授权加盟的成员参与数据维护，且成员间相互认可所有的交易都会被彼此发现和跟踪。这种方式提供了一个可信的区块链网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共识机制&lt;/strong&gt;——共识策略的设定是为了达成一致的一种独特的方法，它可以实现企业间所需的灵活性和可伸缩性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;资产&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;资产可以从有形资产（如房地产和硬件）到无形资产（如合同和知识产权）。Hyperledger Fabric&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;提供了使用智能合约交易修改资产的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;资产在Hyperledger Fabric中以键-值对集合的形态存在，在通道（channel）中各本地账本可以对其状态提交变更事务。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;资产可以用二进制和/或JSON形式表示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过Hyperledger Fabric的&lt;a href=&quot;https://github.com/hyperledger/composer&quot; target=&quot;_blank&quot;&gt;Composer&lt;/a&gt;工具很容易地定义和使用Hyperledger Fabric应用程序中的资产。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;智能合约&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;智能合约是定义资产并且可以用于修改资产的事务指令的软件。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;换句话说，它就是一个通道（channel）所有的业务逻辑。智能合约制定了&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;执行读取或修改键值对以及其它状态数据库信息操作的规则。智能合约通过一个事务请求来执行&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot;&gt;对账本的当前状态数据库操作。智能合约&lt;span class=&quot;tgt&quot; data-group=&quot;0-4&quot;&gt;执行会生成一组读写集，这组读写集可以通过网络提交给排序服务节点，并由排序服务节点广播且应用到所有的对等节点上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-4&quot;&gt;账本特征&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;在Fabric中产生的所有针对数据状态变更的请求都会生成有序且不可篡改的记录存于账本中。数据&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;状态的变更是由所有参与方认可的智能合约调用事务的结果。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;每个事务都将产生一组资产键-值对，这些键值对作为创建、更新或删除等操作而同步到所有账本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;账本由区块链（区块根据hash等算法组成的链条）组成，而每一个区块中都存储有一条或一组有序的且不可篡改的记录，也就是一个状态数据库来维护当前的Fabric的状态。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;每个通道（channel）都有且仅有一个账本，在该通道（channel）中的&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;每个加盟成员的对等点都维护同一份账本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;通过使用基键（键查询）、范围查询及组合键查询等方法可对账本执行查询和更新操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;使用富查询语言的只读查询（如果使用CouchDB作为状态数据库）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;只读历史查询——通过一个键来查询账本历史记录，支持数据来源场景&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;每一条请求的结果都由通过智能合约读取的读集和智能合约写入的写集的键值的多版本组成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;每一条被提交的请求都包含提交该请求的节点的签名证书，并同时提交到排序服务节点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;同一个通道（channel）中的区块里的所有请求事务都会被排序，并且这些区块会被排序服务节点广播到该通道（channel）内的所有对等节点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;对等节点对请求事务的验证依靠背书策略并严格执行该策略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;在添加一个块之前，执行了版本控制检查，以确保被读取的资产的状态在链代码执行时间之后没有改变&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;即将执行变更的请求事务集在新增到一个区块之前必须要做一次版本验证，以确保被读取的资产状态集在本条智能合约执行时间之前没有改变过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;一旦请求事务被验证且提交，就不可篡改&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;一个通道（channel）的账本包含一个区块生成的配置策略、访问控制列表和其它相关信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;考虑到通道（channel）将会从不同的证书机构得到加密文件，因此通道（channel）中拥有成员服务提供者（MSP）实例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;隐私通道&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;Hyperledger Fabric在每个通道（channel）中都有一个不可篡改的账本，以及一个可以操纵和修改当前资产状态的智能合约（例如，更新键值对）。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;一个账本限制在一个通道（channel）的范围内——它可以在整个网络中共享（假设每个参与者都在一个公共通道（channel）上运行）——或者它也可以被私有化，只包含一组特定的参与者。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;在上述中的后一种情况下，这些参与者将创建一个单独的通道（channel），从而使他们的事务和账本隔离出来。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;为了满足即公开透明又能保护隐私的场景，智能合约只能在需要访问资产状态来执行读和写操作的对等节点上安装（换句话说，如果一个智能合约没有安装在对等节点上，它将无法调用账本暴露出去的接口）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;为了进一步混淆数据，智能合约中的值可以使用诸如AES之类的通用加密算法进行加密（在一定程度上或全部使用），然后将事务发送到排序服务，并将生成的区块追加到账本上。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;一旦加密的数据被写入到账本，它只能被拥有相应的密钥用户解密&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;成员安全&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;tgt highlight&quot; data-group=&quot;0-0&quot;&gt;Hyperledger Fabric是一个支持所有参与者都有自己的身份的交易网络。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;公钥的底层方案用于生成与组织、网络组件和最终用户或客户端应用程序绑定的加密证书。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;因此，可以在更广泛的网络和通道（channel）层次上对数据访问控制进行操作和治理。隐私和保密是最重要和最关键的问题，Hyperledger Fabric&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot;&gt;这种“被许可”的概念，再加上通道（channel）的存在和功能，有助于解决该问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;tgt highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot;&gt;共识机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;在分布式账本技术中，共识作为单一功能最近成为了一种特定算法的同义词。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;然而，共识不仅仅是简单地就事务的顺序达成一致，而且在Hyperledger Fabric中这种通过它在整个事务流中的基本作用，包括从提交请求、背书验证，到事务排序、确认和广播，这种区别显得尤为突出。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;简单地说，共识被定义为一个完整的循环，它是由一个经过验证核实的区块所包含的一组事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;当一个区块中的事务集合的顺序和结果经过所有的检查而符合策略标准时，将最终达成一致。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;这些检查和平衡发生在一个个请求事务的生命周期中，包括使用背书策略来规定哪些特定的成员必须支持某个事务类，以及系统智能合约，以确保这些策略得到执行和维护。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;在提交排序服务节点之前，这些执行验证的对等节点将使用这些系统智能合约来确保足够的背书支持，并从适当的实体中获得。&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot; data-section=&quot;0&quot; data-sentence=&quot;3&quot;&gt;此外，在任何包含事务的区块被添加进账本之前，将进行版本控制，在此期间，将对账本的当前状态进行商定或同意。&lt;span class=&quot;tgt&quot; data-group=&quot;0-4&quot; data-section=&quot;0&quot; data-sentence=&quot;4&quot;&gt;最后的检查提供了对双重开销操作（处理相同事务）和其他可能危害数据完整性的威胁的保护，并允许被执行的方法依赖非静态变量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-3&quot; data-section=&quot;0&quot; data-sentence=&quot;3&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-4&quot; data-section=&quot;0&quot; data-sentence=&quot;4&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot; data-section=&quot;0&quot; data-sentence=&quot;0&quot;&gt;除了大量的背书认可、有效性和版本控制检查之外，在事务流的各个方向上也有正在进行的身份验证。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot; data-section=&quot;0&quot; data-sentence=&quot;1&quot;&gt;访问控制列表是在通过网络实现的（排序服务下发到所有通道），并且因为一条事务请求将会通过不同的体系结构组件，所以payloads会被反复地签名、复核及验证。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot; data-section=&quot;0&quot; data-sentence=&quot;2&quot;&gt;总之，达成共识并不仅仅局限于一组交易的达成一致，而是一种包罗万象的特性，它是在交易从提案到最终广播过程中进行的持续验证的副产品。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 16:07:00 +0000</pubDate>
<dc:creator>Aberic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aberic/p/8312829.html</dc:identifier>
</item>
<item>
<title>python 浅析IO 模型 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8309118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8309118.html</guid>
<description>&lt;p&gt;协程：遇到IO操作就切换，但是什么时候切回去呢？怎么确定IO操作？&lt;/p&gt;
&lt;p&gt;       很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。&lt;/p&gt;
&lt;p&gt;     这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。&lt;br/&gt;对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题&lt;/p&gt;
&lt;p&gt;传统的编程是如下线性模式的：&lt;/p&gt;
&lt;p&gt;开始---&amp;gt;代码块A---&amp;gt;代码块B---&amp;gt;代码块C---&amp;gt;代码块D---&amp;gt;......---&amp;gt;结束&lt;/p&gt;
&lt;p&gt;每一个代码块里是完成各种各样事情的代码，但编程者知道代码块A,B,C,D...的执行顺序，唯一能够改变这个流程的是数据。输入不同的数据，根据条件语句判断，流程或许就改为A---&amp;gt;C---&amp;gt;E...---&amp;gt;结束。每一次程序运行顺序或许都不同，但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身），那你就知道接下来甚至一直到结束它的运行流程。&lt;/p&gt;
&lt;p&gt; 对于事件驱动型程序模型，它的流程大致如下：&lt;/p&gt;
&lt;p&gt;开始---&amp;gt;初始化---&amp;gt;等待&lt;/p&gt;
&lt;p&gt; 与上面传统编程模式不同，事件驱动程序在启动之后，就在那等待，等待什么呢？等待被事件触发。传统编程下也有“等待”的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。但这与下面的等待不同，传统编程的“等待”，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，也不强制用户输入或者干什么。只要某一事件发生，那程序就会做出相应的“反应”。这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。&lt;/p&gt;
&lt;p&gt;所以下面先说一下事件驱动模型&lt;/p&gt;
&lt;h2&gt;事件驱动模型&lt;/h2&gt;
&lt;h3&gt;模型说明&lt;/h3&gt;
&lt;p&gt;  在UI编程中，常常要对鼠标点击进行相应，首先如何获取鼠标点击呢？&lt;/p&gt;
&lt;p&gt;方式一：&lt;/p&gt;
&lt;p&gt;创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：&lt;/p&gt;
&lt;p&gt;1：CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这回造成很多多CPU资源浪费；如果扫描鼠标的点击的接口是阻塞的呢？&lt;/p&gt;
&lt;p&gt;2：如果是阻塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；&lt;/p&gt;
&lt;p&gt;3：如果一个循环的需要扫描的设备非常多，这又会引起响应时间的问题；&lt;/p&gt;
&lt;p&gt;所以这非常不好&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;事件驱动模型，目前大多数的UI编程都是事件驱动模型，如很多的UI平台都会提供onclick()事件。这个事件就代表鼠标按下的事件。事件驱动模型的大体思路如下：&lt;/p&gt;
&lt;p&gt;1：有一个事件（消息）队列；&lt;/p&gt;
&lt;p&gt;2：鼠标按下时，往这个队列中增加一个点击事件（消息）；&lt;/p&gt;
&lt;p&gt;3：有个循环，不断从队列中取出事件，根据不同的事件，调用不同的函数，如onclick(),onkeydown()等等&lt;/p&gt;
&lt;p&gt;4：事件（消息）一般都由各自保存的处理函数指针，这样，每个消息都有独立的处理函数；&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118123220646-225099874.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理&lt;/span&gt;&lt;/strong&gt;。另外两种常见的编程范式是（单线程）同步以及多线程编程。 &lt;/p&gt;
&lt;h3&gt;模型概念&lt;/h3&gt;
&lt;p&gt;事件驱动模型一般是由事件收集器、事件发送器和事件处理器三部分组成基本单元组成。&lt;/p&gt;
&lt;p&gt;让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118124030115-718268011.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;模型总结&lt;/h3&gt;
&lt;p&gt;1：要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多数是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断的检查这个条件，直到条件满足，这是很浪费CPU时间的，而事件驱动的程序，则有机会释放CPU从而进入睡眠态（注意是有机会，当然程序也可以自行决定不释放CPU），当事件触发时被操作系统唤醒，这样就能更加有效地使用CPU。&lt;/p&gt;
&lt;p&gt;２：再说什么是事件驱动的程序，一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接受并选择一个要处理的事件，第二个部分就是事件的处理过程，程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序就会因为查询事件队列失败而进入到睡眠状况，从而释放CPU。&lt;/p&gt;
&lt;p&gt;３：事件驱动的程序，必定会直接或者简介拥有一个事件队列，用于存储未能及时处理的事件。&lt;/p&gt;
&lt;p&gt;４：事件驱动的程序行为，完全受外部输出的事件控制，所以，事件驱动的系统中，存在大量的这样的程序，并以事件作为主要的通信方式。&lt;/p&gt;
&lt;p&gt;５：事件驱动的程序，还有一个最大的好处，就是可以按照一定得顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。&lt;/p&gt;
&lt;p&gt;６：目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。&lt;/p&gt;
&lt;p&gt; 7：事件驱动的监听事件是由操作系统调用的cpu来完成的&lt;/p&gt;
&lt;h3&gt;模型应用&lt;/h3&gt;
&lt;h4&gt;一、select库&lt;/h4&gt;
&lt;p&gt;　　select库是各个版本的linux和windows平台都支持的基本事件驱动模型库，并且在接口的定义上也基本相同，只是部分参数的含义略有差异。&lt;/p&gt;
&lt;p&gt;　　使用select库的一般步骤：创建所关注事件的描述集合。对于一个描述符，可以关注其上面的读事件、写事件以及异常发生事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。&lt;/p&gt;
&lt;p&gt;　　其次，调用底层提供的select（）函数，等待事件的发生。select的阻塞与是否设置非阻塞的IO是没有关系的。&lt;/p&gt;
&lt;p&gt;　　然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有响应的时间发生，如果有，则进行处理。&lt;/p&gt;
&lt;p&gt;nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。&lt;/p&gt;
&lt;p&gt;可以使用--with-select_module和--without-select_module两个参数，强制nginx是否编译该库。&lt;/p&gt;
&lt;p&gt;举一个EchoServer的例子，客户端发送任何内容，服务端会原模原样返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import socket
import select
from Queue import Queue

#AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。
#SOCK_STREAM指定使用面向流的TCP协议，如果要使用面向数据包的UCP协议，就指定SOCK_DGRAM。
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False)
#设置监听的ip和port
server_address = ('localhost', 1234)
server.bind(server_address)
#设置backlog为5，client向server发起connect，server accept后建立长连接，
#backlog指定排队等待server accept的连接数量，超过这个数量，server将拒绝连接。
server.listen(5)
#注册在socket上的读事件
inputs = [server]
#注册在socket上的写事件
outputs = []
#注册在socket上的异常事件
exceptions = []
#每个socket有一个发送消息的队列
msg_queues = {}
print &quot;server is listening on %s:%s.&quot; % server_address
while inputs:
     #第四个参数是timeout，可选，表示n秒内没有任何事件通知，就执行下面代码
     readable, writable, exceptional = select.select(inputs, outputs, exceptions)
     for sock in readable:
         #client向server发起connect也是读事件，server accept后产生socket加入读队列中
         if sock is server:
             conn, addr = sock.accept()
             conn.setblocking(False)
             inputs.append(conn)
             msg_queues[conn] = Queue()
             print &quot;server accepts a conn.&quot;
         else:
             #读取client发过来的数据，最多读取1k byte。
             data = sock.recv(1024)
             #将收到的数据返回给client
             if data:
                 msg_queues[sock].put(data)
                 if sock not in outputs:
                     #下次select的时候会触发写事件通知，写和读事件不太一样，前者是可写就会触发事件，并不一定要真的去写
                     outputs.append(sock)
             else:
                 #client传过来的消息为空，说明已断开连接
                 print &quot;server closes a conn.&quot;
                 if sock in outputs:
                     outputs.remove(sock)
                 inputs.remove(sock)
                 sock.close()
                 del msg_queues[sock]
     for sock in writable:
         if not msg_queues[sock].empty():
             sock.send(msg_queues[sock].get_nowait())
         if msg_queues[sock].empty():
             outputs.remove(sock)
     for sock in exceptional:
         inputs.remove(sock)
         if sock in outputs:
             outputs.remove(sock)
         sock.close()
         del msg_queues[sock]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;select有3个缺点：&lt;br/&gt;1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。&lt;br/&gt;2. 每次调用select后，都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。&lt;br/&gt;这点从python的例子里看不出来，因为python select api更加友好，直接返回就绪的socket列表。事实上linux内核select api返回的是就绪socket数目：&lt;br/&gt;&lt;code&gt;int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);&lt;/code&gt;&lt;br/&gt;3. fd数量有限，默认1024。&lt;/p&gt;
&lt;h4&gt;二、poll库&lt;/h4&gt;
&lt;p&gt;　　poll库，作为linux平台上的基本事件驱动模型，Windows平台不支持poll库。&lt;/p&gt;
&lt;p&gt;　　使用poll库的一般过程是：与select的基本工作方式是相同的，都是先创建一个关注事件的描述符集合，再去等待这些事件的发生，然后在轮询描述符集合，检查有没有事件发生，如果有，就进行处理。&lt;/p&gt;
&lt;p&gt;　　与select的主要区别是select需要为读事件、写事件、异常事件分别创建一个描述符的集合，因此在轮询的时候，需要分别轮询这三个集合。而poll库只需创建一个集合，在每个描述符对应的结构上分别设置读事件，写事件和异常事件，最后轮询的时候可以同时检查这三种事件是否发生。是select库优化的实现。&lt;/p&gt;
&lt;p&gt;nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。&lt;/p&gt;
&lt;p&gt;可以使用--with-poll_module和--without-poll_module两个参数，强制nginx是否编译该库。&lt;/p&gt;
&lt;p&gt;poll解决了select的第三个缺点，fd数量不受限制，但是失去了select的跨平台特性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import select
import socket
import sys
import Queue

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False)
server_address = ('localhost', 1234)
server.bind(server_address)
server.listen(5)
print 'server is listening on %s port %s' % server_address
msg_queues = {}
timeout = 1000 * 60
#POLLIN: There is data to read
#POLLPRI: There is urgent data to read
#POLLOUT: Ready for output
#POLLERR: Error condition of some sort
#POLLHUP: Hung up
#POLLNVAL: Invalid request: descriptor not open
READ_ONLY = select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR
READ_WRITE = READ_ONLY | select.POLLOUT
poller = select.poll()
#注册需要监听的事件
poller.register(server, READ_ONLY)
#文件描述符和socket映射
fd_to_socket = { server.fileno(): server}
while True:
     events = poller.poll(timeout)
     for fd, flag in events:
         sock = fd_to_socket[fd]
         if flag &amp;amp; (select.POLLIN | select.POLLPRI):
             if sock is server:
                 conn, client_address = sock.accept()
                 conn.setblocking(False)
                 fd_to_socket[conn.fileno()] = conn
                 poller.register(conn, READ_ONLY)
                 msg_queues[conn] = Queue.Queue()
             else:
                 data = sock.recv(1024)
                 if data:
                     msg_queues[sock].put(data)
                     poller.modify(sock, READ_WRITE)
                 else:
                     poller.unregister(sock)
                     sock.close()
                     del msg_queues[sock]
         elif flag &amp;amp; select.POLLHUP:
             poller.unregister(sock)
             sock.close()
             del msg_queues[sock]
         elif flag &amp;amp; select.POLLOUT:
             if not msg_queues[sock].empty():
                 msg = msg_queues[sock].get_nowait()
                 sock.send(msg)
             else:
                 poller.modify(sock, READ_ONLY)
         elif flag &amp;amp; select.POLLERR:
             poller.unregister(sock)
             sock.close()
             del msg_queues[sock]
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;三、epoll库&lt;/h4&gt;
&lt;p&gt;　　epoll库是Nginx服务器支持的高性能事件之一，它是公认的非常优秀的时间驱动模型，和poll和select有很大的不同，属于poll库的一个变种，他们的处理方式都是创建一个待处理事件列表，然后把这个事件列表发送给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。如果这样的描述符在比较多的应用中，效率就显得低下了，epoll是描述符列表的管理交给内核负责，一旦某种事件发生，内核会把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表，epoll库得到事件列表，就开始进行事件处理了。&lt;/p&gt;
&lt;p&gt;epoll的用法与poll几乎一样&lt;/p&gt;
&lt;p&gt;epoll解决了select的三个缺点，是目前最好的IO多路复用解决方案。&lt;/p&gt;
&lt;h4&gt;四、其他事件驱动模型&lt;/h4&gt;
&lt;p&gt;　　kqueue模型 用于FreeBSD 4.1及以上版本 OpenBSD2.9、NetBSD2.0及Mac os X平台上。都是通过避免轮询操作提供效率。该模型同时支持条件触发（也叫水平触发，只要满足条件就触发一个事件）和边缘触发（每个状态变化时，就触发一个事件）&lt;/p&gt;
&lt;p&gt;　　/dev/poll 主要用在unix衍生平台的高效事件驱动模型，主要在solaris7 11/99及以上版本 HP/UX11.22以上版本等&lt;/p&gt;
&lt;p&gt;　　eventport 模型，用于支持solaris 10及以上版本平台的高效事件驱动模型。&lt;/p&gt;
&lt;h2 id=&quot;二selectpollepoll异步ioio-多路复用&quot;&gt; IO多路复用&lt;/h2&gt;
&lt;p&gt;     前面是用协程实现的IO阻塞自动切换，那么协程又是怎么实现的，在原理是是怎么实现的。如何去实现事件驱动的情况下IO的自动阻塞的切换，这个学名叫什么呢？ =&amp;gt; IO多路复用 &lt;br/&gt;比如socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。 &lt;br/&gt;　 &lt;br/&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 &lt;/p&gt;
&lt;h3&gt;IO模型准备&lt;/h3&gt;
&lt;p&gt;在进行解释之前，首先得说明下面几个概念，用户空间和内核空间，进程切换，进程的阻塞，文件描述符，缓存I/O。&lt;/p&gt;
&lt;h4&gt;用户空间和内核空间&lt;/h4&gt;
&lt;p&gt;现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 &lt;br/&gt;操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 &lt;br/&gt;为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。 &lt;br/&gt;针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。&lt;/p&gt;
&lt;h4&gt;进程切换&lt;/h4&gt;
&lt;p&gt;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 &lt;br/&gt;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：&lt;/p&gt;
&lt;p&gt;保存处理机上下文，包括程序计数器和其他寄存器。&lt;/p&gt;
&lt;p&gt;更新PCB信息。&lt;/p&gt;
&lt;p&gt;把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。&lt;/p&gt;
&lt;p&gt;选择另一个进程执行，并更新其PCB。&lt;/p&gt;
&lt;p&gt;更新内存管理的数据结构。&lt;/p&gt;
&lt;p&gt;恢复处理机上下文。 &lt;br/&gt;注：总而言之就是很耗资源的&lt;/p&gt;
&lt;h4&gt;进程的阻塞&lt;/h4&gt;
&lt;p&gt;        正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。&lt;/p&gt;
&lt;h4&gt;文件描述符fd&lt;/h4&gt;
&lt;p&gt;     文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 &lt;br/&gt;     文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。&lt;/p&gt;
&lt;h4&gt;缓存I/O&lt;/h4&gt;
&lt;p&gt;     缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;缓存 I/O 的缺点： &lt;/p&gt;
&lt;p&gt;数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。&lt;/p&gt;
&lt;p&gt;    首先，内核不能信任任何用户空间的指针。必须对用户空间的指针指向的数据进行验证。如果只做验证不做拷贝的话，那么在随后的运行中要随时受到其它进／线程可能修改用户空间数据的威胁。所以必须做拷贝。（有人提到在 copy 过程中数据依然可以被修改。是的，但是这种修改不能称为「篡改」。因为这种修改是在「合法性检查」之前发生的，影响的是用户进程的正确性，而不是内核对数据的验证。copy 只保证最后被使用的数据是被验证的数据，至于有没有 race 去破坏被传入的数据本身的正确性不在内核责任之内。要注意，「合法性」不等于「正确性」。）其次，上面说的是 Linux 的具体实现。Linux 中内核空间和用户空间共享线性地址，也就是 cr3 不变。但是从逻辑上来说，内核和用户空间完全可以是不同的两套地址空间。OS X 就是用这种方式让 32-bit kernel 运行 64-bit app 的。参见 地址空间划分（一）。所以从设计角度来说，应该让代码能通用兼顾这种逻辑上的考虑。如果考虑考内核和用户空间不能共享线性地址，那么数据拷贝就是必要的&lt;/p&gt;


&lt;p&gt;           同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。&lt;br/&gt;本文讨论的背景是Linux环境下的network IO。 &lt;/p&gt;
&lt;p&gt;Stevens在文章中一共比较了五种IO Model：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;               blocking IO
&lt;ul&gt;&lt;li&gt;    nonblocking IO&lt;/li&gt;
&lt;li&gt;    IO multiplexing&lt;/li&gt;
&lt;li&gt;    signal driven IO&lt;/li&gt;
&lt;li&gt;    asynchronous IO&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。&lt;br/&gt;再说一下IO发生时涉及的对象和步骤。&lt;br/&gt;      对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：&lt;br/&gt; 1 等待数据准备 (Waiting for the data to be ready)&lt;br/&gt; 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)&lt;br/&gt;记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。&lt;/p&gt;
&lt;h3&gt; blocking IO （阻塞IO）&lt;/h3&gt;
&lt;p&gt;在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118151352318-907202394.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。&lt;br/&gt;所以，blocking IO的特点就是在IO执行的两个阶段都被block了。&lt;/p&gt;
&lt;h3&gt;non-blocking IO（非阻塞IO）&lt;/h3&gt;
&lt;p&gt;linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118151503146-870520871.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。&lt;br/&gt;所以，用户进程其实是需要不断的主动询问kernel数据好了没有。&lt;/p&gt;
&lt;p&gt; 注意：&lt;/p&gt;
&lt;p&gt;      在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，&lt;/p&gt;
&lt;p&gt;      也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。&lt;/p&gt;
&lt;h3&gt;IO multiplexing（IO多路复用）&lt;/h3&gt;
&lt;p&gt; IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118151608115-1462252397.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。&lt;br/&gt;这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）&lt;br/&gt;在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。&lt;/p&gt;
&lt;p&gt;注意1：select函数返回结果中如果有文件可读了，那么进程就可以通过调用accept()或recv()来让kernel将位于内核中准备到的数据copy到用户区。&lt;/p&gt;
&lt;p&gt;注意2: select的优势在于可以处理多个连接，不适用于单个连接&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Asynchronous I/O（异步IO）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;linux下的asynchronous IO其实用得很少。先看一下它的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118151923693-2054814331.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。&lt;/p&gt;
&lt;h3&gt;各个IO Model的比较&lt;/h3&gt;
&lt;p&gt; 到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。&lt;br/&gt;先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。&lt;/p&gt;
&lt;p&gt;在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：&lt;br/&gt;    &lt;strong&gt;A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;&lt;br/&gt;    An asynchronous I/O operation does not cause the requesting process to be blocked;&lt;/strong&gt; &lt;br/&gt;      两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。&lt;/p&gt;
&lt;p&gt;       注意：由于咱们接下来要讲的select，poll，epoll都属于IO多路复用，而IO多路复用又属于同步的范畴，故，epoll只是一个伪异步而已。&lt;/p&gt;
&lt;p&gt;各个IO Model的比较如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118155555881-970735316.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。&lt;/p&gt;
&lt;p&gt;五种IO模型比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180118155624584-777775173.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;select poll epoll IO多路复用介绍&lt;/h3&gt;
&lt;h4&gt;首先列一下，select,poll,epoll三者的区别&lt;/h4&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;select&lt;/span&gt;&lt;/strong&gt; &lt;/h4&gt;
&lt;p&gt;        select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。 &lt;br/&gt;       select目前几乎在所有的平台上支持 &lt;br/&gt;　 &lt;br/&gt;        select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。 &lt;br/&gt;　 &lt;br/&gt;         另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。&lt;/p&gt;
&lt;h4&gt;poll&lt;/h4&gt;
&lt;p&gt;它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。 &lt;br/&gt;一般也不用它，相当于过渡阶段&lt;/p&gt;
&lt;h4&gt;epoll&lt;/h4&gt;
&lt;p&gt;      直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll。被公认为Linux2.6下性能最好的多路I/O就绪通知方法。windows不支持 &lt;/p&gt;&lt;p&gt;     没有最大文件描述符数量的限制。 &lt;br/&gt;     比如100个连接，有两个活跃了，epoll会告诉用户这两个两个活跃了，直接取就ok了，而select是循环一遍。 &lt;/p&gt;
&lt;p&gt;     epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。 &lt;br/&gt;另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。 &lt;/p&gt;
&lt;p&gt;所以市面上上见到的所谓的异步IO，比如nginx、Tornado、等，我们叫它异步IO，实际上是IO多路复用。&lt;/p&gt;
&lt;h4&gt;select与epoll&lt;/h4&gt;
&lt;p&gt;         首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。&lt;br/&gt;        不管是文件，还是套接字，还是管道，我们都可以把他们看作流。&lt;br/&gt;        之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假&lt;br/&gt;定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是&lt;br/&gt;服务器还没有把数据传回来），这时候该怎么办？&lt;br/&gt;          阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干&lt;br/&gt;（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话&lt;br/&gt;（假定一定能叫醒你）。&lt;br/&gt;      非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂&lt;br/&gt;个电话：“你到了没？”&lt;br/&gt;       很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。&lt;br/&gt;       大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，&lt;br/&gt;就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。&lt;/p&gt;&lt;p&gt;       为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为&lt;br/&gt;了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进&lt;br/&gt;行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。&lt;br/&gt;假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。&lt;br/&gt;        假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变&lt;br/&gt;到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。&lt;br/&gt;但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写&lt;br/&gt;入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候&lt;br/&gt;会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。&lt;br/&gt;       假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从&lt;br/&gt;长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”&lt;br/&gt;      也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告&lt;br/&gt;诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。&lt;br/&gt;       这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四&lt;br/&gt;个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是&lt;br/&gt;什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。&lt;/p&gt;&lt;p&gt;     然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多&lt;br/&gt;个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。&lt;br/&gt;      于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞&lt;br/&gt;模式再此不予讨论）：&lt;br/&gt;while true {&lt;br/&gt;for i in stream[]; {&lt;br/&gt;if i has data&lt;br/&gt;read until unavailable&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为&lt;br/&gt;如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻&lt;br/&gt;塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。&lt;/p&gt;&lt;p&gt;       为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不&lt;br/&gt;过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻&lt;br/&gt;塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可&lt;br/&gt;以把“忙”字去掉了）。代码长这样:&lt;br/&gt;while true {&lt;br/&gt;select(streams[])&lt;br/&gt;for i in streams[] {&lt;br/&gt;if i has data&lt;br/&gt;read until unavailable&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;        于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知&lt;br/&gt;道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，&lt;br/&gt;找出能读出数据，或者写入数据的流，对他们进行操作。&lt;br/&gt;      但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次&lt;br/&gt;说了这么多，终于能好好解释epoll了&lt;br/&gt;     epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我&lt;br/&gt;们。此时我们对这些流的操作都是有意义的。&lt;br/&gt;     在讨论epoll的实现细节之前，先把epoll的相关操作列出：&lt;br/&gt;     epoll_create 创建一个epoll对象，一般epollfd = epoll_create()&lt;br/&gt;epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件&lt;br/&gt;比如&lt;br/&gt;epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回&lt;br/&gt;epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回&lt;br/&gt;epoll_wait(epollfd,...)等待直到注册的事件发生&lt;br/&gt;（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。&lt;br/&gt;而epoll只关心缓冲区非满和缓冲区非空事件）。&lt;br/&gt;一个epoll模式的代码大概的样子是：&lt;br/&gt;while true {&lt;br/&gt;active_stream[] = epoll_wait(epollfd)&lt;br/&gt;for i in active_stream[] {&lt;br/&gt;read or write till unavailable&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;举个例子:&lt;br/&gt;select:&lt;br/&gt;班里三十个同学在考试,谁先做完想交卷都要通过按钮来活动,他按按钮作为老师的我桌子上的灯就会变红.&lt;br/&gt;一旦灯变红,我(select)我就可以知道有人交卷了,但是我并不知道谁交的,所以,我必须跟个傻子似的轮询&lt;br/&gt;地去问:嘿,是你要交卷吗?然后我就可以以这种效率极低地方式找到要交卷的学生,然后把它的卷子收上来.&lt;/p&gt;&lt;p&gt;epoll:&lt;br/&gt;这次再有人按按钮,我这不光灯会亮,上面还会显示要交卷学生的名字.这样我就可以直接去对应学生那收卷就&lt;br/&gt;好了.当然,同时可以有多人交卷.&lt;/p&gt;
&lt;h3&gt;IO多路复用的触发方式&lt;/h3&gt;
&lt;p&gt;    在linux的IO多路复用中有水平触发,边缘触发两种模式,这两种模式的区别如下:&lt;/p&gt;&lt;p&gt;    水平触发:如果文件描述符已经就绪可以非阻塞的执行IO操作了,此时会触发通知.允许在任意时刻重复检测IO的状态,&lt;br/&gt;没有必要每次描述符就绪后尽可能多的执行IO.select,poll就属于水平触发.&lt;/p&gt;&lt;p&gt;    边缘触发:如果文件描述符自上次状态改变后有新的IO活动到来,此时会触发通知.在收到一个IO事件通知后要尽可能&lt;br/&gt;多的执行IO操作,因为如果在一次通知中没有执行完IO那么就需要等到下一次新的IO活动到来才能获取到就绪的描述&lt;br/&gt;符.信号驱动式IO就属于边缘触发.&lt;/p&gt;&lt;p&gt;    epoll既可以采用水平触发,也可以采用边缘触发.&lt;/p&gt;&lt;p&gt;    大家可能还不能完全了解这两种模式的区别,我们可以举例说明:一个管道收到了1kb的数据,epoll会立即返回,此时&lt;br/&gt;读了512字节数据,然后再次调用epoll.这时如果是水平触发的,epoll会立即返回,因为有数据准备好了.如果是边&lt;br/&gt;缘触发的不会立即返回,因为此时虽然有数据可读但是已经触发了一次通知,在这次通知到现在还没有新的数据到来,&lt;br/&gt;直到有新的数据到来epoll才会返回,此时老的数据和新的数据都可以读取到(当然是需要这次你尽可能的多读取).&lt;/p&gt;&lt;p&gt;下面我们还从电子的角度来解释一下:&lt;/p&gt;&lt;p&gt;水平触发:也就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要&lt;br/&gt;有数据可读(描述符就绪)那么水平触发的epoll就立即返回.&lt;/p&gt;&lt;p&gt;边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据&lt;br/&gt;可读,但是没有新的IO活动到来,epoll也不会立即返回。&lt;/p&gt;
&lt;h3&gt;举例说明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实例1(non-blocking IO)：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import time
import socket
sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sk.setsockopt
sk.bind(('127.0.0.1',6667))
sk.listen(5)
sk.setblocking(False)
while True:
    try:
        print ('waiting client connection .......')
        connection,address = sk.accept()   # 进程主动轮询
        print(&quot;+++&quot;,address)
        client_messge = connection.recv(1024)
        print(str(client_messge,'utf8'))
        connection.close()
    except Exception as e:
        print (e)
        time.sleep(4)

#############################client

import time
import socket
sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

while True:
    sk.connect(('127.0.0.1',6667))
    print(&quot;hello&quot;)
    sk.sendall(bytes(&quot;hello&quot;,&quot;utf8&quot;))
    time.sleep(2)
    break
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。&lt;/p&gt;
&lt;p&gt;　　缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。&lt;/p&gt;
&lt;p&gt;实例2(IO multiplexing):&lt;/p&gt;
&lt;p&gt;在非阻塞实例中，轮询的主语是进程，而“后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。不过，这个监听的重任通过调用select等函数交给了内核去做。IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvfrom系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。&lt;/p&gt;
&lt;h4&gt;实例2&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import socket
import select
sk=socket.socket()
sk.bind((&quot;127.0.0.1&quot;,9904))
sk.listen(5)

while True:
    r,w,e=select.select([sk,],[],[],5)
    for i in r:
        # conn,add=i.accept()
        #print(conn)
        print(&quot;hello&quot;)
    print('&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;')
    
#*************************client.py
import socket

sk=socket.socket()

sk.connect((&quot;127.0.0.1&quot;,9904))

while 1:
    inp=input(&quot;&amp;gt;&amp;gt;&quot;).strip()
    sk.send(inp.encode(&quot;utf8&quot;))
    data=sk.recv(1024)
    print(data.decode(&quot;utf8&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　请思考为什么不调用accept，会反复print？&lt;/p&gt;
&lt;p&gt;           select属于水平触发&lt;/p&gt;
&lt;h4&gt;实例3（server端并发聊天）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#***********************server.py
import socket
import select
sk=socket.socket()
sk.bind((&quot;127.0.0.1&quot;,8801))
sk.listen(5)
inputs=[sk,]
while True:
    r,w,e=select.select(inputs,[],[],5)
    print(len(r))

    for obj in r:
        if obj==sk:
            conn,add=obj.accept()
            print(conn)
            inputs.append(conn)
        else:
            data_byte=obj.recv(1024)
            print(str(data_byte,'utf8'))
            inp=input('回答%s号客户&amp;gt;&amp;gt;&amp;gt;'%inputs.index(obj))
            obj.sendall(bytes(inp,'utf8'))

    print('&amp;gt;&amp;gt;',r)

#***********************client.py

import socket
sk=socket.socket()
sk.connect(('127.0.0.1',8801))

while True:
    inp=input(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;)
    sk.sendall(bytes(inp,&quot;utf8&quot;))
    data=sk.recv(1024)
    print(str(data,'utf8'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文件描述符其实就是咱们平时说的句柄，只不过文件描述符是linux中的概念。注意，我们的accept或recv调用时即向系统发出recvfrom请求&lt;/p&gt;
&lt;p&gt;    (1)  如果内核缓冲区没有数据－－－&amp;gt;等待－－－&amp;gt;数据到了内核缓冲区，转到用户进程缓冲区；&lt;/p&gt;
&lt;p&gt;    (2) 如果先用select监听到某个文件描述符对应的内核缓冲区有了数据，当我们再调用accept或recv时，直接将数据转到用户缓冲区。&lt;/p&gt;
&lt;p&gt;思考2:  如何在某一个client端退出后，不影响server端和其它客户端正常交流&lt;/p&gt;
&lt;p&gt;linux：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
if not data_byte:
            inputs.remove(obj)
            continue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;win&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
try:
      data_byte=obj.recv(1024)
      print(str(data_byte,'utf8'))
      inp=input('回答%s号客户&amp;gt;&amp;gt;&amp;gt;'%inputs.index(obj))
      obj.sendall(bytes(inp,'utf8'))
except Exception:
      inputs.remove(obj)
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;实例4:&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
__author__ = 'Alex Li'
 
import select
import socket
import sys
import queue
 
# Create a TCP/IP socket
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False)
 
# Bind the socket to the port
server_address = ('localhost', 10000)
print(sys.stderr, 'starting up on %s port %s' % server_address)
server.bind(server_address)
 
# Listen for incoming connections
server.listen(5)
 
# Sockets from which we expect to read
inputs = [ server ]
 
# Sockets to which we expect to write
outputs = [ ]
 
message_queues = {}
while inputs:
 
    # Wait for at least one of the sockets to be ready for processing
    print( '\nwaiting for the next event')
    readable, writable, exceptional = select.select(inputs, outputs, inputs)
    # Handle inputs
    for s in readable:
 
        if s is server:
            # A &quot;readable&quot; server socket is ready to accept a connection
            connection, client_address = s.accept()
            print('new connection from', client_address)
            connection.setblocking(False)
            inputs.append(connection)
 
            # Give the connection a queue for data we want to send
            message_queues[connection] = queue.Queue()
        else:
            data = s.recv(1024)
            if data:
                # A readable client socket has data
                print(sys.stderr, 'received &quot;%s&quot; from %s' % (data, s.getpeername()) )
                message_queues[s].put(data)
                # Add output channel for response
                if s not in outputs:
                    outputs.append(s)
            else:
                # Interpret empty result as closed connection
                print('closing', client_address, 'after reading no data')
                # Stop listening for input on the connection
                if s in outputs:
                    outputs.remove(s)  #既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉
                inputs.remove(s)    #inputs中也删除掉
                s.close()           #把这个连接关闭掉
 
                # Remove message queue
                del message_queues[s]
    # Handle outputs
    for s in writable:
        try:
            next_msg = message_queues[s].get_nowait()
        except queue.Empty:
            # No messages waiting so stop checking for writability.
            print('output queue for', s.getpeername(), 'is empty')
            outputs.remove(s)
        else:
            print( 'sending &quot;%s&quot; to %s' % (next_msg, s.getpeername()))
            s.send(next_msg)
    # Handle &quot;exceptional conditions&quot;
    for s in exceptional:
        print('handling exceptional condition for', s.getpeername() )
        # Stop listening for input on the connection
        inputs.remove(s)
        if s in outputs:
            outputs.remove(s)
        s.close()
 
        # Remove message queue
        del message_queues[s]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;实例5&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。
# 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。
#server端


import select
import socket
import queue

server = socket.socket()
server.bind(('localhost',9000))
server.listen(1000)

server.setblocking(False)  # 设置成非阻塞模式，accept和recv都非阻塞
# 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们
# BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。
msg_dic = {}
inputs = [server,]  # 交给内核、select检测的列表。
# 必须有一个值，让select检测，否则报错提供无效参数。
# 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接
outputs = []  # 你往里面放什么，下一次就出来了

while True:
    readable, writeable, exceptional = select.select(inputs, outputs, inputs)  # 定义检测
    #新来连接                                        检测列表         异常（断开）
    # 异常的也是inputs是： 检测那些连接的存在异常
    print(readable,writeable,exceptional)
    for r in readable:
        if r is server:  # 有数据，代表来了一个新连接
            conn, addr = server.accept()
            print(&quot;来了个新连接&quot;,addr)
            inputs.append(conn)  # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了
            # inputs = [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了
            # 如果server活动，则来了新连接，conn活动则来数据
            msg_dic[conn] = queue.Queue()  # 初始化一个队列，后面存要返回给这个客户端的数据
        else:
            try :
                data = r.recv(1024)  # 注意这里是r，而不是conn，多个连接的情况
                print(&quot;收到数据&quot;,data)
                # r.send(data) # 不能直接发，如果客户端不收，数据就没了
                msg_dic[r].put(data)  # 往里面放数据
                outputs.append(r)  # 放入返回的连接队列里
            except ConnectionResetError as e:
                print(&quot;客户端断开了&quot;,r)
                if r in outputs:
                    outputs.remove(r) #清理已断开的连接
                inputs.remove(r) #清理已断开的连接
                del msg_dic[r] ##清理已断开的连接

    for w in writeable:  # 要返回给客户端的连接列表
        data_to_client = msg_dic[w].get()  # 在字典里取数据
        w.send(data_to_client)  # 返回给客户端
        outputs.remove(w)  # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。

    for e in exceptional:  # 如果连接断开，删除连接相关数据
        if e in outputs:
            outputs.remove(e)
        inputs.remove(e)
        del msg_dic[e]


#*************************client
import socket
client = socket.socket()

client.connect(('localhost', 9000))

while True:
    cmd = input('&amp;gt;&amp;gt;&amp;gt; ').strip()
    if len(cmd) == 0 : continue
    client.send(cmd.encode('utf-8'))
    data = client.recv(1024)
    print(data.decode())

client.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;实例6&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
import selectors
import socket

sel = selectors.DefaultSelector()

def accept(sock, mask):
    conn, addr = sock.accept()  # Should be ready
    print('accepted', conn, 'from', addr)
    conn.setblocking(False)
    sel.register(conn, selectors.EVENT_READ, read)

def read(conn, mask):
    data = conn.recv(1000)  # Should be ready
    if data:
        print('echoing', repr(data), 'to', conn)
        conn.send(data)  # Hope it won't block
    else:
        print('closing', conn)
        sel.unregister(conn)
        conn.close()

sock = socket.socket()
sock.bind(('localhost', 1234))
sock.listen(100)
sock.setblocking(False)
sel.register(sock, selectors.EVENT_READ, accept)

while True:
    events = sel.select()
    for key, mask in events:
        callback = key.data
        callback(key.fileobj, mask)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;注：本文系老师讲课的课后总结和学习，参考博文http://www.cnblogs.com/yuanchenqi/articles/5722574.html&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:58:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8309118.html</dc:identifier>
</item>
<item>
<title>浅析nodeJS中的Crypto模块，包括hash算法，HMAC算法，加密算法知识，SSL协议 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/8313598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/8313598.html</guid>
<description>&lt;p&gt;node.js的crypto在0.8版本，这个模块的主要功能是加密解密。&lt;/p&gt;
&lt;p&gt;node利用 OpenSSL库（&lt;a href=&quot;https://www.openssl.org/source/&quot; target=&quot;_blank&quot;&gt;https://www.openssl.org/source/&lt;/a&gt;）来实现它的加密技术，&lt;/p&gt;
&lt;p&gt;这是因为OpenSSL已经是一个广泛被采用的加密算法。它包括了类似MD5 or SHA-1 算法，这些算法你可以利用在你的应用中。&lt;/p&gt;
&lt;p&gt;作为工程师，对于openssl一个开源的软件库，你没有用过，你应该听过这个名字。openssl是使用C/C++实现算法的。&lt;/p&gt;
&lt;p&gt;Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。&lt;/p&gt;

&lt;p&gt;以下你可以看到内容：&lt;/p&gt;
&lt;p&gt;一、首先看一下hash算法&lt;/p&gt;
&lt;p&gt;二、HMAC算法&lt;/p&gt;
&lt;p&gt;三、加密算法知识&lt;/p&gt;
&lt;p&gt;四、SSL协议&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、首先看一下hash算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.1创建hash实例&lt;/p&gt;
&lt;p&gt;通过crypto.createHash()函数,，创建一个hash实例，但是需要调用md5，sha1，sha256，sha512算法来实现实例的创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const hash = crypto.createHash('md5');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样带有md5加密算法的hash实例创建成功。可以把md5换成sha1护着其他的。&lt;/p&gt;
&lt;p&gt;MD5是最常用的，但是他有一定的碰撞的问题，你可以使用更新的sha1算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2加密数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过hash.update('需要机密的字符串')函数，实现加密。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash.update('需要加密的字符串')；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样数据就加密好了，但是我怎么看到我加密的数据。&lt;/p&gt;
&lt;p&gt;注意：hash.update()方法是有记忆功能的，实际就是将&lt;strong&gt;字符串相加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3获取hash对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过hash.digest()函数实现字符串加密返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hash.digest()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接运行 hash.digest(); 出现了乱码，因为它默认返回的是2进制的数据;&lt;/p&gt;
&lt;p&gt;所以使用的是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hash.digest('hex');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以以16进制的形式显示出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;md5.digest();这个方法被调用了，hash 对象就被清空了是不能被重用的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2、md5加密的栗子&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const crypto = require('crypto'&lt;span&gt;);
const hash &lt;/span&gt;= crypto.createHash('md5'&lt;span&gt;);

hash.update(&lt;/span&gt;'&lt;span&gt;&lt;strong&gt;HEllo World&lt;/strong&gt;&lt;/span&gt;'&lt;span&gt;);
hash.update(&lt;/span&gt;'&lt;span&gt;&lt;strong&gt;hhhhhhh&lt;/strong&gt;&lt;/span&gt;'&lt;span&gt;);

console.log(hash.digest(&lt;/span&gt;'hex'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用node index.js方式运行，因为crypto需要用到nodeJS的核心模块。(注：&lt;span&gt;&lt;strong&gt;crypto.js是我们自己编写的js文件&lt;/strong&gt;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180118204422834-986407410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
28210daaea2a2a4dcc6d29f775671854
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、md5的update()函数由记忆功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是crypto.js代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const crypto = require('crypto'&lt;span&gt;);
const hash &lt;/span&gt;= crypto.createHash('md5'&lt;span&gt;);

hash.update(&lt;/span&gt;'&lt;span&gt;&lt;strong&gt;HEllo Worldhhhhhhh&lt;/strong&gt;&lt;/span&gt;'&lt;span&gt;);

console.log(hash.digest(&lt;/span&gt;'hex'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行，结果一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180118204558771-1917898959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、sha1的加密算法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const crypto = require('crypto'&lt;span&gt;);
const hash &lt;/span&gt;= crypto.createHash('&lt;span&gt;&lt;strong&gt;sha1&lt;/strong&gt;&lt;/span&gt;'&lt;span&gt;);

hash.update(&lt;/span&gt;'HEllo Worldhhhhhhh'&lt;span&gt;);

console.log(hash.digest(&lt;/span&gt;'hex'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180118204727443-1312343707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
f67592206f0fe61cb3123cabf8d9dbe160a7f54a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、sha256的加密算法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const crypto = require('crypto'&lt;span&gt;);
const hash &lt;/span&gt;= crypto.createHash('sha256'&lt;span&gt;);

hash.update(&lt;/span&gt;'HEllo Worldhhhhhhh'&lt;span&gt;);

console.log(hash.digest(&lt;/span&gt;'hex'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180118204929115-1439517533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
300bfc4b9f19bcfc6a8fac7ea54e4e8d31b0cea544c23f9e4cea21dc94c3ea22
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6、sha512的加密算法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const crypto = require('crypto'&lt;span&gt;);
const hash &lt;/span&gt;= crypto.createHash('&lt;strong&gt;&lt;span&gt;sha512&lt;/span&gt;&lt;/strong&gt;'&lt;span&gt;);

hash.update(&lt;/span&gt;'HEllo Worldhhhhhhh'&lt;span&gt;);

console.log(hash.digest(&lt;/span&gt;'hex'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/900740/201801/900740-20180118205111584-1596755376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
062e805ad0c342151275dec7c25f4bc15fca747f70395cda6b41d6fce7c5954628e0f42587f5d6d3d6312ae353f72208c9ca6bfdd7b953dbb51317db79abfc34
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、HMAC算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;翻译之后的就是&quot;哈希运算消息认证码&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用哈希算法，以一个密钥和一个消息为输入，生成一个加密串作为输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HMAC可以有效防止一些类似md5的彩虹表等攻击，比如一些常见的密码直接MD5存入数据库的，可能被反向破解。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
crypto.createHmac(algorithm, key)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法返回和createHash一样，返回一个HMAC的实例，有update和digest方法。&lt;/p&gt;

&lt;p&gt;但是这个key怎么获&lt;span&gt;取呢？这个要说一下SSL，&lt;strong&gt;利用opensll命令来创建一个key.pem&lt;/strong&gt;，这个key.pem就是key，就是这个秘钥。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这样我们就生成了一个秘钥key.pem&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; crypto = require('crypto'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fs = require('fs'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pem = fs.readFileSync('key.pem'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = pem.toString('ascii'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hmac = crypto.createHmac('sha1'&lt;span&gt;, key);

hmac.update(&lt;/span&gt;'foo'&lt;span&gt;);

hmac.digest(&lt;/span&gt;'hex'&lt;span&gt;);
&lt;/span&gt;'7b058f2f33ca28da3ff3c6506c978825718c7d42'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;先通过 fs.readFileSync 方法读取了key.pem密钥，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后将它转为ascii码，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后通过 createHmac(‘sha1’, key) 方法获得HMAC实例，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后执行update和digest，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成一串密钥字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：由于key的不同，所以同样的字符串’foo’经过hmac加密后生成的16进制字符串也是不同的，从而更加保障了数据的安全性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、加密算法知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是加密算法？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加密算法很容易理解，就是把明文变成人家看不懂的东西，然后送给自己想要的送到的地方，接收方用配套的解密算法又把密文解开成明文，这样就不怕密文给人家截获而泄密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、加密算法的种类 ？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大致分为2类，一种是基于key的，一种不是基于key的。 不基于key的算法就是消息双方都通过一定的加密和解密算法来进行通信，这种算法缺点很明显如果加密算法被破解了就泄露了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、基于key的加密算法？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;key是一个什么东西呢？随便你，可以是一个随机产生的数字，或者一个单词，啥都行，只要你用的算法认为你选来做key的东西合法就行。所以基于key的加密算法又分为2类：对称加密和不对称加密。对称加密算法的原理很容易理解，通信一方用KEK加密明文，另一方收到之后用同样的KEY来解密就可以得到明文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、不对称加密算法？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不对称加密指双方用不同的KEY加密和解密明文，通信双方都要有自己的公共密钥和私有密钥。举个例子比较容易理解，我们们假设通信双方分别是A,B. A,拥有KEY_A1,KEY_A2,其中KEY_A1是A的私有密钥，KEY_A2是A的公共密钥。 B,拥有KEY_B1,KEY_B2,其中KEY_B1是B的私有密钥，KEY_B2是B的公共密钥。公共密钥和私有密钥的特点是，经过其中任何一把加密过的明文，只能用另外一把才能够解开。也就是说&lt;strong&gt;经过KEY_A1加密过的明文，只有KEY_A2才能够解密&lt;/strong&gt;，反之亦然。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1不对称加密算法通信过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1.1公共秘钥交换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A--------&amp;gt;;KEY_A2------------&amp;gt;B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A&amp;lt;--------KEY_B2&amp;lt;------------A&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个过程叫做公共密钥交换，老外管这叫keyexchange。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1.2公共秘钥解密&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后A和B就分别用对方的公共密钥解密，用自己的私有密钥加密。 一般公共密钥是要发布出去的，这就是SSL使用的验证机制（注意不是数据传输机制）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用的不对称加密一般有RSA,DSA,DH等。我们一般使用RSA。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、SSL协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 SSL简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;openssl的命令很多，整理一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSL(SecureSocketLayer)是netscape公司提出的主要用于web的安全通信标准，.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TLS(TransportLayerSecurity)是IETF的TLS工作组在SSL3.0基础之上提出的安全通信标准，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSL/TLS提供的安全机制可以保证应用层数据在互联网络传输不被监听,伪造和窜改。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、一般情况下的网络协议应用中，数据在机器中经过简单的由上到下的几次包装，就进入网络，如果这些包被截获的话，那么可以很容易的根据网络协议得到里面的数据.由网络监听工具可以很容易的做到这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、SSL就是为了加密这些数据而产生的协议，可以这么理解，它是位与应用层和 TCP/IP之间的一层，数据经过它流出的时候被加密，再往TCP/IP送，而数据从TCP/IP流入之后先进入它这一层被解密，同时它也能够验证网络连接两端的身份（根据我们之前学习的不对称加密算法只是可知）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、SSL协议包含2个子协议，一个是包协议，一个是握手协议。包协议位于握手协议更下一层，我们暂时对包协议的内容没有兴趣。SSL握手过程说简单点就是：通信双方通过不对称加密算法来协商好一个对称加密算法以及使用的key，然后用这个算法加密以后所有的数据完成应用层协议的数据交换。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 SSL通信流程：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;握手一般都是由client发起的，SSL也不例外。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、client送给server它自己本身使用的ssl的version(ssl一共有三个version)，加密算法的一些配置，和一些随机产生的数据，以及其他在SSL协议中需要用到的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、server送给client它自己的SSL的version，加密算法的配置，随机产生的数据，还会用自己的私有密钥加密SERVER-HELLO信息。Server还同时把自己的证书文件给送&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;过去。同时有个可选的项目，就是server可以要求需要客户的certificate。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、client就用server送过来的certificate来验证server的身份。如果server身份验证没通过，本次通信结束。通过证书验证之后，得到server的公共密钥，解开server送来的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;被其用私有密钥加密过的SERVER-HELLO信息，看看对头与否。如果不对，说明对方只有该server的公共密钥而没有私有密钥，必是假的。通信告吹。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4、client使用到目前为止所有产生了的随机数据(sharedsecret)，client产生本次握手中的premastersecret(这个步骤是有可能有server的参与的，由他们使用的加密算法决&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;定)，并且把这个用server的公共密钥加密，送回给server.如果server要求需要验证client,那么client也需要自己把自己的证书送过去，同时送一些自己签过名的数据过去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;RSA就是我们上一章说过的一种不对称加密算法。首先server把自己的RSA公共密钥送给client，client于是用这个key加密一个随机产生的值(这个随机产生的值就是&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;sharedsecret)，再把结果送给server.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5、Server验证完client的身份之后，然后用自己的私有密钥解密得到premastersecret然后双方利用这个premastersecret来共同协商，得到mastersecret. 6、双方用master&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一起产生真正的sessionkey,着就是他们在剩下的过程中的对称加密的key了。这个key还可以用来验证数据完整性。双方再交换结束信息。握手结束&lt;/span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:56:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/8313598.html</dc:identifier>
</item>
<item>
<title>【原】IOS兼容性之APP内fixed定位头部跳动 - 白水源</title>
<link>http://www.cnblogs.com/coder-dumeng/p/8313542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-dumeng/p/8313542.html</guid>
<description>&lt;p&gt;兼容现象：&lt;/p&gt;
&lt;p&gt;　　在App的webview里边，我们有时候会在页面里写自定义头部，会使用到fixed定位，我们想要的效果是，页面无论怎么滑动，这个自定义的头部始终是固定在顶部的，但是在ios 11以上的版本里边，问题来了，当我们快速滑动页面的时候，页面滚动期间，这个fixed定位的头部会随着页面的滑动滑上去，等到上滑动作执行完毕时，头部才又出现。这个问题在安卓及ios11以下的版本都是没有的。&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;　　直接将这个页面控制在一个盒子里边去滑动，头部相对于这个盒子进行绝对定位。但是这样写带来的副作用就是除类名为wrapper的元素外，其他元素的scrollTop属性值总是0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;bottom:0;-webkit-overflow-scrolling:touch;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;head&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Head&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;wrapper&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;position:absolute;top;0;left:0;right:0;bottom:0;overflow-y:scroll;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;para&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
              ...
              &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;para&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:31:00 +0000</pubDate>
<dc:creator>白水源</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-dumeng/p/8313542.html</dc:identifier>
</item>
<item>
<title>Python 解析构建数据大杂烩 -- csv、xml、json、excel - sherlockChen</title>
<link>http://www.cnblogs.com/sherlockChen/p/8313529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlockChen/p/8313529.html</guid>
<description>&lt;p&gt;Python 可以通过各种库去解析我们常见的数据。其中 csv 文件以纯文本形式存储表格数据，以某字符作为分隔值，通常为逗号；xml 可拓展标记语言，很像超文本标记语言 Html ，但主要对文档和数据进行结构化处理，被用来传输数据；json 作为一种轻量级数据交换格式，比 xml 更小巧但描述能力却不差，其本质是特定格式的字符串；Microsoft Excel 是电子表格，可进行各种数据的处理、统计分析和辅助决策操作，其数据格式为 xls、xlsx。接下来主要介绍通过 Python 简单解析构建上述数据，完成数据的“珍珠翡翠白玉汤”。&lt;/p&gt;


&lt;p&gt;通过标准库中的 csv 模块，使用函数 reader()、writer() 完成 csv 数据基本读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; csv
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('readtest.csv', newline='') as csvfile:
&lt;span&gt;  4&lt;/span&gt;     reader = csv.reader(csvfile)
&lt;span&gt;  5&lt;/span&gt;     for row in reader:
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(row)
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('writetest.csv', 'w', newline='') as csvfile:
&lt;span&gt;  9&lt;/span&gt;     writer = csv.writer(csvfile)
&lt;span&gt; 10&lt;/span&gt;     writer.writerrow(&quot;&lt;span&gt;onetest&lt;/span&gt;&quot;)
&lt;span&gt; 11&lt;/span&gt;     writer.writerows(&quot;&lt;span&gt;someiterable&lt;/span&gt;&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 reader() 返回迭代器， writer() 通过 writerrow() 或 writerrows() 写入一行或多行数据。两者还可通过参数 dialect 指定编码方式，默认以 excel 方式，即以逗号分隔，通过参数 delimiter 指定分隔字段的单字符，默认为逗号。&lt;/p&gt;
&lt;p&gt;在 Python3 中，打开文件对象 csvfile ，需要通过 newline='' 指定换行处理，这样读取文件时，新行才能被正确地解释；而在 Python2 中，文件对象 csvfile 必须以二进制的方式 'b' 读写，否则会将某些字节（0x1A）读写为文档结束符（EOF），导致文档读取不全。&lt;/p&gt;
&lt;p&gt;除此之外，还可使用 csv 模块中的类 DictReader()、DictWriter() 进行字典方式读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; csv
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('readtest.csv', newline='') as csvfile:
&lt;span&gt;  4&lt;/span&gt;     reader = csv.DictReader(csvfile)
&lt;span&gt;  5&lt;/span&gt;     for row in reader:
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(row['first_test'], row['last_test'])
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('writetest.csv', 'w', newline='') as csvfile:
&lt;span&gt;  9&lt;/span&gt;     fieldnames = ['first_test', 'last_test']
&lt;span&gt; 10&lt;/span&gt;     writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
&lt;span&gt; 11&lt;/span&gt;     writer.writeheader()
&lt;span&gt; 12&lt;/span&gt;     writer.writerow({'first_test': 'hello', 'last_test': 'wrold'})
&lt;span&gt; 13&lt;/span&gt;     writer.writerow({'first_test': 'Hello', 'last_test': 'World'})
&lt;span&gt; 14&lt;/span&gt;     #writer.writerows([{'first_test': 'hello', 'last_test': 'wrold'}, {'first_test': 'Hello', 'last_test': 'World'}])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 DictReader() 返回有序字典，使得数据可通过字典的形式访问，键名由参数 fieldnames 指定，默认为读取的第一行。&lt;/p&gt;
&lt;p&gt;DictWriter() 必须指定参数 fieldnames 说明键名，通过 writeheader() 将键名写入，通过 writerrow() 或 writerrows() 写入一行或多行字典数据。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;通过标准库中的 xml.etree.ElementTree 模块，使用 Element、ElementTree 完成 xml 数据的读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; from xml.etree.ElementTree &lt;span&gt;import&lt;/span&gt; Element, ElementTree
&lt;span&gt;  2&lt;/span&gt; root = Element('language')
&lt;span&gt;  3&lt;/span&gt; root.set('&lt;span&gt;name&lt;/span&gt;', 'python')
&lt;span&gt;  4&lt;/span&gt; direction1 = Element('direction')
&lt;span&gt;  5&lt;/span&gt; direction2 = Element('direction')
&lt;span&gt;  6&lt;/span&gt; direction3 = Element('direction')
&lt;span&gt;  7&lt;/span&gt; direction4 = Element('direction')
&lt;span&gt;  8&lt;/span&gt; direction1.text = 'Web'
&lt;span&gt;  9&lt;/span&gt; direction2.text = 'Spider'
&lt;span&gt; 10&lt;/span&gt; direction3.text = 'BigData'
&lt;span&gt; 11&lt;/span&gt; direction4.text = 'AI'
&lt;span&gt; 12&lt;/span&gt; root.append(direction1)
&lt;span&gt; 13&lt;/span&gt; root.append(direction2)
&lt;span&gt; 14&lt;/span&gt; root.append(direction3)
&lt;span&gt; 15&lt;/span&gt; root.append(direction4)
&lt;span&gt; 16&lt;/span&gt; #&lt;span&gt;import&lt;/span&gt; itertools
&lt;span&gt; 17&lt;/span&gt; #root.extend(chain(direction1, direction2, direction3, direction4))
&lt;span&gt; 18&lt;/span&gt; tree = ElementTree(root)
&lt;span&gt; 19&lt;/span&gt; tree.&lt;span&gt;write&lt;/span&gt;('xmltest.xml')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写 xml 文件时，通过 Element() 构建节点，set() 设置属性和相应值，append() 添加子节点，extend() 结合循环器中的 chain() 合成列表添加一组节点，text 属性设置文本值，ElementTree() 传入根节点构建树，write() 写入 xml 文件。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xml.etree.ElementTree as ET
&lt;span&gt;  2&lt;/span&gt; tree = ET.parse('xmltest.xml')
&lt;span&gt;  3&lt;/span&gt; #from xml.etree.ElementTree &lt;span&gt;import&lt;/span&gt; ElementTree
&lt;span&gt;  4&lt;/span&gt; #tree = ElementTree().parse('xmltest.xml')
&lt;span&gt;  5&lt;/span&gt; root = tree.getroot()
&lt;span&gt;  6&lt;/span&gt; tag = root.tag
&lt;span&gt;  7&lt;/span&gt; attrib = root.attrib
&lt;span&gt;  8&lt;/span&gt; text = root.text
&lt;span&gt;  9&lt;/span&gt; direction1 = root.&lt;span&gt;find&lt;/span&gt;('direction')
&lt;span&gt; 10&lt;/span&gt; direction2 = root[1]
&lt;span&gt; 11&lt;/span&gt; directions = root.&lt;span&gt;findall&lt;/span&gt;('.&lt;span&gt;//direction')&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; for direction in root.&lt;span&gt;findall&lt;/span&gt;('direction'):
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(direction.text)
&lt;span&gt; 14&lt;/span&gt; for direction in root.iter('direction'):
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(direction.text)
&lt;span&gt; 16&lt;/span&gt; root.remove(direction2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读 xml 文件时，通过 ElementTree() 构建空树，parse() 读入 xml 文件，解析映射到空树；getroot() 获取根节点，通过下标可访问相应的节点；tag 获取节点名，attrib 获取节点属性字典，text 获取节点文本；find() 返回匹配到节点名的第一个节点，findall() 返回匹配到节点名的所有节点，find()、findall() 两者都仅限当前节点的一级子节点，都支持 xpath 路径提取节点；iter() 创建树迭代器，遍历当前节点的所有子节点，返回匹配到节点名的所有节点；remove() 移除相应的节点。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，还可通过 &lt;a href=&quot;https://docs.python.org/3/library/xml.sax.html&quot; target=&quot;_blank&quot;&gt;xml.sax&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/3/library/xml.dom.minidom.html&quot; target=&quot;_blank&quot;&gt;xml.dom.minidom&lt;/a&gt; 去解析构建 xml 数据。其中 sax 是基于事件处理的；dom 是将 xml 数据在内存中解析成一个树，通过对树的操作来操作 xml；而 ElementTree 是轻量级的 dom ，具有简单而高效的API，可用性好，速度快，消耗内存少，但生成的数据格式不美观，需要手动格式化。&lt;/p&gt;


&lt;p&gt;通过标准库中的 json 模块，使用函数 dumps()、loads() 完成 json 数据基本读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt; json
&lt;span&gt;  2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; json.&lt;span&gt;dumps&lt;/span&gt;(['foo', {'bar': ('baz', None, 1.0, 2)}])
&lt;span&gt;  3&lt;/span&gt; '[&quot;&lt;span&gt;foo&lt;/span&gt;&quot;, {&quot;&lt;span&gt;bar&lt;/span&gt;&quot;: [&quot;&lt;span&gt;baz&lt;/span&gt;&quot;, null, 1.0, 2]}]'
&lt;span&gt;  4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; json.&lt;span&gt;loads&lt;/span&gt;('[&quot;&lt;span&gt;foo&lt;/span&gt;&quot;, {&quot;&lt;span&gt;bar&lt;/span&gt;&quot;:[&quot;&lt;span&gt;baz&lt;/span&gt;&quot;, null, 1.0, 2]}]')
&lt;span&gt;  5&lt;/span&gt; ['foo', {'bar': ['baz', None, 1.0, 2]}]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;json.dumps() 是将 obj 序列化为 json 格式的 str，而 json.loads() 是反向操作。其中 dumps() 可通过参数 ensure_ascii 指定是否使用 ascii 编码，默认为 True；通过参数  separators=(',', ':') 指定 json 数据格式中的两种分隔符；通过参数 sort_keys 指定是否使用排序，默认为 False。&lt;/p&gt;
&lt;p&gt;除此之外，还可使用 json 模块中的函数 dump()、load() 进行 json 数据读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; json
&lt;span&gt;  2&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('jsontest.json', 'w') as jsonfile:
&lt;span&gt;  3&lt;/span&gt;     json.&lt;span&gt;dump&lt;/span&gt;(['foo', {'bar': ('baz', None, 1.0, 2)}], jsonfile)
&lt;span&gt;  4&lt;/span&gt; with &lt;span&gt;open&lt;/span&gt;('jsontest.json') as jsonfile:
&lt;span&gt;  5&lt;/span&gt;     json.&lt;span&gt;load&lt;/span&gt;(jsonfile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;功能与 dumps()、loads() 相同，但接口不同，需要与文件操作结合，多传入一个文件对象。&lt;/p&gt;


&lt;p&gt;通过 pip 安装第三方库 xlwt、xlrd 模块，完成 excel 数据的读写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xlwt
&lt;span&gt;  2&lt;/span&gt; wbook = xlwt.Workbook(encoding='utf-8')
&lt;span&gt;  3&lt;/span&gt; wsheet = wbook.add_sheet('sheet1')
&lt;span&gt;  4&lt;/span&gt; wsheet.&lt;span&gt;write&lt;/span&gt;(0, 0, 'Hello World')
&lt;span&gt;  5&lt;/span&gt; wbook.save('exceltest.xls')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写 excel 数据时，通过 xlwt.Workbook() 指定编码格式参数 encoding 创建工作表，add_sheet() 添加表单，write() 在相应的行列单元格中写入数据，save() 保存工作表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; xlrd
&lt;span&gt;  2&lt;/span&gt; rbook = xlrd.open_workbook('exceltest.xls')
&lt;span&gt;  3&lt;/span&gt; rsheet = book.sheets()[0]
&lt;span&gt;  4&lt;/span&gt; #rsheet = book.sheet_by_index(0)
&lt;span&gt;  5&lt;/span&gt; #rsheet = book.sheet_by_name('sheet1')
&lt;span&gt;  6&lt;/span&gt; nr = rsheet.nrows
&lt;span&gt;  7&lt;/span&gt; nc = rsheet.ncols
&lt;span&gt;  8&lt;/span&gt; rv = rsheet.row_values(0)
&lt;span&gt;  9&lt;/span&gt; cv = rsheet.col_values(0)
&lt;span&gt; 10&lt;/span&gt; cell = rsheet.cell_value(0, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读 excel 数据时，通过 xlrd.open_workbook() 打开相应的工作表，可使用列表下标、表索引 sheet_by_index()、表单名 sheet_by_name() 三种方式获取表单名，nrows 获取行数，ncols 获取列数，row_values() 返回相应行的值列表，col_values() 返回相应列的值列表，cell_value() 返回相应行列的单元格值。&lt;/p&gt;


&lt;p&gt;csv：&lt;a href=&quot;https://docs.python.org/3/library/csv.html&quot; target=&quot;_blank&quot;&gt;Python3 中的 csv&lt;/a&gt;、&lt;a href=&quot;https://docs.python.org/2/library/csv.html&quot; target=&quot;_blank&quot;&gt;Python2 中的 csv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;xml：&lt;a href=&quot;https://docs.python.org/3/library/xml.etree.elementtree.html&quot; target=&quot;_blank&quot;&gt;xml.etree.elementtree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;json：&lt;a href=&quot;https://docs.python.org/3/library/json.html&quot; target=&quot;_blank&quot;&gt;Python3 中的 json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;excel：&lt;a href=&quot;https://github.com/python-excel/xlwt&quot; target=&quot;_blank&quot;&gt;github 中的 xlwt&lt;/a&gt;、&lt;a href=&quot;https://github.com/python-excel/xlrd&quot; target=&quot;_blank&quot;&gt;github 中的 xlrd&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Jan 2018 15:29:00 +0000</pubDate>
<dc:creator>sherlockChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sherlockChen/p/8313529.html</dc:identifier>
</item>
<item>
<title>Maven教程（1）--maven的下载、安装与配置 - platycoden</title>
<link>http://www.cnblogs.com/platycoden/p/8313503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/platycoden/p/8313503.html</guid>
<description>&lt;p&gt;Maven下载&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;&lt;span&gt;http://maven.apache.org/download.cgi&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118230938724-634019983.png&quot; alt=&quot;&quot; width=&quot;845&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后，解压得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231010865-1118691542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Maven&lt;span&gt;目录分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bin&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;mvn&lt;/span&gt;&lt;span&gt;运行的脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;boot&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;plexus-&lt;/span&gt;&lt;span&gt;吃辣爽死我&lt;/span&gt;&lt;span&gt;rlds&lt;/span&gt;&lt;span&gt;类加载器框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;conf&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;settings.xml&lt;/span&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lib&lt;span&gt;文件夹：含有&lt;/span&gt;&lt;span&gt;maven&lt;/span&gt;&lt;span&gt;运行时所需要的&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;类库&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;maven&lt;span&gt;安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;确认电脑上已经安装了&lt;/span&gt;&lt;span&gt;JDK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231041396-489203333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;环境变量的配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）新建环境变量&lt;/span&gt;MAVEN_HOME&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231111115-1034763447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）设置环境变量&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231138646-2068549061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编辑&lt;/span&gt;Path&lt;span&gt;，增加“&lt;/span&gt;&lt;span&gt;%MAVEN_HOME%\bin&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）新建环境变量&lt;/span&gt;&lt;span&gt;MAVEN_OPTS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231208006-765814917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常需要设置&lt;/span&gt;MAVEN_OPTS&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;-Xms128m -Xmx512m&lt;/span&gt;&lt;span&gt;，因为&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;默认的最大可用内存往往不能够满足&lt;/span&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;span&gt;运行的需要，比如在项目较大时，使用&lt;/span&gt;&lt;span&gt;Maven&lt;/span&gt;&lt;span&gt;生成项目站点需要占用大量的内存，如果没有该配置，则很容易得到&lt;/span&gt;&lt;span&gt;java.lang.OutOfMemeoryError&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;验证&lt;/span&gt;&lt;span&gt;MAVEN&lt;/span&gt;&lt;span&gt;安装成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/892404/201801/892404-20180118231300662-116108411.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Jan 2018 15:14:00 +0000</pubDate>
<dc:creator>platycoden</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/platycoden/p/8313503.html</dc:identifier>
</item>
<item>
<title>揭密微信跳一跳小游戏那些外挂 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8313488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8313488.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;张小龙：&lt;/strong&gt;这个游戏发布以后，其实它的效果有点超出我们的预期，我们自己开玩笑说，这个游戏突然变成了有史以来可能用户规模最大的一个游戏，因为它的DAU大概到了1点几亿，但同时出现了很多外挂，我没有想到这么小的一款游戏也会有那么多外挂，我朋友圈的朋友也打出了特别高的分，但是我相信不是他自己打出来的。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;1 月 15 日微信在广州召开 2018 年的微信公开课 Pro，张小龙不仅当场玩了一把跳一跳游戏并取得了900多的高分，还特别提到了跳一跳小游戏的外挂：&lt;/p&gt;

&lt;p&gt;在跳一跳这样一个小的游戏里面，如果一个用户看到里面有一堆外挂得了很高的分，对其他一些每天在练习，试图把自己的水平提高，而打一个高分的人就很不公平，他可能就没有动力继续去练习，继续超越自己个人的最高分数。所以这样一个行为，外挂行为其实会破坏整个系统的规则，并且让规则立即变得失效。&lt;/p&gt;

&lt;p&gt;所以，我们这个小游戏发布以后，我们就开始花了很多很多时间来打击外挂。&lt;/p&gt;

&lt;p&gt;本着钻研技术的学习态度，我对目前几款比较火的外挂进行了源码分析，总结出了它们的一些破解思路，其实这些作者都并非恶意，作为一个程序员，还有什么比用技术挑战规则，突破极限要有成就感呢？&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;跳一跳的游戏可以细分为两步骤：距离判断 + 按压模拟，这两步都有下面这些解决方案：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、距离判断：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 简单方案：像素点判断&lt;/p&gt;
&lt;p&gt;● 进阶方案：OpenCV 图像分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、按压模拟：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 简单方案：adb/wda 指令&lt;/p&gt;
&lt;p&gt;● 进阶方案：机械臂模拟手指点击（原创）&lt;/p&gt;

&lt;p&gt;下面逐一介绍这里的实现方法，非常有意思。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、距离判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 像素点判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该方法采用自目前最火的跳一跳小游戏「辅助程序」：&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/blob/master/wechat_jump_auto.py&quot;&gt;wechat_jump_game&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225314740-662408739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，我们先定义了「棋子」和「棋盘」，需要找到的两个目标点用橙色点标注，首先针对棋子的目标点的判断，可以这么做：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225343287-991978156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225403771-1979849632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而针对棋盘中心点的确认的思路则是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225640287-191167433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然还有一些其他方法来尽量缩小棋盘中心点的检测区域，这里简单介绍下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225705115-1679358304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果恰好跳到中心点，下一个棋盘中间会有白色点，则可以直接匹配中心点的色值，得到棋盘中心点，这种情况基本百发百中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225739646-67912366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225800303-1774352786.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但棋盘种类比较多，形状也各异，而且棋盘表面并非纯色，还有其他颜色，所以即使像素判断的代码里增加了很多特殊 case，依旧不能做到非常完美：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225828818-679581757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下，目前这个方案基本没有太大问题，但如果跳一跳游戏把背景改成了非线性渐变，或随机飘落一些物体，或棋盘表面更加复杂，那这里的算法就基本不可用了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. OpenCV 图像分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于像素点的判断低效而且不够健壮，而利用 OpenCV 计算机视觉库则可以从图像分析层面进一步简化判断逻辑提升效率，首先采用该方法的跳一跳小游戏「辅助程序」来自 wechat_jump_jump。它是这么得到棋子的位置的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225853256-18824017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225915787-361807072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接下来找棋盘的中心点，假如下一个棋盘存在白色的示意点，同样采用上面的模板匹配方法进行匹配，若匹配不上（匹配值小于某阈值，也许下个棋盘本身就是白色，所以灰度图分辨不出），则采用第二种方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118225940568-386841718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里是否准确的精髓就在于高斯滤波去除图像噪音的临界点以及 Canny 函数中阈值的设定，需要不断调整参数到最优状态。&lt;/p&gt;

&lt;p&gt;相关代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230031974-1017271424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、按压模拟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. adb/wda 指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这两个分别是针对 Android 和 iOS 的命令行工具，可以将手机和电脑连接起来，并通过命令行发送指令，指令中就包含了屏幕的截图和按压模拟。不过 iOS 配置起来稍微麻烦一点，具体操作指引可以参考 这里。其核心的命令有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230107240-1981315483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，如果嫌配置麻烦，还可以通过 Android 的 AirDrop App 或 iOS 的 QuickTime 把手机屏幕投到电脑中，然后通过 Python 的 Pillow 库来截取投屏的内容，再做进一步的图像识别工作。&lt;/p&gt;

&lt;p&gt;还有一点值得一提，按压时间这部分还是有优化的空间，前面提到了跳跃距离和按压时间基本是线性关系，但越到后面可以越发现，距离并非和按压时间绝对成线性比例，因为游戏本身不是一个纯 2D 的平面场景（2.5D），所以我们测量到的直线距离在 2.5D 场景中是有变化的，虽然影响不大，但在游戏后期棋盘越来越小，距离越来越大时，容易凸现出问题来，所以关于距离的计算有几种不同的解决：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230135256-267758978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;拟合函数的细节可以参考：&lt;/p&gt;
&lt;p&gt;1）&lt;a href=&quot;https://github.com/metowolf/JumpJumpHelper&quot;&gt;https://github.com/metowolf/JumpJumpHelper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/issues/744&quot;&gt;https://github.com/wangshub/wechat_jump_game/issues/744&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;a href=&quot;https://github.com/wangshub/wechat_jump_game/pull/841&quot;&gt;https://github.com/wangshub/wechat_jump_game/pull/841&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 机械臂模拟手指点击&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本着学术探究的态度，结合之前折腾开源硬件的经历，所以也斗胆想给跳一跳小游戏增加一点动手环节，把触摸模拟这一操作通过机械臂来物理完成，于是在万能淘宝里淘了一个一百多快钱的机械臂和部分配件，自己编写了控制代码，把按压时间传输作为机械臂按下的停留时间，想法确定后便开始购置物品：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/992994/201801/992994-20180118230216568-891559270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到货后折腾一两个晚上，最后成功搭建好了，大家看看效果（电容笔偶尔还是会触碰不良）&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://v.qq.com/x/page/s05329u9gun.html&quot; target=&quot;_blank&quot;&gt;https://v.qq.com/x/page/s05329u9gun.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反对一切使用外挂行为！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过对外挂程序源码的研读，学习到了非常多创新的思维，这也算是外挂留给代码世界的果实。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于腾讯WeTest手游安全测试团队&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;腾讯WeTest手游安全测试团队从2011年初开始对手游安全领域进行探索和技术积累，旨在通过提前发现游戏版本的安全漏洞，预警风险，打造出业界领先的手游安全测试技术方案，在工具上已经支持所有腾讯在研和运营的手游项目。团队通过使用与正式服同样的游戏客户端和服务器，模拟外挂工作室制作外挂的过程，依靠自身的技术积累来提高专业程度，持续保持漏洞的发现率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;目前提供了专家测试服务，希望通过提前发现游戏版本的安全漏洞，预警风险，帮助提高腾讯游戏的品牌和口碑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://wetest.qq.com/product/sr?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;服务目前已经对外开放，点击&lt;/span&gt;&lt;span&gt;http://wetest.qq.com/product/sr&lt;/span&gt;&lt;/a&gt;   &lt;span&gt;即可使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
















</description>
<pubDate>Thu, 18 Jan 2018 15:10:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8313488.html</dc:identifier>
</item>
</channel>
</rss>