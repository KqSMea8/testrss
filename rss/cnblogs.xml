<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网页版仿Excel效果组件--handsontable拓展运用 - 谎言让你心安</title>
<link>http://www.cnblogs.com/wbsndbf/p/8476642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbsndbf/p/8476642.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;前段时间项目需要实现网页版的excel表格功能，瞬间就想到了handsontable，为什么呢？理由如下：该UI组件功能齐全多样，展示效果也更贴近bootstrap风格，兼容所有现代浏览器和IE9+，然后开源，api相当给力。&lt;br/&gt;　　唯一美中不足的是没有中文版的api，也有些分享中文api的文章，也不完整（有就不错了，不满意自己去看官网api啊,啦啦啦~），闲言少叙，进入正文：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我们先看一下功能操作栏（红框部分为部分我们需要实现的功能）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　上图中的 input 会同步响应我们所选单元格的数据，其他的方法如图所示。&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;首先我们既然是表格，那么我们的操作对象基本都是单元格，但同时我们肯定也希望能够满足范围性操作，比如说批量修改样式。当然我们不仅需要考虑到展示效果，还需要考虑到储存和数据渲染，&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们需要的做到以下几点：所选范围、所选范围里的单元格、如何储存数据、如何通过loadData一次性加载数据（包括样式及自定义属性），带着这些问题我们去看api，我们需要找到我们需要方法以及了解如何使用它们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里附上官方api链接：https://docs.handsontable.com/pro/1.16.0/tutorial-introduction.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　阅读过程小生这里就不做赘述了（唔...一把辛酸泪），首先我们需要清楚的是，我们需要获取到被选择的单元格对象，而要获取单元格对象我们要知道所选范围（单个单元格也是一个范围，这里不需要另作判断），而要知道所选范围我们要用到  getSelected()  方法，而此方法应该在我们选择范围后触发，所以我们需要用到钩子函数：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;afterOnCellMouseDown&lt;/span&gt;,具体用法可以到api里自行查阅&lt;/p&gt;&lt;p&gt; 　　万事俱备，接下来该做什么呢？当然是做我们最爱做的事:撸代码！~&lt;/p&gt;&lt;div readability=&quot;1045&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　var&lt;/span&gt; data = [
&lt;span&gt;         [, , , , , , , , , , , , , , , , , , , , ],  
           [&lt;/span&gt;&quot;2001&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2002&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2003&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2004&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2005&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2006&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2007&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2008&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2009&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,8,6,78,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2010&quot;, 30, 15, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,52,6,3,5,3,8,6,8,5,6,56,355,6,3,66,23,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2011&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,26,3,5,26,3,5,3,8,6,8,5,56,6,35,6,3,6,23,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2012&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,666,5,8,6,3,9,6,3,5,56,3,5,3,78,6,58,55,6,6,35,6,23,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2013&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,68,6,3,9,6,3,5,26,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2014&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,26,3,5,3,8,6,58,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2015&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,29,26,3,5,6,3,5,3,78,76,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2016&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,55,6,3,5,3,8,6,28,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2017&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,43,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2018&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,62,3,29,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2019&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,48,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2020&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,68,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,345,6,3,64,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2021&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2022&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,66,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,48,38,23&lt;span&gt;]  
      ];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　汉化右键菜单：如果不需要右键菜单可以设置为false，&lt;/span&gt;&lt;/span&gt;contextMenu : false&lt;/p&gt;&lt;p&gt;　　自定义菜单及回调函数：自定义菜单也是在 contextMenu里面，格式如下（如上图中的 setAlias 设置别名，设置属性方法我们在后面再说明）：&lt;/p&gt;&lt;p&gt;　　Crow：所选单元格的行，Ccol：所选单元格的列，valT：所选单元格的值，selectRange：所选范围，selectRangeArr：所选单元格数组&lt;/p&gt;&lt;p&gt;　　获取所选区域单元格数组，当前单元格高亮：这里需要补充的一点是，handsontable本身在表格失去焦点时会移除所有当前高亮类，而我们在点击按钮修改样式时又需要所选高亮来满足我们的“心中有数”，所以这里我们需要自定义一个高亮的类，看代码：&lt;/p&gt;&lt;p&gt;　　我们可以在控制台查看一下令我们心动的 selectRange 和 selectRangeArr ：&lt;/p&gt;&lt;p&gt;　　修改单元格样式（字体样式和对齐方式）：switch条件语句在这种事件触发对象判断中用起来是相当地令人愉快..&lt;/p&gt;&lt;p&gt;　　　　1、如果对象是合并单元格，那么在赋值和修改样式上需要区别对待，看代码（具体区别请调试代码自己体会o(∩_∩)o ）；&lt;/p&gt;&lt;p&gt;　　　　2、在方法里我们可以看到运用了 &lt;span&gt;setCellMeta() &lt;span&gt;方法，单纯的前端效果我们不需要用到此方法，这里是为了便于储存和渲染数据，如此在初始化表格渲染数据的时候我们能将每一个单元格所对应的样式类名也添加进去，简而言之：每一次初始化表格我们只需要渲染一次，开心~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　自定义背景色、字体颜色、边框色：这里我们用到了插件 bootstrap-colorpicker.js  ：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　　看效果图：　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/p&gt;&lt;p&gt;　　自定义属性：假设我们现在需要给某些单元格添加任意属性，这里我们以设置别名为例，并且希望能在右键菜单中可以直接操作：&lt;/p&gt;&lt;p&gt;　　对的，此处应该有弹窗，这里小生强烈推荐用 layer.js，快准狠还高大上...这里附上 layer.js的官网地址，具体用法有空亲们可以自行琢磨：http://www.layui.com/doc/modules/layer.html，下面看设置别名回调函数：&lt;/p&gt;&lt;p&gt;　　这里需要注意的一点是，setCellMeta添加的属性是单元格的属性，而不是单元格的DOM属性，所以我们用attr或者prop方法是获取不到的（小生不可能告诉亲们当初经历了什么~），我们可以在设置完成以后将所选单元格的属性打印出来：&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这次分享到这里就结束了，希望对大家有所帮助，有疑问或者建议都可以留言交流，新年快乐，摸摸踹~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;</description>
<pubDate>Mon, 26 Feb 2018 15:16:00 +0000</pubDate>
<dc:creator>谎言让你心安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wbsndbf/p/8476642.html</dc:identifier>
</item>
<item>
<title>CSS预处理器之Less详解 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8476602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8476602.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8476602.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;css-预处理器&quot;&gt;CSS 预处理器&lt;/h2&gt;
&lt;h3 id=&quot;为什么要有-css-预处理器&quot;&gt;为什么要有 CSS 预处理器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CSS基本上是设计师的工具，不是程序员的工具&lt;/strong&gt;。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难以组织和维护。&lt;/p&gt;
&lt;p&gt;很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“&lt;strong&gt;CSS预处器&lt;/strong&gt;（CSS Preprocessor）”。&lt;/p&gt;
&lt;h3 id=&quot;什么是-css-预处理器&quot;&gt;什么是 CSS 预处理器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;是 CSS 语言的&lt;strong&gt;超集&lt;/strong&gt;，比CSS更丰满。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 预处理器定义了一种新的语言，其基本思想是：&lt;strong&gt;用一种专门的编程语言，为CSS增加了一些编程的特性&lt;/strong&gt;，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。&lt;/p&gt;
&lt;p&gt;通俗的说，&lt;strong&gt;CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件&lt;/strong&gt;，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。&lt;/p&gt;
&lt;p&gt;CSS预处理器技术已经非常成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：&lt;strong&gt;Sass（SCSS）、LESS&lt;/strong&gt;、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。&lt;/p&gt;
&lt;p&gt;到目前为止，在众多优秀的CSS预处理器语言中就属&lt;strong&gt;Sass、LESS和Stylus最优秀&lt;/strong&gt;，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。&lt;/p&gt;
&lt;h2 id=&quot;less-的介绍&quot;&gt;less 的介绍&lt;/h2&gt;
&lt;p&gt;less 是一款比较流行的&lt;strong&gt;预处理 CSS&lt;/strong&gt;，支持变量、混合、函数、嵌套、循环等特点。&lt;/p&gt;
&lt;h2 id=&quot;less-的语法&quot;&gt;less 的语法&lt;/h2&gt;
&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;less 的注释可以有两种。&lt;/p&gt;
&lt;p&gt;第一种注释：模板注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 模板注释 这里的注释转换成CSS后将会删除&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 less 要转换为 css才能在浏览器中使用。转换成 css 之后，这种注释会被删除（毕竟 css 不识别这种注释）。&lt;/p&gt;
&lt;p&gt;第二种注释：CSS 注释语法&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;
/* CSS 注释语法 转换为CSS后让然保留 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：如果在less中写注释，我们推荐写第一种注释。除非是类似于版权等内容，就采用第二种注释。&lt;/p&gt;
&lt;h3 id=&quot;定义变量&quot;&gt;定义变量&lt;/h3&gt;
&lt;p&gt;我们可以把&lt;strong&gt;重复使用或经常修改的值&lt;/strong&gt;定义为变量，在需要使用的地方引用这个变量即可。这样可以避免很多重复的工作量。&lt;/p&gt;
&lt;p&gt;（1）在less文件中，定义一个变量的格式：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@变量名: 变量值;        //格式

@bgColor: #f5f5f5;      //格式举例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）同时，在 less 文件中引用这个变量。&lt;/p&gt;
&lt;p&gt;最终，less文件的完整版代码如下：&lt;/p&gt;
&lt;p&gt;main.less：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;// 定义变量
@bgColor: #f5f5f5;

// 引用变量
body{
    background-color: @bgColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将上面的less文件编译为 css 文件后（下一段讲less文件的编译），自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f5f5f5&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用嵌套&quot;&gt;使用嵌套&lt;/h3&gt;
&lt;p&gt;在 css 中经常会用到子代选择器，效果可能是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f40&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f50&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码嵌套了很多层，写起来很繁琐。可如果用 less 的嵌套语法来写这段代码，就比较简洁。&lt;/p&gt;
&lt;p&gt;嵌套的举例如下：&lt;/p&gt;
&lt;p&gt;main.less:&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;.container {
  width: @containerWidth;

  &amp;gt; .row {
    height: 100%;
    a {
      color: #f40;

      &amp;amp;:hover {
        color: #f50;
      }

    }
  }

  div {
    width: 100px;

    .hello {
      background-color: #00f;
    }

  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面的less文件编译为 css 文件后，自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f40&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f50&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; div &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; div &lt;span class=&quot;fl&quot;&gt;.hello&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#00f&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;mixin&quot;&gt;Mixin&lt;/h3&gt;
&lt;p&gt;Mixin 的作用是把&lt;strong&gt;重复的代码&lt;/strong&gt;放到一个类当中，每次只要引用类名，就可以引用到里面的代码了，非常方便。&lt;/p&gt;
&lt;p&gt;（1）在 less 文件中定义一个类：（将重复的代码放到自定义的类中）&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;/* 定义一个类 */
.roundedCorners(@radius: 5px) {
  -moz-border-radius: @radius;
  -webkit-border-radius: @radius;
  border-radius: @radius;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，第一行里面，括号里的内容是参数：这个参数是&lt;strong&gt;缺省值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2）在 less 文件中引用上面这个类：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;#header {
  .roundedCorners;
}
#footer {
  .roundedCorners(10px);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，header 中的引用没有带参数，表示参数为缺省值； footer 中的引用带了参数，那就用这个参数。&lt;/p&gt;
&lt;h3 id=&quot;import&quot;&gt;Import&lt;/h3&gt;
&lt;p&gt;在开发阶段，我们可以将不同的样式放到多个文件中，&lt;a href=&quot;mailto:最后通过@import&quot;&gt;最后通过@import&lt;/a&gt; 的方式合并。意思就是，当出现多个 less 文件时，怎么引用它们。&lt;/p&gt;
&lt;p&gt;这个很好理解， css 文件可以有很多个，less文件也可以有很多个。&lt;/p&gt;
&lt;p&gt;（1）定义一个被引用的less文件，名为&lt;code&gt;_button1.less&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_button1.less:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;.btn{
  line-height: 100px;
  color: @btnColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS1：被引用的less文件，我们习惯在前面加&lt;strong&gt;下划线&lt;/strong&gt;，表示它是&lt;strong&gt;部分文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PS2：&lt;code&gt;_button1.less&lt;/code&gt;里可以引用&lt;code&gt;main.css&lt;/code&gt;里的自定义变量。&lt;/p&gt;
&lt;p&gt;（2）在 &lt;code&gt;main.css&lt;/code&gt; 中引用上面的 &lt;code&gt;_button1.less&lt;/code&gt;：（代码的第二行）&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@btnColor: red;

@import url(`_button1.less:');    //这里的路径写的是相对路径

body{
  width: 1024px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 上面的main.less 编译为 main.css之后，自动生成的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.btn&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;内置函数&quot;&gt;内置函数&lt;/h3&gt;
&lt;p&gt;less 里有一些内置的函数，这里讲一下 lighten 和 darken 这两个内置函数。&lt;/p&gt;
&lt;p&gt;main.less:&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;body {
  background-color: lighten(#000, 10%);   // 让黑色变亮 10%
  color: darken(#fff, 10%);               // 让白色变暗 10%
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 上面的 main.less 编译为 main.css 之后，自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#1a1a1a&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#e6e6e6&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还有什么不懂的，可以看 api 文档，在上面的第二段附上了链接。&lt;/p&gt;
&lt;h2 id=&quot;在-index.html中直接引用-less.js&quot;&gt;在 index.html中直接引用 less.js&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;做法一：写完 less文件后，将其编译为 css 文件，然后在代码中引用css文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;做法二：在代码中直接用引用 less 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;产品上线后，当然是使用做法一，因为做法二会多出编译的时间。&lt;/p&gt;
&lt;p&gt;平时开发或演示demo的时候可以用做法二。&lt;/p&gt;
&lt;p&gt;这一段，我们讲一下做法二，其实是浏览器在本地在线地把 less 文件转换为 css 文件。&lt;/p&gt;
&lt;p&gt;（1）在 less 官网下载 less.js 文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把下载好的文件放在工程文件的lib文件夹里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2143.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在 index.html 中引入 less.js 和我们自己写的 main.less。位置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;copy 红框那部分的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;link&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; rel=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;stylesheet/less&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;../main.less&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在打开的网页中，通过控制台看到效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，我们要在服务器中打开 html 文件，否则，看不到效果。&lt;/p&gt;
&lt;p&gt;这里也告诉了我们：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不提倡将 less 引入页面，因为 less 需要编译，因此你就需要再引入一个less.js, 多了一个HTTP 请求，同时当浏览器禁用了 js 你的样式就不起作用了，less 编译应该在服务端或使用 grunt 自动编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工程文件：（工程文件中，我引用的less.js版本是 2.5.3）&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;h2 id=&quot;less-的编译&quot;&gt;less 的编译&lt;/h2&gt;
&lt;p&gt;less 的编译指的是将写好的 less 文件 生成为 css 文件。&lt;/p&gt;
&lt;p&gt;less 的编译，依赖于 NodeJS 环境。因此，我们需要先安装 NodeJS。&lt;/p&gt;
&lt;h3 id=&quot;安装-node.js&quot;&gt;1、安装 Node.js&lt;/h3&gt;
&lt;p&gt;去 &lt;a href=&quot;https://nodejs.org/zh-cn/&quot;&gt;Node.js&lt;/a&gt;的官网下载安装包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一路 next 进行安装。&lt;/p&gt;
&lt;p&gt;安装完成后，配置环境变量：&lt;/p&gt;
&lt;p&gt;在 path 变量中追加安装路径：&lt;code&gt;;C:\Program Files\nodejs&lt;/code&gt;。重启资源管理器，即可生效。&lt;/p&gt;
&lt;p&gt;PS：我发现，我安装的 node.js v8.9.4 版本，已经自动添加了环境变量。&lt;/p&gt;
&lt;p&gt;在 cmd 命令行，输入&lt;code&gt;node.exe -v&lt;/code&gt;，可以查看 node.js 的版本。&lt;/p&gt;
&lt;h3 id=&quot;安装-less-的编译环境&quot;&gt;2、安装 less 的编译环境&lt;/h3&gt;
&lt;p&gt;将 &lt;a href=&quot;http://download.csdn.net/download/smyhvae/10260414&quot;&gt;npm.zip&lt;/a&gt; 解压，将解压后的文件拷贝到路径&lt;code&gt;C:\Users\smyhvae\AppData\Roaming\npm&lt;/code&gt;下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2212.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重启资源管理器（或者重启电脑）。在 cmd 中输入 &lt;code&gt;lessc&lt;/code&gt;，如果能看到下面的效果，说明 less编译环境安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你用的是 linux 系统，可以输入下面的命令安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g less&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;将-less-文件编译为-css-文件&quot;&gt;3、将 less 文件编译为 css 文件&lt;/h3&gt;
&lt;p&gt;在 less 所在的路径下，输入 &lt;code&gt;lessc xxx.less&lt;/code&gt;，即可编译成功。或者，如果输入 &lt;code&gt;lessc xxx.less &amp;gt; ..\xx.css&lt;/code&gt;，表示输出到指定路径。&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 15:01:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8476602.html</dc:identifier>
</item>
<item>
<title>Java集合中的Map接口 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8476573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8476573.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;jdk1.8.0_144　　&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　Map是Java三种集合中的一种位于java.util包中，Map作为一个接口存在定义了这种数据结构的一些基础操作，它的最终实现类有很多：HashMap、TreeMap、SortedMap等等，这些最终的子类大多有一个共同的抽象父类AbstractMap。在AbstractMap中实现了大多数Map实现公共的方法。本文介绍Map接口定义了哪些方法，同时JDK8又新增了哪些。&lt;/p&gt;
&lt;p&gt;　　Map翻译为“映射”，它如同字典一样，给定一个key值，就能直接定位value值，它的存储结构为“key : value&quot;形式，核心数据结构在Map内部定义了一个接口——Entry，这个数据结构包含了一个key和它对应的value。首先来窥探Map.Entry接口定义了哪些方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;interface Map.Entry&amp;lt;K, V&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;K getKey()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获取key值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V getValue()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获取value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V setValue(V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　存储value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean equals(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个方法我在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8445910.html&quot; target=&quot;_blank&quot;&gt;《万类之父——Object》&lt;/a&gt;中提到过，这是Object类中的方法，这两个方法通常是同时出现，也就是说要重写equals方法时为了保证不出现问题往往需要重写intCode方法。而重写equals则需要满足5个规则（自反性、对称性、传递性、一致性、非空性）。当然具体是如何重写的，此处作为接口并不做解释而是交由它的子类完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K extends Comparable&amp;lt;? super K&amp;gt;, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; comparingByKey()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V extends Comparable&amp;lt;? super V&amp;gt;&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; comparingByValue()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; comparingByKey(Comparator&amp;lt;? super K&amp;gt; cmp)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; comparingByValue(Comparator&amp;lt;? super V&amp;gt; cmp)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这四个方法放到一起是因为这都是JDK8针对Map更为简单的排序新增加的泛型方法，这里的泛型方法看似比较复杂，我们针对第一个方法先来简单回顾一下泛型方法。&lt;/p&gt;
&lt;p&gt;　　一个泛型方法的基本格式就是泛型参数列表需要定义在返回值前。这个方法的返回值返回的是Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt;，也就是说它的泛型参数列表是“&amp;lt;K extends Comparable&amp;lt;? super K&amp;gt;, V&amp;gt;”，有两个泛型参数K和V。参数K需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　既然这是JDK8为Map排序新增的方法，那它是如何使用的呢？ 不妨回忆下JDK8以前对Map是如何排序的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f74e6fcb-3e7e-488c-8ffe-6145c138fedd')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f74e6fcb-3e7e-488c-8ffe-6145c138fedd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Sort a Map by Keys.——JDK7
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map To be sorted Map.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Sorted Map.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; sortedByKeys(Map&amp;lt;String, Integer&amp;gt;&lt;span&gt; map) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;(map.entrySet());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Collections.sort(list, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(Map.Entry&amp;lt;String, Integer&amp;gt; o1, Map.Entry&amp;lt;String, Integer&amp;gt;&lt;span&gt; o2) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.getKey().compareTo(o2.getKey());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     Map&amp;lt;String, Integer&amp;gt; linkedMap = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     Iterator&amp;lt;Map.Entry&amp;lt;Strin    g, Integer&amp;gt;&amp;gt; iterator =&lt;span&gt; list.iterator();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Map.Entry&amp;lt;String, Integer&amp;gt; entry =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        linkedMap.put(entry.getKey(), entry.getValue());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; linkedMap;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从JDK7版本对Map排序的代码可以看到，首先需要定义泛型参数为Map.Entry类型的List，利用Collections.sort对集合List进行排序，再定义一个LinkedHashMap，遍历集合List中的元素放到LinkedHashMap中，也就是说并没有一个类似Collections.sort(Map, Comparator)的方法对Map集合类型进行直接排序。JDK8对此作了改进，通过Stream类对Map进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Sort a Map by Keys.——JDK8
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map To be sorted Map.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Sorted Map.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; sortedByKeys(Map&amp;lt;String, Integer&amp;gt;&lt;span&gt; map) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     Map&amp;lt;String, Integer&amp;gt; result = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     map.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEachOrdered(x -&amp;gt;&lt;span&gt; result.put(x.getKey(), x.getValue()));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可见代码量大大减少，简而言之，这四个方法是JDK8利用Stream类和Lambda表达式弥补Map所缺少的排序方法。&lt;/p&gt;
&lt;p&gt;　　comparingByKey() //利用key值进行排序，但要求key值类型需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　comparingByValue() //利用value值进行排序，但要求key值类型需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　comparingByKey(Comparator) //利用key值进行排序，但key值并没有实现Comparable接口，需要传入一个Comparator比较器。&lt;/p&gt;
&lt;p&gt;　　comparingByValue(Comparator) //利用value值进行排序，但value值并没有实现Comparable接口，需要传入一个Comparator比较器。&lt;/p&gt;
&lt;p&gt;　　再多说一句，Comparator采用的是&lt;strong&gt;策略模式&lt;/strong&gt;，即不修改原有对象，而是引入一个新的对象对原有对象进行改变，此处即如果key(或value)并没有实现Comparable接口，此时可在不修改原有代码的情况下传入一个Comparator比较器进行排序，对原有代码进行修改是一件糟糕的事情。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　参考链接：&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8452379.html&quot; target=&quot;_blank&quot;&gt;《JDK8的新特性——Lambda表达式》&lt;/a&gt;&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8460569.html&quot; target=&quot;_blank&quot;&gt;《似懂非懂的Comparable与Comparator》&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Map.Entry接口中定义的方法到此结束，下面是Map接口中锁定义的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Map中key-value键值对的数量，最大值是Integer.MAX_VALUE（2^31-1）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean isEmpty()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否为空，可以猜测如果size() = 0，Map就为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean containsKey(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否包含key键值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean containsValue(Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否包含value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V get(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过key值获取对应的value值。如果Map中不包含key值则返回null，也有可能该key值对应的value值本身就是null，此时要加以区别的话可以先使用containsKey方法判断是否包含key值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V put(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　向Map中存入key-value键值对，并返回插入的value值。&lt;/p&gt;
&lt;p&gt;　　Map从JDK5过后就改为了泛型类，get方法的参数不是泛型K，而是一个Object对象呢？包括上面的containsKey(Object)和containsValue(Object)参数也是Object而不是泛型。在这个地方似乎是使用泛型更加合适。思考以下场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最开始我写了一段代码，定义HashMap&amp;lt;String, String&amp;gt;，定义HashMap&amp;lt;String, String&amp;gt;，此时我put(&quot;a&quot;, &quot;a&quot;)，同时我通过get(&quot;a&quot;)获取值。&lt;/li&gt;
&lt;li&gt;写着写着，我发现我应该定义为HashMap&amp;lt;Integer, String&amp;gt;，此时IDE 会自动的在put(&quot;a&quot;, &quot;a&quot;)方法报错，因为Map的泛型参数类型key修改为了Integer，我能很好的发现它并改正。但是，我的get(&quot;a&quot;)并不会有任何提示，因为它的参数是Object能接收任意类型的值，假如我get方法同样使用了泛型此时IDE就会提醒我这个地方参数类型不对，应该是Integer类型。那么为什么会出现get方法是使用Object类型，而不是泛型呢？难道JDK的作者没有想到这一点吗？明明能在编译时就能发现的问题，为什么要在运行时再去判断？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这个问题在StackOverflow上也有讨论，链接：&lt;a href=&quot;https://stackoverflow.%20com/questions/1926285/why-does-hashmapcontainskey-take-an-parameter-of-type-object&quot; target=&quot;_blank&quot;&gt;https://stackoverflow. com/questions/1926285/why-does-hashmapcontainskey-take-an-parameter-of-type-object&lt;/a&gt;，&lt;a href=&quot;http://smallwig.blogspot.com/2007/12/why-does-setcontains-take-object-not-e.html&quot; target=&quot;_blank&quot;&gt;http://smallwig.blogspot.com/2007/12/why-does-setcontains-take-object-not-e.html&lt;/a&gt; 我大致翻译了一下这可能有以下几个方面的原因：　&lt;/p&gt;
&lt;p&gt;　　1.这是为了保证兼容性 泛型是在JDK1.5才出现的，而HashMap则是在JDK1.2才出现，在泛型出现的时候伴随着不少兼容性问题，为了保证其兼容性不得不做了一些处理，例如泛型类型的擦除等等。假设在JDK1.5之前存在以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; HashMap hashMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ArrayList arrayList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; hashMap.put(arrayList, &quot;this is list&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;System.out.println(hashMap.get(arrayList));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; LinkedList linkedList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; System.out.println(hashMap.get(linkedList));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段代码在不使用泛型的时候能运行的很好，如果此时get方法中的参数变成了泛型，而不是Object，那么此时hashMap.get(linkedList)这句话将会在编译时出错，因为它不是ArrayList类型。&lt;/p&gt;
&lt;p&gt;　　2.无法确定Key的类型。这里有一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashMapTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     HashMap&amp;lt;SubFoo, String&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();          
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SubFoo是Foo类的子类&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     test(hashMap);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译时出错&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(HashMap&amp;lt;Foo, String&amp;gt; hashMap) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数为HashMap，key值是Foo类，但是不能接收它的子类&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     System.out.println(hashMap.get(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo()));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这种情况把test方法中的参数类型修改为HashMap&amp;lt;? extends Foo, String&amp;gt;即可。但是这是在get方法的参数类型是Object情况下才正确，如果get方法的参数类型是泛型，那它对于“? extends Foo”是一无所知的，换句话说，编译器不知道它应该接收Foo类型还是SubFoo类型，甚至是SubSubFoo类型。对于第二个假设，不少网友指出，get方法的参数类型可以是“&amp;lt;T extends E&amp;gt;”，这就能避免第二个问题了。&lt;/p&gt;
&lt;p&gt;　　在国外网友的讨论中，我还是比较倾向于第一种兼容性问题，毕竟泛型相对来说较晚出现，对于作者John也说过，他们尝试把它泛型化，但泛型化过后产生了一系列的问题，这不得不使得他们放弃将其泛型化。其实在源码的get方法注释中能看到put以前也是Object类型，在泛型出现过后，put方法能成功的改造成泛型，而get由于要考虑兼容性问题不得不放弃将它泛型化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V remove(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　删除Map中的key-value键值对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法的参数是一个Map，将传入的Map全部放入此Map中，当然对参数Map有要求，“? extends K”意味着传入的Map其key值需要是此Map的key或者是子类，value同理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void clear()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　移除Map中所有的key-value键值对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&amp;lt;K&amp;gt; keyset()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回key的set集合，注意set是无序且不可存储重复的值，当然Map中也不可能存在重复的key值，也没有有序无序一说。其实这个方法的运用还是有点意思的，这会涉及到Java对象引用相关的一些知识。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; map.put(&quot;a&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; map.put(&quot;b&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(map.keySet());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: [a, b]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; Set&amp;lt;String&amp;gt; sets =&lt;span&gt; map.keySet();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; sets.remove(&quot;a&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; System.out.println(map.keySet());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: [b]&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; sets.add(&quot;c&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: throws UnsupportedOperationException&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; System.out.println(map.keySet());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第4行的输出的是Map中key的set集合，即“[a,b]” 。&lt;/p&gt;
&lt;p&gt;　　接着创建一个set对象指向map.keySet()方法返回set的集合，并且通过这个set对象删除其中的“a”元素。此时再来通过map.keySet()方法打印key的集合，会发现此时打印“[b]”。这是因为我们在&lt;strong&gt;虚拟机栈&lt;/strong&gt;上定义的sets对象其指针指向的是map.keySet()返回的对象，也就是说这两者指向的是同一个地址，那么只要任一一个对其改变都会影响这个对象本身，这也是Map接口对这个方法的定义，同时Map接口对该方法还做了另外一个限制，不能通过keySet()返回的Set对象对其进行add操作，此时将会抛出UnsupportedOperationException异常，原因很简单如果给Set对象add了一个元素，相对应的Map的key有了，那么它对应的value值呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection&amp;lt;V&amp;gt; values()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回value值的Collection集合。这个集合就直接上升到了集合的顶级父接口——Collection。为什么不是Set对象了呢？原因也很简单，key值不能重复返回Set对象很合理，但是value值肯定可以重复，返回Set对象显然不合适，如果仅仅返回List对象，那也不合适，索性返回顶级父接口——Collection。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Map.Entry的Set集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean equals(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　equals在Object类中只是用“==”简单的实现，对于比较两个Map是否值相等显然需要重写equals方法，重写equals方法通常需要重写hashCode方法。重写equals方法需要遵守5个原则：自反性、对称性、传递性、一致性、非空性。在满足了这个几个原则后还需要满足：两个对象equals比较相等，它们的hashCode散列值也一定相等；但hashCode散列值相等，两个对象equals比较不一定相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V getOrDefault(Object key, V defaultValue)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是JDK8才出现的，并且使用了JDK8的一个新特性，在接口中实现一个方法，叫做default方法，和抽象类类似，default方法是一个具体的方法。这个方法主要是弥补在编码过程中遇到的这样场景：如果一个Map不存在某个key值，则存入一个value值。以前是会写一个判断使用contanisKey方法，现在则只需要一句话就可以搞定map.put(&quot;a&quot;, map.getOrDefault(&quot;a&quot;, 2)); 它的实现也很简单，就是判断key值在Map中是否存在，不存在则存入getOrDefault中的defaultValue参数，存在则再存入一次以前的value参数。 (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default void forEach(BiConsumer&amp;lt;? super K, ? super V&amp;gt; action)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法也是JDK8新增的，为了更方便的遍历，这个方法几乎新增在JDK8的集合中，使用这个新的API能方便的遍历集合中的元素，这个方法的使用需要结合Lambda表达式：map.forEach((k, v) -&amp;gt; System.out.println(&quot;key=&quot; + k + &quot;, value=&quot; + v))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default void replaceAll(BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; function)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　替换Map中的value值，Lambda表达式作为参数，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; map.replaceAll((k, v) -&amp;gt; 10);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Map中的所有值替换为10&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; map.replaceAll((k, v) -&amp;gt; {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Map中的key值等于a，其value则替换为10&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (k.equals(&quot;a&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;default V putIfAbsent(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在ConcurrentHashMap中也有一个putIfAbsent方法，那个方法指的key值不存在就插入，存在则不插入。JDK8中在Map中直接也新增了这个方法，这个方法ConcurrentHashMap#putIfAbsent含义相同，这个方法等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;map.containsKey(key, value)) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    map.put(key, value);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    map.get(key);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在之前提到了一个方法和这个类似——getOrDefault。注意不要搞混了，调用putIfAbsent会直接插入，而getOrDefault不会直接插入到Map中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default boolean remove(Object key, Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　原来的remove方法是直接传递一个key从Map中移除对应的key-value键值对。新增的方法需要同时满足key和value同时在Map有对应键值对时才删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default boolean replace(K key, V oldValue, V newValue)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　和replaceAll类似，当参数中的key-oldValue键值对在Map存在时，则使用newValue替换oldValue。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V replace(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是上面方法的重载，不会判断key值对应的value值，而是直接使用value替换key值原来对应的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V computeIfAbsent(K key, Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果Map中不存在key值，则调用Lambda表达式中的函数主体计算value值，再放入Map中，下次再获取的时候直接从Map中获取。这其实在Map实现本地缓存中随处可见，这个方法类似于下列代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (map.get(key) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     value = func(key);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算value值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    map.put(key, value);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; map.get(key);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;default V computeIfPresent(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法给定一个key值，通过Lambda表达式可计算自定义key和value产生的新value值，如果新value值为null，则删除Map中对应的key值，如果不为空则用新的替换旧的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V compute(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是上面两个方法的结合，有同时使用到上面两个的地方可使用这个方法代替，其中Lambda表达式的函数主体使用三木运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V merge(K key, V value, BiFunction&amp;lt;? super V, ? super V, ? extends V&amp;gt; remappingFunction) 　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　“合并”，意味着旧值和新值都会参与计算并复制。给定key和value值参数，如果key值在Map中存在，则将旧value和给定的value一起计算出新value值作为key的值，如果新value为null，那么则从Map中删除key。如果key不存在，则将给定的value值直接作为key的值。&lt;/p&gt;
&lt;p&gt;　　Map映射集合类型作为Java中最重要以及最常用的数据结构之一，Map接口是它们的基类，在这个接口中定义了许多基础方法，而具体的实习则由它的子类完成。JDK8在Map接口中新值了许多default方法，这也为我们在实际编码中提供了很大的便利，如果是使用JDK8作为开发环境不妨多多学习使用新的API。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 14:54:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8476573.html</dc:identifier>
</item>
<item>
<title>OpenCV亚像素角点cornerSubPixel()源代码分析 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/8476456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/8476456.html</guid>
<description>&lt;p&gt;　　上一篇博客中讲到了goodFeatureToTrack（）这个API函数能够获取图像中的强角点。但是获取的角点坐标是整数，但是通常情况下，角点的真实位置并不一定在整数像素位置，因此为了获取更为精确的角点位置坐标，需要角点坐标达到亚像素（subPixel）精度。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1. 求取亚像素精度的原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　找到一篇讲述原理非常清楚的文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xueyayang.github.io/pdf_posts/%E4%BA%9A%E5%83%8F%E7%B4%A0%E8%A7%92%E7%82%B9%E7%9A%84%E6%B1%82%E6%B3%95.pdf&quot; target=&quot;_blank&quot;&gt;https://xueyayang.github.io/pdf_posts/%E4%BA%9A%E5%83%8F%E7%B4%A0%E8%A7%92%E7%82%B9%E7%9A%84%E6%B1%82%E6%B3%95.pdf&lt;/a&gt;，贴上来，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221630159-75261050.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;608&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221542589-598721322.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;818&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221739311-454213270.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;832&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221840746-1648214134.png&quot; alt=&quot;&quot; width=&quot;864&quot; height=&quot;694&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt; 2. OpenCV源代码分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　OpenCV中有cornerSubPixel（）这个API函数用来针对初始的整数角点坐标进行亚像素精度的优化，该函数原型如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::cornerSubPix( InputArray _image, InputOutputArray _corners,
                       Size win, Size zeroZone, TermCriteria criteria )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　_image为输入的单通道图像；_corners为提取的初始整数角点（比如用goodFeatureToTrack提取的强角点）；win为求取亚像素角点的窗口大小，比如设置Size（11,11），需要注意的是11为半径，则窗口大小为23x23；zeroZone是设置的“零区域”，在搜索窗口内，设置的“零区域”内的值不会被累加，权重值为0。如果设置为Size(-1,-1)，则表示没有这样的区域；critteria是条件阈值，包括迭代次数阈值和误差精度阈值，一旦其中一项条件满足设置的阈值，则停止迭代，获得亚像素角点。&lt;/p&gt;
&lt;p&gt;　　这个API通过下面示例的语句进行调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
cv::cornerSubPix(grayImg, pts, cv::Size(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;), cv::Size(-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;), cv::TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;0.1&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　首先看criteria包含的两个条件阈值在代码中是怎么设置的。如下所示，最大迭代次数为100次，误差精度为eps*eps，也就是0.1*0.1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ITERS = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; win_w = win.width * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;, win_h = win.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, k;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max_iters = (criteria.type &amp;amp; CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;), MAX_ITERS) : MAX_ITERS;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; eps = (criteria.type &amp;amp; CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, &lt;span&gt;0&lt;/span&gt;.) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    eps &lt;/span&gt;*= eps; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use square of error in comparsion operations&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后是高斯权重的计算，如下所示，窗口中心附近权重高，越往窗口边界权重越小。如果设置的有“零区域”，则权重值设置为0。计算出的权重分布如下图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Mat maskm(win_h, win_w, CV_32F), subpix_buf(win_h+&lt;span&gt;2&lt;/span&gt;, win_w+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, CV_32F);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* mask = maskm.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; win_h; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; y = (&lt;span&gt;float&lt;/span&gt;)(i - win.height)/&lt;span&gt;win.height;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vy = std::exp(-y*&lt;span&gt;y);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; win_w; j++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x = (&lt;span&gt;float&lt;/span&gt;)(j - win.width)/&lt;span&gt;win.width;
            mask[i &lt;/span&gt;* win_w + j] = (&lt;span&gt;float&lt;/span&gt;)(vy*std::exp(-x*&lt;span&gt;x));
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make zero_zone&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;( zeroZone.width &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; zeroZone.height &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
        zeroZone.width &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt; &amp;lt; win_w &amp;amp;&amp;amp; zeroZone.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt; &amp;lt;&lt;span&gt; win_h )
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i = win.height - zeroZone.height; i &amp;lt;= win.height + zeroZone.height; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = win.width - zeroZone.width; j &amp;lt;= win.width + zeroZone.width; j++&lt;span&gt; )
            {
                mask[i &lt;/span&gt;* win_w + j] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226222728726-364960247.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来就是针对每个初始角点，按照上述公式，逐个进行迭代求取亚像素角点，代码如下。&lt;/p&gt;
&lt;p&gt;　　① 代码中CI2为本次迭代获取的亚像素角点位置，CI为上次迭代获取的亚像素角点位置，CT是初始的整数角点位置。&lt;/p&gt;
&lt;p&gt;　　② 每次迭代结束计算CI与CI2之间的欧式距离err，如果两者之间的欧式距离err小于设定的阈值，或者迭代次数达到设定的阈值，则停止迭代。&lt;/p&gt;
&lt;p&gt;　　③停止迭代后，需要再次判断最终的亚像素角点位置和初始整数角点之间的差异，如果差值大于设定窗口尺寸的一半，则说明最小二乘计算中收敛性不好，丢弃计算得到的亚像素角点，仍然使用初始的整数角点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do optimization loop for all the points&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; pt_i = &lt;span&gt;0&lt;/span&gt;; pt_i &amp;lt; count; pt_i++&lt;span&gt; )
    {
        Point2f cT &lt;/span&gt;= corners[pt_i], cI =&lt;span&gt; cT;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iter = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            Point2f cI2;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;, b = &lt;span&gt;0&lt;/span&gt;, c = &lt;span&gt;0&lt;/span&gt;, bb1 = &lt;span&gt;0&lt;/span&gt;, bb2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            getRectSubPix(src, Size(win_w&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;, win_h+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), cI, subpix_buf, subpix_buf.type());
            &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;* subpix = &amp;amp;subpix_buf.at&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; process gradient&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;( i = &lt;span&gt;0&lt;/span&gt;, k = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; win_h; i++, subpix += win_w + &lt;span&gt;2&lt;/span&gt;&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; py = i -&lt;span&gt; win.height;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; win_w; j++, k++&lt;span&gt; )
                {
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; m =&lt;span&gt; mask[k];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tgx = subpix[j+&lt;span&gt;1&lt;/span&gt;] - subpix[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tgy = subpix[j+win_w+&lt;span&gt;2&lt;/span&gt;] - subpix[j-win_w-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxx = tgx * tgx *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxy = tgx * tgy *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gyy = tgy * tgy *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; px = j -&lt;span&gt; win.width;

                    a &lt;/span&gt;+=&lt;span&gt; gxx;
                    b &lt;/span&gt;+=&lt;span&gt; gxy;
                    c &lt;/span&gt;+=&lt;span&gt; gyy;

                    bb1 &lt;/span&gt;+= gxx * px + gxy *&lt;span&gt; py;
                    bb2 &lt;/span&gt;+= gxy * px + gyy *&lt;span&gt; py;
                }
            }

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; det=a*c-b*&lt;span&gt;b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( fabs( det ) &amp;lt;= DBL_EPSILON*&lt;span&gt;DBL_EPSILON )
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2x2 matrix inversion&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; scale=&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;det;
            cI2.x &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(cI.x + c*scale*bb1 - b*scale*&lt;span&gt;bb2);
            cI2.y &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(cI.y - b*scale*bb1 + a*scale*&lt;span&gt;bb2);
            err &lt;/span&gt;= (cI2.x - cI.x) * (cI2.x - cI.x) + (cI2.y - cI.y) * (cI2.y -&lt;span&gt; cI.y);
            cI &lt;/span&gt;=&lt;span&gt; cI2;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( cI.x &amp;lt; &lt;span&gt;0&lt;/span&gt; || cI.x &amp;gt;= src.cols || cI.y &amp;lt; &lt;span&gt;0&lt;/span&gt; || cI.y &amp;gt;=&lt;span&gt; src.rows )
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( ++iter &amp;lt; max_iters &amp;amp;&amp;amp; err &amp;gt;&lt;span&gt; eps );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if new point is too far from initial, it means poor convergence.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leave initial point as the result&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( fabs( cI.x - cT.x ) &amp;gt; win.width || fabs( cI.y - cT.y ) &amp;gt;&lt;span&gt; win.height )
            cI &lt;/span&gt;=&lt;span&gt; cT;

        corners[pt_i] &lt;/span&gt;=&lt;span&gt; cI;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　自己参照OpenCV源代码写了一个&lt;/span&gt;&lt;span&gt;myCornerSubPix（）接口函数以便加深理解，如下，仅供参考：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//获取窗口内子图像&lt;/span&gt;&lt;br/&gt;bool&lt;/span&gt; getSubImg(cv::Mat srcImg, cv::Point2f currPoint, cv::Mat &amp;amp;&lt;span&gt;subImg)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; subH =&lt;span&gt; subImg.rows;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; subW =&lt;span&gt; subImg.cols;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;int&lt;/span&gt;(currPoint.x+&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;int&lt;/span&gt;(currPoint.y+&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initx = x - subImg.cols / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inity = y - subImg.rows / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initx &amp;lt; &lt;span&gt;0&lt;/span&gt; || inity &amp;lt; &lt;span&gt;0&lt;/span&gt; || (initx+subW)&amp;gt;=srcImg.cols || (inity+subH)&amp;gt;=srcImg.rows )   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    cv::Rect imgROI(initx, inity, subW, subH);
    subImg &lt;/span&gt;=&lt;span&gt; srcImg(imgROI).clone();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;span&gt;//亚像素角点提取
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; myCornerSubPix(cv::Mat srcImg, vector&amp;lt;cv::Point2f&amp;gt; &amp;amp;&lt;span&gt;pts, cv::Size winSize, cv::Size zeroZone, cv::TermCriteria criteria)
{&lt;br/&gt;　　&lt;span&gt;//搜索窗口大小
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winH = winSize.width * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winW = winSize.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winCnt = winH*&lt;span&gt;winW;&lt;br/&gt;　　&lt;span&gt;//迭代阈值限制
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; MAX_ITERS = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max_iters = (criteria.type &amp;amp; CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;), MAX_ITERS) : MAX_ITERS;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; eps = (criteria.type &amp;amp; CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, &lt;span&gt;0&lt;/span&gt;.) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    eps &lt;/span&gt;*= eps; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use square of error in comparsion operations

    &lt;/span&gt;&lt;span&gt;//生成高斯权重&lt;/span&gt;
    cv::Mat weightMask =&lt;span&gt; cv::Mat(winH, winW, CV_32FC1);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; winH; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; winW; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; wx = (&lt;span&gt;float&lt;/span&gt;)(j - winSize.width) /&lt;span&gt; winSize.width;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; wy = (&lt;span&gt;float&lt;/span&gt;)(i - winSize.height) /&lt;span&gt; winSize.height;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vx = exp(-wx*&lt;span&gt;wx);
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vy = exp(-wy*&lt;span&gt;wy);
            weightMask.at&lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(i, j) = (&lt;span&gt;float&lt;/span&gt;)(vx*&lt;span&gt;vy);
        }
    }
　　&lt;span&gt;//遍历所有初始角点，依次迭代
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; pts.size(); k++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; a, b, c, bb1, bb2;
        
        cv::Mat subImg &lt;/span&gt;= cv::Mat::zeros(winH+&lt;span&gt;2&lt;/span&gt;, winW+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, CV_8UC1);
        cv::Point2f currPoint &lt;/span&gt;=&lt;span&gt; pts[k];
        cv::Point2f iterPoint &lt;/span&gt;=&lt;span&gt; currPoint;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iterCnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;迭代&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt; 
        {
            a &lt;/span&gt;= b = c = bb1 = bb2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//提取以当前点为中心的窗口子图像（为了方便求sobel微分，窗口各向四个方向扩展一行（列）像素）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( !getSubImg(srcImg, iterPoint, subImg)) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            uchar &lt;/span&gt;*pSubData = (uchar*)subImg.data+winW+&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;//如下计算参考上述推导公式，窗口内累加
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; winH; i ++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; winW; j++&lt;span&gt;)
                {&lt;br/&gt;　　　　　　　　　　　　&lt;span&gt;//读取高斯权重值
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; m = weightMask.at&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i, j);&lt;br/&gt;&lt;span&gt;//sobel算子求梯度
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sobelx = &lt;span&gt;double&lt;/span&gt;(pSubData[i*(winW+&lt;span&gt;2&lt;/span&gt;) + j + &lt;span&gt;1&lt;/span&gt;] - pSubData[i*(winW+&lt;span&gt;2&lt;/span&gt;) + j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sobely = &lt;span&gt;double&lt;/span&gt;(pSubData[(i+&lt;span&gt;1&lt;/span&gt;)*(winW+&lt;span&gt;2&lt;/span&gt;) + j] - pSubData[(i - &lt;span&gt;1&lt;/span&gt;)*(winW+&lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; j]);
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxx = sobelx*sobelx*&lt;span&gt;m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxy = sobelx*sobely*&lt;span&gt;m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gyy = sobely*sobely*&lt;span&gt;m;
                    a &lt;/span&gt;+=&lt;span&gt; gxx;
                    b &lt;/span&gt;+=&lt;span&gt; gxy;
                    c &lt;/span&gt;+=&lt;span&gt; gyy;
                    &lt;span&gt;//邻域像素p的位置坐标
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; px = j -&lt;span&gt; winSize.width;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; py = i -&lt;span&gt; winSize.height;

                    bb1 &lt;/span&gt;+= gxx*px + gxy*&lt;span&gt;py;
                    bb2 &lt;/span&gt;+= gxy*px + gyy*&lt;span&gt;py;
                }
            }
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; det = a*c - b*&lt;span&gt;b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(det) &amp;lt;= DBL_EPSILON*&lt;span&gt;DBL_EPSILON)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求逆矩阵&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; invA = c /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invC = a /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invB = -b /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角点新位置&lt;/span&gt;
&lt;span&gt;            cv::Point2f newPoint;
            newPoint.x &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(iterPoint.x + invA*bb1 + invB*&lt;span&gt;bb2);
            newPoint.y &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(iterPoint.y + invB*bb1 + invC*&lt;span&gt;bb2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和上一次迭代之间的误差&lt;/span&gt;
            err = (newPoint.x - iterPoint.x)*(newPoint.x - iterPoint.x) + (newPoint.y - iterPoint.y)*(newPoint.y -&lt;span&gt; iterPoint.y);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新角点位置&lt;/span&gt;
            iterPoint =&lt;span&gt; newPoint;
            iterCnt&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (iterPoint.x &amp;lt; &lt;span&gt;0&lt;/span&gt; || iterPoint.x &amp;gt;= srcImg.cols || iterPoint.y &amp;lt; &lt;span&gt;0&lt;/span&gt; || iterPoint.y &amp;gt;=&lt;span&gt; srcImg.rows)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (err &amp;gt; eps &amp;amp;&amp;amp; iterCnt &amp;lt;&lt;span&gt; max_iters);
       &lt;span&gt; //判断求得的亚像素角点与初始角点之间的差异，即：最小二乘法的收敛性
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(iterPoint.x - currPoint.x) &amp;gt; winSize.width || fabs(iterPoint.y - currPoint.y) &amp;gt;&lt;span&gt; winSize.height)
            iterPoint &lt;/span&gt;=&lt;span&gt; currPoint;
　　　&lt;span&gt;　//保存算出的亚像素角点&lt;/span&gt;
        pts[k] &lt;/span&gt;=&lt;span&gt; iterPoint;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　夜已深，结束。&lt;/p&gt;
&lt;p&gt;　&lt;br/&gt;  &lt;/p&gt;






</description>
<pubDate>Mon, 26 Feb 2018 14:50:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/8476456.html</dc:identifier>
</item>
<item>
<title>TensorFlow实战之实现AlexNet经典卷积神经网络 - 蓝色之旅</title>
<link>http://www.cnblogs.com/georgeli/p/8476307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/georgeli/p/8476307.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;        &lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;本文已同步本人另外一个博客（http://blog.csdn.net/qq_37608890/article/details/79371347）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span lang=&quot;zh-cn&quot;&gt;       本文根据最近学习TensorFlow书籍网络文章的情况,特将一些学习心得做了总结,详情如下.如有不当之处,请各位大拿多多指点,在此谢过。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;一、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;模型及其基本原理阐述&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1&lt;span lang=&quot;zh-cn&quot;&gt;、关于AlexNet&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            2012&lt;span lang=&quot;zh-cn&quot;&gt;年，AlexKrizhevsky&lt;span lang=&quot;zh-cn&quot;&gt;提出了深度卷积神经网络模型AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;，可以看作LeNet&lt;span lang=&quot;zh-cn&quot;&gt;的一种更深更宽的版本。该模型包含了6&lt;span lang=&quot;zh-cn&quot;&gt;亿3000&lt;span lang=&quot;zh-cn&quot;&gt;万个连接，6000&lt;span lang=&quot;zh-cn&quot;&gt;万个参数和65&lt;span lang=&quot;zh-cn&quot;&gt;万个神经元，拥有5&lt;span lang=&quot;zh-cn&quot;&gt;个卷积层，其中3&lt;span lang=&quot;zh-cn&quot;&gt;个卷积层后面连接了最大池化层，最后还有3&lt;span lang=&quot;zh-cn&quot;&gt;个全连接层。它将LeNet&lt;span lang=&quot;zh-cn&quot;&gt;的思想得到更广泛的传播，把把CNN&lt;span lang=&quot;zh-cn&quot;&gt;的基本原理应用到很深很宽的网络中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span lang=&quot;zh-cn&quot;&gt;、AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;主要使用到的新技术点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;(1)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;成功使用RelU&lt;span lang=&quot;zh-cn&quot;&gt;作为CNN&lt;span lang=&quot;zh-cn&quot;&gt;的激活函数，并验证其效果在较深的网络超过Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数，成功解决了Sigmoid&lt;span lang=&quot;zh-cn&quot;&gt;函数在网络较深时梯度弥散问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        (2)&lt;span lang=&quot;zh-cn&quot;&gt;训练时使用Droupout&lt;span lang=&quot;zh-cn&quot;&gt;随机忽略一部分神经元，以避免出现模型过拟合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        (3) &lt;span lang=&quot;zh-cn&quot;&gt;在CNN&lt;span lang=&quot;zh-cn&quot;&gt;中使用重叠的最大池化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        (4) &lt;span lang=&quot;zh-cn&quot;&gt;提出了LRN&lt;span lang=&quot;zh-cn&quot;&gt;层，对局部神经元的活动创建竞争机制，使得其中响应比较大的值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        (5) &lt;span lang=&quot;zh-cn&quot;&gt;使用CUDA&lt;span lang=&quot;zh-cn&quot;&gt;加速深度卷积网络的训练，利用GPU&lt;span lang=&quot;zh-cn&quot;&gt;强大的并行计算能力，处理神经网络训练时大量的矩阵运算。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        (6) &lt;span lang=&quot;zh-cn&quot;&gt;数据增强，随机地从256*256&lt;span lang=&quot;zh-cn&quot;&gt;的原始图像中截取224*224&lt;span lang=&quot;zh-cn&quot;&gt;大小的区域（以及水平翻转的镜像），相当于增加了(256-224)^2=2048&lt;span lang=&quot;zh-cn&quot;&gt;倍的数据量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;span lang=&quot;zh-cn&quot;&gt;、原理阐释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;整个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;包括8&lt;span lang=&quot;zh-cn&quot;&gt;个需要训练参数的层（不含LRN&lt;span lang=&quot;zh-cn&quot;&gt;和池化层），前5&lt;span lang=&quot;zh-cn&quot;&gt;层为卷积层，后3&lt;span lang=&quot;zh-cn&quot;&gt;层为全连接层，如图1&lt;span lang=&quot;zh-cn&quot;&gt;所示。AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;最后一层是有1000&lt;span lang=&quot;zh-cn&quot;&gt;类输出的Softmax&lt;span lang=&quot;zh-cn&quot;&gt;层用作分类。LRN&lt;span lang=&quot;zh-cn&quot;&gt;层出现在第1&lt;span lang=&quot;zh-cn&quot;&gt;个及第2&lt;span lang=&quot;zh-cn&quot;&gt;个卷积层后，而最大池化层出现在两个LRN&lt;span lang=&quot;zh-cn&quot;&gt;层及最后一个卷积层后。RelU&lt;span lang=&quot;zh-cn&quot;&gt;激活函数则应用在这8&lt;span lang=&quot;zh-cn&quot;&gt;层每一层的后面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180226220518239&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                         &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;图&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;的网络结构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;每层的超参数如图1&lt;span lang=&quot;zh-cn&quot;&gt;所示，其中输入的图片尺寸为224*224&lt;span lang=&quot;zh-cn&quot;&gt;，第一个卷积层使用了较大的卷积核尺寸11*11&lt;span lang=&quot;zh-cn&quot;&gt;，步长为4&lt;span lang=&quot;zh-cn&quot;&gt;，有96&lt;span lang=&quot;zh-cn&quot;&gt;个卷积核；然后是一个LRN&lt;span lang=&quot;zh-cn&quot;&gt;层；再往后是一个3*3&lt;span lang=&quot;zh-cn&quot;&gt;的最大池化层，步长为2&lt;span lang=&quot;zh-cn&quot;&gt;。再往后的卷积核尺寸都比较小，基本都是5*5&lt;span lang=&quot;zh-cn&quot;&gt;或3*3&lt;span lang=&quot;zh-cn&quot;&gt;的大小，且步长都是1&lt;span lang=&quot;zh-cn&quot;&gt;，即会扫描全图像所有像素；而最大池化层依然保持为3*3&lt;span lang=&quot;zh-cn&quot;&gt;，步长为2&lt;span lang=&quot;zh-cn&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;这里不难发现，前几个卷积层里面，虽然计算量很大，但参数量很小，基本都在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1M&lt;span lang=&quot;zh-cn&quot;&gt;左右甚至更小，只占AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;总参数量很小一部分。这也是卷积层的价值所在：通过较小的参数量提取有效的特征。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;如果前几层直接使用全连接层，则参数量和计算量将会难以想象。尽管每一个卷积层只占整个网络参数量的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1%&lt;span lang=&quot;zh-cn&quot;&gt;不到，但如果抛弃任何一个卷积层，都会迫使整个网络的分类能力大幅度下降。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;             &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;图1中特殊的地方是卷积部分都是画成上下两块，意思是说把这一层计算出来的&lt;span&gt;&lt;span&gt;featuremap&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;分开，但是前一层用到的数据要看连接的虚线，如图中&lt;span&gt;&lt;span&gt;input&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;层之后的第一层第二层之间的虚线是分开的，是说二层上面的&lt;span&gt;&lt;span&gt;128map&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;是由一层上面的&lt;span&gt;&lt;span&gt;48map&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;计算的，下面同理；而第三层前面的虚线是完全交叉的，就是说每一个&lt;span&gt;&lt;span&gt;192map&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;都是由前面的&lt;span&gt;&lt;span&gt;128+128=256map&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;同时计算得到的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;              Alexnet&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;有一个特殊的计算层，&lt;span&gt;&lt;span&gt;LRN&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;层，做的事是对当前层的输出结果做平滑处理&lt;span&gt;&lt;span&gt;，图2&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;所示&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;                  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;http://img.blog.csdn.net/20180226220526993&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;               &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;&lt;span&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;前后几层（对应位置的点）对中间这一层做一下平滑约束，计算方法如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;                 &lt;img src=&quot;http://img.blog.csdn.net/20180226220642522&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;二、经典卷积神经网络&lt;/span&gt;&lt;/span&gt;&lt;span&gt;AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;模型实现过程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span lang=&quot;zh-cn&quot;&gt;、简要说明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;因为使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ImageNet&lt;span lang=&quot;zh-cn&quot;&gt;数据集训练一个完整的AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;非常耗时，这里AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;的实现将不涉及实际数据的训练，但会创建一个完整的AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;卷积神经网络，然后对它每个batch&lt;span lang=&quot;zh-cn&quot;&gt;的前馈计算（forward&lt;span lang=&quot;zh-cn&quot;&gt;）和反馈计算（backward&lt;span lang=&quot;zh-cn&quot;&gt;）的速度进行测试。下面使用随机图片数据来计算每轮前馈、反馈的平均耗时。当然，读者也可以自行下载ImageNet&lt;span lang=&quot;zh-cn&quot;&gt;数据完成训练并测试。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;、实现过程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;194&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
==============================================================================
from datetime import datetime
import math
import time
import tensorflow as tf

#这里总共测试100个batch的数据。
batch_size=32
num_batches=100
#定义一个用来显示网络每一层结构的函数print_activations，展示每一个卷积层或池化层输出的tensor尺寸。
def print_activations(t):
    print(t.op.name, ' ', t.get_shape().as_list())

#设计AlexNet网络结构。
#设定inference函数，用于接受images作为输入，返回最后一层pool5（第5个池化层）及parameters（AlexnNet中所有需要训练的模型参数）
#该函数包括多个卷积层和池化层。
def inference(images):
    parameters = []
    # 第1个卷积层
    with tf.name_scope('conv1') as scope:
        kernel = tf.Variable(tf.truncated_normal([11, 11, 3, 64], dtype=tf.float32,
                                                 stddev=1e-1), name='weights')
        conv = tf.nn.conv2d(images, kernel, [1, 4, 4, 1], padding='SAME')
        biases = tf.Variable(tf.constant(0.0, shape=[64], dtype=tf.float32),
                             trainable=True, name='biases')
        bias = tf.nn.bias_add(conv, biases)
        conv1 = tf.nn.relu(bias, name=scope)
        print_activations(conv1)
        parameters += [kernel, biases]

  # 添加LRN层和最大池化层
    lrn1 = tf.nn.lrn(conv1, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='lrn1')
    pool1 = tf.nn.max_pool(lrn1,
                           ksize=[1, 3, 3, 1],
                           strides=[1, 2, 2, 1],
                           padding='VALID',
                           name='pool1')
    print_activations(pool1)

  # 设计第2个卷积层
    with tf.name_scope('conv2') as scope:
        kernel = tf.Variable(tf.truncated_normal([5, 5, 64, 192], dtype=tf.float32,
                                                 stddev=1e-1), name='weights')
        conv = tf.nn.conv2d(pool1, kernel, [1, 1, 1, 1], padding='SAME')
        biases = tf.Variable(tf.constant(0.0, shape=[192], dtype=tf.float32),
                             trainable=True, name='biases')
        bias = tf.nn.bias_add(conv, biases)
        conv2 = tf.nn.relu(bias, name=scope)
        parameters += [kernel, biases]
    print_activations(conv2)

  # 对第2个卷积层的输出进行处理，同样也是先做LRN处理再做最大化池处理。
    lrn2 = tf.nn.lrn(conv2, 4, bias=1.0, alpha=0.001 / 9.0, beta=0.75, name='lrn2')
    pool2 = tf.nn.max_pool(lrn2,
                           ksize=[1, 3, 3, 1],
                           strides=[1, 2, 2, 1],
                           padding='VALID',
                           name='pool2')
    print_activations(pool2)

  # 设计第3个卷积层
    with tf.name_scope('conv3') as scope:
        kernel = tf.Variable(tf.truncated_normal([3, 3, 192, 384],
                                                 dtype=tf.float32,
                                                 stddev=1e-1), name='weights')
        conv = tf.nn.conv2d(pool2, kernel, [1, 1, 1, 1], padding='SAME')
        biases = tf.Variable(tf.constant(0.0, shape=[384], dtype=tf.float32),
                             trainable=True, name='biases')
        bias = tf.nn.bias_add(conv, biases)
        conv3 = tf.nn.relu(bias, name=scope)
        parameters += [kernel, biases]
        print_activations(conv3)

  # 设计第4个卷积层
    with tf.name_scope('conv4') as scope:
        kernel = tf.Variable(tf.truncated_normal([3, 3, 384, 256],
                                                 dtype=tf.float32,
                                                 stddev=1e-1), name='weights')
        conv = tf.nn.conv2d(conv3, kernel, [1, 1, 1, 1], padding='SAME')
        biases = tf.Variable(tf.constant(0.0, shape=[256], dtype=tf.float32),
                             trainable=True, name='biases')
        bias = tf.nn.bias_add(conv, biases)
        conv4 = tf.nn.relu(bias, name=scope)
        parameters += [kernel, biases]
        print_activations(conv4)

  # 设计第5个卷积层
    with tf.name_scope('conv5') as scope:
        kernel = tf.Variable(tf.truncated_normal([3, 3, 256, 256],
                                                 dtype=tf.float32,
                                                 stddev=1e-1), name='weights')
        conv = tf.nn.conv2d(conv4, kernel, [1, 1, 1, 1], padding='SAME')
        biases = tf.Variable(tf.constant(0.0, shape=[256], dtype=tf.float32),
                             trainable=True, name='biases')
        bias = tf.nn.bias_add(conv, biases)
        conv5 = tf.nn.relu(bias, name=scope)
        parameters += [kernel, biases]
        print_activations(conv5)

  # 最大池化层
    pool5 = tf.nn.max_pool(conv5,
                           ksize=[1, 3, 3, 1],
                           strides=[1, 2, 2, 1],
                           padding='VALID',
                           name='pool5')
    print_activations(pool5)

    return pool5, parameters

#构建函数time_tensorflow_run，用来评估AlexNet每轮计算时间。
def time_tensorflow_run(session, target, info_string):
    num_steps_burn_in = 10
    total_duration = 0.0
    total_duration_squared = 0.0
    for i in range(num_batches + num_steps_burn_in):
        start_time = time.time()
        _ = session.run(target)
        duration = time.time() - start_time
        if i &amp;gt;= num_steps_burn_in:
            if not i % 10:
                print ('%s: step %d, duration = %.3f' %
                       (datetime.now(), i - num_steps_burn_in, duration))
            total_duration += duration
            total_duration_squared += duration * duration
    mn = total_duration / num_batches
    vr = total_duration_squared / num_batches - mn * mn
    sd = math.sqrt(vr)
    print ('%s: %s across %d steps, %.3f +/- %.3f sec / batch' %
           (datetime.now(), info_string, num_batches, mn, sd))

#主函数
def run_benchmark():

    with tf.Graph().as_default():
        image_size = 224
        images = tf.Variable(tf.random_normal([batch_size,
                                           image_size,
                                           image_size, 3],
                                          dtype=tf.float32,
                                          stddev=1e-1))

   
        pool5, parameters = inference(images)

    
        init = tf.global_variables_initializer()

    
        config = tf.ConfigProto()
        config.gpu_options.allocator_type = 'BFC'
        sess = tf.Session(config=config)
        sess.run(init)

   
        time_tensorflow_run(sess, pool5, &quot;Forward&quot;)

    
        objective = tf.nn.l2_loss(pool5)
   
        grad = tf.gradients(objective, parameters)
    # Run the backward benchmark.
        time_tensorflow_run(sess, grad, &quot;Forward-backward&quot;)

#执行主函数
run_benchmark()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;span lang=&quot;zh-cn&quot;&gt;、执行结果分析&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;这里有三部分如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             &lt;span lang=&quot;zh-cn&quot;&gt;首先是AlexNet&lt;span lang=&quot;zh-cn&quot;&gt;的网络结构   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
conv1   [32, 56, 56, 64]
pool1   [32, 27, 27, 64]
conv2   [32, 27, 27, 192]
pool2   [32, 13, 13, 192]
conv3   [32, 13, 13, 384]
conv4   [32, 13, 13, 256]
conv5   [32, 13, 13, 256]
pool5   [32, 6, 6, 256]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;              其次是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Forward&lt;span lang=&quot;zh-cn&quot;&gt;运行的时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
2018-02-26 08:08:01.966903: step 0, duration = 0.914
2018-02-26 08:08:11.376824: step 10, duration = 0.939
2018-02-26 08:08:21.075799: step 20, duration = 0.953
2018-02-26 08:08:30.983637: step 30, duration = 0.930
2018-02-26 08:08:40.616086: step 40, duration = 0.938
2018-02-26 08:08:50.259619: step 50, duration = 0.965
2018-02-26 08:09:01.280123: step 60, duration = 1.128
2018-02-26 08:09:11.993487: step 70, duration = 0.998
2018-02-26 08:09:22.223815: step 80, duration = 0.935
2018-02-26 08:09:31.741528: step 90, duration = 0.921
2018-02-26 08:09:40.085934: Forward across 100 steps, 0.990 +/- 0.082 sec / batch
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;               最后是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;backward&lt;span lang=&quot;zh-cn&quot;&gt;运行的时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
2018-02-26 08:10:19.714161: step 0, duration = 3.387
2018-02-26 08:10:55.765137: step 10, duration = 3.495
2018-02-26 08:11:32.451839: step 20, duration = 4.189
2018-02-26 08:12:07.982546: step 30, duration = 3.369
2018-02-26 08:12:43.531404: step 40, duration = 3.415
2018-02-26 08:13:18.980045: step 50, duration = 3.470
2018-02-26 08:13:54.535575: step 60, duration = 3.371
2018-02-26 08:14:29.413705: step 70, duration = 3.655
2018-02-26 08:15:06.147061: step 80, duration = 3.583
2018-02-26 08:15:43.403758: step 90, duration = 3.921
2018-02-26 08:16:16.511215: Forward-backward across 100 steps, 3.602 +/- 0.237 sec / batch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;zh-cn&quot;&gt;三、小结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            AlexNet为卷积神经网络和深度学习正名，为复兴神经网络做出了很多贡献，当然，超大型的数据集ImageNet也给深度学习带来了很大贡献。训练深度卷积神经网络，必须要有一个类似于ImageNet这样超大型数据集才能避免出现过拟合现象，从而更能体现深度学习的优势所在。因此，传统机器学习模型更适合一个小型数据集，在面对大型数据集时，需要更大学习容量的模型，那就是深度学习模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            深度学习的参数不一定比传统机器学习模型多，尤其是在卷积层使用的参数量一般都比较少，但其抽取特征的能力非常强悍，这是CNN之所以有效的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   参考资料   &lt;strong&gt;主要参考资料《TensorFlow实战》（黄文坚  唐源 著）（电子工业出版社）&lt;/strong&gt;。         &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 14:11:00 +0000</pubDate>
<dc:creator>蓝色之旅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/georgeli/p/8476307.html</dc:identifier>
</item>
<item>
<title>项目管理上的失误和应对措施 - 双鱼座的牛</title>
<link>http://www.cnblogs.com/jiangchao226/p/8476240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangchao226/p/8476240.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6290181-b321702f77f31deb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;学习英语的途中，尝试翻译的文章&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着一家公司的发展，资深工程师将不可避免的被要求成为关键项目的关键开发人员,甚至可能被要求管理其他的开发者，从而不知不觉的成为一名项目管理人员。而随着时间的推移，可能就不得不面临着程序员生涯的最大改变了.&lt;br/&gt;首先是要不要停止程序员的生涯。&lt;br/&gt;不可否认，某天，你突然不在写代码了，而只是对项目进行管理，监督团队中的其他人？想想都觉得可怕。因为作为一个项目管理人员，你不但要对项目进行整体把控规划，对项目资源进行统筹管理，还要确保每个项目成员都在工作中处于最好的状态。这意味着，你将不只是要自己成长，而是要带领团队中的兄弟们一起成长。&lt;/p&gt;
&lt;p&gt;可惜的是，一般公司都不会提供管理方面的专业培训，但是，缺希望你从一开始就能圆满的胜任这个职务，这个期望和培训的缺乏，可能会导致60%的新项目经理在前两年多了一份从入门到放弃的经历。&lt;/p&gt;
&lt;p&gt;虽然只要有了足够的时间，每个人都会形成自己的管理风格，但是，这个足够的实际几乎是不可能存在的，当我们到达了一个项目管理的岗位的时候，就必须承担这个岗位的责任，所以尽管现在依然缺乏经验，但项目和团队成员都需要你尽快的强大起来。&lt;/p&gt;
&lt;p&gt;所以，我们尽快的想办法，让自己成为一个，至少来说，比较不错的项目经理。&lt;/p&gt;
&lt;p&gt;所以有了这篇文章，这里将简单梳理一下你与团队成员最频繁使用的三种交流方式，一对一交流，项目会议，和电子邮件。已经他们会出现的问题，和面对问题我们能做出的改变，以便帮你快速的定位问题，从而可以再这个岗位上快速找到立足点。&lt;/p&gt;
&lt;h2 id=&quot;一对一交流&quot;&gt;一对一交流&lt;/h2&gt;
&lt;p&gt;当前的情况下，选择像是在公司内，和高层，比如说boss那样谈话的没事与工程师进行一对一的会议可能不是那么好，比如同老板谈话的的情景可能是这样的：老板问你现在项目的情况怎么样？需要你向他详细的介绍一下项目的状态，然后收工。或者少数情况下，老板给你一些反馈，当然，假如你足够的幸运，要升值加薪了，可能会和老板进行一些深入的交流，比如关于公司，关于职业生涯啥的。&lt;/p&gt;
&lt;p&gt;但是，和团队中的工程师谈话，需要充足的时间。而我们常常面对的一个最大的错误就是在一对一交流中试图缩短时间。而实际上，任何这种一对一的会议，如果不到1小时的画，都是在浪费双方的时间。&lt;/p&gt;
&lt;p&gt;关于高生产力的管理，Andy Grove解释过，在任何一对一的交流中，前25分钟都是充斥着个人状态，一般意见和闲聊。&lt;/p&gt;
&lt;p&gt;这意味着，如果你这次一对一的会议只有30分钟的时长，那么你会听到员工的牢骚，寒暄，或最近比较热点的事情，然后关于项目？大概只有5分钟穿插在谈话的图中，作为一个项目经理，显然是不够用的。&lt;/p&gt;
&lt;p&gt;这意味着，你可能需要一个小时或更多的实际进行一对一的会议，这样，如果是一个大的团队，在一周内你可能就无法进行其他的工作了，这时候，第二个错误也就呼之欲出了：频率。&lt;/p&gt;
&lt;p&gt;一个新的项目经理通常认为每周至少与每名队员进行一次一对一的会议，而频率更高，更对项目的进展有利。&lt;/p&gt;
&lt;p&gt;其实如果是简短的一对一会议，无论是多久进行一次，都不会对项目有很大的影响。他只会让员工对你有刻板，乏味的印象。&lt;/p&gt;
&lt;p&gt;实际上，一对一的谈话频率应该根据每个人的实际情况来进行判断，比如如果是一个初级的工程师或者是一个新加入团队的成员，那么可能真的需要每周至少进行一次谈话，否则，如果他是一个高级工程师，那么他根据计划就会知道自己该做什么，那么，就可以适当的减少正式谈话的数量频率。&lt;/p&gt;
&lt;p&gt;一次比较好的一对一会议，应该比单纯的项目状态更新汇报更加的深入，甚至可以对项目中的一些技术问题进行探讨，与其单纯的询问一些项目进度等方面的问题，不如问问他在这个项目中，遇到的，或者说所学到的最有钱的东西是什么。当然，重点是询问一些对这些新事物的看法而不是问一下这些新事物本身。如果有可能的话，还可以建立一个自己的一对一会议的模板来使这些会议不至于偏离正轨。&lt;/p&gt;
&lt;p&gt;实际上，虽然有些新的项目经理对一对一的看法很低，但是事实上，适当的一对一谈话时你作为一个项目管理者，掌控项目，帮助团队中人进行项目推进的一个最重要的工具。&lt;/p&gt;
&lt;h2 id=&quot;团队会议&quot;&gt;团队会议&lt;/h2&gt;
&lt;p&gt;你把团队的所有人带进一间屋子，然后...?没有人期待一个一团糟的会议，但是，我想每个人都会举出一个类似会议的例子。作为一个新的项目经理，如果没有一个详细的计划，很容易就回将会议变得毫无价值。&lt;/p&gt;
&lt;p&gt;一个新项目经理往往所犯下的第一个错误就是不清楚为什么会召开这个会议。这样的话，一个没有目标的会议会浪费所有人的实际。就像所有的有效会议一样，首先就要确定一个会议的目标。&lt;/p&gt;
&lt;p&gt;一个好的目标不仅要概况你希望解决的问题，并且需要明确的指出。每个问题的情况和所需要采取的行动：“本次会议的目的是讨论现在团队内的问题和挑战，因为我觉得面对面的讨论是解决现有问题的最好方式，如果这次会议所提的每一个问题都有了明确的可采取的下一步行动，那么，这就代表着这次会议的成功！”&lt;/p&gt;
&lt;p&gt;就像上面的话一样，首先给会议定义一个目标，你也将大大避免一个项目经理会犯的另一个错误：过度规划团队会议。作为一个工程师出身的项目经理，先行召开一个全体会议确实有着很大的诱惑力。但这样，却会减少一个健康团队有机讨论或辩论的机会。&lt;/p&gt;
&lt;p&gt;另外实际上，我们不可能能够准确的知道讨论一个主题所需要的准确时间，如果我们每次都为会议确定恰到好处的实际，那么结果要么就是会跳过某个议题，要么就是排在后边的议题永远都见不到光。&lt;/p&gt;
&lt;p&gt;而且过于死板的会议议程会忽略团队自发的讨论和发现问题的方式。通常，这样可能会导致你仅仅与特定的工程师，负责人进行交谈，而不是整个团队的会议。&lt;/p&gt;
&lt;p&gt;所以，与其试图组织整个会议，不如提前向队员询问所需的会议主题，然后将它们写在会议室的白板上，并且，在会议开始之前，在围绕会议室步行一周，再次确定主题。&lt;/p&gt;
&lt;p&gt;当团队成员感觉自己是这个会议的主导者，而不是仅仅是一个被动的参与者的时候，他们会更加积极的，深入的讨论他们所遇到的问题，并未当前的问题提出响应的建议，而这个时候，你所需要的仅仅是促进这些讨论并且对队员们所提出的解决意见进行记录并探讨。并且，这种会议还有一个额外的好处，那就是一个健康良好的会议，意味着在进行一对一的会议的时候不需要在进行对项目状态的了解和更新。&lt;/p&gt;
&lt;p&gt;实际上，只有当队员开始重视每次的集体会议时间的时候，作为一个项目经理，你才会知道这样做的价值。&lt;/p&gt;
&lt;h2 id=&quot;电子邮件&quot;&gt;电子邮件&lt;/h2&gt;
&lt;p&gt;我想每个人都能回忆起，自己至少有一个晚上，被上头发来的邮件给毁了。是的，现在作为一个新上任的项目经理，发现角色变了，作为了邮件的发出者。但是，尽管我们都曾经这么的厌恶这些邮件，但是缺发现，作为项目经理的新的责任，新的工作，我们还是不得不这样做。要知道，至少50%的行业在工作时间之外发送邮件都是有罪的，所以，希望你能考虑团队成员的状况，至少让成员对你能够产生好感。&lt;/p&gt;
&lt;p&gt;首先要认识到，电子邮件这种东西至少对一个团队产生了两大负面影响。首先，每个人的工作时间都是8小时，其他的时间需要休息，这对一个健康的生产力和创造力至关重要。虽然这样可能给你一种能迅速追踪处理事情的错觉，但是实际上我们团队处理问题的能力缺收到了损害。&lt;/p&gt;
&lt;p&gt;而他的第二个问题就是电子邮件会破坏你的团队，Lehigh大学的一项研究表示，在工作之余时间的邮件会直接导致情绪的疲惫和衰竭。而情绪疲惫衰竭几乎占所有离职原因的一半，所以，通过发送电子邮件打断一个人的生活，实际上是有很高的成本。&lt;/p&gt;
&lt;p&gt;虽然这些成本的消耗似乎无法克服，但实际上还是有办法解决的。最简单的方式，我们停止在工作之外的实际发送邮件即可。但是，有一些时候，大脑会 突然有一些闪光点，如果不是立即发送邮件则很容易把它抛在脑后的情况，该怎么办呢？其实我们可以看到，每个平台都会有一些邮件的客户端，而几乎每个客户端都有定时发送的功能。&lt;/p&gt;
&lt;p&gt;这下，邮件发送时间的问题解决了，但其实，邮件最重要的还是内容，一个好的邮件内容能够明确的告诉读者，我需要什么，他们需要做什么，并且要求问责。尤其是当邮件是转发的时候，这点尤其重要。实际上，与电话相比，邮件的线程是难以跟踪的，所以，要求你的邮件接收人给与适当的反馈，并假设他们采取了相应的行动。&lt;/p&gt;
&lt;p&gt;为了让你的邮件变得清晰，明了，你可以在邮件的顶部先确定一个简单的模板或者大纲，比如：“(姓名),我希望您需要(期望执行的任务)”，如果发现这种模板无法完成所需要的邮件，那么想一下，可能这块工作不适合与使用电子邮件来完成。&lt;/p&gt;
&lt;p&gt;然后，你就可以在某个团队会议上，告诉你的队员你的新的邮件方式，并且严格按照这个承诺的时候，你会发现，团队的生产力，创造力和信任程度都显著的提升，当一些事情不得不在工作时间之外的时间解决时，你同样会发现你的邮件被高度重视并迅速的被执行。&lt;/p&gt;
&lt;h2 id=&quot;作为项目经理的下一步&quot;&gt;作为项目经理的下一步&lt;/h2&gt;
&lt;p&gt;虽然作为一个新的项目经理，你可以专注的知识领域多达几十个。但这三个沟通点缺总是可以脱颖而出，因为这三点对你的团队将产生重大的影响。&lt;/p&gt;
&lt;p&gt;更重要的是，一旦你建立了一对一会议，团队会议，和电子邮件的体系结构，那么，你的这个团队就回成为帮助你成为一个更强的项目经理的一个基石。&lt;/p&gt;
&lt;p&gt;所以，不要害怕使用这些不同的渠道，询问你的团队或者某个队员：“我干的怎么样？”一定要虚心听他们的反馈，因为你的团队是希望你成功的，一旦让他们知道了你是致力于帮助他们，他们也会全力的使你走向成功。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://simpleprogrammer.com/engineering-management-mistakes/&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 13:56:00 +0000</pubDate>
<dc:creator>双鱼座的牛</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangchao226/p/8476240.html</dc:identifier>
</item>
<item>
<title>Django——ContentType及ContentType-signals的使用 - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/8475918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/8475918.html</guid>
<description>&lt;p&gt;　在django中，有一个记录了项目中所有model元数据的表，就是ContentType，表中一条记录对应着一个存在的model，所以可以通过一个ContentType表的id和一个具体表中的id找到任何记录，及先通过ContenType表的id可以得到某个model，再通过model的id得到具体的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4967928a-742f-463c-80cd-3d7457574989')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_4967928a-742f-463c-80cd-3d7457574989&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4967928a-742f-463c-80cd-3d7457574989&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4967928a-742f-463c-80cd-3d7457574989',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4967928a-742f-463c-80cd-3d7457574989&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ContentType(models.Model):
    app_label &lt;/span&gt;= models.CharField(max_length=100&lt;span&gt;)
    model &lt;/span&gt;= models.CharField(_(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python model class name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), max_length=100&lt;span&gt;)
    objects &lt;/span&gt;=&lt;span&gt; ContentTypeManager()

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        verbose_name_plural &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content types&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        db_table &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django_content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        unique_together &lt;/span&gt;= ((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app_label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; name(self):
        model &lt;/span&gt;=&lt;span&gt; self.model_class()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; model:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.model
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; force_text(model._meta.verbose_name)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; model_class(self):
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Returns the Python model class for this type of content.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; apps.get_model(self.app_label, self.model)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; LookupError:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_object_for_this_type(self, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Returns an object of this type for the keyword arguments given.
        Basically, this is a proxy around this object_type's get_object() model
        method. The ObjectNotExist exception, if thrown, will not be caught,
        so code that calls this method should catch it.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.model_class()._base_manager.using(self._state.db).get(**&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_all_objects_for_this_type(self, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        Returns all objects of this type for the keyword arguments given.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.model_class()._base_manager.using(self._state.db).filter(**&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; natural_key(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (self.app_label, self.model)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ContentType源码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　這个类主要作用是记录每个app中的model。例如，我们在自己的app中创建了如下几个model：post，event。迁移之后，我们来查看一下ContentType這个数据表中生成的数据：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136072/201711/1136072-20171124165357109-1099990496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图，生成了app与model的对应关系。那么，這个主要有什么用呢？&lt;/p&gt;
&lt;p&gt;　　我们在View视图中，来这样玩玩：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; demo(request):
    obj &lt;/span&gt;= models.ContentType.objects.get(id=10&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.model_class()) # &amp;lt;class 'app01.models.Post'&amp;gt;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;............&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，我们&lt;span&gt;通过model_class就可以获取对应的类&lt;/span&gt;。也就是说，今后，我们如果自己定义model如果有外键关联到這个ContentType上，我们就能找到对应的model名称。&lt;/p&gt;

&lt;p&gt;　　django的signal结合contenttypes可以实现好友最新动态，新鲜事，消息通知等功能。总体来说这个功能就是在用户发生某个动作的时候将其记录下来或者附加某些操作，比如通知好友。要实现这种功能可以在动作发生的代码里实现也可以通过数据库触发器等实现，但在django中，一个很简单的方法的就是使用signals。&lt;/p&gt;
&lt;p&gt;　　当django保存一个object的时候会发出一系列的signals，可以通过对这些signals注册listener，从而在相应的signals发出时执行一定的代码。&lt;br/&gt;　　使用signals来监听用户的动作有很多好处，1、不管这个动作是发生在什么页面，甚至在很多页面都可以发生这个动作，都只需要写一次代码来监听保存object这个动作就可以了。2、可以完全不修改原来的代码就可以添加监听signals的功能。3、你几乎可以在signals监听代码里写任何代码，包括做一些判断是不是第一次发生此动作还是一个修改行为等等。&lt;/p&gt;
&lt;p&gt;　　想要记录下每个操作，同时还能追踪到这个操作的具体动作。&lt;br/&gt;　　*首先用信号机制，监听信号，实现对信号的响应函数，在响应函数中记录发生的动作（记录在一张记录表，相当于下文的Event）。&lt;br/&gt;　　*其次就是为了能追踪到操作的具体动作，必须从这张表中得到相应操作的model，这就得用到上面说的ContentType。&lt;/p&gt;
&lt;p&gt;　　对于新鲜事这个功能来说就是使用GenericRelation来产生一个特殊的外键，它不像models.ForeignKey那样，必须指定一个Model来作为它指向的对象。GenericRelation可以指向任何Model对象，有点像C语言中 void* 指针。&lt;/p&gt;
&lt;p&gt;　　这样关于保存用户所产生的这个动作，比如用户写了一片日志，我们就可以使用Generic relations来指向某个Model实例比如Post，而那个Post实例才真正保存着关于用户动作的完整信息，即Post实例本身就是保存动作信息最好的地方。这样我们就可以通过存取Post实例里面的字段来描述用户的那个动作了，需要什么信息就往那里面去取。而且使用Generic relations的另外一个好处就是在删除了Post实例后，相应的新鲜事实例也会自动删除。&lt;/p&gt;
&lt;p&gt;　　怎么从这张操作记录表中得到相应操作的model呢，这就得用到fields.GenericForeignKey，它是一个特殊的外键，可以指向任何Model的实例，在这里就可以通过这个字段来指向类似Post这样保存着用户动作信息的Model实例。&lt;/p&gt;
&lt;p&gt;　　先来看看model：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; User
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes &lt;span&gt;import&lt;/span&gt;&lt;span&gt; fields
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signals


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post(models.Model):
    author &lt;/span&gt;=&lt;span&gt; models.ForeignKey(User)
    title &lt;/span&gt;= models.CharField(max_length=255&lt;span&gt;)
    content &lt;/span&gt;=&lt;span&gt; models.TextField()
    created &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发表时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, auto_now_add=&lt;span&gt;True)
    updated &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最后修改时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, auto_now=&lt;span&gt;True)

    events &lt;/span&gt;= fields.GenericRelation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Event&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.title

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; description(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 发表了日志《%s》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (self.author, self.title)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Event(models.Model):
    user &lt;/span&gt;=&lt;span&gt; models.ForeignKey(User)
    content_type &lt;/span&gt;=&lt;span&gt; models.ForeignKey(ContentType)
    object_id &lt;/span&gt;=&lt;span&gt; models.PositiveIntegerField()

    content_object&lt;/span&gt;= fields.GenericForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    created &lt;/span&gt;= models.DateTimeField(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;事件发生时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, auto_now_add=&lt;span&gt;True)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的事件: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.user, self.description())

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; description(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.content_object.description()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; post_post_save(sender, instance, signal, *args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    :param sender:监测的类：Post类
    :param instance: 监测的类：Post类
    :param signal: 信号类
    :param args: 
    :param kwargs: 
    :return: 
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    post &lt;/span&gt;=&lt;span&gt; instance
    event &lt;/span&gt;= Event(user=post.author, content_object=&lt;span&gt;post)
    event.save()

signals.post_save.connect(post_post_save, sender&lt;/span&gt;=Post)&lt;br/&gt;#signals.post_save.connect(post_post_sace,sender=Book)可以监听多个类
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只要model中有object的保存操作，都将执行post_post_save函数，故可以在这个接受函数中实现通知好友等功能。&lt;/p&gt;
&lt;p&gt;　　前面说到django在保存一个object的时候会发出一系列signals，在这里我们所监听的是signals.post_save这个signal，这个signal是在django保存完一个对象后发出的，django中已定义好得一些signal, 在django/db/models/signal.py中可以查看，同时也可以自定义信号。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　利用connect这个函数来注册监听器， connect原型为：&lt;br/&gt;　　def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):&lt;br/&gt;　　第一个参数是要执行的函数，第二个参数是指定发送信号的Class，这里指定为Post这个Model，对其他Model所发出的signal并不会执行注册的函数。&lt;br/&gt;instance这个参数，即刚刚保存完的Model对象实例。创建事件的时候看到可以将post这个instance直接赋给generic.GenericForeignKey类型的字段，从而event实例就可以通过它来获取事件的真正信息了。&lt;br/&gt;　　最后有一点需要的注意的是，Post的Model定义里现在多了一个字段：&lt;br/&gt;      content_object= GenericRelation(‘Event’)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      通过这个字段可以得到与某篇post相关联的所有事件，最重要的一点是如果没有这个字段，那么当删除一篇post的时候，与该post关联的事件是不会自动删除的。反之有这个字段就会进行自动的级联删除&lt;/p&gt;

&lt;h2&gt;案例一、调查问卷表设计&lt;/h2&gt;
&lt;p&gt;　　例如：设计如下类型的调查问卷表：问卷类型包括（打分，建议，选项），先来看看一个简单的问答，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您最喜欢吃什么水果？
&lt;ul&gt;&lt;li&gt;A.苹果　　B.香蕉　C.梨子    D.橘子&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于上面一个类型的问答，我们可以知道，一个问卷系统主要包括：问卷，问卷中每个题目，每个题目的答案，以及生成问卷记录。常规设计表如下：&lt;/p&gt;
&lt;div onclick=&quot;cnblogs_code_show('ef2ea752-b3f2-4a3b-821f-aa127ccd90f4')&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3e9554ff-32ef-4e63-be15-9e1c88a3f235')&quot; readability=&quot;47.5&quot;&gt;&lt;img id=&quot;code_img_closed_3e9554ff-32ef-4e63-be15-9e1c88a3f235&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3e9554ff-32ef-4e63-be15-9e1c88a3f235&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3e9554ff-32ef-4e63-be15-9e1c88a3f235',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e9554ff-32ef-4e63-be15-9e1c88a3f235&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.fields &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GenericForeignKey, GenericRelation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ContentType
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Survery(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷
    ID        name            by_class      creator
    1    第一次班级调查      三年级五班     李老师
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    name &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查问卷名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=128, unique=&lt;span&gt;True)
    by_class &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷调查班级&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClassList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    date &lt;/span&gt;= models.DateTimeField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷创建日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, auto_now_add=&lt;span&gt;True)
    creator &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建者&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryItem(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷题目
    ID                 survery                       name                   date          answer_type
     1    1(代表上面创建的第一次班级调查)      您最喜欢吃什么水果?       xxx-xxx-xx           1
     1    1(代表上面创建的第一次班级调查)      您最喜欢什么玩具?         xxx-xxx-xx           2
     1    1(代表上面创建的第一次班级调查)      您最喜欢什么英雄人物?     xxx-xxx-xx           3
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    survery &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问卷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Survery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    name &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查问题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=255&lt;span&gt;)
    date &lt;/span&gt;= models.DateField(auto_now_add=&lt;span&gt;True)
    answer_type_choices &lt;/span&gt;=&lt;span&gt; (
        (&lt;/span&gt;1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打分(1~10分)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单选&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    )
    answer_type &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问题类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, choices=answer_type_choices, default=1&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryChoices(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷选项答案(针对选项类型)
    ID    item    content   points
    1       2       A         10分
    1       2       B         9分
    1       2       C         8分
    1       2       D         7分
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    content &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, max_length=256&lt;span&gt;)
    points &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;分值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryRecord(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷记录
    ID    survery      student_name   survery_item  score  single  suggestion  date
    1        1            1               1          10分   null      null    xxxxx     
    1        1            1               2          null     A       null    xxxxx     
    1        1            1               3          null   null      XXXXX    xxxxx     
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    survery &lt;/span&gt;= models.ForeignKey(Survery, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    student_name &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学员姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    survery_item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    score &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;评分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, blank=True, null=&lt;span&gt;True)
    single &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;单选&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryChoices&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, blank=True, null=&lt;span&gt;True)
    suggestion &lt;/span&gt;= models.TextField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=1024, blank=True, null=&lt;span&gt;True)

    date &lt;/span&gt;= models.DateTimeField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;答题日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, auto_now_add=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　但是，如果我有另外一个需求，也需要与SurveryRecord建立外键关系，那么此时应该怎么做呢？是再给上面的表增加一个外键，然后重新修改数据库么？显然是不能，一旦数据库被创建了，我们几乎很少再去修改数据，如果再给其添加额外字段，无疑会带来不必要的麻烦。为此，我们可以利用Django自带的ContentType类，来做这件事情。&lt;/p&gt;
&lt;p&gt;　　下面来看看经过修改以后的model：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a2dc6bce-c4fd-4256-afd7-e7daaf78d23a')&quot; readability=&quot;47.5&quot;&gt;&lt;img id=&quot;code_img_closed_a2dc6bce-c4fd-4256-afd7-e7daaf78d23a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a2dc6bce-c4fd-4256-afd7-e7daaf78d23a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a2dc6bce-c4fd-4256-afd7-e7daaf78d23a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a2dc6bce-c4fd-4256-afd7-e7daaf78d23a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.fields &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GenericForeignKey, GenericRelation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ContentType
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Survery(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷
    ID        name            by_class      creator
    1    第一次班级调查      三年级五班     李老师
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    name &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查问卷名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=128, unique=&lt;span&gt;True)
    by_class &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷调查班级&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClassList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    date &lt;/span&gt;= models.DateTimeField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷创建日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, auto_now_add=&lt;span&gt;True)
    creator &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建者&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryItem(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷题目
    ID                 survery                       name                   date          answer_type
     1    1(代表上面创建的第一次班级调查)      您最喜欢吃什么水果?       xxx-xxx-xx           1
     1    1(代表上面创建的第一次班级调查)      您最喜欢什么玩具?         xxx-xxx-xx           2
     1    1(代表上面创建的第一次班级调查)      您最喜欢什么英雄人物?     xxx-xxx-xx           3
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    survery &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问卷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Survery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    name &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查问题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, max_length=255&lt;span&gt;)
    date &lt;/span&gt;= models.DateField(auto_now_add=&lt;span&gt;True)
    answer_type_choices &lt;/span&gt;=&lt;span&gt; (
        (&lt;/span&gt;1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打分(1~10分)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单选&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        (&lt;/span&gt;3, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;建议&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    )
    answer_type &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问题类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, choices=answer_type_choices, default=1&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryChoices(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷选项答案(针对选项类型)
    ID    item    content   points
    1       2       A         10分
    1       2       B         9分
    1       2       C         8分
    1       2       D         7分
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    content &lt;/span&gt;= models.CharField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, max_length=256&lt;span&gt;)
    points &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;分值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    surveryrecord &lt;/span&gt;= GenericRelation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SurveryRecord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Score(models.Model):
    item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    points &lt;/span&gt;= models.IntegerField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;分值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    surveryrecord &lt;/span&gt;= GenericRelation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SurveryRecord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Suggestion(models.Model):
    item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    suggests &lt;/span&gt;= content = models.CharField(verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, max_length=256&lt;span&gt;)
    surveryrecord &lt;/span&gt;= GenericRelation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SurveryRecord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SurveryRecord(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    问卷记录
    ID    survery      student_name   survery_item  content_type  object_id  
    1        1            1               1              1             1
    1        1            1               2              1              2
    1        1            1               3              1               3
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    survery &lt;/span&gt;= models.ForeignKey(Survery, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;问卷&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    student_name &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学员姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    survery_item &lt;/span&gt;= models.ForeignKey(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调查项&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SurveryItem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    content_type &lt;/span&gt;= models.ForeignKey(ContentType, blank=True, null=&lt;span&gt;True)
    object_id &lt;/span&gt;= models.PositiveIntegerField(blank=True, null=&lt;span&gt;True)
    content_object &lt;/span&gt;= GenericForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 這个字段不会再数据库中存在,只是在查询时有用&lt;/span&gt;
&lt;span&gt;
    date &lt;/span&gt;= models.DateTimeField(verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;答题日期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, auto_now_add=True) 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;案例二、优惠券系统设计&lt;/h2&gt;
&lt;p&gt;　　应用场景：某一在线教育网，需要为每位积极客户发一些观看视频的优惠券，但是，对于不同类型的视频，优惠券是不同。比如：有一个普通课程，需要发一些满200减30的优惠券，而又有精品课程，需要发满100键70的优惠券。根据以上需求，我们很快就知道，需要三张表，学位课程表，课程表以及优惠券表，那么，这三张表又是如何关联的呢？&lt;/p&gt;
&lt;p&gt;　　正常情况我们会想到下面這种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;A 学位课程表结构&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  ID     名称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  1    学位课1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  2    学位课2&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;B普通课程表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ID    名称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1    普通课1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2    普通课2&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;优惠券表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ID     优惠券名称     A(FK）         B(FK)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1       通用优惠券    null           null  # 两个都为空,说明全场都可以使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2       满100-10      1             null  # 给学位课程创建优惠券&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;3       满200-30     null            1    # 给普通课程创建优惠券&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是这样一来，如果再来一种课程，上面的优惠券表还需要额外新增一列，为了解决這个问题，我们可以使用ContentType类来实现上述需求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6c43e161-e2e6-46c1-8e96-ea1ebab8ed02')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_6c43e161-e2e6-46c1-8e96-ea1ebab8ed02&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6c43e161-e2e6-46c1-8e96-ea1ebab8ed02&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6c43e161-e2e6-46c1-8e96-ea1ebab8ed02',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6c43e161-e2e6-46c1-8e96-ea1ebab8ed02&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.fields &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GenericForeignKey, GenericRelation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ContentType

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your models here.&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DegreeCourse(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;学位课程
     ID    名称
     1    学位课1
     2    学位课2

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    name &lt;/span&gt;= models.CharField(max_length=128, unique=&lt;span&gt;True)

    x1 &lt;/span&gt;= GenericRelation(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Coupon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Course(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;课程
     ID    名称
     1    普通课1
     2    普通课2
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    name &lt;/span&gt;= models.CharField(max_length=128, unique=&lt;span&gt;True)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coupon(models.Model):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;优惠券生成规则

    ID     优惠券名称         content_type_id(表)         object_id（表中数据ID）
     1       通用                 null                    null
     2       满100-10               8                      1
     3       满200-30               8                      2
     4       满200-30               9                      1
    总结：
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    name &lt;/span&gt;= models.CharField(max_length=64, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;活动名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    brief &lt;/span&gt;= models.TextField(blank=True, null=True, verbose_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;优惠券介绍&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给你的model设置一个 ForeignKey 字段到ContentType. 一般命名为“content_type”.用来放想要关联的那个表在contenttype表中的id&lt;/span&gt;
    content_type = models.ForeignKey(ContentType, blank=True, null=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对象ID，用来储存你想要关联的model主键值，对于大多数model,，这是一个 PositiveIntegerField字段。并且通常命名为 “object_id”.&lt;/span&gt;
    object_id = models.PositiveIntegerField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;绑定课程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, blank=True, null=True, help_text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;可以把优惠券跟课程绑定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    content_object &lt;/span&gt;= GenericForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app01/models.py&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;根据ContentType字段查询关联字段操作&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('65487392-ff79-40f6-bedd-edf54ae251d7')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_65487392-ff79-40f6-bedd-edf54ae251d7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_65487392-ff79-40f6-bedd-edf54ae251d7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('65487392-ff79-40f6-bedd-edf54ae251d7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_65487392-ff79-40f6-bedd-edf54ae251d7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render,HttpResponse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.contenttypes.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ContentType
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(request):



    content &lt;/span&gt;= ContentType.objects.get(app_label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,model=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coupon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    model_class &lt;/span&gt;=&lt;span&gt; content.model_class()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(content)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coupon&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(model_class)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'app01.models.Coupon'&amp;gt;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(model_class.objects.all())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;&amp;lt;QuerySet [&amp;lt;Coupon: 通用&amp;gt;, &amp;lt;Coupon: 满100-10&amp;gt;, &amp;lt;Coupon: 满200-30&amp;gt;, &amp;lt;Coupon: 满200-30&amp;gt;]&amp;gt;&lt;/span&gt;


    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给学位课1或普通课创建优惠券&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; d1 = models.DegreeCourse.objects.get(id=1)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; models.Coupon.objects.create(name='优惠券', brief='2000-30', content_object=d1)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; d1 = models.Course.objects.get(id=1)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; models.Coupon.objects.create(name='优惠券', brief='100-90', content_object=d1)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;或 models.Coupon.objects.create(name='优惠券', brief='100-90', content_object_id=1)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前优惠券，绑定的课程？&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; obj = models.Coupon.objects.get(id=2)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.content_object)   #普通课1&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;通过content_object直接找到与其关联的models对象&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;正向查找：models对象.content_object得到的是models对象&lt;/span&gt;



    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前课程，都有哪些优惠券？&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; obj = models.DegreeCourse.objects.get(id=1)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.x1.all()) # [&amp;lt;Coupon: 满200-30&amp;gt;]&amp;gt;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v = models.DegreeCourse.objects.values('name','x1__brief')&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(v)    # &amp;lt;QuerySet [{'name': '学位课1', 'x1__brief': ''}, {'name': '学位课2', 'x1__brief': None}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查找：models对象.反向关联字段.all() 得到的是QuerySet对象&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app01/views.py&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;总之，如果一个表与其他表有多个外键关系，我们可以通过ContentType来解决这种关联。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 26 Feb 2018 13:51:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/8475918.html</dc:identifier>
</item>
<item>
<title>Deep Learning for Information Retrieval - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8476056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8476056.html</guid>
<description>&lt;p&gt;最近关注了一些Deep Learning在Information Retrieval领域的应用，得益于Deep Model在对文本的表达上展现的优势（比如RNN和CNN），我相信在IR的领域引入Deep Model也会取得很好的效果。&lt;/p&gt;
&lt;p&gt;IR的范围可能会很广，比如传统的Search Engine（query retrieves documents），Recommendation System（user retrieves items）或者Retrieval based Question Answering（Question retrieves answers）可能都可以属于IR的范畴。仔细考虑这些应用，不难看出他们都存在一个模式，也就是几个基本需要解决的任务：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Query（Intent）的表达和Document（Content）的表达？&lt;/li&gt;
&lt;li&gt;Matching Model：maps query-document pairs to a feature vector representation where each component reflects a certain type of similarity, e.g., lexical, syntactic, and semantic。或者这里根据matching vector与参数w直接得到matching score，相当于做了内积。&lt;/li&gt;
&lt;li&gt;Ranking Model：接受q-d的matching结果（matching vector或matching score），在当前end-to-end的训练框架下，其实使用matching score更方便一点（为什么更方便一点本文后面会说明），然后使用learning to rank的方法（pointwise，pairwise或listwise）来进行训练，重点是如何设计loss function。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我主要参考Li Hang在sigir 2016上的tutorial（&lt;a href=&quot;http://t.cn/Rt7OK2w&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://t.cn/Rt7OK2w&lt;/a&gt;）来组织我的笔记，同时会重点阅读几篇有代表性的论文来更好的理解细节。一句话，希望学习可以既见森林，又可见树木。&lt;/p&gt;
&lt;p&gt;我主要从以下四个部分来讲解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IR的基础&lt;/li&gt;
&lt;li&gt;相关的Deep Learning模型（Word Embedding，RNN和CNN）&lt;/li&gt;
&lt;li&gt;Deep Learning for IR的基础性问题&lt;/li&gt;
&lt;li&gt;Deep Learning for IR的具体应用&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;IR的基础&quot;&gt;IR的基础&lt;/h2&gt;
&lt;p&gt;下图展现了Information Retrieval的一个整体构架，&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Overview_of_Information_Retrieval.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Overview_of_Information_Retrieval.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传统的IR使用向量空间模型（VSM）来计算query和document的相似度，具体方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Representing query and document as tf-idf (or BM25) vectors&lt;/li&gt;
&lt;li&gt;Calculating cosine similarity between them&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Approach_in_Traditional_IR.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Approach_in_Traditional_IR.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现代的IR使用了一个更加general的框架来处理similarity的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Conducting query and document understanding&lt;/li&gt;
&lt;li&gt;Representing query and document as feature vectors&lt;/li&gt;
&lt;li&gt;Calculating multiple matching scores between query and document (Matching Model)&lt;/li&gt;
&lt;li&gt;Training ranker with matching scores as features using learning to rank (Ranking Model)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Approach_in_Modern_IR.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Approach_in_Modern_IR.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般这四个步骤都是在一个end-to-end的神经网络结构下进行训练的。这里注意，Matching Model只有唯一一个，就是说所有的query-document对都使用一个Matching Model，Ranking Model只使用这唯一一个Matching Model产生的Matching Score或Matching Vector。&lt;/p&gt;
&lt;p&gt;Deep Learning的方法可以渗透在IR中的不同步骤中，如下图所示，一般包括了Intent和Content的表示和Matching Model的学习。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Deep_Learning_and_IR.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Deep_Learning_and_IR.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意，这里并没有说明Ranking Model，其实Ranking Model可以看做整个神经网络结构的loss function层，不同的learning to rank方法有不同的loss形式，本文只讨论pointwise和pairwise方法，因为这两种方法效率足够高，在实践中应用的最多。&lt;/p&gt;
&lt;p&gt;同时，本文重点考察两种工业中应用最多的训练数据形式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种形式，数据提供了某个query对应的完全的document的排序（或relevance值）；&lt;/li&gt;
&lt;li&gt;第二种形式，数据只提供了某个query对应的一个或几个相关document，其他document并不知道相关性，具体类似推荐系统的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实，在工业环境中第二种数据形式是最普遍的，由于本身只有正样本，所以需要进行随机负采样，来构造一种排序关系。同时loss function也可以使用pointwise或pairwise的方法，pointwise方法直接把问题当做二分类问题来做；pairwise使用了正样本和每个负样本的偏序关系，可以使用RankSVM的形式（hinge loss）或RankNet的形式（cross entropy loss）。&lt;/p&gt;
&lt;h2 id=&quot;相关Deep-Learning模型的基础&quot;&gt;相关Deep Learning模型的基础&lt;/h2&gt;
&lt;h3 id=&quot;Word-Embedding&quot;&gt;Word Embedding&lt;/h3&gt;
&lt;p&gt;Word Embedding的教程可以参考《word2vec中的数学原理详解》，我觉得这篇文章讲的很详细也很生动。&lt;/p&gt;
&lt;h3 id=&quot;RNN&quot;&gt;RNN&lt;/h3&gt;
&lt;p&gt;RNN的教程可以参考我之前写的tutorial &lt;a href=&quot;https://github.com/pangolulu/rnn-from-scratch&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://github.com/pangolulu/rnn-from-scratch&lt;/a&gt;，其中也包含了很多拓展的资料。&lt;/p&gt;
&lt;h3 id=&quot;CNN&quot;&gt;CNN&lt;/h3&gt;
&lt;p&gt;CNN for text可以参考这篇论文&lt;a href=&quot;https://arxiv.org/pdf/1408.5882v2.pdf&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/pdf/1408.5882v2.pdf&lt;/a&gt;，他将CNN模型应用到了sentence classification的问题上，并取得了state-of-art的效果。&lt;/p&gt;
&lt;h2 id=&quot;Deep-Learning-for-IR的基础性问题&quot;&gt;Deep Learning for IR的基础性问题&lt;/h2&gt;
&lt;h3 id=&quot;Representation-Learning&quot;&gt;Representation Learning&lt;/h3&gt;
&lt;p&gt;Word Embedding的出现使得我们可以使用低维的向量空间来表示Word的语义，避免了使用one-hot表示产生了一些问题，比如维度高、one-hot词向量间无法表达相关性等等。这种embedding的方法称为hierarchy representation。&lt;/p&gt;
&lt;p&gt;那么，如何将一段文本表示成embedding的形式呢？也就是sentence representation或document representation，目的是represent syntax, semantics, and even pragmatics of sentences。目前有很多研究工作可以应用，对于sentence的表示可以使用rnn或cnn，对于document的表示会复杂一点，可以参考&lt;code&gt;Hierarchical Attention Networks for Document Classification&lt;/code&gt;和&lt;code&gt;Convolutional Neural Network Architectures for Matching Natural Language Sentences&lt;/code&gt;这两篇工作。它们主要的思想其实就是使用cnn或rnn来表示document中的sentences，然后使用表示好的sentence vectors作为另外的rnn的输入来最终表示整个document。&lt;/p&gt;
&lt;p&gt;一般CNN或RNN会随着整个网络进行end-to-end的训练，也就是Task-dependent的，也是有监督的。&lt;/p&gt;
&lt;p&gt;Representation Learning是整个IR或NLP task的基础，无论是Classification的问题，Matching的问题，还是Translation的问题，都需要先学习一个document或sentence的中间表示。可以看下面的示意图，表示IR或NLP不同任务之间的关系，和representation learning所处的位置。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/representation_learning.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/representation_learning.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Matching-Model&quot;&gt;Matching Model&lt;/h3&gt;
&lt;p&gt;Matching是IR任务中重要的一步，意义是maps query-document pairs to a feature vector representation where each component reflects a certain type of similarity, e.g., lexical, syntactic, and semantic。这里产生的是一个matching vector，接下来可以根据matching vector与参数w直接得到matching score（比如做内积）。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/matching_model.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/matching_model.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Maching Model产生的结果（matching vector或matching score）接下来会作为ranking model的输入，ranking model其实相当于整个网络的loss function，在当前end-to-end的训练框架下，其实使用matching score更方便一点。之后可以看到，使用&lt;code&gt;matching vector + LTR&lt;/code&gt;的方法和使用&lt;code&gt;maching score + ranking loss&lt;/code&gt;的方法一定程度上是等价的（这里只考虑pointwise和pairwise方法），而且后面一种形式更加general，它包含了传统的LTR的表达，也可以做一些变化，比如做一些negative sampling等等。之后在Ranking Model的讲解会重点介绍几篇论文中常见的ranking loss的形式，并且说明一下LTR方法使用matching vector和使用matching score的等价性。&lt;/p&gt;
&lt;p&gt;好，现在我们重点讲解使用深度学习来做Matching的方法。一般Matching的方法有三种形式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Projection to Latent Space&lt;/li&gt;
&lt;li&gt;One Dimensional Matching&lt;/li&gt;
&lt;li&gt;Two Dimensional Matching&lt;/li&gt;
&lt;li&gt;Tree Matching&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文暂时只讨论前三种。&lt;/p&gt;
&lt;h4 id=&quot;Matching-Projection-to-Latent-Space&quot;&gt;Matching: Projection to Latent Space&lt;/h4&gt;
&lt;p&gt;类似于VSM的方法&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Projection_to_Latent_Space.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Projection_to_Latent_Space.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Matching-One-Dimensional-Matching&quot;&gt;Matching: One Dimensional Matching&lt;/h4&gt;
&lt;p&gt;应用的比较多，可以在这个基础上融合不同的matching方法得到的结果，比如融入了第一种matching方法（query和document的vector做内积）。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/One_Dimensional_Matching.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/One_Dimensional_Matching.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Matching-Two-Dimensional-Matching&quot;&gt;Matching: Two Dimensional Matching&lt;/h4&gt;
&lt;p&gt;直接生成二维的matching score，然后用cnn模型进行学习。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Two_Dimensional_Matching.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Two_Dimensional_Matching.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一些研究的结论，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于sentence的表示学习，cnn方法要比rnn方法好，这个有待于验证。&lt;/li&gt;
&lt;li&gt;2-dimensional CNN比1-dimensional CNN方法好&lt;/li&gt;
&lt;li&gt;Matching scores can be used as features of learning to rank models，这个方法相当于可以融合不同方法得到的matching score，然后组成一个matching vector。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;Ranking-Model&quot;&gt;Ranking Model&lt;/h3&gt;
&lt;p&gt;也就是大家熟知的Learning to Rank，不过我这里想解释的更加general一点，可能在构造训练集上和LTR有一些不同。&lt;/p&gt;
&lt;p&gt;先说一下问题的定义，假设我有query &lt;code&gt;q&lt;/code&gt;和候选的document集合&lt;code&gt;D={d1, d2, ..., dn}&lt;/code&gt;。对于训练集，首先必须再次强调一下训练数据的形式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种形式，数据提供了某个query对应的完全的document的排序（或relevance值）；&lt;/li&gt;
&lt;li&gt;第二种形式，数据只提供了某个query对应的一个或几个相关document，其他document并不知道相关性，具体类似推荐系统的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后说一下LTR的输入，LTR接受Matching Model得到的结果，即可以使Matching Vector或者是Matching Score。&lt;/p&gt;
&lt;p&gt;对于第一种形式的数据，可以采用传统的LTR方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pointwise方法直接当做回归问题，可以看到Matching Score就可以看做是回归的值了，如果使用Matching Vector作为输入，相当于继续使用一些参数W做了一次回归问题。但其实这是可以通过神经网络end-to-end学习出来的，相当于整个网络（包括Representation Learning和Matching Model）的目标函数就是回归问题（损失函数为最小二乘）。&lt;/li&gt;
&lt;li&gt;pairwise方法考虑了document集合中两两document的偏序关系，由此构造训练集。考虑所有两两的document，比如&lt;code&gt;d1&lt;/code&gt;和&lt;code&gt;d2&lt;/code&gt;，如果训练集中&lt;code&gt;d1 &amp;gt; d2&lt;/code&gt;，那么我们希望通过Matching Model得到的&lt;code&gt;d1&lt;/code&gt;和&lt;code&gt;d2&lt;/code&gt;对应的Matching Score &lt;code&gt;m1&lt;/code&gt;要大于&lt;code&gt;m2&lt;/code&gt;。在上面的intuition的指导下，我们可以定义不同的loss function了，最常见就是hinge loss function，也就是我们希望&lt;code&gt;m1&lt;/code&gt;比&lt;code&gt;m2&lt;/code&gt;要至少大于一个值，对应了SVM中的1，具体可以写成&lt;code&gt;max(0, theta - m1 + m2)&lt;/code&gt;。这个Hinge Loss的定义方法其实就是RankSVM的方法，不过传统的RankSVM的定义使用了Matching Vector作为输入，比如&lt;code&gt;v1&lt;/code&gt;和&lt;code&gt;v2&lt;/code&gt;，并且重新构造了训练集，&lt;code&gt;v1 - v2&lt;/code&gt;对应的label为&lt;code&gt;+1&lt;/code&gt;（正类），&lt;code&gt;v2 - v1&lt;/code&gt;对应的label为&lt;code&gt;-1&lt;/code&gt;（负类）。大家可以看一下RankSVM的公式形式，不难会发现RankSVM和我这里表达的定义其实是等价的，感兴趣的同学可以参考&lt;a href=&quot;http://www.cnblogs.com/kemaswill/p/3241963.html&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/kemaswill/p/3241963.html&lt;/a&gt;。其实，对于RankNet也是相同的道理，感兴趣的可以参考&lt;a href=&quot;http://www.cnblogs.com/kemaswill/p/kemaswill.html&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/kemaswill/p/kemaswill.html&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于第二种形式的数据，训练数据中只提供了某个query对应的一个或几个相关document，其他document并不知道相关性。由于只提供了正反馈的数据，目前主流的做法就是进行contrastive sampling，也就是随机负采样。当有了负样本之后，相当于可以得到document之间的偏序关系了，就可以使用LTR的方法，这里面我倾向于称为ranking loss，也包括了pointwise和pairwise这两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pointwise方法直接把问题当做二分类来做，正相关的document为正例，采样的负相关的数据为负例。如果接收Matching Score，可以在外面套一层sigmoid函数转化成概率，使用交叉熵损失函数进行训练；如果接收Matching Vector，相当可以再做一次logistics regression，但其实和前面方法是等价的。&lt;/li&gt;
&lt;li&gt;pairwise方法是目前主流的做法，对一个query来说正相关的document偏序关系要大于这个query下随机采样的负相关的document，采样的个数可以作为一个超参数。这样可以使用和第一种数据形式的pairwise方法设计ranking loss了，这里不再赘述。一般文献里面都会使用hinge loss，表达示为&lt;code&gt;e(x, y_pos, y_neg) = max(0, theta - s_match(x, y_pos) + s_match(x, y_neg))&lt;/code&gt;，其中&lt;code&gt;x&lt;/code&gt;为query，&lt;code&gt;y_pos&lt;/code&gt;为正相关document，&lt;code&gt;y_neg&lt;/code&gt;为负相关document，&lt;code&gt;s_match&lt;/code&gt;为Matching Model得到的Matching Score。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;Deep-Learning-for-IR的具体应用&quot;&gt;Deep Learning for IR的具体应用&lt;/h2&gt;
&lt;h3 id=&quot;Document-Retrieval&quot;&gt;Document Retrieval&lt;/h3&gt;
&lt;p&gt;这里考虑Learning to Rank for Document Retrieval，下图是整体的构架图，可以看到系统直接返回Ranking Model，相当于Matching Model和Ranking Model以一起学出来的。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Document_Retrieval.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Document_Retrieval.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体有一下几点考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;simultaneously learn matching model and ranking model&lt;/li&gt;
&lt;li&gt;Matching model: Projection into Latent Space, Using CNN&lt;/li&gt;
&lt;li&gt;Ranking model: taking matching model output as features, as well as other features, Using DNN&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较重要的就是Matching Model和Ranking Model的关系，下图直观的表示出来：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Relation_between_Matching_Model_and_Ranking_Model.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Relation_between_Matching_Model_and_Ranking_Model.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实，在我看来图中最后都会输出一个score，这个score就是matching score，而这个是最重要的。&lt;/p&gt;
&lt;p&gt;下面给出一篇论文的网络结构图，这篇论文发表在sigir 2015，叫做&lt;code&gt;Learning to Rank Short Text Pairs with Convolutional Deep Neural Networks&lt;/code&gt;，有兴趣的同学可以回去精读。&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/sigir_2015.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/sigir_2015.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，这篇论文使用了pointwise的方法，所以是一个二分类问题；使用CNN来对query和document学习representation；使用一个双线性函数来match query-vector和document-vector（&lt;code&gt;q_vec M d_vec&lt;/code&gt;的内积）；之后与query-vector和document-vector或者加上其他feature一同连接成一个feature vector，这个就是Matching Vector；网络后几层经过若干fully connected层，最后会得到一个实数，就是Matching Score；由于是一个二分类问题，Matching Score外面套一层sigmoid函数转换成概率，使用交叉熵损失函数进行训练。&lt;/p&gt;
&lt;h3 id=&quot;Retrieval-based-Question-Answering&quot;&gt;Retrieval based Question Answering&lt;/h3&gt;
&lt;p&gt;Retrieval based QA其实和Document Retrieval没有什么区别，下图给出了一个整体的框架图：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Retrieval_based_QA_System.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Retrieval_based_QA_System.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体的一篇论文可以参考李航发表在nips 2015的文章，题目叫&lt;code&gt;Convolutional Neural Network Architectures for Matching Natural Language Sentences&lt;/code&gt;。文中也是用了CNN来学习sentence的表示，但文中提出了两种Matching Model结构，一种是One Dimensional Matching，另一种是Two Dimensional Matching。分别表示如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/NIPS_One_Dimensional_Matching.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/NIPS_One_Dimensional_Matching.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/NIPS_Two_Dimensional_Matching.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/NIPS_Two_Dimensional_Matching.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后Matching Model会生成一个Matching Score，正如我在这篇博文阐述的一样。&lt;/p&gt;
&lt;p&gt;对于Ranking Model，也就是ranking loss，这篇文章使用了pairwise的方式，使用了hinge loss function，具体为：&lt;code&gt;e(x, y+, y−) = max(0, 1 + s(x, y−) − s(x, y+))&lt;/code&gt;。其中，&lt;code&gt;y+&lt;/code&gt;比&lt;code&gt;y-&lt;/code&gt; match &lt;code&gt;x&lt;/code&gt;的分数要高，也就是&lt;code&gt;y+&lt;/code&gt;排在&lt;code&gt;y-&lt;/code&gt;之前；&lt;code&gt;s(x, y)&lt;/code&gt;是&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;的matching score。&lt;/p&gt;
&lt;h3 id=&quot;Image-Retrieval&quot;&gt;Image Retrieval&lt;/h3&gt;
&lt;p&gt;这个任务的意义是用文字来搜索图，反过来或者用图来搜索文字。一个整体的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Image_Retrieval.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Image_Retrieval.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体的一篇论文也是来自李航老师的，发表在ICCV 2016，题目叫作&lt;code&gt;Multimodal Convolutional Neural Networks for Matching Image and Sentence&lt;/code&gt;。这篇论文使用了Multimodal CNN的方法，具体为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Represent text and image as vectors and then match the two vectors&lt;/li&gt;
&lt;li&gt;三种matching方法：Word-level matching, phrase-level matching, sentence-level matching&lt;/li&gt;
&lt;li&gt;CNN model works better than RNN models (state of the art) for text&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中sentence-level matching和Word-level matching的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Sentence_level_Matching.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Sentence_level_Matching.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a class=&quot;fancybox&quot; title=&quot;IR&quot; href=&quot;http://pangolulu.github.io/assets/img/dl-ir/Word_level_Matching_Model.png&quot; rel=&quot;gallery0&quot;&gt;&lt;img src=&quot;http://pangolulu.github.io/assets/img/dl-ir/Word_level_Matching_Model.png&quot; alt=&quot;IR&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后网络会输出一个Matching Score，这篇文章也使用了pairwise方法，但是训练数据没有负相关样本，所以使用了随机负采样的方法；loss function选择了hinge loss，具体形式为&lt;code&gt;e_θ(xn, yn, ym) = max(0, theta − s_match(xn, yn) + s_match(xn, ym)&lt;/code&gt;，其中&lt;code&gt;ym&lt;/code&gt;是随机采样的负样本。&lt;/p&gt;
&lt;p&gt;总结一下，可以看到，无论是Document Retrieval，Retrieval based Question Answering还是Image Retrieval，它们的模式都已一样的，都包括了三个基本要素：Representation Learning，Matching Model和Ranking Model。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文在于帮助梳理一下这种retrieve，match，similarity或者说recommend等一类问题的一些模式和关键要素，使点连成线，在大脑中构建真正的理解，能做到举一反三，遇到相似的任务能很自然的联想过去。大家如果有什么意见或想法，欢迎在下面留言。&lt;/p&gt;
&lt;h2 id=&quot;Reference&quot;&gt;Reference&lt;/h2&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Convolutional Neural Network Architectures for Matching Natural Language Sentences, nips 2015&lt;/li&gt;
&lt;li&gt;Learning to Rank Short Text Pairs with Convolutional Deep Neural Networks, sigir 2015&lt;/li&gt;
&lt;li&gt;Multimodal Convolutional Neural Networks for Matching Image and Sentence, iccv 2016&lt;/li&gt;
&lt;li&gt;TOWARDS UNIVERSAL PARAPHRASTIC SENTENCE, ICLR 2016&lt;/li&gt;
&lt;li&gt;deep_learning_for_information_retrieval, sigir 2016 tutorial&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 26 Feb 2018 13:12:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8476056.html</dc:identifier>
</item>
<item>
<title>[译]Serilog Tutorial - 假正经哥哥</title>
<link>http://www.cnblogs.com/xuanye/p/8474469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuanye/p/8474469.html</guid>
<description>&lt;p&gt;在过去的几年中，结构化日志已经大受欢迎。而Serilog是 .NET 中最著名的结构化日志类库 ,我们提供了这份的精简指南来帮助你快速了解并运用它。&lt;/p&gt;
&lt;h2 id=&quot;内容&quot;&gt;0. 内容&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;设定目标&lt;/li&gt;
&lt;li&gt;认识Serilog&lt;/li&gt;
&lt;li&gt;事件和级别&lt;/li&gt;
&lt;li&gt;触发和收集结构化数据&lt;/li&gt;
&lt;li&gt;为过滤和关联添加事件标记&lt;/li&gt;
&lt;li&gt;大海捞针 [Finding needles in the haystack]&lt;/li&gt;
&lt;li&gt;下一步是什么？&lt;/li&gt;
&lt;li&gt;获得帮助&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;设定目标&quot;&gt;1. 设定目标&lt;/h2&gt;
&lt;p&gt;你可能之前已经在项目中使用了Serilog，或者你有一个新的项目希望使用Serilog，又或者你只是对结构化日志记录感兴趣: 那就非常好！ 你来对地方了。&lt;/p&gt;
&lt;p&gt;然而，更进一步来说，你的目标可能是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;希望在用户之前发现代码中的BUG和错误&lt;/li&gt;
&lt;li&gt;为了更快的找到生产环境中的问题&lt;/li&gt;
&lt;li&gt;深入的了解系统运行表现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Serilog使用json格式来记录应用程序中的事件，方便我们可以快速的查询日志，关键是可以方便地过滤和查询日志，而不用编写正则表达式。&lt;/p&gt;
&lt;p&gt;在本教程中，我们将介绍最关键的几个部分，帮助我们可以在生成环境中提供令人惊叹的诊断能力。[注：原文这句挺拗口]&lt;/p&gt;
&lt;h2 id=&quot;认识-serilog&quot;&gt;2. 认识 Serilog&lt;/h2&gt;
&lt;p&gt;那就让我们开始吧！为了更好的理解，你可以先创建一个新的.Net console 项目，可以是netcore或者传统的NETFramework版本。&lt;/p&gt;
&lt;p&gt;Serilog 通过NuGet分发，项目包括一个Seirlog核心项目&lt;em&gt;Seirlog&lt;/em&gt;和很多接收器&lt;em&gt;sinks&lt;/em&gt;(超过100个)，这些接收是通过插件的方式来实现将日志写入到各种终端，文件,邮件,数据库或日志服务器&lt;/p&gt;
&lt;p&gt;我们将通过使用&lt;em&gt;Serilog&lt;/em&gt;和&lt;em&gt;Serilog.Sinks.Console&lt;/em&gt;这两个组件开始，在稍后讨论其他选项：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet add package Serilog
dotnet add package Serilog.Sinks.Console&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是世界上最简单的&lt;em&gt;Serilog&lt;/em&gt;配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Serilog;

class Program  
{
    public static void Main(string[] args)
    {
        using (var log = new LoggerConfiguration()
            .WriteTo.Console()
            .CreateLogger())
        {
            log.Information(&quot;Hello, Serilog!&quot;);
            log.Warning(&quot;Goodbye, Serilog.&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们稍微分解一下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;LoggerConfiguration&lt;/code&gt; 类提供一个流式接口用于构建一个日志记录管道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WriteTo.Console（)&lt;/code&gt; 将控制台接收器添加到上述管道中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CreateLogger（）&lt;/code&gt; 组装并返回一个实现&lt;code&gt;ILogger&lt;/code&gt;接口的&lt;code&gt;Logger&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;上述Logger对象同样实现了IDisposable，所以我们可以在&lt;code&gt;using&lt;/code&gt;中调用它&lt;/li&gt;
&lt;li&gt;最后&lt;code&gt;log.Information（）&lt;/code&gt;和&lt;code&gt;log.Warning（）&lt;/code&gt; 触发记录日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个日志记录管道是一个可释放的[disposable],这可能会让你有点意外，但是请记住，记录器通常是要写入文件，数据库等等： 很多&lt;em&gt;sinks&lt;/em&gt; 必须被完全地关闭掉。尽管这样，也仅仅在应用程序退出前，根logger才需要被释放。而在应用程序中使用logger是不需要关心这些细节的。&lt;/p&gt;
&lt;p&gt;你运行了这个程序嘛？这是你看到的效果吧？&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697065c1gy1fottdd5d6nj20sf0dht8r.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Apart from just passing it around everywhere, there are two possibilities. [ 除了在各地传递外，还有两种可能性。] If you're using an IoC container, you might have components receive an ILogger through dependency injection. [ 如果您使用的是IoC容器，则可能会让组件通过依赖注入来接收ILogger。] Packages like AutofacSerilogIntegration can help with that. [ 像AutofacSerilogIntegration这样的软件包可以提供帮助。]&lt;/p&gt;
&lt;p&gt;现在最直接的问题是：我们在应用程序的其他类里面如何获得这个&lt;code&gt;log&lt;/code&gt;对象,除了到处传递之外，还有两个办法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果你使用IoC容器，你可以组件注入一个ILogger对象来接收，像&lt;code&gt;AutofacSerilogIntegration&lt;/code&gt;的包括帮助你实现这种方式。&lt;/li&gt;
&lt;li&gt;或者，您可以将Logger对象存储在众所周知的位置; Serilog 已经内容内置了一个静态的Log对象，就像这样：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
Log.Logger = new LoggerConfiguration()  
    .WriteTo.Console()
    .CreateLogger();

Log.Information(&quot;Hello again, Serilog!&quot;);

Log.CloseAndFlush();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Log&lt;/code&gt;类提供所有与&lt;code&gt;ILogger&lt;/code&gt;接口相同的方法,这里我们显示调用&lt;code&gt;Log.CloseAndFlush（）&lt;/code&gt;来关闭它，而不是使用&lt;code&gt;using&lt;/code&gt;代码块&lt;/p&gt;
&lt;p&gt;你可以使用依赖注入的方式，也可以是静态属性的方式 - 这取决你的个人喜好问题。为了简单起见，我们在本教程中使用了静态Log的方式。&lt;/p&gt;
&lt;blockquote readability=&quot;6.6129032258065&quot;&gt;
&lt;p&gt;也许，你不是在编写一个控制台应用程序。我们将使用Console应用作为广为人知的示例，但是你一旦完成了本教程，您应该查看目标平台的文档（例如，&lt;a href=&quot;https://nblumhardt.com/2017/08/use-serilog/&quot; title=&quot;Leaner, meaner ASP.NET Core 2 logging&quot;&gt;ASP.NET Core&lt;/a&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;event-and-level-时间和级别&quot;&gt;3. Event and Level [时间和级别]&lt;/h2&gt;
&lt;p&gt;和一些老的日志类库相比（如log4net），在使用Serilog时，你需要做的就是最大改变就是思考日志&lt;em&gt;事件&lt;/em&gt;[log &lt;em&gt;events&lt;/em&gt;]，而不是日志&lt;em&gt;消息&lt;/em&gt;[log &lt;em&gt;message&lt;/em&gt;]，一条事件[event]由以下几个内容组成:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件发生时的&lt;strong&gt;时间戳&lt;/strong&gt;[&lt;strong&gt;timestamp&lt;/strong&gt;]&lt;/li&gt;
&lt;li&gt;描述何时应该捕获事件的&lt;strong&gt;级别&lt;/strong&gt;[&lt;strong&gt;level&lt;/strong&gt;]&lt;/li&gt;
&lt;li&gt;记录事件的消息[&lt;strong&gt;message&lt;/strong&gt;]内容]&lt;/li&gt;
&lt;li&gt;描述事件的命名&lt;strong&gt;属性&lt;/strong&gt;[&lt;strong&gt;properties&lt;/strong&gt;]&lt;/li&gt;
&lt;li&gt;还可能有一个&lt;strong&gt;Exception&lt;/strong&gt;对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;您可以将日志事件格式化为控制台的可读文本，正如我们在第一个示例中看到的那样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;11:33:01 [INF] Hello, Serilog!  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，您可以将相同的事件格式化为JSON并将其发送到远程日志服务器：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;json {&quot;@t&quot;:&quot;2017-11-20T11:33:01.22138&quot;,&quot;@m&quot;:&quot;Hello, Serilog!&quot;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在背后，应用程序中的日志语句会创建&lt;code&gt;LogEvent&lt;/code&gt;对象，而连接到管道的接收器[&lt;em&gt;sinks&lt;/em&gt;]会知道如何记录它们。&lt;/p&gt;
&lt;p&gt;### Logging levels&lt;/p&gt;
&lt;p&gt;Serilog速度很快，但始终构建和记录详细的日志事件会浪费CPU，磁盘和网络资源。为了管理这个，Serilog事件被赋予了多种级别：&lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Information&lt;/code&gt;, &lt;code&gt;Warning&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt;等。对应的有一个&lt;code&gt;Log.*()&lt;/code&gt;方法来对应各个级别。&lt;/p&gt;
&lt;p&gt;在开发过程中，可能会打开调试级别的事件：&lt;/p&gt;
&lt;p&gt;```csharp&lt;br/&gt;Log.Logger = new LoggerConfiguration()&lt;br/&gt;.MinimumLevel.Debug() // &amp;lt;- Set the minimum level&lt;br/&gt;.WriteTo.Console()&lt;br/&gt;.CreateLogger();&lt;/p&gt;
&lt;p&gt;// In a tight loop...&lt;br/&gt;Log.Debug(&quot;Processing item {ItemNumber} of {ItemCount}&quot;, itemNumber, itemCount);&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;在生成环境中，通常关闭调试的日志，并将最小的日志级别设置成&lt;code&gt;Information&lt;/code&gt;,以便只记录重要的事件，在&lt;a href=&quot;https://github.com/serilog/serilog/wiki/Writing-Log-Events#log-event-levels&quot;&gt;这篇文档&lt;/a&gt;中可以获得有关Serilog Logger Lever的更多信息&lt;/p&gt;
&lt;p&gt;Tip: Serilog has special handling for Exception objects; methods like Log.Error() take the exception as the first parameter, e.g. [ 提示：Serilog对Exception对象有特殊的处理;] Log.Error(ex, &quot;Task {TaskName} was canceled&quot;, task). [ Log.Error（例如，“任务{任务名称}被取消”，任务）。] Don't include exceptions in the log message itself. [ 不要在日志消息本身中包含异常。]&lt;br/&gt;&lt;strong&gt;提示&lt;/strong&gt;:Serilog对Exception对象有特殊的处理; 像方法&lt;code&gt;Log.Error()&lt;/code&gt; 将 &lt;em&gt;exception&lt;/em&gt; 作为第一个参数，例如&lt;code&gt;Log.Error(ex, &quot;Task {TaskName} was canceled&quot;, task)&lt;/code&gt;，不要将异常的包括在message消息中&lt;/p&gt;
&lt;h2 id=&quot;触发和收集结构化数据&quot;&gt;4. 触发和收集结构化数据&lt;/h2&gt;
&lt;p&gt;让我们回到最后一个代码片段：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var itemNumber = 10;  
var itemCount = 999;  
Log.Debug(&quot;Processing item {ItemNumber} of {ItemCount}&quot;, itemNumber, itemCount);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您是否注意到日志消息中的&lt;code&gt;{ItemNumber}&lt;/code&gt;这样的占位符？ 这不是一个C#的内插字符串[&lt;em&gt;Interpolated string&lt;/em&gt; C# 6.0的新特性],&lt;code&gt;Log.*()&lt;/code&gt;方法接收一个&lt;a href=&quot;https://messagetemplates.org&quot;&gt;消息模板&lt;/a&gt;,另外一种.NET格式化字符串，除了支持传统的&lt;code&gt;{0}&lt;/code&gt;的方式，还支持&lt;code&gt;{Name}&lt;/code&gt;的方式。&lt;/p&gt;
&lt;p&gt;这看起来有点奇怪，除非您意识到通过这样做，Serilog可以将这些消息的一部分作为类的属性与人性化的文本一起捕获：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;@t&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;2017-11-20T11:33:01.22138&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;@l&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Debug&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;@m&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Processing item 10 of 999&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;ItemNumber&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;ItemCount&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;999&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为什么要这样做？因为通过这种有趣的字段插入方式，并作为属性记录到事件日志中，我们可以立即使用优雅的简单的过滤器来查找事件，就像&lt;code&gt;ItemNumber &amp;gt; 900&lt;/code&gt;,而无需通过正则表达式从消息中提取了。&lt;/p&gt;
&lt;p&gt;进一步，我们可以使用 &lt;code&gt;@&lt;/code&gt; 结构捕获运算符 来获取不仅仅是平坦的属性值，而是完整的对象：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var user = new { Name = &quot;Nick&quot;, Id = &quot;nblumhardt&quot; };  
Log.Information(&quot;Logged on user {@User}&quot;, user);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，&lt;code&gt;user&lt;/code&gt;对象被捕获，并生成的JSON中，以便我们可以使用查询来查找事件,如:&lt;code&gt;User.Id = 'nblumhardt'&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;@t&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;2017-11-20T11:33:01.22138&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;@m&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Logged on user {&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Nick&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Id&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;nblumhardt&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;}&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;User&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;&quot;Name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Nick&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;&quot;Id&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;nblumhardt&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生产环境的监控和调试已经非常困难和耗时，而且经常是压力山大的任务：而通过将相关的数据放在手边，Serilog除去了运维操作相关活动的最大难题之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: 从Visual Studio Marketplace安装令人惊叹的&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Suchiman.SerilogAnalyzer&quot;&gt;Serilog Analyzer&lt;/a&gt;，可以帮助你检查你的消息模板类型（ 注：这个插件还能帮你通过配置代码生成appsetting.json的内容，但是只支持生成一级配置:( ）&lt;/p&gt;
&lt;p&gt;这实际上有多大的差异取决于你如何收集Serilog的事件。一般来说，日志事件进入文本文件并用&lt;code&gt;grep&lt;/code&gt;进行搜索。Serilog也可以记录文本文件，但不能在记事本中执行&lt;code&gt;ItemNumber&amp;gt; 900&lt;/code&gt;，因此您需要评估更强大的工具来执行此操作。&lt;/p&gt;
&lt;h3 id=&quot;写-json-格式的日志文件&quot;&gt;写 JSON 格式的日志文件&lt;/h3&gt;
&lt;p&gt;如果您的需求很简单，您可以将JSON写入日志文件，并使用支持JSON的工具直接查询文件。] [ Serilog的文件接收器[&lt;em&gt;sink&lt;/em&gt;]和紧凑的JSON格式化类库[compact JSON formatter]使第一部分变得简单。 让我们重新建一个控制台应用程序，并安装下列软件包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet add package Serilog
dotnet add package Serilog.Sinks.File  
dotnet add package Serilog.Formatting.Compact  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;Main&lt;/code&gt;函数中插入:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Log.Logger = new LoggerConfiguration()  
    .MinimumLevel.Debug()
    .WriteTo.File(new CompactJsonFormatter(), &quot;log.clef&quot;)
    .CreateLogger();

var itemCount = 99;  
for (var itemNumber = 0; itemNumber &amp;lt; itemCount; ++itemNumber)  
    Log.Debug(&quot;Processing item {ItemNumber} of {ItemCount}&quot;, itemNumber, itemCount);

Log.CloseAndFlush();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这个程序将产生使用Serilog的紧凑格式[compact]，在文件log.clef中生成以&lt;a href=&quot;https://en.wikipedia.org/wiki/JSON_streaming&quot; title=&quot;newline-delimited JSON stream&quot;&gt;换行符分隔的&lt;code&gt;JSON&lt;/code&gt;流&lt;/a&gt;,如果没有使用&lt;code&gt;CompactJsonFormatter&lt;/code&gt;，则会创建一个简单饿扁平日志文件。&lt;/p&gt;
&lt;p&gt;如果你在文本编辑器中打开文件，你会看到JSON事件，就像我们上面使用的例子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/datalust/clef-tool&quot;&gt;CLEF-tool&lt;/a&gt; 是查询CLEF格式的日志文件的方便的命令行应用程序：(注:貌似只支持windows)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697065c1gy1fotvarg5n7j20xe0dzdgb.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意第二行的过滤器&lt;code&gt;ItemNumber&amp;gt; 95&lt;/code&gt;：毫不费力地在大型日志流中定位事件,就是结构化日志记录的好处吧。&lt;/p&gt;
&lt;h3 id=&quot;将日志写入日志服务器&quot;&gt;将日志写入日志服务器&lt;/h3&gt;
&lt;p&gt;将日志事件从多个应用程序发送到中央服务器或日志聚合服务非常方便,而不是试图在生产环境中多个日志进行浑水摸鱼[shuffle log files]&lt;/p&gt;
&lt;p&gt;日志服务器通常通过HTTP/S或UDP在网络上接收事件，并为开发人员和操作员工程师提供用户界面，以便在出现问题时搜索和分析日志流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/serilog/serilog/wiki/Provided-Sinks&quot;&gt;Serilog接收器&lt;/a&gt;[sinks]支持大量的日志服务器，其中许多具有结构化数据支持。&lt;/p&gt;
&lt;p&gt;注：这段是广告就不翻译了，读者可以根据实际需求选择自己的日志服务器。&lt;/p&gt;
&lt;h2 id=&quot;为过滤和关联标记事件&quot;&gt;5. 为过滤和关联标记事件&lt;/h2&gt;
&lt;p&gt;我们刚刚看到消息模板如何实现我们传统上认为可以有效搜索和分析的日志“消息”。&lt;/p&gt;
&lt;p&gt;结构化日志记录的另一方面是通过某种因果关系或空间关联来识别相关事件集合。事件触发:[Events raised: ]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在处理单个HTTP请求期间&lt;/li&gt;
&lt;li&gt;从特定的机器，应用程序，服务或组件&lt;/li&gt;
&lt;li&gt;关于单个客户，订单或交易&lt;/li&gt;
&lt;li&gt;起因于事件的因果链&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Serilog通过&lt;em&gt;enrichment&lt;/em&gt;来处理所有这些情况（以及其他情况）。&lt;em&gt;Enrichment&lt;/em&gt;只是为事件添加附加属性，而不是源自消息模板的属性&lt;/p&gt;
&lt;h3 id=&quot;添加enriching特定的属性&quot;&gt;添加[Enriching]特定的属性&lt;/h3&gt;
&lt;p&gt;最简单的enrichment方法将固定属性值添加到源自日志记录管道的所有事件，可以通过&lt;code&gt;Enrich.WithProperty()&lt;/code&gt;方法快速实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Log.Logger = new LoggerConfiguration()  
    .Enrich.WithProperty(&quot;Application&quot;, &quot;Demo&quot;)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;) //Seq 日志服务器
    .CreateLogger();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;LogEvents&lt;/code&gt;上，通过&lt;em&gt;enrichment&lt;/em&gt;添加的属性看起来与源自消息模板的属性相同&lt;/p&gt;
&lt;p&gt;&lt;code&gt;json { &quot;@t&quot;: &quot;2017-11-20T11:33:01.22138&quot;, &quot;@l&quot;: &quot;Debug&quot;, &quot;@m&quot;: &quot;Processing item 10 of 999&quot;, &quot;ItemNumber&quot;: 10, &quot;ItemCount&quot;: 999, &quot;Application&quot;: &quot;Demo&quot; }&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;丰富特殊的属性&quot;&gt;丰富特殊的属性&lt;/h3&gt;
&lt;p&gt;通过创建和使用上下文记录器，可以将属性添加到一个或几个相关事件中，而不是增加具有相同值的所有事件&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var orderLog = Log.ForContext(&quot;OrderId&quot;, order.Id);  
orderLog.Information(&quot;Looking up product codes&quot;);  
// ...
orderLog.Information(&quot;Product lookup took {Elapsed} ms&quot;, elapsed.TotalMilliseconds);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，通过&lt;code&gt;orderLog&lt;/code&gt;发出的两个事件都会附加一个&lt;code&gt;OrderId&lt;/code&gt;属性。&lt;br/&gt;&lt;code&gt;Enrichmen&lt;/code&gt;是附加的:如果应用程序属性设置在管道级别，则上面的第二个事件将携带&lt;code&gt;Elapsed&lt;/code&gt;（来自消息），&lt;code&gt;OrderId&lt;/code&gt;（来自上下文记录器）和&lt;code&gt;Application&lt;/code&gt;（来自记录管道）。&lt;/p&gt;
&lt;h3 id=&quot;丰富消息源类型信息&quot;&gt;丰富消息源类型信息&lt;/h3&gt;
&lt;p&gt;记录器特定的&lt;em&gt;enrichment&lt;/em&gt;一个特例是关于如何使用创建它们的类标记事件&lt;/p&gt;
&lt;p&gt;在名为&lt;code&gt;HomeController&lt;/code&gt;的类中，使用以下命令创建类型特定的记录器：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly ILogger _log = Log.ForContext&amp;lt;HomeController&amp;gt;();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;_log&lt;/code&gt;发出的事件将携带一个值为&lt;code&gt;MyApp.Controllers.HomeController&lt;/code&gt;的&lt;code&gt;SourceContext&lt;/code&gt;属性。&lt;/p&gt;
&lt;h3 id=&quot;充分利用上下文&quot;&gt;充分利用上下文&lt;/h3&gt;
&lt;p&gt;为了丰富工作单元中所有事件[为所有事件添加特定属性],&lt;code&gt;Serilog&lt;/code&gt;提供了&lt;code&gt;LogContext&lt;/code&gt;,首先需要使用&lt;code&gt;Enrich.FromLogContext()&lt;/code&gt;在&lt;code&gt;LoggerConfiguration&lt;/code&gt;级别启用：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Log.Logger = new LoggerConfiguraition()  
     .Enrich.FromLogContext()
     // ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LogContext可以被认为是一堆&lt;code&gt;(key,value)&lt;/code&gt;键值对;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using (LogContext.PushProperty(&quot;MessageId&quot;, message.Id))  
{
    Log.Debug(&quot;Dispatching message of type {MessageType}&quot;, message.GetType());
    await handler.HandleAsync(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于LogContext有趣的是没有什么需要对象需要传递。在示例代码中，&lt;code&gt;HandleAsync()&lt;/code&gt;以及由它调用的任何其他方法的实现可以直接使用&lt;code&gt;Log&lt;/code&gt;和&lt;code&gt;ILogger&lt;/code&gt; - MessageId属性将自动T并添加&lt;code&gt;LogEvent&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: &lt;code&gt;LogContext&lt;/code&gt;是一个堆栈;推送到堆栈上的属性必须通过释放从PushProperty()返回的对象， -- 上述通过手动使用&lt;code&gt;using&lt;/code&gt;块的方式&lt;/p&gt;
&lt;h3 id=&quot;已经存在的enricher&quot;&gt;已经存在的Enricher&lt;/h3&gt;
&lt;p&gt;所有&lt;em&gt;enrichment&lt;/em&gt; API都是使用&lt;code&gt;Enricher&lt;/code&gt;的实现Serilog的&lt;code&gt;ILogEventEnricher&lt;/code&gt;接口的对象来实现的。&lt;/p&gt;
&lt;p&gt;NuGet中为线程细节，机器信息和用户详细信息等内容提供了一些有趣的预先构建的Enricher实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/serilog/serilog-enrichers-thread&quot;&gt;Serilog.Enrichers.Thread&lt;/a&gt; 通过 Enrich.WithThreadId() 来添加线程ID相关的扩展:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Log.Logger = new LoggerConfiguration()  
    .Enrich.WithThreadId()
    // ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这将为事件附加一个&lt;code&gt;ThreadId&lt;/code&gt;属性，以便交错事件可以再次分开。&lt;/p&gt;
&lt;p&gt;我们将在下一节中看到一个简单的例子，说明如何编写和插入自己的应用程序专用的&lt;code&gt;Enricher&lt;/code&gt;程序。&lt;/p&gt;
&lt;h2 id=&quot;大海捞针-finding-needles-in-the-haystack&quot;&gt;6. 大海捞针 Finding needles in the haystack&lt;/h2&gt;
&lt;p&gt;如果我们已经知道如何使用Serilog调用消息模板和enrichment结构化日志的两个支柱，那么第三个支柱就是隐式事件类型的概念。&lt;/p&gt;
&lt;p&gt;结构化日志适合有效处理大量日志数据。关于大型日志流的一个有趣的观察是，真实产生的事件比编写日志语句代码块时要多的多（注:这算什么发现）&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Log.Debug(&quot;Processing item {ItemNumber} of {ItemCount}&quot;, itemNumber, itemCount);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着,尽管生成了许多独特的消息字符串,如&lt;code&gt;&quot;Processing item 31 of 4159&quot;&lt;/code&gt;,但由此日志记录语句生成的每个事件共享相同的消息模板，即&lt;code&gt;&quot;Processing item {ItemNumber} of {ItemCount}&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Serilog及其许多sinks 利用这一事实从根本上改进了查询和过滤日志事件的体验。如果消息模板与事件一起保存，则下面的过滤器可以立即从嘈杂的日志记录语句中排除成千上万的事件，从而更容易看到否则会被淹没的有趣事件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@MessageTemplate &amp;lt;&amp;gt; 'Processing item {ItemNumber} of {ItemCount}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反转也适用 - 放大事件类型可以从单个日志记录语句中查找所有事件&lt;/p&gt;
&lt;p&gt;如何利用此功能取决于您存储和搜索日志的位置。接下来我们会看看细节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;:字符串链接，C#内插字符串，以及其他技术手段来预格式化传递给Serilog的消息内容，会取消此功能。详细请看 &lt;a href=&quot;https://nblumhardt.com/2014/09/how-not-to-parameterize-serilog-events/&quot;&gt;How (not) to parameterize Serilog events&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;隐式事件类型&quot;&gt;隐式事件类型&lt;/h3&gt;
&lt;p&gt;存储，然后过滤罗嗦的消息模板并不总是理想的。 相反，通常从消息模板创建一个数字哈希值，并将其与事件一起存储：&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697065c1gy1fotxujxoo9j21690h0q3j.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事件类型-enrichment&quot;&gt;事件类型 enrichment&lt;/h3&gt;
&lt;p&gt;日志文件和本地不支持消息模板的日志服务器仍然可以通过在Serilog管道中明确地&lt;code&gt;enricher&lt;/code&gt;事件来接收事件类型。&lt;/p&gt;
&lt;p&gt;为此，自定义&lt;code&gt;enricher&lt;/code&gt;程序将&lt;code&gt;EventType&lt;/code&gt;属性附加到每个事件&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// Install-Package Murmurhash

class EventTypeEnricher : ILogEventEnricher  
{
   public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
   {
      var murmur = MurmurHash.Create32();
      var bytes = Encoding.UTF8.GetBytes(logEvent.MessageTemplate.Text);
      var hash = murmur.ComputeHash(bytes);
      var numericHash = BitConverter.ToUInt32(hash, 0);
      var eventType = propertyFactory.CreateProperty(&quot;EventType&quot;, numericHash);
      logEvent.AddPropertyIfAbsent(eventType);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当插入管道时，这会使&lt;code&gt;{EventType}&lt;/code&gt;属性可用于&lt;code&gt;sinks&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Log.Logger = new LoggerConfiguration()  
   .Enrich.With&amp;lt;EventTypeEnricher&amp;gt;()
   .WriteTo.Console(outputTemplate:
       &quot;{Timestamp:HH:mm:ss} [{EventType:x8} {Level:u3}] {Message:lj}{NewLine}{Exception}&quot;)
   .CreateLogger();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;WriteTo.Console()&lt;/code&gt;的参数是一个Serilog输出模板，描述了如何将日志事件的属性格式化为文本。 大多数基于文本的sinks（包括&lt;code&gt;Serilog.Sinks.File&lt;/code&gt;）都可以接受输出模板来指导格式化。&lt;/p&gt;
&lt;p&gt;[ 输出如下所示：]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/697065c1gy1foty29nelmj21eo0b3dg5.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下一步做什么&quot;&gt;7. 下一步做什么&lt;/h2&gt;
&lt;p&gt;Serilog是一个强大的库，拥有广泛的插件和工具生态系统。我们只涉及绝对的基础知识 - 取决于您希望如何使用Serilog以及您使用的框架和平台，还有很多可以发现的地方。&lt;/p&gt;
&lt;p&gt;这里有一些文章和扩展，供你参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Debugging and diagnostics&lt;/strong&gt; - if you're having trouble getting Serilog or a sink to work, check out this page on &lt;a href=&quot;https://github.com/serilog/serilog/wiki/Debugging-and-Diagnostics&quot;&gt;the Serilog wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;appsettings.json&lt;/code&gt; configuration&lt;/strong&gt; - in this article we've only shown the C# configuration API; &lt;a href=&quot;https://github.com/serilog/serilog-settings-configuration&quot;&gt;Serilog.Settings.Configuration&lt;/a&gt; adds support for logger configuration in .NET Core JSON settings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XML &lt;code&gt;&amp;lt;appSettings&amp;gt;&lt;/code&gt; configuration&lt;/strong&gt; - &lt;a href=&quot;https://github.com/serilog/serilog-settings-appsettings&quot;&gt;Serilog.Settings.AppSettings&lt;/a&gt; adds support for reading logger configuration from .NET Framework configuration files&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASP.NET Core integration&lt;/strong&gt; - the &lt;a href=&quot;https://github.com/serilog/serilog-aspnetcore&quot;&gt;Serilog.AspNetCore&lt;/a&gt; package seamlessly integrates Serilog into ASP.NET Core 2.0 apps to take advantage of the structured log events emitted by the framework&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASP.NET integration&lt;/strong&gt; - check out &lt;a href=&quot;https://github.com/serilog-web/classic&quot;&gt;SerilogWeb.Classic&lt;/a&gt; for a quick-and-painless way to record unhandled exceptions and request timings from ASP.NET projects&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart logging middleware for ASP.NET Core&lt;/strong&gt; - improve the quality of request logging in ASP.NET Core with the &lt;a href=&quot;https://blog.getseq.net/smart-logging-middleware-for-asp-net-core/&quot;&gt;middleware from this article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timed operations&lt;/strong&gt; - &lt;a href=&quot;https://github.com/nblumhardt/serilog-timings&quot;&gt;SerilogTimings&lt;/a&gt; is a small wrapper for Serilog that makes it easy to log operation timings&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Autofac-Serilog integration&lt;/strong&gt; - use &lt;a href=&quot;https://github.com/nblumhardt/autofac-serilog-integration&quot;&gt;AutofacSerilogIntegration&lt;/a&gt; to inject Serilog ILoggers through Autofac with type information automatically added&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code analysis for Serilog&lt;/strong&gt; - mentioned earlier, &lt;a href=&quot;https://github.com/suchiman/SerilogAnalyzer&quot;&gt;Serilog Analyzer&lt;/a&gt; checks message template syntax in Visual Studio as-you-type, and detects many potential Serilog usage issues&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic filtering&lt;/strong&gt; - &lt;a href=&quot;https://github.com/serilog/serilog-filters-expressions&quot;&gt;Serilog.Filters.Expressions&lt;/a&gt; makes it possible to filter events using a simple domain-specific language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Async wrapper&lt;/strong&gt; - the latency of logging to files or the console can be reduced further using the &lt;a href=&quot;https://github.com/serilog/serilog-sinks-async&quot;&gt;Serilog.Sinks.Async&lt;/a&gt; package&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sink READMEs&lt;/strong&gt; - most sinks, including &lt;a href=&quot;https://github.com/serilog/serilog-sinks-file&quot;&gt;Serilog.Sinks.File&lt;/a&gt;, &lt;a href=&quot;https://github.com/serilog/serilog-sinks-console&quot;&gt;Serilog.Sinks.Console&lt;/a&gt;, &lt;a href=&quot;https://github.com/serilog/serilog-sinks-seq&quot;&gt;Serilog.Sinks.Seq&lt;/a&gt; and others, have good README documents in their GitHub repositories with detailed instructions for using the sink&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structured Logging Concepts in .NET series&lt;/strong&gt; - this &lt;a href=&quot;https://nblumhardt.com/2016/06/structured-logging-concepts-in-net-series-1/&quot;&gt;blog series on structured logging&lt;/a&gt; has more detail on much of what we've covered in this tutorial&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F# support&lt;/strong&gt; - if your application is written in F#, &lt;a href=&quot;https://github.com/destructurama/fsharp&quot;&gt;Destructurama.FSharp&lt;/a&gt; will let you log F# types seamlessly through Serilog&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSON.NET support&lt;/strong&gt; - &lt;a href=&quot;https://github.com/destructurama/json-net&quot;&gt;Destructurama.JsonNet&lt;/a&gt; extends Serilog to allow JSON.NET dynamic objects to be logged as structured data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exception enricher&lt;/strong&gt; - &lt;a href=&quot;https://github.com/RehanSaeed/Serilog.Exceptions&quot;&gt;Serilog.Exceptions&lt;/a&gt; collects additional exception-type-specific information and attaches it to log events&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Async stack trace unmangling&lt;/strong&gt; - &lt;a href=&quot;https://github.com/nblumhardt/serilog-enrichers-demystify&quot;&gt;Serilog.Enrichers.Demystify&lt;/a&gt; plugs in Ben Adams' Demystifier to improve the readability of exception stack traces&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;获得帮助&quot;&gt;8. 获得帮助&lt;/h2&gt;
&lt;p&gt;Serilog有三大优秀的社区支持渠道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/tagged/serilog&quot;&gt;Stack Overflow&lt;/a&gt; - 如果您有Seri​​log使用问题，Stack Overflow上的Serilog标签是一个很好的开始; 它被积极监控，并且您将通过留下一个容易找到的答案来帮助其他人解决同一个问题&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitter.im/serilog/serilog&quot;&gt;Gitter Chat&lt;/a&gt; - 如果您的问题不符合Stack Overflow格式，或者您只是想完善检查方法，那么Gitter聊天室是与Serilog社区中的其他人联系的快捷方式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/serilog/serilog/issues&quot;&gt;GitHub Issues&lt;/a&gt; - 最后，如果你发现了一个bug或者想要对Serilog进行改进，GitHub就是这个地方; &lt;a href=&quot;https://github.com/serilog&quot;&gt;Serilog organization&lt;/a&gt; 包括了serilog所有的核心库和问题跟踪。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Happy logging!&lt;/p&gt;
&lt;p&gt;原文地址&lt;a href=&quot;http://blog.getseq.net/serilog-tutorial/&quot; class=&quot;uri&quot;&gt;http://blog.getseq.net/serilog-tutorial/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 09:58:00 +0000</pubDate>
<dc:creator>假正经哥哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuanye/p/8474469.html</dc:identifier>
</item>
<item>
<title>dcoker实战,使用docker部署NodeJs应用 - 进击的小羊驼</title>
<link>http://www.cnblogs.com/pass245939319/p/8473861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pass245939319/p/8473861.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker.jpg&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;  docker是一个开源的应用容器引擎，可以为我们提供安全、可移植、可重复的自动化部署的方式。docker采用虚拟化的技术来虚拟化出应用程序的运行环境。如上图一样。docker就像一艘轮船。而轮船上面的每个小箱子可以看成我们需要部署的一个个应用。使用docker可以充分利用服务器的系统资源，简化了自动化部署和运维的繁琐流程,减少很多因为开发环境中和生产环境中的不同引发的异常问题。从而提高生产力。&lt;br/&gt;  docker三个核心概念如下：&lt;/p&gt;
&lt;ul readability=&quot;2.4194991055456&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;镜像（images）：一个只读的模板，可以理解为应用程序的运行环境，包含了程序运行所依赖的环境和基本配置。相当于上图中的每个小箱子里面装的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;仓库（repository）：一个用于存放镜像文件的仓库。可以看做和gitlab一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.859375&quot;&gt;
&lt;p&gt;容器（container）：一个运行应用程序的虚拟容器，他和镜像最大的区别在于容器的最上面那一层是可读可写的。 相当于上图中的每个小箱子里。&lt;/p&gt;

&lt;h2 id=&quot;mac&quot;&gt;mac&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://www.docker.com/docker-mac&quot;&gt;官网下载地址&lt;/a&gt;，点击下载即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;liunx&quot;&gt;liunx&lt;/h2&gt;
&lt;p&gt;打开终端 输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl https://releases.rancher.com/install-docker/17.12.sh | sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待安装完成。检查是否安装成功。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_v.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;环境已经安装完毕。现在来开始部署应用吧。&lt;br/&gt;  &lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;h2 id=&quot;初始化一个nodejs程序&quot;&gt;初始化一个NodeJs程序&lt;/h2&gt;
&lt;p&gt;以下操作必须已经安装了NodeJS。如果没有安装请参照之前的教程&lt;a href=&quot;http://shepherd618.cn/2018/01/08/ubuntu%E9%83%A8%E7%BD%B2NodeJs%E7%BA%BF%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/&quot;&gt;传送门&lt;/a&gt;&lt;br/&gt;首先创建一个空文件夹。并创建以下文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;server.js&lt;/li&gt;
&lt;li&gt;package.json&lt;/li&gt;
&lt;li&gt;Dockerfile&lt;/li&gt;
&lt;li&gt;.dockerignore&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir docker_demo
cd docker_demo
touch server.js
touch package.json
touch Dockerfile
touch .dockerignore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在server.js写入&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Koa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'koa'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Koa&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;use&lt;/span&gt;(async ctx &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello docker'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在package.json中写入&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;docker_demo&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;dt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;dt&quot;&gt;&quot;private&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;dt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;dt&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;node server.js&quot;&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
 &lt;span class=&quot;dt&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;dt&quot;&gt;&quot;koa&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;^2.5.0&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试程序。控制台输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器打开&lt;a href=&quot;http://localhost:3000/&quot;&gt;本地测试&lt;/a&gt;,如果如图所示。表示demo创建成功。请继续往下。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_test.png&quot; alt=&quot;测试结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建dockerfile文件&quot;&gt;创建dockerfile文件&lt;/h2&gt;
&lt;p&gt;  Dockerfile是由一系列命令和参数构成的脚本，一个Dockerfile里面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列命令自动构建image.&lt;br/&gt;在.dockerignore文件里面写入代码。表示过滤该类型的文件。类似git的.gitignore&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Logs
logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# node-waf configuration
.lock-wscript

# Compiled binary addons (http://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules
jspm_packages

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history
.idea
.node_modules
node_modules
.vscode&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在Dockerfile文件中写入以下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;co&quot;&gt;#制定node镜像的版本&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; node:8.9-alpine
&lt;span class=&quot;co&quot;&gt;#声明作者&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;MAINTAINER&lt;/span&gt; robin
&lt;span class=&quot;co&quot;&gt;#移动当前目录下面的文件到app目录下&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ADD&lt;/span&gt; . /app/
&lt;span class=&quot;co&quot;&gt;#进入到app目录下面，类似cd&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /app
&lt;span class=&quot;co&quot;&gt;#安装依赖&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; npm install
&lt;span class=&quot;co&quot;&gt;#对外暴露的端口&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;EXPOSE&lt;/span&gt; 8000
&lt;span class=&quot;co&quot;&gt;#程序启动脚本&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;npm&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;start&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h2&gt;
&lt;p&gt;使用build命令构造镜像,注意后面那个.不能少。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t docker_demo .&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;robin:docker_demo robin$ docker build -t docker_demo .
Sending build context to Docker daemon  39.94kB
Step 1/7 : FROM node:8.9-alpine
---&amp;gt; 406f227b21f5
Step 2/7 : MAINTAINER robin
---&amp;gt; Using cache
---&amp;gt; 78d6cdbcfee2
Step 3/7 : ADD . /app/
---&amp;gt; 2cb30678612d
Step 4/7 : WORKDIR /app
Removing intermediate container e51377081039
---&amp;gt; c2b7d0f37d2d
Step 5/7 : RUN npm install
---&amp;gt; Running in da0c3946ca8d
npm notice created a lockfile as package-lock.json. You should commit this file.
added 38 packages in 3.323s
Removing intermediate container da0c3946ca8d
---&amp;gt; eecee87f10e2
Step 6/7 : EXPOSE 8000
---&amp;gt; Running in f3973cc168a4
Removing intermediate container f3973cc168a4
---&amp;gt; 2671a4c6deb4
Step 7/7 : CMD [&quot;npm&quot;, &quot;start&quot;]
---&amp;gt; Running in dec529f754aa
Removing intermediate container dec529f754aa
---&amp;gt; 6ec73793d353
Successfully built 6ec73793d353
Successfully tagged docker_demo:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待镜像构造完成。然后使用 images命令查看镜像。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_images.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;此时可以看到images已经构造完成。现在开始启动images，并测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#启动镜像 -d表示后台执行，-p 9000:3000表示指定本地的9000端口隐射到容器内的3000端口，docker_demo为镜像名称
docker run -d -p 9000:3000 docker_demo
#查看容器
docker ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_run.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;此时浏览器打开&lt;a href=&quot;http://localhost:9000/&quot; class=&quot;uri&quot;&gt;http://localhost:9000/&lt;/a&gt;,如果如图所示。表示容器运行正常。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/docker_test.png&quot; alt=&quot;测试结果&quot;/&gt;&lt;br/&gt;  如果此时本地无法打开。可以使用log命令查看日志。根据日志修改对应出现的对方。&lt;/p&gt;
&lt;h2 id=&quot;绑定docke-hub&quot;&gt;绑定docke hub&lt;/h2&gt;
&lt;p&gt;  镜像已经存在了我们本机硬盘，那我们实际中要么上传到服务器呢？这里通常有2个方法。一直是自己搭建镜像仓库比如（harbor）,还有就是官方的docke hub，类似gitlab。我们这里先以docke hub为列。harbor放在下篇博客。首先需要注册docke hub账号,&lt;a href=&quot;https://hub.docker.com/&quot;&gt;官网注册地址&lt;/a&gt;。然后登陆。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;robin:docker_demo robin$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username:xxxxxx
Password: 
Login Succeeded
robin:docker_demo robin$ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登陆成功之后。需要给当前images。添加tag,并push&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#格式docker tag 标签名 用户名/标签名
docker tag docker_demo robin365/docker_demo
#格式docker push 用户名/标签名
docker push robin365/docker_demo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  完成之后,可以登陆&lt;a href=&quot;https://hub.docker.com/&quot;&gt;docke hub&lt;/a&gt;查看刚刚push的镜像。我们可以设置这个镜像是否公开。Public：所有人都可以下载。Private：表示自己才能下载。&lt;img src=&quot;http://img.shepherd618.cn/image_s.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;  这样我们已经把images上传到docke hub了,在我们需要用到这个images的时候可以直接通过docker pull命令下载使用了。&lt;br/&gt;  到此本教程结束。实际项目中部署可能会出现各种各样的问题，我们需要多查看log。根据log去做相应修改。后面我也会整理出有关docke在部署nodejs应用中的一些比较容易出错的地方。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;#查看当前docker版本
docker -v
#查看当前本地所有镜像
docker images
#构造镜像,用法docker build -t 镜像名称 .
docker build -t docker_demo .
#用于容器与主机之间的数据拷贝。用法docker cp 主机文件地址 容器内地址。12d7f14v45cv为容器id。
docker cp /www/runoob 12d7f14v45cv:/www/
#创建一个新的容器并运行，-d为后台执行，-p 9000:3000前面为主机端口，后面是容器端口。docker_demo镜像名
docker run -d -p 9000:3000 docker_demo
#启动已被停止的容器
docker start docker_demo
#关闭已被启动的容器
docker stop docker_demo
#重新启动容器
docker restart docker_demo
#杀掉一个运行中的容器。
docker kill -s KILL docker_demo
#删除一个或多少容器。-f :通过SIGKILL信号强制删除一个运行中的容器-l :移除容器间的网络连接，而非容器本身-v :-v 删除与容器关联的卷
docker rm -f docker_demo、docker_demo1
#在运行的容器中执行命令。104e28f2f072容器id
sudo docker exec -it 104e28f2f072 /bin/bash 
#列出容器。 -a:所有容器包含没有运行的
docker ps 
#获取容器获取容器的日志 104e28f2f072容器id，-t:显示时间戳
docker logs -f -t 104e28f2f072 
#登陆镜像仓库
docker login
#获取镜像
docker pull 
#上传镜像
docker push
#查看指定镜像的创建历史。
docker history docker_demo&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 26 Feb 2018 08:27:00 +0000</pubDate>
<dc:creator>进击的小羊驼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pass245939319/p/8473861.html</dc:identifier>
</item>
</channel>
</rss>