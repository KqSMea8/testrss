<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>23.Linux-块设备驱动(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7661454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7661454.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过上节的&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7651667.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;块设备驱动分析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;,本节便通过内存来模拟块设备驱动 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考内核自带的块设备驱动程序:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;drivers/block /xd.c  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;drivers/block /z2ram.c  &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.本节需要的结构体如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 gendisk磁盘结构体:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; gendisk {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; major;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备主设备号,等于register_blkdev()函数里的major &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; first_minor;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;起始次设备号,等于0,则表示此设备号从0开始的 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; minors;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分区(次设备)数量,当使用alloc_disk()时,就会自动设置该成员&lt;/span&gt;
        &lt;span&gt;char&lt;/span&gt; disk_name[&lt;span&gt;32&lt;/span&gt;];            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;块设备名称, 等于register_blkdev()函数里的name&lt;/span&gt;
 
        &lt;span&gt;struct&lt;/span&gt; hd_struct **part;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;分区表的信息&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; part_uevent_suppress;
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; block_device_operations *fops; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;块设备操作函数&lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; request_queue *queue;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求队列，用于管理该设备IO请求队列的指针*&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; *private_data;                    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;私有数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        sector_t capacity;               &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;扇区数,512字节为1个扇区,描述设备容量&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ....
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 request申请结构体:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; request {  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于挂在请求队列链表的节点，使用函数elv_next_request()访问它，而不能直接访问  &lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; list_head queuelist;   
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; list_head donelist;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;用于挂在已完成请求链表的节点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;struct&lt;/span&gt; request_queue *q;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;指向请求队列&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  

    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cmd_flags;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;命令标识&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  

    &lt;span&gt;enum&lt;/span&gt; rq_cmd_type_bits cmd_type;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读写命令标志,为 0(READ)表示读, 为1(WRITE)表示写&lt;/span&gt;&lt;span&gt;
 
    sector_t sector;                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要提交的下一个扇区偏移位置(offset)&lt;/span&gt;&lt;span&gt;
    ... ...&lt;/span&gt;&lt;span&gt;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; current_nr_sectors;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前需要传送的扇区数(长度) &lt;/span&gt;&lt;span&gt;
    ... ...

&lt;/span&gt;&lt;span&gt;    char&lt;/span&gt; *buffer;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前请求队列链表的申请里面的数据,用来读写扇区数据(源地址)&lt;/span&gt;&lt;span&gt;
    ... ...
  };  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.本节需要的函数如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; register_blkdev(unsigned &lt;span&gt;int&lt;/span&gt; major, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建一个块设备&lt;/span&gt;&lt;/strong&gt;,当major==0时,表示动态创建,创建成功会返回一个主设备号&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
unregister_blkdev(unsigned &lt;span&gt;int&lt;/span&gt; major, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *name);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;卸载一个块设备,&lt;/strong&gt;&lt;/span&gt; 在出口函数中使用,major:主设备号, name:名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; gendisk *alloc_disk(&lt;span&gt;int&lt;/span&gt; minors);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;分配一个gendisk结构，&lt;/strong&gt;&lt;/span&gt;minors为分区数,填1表示不分区&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; del_gendisk(&lt;span&gt;struct&lt;/span&gt; gendisk *disk);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;释放gendisk结构,&lt;/strong&gt;&lt;/span&gt;在出口函数中使用,也就是不需要这个磁盘了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *&lt;span&gt;lock&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;分配一个request_queue请求队列,&lt;/strong&gt;&lt;/span&gt;分配成功返回一个request_queue结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;rfn:&lt;/strong&gt;&lt;/span&gt; request_fn_proc结构体,用来执行放置在队列中的请求的处理函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  &lt;span&gt;lock:&lt;/span&gt;&lt;/strong&gt;队列访问权限的自旋锁(spinlock),该锁通过DEFINE_SPINLOCK()来定义&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; blk_cleanup_queue(request_queue_t * q);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;清除&lt;/span&gt;&lt;/strong&gt;内核中的&lt;strong&gt;&lt;span&gt;request_queue请求队列&lt;/span&gt;&lt;/strong&gt;,在出口函数中使用&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; DEFINE_SPINLOCK(spinlock_t &lt;span&gt;lock&lt;/span&gt;);   &lt;span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义一个自旋锁(spinlock)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; set_capacity(&lt;span&gt;struct&lt;/span&gt; gendisk *disk, sector_t size);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设置gendisk结构体&lt;/span&gt;&lt;/strong&gt;的&lt;strong&gt;&lt;span&gt;扇区数&lt;/span&gt;&lt;/strong&gt;(成员copacity), size等于扇区数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该函数内容如下:&lt;/p&gt;
&lt;p&gt;disk-&amp;gt;capacity = size;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; add_disk(&lt;span&gt;struct&lt;/span&gt; gendisk *gd);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;向内核中&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注册gendisk结构体&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; put_disk(&lt;span&gt;struct&lt;/span&gt; gendisk *disk);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注销&lt;/span&gt;&lt;/strong&gt;内核中的&lt;strong&gt;&lt;span&gt;gendisk结构体&lt;/span&gt;&lt;/strong&gt;,在出口函数中使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt; request *elv_next_request(request_queue_t *q);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过电梯算法&lt;span&gt;&lt;strong&gt;获取&lt;/strong&gt;&lt;/span&gt;申请队列中未完成的&lt;strong&gt;&lt;span&gt;申请&lt;/span&gt;&lt;/strong&gt;,获取成功返回一个request结构体,不成功返回NULL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(PS: 不使用获取到的这个申请时,应使用end_request()来结束获取申请)&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; end_request(&lt;span&gt;struct&lt;/span&gt; request *req, &lt;span&gt;int&lt;/span&gt; uptodate);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;结束获取申请,&lt;/strong&gt;&lt;/span&gt; 当uptodate==0,表示使用该申请读写扇区失败, uptodate==1,表示成功&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; inline &lt;span&gt;void&lt;/span&gt; *kzalloc(size_t size, gfp_t flags);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;分配一段静态缓存&lt;/strong&gt;&lt;/span&gt;,这里用来当做我们的磁盘扇区用,分配成功返回缓存地址,分配失败会返回0&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; kfree(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *block);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注销一段静态缓存&lt;/strong&gt;&lt;/span&gt;,与kzalloc()成对,在出口函数中使用&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rq_data_dir(rq);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取request&lt;/span&gt;&lt;/strong&gt;申请结构体&lt;strong&gt;&lt;span&gt;的命令标志&lt;/span&gt;&lt;/strong&gt;(cmd_flags成员),当返回READ(0)表示读扇区命令,否则为写扇区命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.步骤如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1在入口函数中:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1)使用register_blkdev()创建一个块设备&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2) blk_init_queue()使用分配一个申请队列,并赋申请队列处理函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)使用alloc_disk()分配一个gendisk结构体&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4)设置gendisk结构体的成员&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;  -&amp;gt;4.1)设置成员参数(major、first_minor、disk_name、fops)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;  -&amp;gt;4.2)设置queue成员,等于之前分配的申请队列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;  -&amp;gt;4.3)通过set_capacity()设置capacity成员,等于扇区数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5)使用kzalloc()来获取缓存地址,用做扇区&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;6)使用add_disk()注册gendisk结构体&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2在申请队列的处理函数中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1) while循环使用elv_next_request()获取申请队列中每个未处理的申请&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2)使用rq_data_dir()来获取每个申请的读写命令标志,为 0(READ)表示读, 为1(WRITE)表示写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)使用memcp()来读或者写扇区(缓存)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4)使用end_request()来结束获取的每个申请&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3在出口函数中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1)使用put_disk()和del_gendisk()来注销,释放gendisk结构体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2)使用kfree()释放磁盘扇区缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)使用blk_cleanup_queue()清除内存中的申请队列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4)使用unregister_blkdev()卸载块设备&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.代码如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
#include &amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/errno.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/interrupt.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mm.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/fs.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/timer.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/genhd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/hdreg.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/ioport.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/wait.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/blkdev.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/blkpg.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/delay.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/io.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;asm/system.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/uaccess.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/dma.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; DEFINE_SPINLOCK(memblock_lock);         　　　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义自旋锁&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; request_queue_t * memblock_request;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请队列&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; gendisk   *memblock_disk;                　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;磁盘结构体&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; memblock_major;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BLOCKBUF_SIZE               (1024*1024)         　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;磁盘大小&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SECTOR_SIZE                   (512)                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扇区大小&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;   *block_buf;                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;磁盘地址&lt;/span&gt;


&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; memblock_getgeo(&lt;span&gt;struct&lt;/span&gt; block_device *bdev, &lt;span&gt;struct&lt;/span&gt; hd_geometry *&lt;span&gt;geo)
{    
       geo&lt;/span&gt;-&amp;gt;heads =&lt;span&gt;2&lt;/span&gt;;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2个磁头分区&lt;/span&gt;
       geo-&amp;gt;cylinders = &lt;span&gt;32&lt;/span&gt;;                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个磁头有32个柱面&lt;/span&gt;
       geo-&amp;gt;sectors = BLOCKBUF_SIZE/(&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;32&lt;/span&gt;*SECTOR_SIZE);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个柱面有多少个扇区&lt;/span&gt;    
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; block_device_operations memblock_fops =&lt;span&gt; {
       .owner    &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
       .getgeo   &lt;/span&gt;=  memblock_getgeo,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;几何,保存磁盘的信息(柱头,柱面,扇区)&lt;/span&gt;
&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;申请队列处理函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; do_memblock_request (request_queue_t *&lt;span&gt; q)
{
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; request *&lt;span&gt;req;
        unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset;
        unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; len; 
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; r_cnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt; w_cnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
              
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((req = elv_next_request(q)) != NULL)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取每个申请&lt;/span&gt;
&lt;span&gt;        {
        offset&lt;/span&gt;=req-&amp;gt;sector*SECTOR_SIZE;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;偏移值&lt;/span&gt;
        len=req-&amp;gt;current_nr_sectors*SECTOR_SIZE;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度    &lt;/span&gt;
                      
        &lt;span&gt;if&lt;/span&gt;(rq_data_dir(req)==&lt;span&gt;READ)
        {            
            memcpy(req&lt;/span&gt;-&amp;gt;buffer,block_buf+offset,len);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出缓存&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {              
            memcpy(block_buf&lt;/span&gt;+offset,req-&amp;gt;buffer,len);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入缓存&lt;/span&gt;
&lt;span&gt;        }
        end_request(req, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束获取的申请&lt;/span&gt;
&lt;span&gt;        }    
}

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;入口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; memblock_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1)使用register_blkdev()创建一个块设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     memblock_major&lt;/span&gt;=register_blkdev(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memblock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);     
     
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2) blk_init_queue()使用分配一个申请队列,并赋申请队列处理函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     memblock_request&lt;/span&gt;=blk_init_queue(do_memblock_request,&amp;amp;&lt;span&gt;memblock_lock);
    
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3)使用alloc_disk()分配一个gendisk结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     memblock_disk&lt;/span&gt;=alloc_disk(&lt;span&gt;16&lt;/span&gt;);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不分区&lt;/span&gt;
    
     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4)设置gendisk结构体的成员&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.1)设置成员参数(major、first_minor、disk_name、fops)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;           
     memblock_disk&lt;/span&gt;-&amp;gt;major =&lt;span&gt; memblock_major;
     memblock_disk&lt;/span&gt;-&amp;gt;first_minor = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     sprintf(memblock_disk&lt;/span&gt;-&amp;gt;disk_name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memblock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     memblock_disk&lt;/span&gt;-&amp;gt;fops = &amp;amp;&lt;span&gt;memblock_fops;
        
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.2)设置queue成员,等于之前分配的申请队列&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     memblock_disk&lt;/span&gt;-&amp;gt;queue =&lt;span&gt; memblock_request;
      
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.3)通过set_capacity()设置capacity成员,等于扇区数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     set_capacity(memblock_disk,BLOCKBUF_SIZE&lt;/span&gt;/&lt;span&gt;SECTOR_SIZE);
   
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5)使用kzalloc()来获取缓存地址,用做扇区&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     block_buf&lt;/span&gt;=&lt;span&gt;kzalloc(BLOCKBUF_SIZE, GFP_KERNEL);
 
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;6)使用add_disk()注册gendisk结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     add_disk(memblock_disk);   
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; memblock_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{        
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1)使用put_disk()和del_gendisk()来注销,释放gendisk结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      put_disk(memblock_disk);
      del_gendisk(memblock_disk);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2)使用kfree()释放磁盘扇区缓存   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
      kfree(block_buf);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3)使用blk_cleanup_queue()清除内存中的申请队列    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      blk_cleanup_queue(memblock_request);
      
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4)使用unregister_blkdev()卸载块设备               &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      unregister_blkdev(memblock_major,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memblock&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

module_init(memblock_init);
module_exit(memblock_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.测试运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
insmod ramblock.ko                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂载memblock块设备&lt;/span&gt;
&lt;span&gt;
mkdosfs &lt;/span&gt;/dev/memblock                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将memblock块设备格式化为dos磁盘类型&lt;/span&gt;
&lt;span&gt;
mount &lt;/span&gt;/dev/ memblock   /tmp/                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂载块设备到/tmp目录下&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;接下来在/tmp目录下vi 1.txt文件,最终都会保存在/dev/ memblock块设备里面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
cd /; umount /tmp/                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出/tmp,卸载,同时之前读写的文件也会消失&lt;/span&gt;

cat /dev/memblock &amp;gt; /mnt/&lt;span&gt;memblock.bin   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在/mnt目录下创建.bin文件,然后将块设备里面的文件追加到.bin里面&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;然后进入linux&lt;/strong&gt;&lt;strong&gt;的nfs&lt;/strong&gt;&lt;strong&gt;挂载目录中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo mount -o loop ramblock.bin   /mnt      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂载ramblock.bin, -loop:将文件当做磁盘来挂载&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如下图,就可以找到我们之前在开发板上创建的1.txt了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171013152628965-1930935685.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明这个块设备测试运行无误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.使用fdisk&lt;/strong&gt;&lt;strong&gt;来对磁盘分区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(&lt;strong&gt;fdisk&lt;/strong&gt;命令使用详解: &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7661239.html&quot;&gt;&lt;span&gt;http://www.cnblogs.com/lifexy/p/7661239.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共分了两个分区,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171013152504043-1052444024.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如下图,接下来就可以向上小节那样,分别操作多个分区磁盘了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171013152509668-562788193.png&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;45&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171013152513902-1538931645.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 07:36:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7661454.html</dc:identifier>
</item>
<item>
<title>JavaScript设计模式--简单工厂模式 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7661020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7661020.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一，介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里将工厂简单分为三种：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;（1）简单工厂：通过第三方的类完成松耦合的任务。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）复杂工厂：通过把实例化的任务交给子类来完成的，用以到达松耦合的目的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3）超级工厂：通过eval()来完成智能工厂。&lt;br/&gt;工厂的目的：&lt;/span&gt;&lt;span&gt;在于判断接口最终用哪个类实例化（故与接口密不可分）。&lt;br/&gt;使用工厂&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt;最终达到的效果是：多态，和类与类之间的松耦合。&lt;p&gt;&lt;strong&gt;&lt;span&gt;二，正文部分&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;工厂模式与接口是密不可分的所以我们需要先引入接口文件和继承类文件&lt;br/&gt;（1）接口文件：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个静态方法来实现接口与实现类的直接检验
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法不要写出Interface.prototype ,因为这是写到接口的原型链上的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们要把静态的函数直接写到类层次上
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)定义一个接口类&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Interface=function (name,methods) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：接口名字&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须是两个参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methods=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个空数组装载函数名&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;methods.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;  methods[i]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数名必须是字符串类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.methods.push( methods[i]);
        }
    }
};
Interface.ensureImplement&lt;/span&gt;=function (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数必须不少于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inter=&lt;span&gt;arguments[i];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是接口就必须是Interface类型&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(inter.constructor!=&lt;span&gt;Interface){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;如果是接口类的话，就必须是Interface类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接口中的方法是否全部实现
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历函数集合&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;inter.methods.length;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method=inter.methods[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口中所有函数

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;object[method]传入的函数
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终是判断传入的函数是否与接口中所用函数匹配&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;object&lt;/span&gt;[method]||&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[method]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类中必须有方法名字与接口中所用方法名相同&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现类中没有完全实现接口中的所有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）继承文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建extend函数为了程序中所有的继承操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subClass:子类  superClass：超类&lt;/span&gt;
&lt;span&gt;function extend(subClass,superClass) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1，使子类原型属性等于父类的原型属性

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个中间空对象，目的是为了转换主父关系&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; F =&lt;span&gt; function () {};
    F.prototype &lt;/span&gt;=&lt;span&gt; superClass.prototype;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2， 让子类继承F&lt;/span&gt;
    subClass.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
    subClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; subClass;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3，为子类增加属性 superClass ==》原型链的引用&lt;/span&gt;
    subClass.superClass =&lt;span&gt; superClass.prototype;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4，增加一个保险，就算你的原型类是超类（Object）那么也要把你的构造函数级别降下来&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (superClass.prototype.constructor ==&lt;span&gt; Object.prototype.constructor) {
        superClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; superClass;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;通过下面的例子，逐步引进工厂模式及改进工厂模式&lt;br/&gt;1，工厂模式的引入，&lt;br/&gt;（1）创建接口对象&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; Pet=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;（2）定义一个宠物店类并在prototype上进行扩展&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; PetShop=&lt;span&gt;function () {}
    PetShop.prototype&lt;/span&gt;=&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出售宠物的方法&lt;/span&gt;
&lt;span&gt;        sellPet:function (kind) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (kind){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pig();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
            }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口  &lt;/span&gt;
         Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实现接口Pet里面全部的方法    （对象，接口）&lt;/span&gt;
&lt;span&gt;          pet.eat();
          pet.register();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
（3）分析宠物的一些特点可以将一些公共的部分提取出来（这里只是简单的提取）
&lt;/pre&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;基类  有共同的提出来&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记...&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭...&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）各个实现类 ---这里是各种动物&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口部分&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }

    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口部分&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口部分&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口部分&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）各个实现类继承基类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//继承&lt;br/&gt;extend(Dog,basePet);
extend(Cat,basePet);
extend(Pig,basePet);
extend(Bird,basePet);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）创建宠物的开始卖宠物&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; newPetShop=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PetShop();
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flowerPig=newPetShop.sellPet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    flowerPig.run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171013143738684-178728736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下，上述好像没怎么体现有关工厂之类的，我们应该注意到这么一个问题就是：&lt;span&gt;当需要增加一个新品种宠物时，我们需要修改 '宠物店类'，耦合度较高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;为了解决这个问题我们使用简单工厂模式来解决。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;2，简单工厂模式（针对上述的改进）&lt;/p&gt;
&lt;p&gt;（1）接口文件与继承文件的的引入  同上面&lt;/p&gt;
&lt;p&gt;（2）静态工厂&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用工厂方式创建宠物对象 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态工厂&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; factoryPet=&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出售宠物的方法&lt;/span&gt;
&lt;span&gt;        getPet:function (kind) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (kind){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pig();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
            Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）利用工厂创建宠物店对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; factoryPetShop=&lt;span&gt;function () {}
    factoryPetShop.prototype&lt;/span&gt;=&lt;span&gt;{
        getPet:function (kind) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;factoryPet.getPet(kind);
            pet.eat();
            pet.register();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）从宠物店购买宠物实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; newPetShop=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; factoryPetShop();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flowerCat=newPetShop.getPet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    flowerCat.sing();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）使用简单工厂实现的全部代码（数字标号表示其思考的先后顺序）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)接口调用&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; Pet=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（3）基类  分析后有共同的提出来作为基类&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4）实现类  继承基类+接口实现&lt;/span&gt;
&lt;span&gt;    function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;
&lt;span&gt;    extend(Dog,basePet);
    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);


   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（1）使用工厂方式创建宠物对象
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态工厂&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; factoryPet=&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出售宠物的方法&lt;/span&gt;
&lt;span&gt;        getPet:function (kind) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (kind){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pig();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
            Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（5）利用工厂的宠物店对象（宠物店买宠物）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; factoryPetShop=&lt;span&gt;function () {}
    factoryPetShop.prototype&lt;/span&gt;=&lt;span&gt;{
        getPet:function (kind) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;factoryPet.getPet(kind);
            pet.eat();
            pet.register();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6）从宠物店购买宠物&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; newPetShop=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; factoryPetShop();//宠物工厂
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flowerCat=newPetShop.getPet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);//从宠物工厂中得到宠物
    flowerCat.sing();

})()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下，上述看似完美，但是任有问题存在：比如说：张三的宠物店想卖哈士奇，李四的宠物店想卖鸟时，&lt;span&gt;这样的话，宠物都是通过一个工厂生产的，并不一定满足各个卖家的需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们需要根据各个厂家的需求，有不同的工厂，各个卖家可以根据自己需求使用不同的工厂（其实是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;利用不同子类实现各自合适的工厂&lt;/span&gt;&lt;span&gt;&lt;span&gt;），用于满足每个宠物店的不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;于是我们有了复杂的工厂用来解决该问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3，复杂工厂：通过把实例化的任务交给子类来完成的，用以到达松耦合的目的。&lt;/p&gt;
&lt;p&gt;此处同样是根据上述进行改进的，还是简单的说明一下实现过程&lt;/p&gt;
&lt;p&gt;（1）在html中将接口文件的引进，代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个静态方法来实现接口与实现类的直接检验
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法不要写出Interface.prototype ,因为这是写到接口的原型链上的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们要把静态的函数直接写到类层次上
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个接口类&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; Interface=function (name,methods) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：接口名字&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须是两个参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methods=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个空数组装载函数名&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;methods.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;  methods[i]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数名必须是字符串类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.methods.push( methods[i]);
        }
    }
};
Interface.ensureImplement&lt;/span&gt;=function (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数必须不少于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inter=&lt;span&gt;arguments[i];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是接口就必须是Interface类型&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(inter.constructor!=&lt;span&gt;Interface){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;如果是接口类的话，就必须是Interface类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接口中的方法是否全部实现
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历函数集合&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;inter.methods.length;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method=inter.methods[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口中所有函数

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;object[method]传入的函数
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最终是判断传入的函数是否与接口中所用函数匹配&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;object&lt;/span&gt;[method]||&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[method]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类中必须有方法名字与接口中所用方法名相同&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现类中没有完全实现接口中的所有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在html中将继承文件引入，代码如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建extend函数为了程序中所有的继承操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;subClass:子类  superClass：超类&lt;/span&gt;
&lt;span&gt;function extend(subClass,superClass) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1，使子类原型属性等于父类的原型属性

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个中间空对象，目的是为了转换主父关系&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; F =&lt;span&gt; function () {};
    F.prototype &lt;/span&gt;=&lt;span&gt; superClass.prototype;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2， 让子类继承F&lt;/span&gt;
    subClass.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
    subClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; subClass;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3，为子类增加属性 superClass ==》原型链的引用&lt;/span&gt;
    subClass.superClass =&lt;span&gt; superClass.prototype;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4，增加一个保险，就算你的原型类是超类（Object）那么也要把你的构造函数级别降下来&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (superClass.prototype.constructor ==&lt;span&gt; Object.prototype.constructor) {
        superClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; superClass;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）分析各个类提出相同的部分作为基类，基类代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基类  分析后有共同的提出来作为基类&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）各个具体的实现类：继承基类+接口实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;各个宠物类（实现类）  继承基类+接口实现&lt;/span&gt;
&lt;span&gt;    function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）实现类与基类的继承实现，代码如下（调用extend（））&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
extend(Dog,basePet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动物狗继承基类&lt;/span&gt;
&lt;span&gt;    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）将商店抽取出来，做成抽象类，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//把核心商店抽取出来
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; petShop=&lt;span&gt;function () {};
       petShop.prototype&lt;/span&gt;={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟抽象类  需要被子类覆盖&lt;/span&gt;
&lt;span&gt;           getPet:function (kind){
               &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getpet(kind);
               pet.eat();
               pet.register();
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
           },
           getpet:function (model){
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该类是抽象类，不能实例化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

           }
       };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（7）利用子类来满足各个商家的不同类型宠物店的实现 ，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用子类来满足之前的需求（多态）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oneShop=&lt;span&gt;function () { }
       extend(oneShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
      oneShop.prototype.getpet=&lt;span&gt;function (model) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
          &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (model){
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
          Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;          pet.eat();
          pet.register();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
      };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同上，这个也是一个不同的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 twoShop=&lt;span&gt;function () {};
    extend(twoShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店的继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
      twoShop.prototype.getPet=&lt;span&gt;function (model) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
          &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (kind){
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pig();
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
          Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;          pet.eat();
          pet.register();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
      };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（8） 使用，实质是子类对父类的实例化&lt;/p&gt;
&lt;p&gt;这里实现其中一个宠物店，另外一个同理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//子类对父类的实例化
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jim=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; oneShop();
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pig= jim.getpet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        pig.run();
        pig.sing()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（9）上述代码综合在一起为，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)接口调用&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; Pet=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（1）基类  分析后有共同的提出来作为基类&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（3）实现类  继承基类+接口实现&lt;/span&gt;
&lt;span&gt;    function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;
    extend(Dog,basePet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物的继承&lt;/span&gt;
&lt;span&gt;    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4）把核心商店抽取出来&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; petShop=&lt;span&gt;function () {};
       petShop.prototype&lt;/span&gt;={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟抽象类  需要被子类覆盖&lt;/span&gt;
&lt;span&gt;           getPet:function (kind){
               &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getpet(kind);
               pet.eat();
               pet.register();
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
           },
           getpet:function (model){
             &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该类是抽象类，不能实例化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

           }
       };
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（5）商店1 利用子类来满足之前的需求（多态）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oneShop=&lt;span&gt;function () { }
       extend(oneShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
      oneShop.prototype.getpet=&lt;span&gt;function (model) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
          &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (model){
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
          Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;          pet.eat();
          pet.register();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
      };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（5）商店2&lt;/span&gt;
    twoShop=&lt;span&gt;function () {};
    extend(twoShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店的继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
      twoShop.prototype.getPet=&lt;span&gt;function (model) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
          &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (kind){
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pig();
                  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                  pet&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bird();
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
          Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;          pet.eat();
          pet.register();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
      };
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6）使用  子类对父类的实例化&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; jim=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; oneShop();//开宠物店
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pig= jim.getpet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);//从宠物店得到宠物
        pig.run();//宠物功能
        pig.sing()

})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：代码中的注释编号表示其大概思考过程及实现顺序。&lt;/p&gt;
&lt;p&gt;总结一下，在该个模式中主要体现在多态多一点。现在我们将前面的各种综合在一起使用JavaScript的eval()做一个智能化的工厂。&lt;/p&gt;
&lt;p&gt;4，通过eval()实现智能化工厂&lt;/p&gt;
&lt;p&gt;（1）接口文件和继承文件的引入，如上述的一模一样，这里将不再重复贴代码了，直接开始我们的新东西吧。&lt;/p&gt;
&lt;p&gt;（2）接口调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; Pet=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）将相同部分提取出来（简单的提取）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基类  分析后有共同的提出来作为基类&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）各动物类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类  继承基类+接口实现&lt;/span&gt;
&lt;span&gt;    function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）实现各动物类继承基类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;
&lt;span&gt;    extend(Dog,basePet);
    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）将商店核心抽取出来，做成一个抽象类，代码如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; petShop=&lt;span&gt;function () {};
    petShop.prototype&lt;/span&gt;={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟抽象类  需要被子类覆盖&lt;/span&gt;
&lt;span&gt;        getPet:function (kind){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getpet(kind);
            pet.eat();
            pet.register();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        },
        getpet:function (model){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该类是抽象类，不能实例化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        }
    };&lt;br/&gt;//这里是做成抽象类其中的getpet方法是通过子类实现的。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（7）做一个智能工厂&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(5)智能工厂 只负责生成宠物&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PetFactory=&lt;span&gt;{
        sellPet:function (kind) {
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
           pet&lt;/span&gt;=eval(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+kind+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Interface.ensureImplement(pet,Pet);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （8）利用子类来满足各个商家的不同类型宠物店的实现 ，代码如下&lt;/p&gt;
&lt;p&gt;其中一个子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用子类来满足各个商家的不同类型宠物店的实现 （多态）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oneShop=&lt;span&gt;function () { };
    extend(oneShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
    oneShop.prototype.getpet=&lt;span&gt;function (model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pets=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bird&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店自己拥有的宠物  宠物货架&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(v &lt;span&gt;in&lt;/span&gt; pets){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环出索引&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(pets[v]==model){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;model是我们自己传递过来需要创建的宠物&lt;/span&gt;
            pet=&lt;span&gt;PetFactory.sellPet(model);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
       Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;                pet.eat();
                pet.register();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 另一个子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（商店2）利用子类来满足各个商家的不同类型宠物店的实现 （多态）&lt;/span&gt;
    twoShop=&lt;span&gt;function () {};
    extend(twoShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店的继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
    twoShop.prototype.getPet=&lt;span&gt;function (model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pets=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店自己拥有的宠物&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(v &lt;span&gt;in&lt;/span&gt; pets){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环出索引&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(pets[v]==&lt;span&gt;model){
                pet&lt;/span&gt;=&lt;span&gt;PetFactory.sellPet(model);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
                Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;                pet.eat();
                pet.register();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（9）实现开宠物店卖宠物&lt;/p&gt;
&lt;p&gt;这里我们来开第二个商店，卖Pig&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; shop=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; twoShop();//创建商店
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=shop.getPet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);//从商店中得到宠物
      pet.run();//宠物的功能&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（10）智能化工厂的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)接口调用&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; Pet=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;register&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（2）基类  分析后有共同的提出来作为基类&lt;/span&gt;
&lt;span&gt;    function basePet() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.register=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物登记。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eat=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宠物吃饭。。。。&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（3）各个动物类（实现类） 继承基类+接口实现&lt;/span&gt;
&lt;span&gt;    function Dog() {
        Dog.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小狗唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Cat() {
        Cat.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猫唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Pig() {
        Pig.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小猪唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    function Bird() {
        Bird.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现接口&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.run=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟跑......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sing=&lt;span&gt;function () {
            document.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小鸟唱歌......&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;
&lt;span&gt;    extend(Dog,basePet);
    extend(Cat,basePet);
    extend(Pig,basePet);
    extend(Bird,basePet);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(4)把核心商店抽取出来&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; petShop=&lt;span&gt;function () {};
    petShop.prototype&lt;/span&gt;={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟抽象类  需要被子类覆盖&lt;/span&gt;
&lt;span&gt;        getPet:function (kind){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getpet(kind);
            pet.eat();
            pet.register();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        },
        getpet:function (model){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该类是抽象类，不能实例化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        }
    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(5)智能工厂 只负责生成宠物&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PetFactory=&lt;span&gt;{
        sellPet:function (kind) {
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; pet;
           pet&lt;/span&gt;=eval(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+kind+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Interface.ensureImplement(pet,Pet);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(6)（商店1）利用子类来满足各个商家的不同类型宠物店的实现 （多态）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oneShop=&lt;span&gt;function () { };
    extend(oneShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
    oneShop.prototype.getpet=&lt;span&gt;function (model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pets=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bird&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店自己拥有的宠物  宠物货架&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(v &lt;span&gt;in&lt;/span&gt; pets){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环出索引&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(pets[v]==model){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;model是我们自己传递过来需要创建的宠物&lt;/span&gt;
            pet=&lt;span&gt;PetFactory.sellPet(model);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
       Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;                pet.eat();
                pet.register();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（商店2）利用子类来满足各个商家的不同类型宠物店的实现 （多态）&lt;/span&gt;
    twoShop=&lt;span&gt;function () {};
    extend(twoShop,petShop);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店的继承
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆写方法&lt;/span&gt;
    twoShop.prototype.getPet=&lt;span&gt;function (model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pet=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宠物种类&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pets=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;商店自己拥有的宠物&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(v &lt;span&gt;in&lt;/span&gt; pets){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环出索引&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(pets[v]==&lt;span&gt;model){
                pet&lt;/span&gt;=&lt;span&gt;PetFactory.sellPet(model);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证接口&lt;/span&gt;
                Interface.ensureImplement(pet,Pet);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断pet对象是否全部实行接口Pet里面全部的方法&lt;/span&gt;
&lt;span&gt;                pet.eat();
                pet.register();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pet;
    };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7）开宠物店卖宠物&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; shop=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; twoShop();
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pet=shop.getPet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      pet.run();

})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下，该种智能化工厂的特点体现在我们需要什么宠物店时，我们可以直接通过智能化工厂创建。很完美。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 3，工厂模式的使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;待续。。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 13 Oct 2017 07:36:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7661020.html</dc:identifier>
</item>
<item>
<title>Rx 入门指引 （一） - 小精灵儿Pawn</title>
<link>http://www.cnblogs.com/likeFlyingFish/p/7661395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/likeFlyingFish/p/7661395.html</guid>
<description>&lt;p&gt;自学 Rx 快有一个周了， 它非常适合处理复杂的异步场景。结合自己所学，决定写系列教程。&lt;/p&gt;
&lt;p&gt;我认为， Rx 中强大的地方在于两处&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;管道思想，通过管道，我们订阅了数据的来源，并在数据源更新时响应 。&lt;/li&gt;
&lt;li&gt;强大的操作符，通过操作符对流和流中的数据转换，拼接，以形成我们想要的数据模型 。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据管道&quot;&gt;数据管道&lt;/h2&gt;
&lt;p&gt;在 Rx 中，我们先预装好管道，通过管道流通数据 。这些管道的来源多种， create ，from， fromEvent， of .., 通过操作符将管道 拼接，合并，映射...形成最终的数据模型 。&lt;br/&gt;对于管道来说，有两点非常重要&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;. 管道是懒执行的，只有订阅器 observer subscribe了 数据管道，这个管道才会有数据流通 。&lt;/li&gt;
&lt;li&gt;. 整个节点组成一个完整的管道，订阅了后面的管道节点，也会同时订阅之前的管道节点 ，每个节点接受之前的值，并发出新值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在很多教程中， Rx 往往以这个例子开始 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  const example = Rx.Observable.create ((observer) =&amp;gt; {
    const timer = setTimeout(() =&amp;gt; {
      observer.next(8);
    })
    observer.next(10);
    return () =&amp;gt; {
      clearTimeout(timer);
    }
  })

  const unsubscribe = example.subscribe((a) =&amp;gt; {
    console.log(a);
  })

  //结果当然是 10， 8.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子发现了两种相似的设计模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器模式&lt;/li&gt;
&lt;li&gt;观察者模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;迭代器模式：类似于 JS 6 增加的迭代器 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  const iterator = [1, 2, 3][Symbol.iterator]();
  while(true) {
    const result = iterator.next();
    if(result.done) return;

    cnosole.log(result.value);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者模式： 事件模型是最常见的观察者模式， 定义生产者与消费者，生产者发出值，消费者收到消息，并执行相应行文 。 Observable 与其不同的是， Observable 是拉模型，懒执行，只有指定订阅者，生产者才会派发。 Rx 中的推模型实现Subject 就是采用观察者模式，不管有没有订阅者，都会推送数据 。&lt;/p&gt;
&lt;h2 id=&quot;操作符&quot;&gt;操作符&lt;/h2&gt;
&lt;p&gt;Rx 如此高效和强大，得益于其强大的操作符 。&lt;br/&gt;主要包含下面几类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建操作符： create， range， of， from， fromEvent， fromPromise, empty ..&lt;/li&gt;
&lt;li&gt;组合 contact ,merge, startWith, zip ..&lt;/li&gt;
&lt;li&gt;时间 delay , throttle, dobounceTime, interval ..&lt;/li&gt;
&lt;li&gt;过滤： filter, first, last, skip, distinct, take ..&lt;/li&gt;
&lt;li&gt;转换： buffer,map, mapTo, mergeMap, switch, switchMap, reduce, scan ..&lt;/li&gt;
&lt;li&gt;工具： do, toPromise ..&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;vs-promise&quot;&gt;vs Promise&lt;/h2&gt;
&lt;p&gt;很多大牛介绍，在相对简单的情况下，大可不必使用 Observable ，Promise 足以应对。&lt;br/&gt;类似于下面的模型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  new Promise ((resolve, reject) = {})
  .then()
  .then()
  .then() ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模型非常大程度改善了 回调地狱， 也能处理大部分的异步场景，name 对于 Rx ， 它有哪些地方不足呢 ？&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Rx 抽象了数据的来源，主要是对事件和网络请求的抽象 。&lt;/li&gt;
&lt;li&gt;Rx 可以多次发出数据， 而Promise 只能发出一次数据， 复用之前的管道。&lt;/li&gt;
&lt;li&gt;Rx 可以是懒执行的，只有在订阅之后，才会发出值，也就是订阅 。 而Promise 在定义后理解执行 。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;注意到我们上面的例子，是可以cancle 取消订阅的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  return () =&amp;gt; {
    clearTimeout(timer);
  }
})

const unsubscribe = example.subscribe((a) =&amp;gt; {
  console.log(a);
})&lt;/code&gt;
&lt;/pre&gt;
create 会返回一直函数，这个函数用于清理管道执行产生的垃圾，比如这里的定时器 。调用 unsubscribe 会取消订阅，并执行清理函数。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Promise 中数据变换只有通过then 链来进行，这点在fetch API 中体现最明显。但是Rx包含大量的操作符，简化了很多运算 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;尾声&quot;&gt;尾声&lt;/h2&gt;
&lt;p&gt;在这一篇， 我介绍了Rx 的概念，以及与Promise 的对比，理解Rx ，主要是理解管道思想和响应式编程 。说Rx 门槛高，也就是新手们管道思想和响应式编程在前端的实践不多。&lt;br/&gt;在下一篇，会分类使用所有的操作符，如果算是API 文档，那就死文档吧 。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 07:25:00 +0000</pubDate>
<dc:creator>小精灵儿Pawn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/likeFlyingFish/p/7661395.html</dc:identifier>
</item>
<item>
<title>this到底指向哪里 - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/7661382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/7661382.html</guid>
<description>&lt;p&gt;首先要明确，this指向调用方，谁调用，this指向谁。&lt;/p&gt;
&lt;h2 id=&quot;直接调用&quot;&gt;直接调用&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'window'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'inner'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test change'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// test change&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// test change&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在chrome中执行后可以发现，外部挂在window下的test被修改了，因为这个testThis的函数，是被window调用的，它只会读取window下的test。&lt;/p&gt;
&lt;h2 id=&quot;构造函数调用&quot;&gt;构造函数调用&lt;/h2&gt;
&lt;p&gt;再举个栗子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'window'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'inner'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'test change'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; newTestThis &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// test change&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// window&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在chrome中执行以下可以发现，依次输出undefined、test change、window。&lt;br/&gt;这个栗子与上面的区别在于调用了new。此时，该函数作为构造函数调用，我们都知道，构造函数中的this都指向new出来的对象。所以this指向了这个新生成的newTestThis。自然地，window下test就没有被修改。&lt;/p&gt;
&lt;h2 id=&quot;嵌套调用&quot;&gt;嵌套调用&lt;/h2&gt;
&lt;p&gt;接下来举一个栗子，来说明在函数嵌套调用时的this指向：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'global'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// this.x = 'fuck';&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// console.log(this)&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;innerObj&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'inner'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerTestThis&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; testThis&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerTestThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;wrapObj&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'wrap'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// var test = new testThis();&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// console.log(test.x)&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;testThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;wrapTestThis&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; testThis&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;wrapTestThis&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerTestThis&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;innerObj&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; wrap &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;wrapObj&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;wrapObj&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// global&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// wrap&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// global&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// inner&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// wrap&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// wrap&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// wrap&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// inner&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显，在函数嵌套时，如果不给函数指定调用对象，则不论被调用函数是在哪个函数的作用域里，被调用的函数的this都是指向window的。&lt;br/&gt;我们可以这样理解，在直接调用时，这些函数除了拥有自己的作用域外，就像是把这几行代码写到了相应的位置。可以想一下，所有的js代码最后都拼到一起，很明显，他们的调用方都是window。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;strong&gt;1.不论函数在哪里被调用，只要没有指定调用方，则this都指向window。指定了调用方，就指向调用方。2.作为构造函数中调用，this指向新生成的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析一下settimeout和setinterval&quot;&gt;分析一下：setTimeout和setInterval&lt;/h2&gt;
&lt;p&gt;bind的作用就是给函数一个指定的thisArg，经常使用bind的地方就是setTimeout和setInterval了。为什么呢？&lt;br/&gt;setTimeout和setInterval都有一个特点，它会将回调函数的作用域转移到window上面。其实结合我们上面说的，很容易知道为什么。&lt;br/&gt;以setTimeout为例：翻看&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout&quot;&gt;MDN下setTimeout的定义&lt;/a&gt;，可以发现，setTimeout是把一段callback代码延迟执行。写过callback的同学都知道，callback的代码其实就是占了位，然后去调用一行行的代码，所以，callback中的this也会指向window。&lt;br/&gt;实际开发中，我们不希望this指向window，故而常使用bind来使this指向我们希望的对象。&lt;/p&gt;
&lt;h2 id=&quot;bindapplycall&quot;&gt;bind、apply、call&lt;/h2&gt;
&lt;p&gt;说到了bind，就还需要提一下另外的可以改变this指向的方法：apply和call。&lt;br/&gt;这两个函数大同小异，只是传参有区别。不论使用apply还是call，都会传入一个thisArg，作为函数调用方，让函数中的this指向thisArg。&lt;br/&gt;在下一篇，我会介绍一下apply和call。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 07:23:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/7661382.html</dc:identifier>
</item>
<item>
<title>用C#实现字符串相似度算法（编辑距离算法 Levenshtein Distance） - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7661375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7661375.html</guid>
<description>&lt;p&gt;在搞验证码识别的时候需要比较字符代码的相似度用到“编辑距离算法”，关于原理和C#实现做个记录。&lt;/p&gt;
&lt;p&gt;据百度百科介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编辑距离&lt;/strong&gt;，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。&lt;/p&gt;
&lt;p&gt;　　例如将kitten一字转成sitting：&lt;/p&gt;
&lt;p&gt;　　sitten （k→s）&lt;/p&gt;
&lt;p&gt;　　sittin （e→i）&lt;/p&gt;
&lt;p&gt;　　sitting （→g）&lt;/p&gt;
&lt;p&gt;　　俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。因此也叫Levenshtein Distance。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果str1=&quot;ivan&quot;，str2=&quot;ivan&quot;，那么经过计算后等于 0。没有经过转换。相似度=1-0/Math.Max(str1.length,str2.length)=1&lt;/li&gt;
&lt;li&gt;如果str1=&quot;ivan1&quot;，str2=&quot;ivan2&quot;，那么经过计算后等于1。str1的&quot;1&quot;转换&quot;2&quot;，转换了一个字符，所以距离是1，相似度=1-1/Math.Max(str1.length,str2.length)=0.8&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　DNA分析&lt;/p&gt;
&lt;p&gt;　　拼字检查&lt;/p&gt;
&lt;p&gt;　　语音辨识&lt;/p&gt;
&lt;p&gt;　　抄袭侦测&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;str1或str2的长度为0返回另一个字符串的长度。 if(str1.length==0) return str2.length; if(str2.length==0) return str1.length;&lt;/li&gt;
&lt;li&gt;初始化(n+1)*(m+1)的矩阵d，并让第一行和列的值从0开始增长。&lt;/li&gt;
&lt;li&gt;扫描两字符串（n*m级的），如果：str1[i] == str2[j]，用temp记录它，为0。否则temp记为1。然后在矩阵d[i,j]赋于d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp三者的最小值。&lt;/li&gt;
&lt;li&gt;扫描完后，返回矩阵的最后一个值d[n][m]即是它们的距离。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;计算相似度公式：1-它们的距离/两个字符串长度的最大值。&lt;br/&gt;为了直观表现，我将两个字符串分别写到行和列中，实际计算中不需要。我们用字符串“ivan1”和“ivan2”举例来看看矩阵中值的状况：&lt;/p&gt;
&lt;p&gt;1、第一行和第一列的值从0开始增长&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5&gt; &lt;/h5&gt;
&lt;p&gt;2、i列值的产生 Matrix[i - 1, j] + 1 ; Matrix[i, j - 1] + 1   ;    Matrix[i - 1, j - 1] + t&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;0+t=0&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;&lt;span&gt;1+1=2&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;&lt;span&gt;1+1=2&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;&lt;span&gt;取三者最小值=0&lt;/span&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;依次类推：1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;101&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;39&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;37&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;43&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;3、V列值的产生&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;依次类推直到矩阵全部生成&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;i&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;v&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;a&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;n&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;31&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;25&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;28&quot;&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;最后得到它们的距离=1&lt;/p&gt;
&lt;p&gt;相似度：1-1/Math.Max(“ivan1”.length,“ivan2”.length) =0.8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法用C#实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LevenshteinDistance
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取最小的一位数
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;first&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;second&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;third&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; LowerOfThree(&lt;span&gt;int&lt;/span&gt; first, &lt;span&gt;int&lt;/span&gt; second, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; third)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; min =&lt;span&gt; Math.Min(first, second);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.Min(min, third);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Levenshtein_Distance(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; str2)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[,] Matrix;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; str1.Length;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; str2.Length;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch1;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch2;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (m == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             Matrix = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + &lt;span&gt;1&lt;/span&gt;, m + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化第一列&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 Matrix[i, &lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt;= m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化第一行&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                 Matrix[&lt;span&gt;0&lt;/span&gt;, j] =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 ch1 = str1[i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     ch2 = str2[j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ch1.Equals(ch2))
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                         temp = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                     Matrix[i, j] = LowerOfThree(Matrix[i - &lt;span&gt;1&lt;/span&gt;, j] + &lt;span&gt;1&lt;/span&gt;, Matrix[i, j - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;, Matrix[i - &lt;span&gt;1&lt;/span&gt;, j - &lt;span&gt;1&lt;/span&gt;] +&lt;span&gt; temp);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt;= m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                     Console.Write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {0} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Matrix[i, j]);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;       
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Matrix[n, m];
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 计算字符串相似度
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;str1&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;str2&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; LevenshteinDistancePercent(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; str2)
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int maxLenth = str1.Length &amp;gt; str2.Length ? str1.Length : str2.Length;&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; val =&lt;span&gt; Levenshtein_Distance(str1, str2);
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; - (&lt;span&gt;decimal&lt;/span&gt;)val /&lt;span&gt; Math.Max(str1.Length, str2.Length);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 调用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; str1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ivan1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; str2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ivan2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字符串1 {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str1);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字符串2 {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, str2);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;相似度 {0} %&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; LevenshteinDistance().LevenshteinDistancePercent(str1, str2) * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);          
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Console.ReadLine();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171013151243590-964288059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拓展与补充：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　小规模的字符串近似搜索，需求类似于搜索引擎中输入关键字，出现类似的结果列表。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;来源&lt;/strong&gt;：.Net.NewLife。&lt;br/&gt;    &lt;strong&gt;需求&lt;/strong&gt;：假设在某系统存储了许多地址，例如：“北京市海淀区中关村大街1号海龙大厦”。用户输入“北京 海龙大厦”即可查询到这条结果。另外还需要有容错设计，例如输入“广西 京岛风景区”能够搜索到&quot;&lt;span&gt;广西&lt;/span&gt;壮族自治区&lt;span&gt;京岛风景&lt;span&gt;名胜&lt;/span&gt;区&lt;/span&gt;&quot;。最终的需求是：&lt;strong&gt;可以根据用户输入，匹配若干条近似结果共用户选择&lt;/strong&gt;。&lt;br/&gt;    &lt;strong&gt;目的&lt;/strong&gt;：避免用户输入类似地址导致数据出现重复项。例如，已经存在“北京市中关村”，就不应该再允许存在“北京中关村”。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;举例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Aimeast/201109/201109051844271870.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Aimeast/201109/201109051844285034.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Aimeast/201109/201109051844292658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    此类技术在搜索引擎中早已广泛使用，例如“查询预测”功能。&lt;/p&gt;
&lt;p&gt;    要实现此算法，首先需要明确“字符串近似”的概念。&lt;/p&gt;
&lt;p&gt;    计算字符串相似度通常使用的是动态规划(DP)算法。&lt;/p&gt;
&lt;p&gt;    常用的算法是 &lt;a class=&quot;external&quot; href=&quot;http://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;Levenshtein Distance&lt;/a&gt;。用这个算法可以直接计算出两个字符串的“编辑距离”。所谓编辑距离，是指一个字符串，每次只能通过插入一个字符、删除一个字符或者修改一个字符的方法，变成另外一个字符串的最少操作次数。这就引出了第一种方法：&lt;strong&gt;计算两个字符串之间的编辑距离&lt;/strong&gt;。稍加思考之后发现，不能用输入的关键字直接与句子做匹配。你必须从句子中选取合适的长度后再做匹配。把结果按照距离升序排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BestString
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SearchHelper
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] Search(&lt;span&gt;string&lt;/span&gt; param, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] datas)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(param))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;  
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] words = param.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] { &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;　&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }, StringSplitOptions.RemoveEmptyEntries);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; maxDist = (word.Length - &lt;span&gt;1&lt;/span&gt;) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; q = &lt;span&gt;from&lt;/span&gt; str &lt;span&gt;in&lt;/span&gt;&lt;span&gt; datas
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;where&lt;/span&gt; word.Length &amp;lt;=&lt;span&gt; str.Length
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                             &amp;amp;&amp;amp; Enumerable.Range(&lt;span&gt;0&lt;/span&gt;, maxDist + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             .Any(dist =&amp;gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                                 &lt;span&gt;return&lt;/span&gt; Enumerable.Range(&lt;span&gt;0&lt;/span&gt;, Math.Max(str.Length - word.Length - dist + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                                     .Any(f =&amp;gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                         &lt;span&gt;return&lt;/span&gt; Distance(word, str.Substring(f, word.Length + dist)) &amp;lt;=&lt;span&gt; maxDist;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                            })
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;orderby&lt;/span&gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;select&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 datas =&lt;span&gt; q.ToArray();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;  
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; datas;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;  
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Distance(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; str2)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; str1.Length;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; str2.Length;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[,] C = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + &lt;span&gt;1&lt;/span&gt;, m + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, x, y, z;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 C[i, &lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= m; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 C[&lt;span&gt;0&lt;/span&gt;, i] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; m; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     x = C[i, j + &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     y = C[i + &lt;span&gt;1&lt;/span&gt;, j] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (str1[i] ==&lt;span&gt; str2[j])
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                         z =&lt;span&gt; C[i, j];
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                         z = C[i, j] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     C[i + &lt;span&gt;1&lt;/span&gt;, j + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; Math.Min(Math.Min(x, y), z);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C[n, m];
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    分析这个方法后发现，每次对一个句子进行相关度比较的时候，都要把把句子从头到尾扫描一次，每次扫描还需要以最大误差作长度控制。这样一来，对每个句子的计算次数大大增加。达到了二次方的规模（忽略距离计算时间）。&lt;/p&gt;
&lt;p&gt;    所以我们需要更高效的计算策略。在纸上写出一个句子，再写出几个关键字。一个一个涂画之后，偶然发现另一种字符串相关的算法完全可以适用。那就是 &lt;a class=&quot;external&quot; href=&quot;http://en.wikipedia.org/wiki/Longest_common_subsequence_problem&quot;&gt;Longest common subsequence（LCS，最长公共字串）&lt;/a&gt;。为什么这个算法可以用来计算两个字符串的相关度？先看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字：&lt;span&gt;少年时代&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;神话&lt;/span&gt;&lt;span&gt;播下了浪漫&lt;/span&gt;注意&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;句子：就是&lt;span&gt;少年时代&lt;/span&gt;&lt;span&gt;大量&lt;/span&gt;&lt;span&gt;神话&lt;/span&gt;传说在其心田里&lt;span&gt;播下了浪漫&lt;/span&gt;主义这颗难以磨灭的种子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    这里用了两个关键字进行搜索。可以看出来两个关键字都有部分匹配了句子中的若干部分。这样可以单独为两个关键字计算 LCS，LCS之和就是简单的相关度。看到这里，你若是已经理解了核心思想，已经可以实现出基本框架了。但是，请看下面这个例子：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字：东土大唐，唐三藏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;句子：我本是&lt;span&gt;东土大唐&lt;/span&gt;钦差御弟&lt;span&gt;唐三藏&lt;/span&gt;大徒弟孙悟空行者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    看出来问题了吗？下面还是使用同样的关键字和句子。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字：东土大(唐唐)三藏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;句子： 我本是&lt;span&gt;东土大&lt;/span&gt;唐钦差御弟&lt;span&gt;唐&lt;/span&gt;&lt;span&gt;三藏&lt;/span&gt;大徒弟孙悟空行者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    举这个例子为了说明，在进行 LCS 计算的过程中，得到的结果并不能保证就是我们期望的结果。为了①保证所匹配的结果中不存在交集，并且②在句子中的匹配结果尽可能的短，需要采取两个补救措施。（为什么需要满足这样的条件，读者自行思考）&lt;/p&gt;
&lt;p&gt;    第一：可以在单次计算 LCS 之后，用贪心策略向前（向后）找到最先能够完成匹配的位置，再用相同的策略向后（向前）扫描。这样可以满足第二个条件找到句子中最短的匹配。如果你对 LCS 算法有深入了解，完全可以在计算 LCS 的过程中找到最短匹配的结束位置，然后只需要进行一次向前扫描就可以完成。这样节约了一次扫描过程。&lt;/p&gt;
&lt;p&gt;    第二：增加一个标记数组，记录句子中的字符是否被匹配过。&lt;/p&gt;
&lt;p&gt;    最后标记数组中标记过的位置就是匹配结果。&lt;/p&gt;
&lt;p&gt;    相信你看到这里一定非常头晕，下面用一个例子解释：（句子）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字：   ABCD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;句子：     &lt;span&gt;X&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&lt;span&gt;A&lt;/span&gt;B&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;YZ&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;句子分解： &lt;span&gt;X Y  Z  X   YZ&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;span&gt;A   B C   D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              &lt;span&gt;A   B C D&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    你可能会匹配成 AYABZCBXCDD，AYABZCBXCD，ABZCBXCDD，ABZCBXCD。我们实际需要的只是ABZCBXCD。&lt;/p&gt;
&lt;p&gt;    使用LCS匹配之后，得到的很可能是 X&lt;span&gt;AYABZCBXCDD&lt;/span&gt;YZ；&lt;/p&gt;
&lt;p&gt;    用贪心策略向前处理后，得到结果为 XAY&lt;span&gt;ABZCBXCDD&lt;/span&gt;YZ；&lt;/p&gt;
&lt;p&gt;    用贪心策略向后处理后，得到结果为 XAY&lt;span&gt;ABZCBXCD&lt;/span&gt;DYZ。&lt;/p&gt;
&lt;p&gt;    这样处理的目的是为了避免得到较长的匹配结果（类似正则表达式的贪婪、懒惰模式）。&lt;/p&gt;
&lt;p&gt;    以上只是描述了怎么计算两个字符串的相似程度。除此之外还需要：①剔除相似度较低的结果；②对结果进行排序。&lt;/p&gt;
&lt;p&gt;    剔除相似度较低的结果，这里设定了一个阈值：差错比例不能超过匹配结果长度的一半。&lt;/p&gt;
&lt;p&gt;    对结果进行排序，不能够直接使用相似度进行排序。因为相似度并没有考虑到句子的长度。按照使用习惯，通常会把匹配度高，并且句子长度短的放在前面。这就得到了排序因子：（不匹配度+0.5）/句子长度。&lt;/p&gt;
&lt;p&gt;    最后得到我们最终的搜索方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BestString
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SearchHelper
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] Search(&lt;span&gt;string&lt;/span&gt; param, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] items)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(param) || items == &lt;span&gt;null&lt;/span&gt; || items.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] words =&lt;span&gt; param
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                 .Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] { &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\u3000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }, StringSplitOptions.RemoveEmptyEntries)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                                 .OrderBy(s =&amp;gt;&lt;span&gt; s.Length)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                                .ToArray();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; q = &lt;span&gt;from&lt;/span&gt; sentence &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items.AsParallel()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     let MLL =&lt;span&gt; Mul_LnCS_Length(sentence, words)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;where&lt;/span&gt; MLL &amp;gt;= &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;orderby&lt;/span&gt; (MLL + &lt;span&gt;0.5&lt;/span&gt;) /&lt;span&gt; sentence.Length, sentence
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;select&lt;/span&gt;&lt;span&gt; sentence;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;  
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; q.ToArray();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;static int[,] C = new int[100, 100];&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;  
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sentence&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;words&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;多个关键字。长度必须大于0，必须按照字符串长度升序排列。&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Mul_LnCS_Length(&lt;span&gt;string&lt;/span&gt; sentence, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] words)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; sLength =&lt;span&gt; sentence.Length;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; sLength;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt;[] flags = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;[sLength];
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[,] C = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[sLength + &lt;span&gt;1&lt;/span&gt;, words[words.Length - &lt;span&gt;1&lt;/span&gt;].Length + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int[,] C = new int[sLength + 1, words.Select(s =&amp;gt; s.Length).Max() + 1];&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; wLength =&lt;span&gt; word.Length;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; first = &lt;span&gt;0&lt;/span&gt;, last = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, LCS_L;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;foreach 速度会有所提升，还可以加剪枝&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sLength; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; wLength; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (sentence[i] ==&lt;span&gt; word[j])
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                             C[i + &lt;span&gt;1&lt;/span&gt;, j + &lt;span&gt;1&lt;/span&gt;] = C[i, j] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (first &amp;lt;&lt;span&gt; C[i, j])
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                                 last =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                                 first =&lt;span&gt; C[i, j];
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;                             C[i + &lt;span&gt;1&lt;/span&gt;, j + &lt;span&gt;1&lt;/span&gt;] = Math.Max(C[i, j + &lt;span&gt;1&lt;/span&gt;], C[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, j]);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  
&lt;span&gt;65&lt;/span&gt;                 LCS_L =&lt;span&gt; C[i, j];
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (LCS_L &amp;lt;= wLength &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;  
&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (i &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; j &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (C[i - &lt;span&gt;1&lt;/span&gt;, j - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt; ==&lt;span&gt; C[i, j])
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                         i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                         j--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flags[i])
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                             flags[i] = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                             result--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                         first =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (C[i - &lt;span&gt;1&lt;/span&gt;, j] ==&lt;span&gt; C[i, j])
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                         i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if (C[i, j - 1] == C[i, j])&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;                         j--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;  
&lt;span&gt;88&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (LCS_L &amp;lt;= (last - first + &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;  
&lt;span&gt;92&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    对于此类问题，要想得到更快速的实现，必须要用到分词+索引的方案。在此不做探讨。&lt;/p&gt;
&lt;p&gt;代码打包下载：&lt;a title=&quot;http://files.cnblogs.com/Aimeast/BestString.zip&quot; href=&quot;http://files.cnblogs.com/Aimeast/BestString.zip&quot;&gt;http://files.cnblogs.com/Aimeast/BestString.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 07:22:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7661375.html</dc:identifier>
</item>
<item>
<title>干了这杯Java之ArrayList - 阿克西斯教成员污米饭</title>
<link>http://www.cnblogs.com/imeng/p/7661149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imeng/p/7661149.html</guid>
<description>&lt;p&gt;List存储一个有序元素合集&lt;/p&gt;
&lt;p&gt;List接口的实现类有: ArrayList,LinkedList,Vector,Stack&lt;/p&gt;
&lt;p&gt;ArrayList一个数组型的List&lt;/p&gt;
&lt;p&gt;默认容量为10&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩容&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
    &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = minCapacity;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        newCapacity = &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(minCapacity);
    &lt;span class=&quot;co&quot;&gt;// minCapacity is usually close to size, so this is a win:&lt;/span&gt;
    elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, newCapacity);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;扩容的大小为原长度+1/2的原长度&lt;/li&gt;
&lt;li&gt;如果扩容长度比传入的最小容量小，则使用最小容量,如果扩容长度超过设定的最大容量,则实用最大正整数&lt;/li&gt;
&lt;li&gt;初始化默认长度为10,当添加到11个长度时,容量为15&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;add方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
    &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// Increments modCount!!&lt;/span&gt;
    elementData[size++] = e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ensureCapacityInternal(size + 1);确保内部容量，不够则扩容&lt;/li&gt;
&lt;li&gt;elementData[size++] = e;赋值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;remove方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
    &lt;span class=&quot;co&quot;&gt;//检查下标&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(index);

    modCount++;
    E oldValue = &lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;(index);
    &lt;span class=&quot;co&quot;&gt;//移动元素&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numMoved = size - index - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;, elementData, index,
                         numMoved);
    elementData[--size] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// clear to let GC do its work&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldValue;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subList内部类&lt;/p&gt;
&lt;p&gt;生成subList对象&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;E&amp;gt; &lt;span class=&quot;fu&quot;&gt;subList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fromIndex, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; toIndex) {
    &lt;span class=&quot;co&quot;&gt;//检查边界&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;subListRangeCheck&lt;/span&gt;(fromIndex, toIndex, size);
    &lt;span class=&quot;co&quot;&gt;//生成的时SubList对象,注意this&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SubList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, fromIndex, toIndex);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;subList继承自AbstractList&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; parent;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; parentOffset;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size;

&lt;span class=&quot;fu&quot;&gt;SubList&lt;/span&gt;(AbstractList&amp;lt;E&amp;gt; parent,
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fromIndex, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; toIndex) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = parent;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parentOffset&lt;/span&gt; = fromIndex;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;offset&lt;/span&gt; = offset + fromIndex;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt; = toIndex - fromIndex;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;modCount&lt;/span&gt; = ArrayList.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;modCount&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在构造方法中this.parent = parent,意味着对象为原始list&lt;/li&gt;
&lt;li&gt;this.parentOffset = fromIndex;和this.offset = offset + fromIndex;为原始索引&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E e) {
    &lt;span class=&quot;fu&quot;&gt;rangeCheckForAdd&lt;/span&gt;(index);
    &lt;span class=&quot;fu&quot;&gt;checkForComodification&lt;/span&gt;();
    parent.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(parentOffset + index, e);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;modCount&lt;/span&gt; = parent.&lt;span class=&quot;fu&quot;&gt;modCount&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;++;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;parent.add(parentOffset + index, e);原始list将被添加一个元素&lt;/li&gt;
&lt;li&gt;remove方法中E result = parent.remove(parentOffset + index);将在原始list中移除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;结论:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在操作sublist的添加、移除等方法的时候,原始list将会被修改&lt;/li&gt;
&lt;li&gt;sublist是一个list的视图&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 13 Oct 2017 06:48:00 +0000</pubDate>
<dc:creator>阿克西斯教成员污米饭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imeng/p/7661149.html</dc:identifier>
</item>
<item>
<title>将 Intent 序列化，像 Uri 一样传递 Intent！！！ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/7660825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/7660825.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/301111864f9548e5f033934578e04e33&quot; alt=&quot;tips&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一真的需要new一个intent吗&quot;&gt;一、真的需要new一个Intent吗？&lt;/h2&gt;
&lt;p&gt;在 Android 中，打开一个 Activity ，有多少种方式？不过不管是使用什么方式，最终都没办法逃避创建一个 Intent ，然后&lt;code&gt;startActivity()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/3ecb8767d28ce1a43aa28a69f6fd508a&quot; alt=&quot;startActivity&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，如果想根据数据来确定跳转的页面呢？&lt;/p&gt;
&lt;p&gt;需要怎么做比较好一点。DeepLink 好像是一个不错的解决方案，在 AndroidManifest.xml 中，定义好 data 字段，标记好 scheme 、 host 等等，然后按照规则进行传递，这样也可以跳转到某些页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/d9ee908158acd6672b41de70f3fff18d&quot; alt=&quot;Deeplink&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这样真的方便吗？&lt;/p&gt;
&lt;p&gt;我们需要在每个需要跳转的 Activity 上，设定好data？当然，现在 Github 上也有一些成熟的 Deeplink 的解决方案，只需要在为某个 Activity 设定 data ，然后所有 deeplink 的链接都跳转到这个 Activity 上，最后再由这个RouterActivity，去决定向那里跳转，并携带上参数。&lt;/p&gt;
&lt;p&gt;那么还有别的方案吗？&lt;/p&gt;
&lt;h2 id=&quot;二intent的touri&quot;&gt;二、Intent的toUri()&lt;/h2&gt;
&lt;p&gt;直到我发现 Intent 居然有个 &lt;code&gt;toUri()&lt;/code&gt; 的方法，我就觉得有办法对 Intent 进行简单的序列化了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/3ae795cf53923fabb9173ebfe4cc26ca&quot; alt=&quot;method&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从文档中可以看出，&lt;code&gt;toUri()&lt;/code&gt; 方法可以将一个 Intent 转换成一个 URI ，其中包含了 action、categories、flags 等一些必要的参数。&lt;/p&gt;
&lt;p&gt;那么文章开头的地方，那么 startActivity ，最终转换成 URI ，是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/bf5911bc4873230d160b8dd1f3d20dc6&quot; alt=&quot;uri_string&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细看，flag、compoent、putExtra 的数据，都被序列化成一个字符串了。&lt;/p&gt;
&lt;p&gt;得到的这个 Uri ，如何使用呢？可以借助 Intent 的一个静态方法，&lt;code&gt;parseUri()&lt;/code&gt; 将一个 Intent 的 URI ，转换成实际的 Intent 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/78718ea6dc307bbcec3c2724d5b12a81&quot; alt=&quot;parseUri&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的话，其实下面的方式，同样也会调起TwoActivity，并且带过去一个 balabala 的 ID 数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/e92f9177cffd1a22351710dba5b89a04&quot; alt=&quot;start_uri&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，基本上把本篇文章需要讲解的内容都讲明白了。但是有追求的程序员，我们还是要深挖一下，&lt;code&gt;toUri()&lt;/code&gt; 到底干了些什么？&lt;/p&gt;
&lt;h2 id=&quot;三touri到底干了什么&quot;&gt;三、toUri()到底干了什么？&lt;/h2&gt;
&lt;p&gt;来看看 &lt;code&gt;toUri()&lt;/code&gt; 的具体实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/5d9e07bccbd3b264e1d669deae2c0ff8&quot; alt=&quot;to_uri_shixian&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从源码的实现看，其实 &lt;code&gt;toUri()&lt;/code&gt; 只是把每个字段读取出来，然后按照规则进行序列化，最后 &lt;code&gt;parseUri()&lt;/code&gt; 只是按照这个规则进行了反序列化。熟练的话，基本上无需使用 &lt;code&gt;toUri()&lt;/code&gt; 这个方法转换，就可以盲写 Intent 的 URI。&lt;/p&gt;
&lt;h2 id=&quot;四会有什么隐患吗&quot;&gt;四、会有什么隐患吗？&lt;/h2&gt;
&lt;p&gt;我们使用的 API 都是官方对 Intent 提供的，用起来好像也确实没有什么问题。但是真的像看上去那么美好吗？&lt;/p&gt;
&lt;p&gt;从传递参数的方向看，&lt;code&gt;toUriInner()&lt;/code&gt; 方法是&lt;code&gt;toUri()&lt;/code&gt; 方法中，对传递的数据进行序列化的方法。下面看看具体实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/d321b8c2a23f3280e4765e0f6ef5563f&quot; alt=&quot;toUriInner&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到， &lt;code&gt;toUriInner()&lt;/code&gt; 方法，它对基本的数据类型，都有对应的类型进行转换，例如之前S.id=balabala 表示一个 key 为 id 的 String 类型的值 balabala 。&lt;/p&gt;
&lt;p&gt;好像已经涵盖了所有的类型传参了，可是并不是这么美好。发现没有，没有关于 Bundle 的参数传递，难道是看漏了吗？&lt;/p&gt;
&lt;p&gt;代码也不看了，做个试验验证一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/8f36264106e77097e5ca57313f221b88&quot; alt=&quot;start_bundler3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看 Log 输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/13/c4cff495e5a7fb885238a7bc0f73e0c4&quot; alt=&quot;uri_string2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，&lt;code&gt;toUri()&lt;/code&gt; 这个方法，确实对 Bundle 参数的序列化并没有做特殊处理。&lt;/p&gt;
&lt;p&gt;得到的结论，就是虽然 &lt;code&gt;toUri()&lt;/code&gt; 和 &lt;code&gt;parseUri()&lt;/code&gt; 方法确实很好用，但是也是有缺陷的，Bundle 传递的数据没法序列化成 Uri。&lt;/p&gt;
&lt;p&gt;实际使用中，就需要我们对传递的参数有严格的要求，避免使用 Bundle 去传递数据，当然我们也可以自己去是实现序列化和反序列化 Bundle 的逻辑。&lt;/p&gt;
&lt;h2 id=&quot;五结语&quot;&gt;五、结语&lt;/h2&gt;
&lt;p&gt;这样就可以简单的对 Intent 进行传递，可以从后端服务器拿到一个 IntentUri ，这样就无需给每个点击设定好既定的打开页面了。当然，怎么用还是要看实际的使用场景了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天在&lt;strong&gt;承香墨影&lt;/strong&gt;公众号的后台，回复『&lt;strong&gt;成长&lt;/strong&gt;』。我会送你一些我整理的学习资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/10/9/8b7f5b0bec734584e62ce6f5e7c103aa&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点赞或者分享吧~&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 05:59:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/7660825.html</dc:identifier>
</item>
<item>
<title>spring cloud+dotnet core搭建微服务架构：配置中心（四） - 龙向辉</title>
<link>http://www.cnblogs.com/longxianghui/p/7660752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longxianghui/p/7660752.html</guid>
<description>&lt;p&gt;我们项目中有很多需要配置的地方，最常见的就是各种服务URL地址，这些地址针对不同的运行环境还不一样，不管和打包还是部署都麻烦，需要非常的小心。一般配置都是存储到配置文件里面，不管多小的配置变动，都需要对应用程序进行重启，对于分布式系统来说，这是非常不可取的。所以配置中心就在这种场景孕育出来，能够适配不同的环境，正在运行的程序不用重启直接生效。&lt;/p&gt;

&lt;p&gt;现在开始介绍我们今天的主角spring cloud config，我觉得它最大的优点就是可以和git做集成，使用起来非常方便。spring cloud config包含服务端和客户端，服务端提供配置的读取和配置仓库，客户端来获取配置。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也可以使用svn或者文件来存储配置文件，我们这里只讲Git的方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们模拟一个业务场景，有一个远程配置文件我们通过应用程序获取它。&lt;/p&gt;

&lt;p&gt;我们需要创建2个应用程序:配置服务服务端（Java），配置服务客户端（.Net Core）和一个Github仓库。&lt;br/&gt;使用IntelliJ IDEA创建一个spring boot项目，创建配置中心服务端，端口设置为5100&lt;/p&gt;
&lt;h5 id=&quot;pom.xml&quot;&gt;pom.xml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;configserverapplication.java&quot;&gt;ConfigServerApplication.java&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;application.properties&quot;&gt;application.properties&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;server.port=5100
spring.application.name=config-server
#git仓库地址
spring.cloud.config.server.git.uri=https://github.com/longxianghui/configs.git
#git用户名和密码
#spring.cloud.config.server.git.username=xxx
#spring.cloud.config.server.git.password=xxx
#git目录下的文件夹，多个用逗号分割
#spring.cloud.config.server.git.search-paths=xxx,xxx,xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Github创建一个仓库，并提交3个文件，文件内容如下（注意yml格式）&lt;/p&gt;
&lt;h5 id=&quot;demo-dev.yml&quot;&gt;demo-dev.yml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;name: mickey
age: 3
env: test&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;demo-test.yml&quot;&gt;demo-test.yml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;name: fiona
age: 28
env: test&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;demo-prod.yml&quot;&gt;demo-prod.yml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;name: leo
age: 30
env: prod&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;配置文件命名规则{application}-{profile}.yml&lt;br/&gt;支持yml和properties格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行配置中心服务端&lt;br/&gt;在浏览器输入http://localhost:5001/demo/dev&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_1.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;再访问http://localhost:5001/demo/test&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_2.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;再访问http://localhost:5001/demo/prod&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_3.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;通过上面3个URL我们发现配置中心通过REST的方式将配置信息返回。&lt;br/&gt;配置服务REST规则如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;/{application}/{profile}[/{label}]&lt;br/&gt;/{application}-{profile}.yml&lt;br/&gt;/{label}/{application}-{profile}.yml&lt;br/&gt;/{application}-{profile}.properties&lt;br/&gt;/{label}/{application}-{profile}.properties&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们再看看.NET程序如何读取配置信息呢？&lt;br/&gt;创建一个 .net core web api程序，端口5101&lt;/p&gt;
&lt;h5 id=&quot;nuget引用&quot;&gt;nuget引用&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Steeltoe.Extensions.Configuration.ConfigServer&quot; Version=&quot;1.1.0&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;appsettings.json&quot;&gt;appsettings.json&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;spring&quot;: {
    &quot;application&quot;: {
      &quot;name&quot;: &quot;demo&quot;//与配置文件的名称对应
    },
    &quot;cloud&quot;: {
      &quot;config&quot;: {
        &quot;uri&quot;: &quot;http://localhost:5100&quot;,
        &quot;env&quot;: &quot;dev&quot; //与环境名称对应
      }
    }
  },
  &quot;Logging&quot;: {
    &quot;IncludeScopes&quot;: false,
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;startup.cs&quot;&gt;Startup.cs&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public Startup(IHostingEnvironment env)
{
    var builder = new ConfigurationBuilder()
        .SetBasePath(env.ContentRootPath)
        .AddJsonFile(&quot;appsettings.json&quot;, optional: false, reloadOnChange: true)
        .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true)
        .AddEnvironmentVariables()
        .AddConfigServer(env);
    Configuration = builder.Build();
}
public void ConfigureServices(IServiceCollection services)
{
    services.AddConfigServer(Configuration);
    // Add framework services.
    services.AddMvc();
    services.Configure&amp;lt;Demo&amp;gt;(Configuration);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;demo.cs&quot;&gt;Demo.cs&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class Demo
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Env { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;valuescontroller.cs&quot;&gt;ValuesController.cs&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;/&quot;)]
public class ValuesController : Controller
{
    private readonly IConfigurationRoot _config;
    private readonly IOptionsSnapshot&amp;lt;Demo&amp;gt; _configDemo;

    public ValuesController(IConfigurationRoot config, IOptionsSnapshot&amp;lt;Demo&amp;gt; configDemo)
    {
        _config = config;
        _configDemo = configDemo;
    }
    [HttpGet]
    public Demo Get()
    {
        //两种方式获取配置文件的数据
        //var demo = new Demo
        //{
        //    Name = _config[&quot;name&quot;],
        //    Age = int.Parse(_config[&quot;age&quot;]),
        //    Env = _config[&quot;env&quot;]
        //};
        var demo = _configDemo.Value;
        return demo;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序 浏览器访问http://localhost:5101/,&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_5.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;更改配置文件appsettings.json，&lt;code&gt;&quot;env&quot;: &quot;test&quot;&lt;/code&gt;,重新启动程序，刷新页面&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_6.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;再更改配置文件appsettings.json，&lt;code&gt;&quot;env&quot;: &quot;prod&quot;&lt;/code&gt;,程序启动程序，刷新页面&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_7.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;这样通过修改本地的配置文件，就能获取远程上的各种配置了。&lt;br/&gt;我们再试试修改远程的配置文件，修改demo-prod.yml的配置name: leo1,提交到github。&lt;br/&gt;再访问http://localhost:5011/，发现配置并没有变化，这是因为配置服务并不知道git有更新，我们重启配置服务，再次访问，问题依旧，那么再重启客户端,发现我们得到了刚才更新的配置name= leo1，配置生效了。&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/longxianghui/1095508/o_8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过上面的例子，我们能够通过应用程序获取到配置信息，但是这有明显的问题，总不能一有配置更新就去重启配置服务和客户端吧？如何做到自动通知到客户端呢？留下这些问题，敬请期待下一章。&lt;/p&gt;

&lt;p&gt;所有代码均上传&lt;a href=&quot;https://github.com/longxianghui/microservice&quot;&gt;github&lt;/a&gt;。代码按照章节的顺序上传，例如第一章demo1，第二章demo2以此类推。&lt;br/&gt;求推荐，你们的支持是我写作最大的动力，我的QQ群：328438252,交流微服务。&lt;/p&gt;


&lt;p&gt;java部分&lt;/p&gt;
&lt;p&gt;.net部分&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 05:50:00 +0000</pubDate>
<dc:creator>龙向辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longxianghui/p/7660752.html</dc:identifier>
</item>
<item>
<title>#云栖大会# 移动安全专场——APP加固新方向（演讲速记） - 阿里聚安全</title>
<link>http://www.cnblogs.com/alisecurity/p/7660676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alisecurity/p/7660676.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45tj55tv2ak0.jpg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;433&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;主持人导语：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;近些年来，移动APP数量呈现爆炸式的增长，黑产也从原来的PC端转移到了移动端，伴随而来的逆向攻击手段也越来越高明。在解决加固产品容易被脱壳的方案中，代码混淆技术是对抗逆向攻击最有效的方式之一。但目前的移动端加固技术真能抵御黑客的攻击吗？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;本报告将分享阿里巴巴集团安全部应用加固能力养成记，重点介绍Android加固对于端上的业务风险控制是如何做到自动化部署和分析，更快捷的感知安全风险，以便快速做出响应，减少不必要的业务损失。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;有请阿里巴巴安全专家乱武。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45tj5bqtcv10.jpg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;433&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;嘉宾演讲正文：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;    非常感谢各位来宾来到这里，欢迎来到云栖大会移动安全论坛。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    今天讲的大的标题叫【APP加固新方向】，副标题主要讲阿里巴巴对Android加固的基础介绍，以及在开发这个产品过程中遇到的一些问题和一些复杂场景的适配过程。由于大会给我的时间是25分钟到30分钟，整个安卓加固方面涉及的技术点还蛮多的，为了让这次的分享有一个比较聚焦的点，所以这次的分享主要是讲Android java代码方面的保护，也就是说编译成Android安装文件之后，Dex文件方面的一些基础保护点。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;strong&gt;我这次分享的主要有三个部分，第一部分主要是要介绍一下&lt;/strong&gt;&lt;strong&gt;Android java&lt;/strong&gt;&lt;strong&gt;代码保护的技术。第二部分介绍一下应用加固在复杂业务场景下的挑战以及遇到的一些问题。第三部分说一下未来对于&lt;/strong&gt;&lt;strong&gt;Android java&lt;/strong&gt;&lt;strong&gt;代码保护的一些思路，跟大家分享一下，也许大家将来会碰到，或者有相应的一些启发。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第一部分主要讲Android java代码的技术保护，刚才主持人做了一个小的问卷调查，这里不少同学不是开发，我大概介绍一下这个上下文。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    本身安卓手机大家不陌生，苹果和安卓，目前是业内主流的两大智能操作系统。安卓本身的开发环境是用java语言开发的，它有一个特点。由于java语言生成的文件是在虚拟机里面执行的，必然要保留大量的语义，虚拟机能够认识可执行文件的时候保留了很多的语义。这就带来一个问题，既然编译生成这种Dex格式，保留了大量的语义，而这种格式谷歌对外完全公开的，恶意者通过反编译达到看到原来Java代码的这种目的。不管是阿里巴巴还是其他安全加固的友商，对安卓java代码的一个保护，也就是安卓上面Dex文件的保护，从加固服务产生到现在一直是重点。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;strong&gt;我简单介绍一下Android java代码以及Dex代码保护迭代介绍，业内主要总结了四代的保护方案。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第一代加固本身这种方案刚出来的时候，大概是2013到2014年之间，本身这个加固方案对于安卓本身的可执行文件，也就是Dex文件的保护，相当于是在打包的时候，就是生成整个安卓安装应用包的时候会对Dex进行加密。加密算法各种各样，可以用AES，也可以用其它的。在运行的时候通过一个自定义的类加载器进行解密，真正在运行的时候是完整的原来应用开发者编译出来的Dex文件。这种加固的特点一目了然，你拿到文件的时候，既不知道密钥，也不知道加密算法，看不出来文件的整个逻辑，这个时候一定程度上能够防住，通过一些开源的工具逆向分析这个Dex文件。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    缺点也很明显，因为它简单，因为运行时用一个自定义的类加载器在加载的时候解密，把这点拦掉，就把这个壳脱了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    那通过一段时间的发展以后，又出现了第二代的保护方案，就是类级别的Dex保护。我前面介绍了其实Dex文件来说，它的格式是公开的，公开就意味着这里面的某些类、某些函数保护的code在哪一个位置，其实所有人都能够知道。所以第二代的保护方案，相当于把Dex里面要保护的核心函数抽离出来生成另外一个文件，利用一个虚拟机类加载机制。本身虚拟机有一个特点，它必然会掉到这个类里面的一个方法，我们已经在打包的时候，将这些核心函数保留在已知的位置，通过这个函数调用我们的修复函数，然后将所有的业务逻辑进行修复。这样的一个方案，其实主要的原理还是利用虚拟机类加载机制的特点来达到一定保护的效果。当然这种保护有一个特点，我们如果简单来说，即便是我把它抽离了，最后运行的指令是谷歌支持的Dex标准指令，这点大家要注意。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第三代跟前面两代完全不同，因为谷歌的Dex指令是开源的，不管第一代第二代，内存中运行的都是谷歌的标准指令，所以从原理上一定有办法将这个指令完全逆向出来，然后把它反编译出来。但是第三代就有一个质的区别了。其实第一步和第二代是一样的，也是在编译打包的时候将Dex的核心函数抽离的，抽离后，翻译成一种自己定义的指令，用自己的一种编译指令进行翻译，把这个指令变一个种，变成其他的指令，这个时候运行的时候通过自己的解释器来解释执行，是自己定义的相关指令，这是跟第二代有质的区别的。我在内存中运行的指令，在某些保护的函数里面就一定不是谷歌的标准指令了，这点能够很有效的防止内存直接拷贝等破解方案。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第四代，也是行业目前公认的方案，就是java 2C的保护方案，这种更简单直接，它的原理很清晰，我们如果作为一个开发者，在开发java代码的时候，不管是原来传统的PC上的java虚拟机还是谷歌的虚拟机，java代码一定是可以翻译成用C代码来表示的。比如说写一个java代码的函数，从原理来说其实只要不嫌麻烦，我一定能够利用虚拟机漏出的接口写成C代码，这种保护方案直接从根源上解决这个问题。你认为核心要保护的函数，我们直接在编译打包的时候将这些函数翻译成C语言的代码，然后再用编译器编译成一个so的文件，也就是这个CPU支持的一个二进制code，这样达到了比较好的保护。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    这基本上就是我介绍目前安卓移动端对于java代码保护的四代技术。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    因为第一代和第二代技术相对比较简单，我介绍一下第三代和第四代技术整个的框架流程图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    自定义解释器的Dex保护方法第一部分应用打包和普通的是没有什么区别的，最终生成的也是安卓系统能够认识的一个可执行的文件。但是到了第二步和第三步的时候就有点区别了，第二步要经过一个加固的工具链，因为也是一个安卓的可知性的文件，首先要找到一个Dex文件，抽取核心函数指令，然后埋点一些hook接口，接下来打包还回apk文件，签名后应用发布。蓝色的部分表示是在运行时，黄色的部分是没有安装到用户手上，蓝色的部分应用已经发布了，然后在用户的手机上执行的一个逻辑。因为第二步埋点了hook接口，就进入一个自定义的一个解释器，根据传译的二进制的code翻译成原来Dex文件想保护的java那个code的逻辑，完成了第三代的保护效果。真正在解释的时候解释执行的就是这种变种的指令，然后达到正常执行业务逻辑的效果，这是第三代的一个自定义解释器Dex保护方案的介绍。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    说一下第四代java2C保护方法的介绍，前两步也跟第三代是一样的，就是开发者自己编译好的一个安卓可安装程序。不同的是，直接简单粗暴将需要保护的Dex核心函数直接翻译成C代码。比如一个编译好的Dex文件，直接把这个函数编译成C代码，可以自定义一个编译器翻译成一个C代码。C代码还是很成熟的，可以用各种各样的编译器，包括谷歌以及第三方编译器，这样完全去除了里面的核心指令，就变成看这个手机或者这个架构支持的Dex文件。这里面运行的时候又有不同，因为这个时候是需要把SO给打进APP里面，因为这些代码其实已经编成SO，要加到apk里面，所以核心函数一般加一个native标签，调到本身的SO里面，后面的执行顺理成章了，就是本地指令的执行保护函数，能够达到完全的正常执行的业务逻辑。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;strong&gt;第一部分大概介绍完了，包括目前比较流行的新的技术，就是第三代和第四代，但是其实我这边要说一下第三代和第四代的一些缺点。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    从刚才的介绍看起来比较美好，但是到了第三代的自定义解释器的时候，这个时候由于要hook系统的一些接口，普通的应用开发者要遇到很多碎片化的问题，对于加固要调用大量的系统私有api的安全服务来说，可能遇到的问题更显突兀，所以基本上在第三代的自定义解释器的保护方案，不是说不强，但可能遇到碎片化的东西比较多，到第四代其实反倒碎片化比较小，为什么大家比较推崇java2C的保护方案，是因为把java代码翻译成C代码再编译成SO，是完全符合很多虚拟机的开发规范的，这样的兼容性问题最小。当然这两个场景也有一个问题，它编译出来的函数可能会体积变大，可能执行效率变低，但是这些都是一些具体的细节，今天的时间有限，就不再详细赘述了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;strong&gt;第二部分介绍一下加固在复杂业务场景下的挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    安卓从几年前大家也不是特别看好的一个智能操作系统到现在成为全球第一大的智能操作系统来说，自身的操作系统是有一个不断的迭代，包括今年最新发布的android O，我们能看到它的进步。在安卓上面开发各种业务其实现在已经变得很复杂了，就以我们阿里巴巴公司比较旗舰类型的应用，比如手机淘宝和支付宝的应用，应用开发的流程和开发使用的黑科技的各种技术，已经是不亚于传统上面的一些PC上面一些比较复杂的客户端开发的程度了，所以加固在服务于这些应用的时候，也面临着一些复杂业务场景的挑战，我做一些简单的介绍，举两个例子。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    Hotpatch应用场景，安卓应用如果是说在你的应用发布以后，到了用户的手机端上以后如果发现一些bug，按照传统的方案有一种解决方式，用户升级再更新一个版本、重新安装一遍把这个问题解决了。但是在对于很多复杂的应用来说，比如说像手机淘宝或者天猫或者支付宝，它本身的一个安装包就已经70多兆了，比如里面有一个很小的bug，比如哪一个页面显示不对，让用户完全的升级一遍，重新下载包升级一下，用户体验不是很好，他们业务方开始研究一种技术，当我发现某一个地方某一段代码有问题了，这个时候我就只修改这一部分代码，而不需要用户安装整个发布包。我们这个原始应用有三个类，分为A/B/C，当我有问题的时候，比如我发现的问题是某一个代码有bug了，假设B类有bug，我只需要把他弄成一个Dex文件，把这个下发下来，热部署以后把原始APP里面的Dex文件修改一下，让它变成只有A和C这两个类，然后再通过一些类加载器里面寻找Dex的顺序，达到首先执行我的热部署后的这个文件，当需要调用B的时候再执行B这个类，达到修复这个原有程序业务逻辑bug的目的，或者我想更新达到更新的效果，当然这种方案目前在安卓上面运行的还是比较多的，包括阿里也有发布热补丁的。原来这种在苹果上面也会应用，但整个来说苹果不让用了，谷歌想在明年P的版本可能会全面限制这种技术方案，但是目前来说发布O的版本目前还没有这个限制。但是这种方案其实在加固来说，从加固的原理来说有一点冲突，热部署后的dex文件会出现一点问题，这是加固服务发展过程中发现的一个比较复杂场景的举例。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第二种场景大家更不陌生，由于业务发展越来越复杂，开发规模稍微大一点的应用，需要插件化的部署，比如手机淘宝集成了各种各样的服务，这时候要多个团队协作开发，这就无可避免要利用我们所谓的插件化的思想，然后分步开发。这时候传统的加固面临一个问题，最初我们主要是保护主Dex文件一些根目录下的Dex文件，插件会埋到lib下面很深的地方，导致加固刺出现盲点，作为一个通用化的一个加固方案很难做到将所有的Dex文件也保护，但是有些是比较核心的。刚才我提的这两个例子，不管是阿里巴巴还是很多友商，这个问题都得到很好的解决，具体的细节我就不赘述了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &lt;strong&gt;最后一部分介绍一下业内认为未来对于安卓java代码一种保护手段的思路&lt;/strong&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第四代java2C保护方案是用编译器编译成一个标准的SO文件，其实标准的SO文件开发者都很清楚，这种elf格式也是透明的，相当于本身这种格式也是完全有规范的，是透明的，也是可以逆向的。既然可以把DEX文件翻译成c代码，那么也可以用支持vmp虚壳的编译器在编译成内置于vmp虚壳的保护的so。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    风险设备的控制，我们做安全来说从原理来说，如果不是特别计较成本的话，其实只要在端上运行的东西，特别谷歌开源运行的，其实原理上是能够破解的，只不过你花费的时间长短和破解成本的高低，所以在手机淘宝和电商的超级应用，保护思路越来越从端上防护倾向于端和云联合的防护。在端上在打包的时候会埋入很多点，不管是安全adk还是本身加固工具链的方式，获取一个端上唯一的标识，我们称为一个设备指纹。像下单这种行为会加入这种设备指纹的请求，然后服务器通过这个指纹识别进行风险控制，比如我们认为是恶意者操控的设备，可以加入黑名单，不会让这个应用崩溃。比如你抢红包抢不到，你买东西买不成功，给用户一个反馈，这种其实保护效果是相当好的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://epo.alicdn.com/image/45tj9331d9n0.png&quot; alt=&quot;&quot; width=&quot;850&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  我的分享结束了，最后感谢大家的聆听，谢谢。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;——————————————&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;通过对Android应用进行重新编译、加壳保护、修改指令调用顺序等手段来增强应用反破解能力。我们的加固功能注重加固强度与兼容性并重，避免一般加固功能盲目追求加固强度导致加固后完全不可用。&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Fri, 13 Oct 2017 05:17:00 +0000</pubDate>
<dc:creator>阿里聚安全</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alisecurity/p/7660676.html</dc:identifier>
</item>
<item>
<title>C#设计模式之七适配器模式（Adapter）【结构型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/7660554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/7660554.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   从今天开始我们开始讲【结构型】设计模式，【结构型】设计模式有如下几种：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。【创建型】的设计模式解决的是对象创建的问题，那【结构型】设计模式解决的是类和对象的组合关系的问题。今天我们就开始讲【结构型】设计模式里面的第一个设计模式，适配器模式。说起这个模式其实很简单，在现实生活中也有很多实例，比如：我们手机的充电器，充电器的接头，有的是把两相电转换为三相电的，当然也有把三相电转换成两相电的。我们经常使用笔记本电脑，笔记本电脑的工作电压和我们家里照明电压是不一致的，当然也就需要充电器把照明电压转换成笔记本的工作电压，只有这样笔记本电脑才可以正常工作。太多了，就不一一列举了。我们只要记住一点，适配就是转换，把不能在一起工作的两样东西通过转换，让他们可以在一起工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、适配器模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结果图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   适配器有两种结构&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;-对象适配器（&lt;span&gt;更常用&lt;/span&gt;）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201710/1048776-20171013121624793-1439407152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;　　   对象适配器使用的是对象组合的方案，它的Adapter核Adaptee的关系是组合关系。&lt;/p&gt;&lt;p&gt;　　   OO中优先使用组合模式，组合模式不适用再考虑继承。因为组合模式更加松耦合，而继承是紧耦合的，父类的任何改动都要导致子类的改动。&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;-类适配器&lt;/strong&gt;&lt;br/&gt;       &lt;br/&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201710/1048776-20171013121644605-1330943490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  . 目标角色（Target）：定义Client使用的与特定领域相关的接口。&lt;br/&gt;   &lt;br/&gt;  . 客户角色（Client）：与符合Target接口的对象协同。&lt;br/&gt; &lt;br/&gt;  . 被适配角色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。&lt;br/&gt; &lt;br/&gt;  . 适配器角色（Adapte) ：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5 适配器模式的具体实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   由于适配器模式有两种实现结构，今天我们针对每种都实现了自己的方式。&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;1、对象的是适配器模式实现&lt;/strong&gt;&lt;br/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 对象的适配器模式
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;家里只有两个孔的插座，也懒得买插线板了，还要花钱，但是我的手机是一个有3个小柱子的插头，明显直接搞不定，那就适配吧
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;好了，现在就可以给手机充电了&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             TwoHole homeTwoHole = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreeToTwoAdapter();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            homeTwoHole.Request();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            Console.ReadLine();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 我家只有2个孔的插座，也就是适配器模式中的目标(Target)角色，这里可以写成抽象类或者接口
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TwoHoleTarget
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端需要的方法&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Request()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以把一般实现放在这里&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;  
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 手机充电器是有3个柱子的插头，源角色——需要适配的类（Adaptee）
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreeHoleAdaptee
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SpecificRequest()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是3个孔的插头&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;  
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 适配器类，TwoHole这个对象写成接口或者抽象类更好，面向接口编程嘛
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreeToTwoAdapter : TwoHoleTarget
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用两个孔插头的实例,从而将客户端与TwoHole联系起来&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; ThreeHoleAdaptee threeHoleAdaptee = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreeHoleAdaptee();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以继续增加适配的对象。。&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;  
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现2个孔插头接口方法
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Request()
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以做具体的转换工作&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            threeHoleAdaptee.SpecificRequest();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以做具体的转换工作&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;   &lt;strong&gt;2、类的适配器模式实现&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 设计模式之适配器模式
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这里手机充电器为例，我们的家的插座是两相电的，但是手机的插座接头是三相电的
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;好了，现在可以充电了&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             ITwoHoleTarget change = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreeToTwoAdapter();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            change.Request();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            Console.ReadLine();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 我家只有2个孔的插座，也就是适配器模式中的目标角色（Target），这里只能是接口，也是类适配器的限制
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ITwoHoleTarget
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Request();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;  
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 3个孔的插头，源角色——需要适配的类（Adaptee）
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreeHoleAdaptee
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SpecificRequest()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是三个孔的插头&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;  
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 适配器类，接口要放在类的后面，在此无法适配更多的对象，这是类适配器的不足
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreeToTwoAdapter:ThreeHoleAdaptee,ITwoHoleTarget
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现2个孔插头接口方法
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Request()
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用3个孔插头方法&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.SpecificRequest();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt; 代码都很简答，谁都可以看得懂，也有详细的备注&lt;strong&gt;。&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;三、适配器模式的实现要点：&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;      Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。&lt;/p&gt;&lt;p&gt;　　GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。类适配器采用“多继承”的实现方式，在C#语言中，如果被适配角色是类，Target的实现只能是接口，因为C#语言只支持接口的多继承的特性。在C#语言中类适配器也很难支持适配多个对象的情况，同时也会带来了不良的高耦合和违反类的职责单一的原则，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神，对适配的对象也没限制，可以一个，也可以多个，但是，使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。&lt;/p&gt;&lt;p&gt;　　Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便地适配。&lt;/p&gt;&lt;p&gt;      适配器模式用来解决现有对象与客户端期待接口不一致的问题,下面详细总结下适配器两种形式的优缺点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 中适配器模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    说道适配器模式在Net中的实现就很多了，比如：System.IO里面的很多类都有适配器的影子，当我们操作文件的时候，其实里面调用了COM的接口实现。以下两点也是适配器使用的案例：&lt;/p&gt;&lt;p&gt;      1.在.NET中复用COM对象：&lt;/p&gt;&lt;p&gt;　　  COM对象不符合.NET对象的接口，使用tlbimp.exe来创建一个Runtime Callable Wrapper（RCW）以使其符合.NET对象的接口，COM Interop就好像是COM和.NET之间的一座桥梁。&lt;/p&gt;&lt;p&gt;　　2..NET数据访问类（Adapter变体）：&lt;/p&gt;&lt;p&gt;　　 各种数据库并没有提供DataSet接口，使用DbDataAdapter可以将任何个数据库访问/存取适配到一个DataSet对象上，DbDataAdapter在数据库和DataSet之间做了很好的适配。当然还有SqlDataAdapter类型了，针对微软SqlServer类型的数据库在和DataSet之间进行适配。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     今天的文章就写到这里了，在结束今天写作之前，有一句话还是要说的，虽然以前说过。每种设计模式都有自己的适用场景，它是为了解决一类问题，没有所谓的缺点，没有一种设计模式可以解决所有情况的。我们使用设计模式的态度是通过不断地重构来使用模式，不要一上来就使用设计模式，为了模式而模式。如果软件没有需求的变化，我们不使用模式都没有问题。遇到问题，我们就按着常规来写，有了需求变化，然后我们去抽象，了解使用的场景，然后在选择合适的设计模式。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Oct 2017 04:21:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/7660554.html</dc:identifier>
</item>
</channel>
</rss>