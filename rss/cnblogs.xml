<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SQL Server 数据库调整表中列的顺序操作 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9941273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9941273.html</guid>
<description>&lt;p&gt;SQL Server 数据库中表一旦创建，我们不建议擅自调整列的顺序，特别是对应的应用系统已经上线，因为部分开发人员，不一定在代码中指明了列名。表是否可以调整列的顺序，其实可以自主设置，我们建议在安装后设置为禁止。&lt;/p&gt;
&lt;p&gt;那么，如果确实需要调整某一列的顺序，我们是怎么操作的呢？ 下面，我们就要演示一下怎么取消这种限制。当然，通过取消限制的演示，相信大家也知道了怎么添加限制了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;需求及问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1）测试表 Test001&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111032725848-349697211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）更新前&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111032735976-670640222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）例如，需求为调整 SN5 和SN4的序列&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111032752901-495007089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击保存时报错&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111032805363-742873878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改数据库表结构时提示【不允许保存更改。您所做的更改要求删除并重新创建以下表。您对无法重新创建的标进行了更改或者启用了“阻止保存要求重新创建表的更改&quot;选项。】&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;处理方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Step 1  在SSMS客户端，点击 菜单【工具】然后选中【选项】&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111033610583-388033900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 2 打开了选项对话框，我们展开 设计器 【英文版 Designers】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111033747148-983737790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 3 取消【阻止保存要求重新创建表的更改】复选框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111034002841-250987562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step 4 再次执行调整列顺序操作，修改 OK &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181111034055170-1352507195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Nov 2018 19:43:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>SQL Server 数据库中表一旦创建，我们不建议擅自调整列的顺序，特别是对应的应用系统已经上线，因为部分开发人员，不一定在代码中指明了列名。表是否可以调整列的顺序，其实可以自主设置，我们建议在安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9941273.html</dc:identifier>
</item>
<item>
<title>设计模式——模板模式（Template Pattern） - 才丶</title>
<link>http://www.cnblogs.com/Caucasian/p/9933036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Caucasian/p/9933036.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在读Spring源码的时候，发现Spring代码中运用了大量的模板模式，比如根据文件系统目录加载配置文件（FileSystemXmlApplicationContext），类路径加载配置文件(ClassPathXmlApplicationContext)，以及根据项目上下文目录(XmlWebApplicationContext)加载配置文件。这个在加载的过程中就使用了模板设计模式，所以特意去学习了一下模板设计模式，从而更好的理解源码。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的翻译就是：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;span&gt;小张的团队最近接受一个需求，实现实现一家咖啡店的冲泡咖啡和茶的冲泡自动化。之前这家咖啡店都是由咖啡师傅手动进行调制咖啡和茶。现在咖啡店需要引入自动化的点单和调制饮料的系统，小张负责实现调制饮料的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　咖啡师傅手工冲泡咖啡和茶的流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　冲泡咖啡：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       把水煮沸&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              用沸水冲泡咖啡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              把咖啡倒入杯子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              加糖和牛奶&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　冲泡茶：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            把水煮沸&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            用沸水冲泡茶叶&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            把茶倒入杯子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            加柠檬&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;使用模板模式实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;我们首先看一个类图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/853208/201811/853208-20181109074511117-466959438.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;　　代码实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xuelongjiang.designpartten.templatemethod;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 * 模板方法
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;abstract&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaffeineBeverage {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;算法。 抽象类的算法是final 的不允许被子类修改&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt;   prepareRecipe(){

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;算法的具体步骤&lt;/span&gt;
         boilWater(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;烧水&lt;/span&gt;
         brew();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冲泡&lt;/span&gt;
         pourInCup();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把饮料倒入杯子&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(hook()){
             addCondiments();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加调料&lt;/span&gt;
&lt;span&gt;         }

    }


   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;abstract&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew();

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;   &lt;span&gt;abstract&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments();


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; boilWater(){

        System.out.println(&lt;/span&gt;&quot;烧水&quot;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pourInCup(){
        System.out.println(&lt;/span&gt;&quot;把饮料倒入杯子&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *  钩子，具体实现可以对算法步骤做一些控制
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hook(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到我们在冲泡咖啡/茶的抽象类中有一个hook方法，这个方法就是钩子方法。默认返回true，如果冲泡咖啡默认是加调料的那么子类就不用重写hook方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;咖啡类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xuelongjiang.designpartten.templatemethod;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *咖啡类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Coffee &lt;span&gt;extends&lt;/span&gt;&lt;span&gt;  CaffeineBeverage {


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew() {
        System.out.println(&lt;/span&gt;&quot;用沸水冲泡咖啡粉&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments() {
        System.out.println(&lt;/span&gt;&quot;加糖和牛奶&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hook() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.hook();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;茶类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xuelongjiang.designpartten.templatemethod;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 茶类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tea &lt;span&gt;extends&lt;/span&gt;&lt;span&gt;  CaffeineBeverage {


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; brew() {
        System.out.println(&lt;/span&gt;&quot;用沸水侵泡茶叶&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCondiments() {
        System.out.println(&lt;/span&gt;&quot;加柠檬&quot;&lt;span&gt;);
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hook() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.hook();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; xuelongjiang.designpartten.templatemethod;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TemplateMethodTest {


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        CaffeineBeverage caffeineBeverage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tea();
        caffeineBeverage.prepareRecipe();

        System.out.println(&lt;/span&gt;&quot;-------------------&quot;&lt;span&gt;);

        caffeineBeverage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Coffee();
        caffeineBeverage.prepareRecipe();


    }
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/span&gt;　　　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。（即高层组件对低层组件的方式是：别调用我们，我们会调用你们）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　模版方法定义了算法的步骤，把这些步骤的实现延迟到了子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　模版方法模式为我们提供了一种代码复用的重要技巧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;模版方法的抽象类可以定义具体方法、抽象方法和钩子。&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;抽象方法由子类实现。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　为了防止子类改变模版方法中的算法，可以将模版方法声明为final&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;---------------------&lt;br/&gt;代码部分参考：https://blog.csdn.net/u013565163/article/details/79285617&lt;/p&gt;

</description>
<pubDate>Sat, 10 Nov 2018 18:36:00 +0000</pubDate>
<dc:creator>才丶</dc:creator>
<og:description>在读Spring源码的时候，发现Spring代码中运用了大量的模板模式，比如根据文件系统目录加载配置文件（FileSystemXmlApplicationContext），类路径加载配置文件(Clas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Caucasian/p/9933036.html</dc:identifier>
</item>
<item>
<title>Kali Linux Vmware虚拟机（新手）安装 - GhostGuest</title>
<link>http://www.cnblogs.com/GhostGuest/p/9941188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GhostGuest/p/9941188.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备工作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.安装VMware workstation 软件&lt;/p&gt;
&lt;p&gt;2.下载好kali linux 的ios系统文件&lt;/p&gt;
&lt;p&gt;3.打开电脑的虚拟化支持（&lt;span&gt;Intel VT-x/EPT或AMD-V/RVI(V)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;虚拟机设置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.在VMware虚拟机中新建虚拟机，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181110235142434-47798333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.点击浏览，选择Kali Linux的安装文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181110235227661-1565192175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在客户机操作系统中选择Linux，在版本中选择Debian系统（可以选择最新的版本以及相应系统位数，此处可以选择64位）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181110235330716-884747416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.重命名虚拟机名称，点击浏览选择虚拟机保存的位置（此项可以在虚拟机任务栏编辑中的首选项里面设置默认保存位置，以方便下次建立虚拟机的时候直接默认，最好可以分一个区专用保存虚拟机文件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181110235643868-261321200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.设置最大磁盘空间（此处的磁盘不会在系统中全部显示，是用多少显示多少，只是限制最大使用量，一定小于分区最大磁盘容量），&lt;/p&gt;
&lt;p&gt;并将磁盘储存为单个文件（提高磁盘的使用效率），下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111000019459-2088389451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.因为Kali Linux中很少或者不使用打印机，最好移除，在此页可以设置内存大小，CPU等其他信息，建议在此页勾选CPU中的虚拟化Intel VT-x/EPT或AMD-V/RVI(V)选项，速度可以得到一定的提升，设置好后点击关闭&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111000639894-2097019624.png&quot; alt=&quot;&quot; width=&quot;649&quot; height=&quot;653&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.设置完后可以看到此页，里面可以查看虚拟机的一些基本信息，点击开启虚拟机，开始系统的安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111001142935-680872942.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统安装：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，开启虚拟机后可以看到如下页面&lt;/p&gt;
&lt;p&gt;选择图形化界面安装，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111001407340-621305600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在此处选择中文简体（英文好的可以选择默认英文），然后点击continue（继续）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111001456995-2110683295.png&quot; alt=&quot;&quot; width=&quot;653&quot; height=&quot;540&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示翻译未完全时选择是，然后继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111001624345-205214776.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.区域选择中国（不建议选择台湾和香港，因为歪果仁搞不明白它俩就是属于中国的，此页面差评设计者）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111001726615-1700264926.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4设置键盘，默认就可以了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002001600-1699587709.png&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.主机名可以自己设置喜欢的名字，在此我选择默认了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002030128-1850273379.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有需要设置域名的朋友可以在此页面设置，没有需要的就留空，新手留空就OK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002120977-1830476473.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;504&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.设置root用户密码（&lt;span&gt;一定要设置，不设置默认不启用root需要另外设置用户名及密码&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002230096-759297168.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.对磁盘进行分区，此处可以使用向导，如图&lt;span&gt;选择第一项直接下一步&lt;/span&gt;（方法一），也可以手动分区（方法二）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002336197-231989813.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;516&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(&lt;span&gt;方法二&lt;/span&gt;)点击手动分区后，选择虚拟磁盘并新建分区表，然后创建根分区和交换分区，根分区如下图，交换空间创建时，在弹出类似下图的界面中直接点击用于选择交换空间其他默认即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111002505036-1402998564.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分区设置好后可以看到如下图，选择结束分区设定并写入磁盘项，然后点击继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111003138300-1764001748.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择是，写入磁盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111003305678-895835701.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.网络镜像可以选择是也可以不选择（ios光盘镜像文件是从官网下载的完整包可以选择否，无影响）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111003337576-1709252492.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;501&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理选项可以留空（新手一般用不到）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111003532775-253399002.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.安装启动引导软件，这里默认发grub，&lt;span&gt;一定要选择是&lt;/span&gt;，否者无法引导进入系统，易导致前面的所以安装失效，一定重视&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111004036505-405827859.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;p&gt;弹出此页后选择你的设备，如图选择&lt;span&gt;/dev/sda&lt;/span&gt;设备（磁盘）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111004233374-838530482.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10.完成以上所有的步骤后会弹出此页以结束安装，点击继续结束安装并重启，然后进入系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111004333599-1283148610.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;527&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，系统安装全部结束&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;重启后：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.显示GNU GRUB界面默认第一项回车进入系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111004700057-379116756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.弹出登录界面后输入用户名（root），密码进入系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111004808159-1975481924.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.安装VMware tools(安装好的系统不会全屏显示，也不能与物理机之间相互拖动文件，所以要安装VMware tools)&lt;/p&gt;
&lt;p&gt;点击虚拟机，安装VMware tools选项将安装镜像光盘挂载到系统，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111011743264-1333019413.png&quot; alt=&quot;&quot; width=&quot;699&quot; height=&quot;569&quot;/&gt;&lt;/p&gt;
&lt;p&gt;挂载后如图，打开光盘镜像文件，将VMware tools安装包拖动到桌面（方便操作），接着就可以取消VMware tools的挂载，取消挂载和挂载一样的步骤，参考上图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111011857323-2000178552.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;558&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4，打开命令行，切换到桌面，然后用tar 命令解压VMware tools安装包&lt;/p&gt;
&lt;p&gt;具体步骤如图，&lt;span&gt;”cd 桌面“命令时没有中文输入法只能用ctrl+shift+c复制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;回车开始解压，可以看到桌面会有一个文件夹出现&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111012328222-603048839.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.解压完毕后，进入解压后的文件夹，然后用&quot;&lt;span&gt;./vmware-install.pl&lt;/span&gt;&quot;（&lt;span&gt;有小点&lt;/span&gt;）执行安装脚本进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111012948513-611720885.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.安装过程所有设置保持默认，不建议修改，除非你知道具体作用和功能&lt;/p&gt;
&lt;p&gt;如果出现如下界面说明安装成功了，可以重启进入系统了，你会发现系统自动全屏且可以与物理机相互拖放文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1484127/201811/1484127-20181111013245789-1909583874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Nov 2018 17:38:00 +0000</pubDate>
<dc:creator>GhostGuest</dc:creator>
<og:description>准备工作： 1.安装VMware workstation 软件 2.下载好kali linux 的ios系统文件 3.打开电脑的虚拟化支持（Intel VT-x/EPT或AMD-V/RVI(V)） 虚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GhostGuest/p/9941188.html</dc:identifier>
</item>
<item>
<title>Redis基本使用及百亿数据量中的使用技巧分享 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9941208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9941208.html</guid>
<description>&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9941208.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9941208.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;作者：大石头&lt;/li&gt;
&lt;li&gt;时间：2018-11-10 晚上20：00&lt;/li&gt;
&lt;li&gt;地点：钉钉群（组织代码BKMV7685）QQ群：1600800&lt;/li&gt;
&lt;li&gt;内容：Redis基本使用及百亿数据量中的使用技巧分享&lt;/li&gt;
&lt;li&gt;记录人：依乐祝&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;热场准备&quot;&gt;热场准备&lt;/h2&gt;
&lt;p&gt;熟悉的开场白，大家晚上好啊，今天给大家分享的是Redis在大数据中的使用，可能真正讲的是一些redis的使用技巧，Redis基本的一些东西。&lt;/p&gt;
&lt;p&gt;首先给大家个地址，源码以及实例都在里面，当然今天的分享也是按照里面的实例来进行的，大家可以先进行下载。&lt;br/&gt;&lt;a href=&quot;http://git.newlifex.com/NewLife/NewLife.Redis&quot; class=&quot;uri&quot;&gt;http://git.newlifex.com/NewLife/NewLife.Redis&lt;/a&gt;&lt;br/&gt;当然这里也附上Redis的下载地址：&lt;br/&gt;windows：&lt;a href=&quot;https://github.com/MicrosoftArchive/redis/releases&quot; class=&quot;uri&quot;&gt;https://github.com/MicrosoftArchive/redis/releases&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://x.newlifex.com/Redis-x64-3.2.100.msi&quot; class=&quot;uri&quot;&gt;http://x.newlifex.com/Redis-x64-3.2.100.msi&lt;/a&gt;&lt;br/&gt;Linux：&lt;a href=&quot;https://redis.io/download&quot; class=&quot;uri&quot;&gt;https://redis.io/download&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;h3 id=&quot;redis封装架构讲解&quot;&gt;Redis封装架构讲解&lt;/h3&gt;
&lt;p&gt;实际上NewLife.Redis是一个完整的Redis协议的功能的实现，但是redis的核心功能并没有在这里面，Redis的核心功能的实现是在NewLife.Core里面。这里可以打开看一下，NewLife.Core里面有一个NewLife.Caching的命名空间，里面有一个Redis类里面实现了Redis的基本功能，另一个类是RedisClient是Redis的客户端。Redis的核心功能就是有这两个类实现。RedisClient代表着Redis客户端对服务器的一个连接。Redis真正使用的时候有一个Redis连接池，里面存放着很多个RedisClient对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181111012541779-309393432.png&quot; alt=&quot;1541862210472&quot;/&gt;&lt;br/&gt;所以我们Redis的封装有两层，一层是NewLife.Core里面的Redis以及RedisClient。另一层就是NewLife.Redis。这里面的FullRedis是对Redis的实现了Redis的所有的高级功能。这里你也可以认为NewLife.Redis是Redis的一个扩展。&lt;/p&gt;
&lt;h3 id=&quot;test实例讲解redis的基本使用&quot;&gt;Test实例讲解Redis的基本使用&lt;/h3&gt;
&lt;h4 id=&quot;实例&quot;&gt;实例&lt;/h4&gt;
&lt;p&gt;打开Program.cs看下代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181111012541042-1180727422.png&quot; alt=&quot;1541862821768&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里&lt;code&gt;XTrace.UseConsole();&lt;/code&gt;是向控制台输出日志，方便调试使用查看结果。&lt;/p&gt;
&lt;p&gt;接下来看第一个例子Test1。具体的我都在代码中进行了注释，大家可以看下&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static void Test1()
        {
            var ic = Redis.Create(&quot;127.0.0.1:6379&quot;, 3);//创建Redis实例，得到FullRedis对象
            //var ic = new FullRedis();//另一种实例化的方式
            //ic.Server = &quot;127.0.0.1:6379&quot;;
            //ic.Db = 3;//Redis中数据库
            ic.Log = XTrace.Log;//显示日志，进行Redis操作把日志输出，生产环境不用输出日志

            // 简单操作
            Console.WriteLine(&quot;共有缓存对象 {0} 个&quot;, ic.Count);//缓存对象数量

            ic.Set(&quot;name&quot;, &quot;大石头&quot;);//Set K-V结构，Set第二个参数可以是任何类型
            Console.WriteLine(ic.Get&amp;lt;String&amp;gt;(&quot;name&quot;));//Get泛型，指定获取的类型

            ic.Set(&quot;time&quot;, DateTime.Now, 1);//过期时间秒
            Console.WriteLine(ic.Get&amp;lt;DateTime&amp;gt;(&quot;time&quot;).ToFullString());
            Thread.Sleep(1100);
            Console.WriteLine(ic.Get&amp;lt;DateTime&amp;gt;(&quot;time&quot;).ToFullString());

            // 列表
            var list = ic.GetList&amp;lt;DateTime&amp;gt;(&quot;list&quot;);
            list.Add(DateTime.Now);
            list.Add(DateTime.Now.Date);
            list.RemoveAt(1);
            Console.WriteLine(list[list.Count - 1].ToFullString());

            // 字典
            var dic = ic.GetDictionary&amp;lt;DateTime&amp;gt;(&quot;dic&quot;);
            dic.Add(&quot;xxx&quot;, DateTime.Now);
            Console.WriteLine(dic[&quot;xxx&quot;].ToFullString());

            // 队列
            var mq = ic.GetQueue&amp;lt;String&amp;gt;(&quot;queue&quot;);
            mq.Add(new[] { &quot;abc&quot;, &quot;g&quot;, &quot;e&quot;, &quot;m&quot; });
            var arr = mq.Take(3);
            Console.WriteLine(arr.Join(&quot;,&quot;));

            // 集合
            var set = ic.GetSet&amp;lt;String&amp;gt;(&quot;181110_1234&quot;);
            set.Add(&quot;xx1&quot;);
            set.Add(&quot;xx2&quot;);
            set.Add(&quot;xx3&quot;);
            Console.WriteLine(set.Count);
            Console.WriteLine(set.Contains(&quot;xx2&quot;));

            Console.WriteLine(&quot;共有缓存对象 {0} 个&quot;, ic.Count);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Set的时候如果是字符串或者字符数据的话Redis会直接保存起来（字符串内部机制也是保存二进制），如果是其他类型会默认进行json序列化然后再保存起来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Get的时候如果是字符串或者字符数据会直接获取，如果是其他类型会进行json反序列化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Set第三个参数过期时间单位是秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;vs调试小技巧，按F5或者直接工具栏“启动”会编译整个解决方案会很慢（VS默认），可以选中项目然后右键菜单选择调试-&amp;gt;启动新实例。会只编译将会用到的项目，这样对调试来说会快很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;大家运行调试后可以看到控制台输出的内容：向右的箭头=》是&lt;code&gt;ic.Log=XTrace.Log&lt;/code&gt;输出的日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181111012540321-1623823108.png&quot; alt=&quot;1541865736212&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;字典的使用：对象的话需要把json全部取出来然后转换成对象，而字典的话就可以直接取某个字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;队列是List结构实现的，使用场景可以上游数据太多，下游处理不过来的时候，那么就可以使用这个队列。上游的数据发到队列，然后下游漫漫的消费。另一个应用，夸语言的协同工作，比方说其他语言实现的程序往队列里面塞数据，然后另一种语言来进行消费处理。哈，这种方式类似mq的概念，虽然有点low，但是也很好用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;集合，用的比较多的是用在一个需要精确判断的去重功能。像我们每天有三千万订单，这三千万订单可以有重复，这时候我想统计下一共有订单，这时候直接数据库group by是不大可能的，因为数据库中分了十几张表，这里分享个实战经验：比方说揽收，商家发货了，网点要把件收回来，但是收回来之前网点不知道自己有多少货啊，这时候我们做了一个功能，也就是订单会发送到我们公司来，我们会建一个time_site的key的集合，而且集合本身有去重的功能，而且我们可以很方便的通过set.Count功能来统计数量，当件被揽收以后，我们后台把这个件从集合中Remove掉.然后这个Set中存在的就是网点还没有揽收的件，这时候通过Count就会知道这个网点今天还有多少件没有揽收。实际使用中这个数量比较大，因为有几万个网点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Redis中布隆过滤器，去重的，面试的时候问的比较多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小经验分享：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库中不合法的时间处理：判断时间中的年份，是否大于2000年。如果小于2000就认为不合法。习惯大于小于号不习惯用等于号，这样可以处理很多意外的数据&lt;/li&gt;
&lt;li&gt;Set的时候最好指定过期时间防止有些需要删除的数据，我们忘记删了&lt;/li&gt;
&lt;li&gt;Redis异步尽量不用，因为Redis延迟本身很小，大概在100us-200us，再一个就是Redis本身是单线程的，异步任务切换的耗时比网络耗时还要大。&lt;/li&gt;
&lt;li&gt;List用法：物联网中数据上传，量比较大时，我们可以把这些数据先放在Redis的List中，比如说一秒钟1万条，然后再批量取出来然后批量插入数据库中。这时候要设置好key,可以前缀+时间，对于已经处理的List可以进行remove移除。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;压力测试&quot;&gt;压力测试&lt;/h4&gt;
&lt;p&gt;接下来看第四个例子，我们直接做压力测试，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; static void Main(String[] args)
        {
            XTrace.UseConsole();

            // 激活FullRedis，否则Redis.Create会得到默认的Redis对象
            FullRedis.Register();

            Test4();

            Console.ReadKey();
        }
 static void Test4()
        {
            var ic = Redis.Create(&quot;127.0.0.1:6379&quot;, 5);
            //var ic = new MemoryCache();
            ic.Bench();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181111012539762-1957609957.png&quot; alt=&quot;1541867419541&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试就是进行get,set remove,累加等的操作。大家可以看到在我本机上轻轻松松的到了六十万，多线程到时候甚至到了一百多万。为什么会达到这么高的ops呢，下面给大家说一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bench 会分根据线程数分多组进行添删改压力测试。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;rand 参数，是否随机产生key/value。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;batch 批大小，分批执行读写操作，借助GetAll/SetAll进行优化。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;redis中nb的函数来提升性能&quot;&gt;Redis中NB的函数来提升性能&lt;/h4&gt;
&lt;p&gt;上面的操作如果大家都掌握的基本算Redis入门了，接下来进行进阶。会了基本比别人更胜一筹了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GetAll()与SetAll()&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GetAll:比方说我要取是个key，这个时候可以用getall。这时候redis就执行了一次命令。比方说我要取10个key那么用get的话要取10次，如果用getall的话要用1次。一次getall时间大概是get的一点几倍，但是10次get的话就是10倍的时间，这个账你应该会算吧。强烈推荐大家用getall。&lt;/p&gt;
&lt;p&gt;setall 跟getall相似。批量设置K-V.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;setall与getall性能很恐怖，官方公布的ops也就10万左右，为什么我们的测试轻轻松松到五十万甚至上百万，因为我们就用了setall,getall。&lt;/p&gt;
&lt;p&gt;如果get,set两次以上，建议用getall，setall&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Redis管道Pipeline&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如执行10次命令会打包成一个包集体发过去执行，这里实现的方式是StartPipeline()开始，StopPipeline()结束中间的代码就会以管道的形式执行。这里推荐使用我们的更强的武器，AutoPipeline自动管道属性。管道操作到一定数量时，自动提交，默认0.使用了不需要使用AutoPipeline，就不需要StartPipeline，StopPipeline指定开始结束了！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Add与Replace&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Add:Redis中没有这个Key就添加，有了就不要添加，返回false&lt;/li&gt;
&lt;li&gt;Replace:有则替换，还会返回原来的值，没有则不进行操作&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Add跟Replace就是实现Redis分布式锁的关键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;redis使用技巧经验分享&quot;&gt;Redis使用技巧，经验分享&lt;/h3&gt;
&lt;p&gt;在项目的Readme中，这里摘录下：&lt;/p&gt;
&lt;h4 id=&quot;特性&quot;&gt;特性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在ZTO大数据实时计算广泛应用，200多个Redis实例稳定工作一年多，每天处理近1亿包裹数据，日均调用量80亿次&lt;/li&gt;
&lt;li&gt;低延迟，Get/Set操作平均耗时200~600us（含往返网络通信）&lt;/li&gt;
&lt;li&gt;大吞吐，自带连接池，最大支持1000并发&lt;/li&gt;
&lt;li&gt;高性能，支持二进制序列化（默认用的json,json很低效，转成二进制性能会提升很多）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;redis经验分享&quot;&gt;Redis经验分享&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;在Linux上多实例部署，实例个数等于处理器个数，各实例最大内存直接为本机物理内存，避免单个实例内存撑爆（比方说8核心处理器，那么就部署8个实例）&lt;/li&gt;
&lt;li&gt;把海量数据（10亿+）根据key哈希（Crc16/Crc32）存放在多个实例上，读写性能成倍增长&lt;/li&gt;
&lt;li&gt;采用二进制序列化，而非常见的Json序列化&lt;/li&gt;
&lt;li&gt;合理设计每一对Key的Value大小，包括但不限于使用批量获取，原则是让每次网络包控制在1.4k字节附近，减少通信次数（实际经验几十k，几百k也是没问题的）&lt;/li&gt;
&lt;li&gt;Redis客户端的Get/Set操作平均耗时200~600us（含往返网络通信），以此为参考评估网络环境和Redis客户端组件（达不到就看一下网络，序列化方式等等）&lt;/li&gt;
&lt;li&gt;使用管道Pipeline合并一批命令&lt;/li&gt;
&lt;li&gt;Redis的主要性能瓶颈是序列化、网络带宽和内存大小，滥用时处理器也会达到瓶颈&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;其它可查优化技巧&lt;br/&gt;以上经验，源自于300多个实例4T以上空间一年多稳定工作的经验，并按照重要程度排了先后顺序，可根据场景需要酌情采用！&lt;/p&gt;
&lt;h3 id=&quot;缓存redis的兄弟姐妹&quot;&gt;缓存Redis的兄弟姐妹&lt;/h3&gt;
&lt;p&gt;Redis实现ICache接口，它的孪生兄弟MemoryCache，内存缓存，千万级吞吐率。&lt;br/&gt;各应用强烈建议使用ICache接口编码设计，小数据时使用MemoryCache实现；&lt;br/&gt;数据增大（10万）以后，改用Redis实现，不需要修改业务代码。&lt;/p&gt;
&lt;h3 id=&quot;提问环节聊聊大数据中redis使用的经验问题&quot;&gt;提问环节聊聊大数据中Redis使用的经验，问题&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一条数据多个key怎么设置比较合理？&lt;br/&gt;如果对性能要求不是很高直接用json序列化实体就好，没必要使用字典进行存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;队列跟List有什么区别？左进右出的话用List还是用队列比较好？&lt;br/&gt;队列其实就是用List实现的，也是基于List封装的。左进右出的话直接队列就好。Redis的List结构比较有意思，既可以左进右出，也能右进左出。所以它既可以实现列表结构，也能队列，也能实现栈&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;存放多个字段的类性能一样吗？&lt;br/&gt;大部分场景都不会有偏差，可能对于大公司数据量比较大的场景会有些偏差&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可否介绍一下使用Redis进行数据计算、统计的场景？&lt;br/&gt;略。自己看视频吧！o(∩_∩)o 哈哈！（因为我没听清！）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;大数据写入到数据库之后 比如数据到亿以上的时候 统计分析这块 查询这块 能不能分享些经验。&lt;br/&gt;分表分库，拆分到一千万以内。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU为何暴涨？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;程序员终极理念：CPU达到百分百，然后性能达到最优，尽量不要浪费。最痛恨的是：如果cpu不到百分百，性能没法提升了，说明代码有问题！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;虽然Redis会用，但是没有像大石头这样的大数据使用场景。今天的视频收获颇丰，可能大部分人跟我一样，没有大石头的使用场景，但是值得借鉴的经验还是很丰富的！期待下一次的精彩分享。同时附上QQ群：1600800。可以共同交流使用经验！&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 17:29:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文地址：https://www.cnblogs.com/yilezhu/p/9941208.html 作者：大石头 时间：2018 11 10 晚上20：00 地点：钉钉群（组织代码B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9941208.html</dc:identifier>
</item>
<item>
<title>win10 64位系统中安装多个jdk版本的切换问题 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9941191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9941191.html</guid>
<description>&lt;p&gt;由于电脑安装了myeclipse2017，同时又安装了idea2017，idea是最新版，必须使用jdk1.8以上，而myeclipse中的项目又需要低版本的jdk，所以在电脑上之前安装配置好了jdk1.8，后来又要安装jdk1.7，可以来回切换，但是过程中遇到了很多问题，总结一下。&lt;/p&gt;
&lt;p&gt;安装jdk后，我们配置环境变量，先&lt;span&gt;&lt;strong&gt;特别注意一个问题&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181111010610337-2036658907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更改环境变量的问题，我搜了很多方案，一个个的试，最终解决，主要方案有以下几个：&lt;/p&gt;
&lt;p&gt;　　1、为了从jdk1.8切换到1.7，首先做的是将环境变量中的 &lt;strong&gt;JAVA_HOME &lt;/strong&gt;值改成1.7的安装路径，并将 &lt;strong&gt;JAVA_HOME &lt;/strong&gt;放到Path路径中的最前面。这个是必须做的。&lt;/p&gt;
&lt;p&gt;　　　  如上图，&lt;strong&gt;然后重新打开cmd&lt;/strong&gt;，&lt;strong&gt;进入多个目录下&lt;/strong&gt;，输入命令：&lt;strong&gt;java -version &lt;/strong&gt;查看是否切换成功，如果ok，那就成功了，否则试试后几个方法。&lt;/p&gt;
&lt;p&gt;　　2、找到控制面板，查看方式选择&lt;strong&gt;大图标&lt;/strong&gt;或者&lt;strong&gt;小图标&lt;/strong&gt;，找到 &lt;strong&gt;java选项 &lt;/strong&gt;并点击进入（&lt;span&gt;注意：该java选项只有在独立安装了jre后才有&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;　　　  然后选择&lt;strong&gt;java&lt;/strong&gt;栏，点击查看，将 &lt;strong&gt;1.8、9 &lt;/strong&gt;的启用勾选去掉，并保存。&lt;strong&gt;然后重新打开cmd&lt;/strong&gt;，&lt;strong&gt;进入多个目录下&lt;/strong&gt;，输入命令：&lt;strong&gt;java -version &lt;/strong&gt;查看是否切换成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181110195941327-139817825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：该 &lt;strong&gt;Java控制面板 &lt;/strong&gt;页面只有在 &lt;span&gt;独立安装了jre &lt;/span&gt;后才有。而且是独立安装了 &lt;strong&gt;jre-9 &lt;/strong&gt;才会出现如下界面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181110200113728-742774692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　独立安装了 &lt;strong&gt;jre1.7 &lt;/strong&gt;和 &lt;strong&gt;jre1.8 &lt;/strong&gt;的显示界面跟上图不一样！，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181110235904529-1218824723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择 &lt;strong&gt;更新 &lt;/strong&gt;按钮，去掉&lt;strong&gt;自动检查更新&lt;/strong&gt;，不要自动更新。（同样是独立安装&lt;strong&gt;jre-9&lt;/strong&gt;以后才有如下的界面）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181110225823741-2108437977.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3、找到目录 &lt;strong&gt;C:\Windows\System32&lt;/strong&gt;，将 &lt;strong&gt;java.exe、javaw.exe、javaws.exe &lt;/strong&gt;删除即可。&lt;/p&gt;
&lt;p&gt;　　　  &lt;strong&gt;然后重新打开cmd&lt;/strong&gt;，&lt;strong&gt;进入多个目录下&lt;/strong&gt;，输入命令：&lt;strong&gt;java -version &lt;/strong&gt;查看是否切换成功。&lt;/p&gt;
&lt;p&gt;　　4、找到目录 &lt;strong&gt;C:\ProgramData\Oracle\Java\javapath （&lt;/strong&gt;&lt;span&gt;注意：是隐藏的目录，需要打开文件扩展名和隐藏的项目，如下图所示&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;，将目录中 &lt;strong&gt;java.exe、javaw.exe、javaws.exe &lt;/strong&gt;删除掉。&lt;/p&gt;
&lt;p&gt;　　　  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;当我们把该目录下文件都删除掉后，Path路径下的环境变量 &lt;strong&gt;C:\ProgramData\Oracle\Java\javapath &lt;/strong&gt;会自动消失，很神奇啊！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　  &lt;strong&gt;然后重新打开cmd&lt;/strong&gt;，&lt;strong&gt;进入多个目录下&lt;/strong&gt;，输入命令：&lt;strong&gt;java -version &lt;/strong&gt;查看是否切换成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181111010020802-150416704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、如果还不能切换，你可以使用 &lt;strong&gt;WIN + R&lt;/strong&gt; 输入&lt;strong&gt;regedit&lt;/strong&gt; 敲回车打开注册表，找到 &lt;strong&gt;HKEY_LOCAL_MACHINE&lt;/strong&gt; --&amp;gt; &lt;strong&gt;SOFTWARE&lt;/strong&gt; --&amp;gt; &lt;strong&gt;JavaSoft&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;　　　  点击 &lt;strong&gt;Java Development Kit&lt;/strong&gt; 更改右边 &lt;strong&gt;CurrentVersion &lt;/strong&gt;的值设置为你想要的版本值（&lt;strong&gt;右键 --&amp;gt; 更改&lt;/strong&gt;就可以）。&lt;/p&gt;
&lt;p&gt;　　　  &lt;strong&gt;然后重新打开cmd&lt;/strong&gt;，&lt;strong&gt;进入多个目录下&lt;/strong&gt;，输入命令：&lt;strong&gt;java -version &lt;/strong&gt;查看是否切换成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201811/841693-20181111000159014-329242099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;br/&gt;　　&lt;a href=&quot;https://blog.csdn.net/qq_20372833/article/details/79237158&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/qq_20372833/article/details/79237158&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/weixin_42321963/article/details/80965479&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/weixin_42321963/article/details/80965479&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/ns_code/article/details/18547959&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/ns_code/article/details/18547959&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/Biegral/article/details/46272171&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/Biegral/article/details/46272171&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://blog.csdn.net/sunlovemoon1991/article/details/50667568&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/sunlovemoon1991/article/details/50667568&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 17:03:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>由于电脑安装了myeclipse2017，同时又安装了idea2017，idea是最新版，必须使用jdk1.8以上，而myeclipse中的项目又需要低版本的jdk，所以在电脑上之前安装配置好了jdk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9941191.html</dc:identifier>
</item>
<item>
<title>【Linux】【Apatch Tomcat】CentOS7安装不最新版Apartch Tomcat环境 - Wei_Xiong</title>
<link>http://www.cnblogs.com/Twobox/p/9941185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Twobox/p/9941185.html</guid>
<description>&lt;h3&gt;1、前言&lt;/h3&gt;
&lt;p&gt;　　相当嫌弃，博客园搞掉了我快写完的 Tomcat。&lt;/p&gt;
&lt;p&gt;　　请先安装 ：&lt;a href=&quot;https://www.cnblogs.com/Twobox/p/9941152.html&quot; target=&quot;_blank&quot;&gt;【Linux】【Java】CentOS7安装最新版Java1.8.191运行开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　虽然安装Tomcat没啥技术，但是还是记录一下，方便后面萌新学习。&lt;/p&gt;
&lt;h3&gt;2、开始&lt;/h3&gt;
&lt;h4&gt;　　1、获取下载地址&lt;/h4&gt;
&lt;p&gt;　　　　&lt;a href=&quot;http://tomcat.apache.org/&quot; target=&quot;_blank&quot;&gt;http://tomcat.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　· Tomcat 8.5.35 Released     2018-11-07&lt;/p&gt;
&lt;p&gt;　　　　　　意思 ：2018-11-07发布的 Tomcat 8.5.35 的发行版。&lt;/p&gt;
&lt;p&gt;　　　　· 当然你也可以选着最高版：Tomcat 9.0.13 Released    2018-11-07&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111003100913-1671468807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　右键 &lt;a href=&quot;http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz&quot; rel=&quot;nofollow&quot;&gt;tar.gz&lt;/a&gt; (&lt;a href=&quot;https://www.apache.org/dist/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz.asc&quot;&gt;pgp&lt;/a&gt;, &lt;a href=&quot;https://www.apache.org/dist/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz.sha512&quot;&gt;sha512&lt;/a&gt;) 复制 下载链接：http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111003404118-1072669323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2、下载&lt;/h4&gt;
&lt;p&gt;　　　　· cd /tmp/&lt;/p&gt;
&lt;p&gt;　　　　　　一般下载临时东西 都放到这个文件夹内&lt;/p&gt;
&lt;p&gt;　　　　· wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz&lt;/p&gt;
&lt;p&gt;　　　　　　使用linux wget命令下载程序包&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111003515981-1492498689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　· ls -l&lt;/p&gt;
&lt;p&gt;　　　　　　这里看到已经有了&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111003640441-1006047069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　3、解压（安装）&lt;/h4&gt;
&lt;p&gt;　　　　· cd /usr/local/&lt;/p&gt;
&lt;p&gt;　　　　　　用户安装的软件 一般 放到 /usr/local/ 目录下&lt;/p&gt;
&lt;p&gt;　　　　· cp /tmp/apache-tomcat-8.5.35.tar.gz .&lt;/p&gt;
&lt;p&gt;　　　　　　拷贝 apache-tomcat-8.5.35.tar.gz 到这个目录下&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111003743777-330239329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　· tar -xzvf apache-tomcat-8.5.35.tar.gz&lt;/p&gt;
&lt;p&gt;　　　　　　解压并释放。x：解压、z：指明是gzip压缩文件、v：显示日志、f：指定文件名&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004007372-465595582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　已解压（安装）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004241314-980454628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　4、配置Tomcat服务器&lt;/h4&gt;
&lt;h5&gt;　　　　1、使用vim编辑器编辑service.xml文件&lt;/h5&gt;
&lt;p&gt;　　　　　　· vim apache-tomcat-8.5.35/conf/server.xml&lt;/p&gt;
&lt;p&gt;　　　　　　　　service.xml 里面可以配置 timcat 服务器的端口 ，默认字符编码啥的。就是用来设置tomcat偏好的。&lt;/p&gt;
&lt;p&gt;　　　　　　　　vim编辑器怎么用，哈哈自己百度学习啦，很多。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004354239-570854934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;　　　　2、修改默认端口为80，以前默认为8080&lt;/h5&gt;
&lt;p&gt;　　　　　　conf/server.xml 文件&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004607444-1469007910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;　　　　3、修改默认字符编码为“UFT-8”&lt;/h5&gt;
&lt;p&gt;　　　　　　conf/server.xml 文件&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004639615-894558417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;　　　　4、保存：ESC -&amp;gt; :wq         &lt;/h5&gt;
&lt;h4&gt;　　5、启动&lt;/h4&gt;
&lt;p&gt;　　　　· cd apache-tomcat-8.5.35/bin/&lt;/p&gt;
&lt;p&gt;　　　　　　启动程序在 bin文件夹下&lt;/p&gt;
&lt;p&gt;　　　　· sh startup.sh&lt;/p&gt;
&lt;p&gt;　　　　　　sh命令执行 启动Tomcat服务器脚本&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111004824067-178199735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　启动成功（这是之前的图）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111002621699-171413978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　Tom Cat come escort.&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1118369/201811/1118369-20181111005619326-288382033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 3、后言&lt;/h3&gt;
&lt;p&gt;　　虽然之前写的呗博客园抛弃了，但是第二遍写的时候更加有条理性了。大家看的也会更加清楚。&lt;/p&gt;
&lt;h3&gt;4、修改记录&lt;/h3&gt;
&lt;p&gt;　　2018-11-11 00:52:40 -&amp;gt; 2018-11-11 00:54:47 -&amp;gt; 2018-11-11 00:57:52&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 16:54:00 +0000</pubDate>
<dc:creator>Wei_Xiong</dc:creator>
<og:description>1、前言 相当嫌弃，博客园搞掉了我快写完的 Tomcat。 请先安装 ：【Linux】【Java】CentOS7安装最新版Java1.8.191运行开发环境 虽然安装Tomcat没啥技术，但是还是记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Twobox/p/9941185.html</dc:identifier>
</item>
<item>
<title>Unity3D_(API)射线检测 - Cynical丶Gary</title>
<link>http://www.cnblogs.com/1138720556Gary/p/9941156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1138720556Gary/p/9941156.html</guid>
<description>

&lt;p&gt;　　Unity射线检测官方文档：　　&lt;a href=&quot;https://docs.unity3d.com/2018.3/Documentation/ScriptReference/Physics.Raycast.html&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　一、检测前方是否有游戏物体(射线无限长度)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　二、检测前方是否有游戏物体(射线长度为1m)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　三、检测前方游戏物体碰撞信息(射线无限长度)：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　四、指定检测碰撞Tag层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　2D射线检测：使用Physics2D.Raycast()&lt;/p&gt;
&lt;p&gt;　　Raycast()和RaycastAll()区别：Raycast()只检测当前游戏物体，RaycastAll()检测前方所有游戏物体(返回一个数组)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;创建一个Cube作为地面，重命名为Ground&lt;/p&gt;
&lt;p&gt;　　创建一个Cube作为游戏玩家(重命名为Player)，游戏玩家下再新建一个Cube(重命名为Ray)作为射线发射起点&lt;/p&gt;
&lt;p&gt;　　创建三个Cube作为目标，用来判断射线是否检测到目标&lt;/p&gt;
&lt;p&gt;　　给Ray添加射线检测Player.cs脚本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、检测前方是否有游戏物体(射线无限长度)：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181110234949231-1991248317.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_748cd083-730f-4a55-aedf-6fd36b7f19ad&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_748cd083-730f-4a55-aedf-6fd36b7f19ad&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_748cd083-730f-4a55-aedf-6fd36b7f19ad&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Player : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start () {
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Raycast()方法判断射线是否被检测&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider =&lt;span&gt; Physics.Raycast(ray);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出检测信息，只能为True或False&lt;/span&gt;
&lt;span&gt;        Debug.Log(isCollider);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Player.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Raycast()方法判断射线是否被检测&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider =&lt;span&gt; Physics.Raycast(ray);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出检测信息，只能为True或False&lt;/span&gt;
        Debug.Log(isCollider);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、检测前方是否有游戏物体(射线长度为1m)：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181110235719033-914166365.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_cedba365-c2db-4848-baec-74e7c945a51c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cedba365-c2db-4848-baec-74e7c945a51c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cedba365-c2db-4848-baec-74e7c945a51c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Player : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start () {
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Raycast()方法判断射线是否被检测&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出检测信息，只能为True或False&lt;/span&gt;
&lt;span&gt;        Debug.Log(isCollider);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Player.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Raycast()方法判断射线是否被检测&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出检测信息，只能为True或False&lt;/span&gt;
        Debug.Log(isCollider);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、检测前方游戏物体碰撞信息(射线无限长度)：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181111000847400-2066423001.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_9bafc6df-a3d4-4905-9af4-9ba6ceda08ef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9bafc6df-a3d4-4905-9af4-9ba6ceda08ef&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9bafc6df-a3d4-4905-9af4-9ba6ceda08ef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Player : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start () {
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        RaycastHit hit;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,&lt;span&gt;out&lt;/span&gt;&lt;span&gt; hit);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出是否碰撞到物体&lt;/span&gt;
&lt;span&gt;        Debug.Log(isCollider);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出碰撞物体名字&lt;/span&gt;
&lt;span&gt;        Debug.Log(hit.collider);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出碰撞到物体位置&lt;/span&gt;
&lt;span&gt;        Debug.Log(hit.point);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Player.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        RaycastHit hit;
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,&lt;span&gt;out&lt;/span&gt;&lt;span&gt; hit);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出是否碰撞到物体&lt;/span&gt;
&lt;span&gt;        Debug.Log(isCollider);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出碰撞物体名字&lt;/span&gt;
&lt;span&gt;        Debug.Log(hit.collider);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出碰撞到物体位置&lt;/span&gt;
        Debug.Log(hit.point);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、指定检测碰撞Tag层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　给Cube-1 添加 Gary1标签，其它Cube不做改动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1282839/201811/1282839-20181111001838170-838290422.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_0d3446ea-7aba-4a3d-b3e7-81301ed6d352&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0d3446ea-7aba-4a3d-b3e7-81301ed6d352&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d3446ea-7aba-4a3d-b3e7-81301ed6d352&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Player : MonoBehaviour {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start () {
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Update is called once per frame&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要进行碰撞的Layout层&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,Mathf.Infinity,LayerMask.GetMask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gary1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出是否碰撞到物体&lt;/span&gt;
&lt;span&gt;        Debug.Log(isCollider);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Player.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线发射的起始位置和方向&lt;/span&gt;
        Ray ray = &lt;span&gt;new&lt;/span&gt; Ray(transform.position+&lt;span&gt;transform.forward, transform.forward);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要进行碰撞的Layout层&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; isCollider = Physics.Raycast(ray,Mathf.Infinity,LayerMask.GetMask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gary1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出是否碰撞到物体&lt;/span&gt;
        Debug.Log(isCollider);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Raycast()和RaycastAll()区别&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 16:22:00 +0000</pubDate>
<dc:creator>Cynical丶Gary</dc:creator>
<og:description>Unity射线检测官方文档： 传送门 一、检测前方是否有游戏物体(射线无限长度) 二、检测前方是否有游戏物体(射线长度为1m) 三、检测前方游戏物体碰撞信息(射线无限长度)： 四、指定检测碰撞Tag层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1138720556Gary/p/9941156.html</dc:identifier>
</item>
<item>
<title>C语言RL78 serial bootloader和C#语言bootloader PC端串口通信程序 - GeekyGeek</title>
<link>http://www.cnblogs.com/geekygeek/p/rl78bootloader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geekygeek/p/rl78bootloader.html</guid>
<description>&lt;p&gt;　　　　　　　　　　　　&lt;span&gt;&lt;strong&gt;了解更多关于bootloader 的C语言实现，请加我QQ: 1273623966 （验证信息请填 bootloader）,欢迎咨询或定制bootloader（在线升级程序）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;前段时间完成的hyperboot_rl78， 是专门为Renesas 16-bit单片机RL78 通过串口更新程序的bootloader. 由于它是通过超级终端采用Send File的方式来传送Hex文件，文本原文传送，没有协议，所以基本上hyperboot_rl78是不会使用到产品上，只能在实验室用用。但是今天我要介绍的RL78 bootloader是可靠性非常高的一款串口bootloader。 它分两部分, 一部分是RL78 MCU 端boot程序 rl78Boot,  另一部分是PC端host 程序 rl78Loader. 他们之间有通信协定，所以快速，可靠，可以使用到最终的产品上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      rl78Boot是使用CS+ 和CC-RL开发的boot程序，rl78Boot和application 的memory map 设计和 hyperboot_rl78 是一样的，interrupt vector remap 也和hyperboot_rl78 一样，详见我上一篇博文。rl78Boot上电的时候就运行，3~4秒后如果没有接收到PC 端host 程序 rl78Loader发过来的更新程序请求。就跳转到正常的application去。如果接收到更新请求，就接收 rl78Loader发送过来的数据，并根据数据中的命令字段来执行相应的动作， 并根据结果返回ACK (0x15) 或 NACK （0x51)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;命令字段有以下几种&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                0x6F:     HAND_SHAKE (握手，或叫更新请求）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                0x02:     WR_MEM    (Flash 烧写）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                0x03:      ER_MEM    (Flash 擦除）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                0x04:     VF_MEM     (Flash 验证）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                0x1F:    RUN_APP    (跳转到application)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;rl78Boot的程序框架如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void BTLD_BootProcess(void)
{
    if (R_UART0_RcvFlag())
    {
        if (BTLD_FramePtr == 0)
        {
            uint8_t sof = R_UART0_FlagedReceive();
            if ( sof != 0x02 &amp;amp;&amp;amp; sof != 0x03 &amp;amp;&amp;amp; sof != 0x04 &amp;amp;&amp;amp; sof != 0x1F )
            {
                ;
            }
            else
            {
                BTLD_ReceiveFrame[BTLD_FramePtr++] = sof;
            }
        }
        else
        {
            BTLD_ReceiveFrame[BTLD_FramePtr++] = R_UART0_FlagedReceive();
        }
    }
    if (BTLD_FramePtr == FRAME_BUFF_SIZE)
    {
        uint8_t cmd = BTLD_ReceiveFrame[CMD_INDEX];
        uint8_t addL = BTLD_ReceiveFrame[ADDRL_INDEX];
        uint8_t addH = BTLD_ReceiveFrame[ADDRH_INDEX];
        uint8_t addU = BTLD_ReceiveFrame[ADDRU_INDEX];
        uint32_t add32 = ((uint32_t)addU &amp;lt;&amp;lt; 16)|((uint32_t)addH &amp;lt;&amp;lt; 8) | addL;
        BTLD_FramePtr = 0;
        switch (cmd)
        {
            case ER_MEM:
                BTLD_FlashErase(add32);
                resetDataBuffer(BTLD_ReceiveFrame, FRAME_BUFF_SIZE);
                break;
            case WR_MEM:
                BTLD_FlashWrite(add32);
                resetDataBuffer(BTLD_ReceiveFrame, FRAME_BUFF_SIZE);
                break;
            case VF_MEM:
                BTLD_FlashVerify(add32);
                break;
            case RUN_APP:
                Jump_To_Application(add32);
                break;
            default:
                break;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            rl78Loader是使用Visual Studio 2013和C#开发的带UI界面的PC端host程序， rl78Loader 界面上可以选择COM口，Baud rate, 加载要烧写的hex（目前只支持Motorola S-Record格式）。并将record数据转换成Bin数据。我为rl78Loader 和rl78Boot之间的交互，设计总共5种类型的帧分别对应到5种不同的命令，也就是 HAND_SHAKE, WR_MEM, ER_MEM, VF_MEM, RUN_APP。 5种帧的统一格式如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;          &amp;lt;CMD&amp;gt;&amp;lt;ADDR_L&amp;gt;&amp;lt;ADDR_H&amp;gt;&amp;lt;ADDR_U&amp;gt;&amp;lt;DATA_1&amp;gt;&amp;lt;DATA_2&amp;gt;.....&amp;lt;DATA_n&amp;gt;&amp;lt;CHECK_SUM&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面就是自定义的通信协定，规定了每个帧包含命令字段一个（&amp;lt;CMD&amp;gt;）, 地址字段三个（&amp;lt;ADDR_L&amp;gt;, &amp;lt;ADDR_H&amp;gt;和&amp;lt;ADDR_U&amp;gt;）,组合起来就是24-bit地址。 数据字段n个&amp;lt;DATA_1&amp;gt;....&amp;lt;DATA_n&amp;gt;, 以及最后的校验和&amp;lt;CHECK_SUM&amp;gt;。每个字段都是1个Byte（8-bit）。 当某些字段不用时，可以填充0xFF。 比如握手帧在&amp;lt;CMD&amp;gt;段为0x6F, 在&amp;lt;ADDR_L&amp;gt;, &amp;lt;ADDR_H&amp;gt;, &amp;lt;ADDR_U&amp;gt;都为0xFF, 因为握手帧不需要地址内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        UI 界面上&quot;Start&quot; 按钮按下后， 首先发送握手帧(CMD=0x6F)，并重复多次，如果重复多次仍然没接受到ACK， Log窗口就会打印“bootloader not found&quot;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  但握手时一旦接收到ACK， 就会接着发送擦除帧(CMD=0x03)，并等待ACK， 接着就是烧写帧(CMD=0x02), 验证帧（CMD=0x04), 最后是跳转帧（CMD=0x1F)。这个就是整个烧写流程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  rl78Loader 的UI 界面如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/818084/201811/818084-20181111000316188-544458565.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Nov 2018 16:07:00 +0000</pubDate>
<dc:creator>GeekyGeek</dc:creator>
<og:description>Renesas 16-bit MCU RL78 bootloader, programming application via UART</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geekygeek/p/rl78bootloader.html</dc:identifier>
</item>
<item>
<title>互联网发展的三个阶段 - 极息烟云</title>
<link>http://www.cnblogs.com/focus-yun/p/9941085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/focus-yun/p/9941085.html</guid>
<description>&lt;p&gt;&lt;strong&gt;互联网发展的三个阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;三个阶段&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）PC互联网（PC Internet）&lt;/p&gt;
&lt;p&gt;2）移动互联网（Mobile Internet）&lt;/p&gt;
&lt;p&gt;3）物联网（IOT Internet Of Things）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;互动与互联&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;互动1.0&lt;/p&gt;
&lt;p&gt;　　门户网站，企业门户网站，提供一些信息服务&lt;/p&gt;
&lt;p&gt;互动2.0&lt;/p&gt;
&lt;p&gt;　　Google、百度，搜索互动&lt;/p&gt;
&lt;p&gt;　　新浪微博，微博关注的网络效应&lt;/p&gt;
&lt;p&gt;互联3.0&lt;/p&gt;
&lt;p&gt;　　微信，facebook，让我们互联，新诞生的一些具有影响力的名词，群主，朋友圈等&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;发展特点&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1）业务功能越来越多，越来越复杂&lt;/p&gt;
&lt;p&gt;2）万物互联，数据量越来越大&lt;/p&gt;
&lt;p&gt;3）请求量越来越多，需要更好的更高的用户体验需求&lt;/p&gt;
&lt;p&gt;4）业务持续快速迭代交付的能力&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/647966/201811/647966-20181110234125205-21967325.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 15:39:00 +0000</pubDate>
<dc:creator>极息烟云</dc:creator>
<og:description>互联网发展的三个阶段 三个阶段 1）PC互联网（PC Internet） 2）移动互联网（Mobile Internet） 3）物联网（IOT Internet Of Things） 互动与互联 互动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/focus-yun/p/9941085.html</dc:identifier>
</item>
<item>
<title>HALCON视觉算子相关函数中文说明System(2) - 风口商学院</title>
<link>http://www.cnblogs.com/fksxy/p/9941083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fksxy/p/9941083.html</guid>
<description>&lt;p&gt;16.6  Parameters&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;get_system_&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：根据HALCON系统参数获取关于当前的信息。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;set_system&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：HALCON系统参数的设置。&lt;/p&gt;

&lt;p&gt;16.7  Serial&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;clear_serial&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：清除一个串行连接的缓冲。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;close_all_serials&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：关闭所有的串行设备。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;close_serial&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：关闭一个串行设备。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;get_serial_param&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：获取一个串行设备的参数。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;open_serial&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：打开一个串行设备。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;read_serial&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：读取一个串行设备。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;set_serial_param&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：设置一个串行设备的参数。&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;write_serial&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：写入一个串行设备。&lt;/p&gt;

&lt;p&gt;16.8  Sockets&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;close_socket&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：关闭一个插口（接口）。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;get_next_socket_data_type&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：决定下一个插口（接口）数据的HALCON数据类型。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;get_socket_timeout&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：获取一个插口（接口）的超时。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;open_socket_accept&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：打开一个接受连接请求的插口（接口）。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;open_socket_connect&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：打开一个插口到一个已存在的插口。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;receive_image&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接接收一副图像。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;receive_region&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接接收区域。&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;receive_tuple&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接接收一个元组。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;receive_xld&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接接收一个XLD对象。&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;send_image&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接发送一副图像。&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;send_region&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接发送区域。&lt;/p&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;send_tuple&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接发送一个元组。&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;send_xld&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：通过插口连接发送一个XLD对象。&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;set_socket_timeout&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：设置一个插口的超时。&lt;/p&gt;
&lt;ol start=&quot;15&quot;&gt;&lt;li&gt;socket_accept_connect&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;功能：接受一个监听插口的连接请求。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Nov 2018 15:38:00 +0000</pubDate>
<dc:creator>风口商学院</dc:creator>
<og:description>16.6 Parameters 功能：根据HALCON系统参数获取关于当前的信息。 功能：HALCON系统参数的设置。 16.7 Serial 功能：清除一个串行连接的缓冲。 功能：关闭所有的串行设备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fksxy/p/9941083.html</dc:identifier>
</item>
</channel>
</rss>