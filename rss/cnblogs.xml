<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>又见开始 - 柒小栈主</title>
<link>http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230749613-751557314.jpg&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;

&lt;p&gt;又见开始，文接自“壹柒，壹柒。”&lt;/p&gt;
&lt;p&gt;今天晚间偶然间听闻了涛哥的早睡执行计划（已付诸行动），当然我是隐约能猜到该事件的导火线的，大抵是身体原因吧。听到此处，突然将我前日断断续续的规划推向了一个起点。我想，是时候将所有的规划整理一遍，以作为二〇一八的起点了罢。&lt;/p&gt;
&lt;p&gt;二〇一七是一个多人生大事的年头，在“壹柒，壹柒。”中已经有了详细的总结，此间不再赘述。我想说的是，在二〇一七的年末，自己却是有了一些良好的开端，也算作了人生的一部分规划。&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;作息时间的制定已经是迫在眉睫，随着最后一波九零后与青春年少缠绵多年后和平分手，该浪已推着我们前一批的九零后走在了直线奔三的道路上。真的感觉身体已不能再随意挥霍，我们不再有当年的血气支撑着我们去熬夜，去用整段的时间去做想做的事情，我们无可奈何地向身体妥协。这不，首当其冲的便是要对长久以来透支的作息时间动刀。&lt;/p&gt;
&lt;p&gt;23:30当做了最初的目标，我在我的手机上默默设置好了三个闹钟“23:15”、“23：30”、“7:20”。即便我晚上的效率有多高，我也将晚上熬夜的时间安排在了早上，阉割版的晚上时间，便刚好用来看看书，听听音乐，学习学习外语。&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;日常工作安排、周常计划。没有计划，就总是将临时兴起的一两次很好的活动逐渐废弃。“凡事预则立，不预则废”的古训使我不得不乖乖将曾经的良好习惯重新整理安排进计划表。&lt;/p&gt;
&lt;p&gt;二〇一七年末最让我欣慰的事情莫过于坚持了近两个月的“日常工作进度计划表”。该项计划一直坚持两个月未曾废弃，并且越来越钟爱上了它。初衷大抵为光阴流逝。内容分为了日期、事项、预计时间、实际完成时间、是否完成（未完成第二天标为红色）、完成总结等。为了长期分析自己的日常充斥着什么内容、自己的每天工作效率、对一些小事情的备忘。甚至于未来迁移到自己搭建的平台，最后将自己的生活行为做成大数据分析，了解自己的优势和痛点，对自己的未来起到指导作用也未尝不可。&lt;/p&gt;
&lt;p&gt;周常计划暂定为对本周的生活思想进行总结写一些类似于随笔的东西，这项工作放在周六较为妥当。而另一篇学习博客则放在周日，或许周六非工作日有什么大的总结，周日可以进行整理。总的来说，周末较为弹性，也是为了应对突然决定的活动，不作可以安排，至于一些非工作的计划，则随性调整。&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;对于工薪阶级，尤其是在大城市的童鞋们，一方面是生活成本较高，另一方面是生活娱乐之处较多，总的来说是更容易成为月光一族的。因此，不得不对财政作一番周密的计划，以从容应对随时可能到来的财政紧张。&lt;/p&gt;
&lt;p&gt;“家庭梦想基金”是曾经在街上踱步的时候突然想到的，当时顶着寒风立马将其记录在了OneNote里面，随后又进行了一番整理，最后终于正式提上了日程。虽说首次执行以失败告终，但是本月开始也为时未晚。暂定于每月向某一尾号为2的卡里面转一笔小额作为“家庭梦想基金”，为什么是“2”呢，因为遥相呼应了每年至少2次的旅行活动计划，以作为响应。&lt;/p&gt;
&lt;p&gt;首次失败告终的记录犹在，真得益于日常进度计划表。15是每月15号，1是计划用1天完成，实际完成时间为空，是否完成为空…&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230813597-1825533473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至于其他的生活储蓄计划，将不在本文描述…&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;在路上。&lt;/p&gt;
&lt;p&gt;“身体与心灵总有一个要在路上！”不知是谁曰（yue）出了这么绝妙不可言的辞藻。心灵在路上通俗的做法便是多去读书，无论什么类型的书，本着开卷有益的法则。事实上，现在能静下心来读几本书的人着实不多了。&lt;/p&gt;
&lt;p&gt;不得已，还是计划好了身体在路上吧，至少除了猎奇的心外，还需要有锻炼身体的心啊。至于真正的感悟，我在“壹柒，壹柒。”已经做了详尽的叙述，too 激动 to 不再赘述。&lt;/p&gt;
&lt;p&gt;一年两次，不多不少，佛系旅行。&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;最后说一些硬性计划外的软计划。&lt;/p&gt;
&lt;p&gt;从不是个过分依赖手机的人，但是个依赖生活的人。前段时间由于异地而对手机使用时长大幅度增加，最近从津迁移到京，首先个人时间上有一部分缩短，另一部分若隐若现的原因也让我逐渐得以长时间离开手机。我终于又是个极少依赖手机的人了（可是整天还是依赖着电脑，我能怎么办？？？）。&lt;/p&gt;
&lt;p&gt;减少手机使用时间仍然在软计划中，这段时间从远离手机中度日也越来越体会到个人时间的充实。匪夷所思的事情就在于手机上看一篇文章，看一则新闻，看个段子，看个小视频。最后的结局大抵为忘掉百分之九十，甚至于感觉虚度人生，无所收获。而将每天零碎时间捡起来看看书，约人说说话，出去走走，便会顿觉收获斐然，醍醐灌顶。久后仍记，人生充实，真乃奇闻也哉。&lt;/p&gt;
&lt;p&gt;健身（骑行）仍是要提的话题，健身的需求，职业使然。骑行的目的却不仅仅是健身，更多的是充实人生，穿梭市井，看看人间百态（坐车是很难走进小巷的）。更像是一种里程碑式的记忆。虽说说到底只是一项爱好，可是爱好也需要坚持啊。&lt;/p&gt;
&lt;p&gt;最后要提的便是从去年开始，将所有的读书、电影总结成了一个表格，读书要有读书开始和结束日期，用来分析读书坚持度和读书效率；电影要有观影时间、同观人和观后感，用来沉淀生活的记忆…&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230836066-1444673726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;生活无限好，只是近三十…&lt;/p&gt;
&lt;p&gt;7tiny 2018/1/10 22:30&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>柒小栈主</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</dc:identifier>
</item>
<item>
<title>chrome调试工具高级不完整使用指南（优化篇） - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8244559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8244559.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇文章我们说了chrome调试工具的一些比较基础功能的用法，接下来我们要在这一篇文章中说一说,其他一些chrome调试工具的使用方法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.2 优化模块介绍&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.2.1 Network模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180108224430785-992280287.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在netWork模块中，大致上可以分成四块模块，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 这个模块相当于是一个功能菜单，左边的四个按钮&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110222744660-580691747.gif&quot; alt=&quot;&quot;/&gt;依次表示的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-1 停止捕获请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-2 清除所有的请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-3 对请求进行快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-4 是否开启过滤选项，也就是是否开启图中的2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外里面的Disable Cache是用来请求请求缓存，Preserve log 用来保存请求记录 　offine断网，其他的具体使用与分析会在后面的课程中讲解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2- 这个模块主要是用来过滤请求的类型的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3- 这个的功能是相当于查看各个请求的发送时间，完成时间的一个总的概况，主要是用来全局分析用的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4- 查看里面的各个请求的具体情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.2  Performance模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180108233917269-1806697109.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面的这样图是博客园的首页的一张图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据博主的经验我们重点要看的就是第一和第二，然后其他部分博主一般也没有使用到，具体用法不详，知道的同学请在留言中补充一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 功能菜单模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要要讲解一下前5个按钮功能，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-1 用于触发监控页面，从而输出性能分析图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-2 重新刷新请求性能分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-3 清除所有的分析信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-4 上传分析报告图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-5 下载分析报告图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2- 这一部分主要涉及到火焰图的分析，具体可以赚到阮一峰大大的相关&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/09/flame-graph.html&quot; target=&quot;_blank&quot;&gt;博文&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.2.3 Memory模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块是用来对内存占用情况进行分析的。其中里面有3个小的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110135400394-1591405756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图中上面的1-3分别代表的功能是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 内存堆栈快照 这个功能主要是用来查看当前（没有被垃圾回收机制回收的）的各项资源的占用情况与内存的一个比例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2- 用于动态监控从start启动之后内存的一个占用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3- 通过一个时间轴图来动态监控占用情况，这个相比于2的一个好处是可以动态的监控不需要手动控制，另外一个就是可以通过图的形式直观地显示&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.2.4 Security 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块主要是用来判断当前页面中是否使用了有效的HTTPS证书，不起到其他的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110173522566-1875906765.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.2.5 audits模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块主要是chrome提供的用来自动分析页面的情况的，但是由于这个需要FQ所以推荐大家使用旧的版本Legacy audits来进行分析页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用Ctrl+Shift+P 激活面板，激活之后就会开启里面内置的一些隐藏模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110221015207-2141463667.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的一些性能优化提示自己看看英文的内容，不懂英文请百度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，所有的模块大致上面已经说了一遍了，接下来的内容就是开始说说怎样在实际应用中使用这些特性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8196493.html%20&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/st-leslie/p/8244559.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（优化篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8261319.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（实战一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战二）&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战三）&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 14:35:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8244559.html</dc:identifier>
</item>
<item>
<title>OpenCascade Ruled Surface - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</guid>
<description>&lt;h2&gt;OpenCascade Ruled Surface&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract.&lt;/strong&gt; A ruled surface is formed by moving a line connecting points of equal relative arc length or equal relative parametric value on two parametric curves from a start point to a terminate point on the curves. The paper focus on the ruled surface in opencascade.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key words.&lt;/strong&gt; OpenCascade, Ruled Surface, 直纹面&lt;/p&gt;
&lt;h3&gt;1.Introduction&lt;/h3&gt;
&lt;p&gt;《解析几何》中有关于直纹面Ruled Surface的定义：一曲面S称为直纹面，如果存在一族直线使得这一族中的每一条直线全在S上。并且S上的每个点都在这一族的某一条直线上。这样一族直线称为S的一族直母线。其参数方程为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220430051-841428932.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10134&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220430738-204874296.png&quot; alt=&quot;wps_clip_image-10134&quot; width=&quot;424&quot; height=&quot;89&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即可以将直纹面看作是曲面对当v=0和1时得到的两个边界曲线之间进行线性插值得到的曲面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431254-1601684062.png&quot;&gt;&lt;img title=&quot;wps_clip_image-2878&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431613-2139221305.png&quot; alt=&quot;wps_clip_image-2878&quot; width=&quot;408&quot; height=&quot;306&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Autodesk 3DS Max中的直纹面，图片来自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/CloudHelp/cloudhelp/2015/ENU/3DSMax/files/GUID-364FE529-431B-448A-850B-DD9BBECAC90B-htm.html&quot;&gt;https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/CloudHelp/cloudhelp/2015/ENU/3DSMax/files/GUID-364FE529-431B-448A-850B-DD9BBECAC90B-htm.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直纹面是从两条曲线来构造曲面的方法，Coons曲面是由四边条界曲线来构造曲面，理解直纹面的构造原理，为进一步理解通用的放样Sweep造型打下基础。&lt;/p&gt;
&lt;h3&gt;2.Ruled Surface Parametric Equation&lt;/h3&gt;
&lt;p&gt;直纹面的参数方程也可以写成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431816-429924804.png&quot;&gt;&lt;img title=&quot;wps_clip_image-19769&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431988-2034109216.png&quot; alt=&quot;wps_clip_image-19769&quot; width=&quot;286&quot; height=&quot;43&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接根据参数方程可以定义出相应的直纹面。在OpenCASCADE中话，可以从Geom_Surface派生新的类，并实现相应的虚函数。如实现计算对应参数u,v的值的虚函数D0()等。为了简单起见，用相应的函数计算直纹面上的点，并生成OpenCASCADE Draw Test Harness的命令脚本文件，方便在Draw中可视化。&lt;/p&gt;
&lt;p&gt;如有名的Mobius Strip也是个直纹面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220432410-1387573437.png&quot;&gt;&lt;img title=&quot;wps_clip_image-4834&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220432816-1725399160.png&quot; alt=&quot;wps_clip_image-4834&quot; width=&quot;553&quot; height=&quot;319&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mobius Strip的参数方程为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433097-249218186.png&quot;&gt;&lt;img title=&quot;wps_clip_image-26570&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433363-527722293.png&quot; alt=&quot;wps_clip_image-26570&quot; width=&quot;554&quot; height=&quot;100&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据上述参数方程在OpenCASCADE的Draw生成Mobius Strip，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Standard_Real MOBIUS_RADIUS = &lt;span&gt;50.0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MobiusStrip(Standard_Real theU, Standard_Real theV, gp_Pnt&amp;amp;&lt;span&gt; thePoint)
{
    thePoint.SetX((MOBIUS_RADIUS &lt;/span&gt;+ theU * Cos(&lt;span&gt;0.5&lt;/span&gt; * theV)) *&lt;span&gt; Cos(theV));
    thePoint.SetY((MOBIUS_RADIUS &lt;/span&gt;+ theU * Cos(&lt;span&gt;0.5&lt;/span&gt; * theV)) *&lt;span&gt; Sin(theV));
    thePoint.SetZ(theU &lt;/span&gt;* Sin(&lt;span&gt;0.5&lt;/span&gt; *&lt;span&gt; theV));
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestMobiusStrip()
{
    std::ofstream aTclFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:/mobius.tcl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pload ALL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;

    Standard_Real aWidth &lt;/span&gt;= &lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;;
    Standard_Integer aN &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real s = -aWidth; s &amp;lt; aWidth; s += &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)
    {
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polyline p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; ++&lt;span&gt;aN ;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real t = &lt;span&gt;0.0&lt;/span&gt;; t &amp;lt; M_PI * &lt;span&gt;2.0&lt;/span&gt;; t += &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;)
        {
            gp_Pnt aPoint;
            MobiusStrip(s, t, aPoint);

            aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();
        }

        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n vdisplay p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aN &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }


    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real t = &lt;span&gt;0.0&lt;/span&gt;; t &amp;lt; M_PI * &lt;span&gt;2.0&lt;/span&gt;; t += &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;)
    {
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polyline p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; ++&lt;span&gt;aN;
        gp_Pnt aPoint;

        MobiusStrip(&lt;/span&gt;-&lt;span&gt;aWidth, t, aPoint);
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();

        MobiusStrip(aWidth, t, aPoint);
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();

        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n vdisplay p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aN &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    TestMobiusStrip();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在D盘生成一个mobius.tcl脚本文件，直接在Draw Test Harness中输入命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;source d:/mobius.tcl&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即可得到如下图所示的Mobius环：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433722-591864499.gif&quot;&gt;&lt;img title=&quot;mobius&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220434129-1541157090.gif&quot; alt=&quot;mobius&quot; width=&quot;701&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的直纹面只要知道参数方程，都可以采用这种方法在OpenCASCADE Draw Test Harness中进行显示。有人也用POV-Ray根据直纹面的参数方程来绘制直纹面，效果更不错。&lt;/p&gt;
&lt;p&gt;这是使用参数方程来表示直纹面的方法，如果知道直纹面的参数方程，可以从几何曲面来派生新类Geom_Surface，并实现几个相关虚函数，应该可以直接给OpenCASCADE显示了，这种方法没有测试。&lt;/p&gt;
&lt;h3&gt;3.Ruled Surface to B Spline Surface&lt;/h3&gt;
&lt;p&gt;如果已知直纹面的参数方程，如何用NURBS曲面来表示直纹面呢？在《非均匀有理B样条》一书中给出了一种将给定两条曲线C1,C2转换成直纹面的方法。他给出的限制条件是想要生成在v方向是直线的曲面，即是C1(u)和C2(u)之间的线性插值。而且还要求在两条曲线的等参数点之间进行插值。又由于曲面是张量各曲面，两条边界曲线C1和C2必须具有相同的次数，并定义在相同的节点矢量上，因此表示这样的直纹面的B样条转换过程为：&lt;/p&gt;
&lt;p&gt;l 确保两条曲线定义在相同的参数区间内；&lt;/p&gt;
&lt;p&gt;l 确保两条曲线的次数相同。如果不同，则将次数低的曲线升阶；&lt;/p&gt;
&lt;p&gt;l 确保两条曲线有相同的节点矢量。&lt;/p&gt;
&lt;p&gt;OpenCASCADE中生成直纹面的是类GeomFill的静态函数Surface()，其实现步骤与上述类似，具体实现的类是GeomFill_Profiler。GeomFill_Profiler是个更通用的类，它可以根据多条曲线来构造曲面。下面通过Draw Test Harness脚本来根据两条曲线构造直纹面。&lt;/p&gt;
&lt;h4&gt;3.1 根据两条直线构造直纹面&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between two lines.&lt;/span&gt;
&lt;span&gt;
vertex v1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

vertex v2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;

vertex v3 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;

vertex v4 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

edge e1 v1 v2

edge e2 v3 v4

pruled r1 e1 e2

vdisplay v1 v2 v3 v4 e1 e2 r1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成直纹面是一个双线性曲面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220435754-2117146722.gif&quot;&gt;&lt;img title=&quot;ruled1&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220437535-1601226836.gif&quot; alt=&quot;ruled1&quot; width=&quot;425&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.2 根据两个圆构造直纹面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between circle and ellipse.&lt;/span&gt;
&lt;span&gt;
circle c1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

circle c2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;

mkedge e3 c1

mkedge e4 c2

pruled r2 e3 e4

vdisplay e3 e4 r2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的直纹面是一个圆锥面，效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220437926-759759519.png&quot;&gt;&lt;img title=&quot;wps_clip_image-15852&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438269-698101129.png&quot; alt=&quot;wps_clip_image-15852&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当顶部的圆旋转时会得到如下图所示的直纹面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438629-1988866212.png&quot;&gt;&lt;img title=&quot;wps_clip_image-2230&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438988-2068179871.png&quot; alt=&quot;wps_clip_image-2230&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相应的Draw脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between circle and ellipse.&lt;/span&gt;
&lt;span&gt;
circle c1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

circle c2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;

mkedge e3 c1

mkedge e4 c2

pruled r2 e3 e4

vdisplay e3 e4 r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的动画效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220440488-1141527608.gif&quot;&gt;&lt;img title=&quot;ruled4&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220441722-222089828.gif&quot; alt=&quot;ruled4&quot; width=&quot;425&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4.Conclusion&lt;/h3&gt;
&lt;p&gt;根据直纹面的参数方程就可以绘制出相应的曲面，然后如何用B样条曲面来表示直纹面，需要满足一定的条件。IGES中定义的直纹面就给出了两种方式：等弧长和等参数构造。引用《非均匀有理B样条》书中对两种形式的说明如下：一般情况下，连接两条曲线上相对弧长相等的点会产生一个几何上不同的曲面，而这样的曲面不能通过NURBS来表示。因此，要在NURBS的直纹面和IGES的直纹面（Type 118 Form 0/1）之间进行数学上的精确转换是不可能的。&lt;/p&gt;
&lt;p&gt;OpenCASCADE的直纹面也是使用的NURBS表示，所以其也是等参数形式的直纹面。希望在理解根据两条曲线来构造曲面的方法来理解更一般的造型算法，即通过多条曲线来构造曲面的造型方法。&lt;/p&gt;
&lt;h3&gt;5.References&lt;/h3&gt;
&lt;p&gt;1. Weisstein Eric W. “Ruled Surface”. &lt;a href=&quot;http://mathworld.wolfram.com/RuledSurface.html&quot;&gt;http://mathworld.wolfram.com/RuledSurface.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.ms.uky.edu/~lee/visual05/gallery/ruledsurfaces.doc&quot;&gt;www.ms.uky.edu/~lee/visual05/gallery/ruledsurfaces.doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. The Initial Graphics Exchange Specification (IGES) Version 6.0&lt;/p&gt;
&lt;p&gt;4. 赵罡, 穆国旺, 王拉柱. 非均匀有理B样条. 清华大学出版社. 2010&lt;/p&gt;
&lt;p&gt;5. 丘维声. 解析几何. 北京大学出版社. 1996&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 14:05:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——18. 组合优于继承 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8260992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8260992.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。 提醒一下，本书使用“继承”一词来表示实现继承（当一个类继承另一个类时）。 在这个项目中讨论的问题不适用于接口继承（当类实现接口或当接口继承另一个接口时）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与方法调用不同，继承打破了封装&lt;/strong&gt;[Snyder86]。 换句话说，一个子类依赖于其父类的实现细节来保证其正确的功能。 父类的实现可能会从发布版本不断变化，如果是这样，子类可能会被破坏，即使它的代码没有任何改变。 因此，一个子类必须与其超类一起更新而变化，除非父类的作者为了继承的目的而专门设计它，并对应有文档的说明。&lt;/p&gt;
&lt;p&gt;为了具体说明，假设有一个使用&lt;code&gt;HashSet&lt;/code&gt;的程序。 为了调整程序的性能，需要查询&lt;code&gt;HashSe&lt;/code&gt;，从创建它之后已经添加了多少个元素（不要和当前的元素数量混淆，当元素被删除时数量也会下降）。 为了提供这个功能，编写了一个&lt;code&gt;HashSet&lt;/code&gt;变体，它保留了尝试元素插入的数量，并导出了这个插入数量的一个访问方法。 &lt;code&gt;HashSet&lt;/code&gt;类包含两个添加元素的方法，分别是&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;addAll&lt;/code&gt;，所以我们重写这两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken - Inappropriate use of inheritance!
public class InstrumentedHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; {
    // The number of attempted element insertions
    private int addCount = 0;

    public InstrumentedHashSet() {
    }

    public InstrumentedHashSet(int initCap, float loadFactor) {
        super(initCap, loadFactor);
    }
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }
    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类看起来很合理，但是不能正常工作。 假设创建一个实例并使用&lt;code&gt;addAll&lt;/code&gt;方法添加三个元素。 顺便提一句，请注意，下面代码使用在Java 9中添加的静态工厂方法&lt;code&gt;List.of&lt;/code&gt;来创建一个列表；如果使用的是早期版本，请改为使用&lt;code&gt;Arrays.asList&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InstrumentedHashSet&amp;lt;String&amp;gt; s = new InstrumentedHashSet&amp;lt;&amp;gt;();
s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们期望&lt;code&gt;getAddCount&lt;/code&gt;方法返回的结果是3，但实际上返回了6。哪里出来问题？在&lt;code&gt;HashSet&lt;/code&gt;内部，&lt;code&gt;addAll&lt;/code&gt;方法是基于它的&lt;code&gt;add&lt;/code&gt;方法来实现的，即使&lt;code&gt;HashSet&lt;/code&gt;文档中没有指名其实现细节，倒也是合理的。&lt;code&gt;InstrumentedHashSet&lt;/code&gt;中的&lt;code&gt;addAll&lt;/code&gt;方法首先给&lt;code&gt;addCount&lt;/code&gt;属性设置为3，然后使用&lt;code&gt;super.addAll&lt;/code&gt;方法调用了&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;实现。然后反过来又调用在&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类中重写的&lt;code&gt;add&lt;/code&gt;方法，每个元素调用一次。这三次调用又分别给&lt;code&gt;addCount&lt;/code&gt;加1，所以，一共增加了6：通过&lt;code&gt;addAll&lt;/code&gt;方法每个增加的元素都被计算了两次。&lt;/p&gt;
&lt;p&gt;我们可以通过消除&lt;code&gt;addAll&lt;/code&gt;方法的重写来“修复”子类。 尽管生成的类可以正常工作，但是它依赖于它的正确方法，因为&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;方法是在其&lt;code&gt;add&lt;/code&gt;方法之上实现的。 这个“自我使用（self-use）”是一个实现细节，并不保证在Java平台的所有实现中都可以适用，并且可以随发布版本而变化。 因此，产生的&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类是脆弱的。&lt;/p&gt;
&lt;p&gt;稍微好一点的做法是，重写&lt;code&gt;addAll&lt;/code&gt;方法遍历指定集合，为每个元素调用&lt;code&gt;add&lt;/code&gt;方法一次。 不管&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;方法是否在其&lt;code&gt;add&lt;/code&gt;方法上实现，都会保证正确的结果，因为&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;实现将不再被调用。然而，这种技术并不能解决所有的问题。 这相当于重新实现了父类方法，这样的方法可能不能确定到底是否时自用（self-use）的，实现起来也是困难的，耗时的，容易出错的，并且可能会降低性能。 此外，这种方式并不能总是奏效，因为子类无法访问一些私有属性，所以有些方法就无法实现。&lt;/p&gt;
&lt;p&gt;导致子类脆弱的一个相关原因是，它们的父类在后续的发布版本中可以添加新的方法。假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。可以通过对集合进行子类化，然后并重写所有添加元素的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了这样的新方法，则很有肯能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把&lt;code&gt;Hashtable&lt;/code&gt;和&lt;code&gt;Vector&lt;/code&gt;类加入到Collections框架中的时候，就修复了几个类似性质的安全漏洞。&lt;/p&gt;
&lt;p&gt;这两个问题都源于重写方法。 如果仅仅添加新的方法并且不要重写现有的方法，可能会认为继承一个类是安全的。 虽然这种扩展更为安全，但这并非没有风险。 如果父类在后续版本中添加了一个新的方法，并且你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类编译失败[JLS，8.4.8.3]。 如果已经为子类提供了一个与新的父类方法具有相同签名和返回类型的方法，那么你现在正在重写它，因此将遇到前面所述的问题。 此外，你的方法是否会履行新的父类方法的约定，这是值得怀疑的，因为在你编写子类方法时，这个约定还没有写出来。&lt;/p&gt;
&lt;p&gt;幸运的是，有一种方法可以避免上述所有的问题。不要继承一个现有的类，而应该给你的新类增加一个私有属性，该属性是 现有类的实例引用，这种设计被称为组合（composition），因为现有的类成为新类的组成部分。新类中的每个实例方法调用现有类的包含实例上的相应方法并返回结果。这被称为转发（forwarding），而新类中的方法被称为转发方法。由此产生的类将坚如磐石，不依赖于现有类的实现细节。即使将新的方法添加到现有的类中，也不会对新类产生影响。为了具体说用，下面代码使用组合和转发方法替代&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类。请注意，实现分为两部分，类本身和一个可重用的转发类，其中包含所有的转发方法，没有别的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Reusable forwarding class
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public class ForwardingSet&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt; {

    private final Set&amp;lt;E&amp;gt; s;

    public ForwardingSet(Set&amp;lt;E&amp;gt; s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator&amp;lt;E&amp;gt; iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection&amp;lt;?&amp;gt; c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection&amp;lt;?&amp;gt; c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// Wrapper class - uses composition in place of inheritance
import java.util.Collection;
import java.util.Set;

public class InstrumentedSet&amp;lt;E&amp;gt; extends ForwardingSet&amp;lt;E&amp;gt; {

    private int addCount = 0;

    public InstrumentedSet(Set&amp;lt;E&amp;gt; s) {
        super(s);
    }
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类的设计是通过存在的Set接口来实现的，该接口包含&lt;code&gt;HashSet&lt;/code&gt;类的功能特性。除了功能强大，这个设计是非常灵活的。&lt;code&gt;InstrumentedSet&lt;/code&gt;类实现了Set接口，并有一个构造方法，其参数也是Set类型的。本质上，这个类把&lt;code&gt;Set&lt;/code&gt;转换为另一个类型&lt;code&gt;Set&lt;/code&gt;， 同时添加了计数的功能。与基于继承的方法不同，该方法仅适用于单个具体类，并且父类中每个需要支持构造方法，提供单独的构造方法，所以可以使用包装类来包装任何&lt;code&gt;Set&lt;/code&gt;实现，并且可以与任何预先存在的构造方法结合使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;Instant&amp;gt; times = new InstrumentedSet&amp;lt;&amp;gt;(new TreeSet&amp;lt;&amp;gt;(cmp));
Set&amp;lt;E&amp;gt; s = new InstrumentedSet&amp;lt;&amp;gt;(new HashSet&amp;lt;&amp;gt;(INIT_CAPACITY));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类甚至可以用于临时替换没有计数功能下使用的集合实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void walk(Set&amp;lt;Dog&amp;gt; dogs) {
    InstrumentedSet&amp;lt;Dog&amp;gt; iDogs = new InstrumentedSet&amp;lt;&amp;gt;(dogs);
    ... // Within this method use iDogs instead of dogs
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类被称为包装类，因为每个&lt;code&gt;InstrumentedSet&lt;/code&gt;实例都包含（“包装”）另一个&lt;code&gt;Set&lt;/code&gt;实例。 这也被称为装饰器模式[Gamma95]，因为&lt;code&gt;InstrumentedSet&lt;/code&gt;类通过添加计数功能来“装饰”一个集合。 有时组合和转发的结合被不精确地地称为委托（delegation）。 从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86;Gamma95]。&lt;/p&gt;
&lt;p&gt;包装类的缺点很少。 一个警告是包装类不适合在回调框架（callback frameworks）中使用，其中对象将自我引用传递给其他对象以用于后续调用（“回调”）。 因为一个被包装的对象不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时并不记得外面的包装对象。 这被称为SELF问题[Lieberman86]。 有些人担心转发方法调用的性能影响，以及包装对象对内存占用。 两者在实践中都没有太大的影响。 编写转发方法有些繁琐，但是只需为每个接口编写一次可重用的转发类，并且提供转发类。 例如，Guava为所有的Collection接口提供转发类[Guava]。&lt;/p&gt;
&lt;p&gt;只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，只有在两个类之间存在“is-a”关系的情况下，B类才能继承A类。 如果你试图让B类继承A类时，问自己这个问题：每个B都是A吗？ 如果你不能如实回答这个问题，那么B就不应该继承A。如果答案是否定的，那么B通常包含一个A的私有实例，并且暴露一个不同的API：A不是B的重要部分 ，只是其实现细节。&lt;/p&gt;
&lt;p&gt;在Java平台类库中有一些明显的违反这个原则的情况。 例如，stacks实例并不是vector实例，所以&lt;code&gt;Stack&lt;/code&gt;类不应该继承&lt;code&gt;Vector&lt;/code&gt;类。 同样，一个属性列表不是一个哈希表，所以&lt;code&gt;Properties&lt;/code&gt;不应该继承&lt;code&gt;Hashtable&lt;/code&gt;类。 在这两种情况下，组合方式更可取。&lt;/p&gt;
&lt;p&gt;如果在合适组合的地方使用继承，则会不必要地公开实现细节。由此产生的API将与原始实现联系在一起，永远限制类的性能。更严重的是，通过暴露其内部，客户端可以直接访问它们。至少，它可能导致混淆语义。例如，属性p指向&lt;code&gt;Properties&lt;/code&gt;实例，那么 &lt;code&gt;p.getProperty(key)&lt;/code&gt;和&lt;code&gt;p.get(key)&lt;/code&gt;就有可能返回不同的结果：前者考虑了默认的属性表，而后者是继承&lt;code&gt;Hashtable&lt;/code&gt;的，它则没有考虑默认属性列表。最严重的是，客户端可以通过直接修改超父类来破坏子类的不变性。在&lt;code&gt;Properties&lt;/code&gt;类，设计者希望只有字符串被允许作为键和值，但直接访问底层的&lt;code&gt;Hashtable&lt;/code&gt;允许违反这个不变性。一旦违反，就不能再使用属性API的其他部分（&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;store&lt;/code&gt;方法）。在发现这个问题的时候，纠正这个问题为时已晚，因为客户端依赖于使用非字符串键和值了。&lt;/p&gt;
&lt;p&gt;在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的API有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的API中？继承传播父类的API中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新API。&lt;/p&gt;
&lt;p&gt;总之，继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 13:55:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8260992.html</dc:identifier>
</item>
<item>
<title>【APS.NET 框架系列】您所经历的，但未必研究的那些技术 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8201129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8201129.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110033829004-2140333139.png&quot; alt=&quot;&quot;/&gt;   &lt;span&gt;本篇文章更适合具有一定开发经验，一定功底，且对底层代码有所研究的朋友！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章稍微偏原理且底层，有一定难度和且比较晦涩，&lt;/span&gt;&lt;span&gt;文章粒度稍微粗些，更细粒度的，会在后续的文章中，结合具体的Demo实例分析。感兴趣的朋友，可以先收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一 .NET框架概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110211304301-1160018928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.作用:提供了基于.NET框架开发的基础平台和模板，为.NET开发的基架;&lt;/p&gt;
&lt;p&gt;2.基本构成:可支持语言，CLS，模板框架，基本模板，基本操作，基本类库，公共需要运行时，CTS和CLS，OS等;&lt;/p&gt;
&lt;p&gt;    (1)可支持语言:.NET框架可支持vb，c++，c＃，F＃，js等语言开发;&lt;/p&gt;
&lt;p&gt;    (2)CLS:通用语言规范，使多种语言开发成为了可能，可参考：https://docs.microsoft.com/en-us/dotnet/standard/language-independence-and-language-independent-components&lt;/p&gt;
&lt;p&gt;    (3)模板框架:B/S模式开发，C/S模式开发，App开发，接口开发&lt;/p&gt;
&lt;p&gt;            B/S:WebForm和MVC，.NET Core；主要是PC运用程序；&lt;/p&gt;
&lt;p&gt;            C/S：Winform和WPF，主要是桌面运用程序；&lt;/p&gt;
&lt;p&gt;            APP：当前主流的一种开发模式；&lt;/p&gt;
&lt;p&gt;    (4)基本操作：对DB操作（ADO.NET和EF），I/O操作等；&lt;/p&gt;
&lt;p&gt;    (5)BCL:基本类库，供调用；&lt;/p&gt;
&lt;p&gt;    (6)CLR:公共语言运行时，是IL形成EXE必不可少的环节，也是JIT实现一次编译，多次且跨平台运行的必不可少的环境，在.NET框架中扮演着及其重要的角色，且技术比较难且晦涩；&lt;/p&gt;
&lt;p&gt;    (7)CTS 和 CLS：CTS，即通用类型系统，实现COM组件兼容等；&lt;/p&gt;
&lt;p&gt;    (8)OS:屏蔽底层实现，高度抽象，OS类型：Win XP（基本淘汰，微软官方都不维护了）、Win 7 ,Win 8,Win 10；&lt;/p&gt;
&lt;p&gt;3..NET两大产品：Dynamic CRM 和SharePoint;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （一）ADO.NET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180109233318863-356650063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.作用:程序与数据交互的方式之一。.NET框架中，ADO.NET抽象化了程序与Database的交互，在进行基本的CRUD操作时，只需调用具体的类，方法即可;&lt;/p&gt;
&lt;p&gt;2.基本构成:主要由五大对象构成。Conneciton对象，DataAdapter对象，Command对象，DataSet对象，DataReader对象构成;&lt;/p&gt;
&lt;p&gt;3.五大对象的基本概述:&lt;/p&gt;
&lt;p&gt;   (1)Connection对象:连接数据库的通道，主要方法为Open()和Close()，前者负责打开数据库入口，后者负责关闭数据库入口;&lt;/p&gt;
&lt;p&gt;   (2)Command对象负责对DB的具体操作，CRUD就是通过它实现的;&lt;/p&gt;
&lt;p&gt;   (3)DataAdapter对象负责将DB与DataSet适配，使基本的CRUD得以实现;&lt;/p&gt;
&lt;p&gt;   (4)DataSet对象扮演虚拟内存的角色，也扮演缓存的角色，是实现Application与DB数据交互的必要环节之一;&lt;/p&gt;
&lt;p&gt;   (5)DataReader主要解决读取数据的问题，性能比较高;&lt;/p&gt;
&lt;p&gt;4.建议:具体详细信息，大家可以参照MSDN，其概述比较详细;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）EF框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110011445238-1484651185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.作用:为程序员提供更加方便快捷的数据操作，对于初级程序员来说，能很快的上手，极其方便(当然，有经验的EF开发人员可能经历过EF的各种坑);&lt;/p&gt;
&lt;p&gt;2.三种模式:DB First，Code First，Model First;&lt;/p&gt;
&lt;p&gt;3.基本构成:操作工具(Linq To Entity，Entity SQL)，ObjectServices，Entity Client，EDM，ADO.NET  Data Provider;&lt;/p&gt;
&lt;p&gt;   (1)Linq To  Entity 和Entity SQL:提供了对数据操作的两种不同方式;&lt;/p&gt;
&lt;p&gt;   (2)ObjectServices:DB访问入口，实现实体与数据的转换;&lt;/p&gt;
&lt;p&gt;   (3)Entity Client:负责将Linq To Entity和Entity SQL转化为标准的SQL;&lt;/p&gt;
&lt;p&gt;   (4)EDM:实现概念模型向存储模型的转换;&lt;/p&gt;
&lt;p&gt;    (5)ADO.NET Data Provider:实现对DB的交互;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）程序编译过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110181734941-967506451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.程序编译过程大致可概述&lt;/p&gt;
&lt;p&gt;2.在控制台中操作&lt;/p&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de829739-9214-4c2c-96d0-aee47ab43505')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de829739-9214-4c2c-96d0-aee47ab43505',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ProgramRunDemo
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sum = AddSum(&lt;span&gt;10.5&lt;/span&gt;, &lt;span&gt;9.5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sum={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sum);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; AddSum(&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110194116535-1441406626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们将AddSum()方法编译成dll文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110200405347-614251704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过反编译工具.NET Reflector查看IL代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110205916551-2057553369.png&quot; alt=&quot;&quot; width=&quot;1313&quot; height=&quot;750&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们用NotePad++编译源代码，用VS的csc.exe编译器编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110203709832-848966578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示：当在Dos命令中中提示：‘csc’不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/p&gt;
&lt;p&gt;请将.net csc.exe 路径添加到系统环境变量中，我的csc.exe路径为&lt;/p&gt;
&lt;p&gt;C:\Windows\Microsoft.NET\Framework64\v4.0.30319&lt;/p&gt;
&lt;p&gt;不会的，可以参照 &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8006731.html&quot;&gt;csc.exe Path路径配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者参照我的另外一篇文章&lt;a href=&quot;https://jingyan.baidu.com/article/14bd256e353139bb6d261230.html&quot;&gt;【java系列】java开发环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110204122863-1351847125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;列举几个比较常用的csc.exe命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译生成 File.exe 的 File.cs&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;csc File.cs 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译生成 File.dll 的 File.cs&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; csc /&lt;span&gt;target:library File.cs
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译 File.cs 并创建 My.exe&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; csc /&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:My.exe File.cs
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译当前目录中的所有 C# 文件，对其进行优化并定义 DEBUG 符号。 输出为 File2.exe&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; csc /define:DEBUG /optimize /&lt;span&gt;out&lt;/span&gt;:File2.exe *&lt;span&gt;.cs
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译当前目录中的所有 C# 文件，生成 File2.dll 的调试版本。 不显示徽标和警告&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; csc /target:library /&lt;span&gt;out&lt;/span&gt;:File2.dll /warn:&lt;span&gt;0&lt;/span&gt; /nologo /debug *&lt;span&gt;.cs
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前目录中的所有 C# 文件编译为 Something.xyz (DLL)&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; csc /target:library /&lt;span&gt;out&lt;/span&gt;:Something.xyz *.cs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于csc.exe的命令，大家可以参照MSDN：&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe&lt;/p&gt;
&lt;p&gt;3.编译过程大致可分为两个阶段：&lt;/p&gt;
&lt;p&gt;第一阶段：.cs代码=&amp;gt;IL代码，这个编译时间比较慢&lt;/p&gt;
&lt;p&gt;第二阶段：IL+dll通过CRL形成目标代码，这个过程比较快&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110205600207-427482029.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;103&quot;/&gt;大家想想：为什么第一阶段比较慢，第二阶段比较快呢？将在下面的IL中讲到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（四）CLR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110181416801-1033725850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.作用:内存管理，异常管理，多线程管理，GC管理等。CLR为.NET中极其重要的组成部分，也是.NET框架中比较难且晦涩技术之一。&lt;/p&gt;
&lt;p&gt;2.可以把CLR看成是Java虚拟机;&lt;/p&gt;
&lt;p&gt;3.JIT即时编译，主要由三部分构成(主编译器，PreJit和EconoJit)&lt;/p&gt;
&lt;p&gt;4.JIT+CLR实现一次编译，多次运行且可跨平台;&lt;/p&gt;
&lt;p&gt;5.CLR中比较重要的一个环节，就是管道(Pipes)(HttpModule和HttpHandler)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （五）MSIL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180109215418207-1793616136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.IL是.cs代码经过VS编译器csc.exe编译而成的；&lt;/p&gt;
&lt;p&gt;2.IL比较接近机器代码但非机器代码（这个特点使其IL=》.exe过程比较快）；&lt;/p&gt;
&lt;p&gt;3.IL代码是指令无关的；&lt;/p&gt;
&lt;p&gt;4.可以通过反汇编工具查看IL代码；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二  基于.NET Framework框架的B/S程序运行解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）总体流程概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110024658535-720818725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1.IIS在处理请求时，将资源分为两大类型：静态资源和动态资源&lt;/p&gt;
&lt;p&gt;     静态资源：IMG,JS,CSS,HTML等；&lt;/p&gt;
&lt;p&gt;     动态文件：ASP,ASP.NET,.aspx,..ashx,asax等；&lt;/p&gt;
&lt;p&gt; 2.IIS处理静态资源：&lt;/p&gt;
&lt;p&gt;    当IIS收到来自浏览器的请求，识别为静态资源时，IIS直接处理，将处理结果以HTML形式返回给浏览器；&lt;/p&gt;
&lt;p&gt; 3.IIS如何处理动态资源？&lt;/p&gt;
&lt;p&gt;   当IIS收到来自浏览器的请求，识别为动态资源时，此时IIS不能处理，转交给ISAPI Extensions（ISAPI 扩展程序）扩展程序，该扩展程序根据请求资源扩展名，寻找响应的程序处理，如为.asp文件，则asp_isapi处理&lt;/p&gt;
&lt;p&gt;,若为.aspx,则aspnet_isapi处理，&lt;/p&gt;
&lt;p&gt; 4.IIS如何处理WebForm和MVC？&lt;/p&gt;
&lt;p&gt;  当IIS收到来自浏览器的请求，识别为动态资源时，此时IIS不能处理，转交给ISAPI Extensions处理，此时ASP.NET MVC HTTP处理程序识别请求资源是否为MVC，若是，则交给MVC路由，按照处理MVC方式处理，否则&lt;/p&gt;
&lt;p&gt;，按照WebForm流程处理；&lt;/p&gt;
&lt;p&gt;5.CLR里面的管道（Pipes）是怎样的呢？&lt;/p&gt;
&lt;p&gt;   管道的本质是HttpModule和HttpHandler(一般处理程序.ashx);&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （二）CLR和Pipe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110021131754-1794923343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （三）TCP/IP模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110031440926-2096843504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 1.这个结构为当前比较标准的TCP/IP五层模型，在五层模型成为通用规范前，有七层模型和四层模型两大种类；&lt;/p&gt;
&lt;p&gt; 2.关于这五层，谢希仁编写的《计算机网络》讲得比较详细且透彻，感兴起的朋友可以去看看；&lt;/p&gt;
&lt;p&gt; 3.为什么要提到TCP/IP呢？很简单，我们在浏览器输入：http://www.google.com.hk/，发生了过程中，TCP/IP就不可或缺；&lt;/p&gt;
&lt;p&gt; 4.在这里不多讲，会在后续文章WebApi和HTTP协议中详细讲解；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【01】http://www.wrox.com/&lt;/p&gt;
&lt;p&gt;【02】&lt;img src=&quot;file:///C:/Users/Alan_beijing/AppData/Roaming/Tencent/QQ/Temp/%25W@GJ$ACOF(TYDYECOKVDYB.png&quot; alt=&quot;&quot;/&gt;http://msdn.microsoft.com/en-us/library/system.web.httpapplication(v=vs.80).aspx&lt;/p&gt;
&lt;p&gt;【03】ASP.NET MVC5 高级编程(Jon Galloway,Brad Wilson,K.Scott Allen,David Matson 著 ,孙远帅 译)&lt;/p&gt;
&lt;p&gt;【04】ASP.NET MVC5编程实战（第3版）（Dino Esposite 著，潘丽丞 译）&lt;/p&gt;
&lt;p&gt;【05】ASP.NET MVC4 开发指南   （黄保翕 作）&lt;/p&gt;
&lt;p&gt;【06】计算机网络 （第6版）（谢希仁 著）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四   版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2016177728@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 10 Jan 2018 13:52:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8201129.html</dc:identifier>
</item>
<item>
<title>类和对象的创建过程（元类，__new__,__init__,__call__） - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/8260151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/8260151.html</guid>
<description>&lt;h2&gt;1、创建类的两种方式&lt;/h2&gt;
&lt;h3&gt;方式一&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self,name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)

myc &lt;/span&gt;=&lt;span&gt; MyClass()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(MyClass, type(MyClass))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myc, type(myc))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建了一个名为MyClass的类，并实例化了这个类，得到其对象myc&lt;/p&gt;
&lt;p&gt;上面代码打印的结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;    &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.MyClass object at 0x0288F8F0&amp;gt;   &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;type()&lt;/code&gt;函数可以查看一个类型或变量的类型，&lt;code&gt;MyClass&lt;/code&gt;是一个class，它的类型就是&lt;code&gt;type&lt;/code&gt;，而&lt;code&gt;h&lt;/code&gt;是一个实例，它的类型就是class &lt;code&gt;myc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们说class的定义是运行时动态创建的，而创建class的方法就是使用&lt;code&gt;type()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;type()&lt;/code&gt;函数既可以返回一个对象的类型，又可以创建出新的类型&lt;/span&gt;，比如，我们可以通过&lt;code&gt;type()&lt;/code&gt;函数创建出&lt;code&gt;MyClass&lt;/code&gt;类，而无需通过&lt;code&gt;Class MyClass(object)...&lt;/code&gt;的定义：&lt;/p&gt;

&lt;h3&gt;方式二&lt;/h3&gt;
&lt;p&gt;动态创建类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; fn(self, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先定义函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, %s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; name)

MyClass &lt;/span&gt;= type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, (object,), {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:fn}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建MyClass类,得到一个type的类对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; MyClass = type('MyClass', (object,), {'func':lambda self,name:name}) # 创建MyClass类&lt;/span&gt;
&lt;span&gt;
myc&lt;/span&gt;=&lt;span&gt;MyClass()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(MyClass, type(MyClass))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myc, type(myc))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; 　　&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.MyClass object at 0x0364B830&amp;gt; 　　&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要创建一个class对象，&lt;span&gt;&lt;code&gt;type()&lt;/code&gt;函数依次传入3个参数：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;class的名称；&lt;/li&gt;
&lt;li&gt;继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；&lt;/li&gt;
&lt;li&gt;class的方法名称与函数绑定，这里我们把函数&lt;code&gt;fn&lt;/code&gt;绑定到方法名&lt;code&gt;func&lt;/code&gt;上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过&lt;code&gt;type()&lt;/code&gt;函数创建的类和直接写class是完全一样的&lt;/span&gt;，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用&lt;code&gt;type()&lt;/code&gt;函数创建出class。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;type就是创建类对象的类。&lt;/span&gt;&lt;/strong&gt;你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类(元类，默认为type，也可以自定制)创建而来。type也是由type创建。。&lt;/p&gt;


&lt;p&gt;除了使用&lt;code&gt;type()&lt;/code&gt;动态创建类以外，要控制类的创建行为，还可以使用metaclass。&lt;/p&gt;
&lt;p&gt;metaclass，直译为元类，简单的解释就是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义元类（不自定义时，默认用type），然后创建类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;连接起来就是：&lt;span&gt;先定义metaclass，就可以创建类，最后创建实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是元类创建出来的“实例”。&lt;/p&gt;

&lt;h2&gt;使用metaclass的两种方式&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):　　&lt;span&gt;# 自定义一个type的派生类
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,*args,**&lt;span&gt;kwargs):
       super(MyType,self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(*args,**&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= cls.&lt;span&gt;__new__&lt;/span&gt;(cls,*args, **&lt;span&gt;kwargs)
        cls.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(obj,*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; with_metaclass(base):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,(base,),{})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式一&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):　　&lt;span&gt;# metaclass=MyType,即指定了由MyType创建Foo类，当程序运行，用到class Foo时，即调用MyType的__init__方法，创建Foo类
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo __init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.name &lt;/span&gt;=&lt;span&gt; name


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;方式二    在Flask的wtform的源码中用到过&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; class Foo(with_metaclass(object)):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     def __init__(self,name):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         print('Foo __init__')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         self.name = name&lt;/span&gt;
&lt;span&gt;

a&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 方式一没什么好说的，在这里，说一下，方式二&lt;/p&gt;
&lt;p&gt;方式二中，首先执行with_metaclass函数，即用type的派生类，创建了一个对象，该对象是一个名为‘MyType’的类，然后我们创建的Foo类继承了这个MyType&lt;/p&gt;



&lt;p&gt;__new__： 对象的创建，是一个静态方法，第一个参数是cls。(想想也是，不可能是self，对象还没创建，哪来的self)&lt;/p&gt;
&lt;p&gt;　　　　　 其&lt;span&gt;必须要有返回值，返回实例化出来的实例&lt;/span&gt;，需要注意的是，可以return父类__new__()出来的实例，也可以直接将object的__new__()出来的实例返回。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;__init__ ： 对象的初始化， 是一个实例方法，第一个参数是self，该self参数就是__new__()返回的实例，__init__()在__new__()的基础上可以完成一些其它初始化的动作，__init__()不需要返回值。&lt;br/&gt;__call__ ： 对象可call，注意不是类，是对象。&lt;/p&gt;
&lt;h2&gt;1.对于__new__&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Bar()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo()) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Bar object at 0x0090F930&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到，输出来是一个Bar对象。&lt;/p&gt;
&lt;p&gt;　　__new__方法在类定义中不是必须写的，如果没定义，默认会调用object.__new__去创建一个对象。如果定义了，就是会覆盖,使用自定义的，这样就可以自定制创建对象的行为。&lt;/p&gt;
&lt;p&gt; 单例模式也可以通过这种方式来创建。&lt;a href=&quot;http://www.cnblogs.com/huchong/p/8244279.html#_lab2_1_2&quot; target=&quot;_blank&quot;&gt;点击查看【几种单例模式的创建方法】&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.对于__init__&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):

  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
    self.name &lt;/span&gt;=&lt;span&gt; name
    self.age &lt;/span&gt;=&lt;span&gt; age
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
      obj &lt;/span&gt;= object.&lt;span&gt;__new__&lt;/span&gt;(cls) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象&lt;/span&gt;
      &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行__new__方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

p1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(p1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;执行__new__方法
执行__init__
&lt;/span&gt;&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Person object at 0x028EB830&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　__init__ 方法通常用在初始化一个类实例的时候，但__init__其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是 __new__ 方法。从打印结果就可以看出来&lt;/p&gt;
&lt;p&gt;　　若__new__()没有正确返回当前类cls的实例，那__init__()将不会被调用，即使是父类的实例也不行。&lt;/p&gt;

&lt;h2&gt;3.对于__call__&lt;/h2&gt;
&lt;p&gt;　　对象通过提供__call__(slef, *args ,**kwargs)方法可以模拟函数的行为，如果一个对象x提供了该方法，就可以像函数一样使用它，也就是说x(arg1, arg2...) 等同于调用x.__call__(self, arg1, arg2) 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object): 
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self): 
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt; 
 
f &lt;/span&gt;= Foo()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;类()，即执行元类的__call__&lt;/span&gt;
f()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对象()，即执行Foo的__call__ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(Bar):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们写如这段代码时，Python做了如下的操作：&lt;/p&gt;
&lt;p&gt;　　Foo中有metaclass这个属性吗？如果是，Python会在内存中通过metaclass创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到metaclass，它会继续在Bar（父类）中寻找metaclass属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到metaclass，它就会在模块层次中去寻找metaclass，并尝试做同样的操作。如果还是找不到metaclass,Python就会用内置的type来创建这个类对象。&lt;/p&gt;
&lt;p&gt;　　把上面这段话反复读几次，现在的问题就是，你可以在metaclass中放置些什么代码呢？&lt;/p&gt;
&lt;p&gt;　　答案就是：可以创建一个类的东西。&lt;/p&gt;
&lt;p&gt;　　那么什么可以用来创建一个类呢？&lt;/p&gt;
&lt;p&gt;　　type，或者任何使用到type或者子类化type的东东都可以。&lt;/p&gt;

&lt;p&gt;以上面的代码为例，我们实例化一个对象obj=Foo()时，会先执行Foo类的__new__方法，没写时，用父类的__new__方法，创建一个对象，并返回，然后执行__init__方法（自己有就用自己的，没有就用父类的），对创建的对象进行初始化。&lt;/p&gt;
&lt;p&gt;obj()会执行Foo类的__call__方法，没有则用父类的&lt;/p&gt;
&lt;p&gt;我们现在已经知道，类也是对象，是元类的对象，即我们实例化一个类时，调用其元类的__call__方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;元类处理过程：定义一个类时，使用声明或者默认的元类对该类进行创建，&lt;/strong&gt;对元类求type运算，得到父元类（该类声明的元类的父元类），调用父元类的__call__函数，在父元类的__call__函数中, 调用该类声明的元类的__new__函数来创建对象（该函数需要返回一个对象（指类）实例），然后再调用该元类的__init__初始化该对象（此处对象是指类，因为是元类创建的对象），最终返回该类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.对象是类创建，创建对象时候类的__init__方法自动执行，对象()执行类的 __call__ 方法&lt;br/&gt;2.类是type创建，创建类时候type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;原始type的__call__应该是参数结构应该是：

　　metaname, clsname, baseclasses, attrs

 

原始type的__new__

　　metaname, clsname, baseclasses, attrs

 

原始type的__init__

　　class_obj, clsname, baseclasses, attrs

 

元类的__new__和__init__影响的是创建类对象的行为，父元类的__call__控制对子元类的 &lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;，&lt;span&gt;__init__的调用&lt;/span&gt;&lt;span&gt;，就是说控制类对象的创建和初始化。父元类的__new__和__init__由更上层的控制，

　　　　一般来说，原始type是最初的父元类，其__new__和__init__是具有普遍意义的，即应该是分配内存、初始化相关信息等

元类__call__影响的是创建类的实例对象的行为，此时如果类自定义了__new__和__init__就可以控制类的对象实例的创建和初始化

 

&lt;/span&gt;&lt;span&gt;__new__和__init__&lt;/span&gt;&lt;span&gt; 影响的是创建对象的行为，当这些函数在元类中时，影响创建的是类；同理，当这俩个函数在普通类中时，影响创建的是普通的对象实例。

&lt;/span&gt;&lt;span&gt;__call__&lt;/span&gt; 影响()调用行为, &lt;span&gt;__call__是在创建类的时候调用&lt;/span&gt;，即: &lt;span&gt;class&lt;/span&gt; Test(object): &lt;span&gt;__metaclass__&lt;/span&gt;=&lt;span&gt;type, 定义类时就是创建类，此时会调用元类的__call__，如果元类有继承，子元类定义时执行的是父元类的__call__。

             如果是普通类实例化对象，调用的是普通类的__call__

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 10 Jan 2018 11:18:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/8260151.html</dc:identifier>
</item>
<item>
<title>Spark源码分析 之 Driver和Excutor是怎么跑起来的?(2.2.0版本) - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/8260362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/8260362.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今天抽空回顾了一下Spark相关的源码，本来想要了解一下Block的管理机制，但是看着看着就回到了SparkContext的创建与使用。正好之前没有正式的整理过这部分的内容，这次就顺带着回顾一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容参考：&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/6195422.html&quot;&gt;我的大数据之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spark作为目前最流行的大数据计算框架，已经发展了几个年头了。版本也从我刚接触的1.6升级到了2.2.1。由于目前工作使用的是2.2.0，所以这次的分析也就从2.2.0版本入手了。&lt;/p&gt;
&lt;p&gt;涉及的内容主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Standalone模式中的Master与Worker&lt;/li&gt;
&lt;li&gt;client、driver、excutor的关系&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就按照顺序依次介绍一下。&lt;/p&gt;

&lt;p&gt;在最开始编程的时候，很少会涉及分布式，因为数据量也不大。后来随着硬件的发展cpu的瓶颈，开始流行多线程编程，基于多线程来加快处理速度；再后来，衍生出了网格计算、CPU与GPU的异构并行计算以及当时流行的mapreduce分布式计算。但是mapreduce由于存储以及计算流程的限制，spark开始流行起来。Spark凭借内存计算、强大的DAG回溯能力，快速的占领并行计算的风口。&lt;/p&gt;
&lt;p&gt;那么并行计算肯定是需要分布式集群的，常见的集群管理方式，有Master-Slave模式、P2P模式等等。&lt;/p&gt;
&lt;p&gt;比如Mysql的主从复制，就是Master-Slave模式；Elasticsearch的分片管理就是P2P模式。在Spark中有不同的部署方式，但是计算的模式都是Master-Slave模式，只不过Slave换了名字叫做worker而已。集群的部署模式如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/449064/201801/449064-20180110190943926-1345296787.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程就是用户以client的身份向master提交任务，master去worker上面创建执行任务的载体（driver和excutor）。&lt;/p&gt;

&lt;p&gt;Master和Worker是服务器的部署角色，程序从执行上，则分成了client、driver、excutor三种角色。按照模式的不同，client和driver可能是同一个。以2.2.0版本的standalone模式来说，他们三个是独立的角色。client用于提交程序，初始化一些环境变量；driver用于生成task并追踪管理task的运行；excutor负责最终task的执行。&lt;/p&gt;

&lt;p&gt;总的流程可以总结为下面的一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/449064/201801/449064-20180110191008113-1700099823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过查看源码，来看一下&lt;/p&gt;
&lt;h2 id=&quot;sparkcontext创建调度器&quot;&gt;1 SparkContext创建调度器&lt;/h2&gt;
&lt;p&gt;在创建SparkContext的时候会创建几个核心的模块：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DAGScheduler 面向job的调度器&lt;/li&gt;
&lt;li&gt;TaskScheduler 不同的集群模式，有不同的实现方式，如standalone下的taskschedulerImpl&lt;/li&gt;
&lt;li&gt;SchedulerBackend 不同的集群模式下，有不同的实现方式，如standalone下的StandaloneSchedulerBackend.负责向master发起注册&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 创建并启动调度器
val (sched, ts) = SparkContext.createTaskScheduler(this, master, deployMode)
_schedulerBackend = sched
_taskScheduler = ts
_dagScheduler = new DAGScheduler(this)
...
// 启动调度器
_taskScheduler.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在createTaskSchduler中，根据master的不同，选择不同的实现方式，主要是在backend的实现上有差异：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;master match {
      case &quot;local&quot; =&amp;gt;
        ...

      case LOCAL_N_REGEX(threads) =&amp;gt;
        ...

      case LOCAL_N_FAILURES_REGEX(threads, maxFailures) =&amp;gt;
        ...

      case SPARK_REGEX(sparkUrl) =&amp;gt;
        // 创建调度器
        val scheduler = new TaskSchedulerImpl(sc)
        val masterUrls = sparkUrl.split(&quot;,&quot;).map(&quot;spark://&quot; + _)
        // 创建backend
        val backend = new StandaloneSchedulerBackend(scheduler, sc, masterUrls)
        // 把backend注入到schduler中
        scheduler.initialize(backend)
        (backend, scheduler)

      case LOCAL_CLUSTER_REGEX(numSlaves, coresPerSlave, memoryPerSlave) =&amp;gt;
        ...

      case masterUrl =&amp;gt;
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里只看一下standalone模式的创建，就是创建了TaskSchedulerImpl和StandaloneSchedulerBackend的对象，另外初始化了调度器，根据配置选择调度模式，默认是FIFO:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initialize(backend: SchedulerBackend) {
    this.backend = backend
    schedulableBuilder = {
      schedulingMode match {
        case SchedulingMode.FIFO =&amp;gt;
          new FIFOSchedulableBuilder(rootPool)
        case SchedulingMode.FAIR =&amp;gt;
          new FairSchedulableBuilder(rootPool, conf)
        case _ =&amp;gt;
          throw new IllegalArgumentException(s&quot;Unsupported $SCHEDULER_MODE_PROPERTY: &quot; +
          s&quot;$schedulingMode&quot;)
      }
    }
    schedulableBuilder.buildPools()
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;taskschedulerimpl执行start方法&quot;&gt;2 TaskSchedulerImpl执行start方法&lt;/h2&gt;
&lt;p&gt;其实是执行了backend的start()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def start() {
    backend.start()
    ...
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;standaloneschedulerbackend执行start方法&quot;&gt;3 StandaloneSchedulerBackend执行start方法&lt;/h2&gt;
&lt;p&gt;这部分代码比较多，可以简化的看：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装command对象&lt;/li&gt;
&lt;li&gt;封装appDesc对象&lt;/li&gt;
&lt;li&gt;创建StandaloneAppClient对象&lt;/li&gt;
&lt;li&gt;执行start()方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中command中包含的那个类，就是excutor的实现类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def start() {
    //初始化参数
    ...
    
    val command = Command(&quot;org.apache.spark.executor.CoarseGrainedExecutorBackend&quot;,
      args, sc.executorEnvs, classPathEntries ++ testingClassPath, libraryPathEntries, javaOpts)
   ...
    val appDesc = ApplicationDescription(sc.appName, maxCores, sc.executorMemory, command,
      webUrl, sc.eventLogDir, sc.eventLogCodec, coresPerExecutor, initialExecutorLimit)
    // 注意前面创建了一大堆的配置对象，主要就是那个class等信息
    client = new StandaloneAppClient(sc.env.rpcEnv, masters, appDesc, this, conf)
    client.start()
    ...
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;发起注册&quot;&gt;4 发起注册&lt;/h2&gt;
&lt;p&gt;核心的代码在StanaloneAppClient中，并在start()方法中启动了一个rpc的服务——ClientEndpoint&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def onStart(): Unit = {
  try {
    registerWithMaster(1)//发起注册
  } catch {
    ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;registerWithMaster采用了异步发送请求连接master，只要有一个注册成功，其他的都会cancel。这里有时间可以做个小hello world玩玩看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private def registerWithMaster(nthRetry: Int) {
  registerMasterFutures.set(tryRegisterAllMasters())
  registrationRetryTimer.set(registrationRetryThread.schedule(new Runnable {
    override def run(): Unit = {
      if (registered.get) {
        registerMasterFutures.get.foreach(_.cancel(true))
        registerMasterThreadPool.shutdownNow()
      } else if (nthRetry &amp;gt;= REGISTRATION_RETRIES) {
        markDead(&quot;All masters are unresponsive! Giving up.&quot;)
      } else {
        registerMasterFutures.get.foreach(_.cancel(true))
        registerWithMaster(nthRetry + 1)
      }
    }
  }, REGISTRATION_TIMEOUT_SECONDS, TimeUnit.SECONDS))
}
//发起注册
private def tryRegisterAllMasters(): Array[JFuture[_]] = {
  ...
  masterRef.send(RegisterApplication(appDescription, self))
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;master接收到请求执行schedule方法&quot;&gt;5 Master接收到请求执行schedule方法&lt;/h2&gt;
&lt;p&gt;Master是一个常驻的进程，时刻监听别人发过来的消息。刚才client发送了一个RegisterApplication消息，忽略前面创建app的内容，直接执行了schedule方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case RegisterApplication(description, driver) =&amp;gt;
   // TODO Prevent repeated registrations from some driver
   if (state == RecoveryState.STANDBY) {
     // ignore, don't send response
   } else {
     ...
     schedule()
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;master发送launchdriver&quot;&gt;6 Master发送launchDriver&lt;/h2&gt;
&lt;p&gt;发送lanunchDriver请求&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private def schedule(): Unit = {
  ...
  for (driver &amp;lt;- waitingDrivers.toList) { // iterate over a copy of waitingDrivers
    ...
    while (numWorkersVisited &amp;lt; numWorkersAlive &amp;amp;&amp;amp; !launched) {
      ...
      if (worker.memoryFree &amp;gt;= driver.desc.mem &amp;amp;&amp;amp; worker.coresFree &amp;gt;= driver.desc.cores) {
        launchDriver(worker, driver)
        ...
      }
      ...
    }
  }
  startExecutorsOnWorkers()
}
//向worker发送launchDriver请求
private def launchDriver(worker: WorkerInfo, driver: DriverInfo) {
  ...
  worker.endpoint.send(LaunchDriver(driver.id, driver.desc))
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;worker创建driverrunner&quot;&gt;7 Worker创建DriverRunner&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;case LaunchDriver(driverId, driverDesc) =&amp;gt;
      logInfo(s&quot;Asked to launch driver $driverId&quot;)
      val driver = new DriverRunner(
        conf,
        driverId,
        workDir,
        sparkHome,
        driverDesc.copy(command = Worker.maybeUpdateSSLSettings(driverDesc.command, conf)),
        self,
        workerUri,
        securityMgr)
      drivers(driverId) = driver
      driver.start()

      coresUsed += driverDesc.cores
      memoryUsed += driverDesc.mem&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;master发送launchexcutor&quot;&gt;8 Master发送launchExcutor&lt;/h2&gt;
&lt;p&gt;第6步中最后有一个startExecutorsOnWorkers方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private def startExecutorsOnWorkers(): Unit = {
...
  for (app &amp;lt;- waitingApps if app.coresLeft &amp;gt; 0) {
    ...
    for (pos &amp;lt;- 0 until usableWorkers.length if assignedCores(pos) &amp;gt; 0) {
      allocateWorkerResourceToExecutors(
        app, assignedCores(pos), coresPerExecutor, usableWorkers(pos))
    }
  }
}

private def allocateWorkerResourceToExecutors(
   app: ApplicationInfo,
   assignedCores: Int,
   coresPerExecutor: Option[Int],
   worker: WorkerInfo): Unit = {
 ...
 for (i &amp;lt;- 1 to numExecutors) {
   ...
   launchExecutor(worker, exec)
   ...
 }
}

private def launchExecutor(worker: WorkerInfo, exec: ExecutorDesc): Unit = {
  ...
  worker.endpoint.send(LaunchExecutor(masterUrl,
    exec.application.id, exec.id, exec.application.desc, exec.cores, exec.memory))
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;worker创建excutorrunner&quot;&gt;9 Worker创建ExcutorRunner&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;case LaunchExecutor(masterUrl, appId, execId, appDesc, cores_, memory_) =&amp;gt;
if (masterUrl != activeMasterUrl) {
  ...
} else {
  try {
    ...
    val manager = new ExecutorRunner(
      appId,
      execId,
      appDesc.copy(command = Worker.maybeUpdateSSLSettings(appDesc.command, conf)),
      cores_,
      memory_,
      self,
      workerId,
      host,
      webUi.boundPort,
      publicAddress,
      sparkHome,
      executorDir,
      workerUri,
      conf,
      appLocalDirs, ExecutorState.RUNNING)
    ...
  } catch {
...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，Driver和Excutor就启动起来了.....&lt;/p&gt;
&lt;p&gt;之后代码是怎么运行的，就且听下回分解把！&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;SparkContext &lt;a href=&quot;http://www.cnblogs.com/jcchoiling/p/6427406.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jcchoiling/p/6427406.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;spark worker解密：&lt;a href=&quot;http://www.cnblogs.com/jcchoiling/p/6433196.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jcchoiling/p/6433196.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2.0源码&lt;/li&gt;
&lt;li&gt;《Spark内核机制及性能调优》· 王家林&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 10 Jan 2018 11:13:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/8260362.html</dc:identifier>
</item>
<item>
<title>iPhone X 适配(全) - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/8260182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/8260182.html</guid>
<description>&lt;p&gt;iPhone X 刘海机于9月13日发布，给科技小春晚带来一波高潮。作为开发人员却多出来一份忧虑，iPhone X 怎么适配？我们 App 的脑袋会不会也长一刘海出来？Tabbar 会不会被圆角？先来看一下美团 App 的表现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9701.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9702.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;图 1.1 启动时的 App 表现           图 1.2 下拉刷新之后的表现&lt;/p&gt;
&lt;/center&gt;
&lt;br/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9703.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9704.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;br/&gt;&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;图 1.3 搜索的表现          图 1.4 “我的Tab”表现&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;在图1.1中乍一看表现还不错，可是在图1.2中，下拉刷新之后，我们的导航栏还是被刘海挡住了。搜索也中枪，搜索首页没有办法取消，“热门搜索区域”也多出来一块儿空白。另外，“我的Tab”页部分如图1.3、图1.4所示，导航栏回不去了，右上角的三个UIBarButtonItem也不见了。其他还有很多UI上的Bug，等着我们去一一发现并修改。&lt;/p&gt;
&lt;p&gt;针对可能出现的问题，苹果在 &lt;a href=&quot;https://developer.apple.com/iphone/&quot;&gt;developer.apple.com&lt;/a&gt; 上给出了一些建议。其中一个是 &lt;a href=&quot;https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/&quot;&gt;HIG (Human Interface Guideline)&lt;/a&gt;。另外 WWDC 会议官方 App 的作者，也给出了适配时的一些&lt;a href=&quot;https://developer.apple.com/videos/play/fall2017/201/&quot;&gt;经验&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们来看看他们是怎么说的。&lt;/p&gt;
&lt;h2 id=&quot;hig-&quot;&gt;HIG部分&lt;/h2&gt;
&lt;p&gt;首先看一下各个机型尺寸的变化。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9705.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 2.1 各版本 iPhone 的尺寸&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;下图是 iPhone X 对比其他机型的变化部分。iPhone X 和 iPhone 8 的宽度一致，在垂直方向上多了145pt，这就意味着首页可以展示更多的内容，多出来的这20%的垂直空间，也许可以挂上更高价值的运营位。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9706.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图2.2 iPhone X 和其他设备的尺寸对比&lt;/p&gt;
&lt;/center&gt;
&lt;h3 id=&quot;-&quot;&gt;布局&lt;/h3&gt;
&lt;p&gt;注意图2.2蓝色部分，你会发现这些都算在了展示内容的区域。所以我们在设计的时候，要避免内容被圆角、刘海给挡住。Like this：&lt;/p&gt;
&lt;center readability=&quot;5&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9707.png&quot; alt=&quot;&quot; width=&quot;50%&quot;/&gt;&lt;p&gt;图 2.3 CGRectMake(0,0,100,100)&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;iPhone X 的坐标系统以及能显示内容的区域如下图所示：&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9708.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 2.4 iPhone X 的显示区域&lt;/p&gt;
&lt;/center&gt;
&lt;h3 id=&quot;status-bar&quot;&gt;Status Bar&lt;/h3&gt;
&lt;p&gt;iPhone X 上的 StatusBar 高度比之前的 iPhone 高一些，也就是说，我们如果写死20pt高度的 frame 布局，都要大面积修(tu)改(xue)。在 iPhone X 上，通过打印 [[UIApplication sharedApplication] statusBarFrame] 可以看到，高度是44pt。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9709.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 2.5 iPhone X 的状态栏高度&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&quot;如果你的 App 是隐藏 StatusBar 的，建议重新考虑。iPhone X 为用户在垂直空间上提供了更多展示余地，且状态栏中也包含了用户需要知道的信息，除非能通过隐藏状态栏带给用户额外的价值，否则苹果建议大家将状态栏还给用户。&quot;&lt;/p&gt;
&lt;p&gt;另外还有一点，用户在使用 iPhone X 打电话的时候，StatusBar 的高度也不会发生变化了。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;屏幕底部&lt;/h3&gt;
&lt;p&gt;因为没有了 Home 键，iPhone X 的底部是预留给系统功能的一个区域 - Home Indicator，这部分的高度是34pt。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9710.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 2.6 iPhone X 的 Home Indicator 区域&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;“如果你的底部是 TabBar，那么 Home Indicator 背景会来自于 TabBar 背景的延伸，如果我们是一个 feed 流的页面，那么底部会展示 feed 流的局部。”&lt;/p&gt;
&lt;p&gt;意思是如果有 TabBar，那么那个区域会延展你的 barTintColor；没有的话，就显示透明的（参照 Setting）。之所以这么设计，是为了让 indicator 清晰可见，告诉用户你可以滑动这部分区域。所以苹果不建议我们的 UI 元素过于靠近这部分区域。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9711.png&quot; alt=&quot;&quot; width=&quot;50%/&quot;/&gt;&lt;p&gt;图 2.7 有 TabBar 的 Home Indicator 区&lt;/p&gt;
&lt;/center&gt;
&lt;h3 id=&quot;safearea&quot;&gt;SafeArea&lt;/h3&gt;
&lt;p&gt;iOS 11 废弃了 iOS 7 之后出现的 topLayoutGuide/bottomLayoutGuide，取而代之的是safeLayoutGuide 概念。我们的UI元素都应该布局在这些区域之内，避免被各种 bar（NavgationBar、ToolBar、TabBar、StatusBar）遮挡。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9712.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9713.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图2.8 iPhone 的 SafeArea&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;如果我们用了 AutoLayout，并且开启了 safeAreaLayoutGuide，布局会自动加上这些 safeLayoutGuide，你的视图不会超出这部分 SafeArea。如2.9所示，如果你需要增加 Guide 的区域，那么可以设置 self.additionalSafeAreaInsets 来增加区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9714.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9715.png&quot; alt=&quot;&quot; width=&quot;30%&quot;/&gt;&lt;/p&gt;
&lt;center readability=&quot;5&quot;&gt;
&lt;p&gt;图 2.9 默认的 SafeArea 和 self.additionalSafeAreaInsets = UIEdgeInsetsMake(64, 0, 0, 0);&lt;/p&gt;
&lt;/center&gt;
&lt;h3 id=&quot;-&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;还有其他的一些改变，比如图片的 Aspect Ratio 在 iPhone X 上的表现也会有所不同了；&lt;/p&gt;
&lt;p&gt;刘海两边的区域都能响应不同的手势，最好不要和自己的 App 发生冲突。&lt;/p&gt;
&lt;h2 id=&quot;-session-201-&quot;&gt;来自Session 201的建议&lt;/h2&gt;
&lt;p&gt;① xib 里适配 iPhone X 的话，可以开启 UseSafeAreaLayoutGuides（但这需要在 iOS 9 之后才能用，需要看你的 App 最低支持的版本）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9716.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图3.1 xib 属性&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;② 如果用的系统 SearchViewController，发现没有灰色蒙层了，可以这么试试。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9717.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图3.2 iOS 11 UISearchViewController适配&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;之所以可以这么改，是因为 iOS 11 的 NavigationBar 和 SearchViewController 集成在一块儿了。&lt;/p&gt;
&lt;p&gt;③ 横屏下的 UITableView，SenctionHeader 的背景颜色不是设置的那个颜色。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9718.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图3.3 iOS 11 横屏 Tableview 的作用方式&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;这个问题的原因是：&lt;/strong&gt;横屏下的 UITableView，Cell 都是和屏幕一样宽，但是 Cell 的 ContentView 会被 inset 到 SafeArea 区域。&lt;br/&gt;&lt;strong&gt;解决方法是：&lt;/strong&gt;可以通过调整 Tableview 的默认行为，改变 contentView 的属性（如上图 inset To SafeArea）来让 contentview 顶到边缘，弊端是会改变整个 cell 的内容显示，而且 contentView 的 layoutMargin 依然还是相对于 SafeArea 的。&lt;br/&gt;&lt;strong&gt;最佳方案是：&lt;/strong&gt;改变 UITableViewHeaderFooterView.backgroundView 的 backgroundColor。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9719.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9720.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图3.4 iOS 11 修改前后的样式对比&lt;/p&gt;
&lt;/center&gt;
&lt;h2 id=&quot;-&quot;&gt;刘海打理初体验&lt;/h2&gt;
&lt;p&gt;① 我们来看下开头说的那个刷新之后首页顶上去的问题怎么处理。经过排查，这个问题属于&lt;strong&gt;“状态栏变高系列”&lt;/strong&gt;，解决方案就是把固定的20pt高度改成 &lt;strong&gt;[[UIApplication sharedApplication] statusBarFrame].size.height]&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;② 搜索页面输入框的位置发生了偏移，这是因为 iOS 11 的导航栏的视图层级结构发生了变化，和 iPhone X 的并无直接关系。iOS 11 导航栏的视图层级关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9721.png&quot; alt=&quot;&quot; width=&quot;40%&quot;/&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9722.png&quot; alt=&quot;&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;图4.1 iOS 11 之后的 NavigationBar     图4.2 iOS 11 之前的 NavigationBar&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;适配方式是：&lt;/strong&gt;取到这个 _UIButtonBarStackView 的位置和尺寸信息，然后更改 PFBNavigationBarContainerView 的 X 坐标。&lt;/p&gt;
&lt;p&gt;③ “我的Tab” 页面多出来一块儿灰色的区域，经过排查发现这个是 Tableview 的背景色。也就是说其实是 Tableview 向下偏移了。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9723.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图4.3 iOS11 下“我的Tab” 页面 Tableview 发生偏移&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;出现这个的原因是：&lt;/strong&gt;iOS 11 之后 scrollview 多出来一个 adjustedContentInset 区域。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9724.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 4.4 iOS 11下 ScrollView 的新属性&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;通过打印这个值，我们发现正好和 contentoffset.y 相符合。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9725.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 4.5 这个新属性在 iPhone X 上的值&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;那为什么会发生偏移？这个偏移的值又是怎么确定的？&lt;strong&gt;其实是当 Tableview 的 frame 超出了 safeArea 范围之后，系统会调整内容的位置。系统通过设置 adjustedContentInset 为 safeAreaInset 的值让 Tableview 偏移&lt;/strong&gt;。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9726.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;图 4.6 iPhone X 上 safeAreaInset 的值&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;注意一下这个 adjustedContentInset 是 readOnly 的属性。我们可以通过设置 &lt;strong&gt;Tableview.contentInsetAdjustmentBehavior=UIScrollViewContentInsetAdjustmentNever&lt;/strong&gt; 来纠正这个位置。当然还可以通过设置 tableview.contentOffset 来抵消这个值，但还是推荐第一种。&lt;/p&gt;
&lt;p&gt;④ “我的Tab” 导航栏上，右边那个按钮全都发生了偏移，导致无法点击。这个问题也是在新的导航栏结构视图下会出现，原因是新的导航栏结构用了 AutoLayout 布局，我们这个并不是用常规的 UIBarButtonItem 方式实现的，而是一个 UIBarButtonItem ，他的 customView 包含了三个 Button，这几个 Button 都是 frame 布局，从而导致了在 AutoLayout 下的布局问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正常的解决方式是：&lt;/strong&gt;修改成一个一个添加 UIBarButtonItem 和 UIBarButtonSystemItemFixedSpace。但是这样引出来另外一个问题，iOS 11 之前那种设置负宽度的 fixedspace 来调整间距的 trick 方式已经失效了！详情见&lt;a href=&quot;https://forums.developer.apple.com/thread/80075&quot;&gt;https://forums.developer.apple.com/thread/80075&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们这边的方式是：&lt;/strong&gt;依然用那种一个 CustomView 里包含三个 CustomButton 的方式，然后分别加上约束。CustomView 只需要加上宽高，包含的 Button 加上 left、top 和 size。&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://tech.meituan.com/img/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%9727.png&quot; alt=&quot;&quot; width=&quot;50%/&quot;/&gt;&lt;p&gt;图 4.7 加约束修正后样式&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;以下是尝试修复这部分问题的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// offset 问题
if (@available(iOS 11.0, *)) {
        self.contentViewController.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
    }
// UIBarButtonItem 问题
if (@available(iOS 11.0, *)) {
        [messageButtonsContainerView mas_makeConstraints:^(MASConstraintMaker *make) {
            make.size.mas_equalTo(CGSizeMake(themeButton.width + settingButton.width + messageButton.width, 44));
        }];
        [themeButton mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.equalTo(messageButtonsContainerView);
            make.left.equalTo(messageButtonsContainerView);
            make.size.mas_offset(CGSizeMake(44, 44));
        }];
        [settingButton mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.equalTo(messageButtonsContainerView);
            make.left.equalTo(themeButton.mas_right);
            make.size.mas_offset(CGSizeMake(44, 44));
        }];
        [messageButton mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.equalTo(messageButtonsContainerView);
            make.left.equalTo(settingButton.mas_right).offset(-10);
            make.size.mas_offset(CGSizeMake(44, 44));
        }];
    }

    UIBarButtonItem *rightBarItem = [[UIBarButtonItem alloc] initWithCustomView:messageButtonsContainerView];
    self.navigationItem.rightBarButtonItems = @[rightBarItem];
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当前发现这些问题的环境是 Xcode 9 GM版本(9A235)的模拟器。归结起来是三类问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;StatusBar 变高并且绝对布局。&lt;/li&gt;
&lt;li&gt;导航栏的视图层级结构发生变化而导致 UI(titleView、UIBarButtonItem) 问题。（iPhone 6s iOS 11 上依然是旧的结构，是因为现在 AppStore 上的包依然是用 iOS 10 的 SDK 打出来的）。&lt;/li&gt;
&lt;li&gt;safeAreaInset 导致 Scrollview 偏移。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至于 Tabbar ，因为我们用的是系统的，所以目前并没有发现什么奇怪的地方。希望我们踩的这些坑可以让各位在适配的过程中少走一些弯路！&lt;/p&gt;

&lt;p&gt;源：&lt;a href=&quot;https://tech.meituan.com/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97.html&quot; target=&quot;_blank&quot;&gt;https://tech.meituan.com/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 10:34:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/8260182.html</dc:identifier>
</item>
<item>
<title>设计模式-门面模式 - 馒头的梦想</title>
<link>http://www.cnblogs.com/mongo/p/8257719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mongo/p/8257719.html</guid>
<description>&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;门面模式（Facade Pattern）也叫外观模式，它隐藏系统的复杂性，并向客户端提供一个可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，为子系统中的一组接口提供了一个统一的高层访问接口，这个接口使得子系统更容易被访问或使用。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;9&quot;&gt;
&lt;h3&gt;基本简介 &lt;/h3&gt;
&lt;div class=&quot;para&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;(1)客户端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过调用Facede来完成要实现的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)门面角色&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;门面模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)子系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;19.5&quot;&gt;&lt;strong&gt; &lt;/strong&gt;
&lt;h3&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们拿生活中电脑开机为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/518959/201801/518959-20180110191622597-300948518.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/518959/201801/518959-20180110173225363-2136012886.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;
&lt;p&gt; (1.1)子系统&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cpu {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = Logger.getLogger(Cpu.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 释放
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; freeze() {
        logger.info(&lt;/span&gt;&quot;cpu freeze..&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute() {
        logger.info(&lt;/span&gt;&quot;cpu execute..&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HardDrive {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = Logger.getLogger(HardDrive.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
        logger.info(&lt;/span&gt;&quot;hardDrive read..&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Memory {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = Logger.getLogger(Memory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; load() {
        logger.info(&lt;/span&gt;&quot;memory load..&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; (1.2)门面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Computer {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cpu cpu;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Memory memory;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HardDrive hardDrive;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Computer() {
        cpu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cpu();
        memory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Memory();
        hardDrive &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HardDrive();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        cpu.freeze();
        hardDrive.read();
        memory.load();
        cpu.execute();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; (1.3)客户端&lt;/p&gt;
&lt;p&gt;   这里我们用单元测试入口作为调用端&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; facadeClient {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testFacadeDesign() {
        Computer facade &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Computer();
        facade.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  (1.4)客户端调用结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/518959/201801/518959-20180110173733504-1168885396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;33&quot;&gt;
&lt;h3&gt; 门面模式在Tomcat中的使用&lt;/h3&gt;
&lt;p&gt;    如下是查看tomcat源码中的类引用关系得到的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/518959/201801/518959-20180110175915519-1425109358.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;258&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/518959/201801/518959-20180110180008129-1500137090.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;p&gt;          Request对象中的很多方法都是内部组件之间相互交互时使用的，比如setComet、setRequestedSessionId等方法（这里就不一一列举了）。这些方法并不对外部公开，但是又必须设置为public，因为还需要跟内部组件之间交互使用。最好的解决方法就是通过使用一个Facade类，将与内部组件之间交互使用的方法屏蔽掉，只提供给外部程序感兴趣的方法。&lt;/p&gt;
&lt;p&gt;　　    如果不使用Facade类，直接传递的是Request对象和Response对象，那么熟悉容器内部运作的程序员可以分别把ServletRequest和ServletResponse对象向下转换为Request和Response，并调用它们的公共方法。比如拥有Request对象，就可以调用setComet、setRequestedSessionId等方法，这会危害安全性。&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;       门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。门面模式的优点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 1.松散耦合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 &lt;/strong&gt;门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。&lt;/p&gt;
&lt;p&gt;　　 2.&lt;strong&gt;简单易用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 &lt;/strong&gt;门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。&lt;/p&gt;
&lt;p&gt;　　 3.&lt;strong&gt;更好的划分访问层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 &lt;/strong&gt;通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 10 Jan 2018 10:04:00 +0000</pubDate>
<dc:creator>馒头的梦想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mongo/p/8257719.html</dc:identifier>
</item>
<item>
<title>python常用模块详解 - 古墓派掌门</title>
<link>http://www.cnblogs.com/qflyue/p/8259772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qflyue/p/8259772.html</guid>
<description>&lt;h2&gt;什么是模块&lt;/h2&gt;
&lt;p&gt; 常见的场景：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py的后缀。但其实import加载的模块分为四个通用类别：　&lt;/p&gt;
&lt;p&gt;　　1 使用python编写的代码（.py文件）&lt;/p&gt;
&lt;p&gt;　　2 已被编译为共享库或DLL的C或C++扩展&lt;/p&gt;
&lt;p&gt;　　3 包好一组模块的包&lt;/p&gt;
&lt;p&gt;　　4 使用C编写并链接到python解释器的内置模块&lt;/p&gt;
&lt;h2&gt;常用模块&lt;/h2&gt;
&lt;p&gt;下面列举python的常用模块&lt;/p&gt;
&lt;h3&gt;collections模块&lt;/h3&gt;
&lt;p&gt;在内置数据类型（dict、list、set、tuple）的基础上，&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyY29sbGVjdGlvbnMlRTYlQTglQTElRTUlOUQlOTclRTUlOUMlQTglRTUlODYlODUlRTclQkQlQUUlRTYlOTUlQjAlRTYlOEQlQUUlRTclQjElQkIlRTUlOUUlOEIlRUYlQkMlODhkaWN0JUUzJTgwJTgxbGlzdCVFMyU4MCU4MXNldCVFMyU4MCU4MXR1cGxlJUVGJUJDJTg5JUU3JTlBJTg0JUU1JTlGJUJBJUU3JUExJTgwJUU0JUI4JThBJUVGJUJDJThDJUU4JUJGJTk4JUU2JThGJTkwJUU0JUJFJTlCJUU0JUJBJTg2JUU1JTg3JUEwJUU0JUI4JUFBJUU5JUEyJTlEJUU1JUE0JTk2JUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU3JUIxJUJCJUU1JTlFJThCJUVGJUJDJTlBQ2hhaW5NYXAlRTMlODAlODFDb3VudGVyJUUzJTgwJTgxZGVxdWUlRTMlODAlODFkZWZhdWx0ZGljdCVFMyU4MCU4MW5hbWVkdHVwbGUlRTUlOTIlOENPcmRlcmVkRGljdCVFNyVBRCU4OSVFMyU4MCU4MiUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTVEJTdEJTVEJTdEJTVEJTdEJTJDJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyMS5uYW1lZHR1cGxlJTNBJTIwJUU3JTk0JTlGJUU2JTg4JTkwJUU1JThGJUFGJUU0JUJCJUE1JUU0JUJEJUJGJUU3JTk0JUE4JUU1JTkwJThEJUU1JUFEJTk3JUU2JTlEJUE1JUU4JUFFJUJGJUU5JTk3JUFFJUU1JTg1JTgzJUU3JUI0JUEwJUU1JTg2JTg1JUU1JUFFJUI5JUU3JTlBJTg0dHVwbGUlRTUlQUQlOTAlRTclQjElQkIlNUNuMi5kZXF1ZSUzQSUyMCVFNSU4RiU4QyVFNyVBQiVBRiVFOSU5OCU5RiVFNSU4OCU5NyVFRiVCQyU4QyVFNSU4RiVBRiVFNCVCQiVBNSVFNSVCRiVBQiVFOSU4MCU5RiVFNyU5QSU4NCVFNCVCQiU4RSVFNSU4RiVBNiVFNSVBNCU5NiVFNCVCOCU4MCVFNCVCRSVBNyVFOCVCRiVCRCVFNSU4QSVBMCVFNSU5MiU4QyVFNiU4RSVBOCVFNSU4NyVCQSVFNSVBRiVCOSVFOCVCMSVBMSU1Q24zLkNvdW50ZXIlM0ElMjAlRTglQUUlQTElRTYlOTUlQjAlRTUlOTklQTglRUYlQkMlOEMlRTQlQjglQkIlRTglQTYlODElRTclOTQlQTglRTYlOUQlQTUlRTglQUUlQTElRTYlOTUlQjAlNUNuNC5PcmRlcmVkRGljdCUzQSUyMCVFNiU5QyU4OSVFNSVCQSU4RiVFNSVBRCU5NyVFNSU4NSVCOCU1Q241LmRlZmF1bHRkaWN0JTNBJTIwJUU1JUI4JUE2JUU2JTlDJTg5JUU5JUJCJTk4JUU4JUFFJUE0JUU1JTgwJUJDJUU3JTlBJTg0JUU1JUFEJTk3JUU1JTg1JUI4JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等。&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;294&quot;&gt;&lt;span data-key=&quot;285&quot;&gt;1.namedtuple: 生成可以使用名字来访问元素内容的tuple&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;294&quot;&gt;&lt;span data-key=&quot;285&quot;&gt;2.deque: 双端队列，可以快速的从另外一侧追加和推出对象&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;294&quot;&gt;&lt;span data-key=&quot;285&quot;&gt;3.Counter: 计数器，主要用来计数&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;294&quot;&gt;&lt;span data-key=&quot;285&quot;&gt;4.OrderedDict: 有序字典&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;294&quot;&gt;&lt;span data-key=&quot;285&quot;&gt;5.defaultdict: 带有默认值的字典&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;namedtuple&lt;/h4&gt;
&lt;p&gt;我&lt;span data-offset-key=&quot;297-0&quot;&gt;们知道&lt;span data-offset-key=&quot;297-1&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;span data-offset-key=&quot;297-2&quot;&gt;可以表示不变集合，例如，一个点的二维坐标就可以表示成：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; p = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUJEJTg2JUU2JTk4JUFGJUVGJUJDJThDJUU3JTlDJThCJUU1JTg4JUIwJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyKDElMkMlMjAyKSUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUVGJUJDJThDJUU1JUJFJTg4JUU5JTlBJUJFJUU3JTlDJThCJUU1JTg3JUJBJUU4JUJGJTk5JUU0JUI4JUFBJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIydHVwbGUlMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU3QiUyMmRhdGElMjIlM0ElN0IlN0QlMkMlMjJraW5kJTIyJTNBJTIybWFyayUyMiUyQyUyMnR5cGUlMjIlM0ElMjJDT0RFJTIyJTdEJTVEJTdEJTJDJTdCJTIya2luZCUyMiUzQSUyMnJhbmdlJTIyJTJDJTIydGV4dCUyMiUzQSUyMiVFNiU5OCVBRiVFNyU5NCVBOCVFNiU5RCVBNSVFOCVBMSVBOCVFNyVBNCVCQSVFNCVCOCU4MCVFNCVCOCVBQSVFNSU5RCU5MCVFNiVBMCU4NyVFNyU5QSU4NCVFMyU4MCU4MiUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTVEJTdEJTVEJTdEJTVEJTdEJTJDJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU1JUFFJTlBJUU0JUI5JTg5JUU0JUI4JTgwJUU0JUI4JUFBY2xhc3MlRTUlOEYlODglRTUlQjAlOEYlRTklQTIlOTglRTUlQTQlQTclRTUlODElOUElRTQlQkElODYlRUYlQkMlOEMlRTglQkYlOTklRTYlOTclQjYlRUYlQkMlOEMlMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU1RCU3RCUyQyU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjJuYW1lZHR1cGxlJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlN0IlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIya2luZCUyMiUzQSUyMm1hcmslMjIlMkMlMjJ0eXBlJTIyJTNBJTIyQ09ERSUyMiU3RCU1RCU3RCUyQyU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjIlRTUlQjAlQjElRTYlQjQlQkUlRTQlQjglOEElRTQlQkElODYlRTclOTQlQTglRTUlOUMlQkElRUYlQkMlOUElMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU1RCU3RCU1RCU3RCU1RCU3RCU1RCU3RA==&quot;&gt;但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;313&quot;&gt;&lt;span data-key=&quot;310&quot;&gt;&lt;span data-offset-key=&quot;310-0&quot;&gt;这时，&lt;span data-offset-key=&quot;310-1&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;span data-offset-key=&quot;310-2&quot;&gt;就派上了用场：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import namedtuple
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Point = namedtuple(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; p = Point(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; p.x
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; p.y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类&lt;span data-offset-key=&quot;357-0&quot;&gt;似的，如果要用坐标和半径表示一个圆，也可以用&lt;span data-offset-key=&quot;357-1&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;span data-offset-key=&quot;357-2&quot;&gt;定义：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; #namedtuple(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [属性list]):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Circle = namedtuple(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Circle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;deque双端队列&lt;/h4&gt;
&lt;p&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUJEJUJGJUU3JTk0JUE4JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIybGlzdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU1JUFEJTk4JUU1JTgyJUE4JUU2JTk1JUIwJUU2JThEJUFFJUU2JTk3JUI2JUVGJUJDJThDJUU2JThDJTg5JUU3JUI0JUEyJUU1JUJDJTk1JUU4JUFFJUJGJUU5JTk3JUFFJUU1JTg1JTgzJUU3JUI0JUEwJUU1JUJFJTg4JUU1JUJGJUFCJUVGJUJDJThDJUU0JUJEJTg2JUU2JTk4JUFGJUU2JThGJTkyJUU1JTg1JUE1JUU1JTkyJThDJUU1JTg4JUEwJUU5JTk5JUE0JUU1JTg1JTgzJUU3JUI0JUEwJUU1JUIwJUIxJUU1JUJFJTg4JUU2JTg1JUEyJUU0JUJBJTg2JUVGJUJDJThDJUU1JTlCJUEwJUU0JUI4JUJBJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIybGlzdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU2JTk4JUFGJUU3JUJBJUJGJUU2JTgwJUE3JUU1JUFEJTk4JUU1JTgyJUE4JUVGJUJDJThDJUU2JTk1JUIwJUU2JThEJUFFJUU5JTg3JThGJUU1JUE0JUE3JUU3JTlBJTg0JUU2JTk3JUI2JUU1JTgwJTk5JUVGJUJDJThDJUU2JThGJTkyJUU1JTg1JUE1JUU1JTkyJThDJUU1JTg4JUEwJUU5JTk5JUE0JUU2JTk1JTg4JUU3JThFJTg3JUU1JUJFJTg4JUU0JUJEJThFJUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlMkMlN0IlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIya2luZCUyMiUzQSUyMmJsb2NrJTIyJTJDJTIyaXNWb2lkJTIyJTNBZmFsc2UlMkMlMjJ0eXBlJTIyJTNBJTIycGFyYWdyYXBoJTIyJTJDJTIybm9kZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIydGV4dCUyMiUyQyUyMnJhbmdlcyUyMiUzQSU1QiU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjJkZXF1ZSVFNiU5OCVBRiVFNCVCOCVCQSVFNCVCQSU4NiVFOSVBQiU5OCVFNiU5NSU4OCVFNSVBRSU5RSVFNyU4RSVCMCVFNiU4RiU5MiVFNSU4NSVBNSVFNSU5MiU4QyVFNSU4OCVBMCVFOSU5OSVBNCVFNiU5MyU4RCVFNCVCRCU5QyVFNyU5QSU4NCVFNSU4RiU4QyVFNSU5MCU5MSVFNSU4OCU5NyVFOCVBMSVBOCVFRiVCQyU4QyVFOSU4MCU4MiVFNSU5MCU4OCVFNyU5NCVBOCVFNCVCQSU4RSVFOSU5OCU5RiVFNSU4OCU5NyVFNSU5MiU4QyVFNiVBMCU4OCVFRiVCQyU5QSUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTVEJTdEJTVEJTdEJTVEJTdEJTVEJTdE&quot;&gt;使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;375&quot;&gt;&lt;span data-key=&quot;374&quot;&gt;deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import deque
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; q = deque([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; q.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; q.appendleft(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; q
deque([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d&lt;span data-offset-key=&quot;389-0&quot;&gt;eque&lt;span data-offset-key=&quot;389-1&quot;&gt;除了实现list的&lt;span data-offset-key=&quot;389-2&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;span data-offset-key=&quot;389-3&quot;&gt;和&lt;span data-offset-key=&quot;389-4&quot;&gt;&lt;code&gt;pop()&lt;/code&gt;&lt;span data-offset-key=&quot;389-5&quot;&gt;外，还支持&lt;span data-offset-key=&quot;389-6&quot;&gt;&lt;code&gt;appendleft()&lt;/code&gt;&lt;span data-offset-key=&quot;389-7&quot;&gt;和&lt;span data-offset-key=&quot;389-8&quot;&gt;&lt;code&gt;popleft()&lt;/code&gt;&lt;span data-offset-key=&quot;389-9&quot;&gt;，这样就可以非常高效地往头部添加或删除元素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiUyMmlkJTIyJTNBJTIyb3JkZXJlZGRpY3QlMjIlN0QlMkMlMjJraW5kJTIyJTNBJTIyYmxvY2slMjIlMkMlMjJpc1ZvaWQlMjIlM0FmYWxzZSUyQyUyMnR5cGUlMjIlM0ElMjJoZWFkZXJfdGhyZWUlMjIlMkMlMjJub2RlcyUyMiUzQSU1QiU3QiUyMmtpbmQlMjIlM0ElMjJ0ZXh0JTIyJTJDJTIycmFuZ2VzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnJhbmdlJTIyJTJDJTIydGV4dCUyMiUzQSUyMk9yZGVyZWREaWN0JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;OrderedDict有序字典&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUJEJUJGJUU3JTk0JUE4JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyZGljdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU2JTk3JUI2JUVGJUJDJThDS2V5JUU2JTk4JUFGJUU2JTk3JUEwJUU1JUJBJThGJUU3JTlBJTg0JUUzJTgwJTgyJUU1JTlDJUE4JUU1JUFGJUI5JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyZGljdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU1JTgxJTlBJUU4JUJGJUFEJUU0JUJCJUEzJUU2JTk3JUI2JUVGJUJDJThDJUU2JTg4JTkxJUU0JUJCJUFDJUU2JTk3JUEwJUU2JUIzJTk1JUU3JUExJUFFJUU1JUFFJTlBS2V5JUU3JTlBJTg0JUU5JUExJUJBJUU1JUJBJThGJUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlMkMlN0IlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIya2luZCUyMiUzQSUyMmJsb2NrJTIyJTJDJTIyaXNWb2lkJTIyJTNBZmFsc2UlMkMlMjJ0eXBlJTIyJTNBJTIycGFyYWdyYXBoJTIyJTJDJTIybm9kZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIydGV4dCUyMiUyQyUyMnJhbmdlcyUyMiUzQSU1QiU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjIlRTUlQTYlODIlRTYlOUUlOUMlRTglQTYlODElRTQlQkYlOUQlRTYlOEMlODFLZXklRTclOUElODQlRTklQTElQkElRTUlQkElOEYlRUYlQkMlOEMlRTUlOEYlQUYlRTQlQkIlQTUlRTclOTQlQTglMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU1RCU3RCUyQyU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjJPcmRlcmVkRGljdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUVGJUJDJTlBJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;446&quot;&gt;&lt;span data-key=&quot;443&quot;&gt;&lt;span data-offset-key=&quot;443-0&quot;&gt;如果要保持Key的顺序，可以用&lt;span data-offset-key=&quot;443-1&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;span data-offset-key=&quot;443-2&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import OrderedDict
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; d = dict([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; d # dict的Key是无序的
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; od = OrderedDict([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)])
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; od # OrderedDict的Key是有序的
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; OrderedDict([(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注&lt;span data-offset-key=&quot;462-0&quot;&gt;意，&lt;span data-offset-key=&quot;462-1&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;span data-offset-key=&quot;462-2&quot;&gt;的Key会按照插入的顺序排列，不是Key本身排序：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; od =&lt;span&gt; OrderedDict()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; od[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; od[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; od[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;3&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; od.keys() # 按照插入的Key的顺序返回
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;defaultDict&lt;/h4&gt;
&lt;p&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUJEJUJGJUU3JTk0JUE4JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyZGljdCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJtYXJrJTIyJTJDJTIydHlwZSUyMiUzQSUyMkNPREUlMjIlN0QlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU2JTk3JUI2JUVGJUJDJThDJUU1JUE2JTgyJUU2JTlFJTlDJUU1JUJDJTk1JUU3JTk0JUE4JUU3JTlBJTg0S2V5JUU0JUI4JThEJUU1JUFEJTk4JUU1JTlDJUE4JUVGJUJDJThDJUU1JUIwJUIxJUU0JUJDJTlBJUU2JThBJTlCJUU1JTg3JUJBJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlMkMlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyS2V5RXJyb3IlMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU3QiUyMmRhdGElMjIlM0ElN0IlN0QlMkMlMjJraW5kJTIyJTNBJTIybWFyayUyMiUyQyUyMnR5cGUlMjIlM0ElMjJDT0RFJTIyJTdEJTVEJTdEJTJDJTdCJTIya2luZCUyMiUzQSUyMnJhbmdlJTIyJTJDJTIydGV4dCUyMiUzQSUyMiVFMyU4MCU4MiVFNSVBNiU4MiVFNiU5RSU5QyVFNSVCOCU4QyVFNiU5QyU5QmtleSVFNCVCOCU4RCVFNSVBRCU5OCVFNSU5QyVBOCVFNiU5NyVCNiVFRiVCQyU4QyVFOCVCRiU5NCVFNSU5QiU5RSVFNCVCOCU4MCVFNCVCOCVBQSVFOSVCQiU5OCVFOCVBRSVBNCVFNSU4MCVCQyVFRiVCQyU4QyVFNSVCMCVCMSVFNSU4RiVBRiVFNCVCQiVBNSVFNyU5NCVBOCUyMiUyQyUyMm1hcmtzJTIyJTNBJTVCJTVEJTdEJTJDJTdCJTIya2luZCUyMiUzQSUyMnJhbmdlJTIyJTJDJTIydGV4dCUyMiUzQSUyMmRlZmF1bHRkaWN0JTIyJTJDJTIybWFya3MlMjIlM0ElNUIlN0IlMjJkYXRhJTIyJTNBJTdCJTdEJTJDJTIya2luZCUyMiUzQSUyMm1hcmslMjIlMkMlMjJ0eXBlJTIyJTNBJTIyQ09ERSUyMiU3RCU1RCU3RCUyQyU3QiUyMmtpbmQlMjIlM0ElMjJyYW5nZSUyMiUyQyUyMnRleHQlMjIlM0ElMjIlRUYlQkMlOUElMjIlMkMlMjJtYXJrcyUyMiUzQSU1QiU1RCU3RCU1RCU3RCU1RCU3RCU1RCU3RA==&quot;&gt;&lt;code class=&quot;python plain&quot;&gt;有如下值集合 [&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;11&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;22&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;33&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;44&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;55&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;66&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;77&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;88&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;99&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;90.&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;..]，将所有大于 &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;66&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;的值保存至字典的第一个key中，将小于 &lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;66&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;的值保存至第二个key的值中。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;即： {&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'k1'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;: 大于&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;66&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'k2'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;: 小于&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;66&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;line number2 index1 alt1&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d7110378-58be-45d2-b396-e0c3c25073e1')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_d7110378-58be-45d2-b396-e0c3c25073e1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d7110378-58be-45d2-b396-e0c3c25073e1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d7110378-58be-45d2-b396-e0c3c25073e1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d7110378-58be-45d2-b396-e0c3c25073e1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; values = [&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;33&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;66&lt;/span&gt;,&lt;span&gt;77&lt;/span&gt;,&lt;span&gt;88&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;90&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; my_dict =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt;  values:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; value&amp;gt;&lt;span&gt;66&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; my_dict.has_key(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(value)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; [value]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; my_dict.has_key(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(value)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [value]
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;原生字典解决方案&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a86180b4-61fa-482e-ac69-f41931e67ce1')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_a86180b4-61fa-482e-ac69-f41931e67ce1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a86180b4-61fa-482e-ac69-f41931e67ce1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a86180b4-61fa-482e-ac69-f41931e67ce1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a86180b4-61fa-482e-ac69-f41931e67ce1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import defaultdict
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; values = [&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;33&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;66&lt;/span&gt;,&lt;span&gt;77&lt;/span&gt;,&lt;span&gt;88&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;90&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; my_dict =&lt;span&gt; defaultdict(list)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt;  values:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; value&amp;gt;&lt;span&gt;66&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(value)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         my_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].append(value)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;default字典解决&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;tip：使&lt;span data-offset-key=&quot;402-0&quot;&gt;用&lt;span data-offset-key=&quot;402-1&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;span data-offset-key=&quot;402-2&quot;&gt;时，如果引用的Key不存在，就会抛出&lt;span data-offset-key=&quot;402-3&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;span data-offset-key=&quot;402-4&quot;&gt;。如果希望key不存在时，返回一个默认值，就可以用&lt;span data-offset-key=&quot;402-5&quot;&gt;&lt;code&gt;defaultdict&lt;/code&gt;&lt;span data-offset-key=&quot;402-6&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import defaultdict
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; dd = defaultdict(lambda: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;N/A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; dd[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; dd[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # key1存在
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; dd[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] # key2不存在，返回默认值
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;N/A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;defaultdict类的初始化函数接受一个类型作为参数，当所访问的键不存在的时候，可以实例化一个值作为默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; collections import defaultdict
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; dd =&lt;span&gt; defaultdict(list)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; dd
defaultdict(&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;, {})
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; dd[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; dd
defaultdict(&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []})
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; dd[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; dd
defaultdict(&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]})
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;counter&lt;/h4&gt;
&lt;p&gt;Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
c = Counter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcdeabcdabcaba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print c
输出：Counter({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;时间模块&lt;/h3&gt;
&lt;p&gt;和时间有关系的我们就要用到时间模块。在使用模块之前，应该首先导入这个模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#常用方法
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.time.sleep(secs)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;(线程)推迟指定的时间运行。单位为秒。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.time.time()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 获取当前时间戳
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;表示时间的三种方式&lt;/h4&gt;
&lt;p&gt;在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：&lt;/p&gt;
&lt;p&gt;(1)时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。&lt;/p&gt;
&lt;p&gt;(2)格式化的时间字符串(Format String)： ‘1999-12-06’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; %y 两位数的年份表示（&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;99&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; %Y 四位数的年份表示（&lt;span&gt;000&lt;/span&gt;-&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; %m 月份（&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; %d 月内中的一天（&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;31&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; %H 24小时制小时数（&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; %I 12小时制小时数（&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; %M 分钟数（&lt;span&gt;00&lt;/span&gt;=&lt;span&gt;59&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; %S 秒（&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;59&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; %&lt;span&gt;a 本地简化星期名称
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; %&lt;span&gt;A 本地完整星期名称
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; %&lt;span&gt;b 本地简化的月份名称
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; %&lt;span&gt;B 本地完整的月份名称
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; %&lt;span&gt;c 本地相应的日期表示和时间表示
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; %j 年内的一天（&lt;span&gt;001&lt;/span&gt;-&lt;span&gt;366&lt;/span&gt;&lt;span&gt;）
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; %&lt;span&gt;p 本地A.M.或P.M.的等价符
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; %U 一年中的星期数（&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;53&lt;/span&gt;&lt;span&gt;）星期天为星期的开始
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; %w 星期（&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;），星期天为星期的开始
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; %W 一年中的星期数（&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;53&lt;/span&gt;&lt;span&gt;）星期一为星期的开始
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; %&lt;span&gt;x 本地相应的日期表示
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; %&lt;span&gt;X 本地相应的时间表示
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; %&lt;span&gt;Z 当前时区的名称
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; %% %号本身
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)元组(struct_time) ：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;th&gt;索引（Index）&lt;/th&gt;
&lt;th&gt;属性（Attribute）&lt;/th&gt;
&lt;th&gt;值（Values）&lt;/th&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;tm_year（年）&lt;/td&gt;
&lt;td&gt;如：2016&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;tm_mon（月）&lt;/td&gt;
&lt;td&gt;1 - 12&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;tm_mday（日）&lt;/td&gt;
&lt;td&gt;1 - 31&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;tm_hour（时）&lt;/td&gt;
&lt;td&gt;0 - 23&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;tm_min（分）&lt;/td&gt;
&lt;td&gt;0 - 59&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;tm_sec（秒）&lt;/td&gt;
&lt;td&gt;0 - 59&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;tm_wday（weekday）&lt;/td&gt;
&lt;td&gt;0 - 6&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;tm_yday（一年中的第几天）&lt;/td&gt;
&lt;td&gt;1 - 366&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;tm_isdst（是否是夏令时）&lt;/td&gt;
&lt;td&gt;默认0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;p&gt;python中表示时间的几种格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#导入时间模块
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt;import time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#时间戳
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt;time.time()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;1500875844.800804&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#时间字符串
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d %X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-24 13:54:37&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H-%M-%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-24 13-55-04&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#时间元组:localtime将一个时间戳转换为当前时区的struct_time
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;time.localtime()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; time.struct_time(tm_year=&lt;span&gt;2017&lt;/span&gt;, tm_mon=&lt;span&gt;7&lt;/span&gt;, tm_mday=&lt;span&gt;24&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 　　　　　　　　　　tm_hour=&lt;span&gt;13&lt;/span&gt;, tm_min=&lt;span&gt;59&lt;/span&gt;, tm_sec=&lt;span&gt;37&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                  tm_wday=&lt;span&gt;0&lt;/span&gt;, tm_yday=&lt;span&gt;205&lt;/span&gt;, tm_isdst=&lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的&lt;/p&gt;
&lt;p&gt;几种时间格式的转换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180110163033847-2142224217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
#时间戳--&amp;gt;&lt;span&gt;结构化时间
#time.gmtime(时间戳)    #UTC时间，与英国伦敦当地时间一致
#time.localtime(时间戳) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间&lt;/span&gt;+8小时 =&lt;span&gt; 北京时间 
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.gmtime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;)
time.struct_time(tm_year&lt;/span&gt;=&lt;span&gt;2017&lt;/span&gt;, tm_mon=&lt;span&gt;7&lt;/span&gt;, tm_mday=&lt;span&gt;14&lt;/span&gt;, tm_hour=&lt;span&gt;2&lt;/span&gt;, tm_min=&lt;span&gt;40&lt;/span&gt;, tm_sec=&lt;span&gt;0&lt;/span&gt;, tm_wday=&lt;span&gt;4&lt;/span&gt;, tm_yday=&lt;span&gt;195&lt;/span&gt;, tm_isdst=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.localtime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;)
time.struct_time(tm_year&lt;/span&gt;=&lt;span&gt;2017&lt;/span&gt;, tm_mon=&lt;span&gt;7&lt;/span&gt;, tm_mday=&lt;span&gt;14&lt;/span&gt;, tm_hour=&lt;span&gt;10&lt;/span&gt;, tm_min=&lt;span&gt;40&lt;/span&gt;, tm_sec=&lt;span&gt;0&lt;/span&gt;, tm_wday=&lt;span&gt;4&lt;/span&gt;, tm_yday=&lt;span&gt;195&lt;/span&gt;, tm_isdst=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

#结构化时间&lt;/span&gt;--&amp;gt;&lt;span&gt;时间戳　
#time.mktime(结构化时间)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time_tuple = time.localtime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;time.mktime(time_tuple)
&lt;/span&gt;&lt;span&gt;1500000000.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
#结构化时间--&amp;gt;&lt;span&gt;字符串时间
#time.strftime(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;格式定义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结构化时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  结构化时间参数若不传，则现实当前时间
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d %X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-24 14:55:36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.localtime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-07-14&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

#字符串时间&lt;/span&gt;--&amp;gt;&lt;span&gt;结构化时间
#time.strptime(时间字符串,字符串对应格式)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.strptime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2017-03-16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
time.struct_time(tm_year&lt;/span&gt;=&lt;span&gt;2017&lt;/span&gt;, tm_mon=&lt;span&gt;3&lt;/span&gt;, tm_mday=&lt;span&gt;16&lt;/span&gt;, tm_hour=&lt;span&gt;0&lt;/span&gt;, tm_min=&lt;span&gt;0&lt;/span&gt;, tm_sec=&lt;span&gt;0&lt;/span&gt;, tm_wday=&lt;span&gt;3&lt;/span&gt;, tm_yday=&lt;span&gt;75&lt;/span&gt;, tm_isdst=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.strptime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;07/24/2017&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%m/%d/%Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
time.struct_time(tm_year&lt;/span&gt;=&lt;span&gt;2017&lt;/span&gt;, tm_mon=&lt;span&gt;7&lt;/span&gt;, tm_mday=&lt;span&gt;24&lt;/span&gt;, tm_hour=&lt;span&gt;0&lt;/span&gt;, tm_min=&lt;span&gt;0&lt;/span&gt;, tm_sec=&lt;span&gt;0&lt;/span&gt;, tm_wday=&lt;span&gt;0&lt;/span&gt;, tm_yday=&lt;span&gt;205&lt;/span&gt;, tm_isdst=-&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180110163147301-1338526827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#结构化时间 --&amp;gt; %a %b %d %H:%M:%S %&lt;span&gt;Y串
#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;time.asctime(time.localtime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fri Jul 14 10:40:00 2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;time.asctime()
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Jul 24 15:18:33 2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

#&lt;/span&gt;%a %d %d %H:%M:%S %Y串 --&amp;gt;&lt;span&gt; 结构化时间
#time.ctime(时间戳)  如果不传参数，直接返回当前时间的格式化串
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt;time.ctime()
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mon Jul 24 15:19:07 2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;time.ctime(&lt;span&gt;1500000000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fri Jul 14 10:40:00 2017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('37b7ec91-3464-4b87-927a-7a5d0f8f75a7')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_37b7ec91-3464-4b87-927a-7a5d0f8f75a7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_37b7ec91-3464-4b87-927a-7a5d0f8f75a7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('37b7ec91-3464-4b87-927a-7a5d0f8f75a7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_37b7ec91-3464-4b87-927a-7a5d0f8f75a7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import time
true_time&lt;/span&gt;=time.mktime(time.strptime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-09-11 08:30:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
time_now&lt;/span&gt;=time.mktime(time.strptime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-09-12 11:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
dif_time&lt;/span&gt;=time_now-&lt;span&gt;true_time
struct_time&lt;/span&gt;=&lt;span&gt;time.gmtime(dif_time)
print(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;过去了%d年%d月%d天%d小时%d分钟%d秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(struct_time.tm_year-&lt;span&gt;1970&lt;/span&gt;,struct_time.tm_mon-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                                       struct_time.tm_mday&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,struct_time.tm_hour,
                                       struct_time.tm_min,struct_time.tm_sec))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;计算时间差&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;random模块&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; import random
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#随机小数
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; random.random()      # 大于0且小于1之间的小数
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;0.7664338663654585&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; random.uniform(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) #大于1小于3的小数
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;1.6270147180533838&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#随机整数
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; random.randint(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)  # 大于等于1且小于等于5之间的整数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; random.randrange(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) # 大于等于1且小于10之间的奇数
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#随机选择一个返回
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; random.choice([&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,[&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]])  # #1或者23或者[&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#随机选择多个返回，返回的个数为函数的第二个参数
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; random.sample([&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,[&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]],&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) # #列表元素任意2个组合
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; [[&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#打乱列表顺序
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; item=[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; random.shuffle(item) # 打乱次序
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; [&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; random.shuffle(item)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; [&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成随机验证码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cfbb9d10-16d5-4667-ac2f-184b2142a045')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_cfbb9d10-16d5-4667-ac2f-184b2142a045&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cfbb9d10-16d5-4667-ac2f-184b2142a045&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cfbb9d10-16d5-4667-ac2f-184b2142a045',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cfbb9d10-16d5-4667-ac2f-184b2142a045&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import random

def v_code():

    code &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;):

        num&lt;/span&gt;=random.randint(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;)
        alf&lt;/span&gt;=chr(random.randint(&lt;span&gt;65&lt;/span&gt;,&lt;span&gt;90&lt;/span&gt;&lt;span&gt;))
        add&lt;/span&gt;=&lt;span&gt;random.choice([num,alf])
        code&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join([code,str(add)])

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; code

print(v_code())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;生成随机验证码&lt;/span&gt;&lt;/div&gt;

&lt;h4&gt; sys模块&lt;/h4&gt;
&lt;p&gt;sys模块是与&lt;span class=&quot;s1&quot;&gt;python解释器交互的一个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;sys.argv           命令行参数List，第一个元素是程序本身路径
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; sys.exit(n)        退出程序，正常退出时exit(&lt;span&gt;0&lt;/span&gt;),错误退出sys.exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;sys.version        获取Python解释程序的版本信息
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; sys.platform       返回操作系统平台名称
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;异常处理和status&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import sys
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     sys.exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; except SystemExit &lt;span&gt;as&lt;/span&gt;&lt;span&gt; e:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     print(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;序列化模块&lt;/h3&gt;
&lt;p&gt;什么叫序列化——将原本的字典、列表等内容转换成一个字符串的过程就叫做序列化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d7824cb0-144b-4c31-a872-1c38cda8d816')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d7824cb0-144b-4c31-a872-1c38cda8d816&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d7824cb0-144b-4c31-a872-1c38cda8d816&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d7824cb0-144b-4c31-a872-1c38cda8d816',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d7824cb0-144b-4c31-a872-1c38cda8d816&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;比如，我们在python代码中计算的一个数据需要给另外一段程序使用，那我们怎么给？
现在我们能想到的方法就是存在文件里，然后另一个python程序再从文件里读出来。
但是我们都知道，对于文件来说是没有字典这个概念的，所以我们只能将数据转换成字典放到文件中。
你一定会问，将字典转换成一个字符串很简单，就是str(dic)就可以办到了，为什么我们还要学习序列化模块呢？
没错序列化的过程就是从dic 变成str(dic)的过程。现在你可以通过str(dic)，将一个名为dic的字典转换成一个字符串，
但是你要怎么把一个字符串转换成字典呢？
聪明的你肯定想到了eval()，如果我们将一个字符串类型的字典str_dic传给eval，就会得到一个返回的字典类型了。
eval()函数十分强大，但是eval是做什么的？e官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。
ＢＵＴ！强大的函数有代价。安全性是其最大的缺点。
想象一下，如果我们从文件中读出的不是一个数据结构，而是一句&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;类似的破坏性语句，那么后果实在不堪设设想。
而使用eval就要担这个风险。
所以，我们并不推荐用eval方法来进行反序列化操作(将str转换成python中的数据结构)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;为什么要序列化&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;序列化的目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、以某种存储形式使自定义对象持久化；&lt;/p&gt;
&lt;p&gt;2、将对象从一个地方传递到另一个地方。&lt;/p&gt;
&lt;p&gt;3、使程序更具维护性。&lt;/p&gt;

&lt;div class=&quot;para&quot; readability=&quot;36.5&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/947890/201801/947890-20180110170942191-401599473.png&quot; alt=&quot;&quot;/&gt;&lt;h4&gt;json&lt;/h4&gt;
&lt;p&gt;Json模块提供了四个功能：dumps、dump、loads、load&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2af74d00-6151-4bf8-b0d6-f5e498d0a7b6')&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_2af74d00-6151-4bf8-b0d6-f5e498d0a7b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2af74d00-6151-4bf8-b0d6-f5e498d0a7b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2af74d00-6151-4bf8-b0d6-f5e498d0a7b6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2af74d00-6151-4bf8-b0d6-f5e498d0a7b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import json
dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
str_dic &lt;/span&gt;=&lt;span&gt; json.dumps(dic)  #序列化：将一个字典转换成一个字符串
print(type(str_dic),str_dic)  #&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
#注意，json转换完的字符串类型的字典中的字符串是由&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;表示的

dic2 &lt;/span&gt;=&lt;span&gt; json.loads(str_dic)  #反序列化：将一个字符串格式的字典转换成一个字典
#注意，要用json的loads功能处理的字符串类型的字典中的字符串必须由&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;表示
print(type(dic2),dic2)  #&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}


list_dic &lt;/span&gt;= [&lt;span&gt;1&lt;/span&gt;,[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],&lt;span&gt;3&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}]
str_dic &lt;/span&gt;=&lt;span&gt; json.dumps(list_dic) #也可以处理嵌套的数据类型 
print(type(str_dic),str_dic) #&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; [&lt;span&gt;1&lt;/span&gt;, [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;3&lt;/span&gt;, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]
list_dic2 &lt;/span&gt;=&lt;span&gt; json.loads(str_dic)
print(type(list_dic2),list_dic2) #&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; [&lt;span&gt;1&lt;/span&gt;, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;3&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}]
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;loads和dumps&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fa0d4f54-2e5c-47b4-b484-a19e76d61417')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_fa0d4f54-2e5c-47b4-b484-a19e76d61417&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fa0d4f54-2e5c-47b4-b484-a19e76d61417&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fa0d4f54-2e5c-47b4-b484-a19e76d61417',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fa0d4f54-2e5c-47b4-b484-a19e76d61417&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import json
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
json.dump(dic,f)  #dump方法接收一个文件句柄，直接将字典转换成json字符串写入文件
f.close()

f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
dic2 &lt;/span&gt;=&lt;span&gt; json.load(f)  #load方法接收一个文件句柄，直接将文件中的json字符串转换成数据结构返回
f.close()
print(type(dic2),dic2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;load和dump&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e3fa85d5-aa47-4467-b775-705637d5fbc3')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_e3fa85d5-aa47-4467-b775-705637d5fbc3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e3fa85d5-aa47-4467-b775-705637d5fbc3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e3fa85d5-aa47-4467-b775-705637d5fbc3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e3fa85d5-aa47-4467-b775-705637d5fbc3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import json
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
json.dump({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;国籍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},f)
ret &lt;/span&gt;= json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;国籍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
f.write(ret&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
json.dump({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;国籍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},f,ensure_ascii=&lt;span&gt;False)
ret &lt;/span&gt;= json.dumps({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;国籍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;美国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},ensure_ascii=&lt;span&gt;False)
f.write(ret&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ensure_ascii关键字参数&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;pickle&lt;/h4&gt;
&lt;p&gt;用于序列化的两个模块&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;json，用于字符串 和 python数据类型间进行转换&lt;/li&gt;
&lt;li&gt;pickle，用于python特有的类型 和 python的数据类型间进行转换&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p&gt;pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load  （不仅可以序列化字典，列表...&lt;strong&gt;可以把python中任意的数据类型序列化&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pickle
dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
str_dic &lt;/span&gt;=&lt;span&gt; pickle.dumps(dic)
print(str_dic)  #一串二进制内容

dic2 &lt;/span&gt;=&lt;span&gt; pickle.loads(str_dic)
print(dic2)    #字典

import time
struct_time  &lt;/span&gt;= time.localtime(&lt;span&gt;1000000000&lt;/span&gt;&lt;span&gt;)
print(struct_time)
f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
pickle.dump(struct_time,f)
f.close()

f &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
struct_time2 &lt;/span&gt;=&lt;span&gt; pickle.load(f)
print(struct_time2.tm_year)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;shelve&lt;/h4&gt;
&lt;p&gt;shelve也是python提供给我们的序列化工具，比pickle用起来更简单一些。&lt;br/&gt;shelve只提供给我们一个open方法，是用key来访问的，使用起来和字典类似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import shelve
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; f = shelve.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; f[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;9.5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sample data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}  #直接对文件句柄操作，就可以存入数据
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;f.close()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import shelve
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; f1 = shelve.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; existing = f1[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]  #取出数据的时候也只需要直接用key获取即可，但是如果key不存在会报错
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;f1.close()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; print(existing)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个模块有个限制，它不支持多个应用同一时间往同一个DB进行写操作。所以当我们知道我们的应用如果只进行读操作，我们可以让shelve通过只读方式打开DB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c149d622-66ea-4740-820a-d6ef2236f691')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_c149d622-66ea-4740-820a-d6ef2236f691&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c149d622-66ea-4740-820a-d6ef2236f691&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c149d622-66ea-4740-820a-d6ef2236f691',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c149d622-66ea-4740-820a-d6ef2236f691&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import shelve
f &lt;/span&gt;= shelve.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, flag=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
existing &lt;/span&gt;= f[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
f.close()
print(existing)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;shelve只读&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;由于shelve在默认情况下是不会记录待持久化对象的任何修改的，所以我们在shelve.open()时候需要修改默认参数，否则对象的修改不会保存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('da3827d2-aada-4a44-b6e8-b814400d5ba1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_da3827d2-aada-4a44-b6e8-b814400d5ba1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_da3827d2-aada-4a44-b6e8-b814400d5ba1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('da3827d2-aada-4a44-b6e8-b814400d5ba1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_da3827d2-aada-4a44-b6e8-b814400d5ba1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import shelve
f1 &lt;/span&gt;= shelve.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print(f1[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
f1[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this was not here before&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f1.close()

f2 &lt;/span&gt;= shelve.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve_file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, writeback=&lt;span&gt;True)
print(f2[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
f2[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this was not here before&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f2.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;设置writeback&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;writeback方式有优点也有缺点。优点是减少了我们出错的概率，并且让对象的持久化对用户更加的透明了；但这种方式并不是所有的情况下都需要，首先，使用writeback以后，shelf在open()的时候会增加额外的内存消耗，并且当DB在close()的时候会将缓存中的每一个对象都写入到DB，这也会带来额外的等待时间。因为shelve没有办法知道缓存中哪些对象修改了，哪些对象没有修改，因此所有的对象都会被写入。&lt;/p&gt;


&lt;/div&gt;

&lt;h3&gt;re模块&lt;/h3&gt;

&lt;p&gt;python正则详解：&lt;a href=&quot;http://www.cnblogs.com/qflyue/p/8252528.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qflyue/p/8252528.html&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;os模块&lt;/h3&gt;
&lt;p&gt;python文件操作与os常用命令：&lt;a href=&quot;http://www.cnblogs.com/qflyue/p/8110862.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qflyue/p/8110862.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Jan 2018 09:22:00 +0000</pubDate>
<dc:creator>古墓派掌门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qflyue/p/8259772.html</dc:identifier>
</item>
</channel>
</rss>