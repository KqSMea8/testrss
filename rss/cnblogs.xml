<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core脚本工具dotnet-script - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9820366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9820366.html</guid>
<description>&lt;p&gt;&quot;dotnet-script&quot;是github上一个开源的.net core global tool, 项目地址&lt;a href=&quot;https://github.com/filipw/dotnet-script&quot; class=&quot;uri&quot;&gt;https://github.com/filipw/dotnet-script&lt;/a&gt;。使用它，开发人员可以获得在命令行直接运行C#脚本文件的能力, 且不需要创建任何项目文件。&lt;/p&gt;

&lt;p&gt;.NET Core 2.1中引入了global tool, 所以你可以在命令行直接使用以下命令安装&lt;code&gt;dotnet-script&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;gt; dotnet tool install -g dotnet-script
You can invoke the tool using the following command: dotnet-script
Tool 'dotnet-script' (version '0.26.1') was successfully installed.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips: 为了使用global tool, 请安装.NET Core SDK 2.1.300及以上版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果希望卸载&lt;code&gt;dotnet-script&lt;/code&gt;, 请使用一下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; dotnet tool uninstall dotnet-script -g&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面我们通过一个最简单的例子，说明一下&lt;code&gt;dotnet-script&lt;/code&gt;的使用方式。&lt;/p&gt;
&lt;p&gt;首先我们创建一个helloworld.csx文件， 并在文件中编写以下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Console.WriteLine(&quot;Hello World!&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没有看错，这个文件中只有一行代码，没有任何的using, namespace等代码。&lt;/p&gt;
&lt;p&gt;然后我们在命令行执行&lt;code&gt;dotnet-script helloworld.csx&lt;/code&gt;, 结果如下，&quot;Hello World!&quot;被正确的输出了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet-script helloworld.csx
Hello world!&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;dotnet-script&lt;/code&gt;可以支持使用Roslyn #r 语法(&lt;code&gt;#r &quot;nuget: {包名}, {版本号}&quot;&lt;/code&gt;)引用各种Nuget包。&lt;/p&gt;
&lt;p&gt;例如，下面我们修改helloworld.csx文件, 引入&lt;code&gt;Newtownsoft.Json&lt;/code&gt;库，输出一个序列化之后的字符串。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;#r &quot;nuget: Newtonsoft.Json, 11.0.2&quot;

using Newtonsoft.Json;

Console.WriteLine(JsonConvert.SerializeObject(new {
        Message = &quot;HelloWorld!&quot;
}));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用命令行&lt;code&gt;dotnet-script helloworld.csx&lt;/code&gt;重新运行helloworld.csx文件, 结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet-script helloworld.csx
{&quot;Message&quot;:&quot;HelloWorld!&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.7430167597765&quot;&gt;
&lt;p&gt;Tips: 这里使用的是默认的Nuget源, 如果你想手动添加其他Nuget源, 运行脚本的时候，请添加&lt;code&gt;-s&lt;/code&gt;参数, 例&lt;code&gt;dotnet script foo.csx -s &lt;a href=&quot;https://SomePackageSource&quot; class=&quot;uri&quot;&gt;https://SomePackageSource&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最新版本的&lt;code&gt;dotnet-script&lt;/code&gt;还支持了EHRL - Read Evaluate Print Loop, 即读取-求值-打印-循环, 这是一个在诸如Ruby、Python和Lisp这样的动态语言才有的特性。&lt;/p&gt;
&lt;p&gt;开发人员可以在命令行使用&lt;code&gt;dotnet script&lt;/code&gt;命令, 进入EHRL模式, 根据你输入的表达式, &lt;code&gt;dotnet-script&lt;/code&gt;会帮你打印出表达式的结果。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet script
&amp;gt; 2+2
4
&amp;gt; var myName = &quot;Lamond Lu&quot;;
&amp;gt; Console.WriteLine(myName.ToUpper());
LAMOND LU
&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然在这里你也可以使用Roslyn #r 语法(&lt;code&gt;#r &quot;nuget: {包名}, {版本号}&quot;&lt;/code&gt;)引用各种Nuget包， 例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet script
&amp;gt; #r &quot;nuget: Automapper, 6.1.1&quot;
&amp;gt; using AutoMapper;
&amp;gt; typeof(MapperConfiguration)
[AutoMapper.MapperConfiguration]
&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，EHRL中，还支持多行代码模式。 &lt;code&gt;dotnet-script&lt;/code&gt;会帮助你检测代码块是否完整，如果当你点击回车的时候，代码块不完整，就会出现&lt;code&gt;*&lt;/code&gt;开头的新行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet script
&amp;gt; public class Foo{
* public string Name{get;set;}
* }
&amp;gt; var foo = new Foo();
&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;除了运行本地脚本，最新版本的&lt;code&gt;dotnet-script&lt;/code&gt;还添加了运行远程脚本的功能，你需要使用http/https将你的脚本文件暴露出来。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet script https://tinyurl.com/y8cda9zt
Hello World&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dotnet-script&lt;/code&gt;还支持根据csx脚本文件，生成EXE或DLL文件。&lt;/p&gt;
&lt;p&gt;可用的参数列表如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;指定文件生成的目录，默认当前目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;指定生成的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;指定使用的配置[Release/Debug]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;是否启用Debug输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;指定运行时&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们以第一个HelloWorld.csx为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\script&amp;gt;dotnet-script publish helloworld.csx
Published C:\script\helloworld.csx (executable) to C:\script\publish\win10-x64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行以上命令后，&lt;code&gt;dotnet-script&lt;/code&gt;会使用SCD(Self-contained deployments)的方式生成script.dll和script.exe及运行它所需要的所有基础库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dotnet-script&lt;/code&gt;作为了一个global tool, 相当简单易用, 使用它，你可以像学习Python一样学习.NET Core，在命令行练习各种代码。当然开发人员也可以使用它编写一些简单脚本，而不需要每次都去创建工程项目文件。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 22:34:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9820366.html</dc:identifier>
</item>
<item>
<title>MongoDB副本集及C#程序的连接配置 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9819905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9819905.html</guid>
<description>&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;．副本集&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;高可用是绝大多数数据库管理系统的核心目标之一。如果要想生产数据在发生故障后依然可用，就需要确保为生产数据库多部署一台服务器。MongoDB副本集提供了数据的保护、高可用和灾难恢复的机制。&lt;br/&gt;在MongoDB中，有两种数据冗余方式,一种是 Master-Slave 模式（主从复制），一种是 Replica Sets 模式（副本集）。主从复制和副本集使用了相同的复制机制，但是副本集额外增加了自动化灾备机制：如果主节点宕机，其中一个从节点会自动提升为从节点。除此之外，副本集还提供了其他改进，比如更易于恢复和更复杂地部署拓扑网络。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;集群中没有特定的主库，主库是选举产生，如果主库down了，会再选举出一台主库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181019233320779-1033003295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可复制集推荐使用的最小配置包含&lt;span lang=&quot;EN-US&quot;&gt;3个节点，因为在可复制集里如果只有&lt;span lang=&quot;EN-US&quot;&gt;2个节点，那么一旦主节点垮掉，就无法进行多数投票表决。在&lt;span lang=&quot;EN-US&quot;&gt;3个成员的可复制集里可部署包含&lt;span lang=&quot;EN-US&quot;&gt;3个存储数据的节点服务器，其节点示意图如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181019233357457-27983414.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;也可以是2个数据存储服务器加上一个裁判服务器，其节点示意图如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181019233439266-530520199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（一主一副一仲裁）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;目前，作者所在公司建立的集群大多采用后者架构。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;2.MongoDB.Driver&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;下图是C#的MongoDB.Driver驱动版本与MongoDB版本支持关系，目前安装的MongoDB版本都是3.4.4 及以上版本。所以MongoDB.Driver版本应该选用2.4 及以上。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181019233613774-1220318901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;连接字符串格式&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;副本集连接字符串格式&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;mongodb://username:password@host1:port1,host2:port2[,...,hostN:portN]/database?options&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;options是连接配置中的可选项，replicaSet是其中的一个子项。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面我们举一个例子来说明字符串是怎么配置的，测试环境的副本集信息如下：&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;16&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td nowrap=&quot;nowrap&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;副本集名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td nowrap=&quot;nowrap&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;节点角色&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td nowrap=&quot;nowrap&quot; width=&quot;116&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;节点IP&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td nowrap=&quot;nowrap&quot; width=&quot;67&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;端口&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;left&quot;&gt;repsms&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;left&quot;&gt;主服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;116&quot;&gt;
&lt;p align=&quot;left&quot;&gt;172.177.177.XX1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;67&quot;&gt;
&lt;p align=&quot;right&quot;&gt;27017&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;left&quot;&gt;副本节点&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;116&quot;&gt;
&lt;p align=&quot;left&quot;&gt;172.177.177.XX2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;67&quot;&gt;
&lt;p align=&quot;right&quot;&gt;27017&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;123&quot;&gt;
&lt;p align=&quot;left&quot;&gt;仲裁节点&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;116&quot;&gt;
&lt;p align=&quot;left&quot;&gt;172.177.177.XX3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot; nowrap=&quot;nowrap&quot; width=&quot;67&quot;&gt;
&lt;p align=&quot;right&quot;&gt;27017&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;账号信息如下：&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Username&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Password&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;DBName&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;109&quot;&gt;
&lt;p align=&quot;left&quot;&gt;mongousertest&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;
&lt;p align=&quot;left&quot;&gt;testuserpwd&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;left&quot;&gt;mongotestdb&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此时C#程序中connectionStr的字符串可以设置如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;stringconnectionStr = &quot;mongodb://mongousertest:testuserpwd@172.177.177.xx1:27017,172.177.177.xx2:27017/mongotestdb?replicaSet=reptest&quot;;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;注意：因为仲裁节点没有数据副本，仲裁节点也不可能会被选举为主节点，所以连接字符串信息中不要包含仲裁节点的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;&lt;strong&gt;[说明：本文副本集相关图片来自网络，在此感谢原创作者。]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 19 Oct 2018 15:50:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>1．副本集 高可用是绝大多数数据库管理系统的核心目标之一。如果要想生产数据在发生故障后依然可用，就需要确保为生产数据库多部署一台服务器。MongoDB副本集提供了数据的保护、高可用和灾难恢复的机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9819905.html</dc:identifier>
</item>
<item>
<title>Java学习 - Mesy</title>
<link>http://www.cnblogs.com/Mesy/p/9819915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mesy/p/9819915.html</guid>
<description>[unable to retrieve full-text content]Java实现栈和队列的源码：https://www.cnblogs.com/CherishFX/p/4608880.html 栈和队列的应用：https://blog.csdn.net/xiongmao_dada/article/details/50019165?utm_source=blogxgw</description>
<pubDate>Fri, 19 Oct 2018 15:50:00 +0000</pubDate>
<dc:creator>Mesy</dc:creator>
<og:description>Java实现栈和队列的源码：https://www.cnblogs.com/CherishFX/p/4608880.html 栈和队列的应用：https://blog.csdn.net/xiongma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mesy/p/9819915.html</dc:identifier>
</item>
<item>
<title>hadoop学习线路图，参考 - code--fly</title>
<link>http://www.cnblogs.com/code-fly-blogs/p/9819882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code-fly-blogs/p/9819882.html</guid>
<description>&lt;p&gt;转载自：https://blog.csdn.net/zhoudaxia/article/details/8801769&lt;/p&gt;
&lt;p&gt;按照这个路线图来学习即可。&lt;br/&gt;    1、M. Tim Jones的三篇文章：&lt;br/&gt;    用Hadoop进行分布式数据处理第1部分（入门）：http://www.ibm.com/developerworks/cn/linux/l-hadoop-1/index.html&lt;br/&gt;    用Hadoop进行分布式数据处理第2部分（进阶）：http://www.ibm.com/developerworks/cn/linux/l-hadoop-2/index.html&lt;br/&gt;    用Hadoop进行分布式数据处理第3部分（应用程序开发）：http://www.ibm.com/developerworks/cn/linux/l-hadoop-3/index.html&lt;/p&gt;
&lt;p&gt;    2、“银河里的星星”的博客，其中的Google论文系列（就包括开创性论文“MapReduce:简化大集群上的数据处理”）、搜索与分布式方面的介绍&lt;br/&gt;    [google论文三]MapReduce简化大集群上的数据处理：http://duanple.blog.163.com/blog/static/709717672010923203501/&lt;br/&gt;    词频统计的Map/Reduce程序可以从这里找到：http://blog.csdn.net/shijinupc/article/details/7522446&lt;br/&gt;    Google论文系列：http://duanple.blog.163.com/blog/#m=0&amp;amp;t=3&amp;amp;c=google&lt;br/&gt;    按照Hadoop各组件来串联：http://duanple.blog.163.com/blog/static/7097176720119791920962/&lt;br/&gt;    &lt;br/&gt;    3、IBM developerWorks上的其他Hadoop文章，在dw上用Hadoop关键字进行搜索，可以找到大量Hadoop的文章&lt;br/&gt;    下面一些需要看：&lt;br/&gt;    Hadoop Distributed File System简介：http://www.ibm.com/developerworks/cn/web/wa-introhdfs/index.html&lt;br/&gt;    使用Apache Pig处理数据：http://www.ibm.com/developerworks/cn/bigdata/basic.html&lt;br/&gt;        &lt;br/&gt;    4、《开源软件架构》中的介绍&lt;br/&gt;    （卷1第8章）HDFS--Hadoop分布式文件系统：http://www.ituring.com.cn/article/4299&lt;br/&gt;    英文原文：http://www.aosabook.org/en/index.html （其中的卷1第8章）&lt;br/&gt;    &lt;br/&gt;    5、阿里集团数据平台的官方博客，包含大量Hadoop研究和应用经验&lt;br/&gt;    http://www.alidata.org/archives&lt;br/&gt;    &lt;br/&gt;    6、百度搜索研发部的官方博客，主要包含分布式系统（Hadoop）、搜索技术、数据挖掘、大型网站架构等方面的经验&lt;br/&gt;    http://baidu-tech.com/&lt;/p&gt;

&lt;p&gt;    7、董的博客，关于Hadoop、分布式系统的研究&lt;/p&gt;
&lt;p&gt;    http://dongxicheng.org/recommend/&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    8、官方文档当然更不能少了，主要包括Hadoop集群的搭建，MapReduce的使用，HDFS架构方面的介绍&lt;br/&gt;    优先看稳定版：http://hadoop.apache.org/docs/stable/&lt;br/&gt;    最新版（包括下一代MapReduce即YARN的介绍）：http://hadoop.apache.org/docs/current/&lt;br/&gt;        &lt;br/&gt;    9、caibinbupt的博客，Hadoop源代码分析系列&lt;br/&gt;    http://caibinbupt.iteye.com/?page=6&lt;br/&gt;    千与的专栏，Hadoop-0.20.0源码分析&lt;br/&gt;    http://blog.csdn.net/shirdrn/article/category/595039/3&lt;br/&gt;    &lt;br/&gt;    10、spork的博客，其中关于Hadoop的系列&lt;br/&gt;    http://www.cnblogs.com/spork/category/226077.html&lt;br/&gt;    &lt;br/&gt;    11、chinacloud的博客，其中的Hadoop架构、分布式系统设计方面的一些经验&lt;br/&gt;    http://www.cnblogs.com/chinacloud/archive/2010/12/03/1895369.html&lt;br/&gt;    &lt;br/&gt;    12、beanmoon的博客，其中的Hadoop系列&lt;br/&gt;    http://www.cnblogs.com/beanmoon/&lt;br/&gt;---------------------&lt;br/&gt;作者：Dave888Zhou&lt;br/&gt;来源：CSDN&lt;br/&gt;原文：https://blog.csdn.net/zhoudaxia/article/details/8801769&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 15:40:00 +0000</pubDate>
<dc:creator>code--fly</dc:creator>
<og:description>转载自：https://blog.csdn.net/zhoudaxia/article/details/8801769 按照这个路线图来学习即可。 1、M. Tim Jones的三篇文章： 用Hado</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code-fly-blogs/p/9819882.html</dc:identifier>
</item>
<item>
<title>OEMCC 13.2 集群版本安装部署 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9819091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9819091.html</guid>
<description>&lt;p&gt;之前测试部署过OEMCC 13.2单机，具体可参考之前随笔：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当时环境：&lt;/strong&gt;两台主机，系统RHEL 6.5，分别部署OMS和OMR：&lt;br/&gt;OMS，也就是OEMCC的服务端 IP：192.168.1.88 内存：12G+ 硬盘：100G+&lt;br/&gt;OMR，也就是OEM底层的资料库 IP：192.168.1.89 内存：8G+ 硬盘：100G+&lt;/p&gt;
&lt;p&gt;相当于OMS和OMR都是单机版，然后有些客户对监控系统的要求也很高，这就需要集群来提升高可用性。&lt;br/&gt;对于OMR来说，可以搭建对应版本的RAC来解决单点故障，那么对于OMS而言，又如何构建具备高可用性的集群呢？&lt;br/&gt;最近遇到某客户有这样的高可用需求，本文总结记录一下OEMCC集群版本的完整安装过程。&lt;/p&gt;

&lt;p&gt;客户要求部署OEMCC13.2集群，包括OMR的集群和OMS的集群，其中OMR的集群就是对应Oracle 12.1.0.2 RAC；OMS的集群要求Active-Active模式，并配合SLB实现负载均衡。&lt;/p&gt;

&lt;p&gt;使用两台虚拟机来实现部署。配置信息如下：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_pre-env-config.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要提前下载如下安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--oemcc13.2安装介质
em13200p1_linux64.bin
em13200p1_linux64-2.zip
em13200p1_linux64-3.zip
em13200p1_linux64-4.zip
em13200p1_linux64-5.zip
em13200p1_linux64-6.zip
em13200p1_linux64-7.zip
--oracle 12.1.0.2 RAC 安装介质：
p21419221_121020_Linux-x86-64_1of10.zip
p21419221_121020_Linux-x86-64_2of10.zip
p21419221_121020_Linux-x86-64_5of10.zip
p21419221_121020_Linux-x86-64_6of10.zip
--dbca针对oemcc13.2的建库模版：
12.1.0.2.0_Database_Template_for_EM13_2_0_0_0_Linux_x64.zip&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;OMR集群通过Oracle RAC来实现：OEMCC 13.2提供的模版，要求资料库（OMR）版本为12.1.0.2。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.1&quot;&gt;3.1 环境准备&lt;/h2&gt;
&lt;br/&gt;1) 配置yum源安装依赖rpm包：
&lt;pre&gt;
&lt;code&gt;yum install binutils compat-libcap1 compat-libstdc++-33 \
e2fsprogs e2fsprogs-libs glibc glibc-devel ksh libaio-devel libaio libgcc libstdc++ libstdc++-devel \
libxcb libX11 libXau libXi libXtst make \
net-tools nfs-utils smartmontools sysstat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2) 各节点关闭防火墙、SELinux：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--各节点关闭防火墙:
service iptables stop
chkconfig iptables off

--各节点关闭SELinux:
getenforce
修改/etc/selinux/config SELINUX= disabled
--临时关闭SELinux
setenforce 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3) 配置 /etc/hosts文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#public ip
10.1.43.211 oemapp1
10.1.43.212 oemapp2
#virtual ip
10.1.43.208 oemapp1-vip
10.1.43.209 oemapp2-vip
#scan ip
10.1.43.210 oemapp-scan

#private ip
172.16.43.211 oemapp1-priv
172.16.43.212 oemapp2-priv&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4) 创建用户、组；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--创建group &amp;amp; user：
groupadd -g 54321 oinstall
groupadd -g 54322 dba
groupadd -g 54323 oper
groupadd -g 54324 backupdba
groupadd -g 54325 dgdba
groupadd -g 54326 kmdba  
groupadd -g 54327 asmdba  
groupadd -g 54328 asmoper  
groupadd -g 54329 asmadmin  
groupadd -g 54330 racdba  
  
useradd -u 54321 -g oinstall -G dba,asmdba,backupdba,dgdba,kmdba,racdba,oper oracle  
useradd -u 54322 -g oinstall -G asmadmin,asmdba,asmoper,dba grid  

--然后给oracle、grid设置密码：
passwd oracle 
passwd grid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5) 各节点创建安装目录(root用户)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /app/12.1.0.2/grid
mkdir -p /app/grid
mkdir -p /app/oracle
chown -R grid:oinstall /app
chown oracle:oinstall /app/oracle
chmod -R 775 /app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6) 共享LUN规则配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/udev/rules.d/99-oracle-asmdevices.rules
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29ad39372db383c7903d31788d0&quot;, NAME=&quot;asm-data1&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c298c085f4e57c1f9fcd7b3d1dbf&quot;, NAME=&quot;asm-data2&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c290b495ab0b6c1b57536f4b3cf8&quot;, NAME=&quot;asm-ocr1&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29e7743dca47419aca041b88221&quot;, NAME=&quot;asm-ocr2&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;
KERNEL==&quot;sd*&quot;, BUS==&quot;scsi&quot;, PROGRAM==&quot;/sbin/scsi_id --whitelisted --replace-whitespace --device=/dev/$name&quot;, RESULT==&quot;36000c29608a9ddb8b3168936d01a4f7b&quot;, NAME=&quot;asm-ocr3&quot;, OWNER=&quot;grid&quot;, GROUP=&quot;asmadmin&quot;, MODE=&quot;0660&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载规则后确认共享LUN名称和权限属组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@oemapp1 media]# udevadm control --reload-rules 
[root@oemapp1 media]# udevadm trigger
[root@oemapp1 media]# ls -l /dev/asm*
brw-rw----. 1 grid asmadmin 8, 16 Oct  9 12:27 /dev/asm-data1
brw-rw----. 1 grid asmadmin 8, 32 Oct  9 12:27 /dev/asm-data2
brw-rw----. 1 grid asmadmin 8, 48 Oct  9 12:27 /dev/asm-ocr1
brw-rw----. 1 grid asmadmin 8, 64 Oct  9 12:27 /dev/asm-ocr2
brw-rw----. 1 grid asmadmin 8, 80 Oct  9 12:27 /dev/asm-ocr3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7) 内核参数修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/sysctl.conf
# vi /etc/sysctl.conf  增加如下内容：
fs.file-max = 6815744  
kernel.sem = 250 32000 100 128  
kernel.shmmni = 4096  
kernel.shmall = 1073741824  
kernel.shmmax = 6597069766656
kernel.panic_on_oops = 1  
net.core.rmem_default = 262144  
net.core.rmem_max = 4194304  
net.core.wmem_default = 262144  
net.core.wmem_max = 1048576  
net.ipv4.conf.eth1.rp_filter = 2
net.ipv4.conf.eth0.rp_filter = 1  
fs.aio-max-nr = 1048576  
net.ipv4.ip_local_port_range = 9000 65500  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改生效：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# /sbin/sysctl –p&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8) 用户shell的限制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/security/limits.conf
#在/etc/security/limits.conf 增加如下内容：
grid soft nproc 2047
grid hard nproc 16384
grid soft nofile 1024
grid hard nofile 65536
grid soft stack 10240
oracle soft nproc 2047
oracle hard nproc 16384
oracle soft nofile 1024
oracle hard nofile 65536
oracle soft stack 10240&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9) 插入式认证模块配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi /etc/pam.d/login
--加载 pam_limits.so 模块
 使用 root 用户修改以下文件/etc/pam.d/login,增加如下内容：
session required pam_limits.so&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：limits.conf 文件实际是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so 的配置文件，而且只针对于单个会话。&lt;/p&gt;
&lt;p&gt;10) 各节点设置用户的环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--第1个节点grid用户：
export ORACLE_SID=+ASM1;
export ORACLE_BASE=/app/grid
export ORACLE_HOME=/app/12.1.0.2/grid; 
export PATH=$ORACLE_HOME/bin:$PATH;
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib 

--第2个节点grid用户：
export ORACLE_SID=+ASM2;
export ORACLE_BASE=/app/grid
export ORACLE_HOME=/app/12.1.0.2/grid; 
export PATH=$ORACLE_HOME/bin:$PATH;
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;

--第1个节点oracle用户：
export ORACLE_SID=omr1; 
export ORACLE_BASE=/app/oracle;
export ORACLE_HOME=/app/oracle/product/12.1.0.2/db_1;
export ORACLE_HOSTNAME=;
export PATH=$ORACLE_HOME/bin:$PATH; 
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib; 

--第2个节点oracle用户：
export ORACLE_SID=omr2; 
export ORACLE_BASE=/app/oracle;
export ORACLE_HOME=/app/oracle/product/12.1.0.2/db_1;
export ORACLE_HOSTNAME=;
export PATH=$ORACLE_HOME/bin:$PATH; 
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; 
export CLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3.2&quot;&gt;3.2 GI安装&lt;/h2&gt;
&lt;p&gt;解压安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip p21419221_121020_Linux-x86-64_5of10.zip
unzip p21419221_121020_Linux-x86-64_6of10.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面安装GI：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[grid@oemapp1 grid]$ export DISPLAY=10.1.52.76:0.0
[grid@oemapp1 grid]$ ./runInstaller&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid12.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid13.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid14.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid15.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid16.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid17.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid18.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid19-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_grid20.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.3&quot;&gt;3.3 创建ASM磁盘组、ACFS集群文件系统&lt;/h2&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面创建ASM磁盘组、ACFS集群文件系统：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[grid@oemapp1 grid]$ export DISPLAY=10.1.52.76:0.0
[grid@oemapp1 grid]$ asmca&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建ASM磁盘组：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_asmca04.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建ACFS集群文件系统：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_acfs06.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.4&quot;&gt;3.4 DB软件安装&lt;/h2&gt;
&lt;p&gt;解压安装介质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip p21419221_121020_Linux-x86-64_1of10.zip
unzip p21419221_121020_Linux-x86-64_2of10.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置DISPLAY变量，调用图形界面安装DB软件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 database]$ export DISPLAY=10.1.52.76:0.0
[oracle@oemapp1 database]$ ./runInstaller&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装db软件：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db11-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db11-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_db12.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3.5&quot;&gt;3.5 DBCA使用模版建库&lt;/h2&gt;
&lt;p&gt;解压模版文件到模版目录下，之后dbca就可以从这些模版中选择使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 media]$ unzip 12.1.0.2.0_Database_Template_for_EM13_2_0_0_0_Linux_x64.zip -d /app/oracle/product/12.1.0.2/db_1/assistants/dbca/templates&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DBCA建库步骤：&lt;br/&gt;注意：数据库字符集强烈建议选择AL32UTF8，在后面配置OMS的时候会有对应提示。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca12-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca12-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca13.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca14.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_dbca15.PNG&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本次OMS的集群要求Active-Active模式，并配合SLB实现负载均衡。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.1&quot;&gt;4.1 环境准备&lt;/h2&gt;
&lt;br/&gt;以下环境准备工作是对OMS的两个节点同步操作：&lt;br/&gt;oracle用户环境变量添加：
&lt;pre&gt;
&lt;code&gt;#OMS
export OMS_HOME=$ORACLE_BASE/oms_local/middleware
export AGENT_HOME=$ORACLE_BASE/oms_local/agent/agent_13.2.0.0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;su - oracle
mkdir -p /app/oracle/oms_local/agent
mkdir -p /app/oracle/oms_local/middleware&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对/etc/hosts 修订，使符合oemcc对主机名称的要求（选做）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#public ip
10.1.43.211 oemapp1 oemapp1.oracle.com
10.1.43.212 oemapp2 oemapp2.oracle.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4.2&quot;&gt;4.2 安装主节点&lt;/h2&gt;
&lt;p&gt;开始安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;su - oracle
export DISPLAY=10.1.52.76:0.0
./em13200p1_linux64.bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装步骤：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc02.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc03.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc05.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc06.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc07.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc08.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc09.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc10.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc11.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc12-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc12-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc13-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc13-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_oemcc14.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.3&quot;&gt;4.3 添加OMS节点&lt;/h2&gt;
&lt;p&gt;本节使用OEMCC来添加OMS节点，需要先添加agent，然后添加OMS节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;说明：
1./app/oracle/OMS是共享文件系统；
2./app/oracle/oms_local是各节点本地的文件系统；
3.OMR数据库的processes参数需要从默认300修改为600.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1) 添加agent&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent02-4.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_agent03-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_completed.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2) 添加OMS节点&lt;br/&gt;选择Enterprise menu -&amp;gt; Provisioning and Patching -&amp;gt; Procedure Library.&lt;br/&gt;找到Add Oracle Management Service，点击Launch。&lt;br/&gt;注意：OMS的相关端口，每个OMS节点尽可能保持一致，避免增加后续配置维护的复杂性。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add01.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add02-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add03-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add04.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-0.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-1.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-2.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-3.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-4.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-5.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-6.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-7.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-8.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_add05-9.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4.4&quot;&gt;4.4 测试OMS高可用性&lt;/h2&gt;
&lt;p&gt;分别使用节点1和节点2的IP地址均可以正常访问到OEMCC网页界面：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_211OK.PNG&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_212OK.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;且任意关掉某一节点，另外存活节点访问不受影响。&lt;br/&gt;附：操作oms启动／停止／查看状态的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--查看oms状态
$OMS_HOME/bin/emctl status oms
$OMS_HOME/bin/emctl status oms –details
--停止oms
$OMS_HOME/bin/emctl stop oms
$OMS_HOME/bin/emctl stop oms –all
--启动oms
$OMS_HOME/bin/emctl start oms&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;负载均衡使用的产品是radware，这部分需要负载均衡工程师进行配置。下面是根据Oracle官方文档结合本次需求整理出的配置要求，供参考：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_slb-config01.png&quot;/&gt;&lt;br/&gt;其他具体配置项，例如Monitors、Pools、Required Virtual Servers等都按此为基准结合官方文档进行规划设计即可，不再赘述。&lt;/p&gt;
&lt;p&gt;在/etc/hosts 添加负载均衡地址名称解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10.1.44.207 myslb.oracle.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SLB配置后，OMS同步需要配置。&lt;/p&gt;
&lt;p&gt;配置OMS：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$OMS_HOME/bin/emctl secure oms -host myslb.oracle.com -secure_port 4903 -slb_port 4903 -slb_console_port 443 -slb_bip_https_port 5443 -slb_jvmd_https_port 7301 -lock_console -lock_upload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置agent：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$AGENT_HOME/bin/emctl secure agent –emdWalletSrcUrl https://myslb.oracle.com:4903/em&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看oms状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 backup]$ $OMS_HOME/bin/emctl status oms -details
Oracle Enterprise Manager Cloud Control 13c Release 2  
Copyright (c) 1996, 2016 Oracle Corporation.  All rights reserved.
Enter Enterprise Manager Root (SYSMAN) Password : 
Console Server Host        : oemapp1.oracle.com
HTTP Console Port          : 7788
HTTPS Console Port         : 7802
HTTP Upload Port           : 4889
HTTPS Upload Port          : 4903
EM Instance Home           : /app/oracle/oms_local/gc_inst/em/EMGC_OMS1
OMS Log Directory Location : /app/oracle/oms_local/gc_inst/em/EMGC_OMS1/sysman/log
SLB or virtual hostname: myslb.oracle.com
HTTPS SLB Upload Port : 4903
HTTPS SLB Console Port : 443
HTTPS SLB JVMD Port : 7301
Agent Upload is locked.
OMS Console is locked.
Active CA ID: 1
Console URL: https://myslb.oracle.com:443/em
Upload URL: https://myslb.oracle.com:4903/empbs/upload

WLS Domain Information
Domain Name            : GCDomain
Admin Server Host      : oemapp1.oracle.com
Admin Server HTTPS Port: 7102
Admin Server is RUNNING

Oracle Management Server Information
Managed Server Instance Name: EMGC_OMS1
Oracle Management Server Instance Host: oemapp1.oracle.com
WebTier is Up
Oracle Management Server is Up
JVMD Engine is Up

BI Publisher Server Information
BI Publisher Managed Server Name: BIP
BI Publisher Server is Up

BI Publisher HTTP Managed Server Port   : 9701
BI Publisher HTTPS Managed Server Port  : 9803
BI Publisher HTTP OHS Port              : 9788
BI Publisher HTTPS OHS Port             : 9851
BI Publisher HTTPS SLB Port             : 5443
BI Publisher is locked.
BI Publisher Server named 'BIP' running at URL: https://myslb.oracle.com:5443/xmlpserver
BI Publisher Server Logs: /app/oracle/oms_local/gc_inst/user_projects/domains/GCDomain/servers/BIP/logs/
BI Publisher Log        : /app/oracle/oms_local/gc_inst/user_projects/domains/GCDomain/servers/BIP/logs/bipublisher/bipublisher.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看agent状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@oemapp1 backup]$ $AGENT_HOME/bin/emctl status agent
Oracle Enterprise Manager Cloud Control 13c Release 2  
Copyright (c) 1996, 2016 Oracle Corporation.  All rights reserved.
---------------------------------------------------------------
Agent Version          : 13.2.0.0.0
OMS Version            : 13.2.0.0.0
Protocol Version       : 12.1.0.1.0
Agent Home             : /app/oracle/oms_local/agent/agent_inst
Agent Log Directory    : /app/oracle/oms_local/agent/agent_inst/sysman/log
Agent Binaries         : /app/oracle/oms_local/agent/agent_13.2.0.0.0
Core JAR Location      : /app/oracle/oms_local/agent/agent_13.2.0.0.0/jlib
Agent Process ID       : 17263
Parent Process ID      : 17060
Agent URL              : https://oemapp1.oracle.com:3872/emd/main/
Local Agent URL in NAT : https://oemapp1.oracle.com:3872/emd/main/
Repository URL         : https://myslb.oracle.com:4903/empbs/upload
Started at             : 2018-10-12 15:49:58
Started by user        : oracle
Operating System       : Linux version 2.6.32-696.el6.x86_64 (amd64)
Number of Targets      : 34
Last Reload            : (none)
Last successful upload                       : 2018-10-12 15:50:53
Last attempted upload                        : 2018-10-12 15:50:53
Total Megabytes of XML files uploaded so far : 0.17
Number of XML files pending upload           : 19
Size of XML files pending upload(MB)         : 0.07
Available disk space on upload filesystem    : 63.80%
Collection Status                            : Collections enabled
Heartbeat Status                             : Ok
Last attempted heartbeat to OMS              : 2018-10-12 15:50:33
Last successful heartbeat to OMS             : 2018-10-12 15:50:33
Next scheduled heartbeat to OMS              : 2018-10-12 15:51:35

---------------------------------------------------------------
Agent is Running and Ready&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终测试，通过负载均衡地址10.1.44.207可以直接访问OEMCC，进行正常操作：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1323338/o_all-complete.PNG&quot;/&gt;&lt;br/&gt;至此，OEMCC13.2集群安装已完成。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 14:51:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>之前测试部署过OEMCC 13.2单机，具体可参考之前随笔：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9819091.html</dc:identifier>
</item>
<item>
<title>借鉴Glide思想二次封装Fresco - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9819009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9819009.html</guid>
<description>&lt;p&gt;最近封装了个 Fresco 的组件库：&lt;a href=&quot;https://github.com/woshidasusu/base-module/tree/master/fresco&quot;&gt;DFresco&lt;/a&gt;，就顺便来讲讲。&lt;/p&gt;

&lt;p&gt;Fresco 图片库很强大，我们项目中就是使用的 Fresco，但有一点就是，不怎么好使用，略麻烦。不同项目中，多多少少都需要对 Fresco 进行一层封装才能在 ui 里快速使用。&lt;/p&gt;
&lt;p&gt;这就导致了，不同项目都根据自己的业务需求场景来进行封装，每次有新项目，复制粘贴时又得解决好多业务耦合的错误，麻烦，是真的麻烦~&lt;/p&gt;
&lt;p&gt;而且，首次接触 Fresco，接入上手的成本相比其他图片库，如 Glide，成本都要大很多。&lt;/p&gt;
&lt;p&gt;举个例子，假如你有这么个需求：加载一张网络上的 gif 图片，为了防止内存占用过多，需要设置分辨率压缩，最后显示到圆形控件上，同时，需要设置占位图，错误图，拉伸方式等。&lt;/p&gt;
&lt;p&gt;那么此时，你的代码可能就是这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ImageDecodeOptions imageDecodeOptions = ImageDecodeOptions.newBuilder()
        .setDecodePreviewFrame(true).build();
ImageRequestBuilder builder = ImageRequestBuilder.newBuilderWithSource(mUri)
        .setProgressiveRenderingEnabled(true)
        .setImageDecodeOptions(imageDecodeOptions);
if (mWidth &amp;gt; 0 &amp;amp;&amp;amp; mHeight &amp;gt; 0) {
    builder.setResizeOptions(new ResizeOptions(mWidth, mHeight));
}

ImageRequest request = builder.build();
AbstractDraweeController controller = Fresco.newDraweeControllerBuilder()
            .setImageRequest(request)
            .setControllerListener(listener)
            .setOldController(draweeView.getController())
            .setAutoPlayAnimations(true).build();
draweeView.setController(controller);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，你可能还需要在 xml 中对 SimpleDrawwView 控件进行占位图等等的配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;com.facebook.drawee.view.SimpleDraweeView
        android:id=&quot;@+id/sdv_fresco&quot;
        android:layout_width=&quot;500dp&quot;
        android:layout_height=&quot;500dp&quot;
        fresco:actualImageScaleType=&quot;centerCrop&quot;
        fresco:fadeDuration=&quot;3000&quot;
        fresco:failureImage=&quot;@mipmap/ic_launcher&quot;
        fresco:failureImageScaleType=&quot;centerCrop&quot;
        fresco:placeholderImage=&quot;@mipmap/ic_launcher&quot;
        fresco:placeholderImageScaleType=&quot;centerCrop&quot;
        fresco:progressBarAutoRotateInterval=&quot;1000&quot;
        fresco:progressBarImage=&quot;@drawable/ani_rotate&quot;
        fresco:progressBarImageScaleType=&quot;centerCrop&quot;
        fresco:retryImage=&quot;@mipmap/ic_launcher&quot;
        fresco:retryImageScaleType=&quot;centerCrop&quot;
        fresco:backgroundImage=&quot;@mipmap/ic_launcher&quot;
        fresco:overlayImage=&quot;@mipmap/ic_launcher&quot;
        fresco:pressedStateOverlayImage=&quot;@mipmap/ic_launcher&quot;
        fresco:roundAsCircle=&quot;false&quot;
        fresco:roundingBorderWidth=&quot;2dip&quot;
        fresco:roundingBorderColor=&quot;@color/colorPrimary&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果忘记了某个自定义属性名是什么的时候，还得到网上搜索下资料，是吧。&lt;/p&gt;
&lt;p&gt;小结一下，使用 Fresco，你的接入学习成本至少需要知道 Fresco 的如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SimpleDraweeView 的自定义属性&lt;/li&gt;
&lt;li&gt;ImageRequestBuilder 用法及大概用途&lt;/li&gt;
&lt;li&gt;AbstractDraweeController 用法及大概用途&lt;/li&gt;
&lt;li&gt;GenericDraweeHierarchy 用法及大概用途&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果涉及到一些网络下载监听，缓存之类的，那么你还要了解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Imagepipeline 用法及大概用途&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，Fresco 强大是强大，但使用起来不方便，不得不封装一层。&lt;/p&gt;
&lt;p&gt;既然要封装，那么就直接借鉴 Glide 的使用思想来进行封装好了，如果有使用过 Glide 的应该很清楚，要实现以上功能，全程一个调用链即可。&lt;/p&gt;

&lt;p&gt;封装要达到的目的有两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用简洁、方便&lt;/li&gt;
&lt;li&gt;其他人接入直接上手的成本尽可能少，最好不用去看文档，去看源码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一点可以参考 Glide 的使用方式来设计，那么第二点我的想法是借助 AndroidStudio 的代码提示功能来实现。&lt;/p&gt;
&lt;p&gt;比如，你只需知道，组件的入口是 DFresco 即可，其他都通过 AndroidStudio 来给你提示，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a5f473375cac6cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Dfresco入口.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你在 AndroidStudio 上输入 &lt;code&gt;DFresco.&lt;/code&gt; 后，界面上会弹出你可用 api，这些就是我开放给你的入口，我将这个使用过程划分成几个步骤，每个步骤能做什么，该做什么，我都给你规定好了，你参照着提示，直接从方法命名上就能够知道该如何使用了，AndroidStudio 会一步步引导你。&lt;/p&gt;
&lt;p&gt;这里就两个入口，一个是用来初始化 Fresco 的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init(Context)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个内部封装了一些默认的初始化配置，比如内存大小配置，内部日志配置等等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;init(Context, ImagePipelineConfig)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个是开放给你的自定义配置，如果你不想使用默认的配置的话。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;source(String url)&lt;/code&gt; ：加载网络上的图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(File localFile)&lt;/code&gt; ：加载磁盘上的图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(Context context, int resId)&lt;/code&gt; ：加载 res 内的 drawable 资源图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source(Uri uri)&lt;/code&gt; ：通用的加载方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我将常用的几种图片来源单独封装出来使用，方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a0cfd99084357ca6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DFresco第二步.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当调用了 &lt;code&gt;source()&lt;/code&gt; 后就进入了第二个步骤，这个步骤中，我将图片相关的配置设计到另外一个步骤中去，否则连同图片配置的 api 也都在这里的话，会搞得蛮乱的，可能让使用者到这里后不清楚该调用哪些接口了。&lt;/p&gt;
&lt;p&gt;所以，我会把控每个步骤的 api，尽量让每个步骤的 api 做的事都比较相近，比如这里：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;intoTarget(SimpleDraweeView)&lt;/code&gt; 加载图片显示到控件上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intoTarget(SimpleDraweeView，ControllerListener)&lt;/code&gt; 加载图片显示到控件上，允许监听这个过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intoTarget(BaseBitmapDataSubscriber)&lt;/code&gt; 只加载图片到内存中，以 Bitmap 形式存在&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我的需求场景大概就是直接加载图片显示到控件上，或者有时候只是需要将图片加载到内存中，但不用显示到某个控件上，反而要取得图片的 Bitmap 对象，所以我将这些都封装起来了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resize(int width, int height)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个实际上就是对 Fresco 中的 ResizeOptions 的一层封装而已，简化使用，不至于像以前那么麻烦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;enterImageConfig()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你都使用默认配置的话，那么是不用再去调用那些各种配置的接口的，所以我才将图片配置封装到另外一个步骤中，这个步骤你可进，可不进，如果有需求，那么通过这个方法进入图片配置步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-849966a1a62a8598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ImageConfig.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的配置项很多，也是因为这个原因，所以才不想让这些接口跟上一个步骤放一起，不然很容易让使用者懵掉。而进入了图片配置这个步骤后，这里提供的 api 其实就是对 GenericDraweeHierarchy 的用途进行了一层封装，或者说对 SimpleDraweeView 的自定义属性进行了一层封装。&lt;/p&gt;
&lt;p&gt;如果你不熟悉，没关系，其实就是一些常用的功能，如设置控件为圆形、圆角、边框，设置占位图、失败图、进度图、图片拉伸方式、淡入淡出动画时长等等。&lt;/p&gt;
&lt;p&gt;这样封装的目的在于，你可以通过一条调用链的形式就设置完所有的配置，就像 Glide 的使用一样，而不用再去 new 很多 Fresco 的类，再去拼接。&lt;/p&gt;
&lt;p&gt;进入图片配置步骤只是一个可选的步骤，进来之后当然就要出去，所以当完成了你的配置后，需要调用：&lt;code&gt;finishImageConfig()&lt;/code&gt;，如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-1a196e6efa920365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;第三部.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了图片配置，将流程切回主线了，就可以继续根据你的需要设置图片显示的目标了。&lt;/p&gt;
&lt;p&gt;当然，为了防止再次进入图片配置步骤这样造成之前的配置项失效的场景，我借鉴了 Fresco 的 &lt;code&gt;init&lt;/code&gt; 处理方法，即，如果一次使用过程中，重复进入图片配置步骤，那么程序会抛异常来提醒你不能这么做。&lt;/p&gt;
&lt;p&gt;以上，就是 DFresco 组件的封装思想，欢迎指点一下哈~&lt;/p&gt;
&lt;p&gt;另外，参考了 Glide 的一些处理，当你的 intoTarget 是传入了 SimpleDraweeView 控件时，DFresco 内部会自动根据控件的大小对图片进行一次分辨率压缩，降低图片占用内存，当然，如果你有手动调用了 &lt;code&gt;resize()&lt;/code&gt;，那么以你的为主。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;compile 'com.dasu.image:fresco:0.0.1'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用之前，需先初始化，建议在 Application 中进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DFresco.init(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//加载 res 中的 drawable 图片到 SimpleDraweeView 控件上（默认支持 gif 图，并且会自动根据控件宽高进行分辨率压缩，降低内存占用
DFresco.source(mContext, R.drawable.weixin).intoTarget(mSimpleDraweeView);

//加载磁盘中的图片，手动设置分辨率的压缩，并获取 bitmap 对象，监听回调，手动显示到 ImageView 控件上
DFresco.source(new File(&quot;/mnt/sdcard/weixin.jpg&quot;))
        .resize(500, 500)
        .intoTarget(new BaseBitmapDataSubscriber() {
                @Override
                protected void onNewResultImpl(Bitmap bitmap) {
                    Log.w(&quot;!!!!!!&quot;, &quot;bitmap：ByteCount = &quot; + bitmap.getByteCount() + &quot;:::bitmap：AllocationByteCount = &quot; + bitmap.getAllocationByteCount());
                    Log.w(&quot;!!!!!!&quot;, &quot;width:&quot; + bitmap.getWidth() + &quot;:::height:&quot; + bitmap.getHeight());
                    mImageView.setImageBitmap(bitmap);
                }

                @Override
                protected void onFailureImpl(DataSource&amp;lt;CloseableReference&amp;lt;CloseableImage&amp;gt;&amp;gt; dataSource) {
                    Log.e(&quot;!!!!!!&quot;, &quot;onFailureImpl&quot;);
                }
            });

//加载网络图片，进行各种配置，如缩放方式，占位图，圆形，圆角，动画时长等等，最后自动显示到 SimpleDraweeView 控件上
DFresco.source(&quot;https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png&quot;)
                    .enterImageConfig() //进入配置步骤
                    .allFitXY()  //所有图片，包括占位图等等的拉伸方式
                    .animFade(3000) //淡入淡出动画时长
                    .placeholderScaleType(ScalingUtils.ScaleType.CENTER_INSIDE) //设置占位图的拉伸方式，后面设置的会覆盖前面的
                    .actualScaleType(ScalingUtils.ScaleType.CENTER)
//                    .asRound(50) //设置圆角，（圆角和圆形不能同时设置）
                    .asCircle() //设置控件显示为圆形控件
                    .roundBorderColor(Color.RED) //设置圆角或圆形的边框颜色
                    .roundBorderWidth(20)  //设置圆角或圆形的边框宽度
                    .failure(R.drawable.timg) //设置失败图
                    .progressBar(R.drawable.aaaa) //设置加载进度图
                    .retry(R.drawable.weixin) //设置重试时的图
                    .placeholder(R.drawable.image) //设置占位图
                    .finishImageConfig() //退出配置步骤
                    .intoTarget(mSimpleDraweeView);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/woshidasusu/base-module/tree/master/fresco&quot;&gt;DFresco：https://github.com/woshidasusu/base-module/tree/master/fresco&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 13:43:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>最近封装了个 Fresco 的组件库：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9819009.html</dc:identifier>
</item>
<item>
<title>flex笔记 - 基础 - noobakong</title>
<link>http://www.cnblogs.com/noobakong/p/9818863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noobakong/p/9818863.html</guid>
<description>&lt;h2 id=&quot;flex笔记---基础&quot;&gt;flex笔记 - 基础&lt;/h2&gt;
&lt;p&gt;文章中的所有图示代码都放在了github上： &lt;a href=&quot;https://github.com/noobakong/notes/tree/master/02-CSS/01-Flex%E5%B8%83%E5%B1%80&quot;&gt;阮一峰flex博客跟学代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传统的布局解决方案，基于&lt;strong&gt;盒模型&lt;/strong&gt;， 依赖 display, position, float属性来进行布局，有的时候很不方便，实现垂直居中就很不方便。&lt;/p&gt;
&lt;h3 id=&quot;一.-flex简介&quot;&gt;一. Flex简介&lt;/h3&gt;
&lt;p&gt;Flex 是 Flexible Box 的缩写，译为&lt;strong&gt;弹性布局&lt;/strong&gt;，用来为盒模型提供最大的灵活性。&lt;/p&gt;
&lt;p&gt;任何一个容器都可以使用 Flex 布局&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;元素设置为Flex布局后，子元素的 &lt;code&gt;float&lt;/code&gt;,&lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;vertical-align&lt;/code&gt; 属性将失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二.-基本概念&quot;&gt;二. 基本概念&lt;/h3&gt;
&lt;p&gt;采用Flex布局的元素，为Flex容器，它所有的子元素自动成为容器成员，成为Flex成员，（flex item）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png&quot; alt=&quot;Flex图解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个flex布局存在两根轴，水平横轴，也叫主轴（即图中的 &lt;strong&gt;main axis&lt;/strong&gt;) 和 垂直纵轴 （&lt;strong&gt;cross axis&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;横轴的开始位置，也就是图中左边框上的点集合， 叫做&lt;code&gt;main start&lt;/code&gt;，结束位置，图中右边框的点集合，叫做&lt;code&gt;main end&lt;/code&gt;，垂直纵轴的开始位置（上边框的点）叫做&lt;code&gt;cross start&lt;/code&gt;，结束位置，下边框的点，叫做&lt;code&gt;cross end&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;每一个成员item的水平空间和垂直空间分别为 &lt;code&gt;main size&lt;/code&gt;和 &lt;code&gt;cross size&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;三.-容器属性&quot;&gt;三. 容器属性&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接下来的展示demo github项目中的代码为了方便有些属性写在了item成员上，最正确的方式是些在flex容器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-direction&quot;&gt;1. flex-direction&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-direction&lt;/code&gt;属性决定水平横轴的方向（即项目的排列方向）。&lt;/p&gt;
&lt;p&gt;它可取以下四个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;row&lt;/code&gt;（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;row-reverse&lt;/code&gt;：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt;：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column-reverse&lt;/code&gt;：主轴为垂直方向，起点在下沿。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-flex-direction.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-wrap属性&quot;&gt;2. flex-wrap属性&lt;/h4&gt;
&lt;p&gt;默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。&lt;code&gt;flex-wrap&lt;/code&gt;属性定义，如果一条轴线排不下，如何换行。&lt;/p&gt;
&lt;p&gt;它可取三个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;nowrap&lt;/code&gt;（默认）：不换行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrap&lt;/code&gt;：换行，第一行在上方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrap-reverse&lt;/code&gt;：换行，第一行在下方&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如图我们可以发现，默认的nowrap属性的优先级是高于我们设置的width的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-flex-wrap.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-flow&quot;&gt;3. flex-flow&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-flow&lt;/code&gt;属性是&lt;code&gt;flex-direction&lt;/code&gt;属性和&lt;code&gt;flex-wrap&lt;/code&gt;属性的简写形式，默认值为&lt;code&gt;row nowrap&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;justify-content属性&quot;&gt;4. justify-content属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;justify-content&lt;/code&gt;属性定义了项目在水平横轴上的对齐方式&lt;/p&gt;
&lt;p&gt;阮老师的博客图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性能取5个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：右对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;： 居中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;/code&gt;：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-justify-content.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;align-items属性&quot;&gt;5. align-items属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;属性定义项目在垂直纵轴上如何对齐。 和justify-content属性一块记忆比较容易。&lt;/p&gt;
&lt;p&gt;它可能取5个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;baseline&lt;/code&gt;: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：如果项目&lt;strong&gt;未设置高度&lt;/strong&gt;或设为auto，将占满整个容器的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下图示例是的垂直纵轴方向是由上到下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-align-items.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;align-content属性&quot;&gt;6. align-content属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;属性定义了多根轴线的对齐方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;只适用于&lt;strong&gt;多行&lt;/strong&gt; 的flex容器&lt;/p&gt;
&lt;p&gt;该属性可能取6个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;：与垂直轴的起点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：与垂直轴的终点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;：与垂直轴的中点对齐。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;/code&gt;：与垂直轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stretch&lt;/code&gt;（默认值）：轴线占满整个垂直轴。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-align-content.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四.-item成员的属性&quot;&gt;四. item成员的属性&lt;/h3&gt;
&lt;h4 id=&quot;order属性&quot;&gt;1. order属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;order&lt;/code&gt;属性定义项目的排列顺序。数值越小，排列越靠前，默认为0&lt;/p&gt;
&lt;h4 id=&quot;flex-grow属性&quot;&gt;2. flex-grow属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-grow&lt;/code&gt;属性定义项目的放大比例，默认为&lt;code&gt;0&lt;/code&gt;，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-grow&lt;/code&gt;属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的&lt;code&gt;flex-grow&lt;/code&gt;属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-shrink属性&quot;&gt;3. flex-shrink属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-shrink&lt;/code&gt;属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性都为1，当空间不足时，都将等比例缩小。如果一个项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/p&gt;
&lt;p&gt;负值对该属性无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex-basis属性&quot;&gt;4. flex-basis属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex-basis&lt;/code&gt;属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为&lt;code&gt;auto&lt;/code&gt;，即项目的本来大小。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;它可以设为跟&lt;code&gt;width&lt;/code&gt;或&lt;code&gt;height&lt;/code&gt;属性一样的值（比如350px），则项目将占据固定空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;flex属性&quot;&gt;5. flex属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和 &lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该属性有两个快捷值：&lt;code&gt;auto&lt;/code&gt; (&lt;code&gt;1 1 auto&lt;/code&gt;) 和 none (&lt;code&gt;0 0 auto&lt;/code&gt;)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;align-self属性&quot;&gt;6. align-self属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;align-self&lt;/code&gt;属性允许单个项目有与其他项目不一样的对齐方式，可覆盖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pd92xwp9t.bkt.clouddn.com/image/notes/flex-item.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>noobakong</dc:creator>
<og:description>flex笔记 基础 文章中的所有图示代码都放在了github上：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noobakong/p/9818863.html</dc:identifier>
</item>
<item>
<title>Java虚拟机性能监测工具Visual VM与OQL对象查询语言 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9818491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9818491.html</guid>
<description>&lt;p&gt;Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具，它集成了多种性能统计工具的功能，使用 Visual VM 可以代替jstat、jmap、jhat、jstack甚至是JConsole。在JDK 6 Update 7以后，Visual Vm便作为JDK的一部分发布，它完全免费。&lt;/p&gt;
&lt;p&gt;官方下载：&lt;a href=&quot;https://visualvm.github.io/download.html&quot; class=&quot;uri&quot;&gt;https://visualvm.github.io/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文汉化版：&lt;a href=&quot;https://download.csdn.net/download/yueshutong123/10729777&quot; class=&quot;uri&quot;&gt;https://download.csdn.net/download/yueshutong123/10729777&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual VM插件的安装非常容易，既可以通过离线下载插件*.nbm。然后在 PLugin 对话框的Downloaded页面下，添加已下载的插件。也可以在Availble Plugin页面下，在线安装插件，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195349854-1273448410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是启动VisualVm.exe报错：Can'nt find java1.8 or or higher ,只需要编辑\etc\visualvm.conf文件，找到下面这行并重新指向本地Java路径即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;visualvm_jdkhome=&quot;D:\Java\jdk1.8.0&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;汉化版的插件地址已过时，点击“插件”-&amp;gt;“设置”-&amp;gt;“编辑”，更换URL为https://visualvm.github.io/archive/uc/release138/updates.xml.gz&lt;/p&gt;
&lt;p&gt;插件地址汇总：&lt;a href=&quot;https://visualvm.github.io/pluginscenters.html&quot; class=&quot;uri&quot;&gt;https://visualvm.github.io/pluginscenters.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;visual-vm连接应用程序&quot;&gt;1.1 Visual VM连接应用程序&lt;/h2&gt;
&lt;p&gt;1）Visual VM支持多种连接应用程序，最常见的就是本地连接。只要本地计算机内有Java应用程序正在执行，就可以监测到。如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195410417-1257919564.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）除了本地连接外，Visual VM也支持远程JMX连接。Java应用程序可以通过以下参数启动程序打开JMX端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Djava.rmi.server.hostname=127.0.0.1       #远程服务器的ip地址
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=8888   #指定jmx监听的端口
-Dcom.sun.management.jmxremote.authenticate=false  #是否开启认证
-Dcom.sun.management.jmxremote.ssl=false   #是否开启ssl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加JMX连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195437788-1988961039.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加成功后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195453307-940304575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）添加远程主机。远程主机可以通过jstatd工具建立，如使用以下命令开启&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; jstatd -J-Djava.security.policy=c:\jstatd.all.policy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文本文件jstatd.all.policy的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {
permission java.security.AllPermission;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在Visual VM中添加远程主机，如图。正确填写计算机IP地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195509688-319265979.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;监控应用程序概况&quot;&gt;1.2 监控应用程序概况&lt;/h2&gt;
&lt;p&gt;通过Visual VM，可以查看应用程序的基本情况。比如，进程ID、Main Class、启动参数等。&lt;/p&gt;
&lt;p&gt;单机Tab页面的Monitor页面，即可监控应用程序的CPU、堆、永久区、类加载和线程数的总体情况。通过页面上的Perform GC 和 Heap Dump按钮还可以手工执行Full GC和生成堆快照。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195525092-1676606830.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;thread-dump和分析&quot;&gt;1.3 Thread Dump和分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195540985-452759335.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;1.4 性能分析&lt;/h2&gt;
&lt;p&gt;Visual VM有CPU和内存两个采样器。&lt;/p&gt;
&lt;p&gt;编写测试程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HProfTest {
    public void slowMethod(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void slowerMethod(){
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void fastMethod(){
        try {
            Thread.yield();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        while (true) {
            HProfTest hProfTest = new HProfTest();
            hProfTest.fastMethod();
            hProfTest.slowMethod();
            hProfTest.slowerMethod();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过Visual VM的采样功能，可以找到占用CPU时间最长的方法。如图slowerMethod()方法占用时间最长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195556939-1505328615.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Visual VM的默认统计信息中，不包含JDK内的函数调用统计，需要单击右上角的设置，手工配置。如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195614875-223850578.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快照&quot;&gt;1.5 快照&lt;/h2&gt;
&lt;p&gt;选中java应用，单击应用程序，即可查看堆Dump，线程Dump等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195639494-1349795380.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右击dump快照，可另存为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195717251-1656409003.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存快照分析&quot;&gt;1.6 内存快照分析&lt;/h2&gt;
&lt;p&gt;通过选中右键的堆Dump命令，可以立即获得当前应用程序的内存快照，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195731900-378544401.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在类页面中，还可以对两个不同的内存快照文件进行比较。这个功能可以帮助开发者快速分析同一应用程序运行的不同时刻，内存数据产生的变化。&lt;/p&gt;
&lt;p&gt;在这个类展示的页面中，如果需要获取类的更多信息，可以单击右键，进入该类的实例页面；或者直接双击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195754049-628848661.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实例页面中，将显示类的所有实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195807850-21279711.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mbean管理&quot;&gt;1.7 MBean管理&lt;/h2&gt;
&lt;p&gt;Visual VM可以通过插件，集成JConsole的MBean管理功能。&lt;br/&gt;关于JConsole MBean的使用请参考另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/yueshutong/p/9812464.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yueshutong/p/9812464.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;tda使用&quot;&gt;1.8 TDA使用&lt;/h2&gt;
&lt;p&gt;TDA 是Thread Dump Analyzer 的缩写，是一款线程快照分析工具。当使用jstack或者Visual VM等工具取得线程快照文件后，使用TDA可以帮助开发者分析导出的线程快照。TDA即是一款单独的软件，又是Visual VM的插件。当作为插件时，导出快照后，TDA会自启动。&lt;/p&gt;
&lt;h2 id=&quot;btrace介绍&quot;&gt;1.9 BTrace介绍&lt;/h2&gt;
&lt;p&gt;BTrace 通过字节码注入，动态监控系统的运行情况。它可以跟踪指定的方法调用、构造函数调用和系统内存等信息。在Visual VM中安装插件BTrace后，右击Java程序打开Trece application。如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195822601-1464749633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BTrace脚本示范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@BTrace
public class TimeLogger {

  @TLS 
  private static long startTime = 0;

 @OnMethod(clazz=&quot;/.+/&quot;, //监控任意类
  method=&quot;/slowMethod/&quot;)    //监控slowMethod方法
  public static void startMethod(){
    startTime = timeMillis();
  }

  @OnMethod(clazz=&quot;/.+/&quot;,method=&quot;/slowMethod/&quot;,location=@Location(Kind.RETURN))//方法返回时触发
  public static void endMethod(){
    long time = timeMillis() - startTime;
    println(strcat(&quot;execute time(nanos): &quot;, str(time)));
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上脚本使用@OnMethod注释指定要监控的类和方法名称。@Location注释，可以指定程序运行到某一行代码时，触发某一行为。&lt;/p&gt;
&lt;p&gt;@OnMethod(clazz=&quot;/.+/&quot;, location=@Location(Kind.LINE, line=26))&lt;/p&gt;
&lt;p&gt;定时触发(ms)&lt;/p&gt;
&lt;p&gt;@OnMethod 更换为 @OnTimer(3000)&lt;/p&gt;
&lt;p&gt;监控参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void endMethod(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[]  args){
    //pcn 类名称

    //pmn 方法名称

    //args 参数

  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监控文件&lt;/p&gt;
&lt;p&gt;method=&quot;&amp;lt;init&amp;gt;&quot; //监控构造函数&lt;/p&gt;

&lt;p&gt;上面我们学会了如何查看堆内存快照，但是，堆内存快照十分庞大，快照中的类数量也很多。Visual VM提供了对OQL（对象查询语言）的支持，以便于开发人员在庞大的堆内存数据中，快速定位所需的资源。&lt;/p&gt;
&lt;h2 id=&quot;visual-vm的oql基本语法&quot;&gt;2.1 Visual VM的OQL基本语法&lt;/h2&gt;
&lt;p&gt;OQL 语言是一种类似SQL的查询语言。基本语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select &amp;lt;JavaScript expression to select&amp;gt;
[ from [instanceof] &amp;lt;class name&amp;gt; &amp;lt;identifier&amp;gt;
[ where &amp;lt;JavaScript boolean expression to filter&amp;gt; ] ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OQL由3个部分组成：select 子句、from 子句和where 子句。select 子句指定查询结果要显示的内容；from 子句指定查询范围，可指定类名，如java.lang.String、char[]、[Ljava.io.File（File数组）;where 子句用于指定查询条件。&lt;/p&gt;
&lt;p&gt;select 子句和where 子句支持使用Javascript 语法处理较为复杂的查询逻辑；select 子句可以使用类似json的语法输出多个列；from子句中可以使用instanceof关键字，将给定类的子类也包括到输出列表中。&lt;/p&gt;
&lt;p&gt;在Visual VM的OQL中，可以直接访问对象的属性和部分方法。如下例中，直接使用了String对象的count属性，筛选出长度大于等于100的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s from java.lang.String s where s.count &amp;gt;= 100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选取长度大于等于256的 int 数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select a from int[] a where a.length &amp;gt;= 256&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;筛选出表示两位数整数的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {instance: s, content: s.toString()} from java.lang.String s where /^\d{2}$/(s.toString())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中，select 子句使用了json语法，指定输出两列为String对象以及String.toString() 的输出。where 子句使用正则表达式，指定了符合/^\d{2}$/条件的字符串。&lt;/p&gt;
&lt;p&gt;下例使用 instance 关键字选取所有的ClassLoader，包括子类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select cl from instanceof java.lang.ClassLoader cl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在Java程序中，一个类可能会被多个ClassLoader同时载入，因此，这种情况下，可能需要使用Class的ID来指定Class。如下例，选出了所有ID为0x37A014D8的Class对象实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s from 0x37A014D8 s;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Visual VM 的 OQL 语言支持Javascript作为子表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;内置heap对象&quot;&gt;2.2 内置heap对象&lt;/h2&gt;
&lt;p&gt;heap对象是 Visual VM OQL 的内置对象。通过 heap 对象可以实现一些强大的OQL功能。heap 对象的主要方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;forEachClass()：对每一个Class对象执行一个回调操作。它的使用方法类似于 heap.forEachClass(callback)，其中 callback 为 Javascript 函数。&lt;/li&gt;
&lt;li&gt;findClass()：查找给定名称的类对象，返回类的方法和属性参考表6.3.它的调用方法类似 heap.findClass(className)。&lt;/li&gt;
&lt;li&gt;classes()：返回堆快照中所有的类集合。使用方法如 heap.classes()。&lt;/li&gt;
&lt;li&gt;objects()：返回堆快照中所有的对象集合。使用方法如 heap.objects(clazz,[includeSubtypes],[filter])，其中clazz指定类名称，includeSubtypes指定是否选出子类，filter 为过滤器，指定筛选规则。includeSubtypes 和 filter 可以省略。&lt;/li&gt;
&lt;li&gt;livepaths()：返回指定对象的存活路径。即，显示哪些对象直接或者间接引用了给定对象。它的使用方法如heap.livepaths(obj)。&lt;/li&gt;
&lt;li&gt;roots()：返回这个堆的根对象。使用方法如heap.roots()。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用findClass()返回的Class对象拥有的属性和方法 ：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;name：类名称&lt;/td&gt;
&lt;td&gt;isSubclassOf()：是否是指定类的子类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;superclass：父类&lt;/td&gt;
&lt;td&gt;isSuperclassOf()：是否是指定类的父类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;statics：类的静态变量的名称和值&lt;/td&gt;
&lt;td&gt;subclasses()：返回所有子类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;fields：类的域信息&lt;/td&gt;
&lt;td&gt;superclasses()：返回所有父类&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下例查找java.util.Vector类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;java.util.Vector&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找java.util.Vector的所有父类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;java.util.Vector&quot;).superclasses() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.AbstractList  
java.util.AbstractCollection  
java.lang.Object &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找所有在java.io包下的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找字符串“56”的引用链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.livepaths(s) from java.lang.String s where s.toString()=='56' &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下是一种可能的输出结果，其中java.lang.String#1600即字符串“56”。它显示了该字符串被一个WebPage对象持有。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.String#1600-&amp;gt;geym.zbase.ch7.heap.WebPage#57-&amp;gt;java.lang.Object[]#341-&amp;gt;java.util.Vector#11-&amp;gt;geym.zbase.ch7.heap.Student#3 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找这个堆的根对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.roots() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例查找当前堆中所有java.io.File对象实例，参数true表示java.io.File的子类也需要被显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.objects(&quot;java.io.File&quot;,true) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例访问了TraceStudent类的静态成员webpages对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select heap.findClass(&quot;geym.zbase.ch7.heap.TraceStudent&quot;).webpages &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象函数&quot;&gt;2.3 对象函数&lt;/h2&gt;
&lt;p&gt;在Visual VM中，为OQL语言还提供了一组以对象为操作目标的内置函数。通过这些函数，可以获取目标对象的更多信息。本节主要介绍一些常用的对象函数。&lt;/p&gt;
&lt;h3 id=&quot;classof函数&quot;&gt;1．classof()函数&lt;/h3&gt;
&lt;p&gt;返回给定Java对象的类。调用方法形如classof(objname)。返回的类对象有以下属性。&lt;/p&gt;
&lt;p&gt;Class对象拥有以下方法。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isSubclassOf()：是否是指定类的子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;isSuperclassOf()：是否是指定类的父类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;subclasses()：返回所有子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;superclasses()：返回所有父类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例将返回所有Vector类以及子类的类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select classof(v) from instanceof java.util.Vector v &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种可能的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.Vector  
java.util.Vector  
java.util.Stack &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectid函数&quot;&gt;2．objectid()函数&lt;/h3&gt;
&lt;p&gt;objectid()函数返回对象的ID。使用方法如objectid(objname)。&lt;/p&gt;
&lt;p&gt;返回所有Vector对象（不包含子类）的ID：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select objectid(v) from  java.util.Vector v &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reachables函数&quot;&gt;3．reachables()函数&lt;/h3&gt;
&lt;p&gt;reachables()函数返回给定对象的可达对象集合。使用方法如reachables(obj,[exclude])。obj为给定对象，exclude指定忽略给定对象中的某一字段的可达引用。&lt;/p&gt;
&lt;p&gt;下例返回'56'这个String对象的所有可达对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select reachables(s) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的部分输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char[]#264&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的返回结果是 java.lang.String.value 域的引用对象。即，给定的 String 类型的 value 域指向对象 char[]#264。如果使用过滤，要求输出结果中不包含 java.lang.String.value 域的引用对象，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select reachables(s, &quot;java.lang.String.value&quot;) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询输出结果为空，因为String对象只有value包含对其它对象的引用。&lt;/p&gt;
&lt;h3 id=&quot;referrers函数&quot;&gt;4．referrers()函数&lt;/h3&gt;
&lt;p&gt;返回引用给定对象的对象集合。使用方法如：referrers(obj)。&lt;/p&gt;
&lt;p&gt;下例返回了引用“56”String对象的对象集合：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referrers(s) from java.lang.String s where s.toString()=='56'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出可能如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.Object[]#1077
java.lang.Object[]#1055&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明一个Object数组引用了“56”这个字符串对象。在查询结果中单击 java.lang.Object[]#1077，可进一步找到引用 java.lang.Object[]#1077 对象的是一个ArrayList对象。如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195850014-339926264.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下例找出长度为2，并且至少被2个对象引用的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s.toString() from java.lang.String s where (s.count==2 &amp;amp;&amp;amp; count(referrers(s)) &amp;gt;=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：where子句中使用的逻辑运算符是&amp;amp;&amp;amp;。这是JavaScript语法，不能像SQL一样使用AND操作符。&lt;/p&gt;
&lt;h3 id=&quot;referees函数&quot;&gt;5．referees()函数&lt;/h3&gt;
&lt;p&gt;referees()函数返回给定对象的直接引用对象集合，用法形如：referees(obj)。&lt;/p&gt;
&lt;p&gt;下例返回了File对象的静态成员引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referees(heap.findClass(&quot;java.io.File&quot;)) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回长度为2，并且至少被2个对象引用的字符串的直接引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select referees(s) from java.lang.String s where (s.count==2 &amp;amp;&amp;amp; count(referrers(s)) &amp;gt;=2 )&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sizeof函数&quot;&gt;6．sizeof()函数&lt;/h3&gt;
&lt;p&gt;sizeof()函数返回指定对象的大小（不包括它的引用对象），即浅堆（Shallow Size）。&lt;/p&gt;
&lt;p&gt;注意：sizeof()函数返回对象的大小不包括对象的引用对象。因此，sizeof()的返回值由对象的类型决定，和对象的具体内容无关。&lt;/p&gt;
&lt;p&gt;下例返回所有int数组的大小以及对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),Object:o} from int[] o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回所有Vector的大小以及对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),Object:o} from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的输出可能为如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
size = 36,
Object = java.util.Vector#5
}
{
size = 36,
Object = java.util.Vector#6
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，不论Vector集合包含多少对象。Vector对象所占用的内存大小始终为36字节。这是由Vector本身的结构决定的，与其内容无关。sizeof()函数就是返回对象的固有大小。&lt;/p&gt;
&lt;h3 id=&quot;rsizeof函数&quot;&gt;7．rsizeof()函数&lt;/h3&gt;
&lt;p&gt;rsizeof()函数返回对象以及其引用对象的大小总和，即深堆（Retained Size）。这个数值不仅与类本身的结构有关，还与对象的当前数据内容有关。&lt;/p&gt;
&lt;p&gt;下例显示了所有Vector对象的Shallow Size以及Retained Size：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select {size:sizeof(o),rsize:rsizeof(o)} from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分输出可能如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
size = 36,
rsize = 572
}

{
size = 36,
rsize = 76
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：resizeof()取得对象以及其引用对象的大小总和。因此，它的返回值与对象的当前数据内容有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8．toHtml()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toHtml()函数将对象转为HTML显示。&lt;/p&gt;
&lt;p&gt;下例将Vector对象的输出使用HTML进行加粗和斜体显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select &quot;&amp;lt;b&amp;gt;&amp;lt;em&amp;gt;&quot;+toHtml(o)+&quot;&amp;lt;/em&amp;gt;&amp;lt;/b&amp;gt;&quot; from java.util.Vector o &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出部分结果如图7.44所示。直接点击输出对象，可以展示实例页面中的对应对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019195929957-420535711.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合统计函数&quot;&gt;2.4 集合/统计函数&lt;/h2&gt;
&lt;p&gt;Visual VM中还有一组用于集合操作和统计的函数。可以方便地对结果集进行后处理或者统计操作。集合/统计函数主要有contains()、count()、filter()、length()、map()、max()、min()、sort()、top()等。&lt;/p&gt;
&lt;h3 id=&quot;contains函数&quot;&gt;1．contains()函数&lt;/h3&gt;
&lt;p&gt;contains()函数判断给定集合是否包含满足给定表达式的对象。它的使用方法形如contains(set, boolexpression)。其中set为给定集合，boolexpression为表达式。在boolexpression中，可以使用如下contains()函数的内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回被 File 对象引用的 String 对象集合。首先通过 referrers(s) 得到所有引用String 对象的对象集合。使用 contains() 函数及其参数布尔等式表达式classof(it).name == 'java.io.File')，将 contains() 的筛选条件设置为类名是java.io.File 的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select s.toString() from java.lang.String s where contains(referrers(s), &quot;classof(it).name == 'java.io.File'&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询的部分输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\Java\jdk1.8.0\jre\lib\ext\sunpkcs11.jar
D:\Java\jdk1.8.0\jre\lib\ext\sunec.jar
D:\Java\jdk1.8.0\jre\lib\ext\nashorn.jar
D:\Java\jdk1.8.0\jre\lib\ext\localedata.jar
D:\Java\jdk1.8.0\jre\lib\ext\zipfs.jar
D:\Java\jdk1.8.0\jre\lib\ext\jfxrt.jar
D:\Java\jdk1.8.0\jre\lib\ext\dnsns.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过该OQL，得到了当前堆中所有的File对象的文件名称。可以理解为当前Java程序通过java.io.File获得已打开或持有的所有文件。&lt;/p&gt;
&lt;h3 id=&quot;count函数&quot;&gt;2．count()函数&lt;/h3&gt;
&lt;p&gt;count()函数返回指定集合内满足给定布尔表达式的对象数量。它的基本使用方法如：count(set, [boolexpression])。参数set指定要统计总数的集合，boolexpression为布尔条件表达式，可以省略，但如果指定，count()函数只计算满足表达式的对象个数。在boolexpression表达式中，可以使用以下内置对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;it：当前访问对象。&lt;/li&gt;
&lt;li&gt;index：当前对象索引。&lt;/li&gt;
&lt;li&gt;array：当前迭代的数组/集合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回堆中所有java.io包中的类的数量，布尔表达式使用正则表达式表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下列返回堆中所有类的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(heap.classes()) &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;filter函数&quot;&gt;3．filter()函数&lt;/h3&gt;
&lt;p&gt;filter()函数返回给定集合中，满足某一个布尔表达式的对象子集合。使用方法形如filter(set, boolexpression)。在boolexpression中，可以使用以下内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例返回所有java.io包中的类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(heap.classes(), &quot;/java.io./(it.name)&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例返回了当前堆中，引用了java.io.File对象并且不在java.io包中的所有对象实例。首先使用referrers()函数得到所有引用java.io.File对象的实例，接着使用filter()函数进行过滤，只选取不在java.io包中的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select filter(referrers(f), &quot;! /java.io./(classof(it).name)&quot;) from java.io.File f &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;length函数&quot;&gt;4．length()函数&lt;/h3&gt;
&lt;p&gt;length()函数返回给定集合的数量，使用方法形如length(set)。&lt;/p&gt;
&lt;p&gt;下例返回当前堆中所有类的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select length(heap.classes()) &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map函数&quot;&gt;5．map()函数&lt;/h3&gt;
&lt;p&gt;map()函数将结果集中的每一个元素按照特定的规则进行转换，以方便输出显示。使用方法形如：map(set, transferCode)。set为目标集合，transferCode为转换代码。在transferCode中可以使用以下内置对象。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;it：当前访问对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;index：当前对象索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;array：当前迭代的数组/集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下例将当前堆中的所有File对象进行格式化输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select map(heap.objects(&quot;java.io.File&quot;), &quot;index + '=' + it.path.toString()&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0=D:\tools\jdk1.7_40\jre\bin\zip.dll
1=D:\tools\jdk1.7_40\jre\bin\zip.dll
2=D:\tools\jdk1.7_40\jre\lib\ext
3=C:\Windows\Sun\Java\lib\ext
4=D:\tools\jdk1.7_40\jre\lib\ext\meta-index
5=D:\tools\jdk1.7_40\jre\lib\ext &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：map()函数可以用于输出结果的数据格式化。它可以将集合中每一个对象转成特定的输出格式。&lt;/p&gt;
&lt;h3 id=&quot;max函数&quot;&gt;6．max()函数&lt;/h3&gt;
&lt;p&gt;max()函数计算并得到给定集合的最大元素。使用方法为：max(set, [express])。其中set为给定集合，express为比较表达式，指定元素间的比较逻辑。参数express可以省略，若省略，则执行数值比较。参数express可以使用以下内置对象。&lt;/p&gt;
&lt;p&gt;下例显示了当前堆中最长的String长度。对于JDK 1.6得到的堆，首先使用heap.objects()函数得到所有String对象，接着，使用map()函数将String对象集合转为String对象的长度集合，最后，使用max()函数得到集合中的最大元素。对于JDK 1.7得到的堆，由于String结构发生变化，故通过String.value得到字符串长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6导出的堆  
select max(map(heap.objects('java.lang.String', false), 'it.count'))   
JDK 1.7导出的堆  
select max(map(filter(heap.objects('java.lang.String', false),'it.value!=null'), 'it.value.length'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上OQL的输出为最大字符串长度，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;734.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例取得当前堆的最长字符串。它在max()函数中设置了比较表达式，指定了集合中对象的比较逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6导出的堆  
select max(heap.objects('java.lang.String'), 'lhs.count &amp;gt; rhs.count')   
JDK 1.7导出的堆  
select max(filter(heap.objects('java.lang.String'),'it.value!=null'), 'lhs. value.length &amp;gt; rhs.value.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与上例相比，它得到的是最大字符串对象，而非对象的长度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.String#908 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;min函数&quot;&gt;7．min()函数&lt;/h3&gt;
&lt;p&gt;min()函数计算并得到给定集合的最小元素。使用方法为：min(set, [expression])。其中set为给定集合，expression为比较表达式，指定元素间的比较逻辑。参数expression可以省略，若省略，则执行数值比较。参数expression可以使用以下内置对象：&lt;/p&gt;
&lt;p&gt;下例返回当前堆中数组长度最小的Vector对象的长度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select min(map(heap.objects('java.util.Vector', false), 'it.elementData. length')) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例得到数组元素长度最长的一个Vector对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select min(heap.objects('java.util.Vector'), 'lhs.elementData.length &amp;gt; rhs.elementData.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sort函数&quot;&gt;8．sort()函数&lt;/h3&gt;
&lt;p&gt;sort()函数对指定的集合进行排序。它的一般使用方法为：sort(set, expression)。其中，set为给定集合，expression为集合中对象的排序逻辑。在expression中可以使用以下内置对象：&lt;/p&gt;
&lt;p&gt;下例将当前堆中的所有Vector按照内部数组的大小进行排序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sort(heap.objects('java.util.Vector'), 
'lhs.elementData.length - rhs.elementData.length') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例将当前堆中的所有Vector类（包括子类），按照内部数据长度大小，从小到大排序，并输出Vector对象的实际大小以及对象本身。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select map(    sort(          
heap.objects('java.util.Vector'),       
'lhs.elementData.length - rhs.elementData.length' ), 
'{ size: rsizeof(it), obj: it }'    ) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述查询中，首先通过heap.objects()方法得到所有Vector及其子类的实例，接着，使用sort()函数，通过Vector内部数组长度进行排序，最后使用map()函数对排序后的集合进行格式化输出。&lt;/p&gt;
&lt;h3 id=&quot;top函数&quot;&gt;9．top()函数&lt;/h3&gt;
&lt;p&gt;top()函数返回在给定集合中，按照特定顺序排序的前几个对象。一般使用方法为：top(set, expression,num)。其中set为给定集合，expression为排序逻辑，num指定输出前几个对象。在expression中，可以使用以下内置对象。&lt;/p&gt;
&lt;p&gt;下例显示了长度最长的前5个字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6的堆  
select top(heap.objects('java.lang.String'), 'rhs.count - lhs.count', 5)   
JDK 1.7的堆  
select top(filter(heap.objects('java.lang.String'),'it.value!=null'), 'rhs. value.length - lhs.value.length', 5) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下例显示长度最长的5个字符串，输出它们的长度与对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JDK 1.6的堆  
select map(top(heap.objects('java.lang.String'), 'rhs.count - lhs.count', 5), '{ length: it.count, obj: it }')  
JDK 1.7的堆  
select map(top(filter(heap.objects('java.lang.String'),'it.value!=null'), 'rhs.value.length - lhs.value.length', 5), '{ length: it.value.length, obj: it }') &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述查询的部分输出可能如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{  
length = 734.0, 
obj = java.lang.String#908  } 
{ 
length = 293.0, 
obj = java.lang.String#914  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sum函数&quot;&gt;10．sum()函数&lt;/h3&gt;
&lt;p&gt;sum()函数用于计算集合的累计值。它的一般使用方法为：sum(set,[expression])。其中第一个参数set为给定集合，参数expression用于将当前对象映射到一个整数，以便用于求和。参数expression可以省略，如果省略，则可以使用map()函数作为替代。&lt;/p&gt;
&lt;p&gt;下例计算所有 java.util.Properties 对象的可达对象的总大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sum(map(reachables(p), 'sizeof(it)')) from java.util.Properties p &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将使用 sum() 函数的第2个参数 expression 代替 map() 函数，实现相同的功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select sum(reachables(p), 'sizeof(it)') from java.util.Properties p &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unique函数&quot;&gt;11．unique()函数&lt;/h3&gt;
&lt;p&gt;unique()函数将除去指定集合中的重复元素，返回不包含重复元素的集合。它的一般使用方法形如unique(set)。&lt;/p&gt;
&lt;p&gt;下例返回当前堆中，有多个不同的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select count(unique(map(heap.objects('java.lang.String'), 'it.value'))) &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;程序化oql&quot;&gt;2.5 程序化OQL&lt;/h2&gt;
&lt;p&gt;Visual VM不仅支持在OQL控制台上执行OQL查询语言，也可以通过其OQL相关的JAR包，将OQL查询程序化，从而获得更加灵活的对象查询功能，实现堆快照分析的自动化。&lt;/p&gt;
&lt;p&gt;在进行OQL开发前，工程需要引用Visual VM安装目录下JAR包，如图7.45所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019200034314-1333959757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里以分析Tomcat堆溢出文件为例，展示程序化OQL带来的便利。 对于给定的Tomcat堆溢出Dump文件，这里将展示如何通过程序，计算Tomcat平均每秒产生的session数量，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AveLoadTomcatOOM {
    public static final String dumpFilePath = &quot;d:/tmp/tomcat_oom/tomcat.hprof&quot;;

    public static void main(String args[]) throws Exception {
        OQLEngine engine;
        final List&amp;lt;Long&amp;gt; creationTimes = new ArrayList&amp;lt;Long&amp;gt;(000);
        engine = new OQLEngine(HeapFactory.createHeap(new File(dumpFilePath)));
        String query = &quot;select s.creationTime from org.apache.catalina. session.StandardSession s&quot;; //第8行
        engine.executeQuery(query, new OQLEngine.ObjectVisitor() {
            public boolean visit(Object obj) {
                creationTimes.add((Long) obj);
                return false;
            }
        });
        Collections.sort(creationTimes);
        long min = creationTimes.get(0) / 1000;//第18行
        long max = creationTimes.get(creationTimes.size() - 1) / 1000;
        System.out.println(&quot;平均压力：&quot; + creationTimes.size() * 1.0 / (max - min) + &quot;次/秒&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码第8行，通过OQL语句得到所有session的创建时间，在第18、19行获得所有session中最早创建和最晚创建的session时间，在第21行计算整个时间段内的平均session创建速度。&lt;/p&gt;
&lt;p&gt;运行上述代码，得到输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;平均压力：311.34375次/秒 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式可以做到堆转存文件的全自动化分析，并将结果导出到给定文件，当有多个堆转存文件需要分析时，有着重要的作用。&lt;/p&gt;
&lt;p&gt;除了使用以上方式外，Visual VM的OQL控制台也支持直接使用JavaScript代码进行编程，如下代码实现了相同功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var sessions=toArray(heap.objects(&quot;org.apache.catalina.session.StandardSession&quot;));  
var count=sessions.length;  
var createtimes=new Array();  
for(var i=0;i&amp;lt;count;i++){      createtimes[i]=sessions[i].creationTime;  
}  
createtimes.sort();  
var min=createtimes[0]/1000;  
var max=createtimes[count-1]/1000;  
count/(max-min)+&quot;次/秒&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图显示了在OQL控制台中，执行上述脚本以及输出结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1136672/201810/1136672-20181019200319928-990945901.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的读者可能会发现，这个结果和使用Java访问Dump文件时的结果有所差异，这是因为JavaScript是弱类型语言，在处理整数除法时和Java有所不同，读者可以自行研究，在此不予展开讨论。&lt;/p&gt;
&lt;p&gt;Visual VM的OQL是非常灵活的，除了上述使用JavaScript风格外，也可以使用如下函数式编程风格计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;count(heap.objects('org.apache.catalina.session.StandardSession'))/  (  
max(map(heap.objects('org.apache.catalina.session.StandardSession'),'it.creationTime'))/1000-  
min(map(heap.objects('org.apache.catalina.session.StandardSession'),'it.creationTime'))/1000  ) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码使用了count()、min()、max()、map()等函数，共同完成了平均值的计算。执行上述代码，输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;312.1240594043491 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因JDK版本问题，无法保证上述操作的有效性，仅供学习与参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Oct 2018 12:03:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>1.Visual VM多合一工具 Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具，它集成了多种性能统计工具的功能，使用 Visual VM 可以代替jstat、jmap、jha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9818491.html</dc:identifier>
</item>
<item>
<title>保姆级教程——Ubuntu16.04 Server下深度学习环境搭建：安装CUDA8.0，cuDNN6.0，Bazel0.5.4，源码编译安装TensorFlow1.4.0(GPU版) - 同勉共进</title>
<link>http://www.cnblogs.com/zpcdbky/p/9757821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zpcdbky/p/9757821.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文叙述了在Ubuntu16.04 Server下安装CUDA8.0，cuDNN6.0以及源码编译安装TensorFlow1.4.0(GPU版)的亲身经历，包括遇到的问题及解决办法，也有一些自己的经验，希望能对读者有所帮助。期间参考了许多前人的文章，后文会一一附上链接，在此先行谢过。在下能力有限，经验不足，请大家多多指教。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;Ubuntu16.04 Server   深度学习环境搭建   安装   显卡驱动   CUDA8.0   cuDNN6.0   Bazel   源码编译   TensorFlow1.4.0   GPU版   TensorFlow_gpu1.4.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统和硬件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Ubuntu16.04 Server版&lt;/p&gt;
&lt;p&gt;2.GPU：NVIDIA Tesla P40 （一块）&lt;/p&gt;
&lt;p&gt;3.CPU：Intel Xeon Processor E5-2620 v4   20M Cache,2.10GHz   （两块）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件版本配置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010091721914-1623579633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009215410498-696446925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.以上配置信息来自&lt;a title=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; href=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&lt;/a&gt; ，这也是来自官网的TensorFlow安装教程，也是在下实际安装TensorFlow的过程中的主要参考资料。&lt;/p&gt;
&lt;p&gt;2.在下实际安装时使用的GCC版本为4.9而非4.8，但也没受到任何不良影响。&lt;/p&gt;
&lt;p&gt;3.Ubuntu16.04 Server和显卡驱动安装是由他人完成的，从CUDA8.0的安装开始，都是由在下亲手完成，所以本文重点叙述CUDA等深度学习相关软件库的安装。&lt;/p&gt;
&lt;p&gt;4.本文对其它版本配置的深度学习环境搭建也有一定借鉴意义，许多方法和技巧是通用的。比如：&lt;/p&gt;
&lt;p&gt;            &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xkmc&quot;&gt;查询显卡名称&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;            &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;获取下载链接并使用wget命令下载文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.预警：很长很啰嗦（面向小白，保姆级教程）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title1&quot;&gt;一、安装Ubuntu16.04 Server版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title2&quot;&gt;二、安装显卡驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xkmc&quot;&gt;I. 查看显卡名称&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#xzqd&quot;&gt; II. 下载对应驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#azqd&quot;&gt;III. 安装驱动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title3&quot;&gt;三、安装CUDA8.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_run&quot;&gt;I. 下载.run文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_az&quot;&gt;II. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#C_cs&quot;&gt;III. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title4&quot;&gt;四、安装cuDNN6.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#cu_xz&quot;&gt; I. 下载安装文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#cu_az&quot;&gt;II. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title5&quot;&gt;五、安装Bazel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_ck&quot;&gt;I. 查看/卸已有版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_xz&quot;&gt;II. 下载安装包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_az&quot;&gt;III. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_cs&quot;&gt;IV. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title6&quot;&gt;六、相关准备工作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#gcc&quot;&gt;I. gcc降级&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#qhbb&quot;&gt;II. 切换默认Python版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title7&quot;&gt;七、编译安装TensorFlow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_xz&quot;&gt;I. 下载源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_by&quot;&gt;II. 编译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_az&quot;&gt;III. 安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#tf_cs&quot;&gt;IV. 测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、安装Ubuntu16.04 Server版&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这一部分是其他人做的，在下只是在旁观摩，所以在这里只叙述个大概，详细安装方法请您自行Google。&lt;/p&gt;
&lt;p&gt;下载安装包，做成启动U盘，直接插在机箱上通过BIOS安装（原来机器上装有SentOS），谢天谢地，期间没有遇到什么问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、安装显卡驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显卡驱动也不是在下亲手安装的，这里只给出一些通用的方法和技巧，以及一些可能对您有用的链接，希望对您有所帮助，如有错误纰漏之处，恳请您不吝赐教。&lt;/p&gt;
&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;I. 查看显卡名称&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果您已知您的显卡信息，则略过该步骤。&lt;/p&gt;
&lt;p&gt;现在设想最坏的情况，您不知道您的显卡叫什么名字，也没办法打开机箱来看（比如远程的），问谁谁也不知道，机器上也没有旧的显卡驱动（没有比这更糟糕的了），那么，下面的办法不妨一试：&lt;/p&gt;
&lt;p&gt;step1：运行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
lshw -numeric -C display
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018195712701-1071547139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您使用的是GeForce系列的显卡，上面的命令可以直接输出显卡的名称，但如果您使用的是Tesla系列之类的专业级显卡，上面的命令并不能直接得到显卡名称（如上图所示），这时需要接着进行下面的操作。&lt;/p&gt;
&lt;p&gt;step2：查询显卡名称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接Google关键字10DE:1b38或1A03:2000，第一条就是，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008215858666-1991378829.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222023523-686825366.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008221804987-1965415308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：使用必应搜索也可以，第三条就是。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids&quot; href=&quot;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids&quot; target=&quot;_blank&quot;&gt;https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids &lt;/a&gt; ，Ctrl+F搜索关键字1b38或1a03（不要搜索10de或2000，这两项匹配的结果太多了），如下图。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222739347-1480483919.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181008222857227-448113638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：这个网页上几乎包含了世界上所有显卡（不光是NVIDIA的）的厂商和名称信息，非常全。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://pci-ids.ucw.cz/read/PC/&quot; href=&quot;https://pci-ids.ucw.cz/read/PC/&quot; target=&quot;_blank&quot;&gt;https://pci-ids.ucw.cz/read/PC/&lt;/a&gt;，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009082733137-1325389963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;对10de:1b38而言，我们先找10de，10de以1开头，所以点击上图中的1（用红框圈起来的那个）。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;页面跳转后Ctrl+F查找关键字10de，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009083131538-748492275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;点击10de，页面跳转后Ctrl+F查找关键字1b38，如图&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009083442098-1824826316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;注：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;1.ASPEED Graphics Family（上文中1a03:2000对应的显卡名称）是ASPEED公司（信骅科技，台湾，全球第一大服务器管理芯片供应商）生产的一系列BMC（Baseboard Management Controller ，基板管理控制器）芯片的总称，一般兼做服务器的集显，提供最基础的显示功能。1a03:2000表示AST2000，是ASPEED Graphics Family系列的第一款。更多详情请见：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://pci-ids.ucw.cz/read/PC/1a03/2000&quot; href=&quot;https://pci-ids.ucw.cz/read/PC/1a03/2000&quot; target=&quot;_blank&quot;&gt;https://pci-ids.ucw.cz/read/PC/1a03/2000&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://zhidao.baidu.com/question/504159607.html&quot; href=&quot;https://zhidao.baidu.com/question/504159607.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/504159607.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://zhidao.baidu.com/question/436858677675772444.html&quot; href=&quot;https://zhidao.baidu.com/question/436858677675772444.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/436858677675772444.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;2.网络上的许多教程可能会给出下面一些命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lspci | &lt;span&gt;grep&lt;/span&gt; -&lt;span&gt;i vga
lspci &lt;/span&gt;|&lt;span&gt;grep&lt;/span&gt; -&lt;span&gt;i nvidia
lspci &lt;/span&gt;-v -s &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;     #使用上述两个命令后会输出02:&lt;span&gt;00&lt;/span&gt;.0或06:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;.0等字样
lspci &lt;/span&gt;-v -s &lt;span&gt;06&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;
lspci &lt;/span&gt;-vnn | &lt;span&gt;grep&lt;/span&gt; VGA -A &lt;span&gt;12&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-mce-=&quot;&quot;&gt;如果您的机器使用的是Tesla系列之类的专业级显卡，那么上述命令并不能显示出显卡的名称，但如果您使用的是GeForce系列的显卡，则上述命令可以打印出显卡名称。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;II. 下载对应驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问NVIDIA的官网，填写显卡、系统、CUDA版本等信息，便可下载相应驱动。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;地址：&lt;a title=&quot;https://www.nvidia.com/download/index.aspx&quot; href=&quot;https://www.nvidia.com/download/index.aspx&quot; target=&quot;_blank&quot;&gt;https://www.nvidia.com/download/index.aspx&lt;/a&gt; （English）&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;          &lt;a title=&quot;https://www.nvidia.com/Download/index.aspx?lang=cn&quot; href=&quot;https://www.nvidia.com/Download/index.aspx?lang=cn&quot; target=&quot;_blank&quot;&gt;https://www.nvidia.com/Download/index.aspx?lang=cn&lt;/a&gt;  （Chinese）&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090021638-308237135.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090456393-1548194644.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009090104479-1715660636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009095215721-266866512.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009095610541-553289554.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009100100955-223323926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您的网络使用ivp6协议，那么在实际操作中可能会出现上面第一幅图中所示的下拉列表框点击不动的情况，此时您可能需要使用采用ipv4协议的网络来访问上面的下载地址。&lt;/p&gt;
&lt;p&gt;2.如果您是远程访问，在自己机器上下载好安装文件后还需要使用Xftp等工具将安装文件传输到目标机上，既麻烦又费时，下面介绍一种使用命令行在目标机上直接下载的方法（前提是目标机可以自由访问网络）。&lt;/p&gt;
&lt;p&gt;step1：在上图的绿色按钮（即“AGREE &amp;amp; DOWNLOAD”按钮）上右键，在弹出的菜单中选择“复制链接地址”，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181012110914344-1425242147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：在复制得到的地址前加上“wget”构成如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt;  http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;us.download.nvidia.com/tesla/384.66/nvidia-diag-driver-local-repo-ubuntu1604-384.66_1.0-1_amd64.deb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用该命令便可直接在目标机上在线下载链接指向的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;III. 安装驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跳转到上一步下载的.deb文件所在的目录，依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; dpkg -i nvidia-diag-driver-local-repo-ubuntu1604-&lt;span&gt;384&lt;/span&gt;.66_1.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;1_amd64.deb   #这里需要更换为您自己下载的.deb文件的文件名
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get cuda-&lt;span&gt;drivers
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; reboot now   #安装后重启
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装过程中可能需要您手动回答yes或no（输入y或n），请您根据自己的情况决定（印象中全部选y，但在下没亲自试过）。&lt;/p&gt;
&lt;p&gt;参考网址：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u011889952/article/details/77746668&quot; href=&quot;https://blog.csdn.net/u011889952/article/details/77746668&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u011889952/article/details/77746668&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&quot; href=&quot;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&quot; target=&quot;_blank&quot;&gt;https://gist.github.com/jcjohnson/4976067b503d8d1ebafb5eb6f38f9aae&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.第二个链接中提供了一个自动获取.deb文件并安装的脚本（如您要使用，请记着更改第一行命令中的地址以对应您所需的驱动版本，地址获取方法见上面&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;注2&lt;/a&gt;），其中的参数 --allow-unauthenticated 表示允许使用未通过验证的安装包，--assume-yes 表示对安装过程中的所有询问都回答yes。&lt;/p&gt;
&lt;p&gt;2.除上述方法外，安装驱动的方法还有.run文件、PPA源、apt-get等。有些文章提到用.deb文件安装会失败，此时可以考虑使用.run文件安装，要下载.run文件，只要将上面第一幅图中的Operating System选项选为Linux 64-bit即可，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181009214234850-2125900075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装方法可参考以下链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/1baf9848b7d7&quot; href=&quot;https://www.jianshu.com/p/1baf9848b7d7&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/1baf9848b7d7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.linuxidc.com/Linux/2016-12/138907.htm&quot; href=&quot;https://www.linuxidc.com/Linux/2016-12/138907.htm&quot; target=&quot;_blank&quot;&gt;https://www.linuxidc.com/Linux/2016-12/138907.htm&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/b313625fbe61&quot; href=&quot;https://www.jianshu.com/p/b313625fbe61&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/b313625fbe61&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它安装方法请读者自行探索，这里不再赘述。&lt;/p&gt;
&lt;p&gt;至此，显卡驱动安装完毕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、安装CUDA8.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. 下载.run文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：访问网址&lt;a title=&quot;https://developer.nvidia.com/cuda-downloads?&quot; href=&quot;https://developer.nvidia.com/cuda-downloads?&quot; target=&quot;_blank&quot;&gt;https://developer.nvidia.com/cuda-downloads?&lt;/a&gt; ，按图示操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092052481-1871949925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：不要在上边选择选项，否则下载的将是10.0版本而非8.0版本。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092314278-1444897836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：页面跳转后选择自己需要的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010092554828-723784454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step3：页面跳转后再选择Operating System，Architecture，Distribution，Version，Installer Type等各项指标，其中Installer Type选择runfile(local)选项，选好后点击Download，如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010093543265-202085146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：右击上图所示的绿色下载按钮，在弹出的菜单中点击“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令(如下)，使用该命令可直接在目标机上在线下载。详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.nvidia.com/compute/cuda/8.0/Prod2/local_installers/cuda_8.0.61_375.26_linux-run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;II. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：在目标机上跳转到.run文件所在目录，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;sh&lt;/span&gt; cuda_8.&lt;span&gt;0&lt;/span&gt;.61_375.26_linux.run   #注意这里要使用您下载的.run文件的文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来的安装过程中会问您一系列问题，愚以为最佳回答如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;  Do you accept the previously read EULA?&lt;br/&gt;  accept/decline/quit: accept&lt;/p&gt;
&lt;p&gt;  Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 375.26?&lt;br/&gt;  (y)es/(n)o/(q)uit: n   #&lt;span&gt;这里必须选n&lt;/span&gt;，不然会重新安装显卡驱动，这会覆盖掉原来的驱动&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;Install the CUDA &lt;span&gt;8.0&lt;/span&gt; Toolkit?&lt;span&gt;
(y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y                #选y

Enter Toolkit Location
 [ &lt;/span&gt;&lt;span&gt;default is&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt; ]:    #&lt;span&gt;强烈建议您直接回车&lt;/span&gt;，即接受默认配置，将CUDA安装在&lt;/span&gt;/usr/local/cuda-8.0目录下&lt;span&gt;，这将会为后面TensorFlow的安装提供方便 &lt;/span&gt;/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not writable. &lt;br/&gt;Do you wish to run the installation with &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;?&lt;span&gt; &lt;br/&gt;(y)es&lt;/span&gt;/&lt;span&gt;(n)o: y&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;Please enter your password: &lt;br/&gt;Do you want to install a symbolic link at &lt;/span&gt;/usr/local/cuda?&lt;span&gt; &lt;br/&gt;(y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y         #&lt;span&gt;强烈建议选y&lt;/span&gt;，即建立一个符号链接/usr/local/cuda指向&lt;/span&gt;/usr/local/cuda-8.0，&lt;span&gt;这将会为后面TensorFlow的安装提供方便，也会为后续使用提供方便&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;Install the CUDA &lt;/span&gt;&lt;span&gt;8.0&lt;/span&gt; Samples?&lt;span&gt; (y)es&lt;/span&gt;/(n)o/&lt;span&gt;(q)uit: y Enter CUDA Samples Location &lt;br/&gt;[ &lt;/span&gt;&lt;span&gt;default &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;/home/xxx&lt;/span&gt; ]:      #这是问CUDA的测试用例安装在哪里，您可以选择默认，也可以按自己意愿键入其它目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果顺利安装的话，接下来还会有一大推输出，简单摘取如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Installing the CUDA Toolkit &lt;span&gt;in&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt; ...
Installing the CUDA Samples &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /home/xxx&lt;span&gt; ...
Copying samples to &lt;/span&gt;/home/xxx/NVIDIA_CUDA-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_Samples now...
Finished copying samples.

&lt;/span&gt;===========
= Summary =
===========&lt;span&gt;

Driver:   Not Selected
Toolkit:  Installed &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
Samples:  Installed &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; /home/&lt;span&gt;jlu

Please make sure that        #&lt;span&gt;这个提示很重要，接下来必须照做
 &lt;/span&gt;&lt;/span&gt;-   PATH includes /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/&lt;span&gt;bin
 &lt;/span&gt;-   LD_LIBRARY_PATH includes /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/lib64, or, add /usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;/lib64 to /etc/ld.so.conf and run ldconfig &lt;span&gt;as&lt;/span&gt; root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：更改系统配置文件&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd ~&lt;span&gt;      #进入当前用户的主目录
vim &lt;/span&gt;~/.bashrc   #打开该用户的配置文件.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在打开的文件末尾添加如下指令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export CUDA_HOME=/usr/local/cuda-&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
export PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PATH:/usr/local/cuda-8.0/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export LD_LIBRARY_PATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64:/usr/local/cuda-8.0/extras/CUPTI/lib64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011011817657-2059073068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存并退出文件，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/.bashrc    #使配置文件立即生效  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您想要使CUDA和后面的cuDNN对所有用户都可用，请对/etc/profile这个配置文件进行和上面相同的操作。&lt;/p&gt;
&lt;p&gt;2.CUPTI(CUDA Profiling Tools Interface)是一个针对CUDA应用程序的性能分析和跟踪工具，要安装TensorFlow，就必须将其地址&lt;span&gt; &lt;span&gt;/usr/local/cuda-8.0/extras/CUPTI/lib64&lt;/span&gt;&lt;/span&gt; 添加到环境变量中（如上图黄色框中的最后一句）。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;III. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.646153846154&quot;&gt;
&lt;pre&gt;
cd /home/xxx/NVIDIA_CUDA-&lt;span&gt;8&lt;/span&gt;.0_Samples/1_Utilities/&lt;span&gt;deviceQuery   #跳转到测试样例1所在的目录，如果您在安装过程中（见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#CUDA&quot;&gt;上文最后一段&lt;/a&gt;）将测试样例安装在其它位置，这里也要做出相应更改
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;&lt;span&gt;   #编译
.&lt;/span&gt;/deviceQuery   #执行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;见到类似下面的输出，表明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019173115189-1807399587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;至此，CUDA8.0安装完成。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;本小节参考资料：&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://blog.csdn.net/weixin_41151963/article/details/79530722&quot; href=&quot;https://blog.csdn.net/weixin_41151963/article/details/79530722&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/weixin_41151963/article/details/79530722&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;a title=&quot;https://www.cnblogs.com/chay/p/8038251.html&quot; href=&quot;https://www.cnblogs.com/chay/p/8038251.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chay/p/8038251.html&lt;/a&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;四、安装cuDNN6.0&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;strong&gt;I. 下载安装文件&lt;/strong&gt;&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;访问网址&lt;a title=&quot;https://developer.nvidia.com/cudnn&quot; href=&quot;https://developer.nvidia.com/cudnn&quot; target=&quot;_blank&quot;&gt;https://developer.nvidia.com/cudnn&lt;/a&gt; ，点击Download cuDNN。&lt;/p&gt;
&lt;p data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010204705256-482407822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面跳转后登录或注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010210807940-637657746.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010211033037-1906068037.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010205002822-1423033061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登陆后，按图示操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010211622242-530722595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                          ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                          ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010212444045-1798517881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010214118810-198379711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018221045376-2100399916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                                                                           ▼&lt;/p&gt;
&lt;p&gt;                                                                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181010215649754-48426630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：在上面倒数第二幅图绿色字“cuDNN v6.0 Library for Linux”上右击，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令（如下），使用该命令可直接在目标机上在线下载安装包，详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;developer.nvidia.com/compute/machine-learning/cudnn/secure/v6/prod/8.0_20170307/cudnn-8.0-linux-x64-v6.0-tgz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;II. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意到下载得到的文件有一个奇怪的后缀名(solitairetheme8,纸牌主题8，该文件在Windows下的图标就是纸牌)，所以首先要将文件重命名为.tgz文件。&lt;/p&gt;
&lt;p&gt;在.solitairetheme文件所在目录下依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; cudnn-&lt;span&gt;8.0&lt;/span&gt;-linux-x64-v6.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.solitairetheme8   cudnn.tgz   #将文件重命名为cudnn.tgz
&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -&lt;span&gt;zxvf cudnn.tgz   #解压
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; cuda/include/cudnn.h /usr/local/cuda/include/   #解压后会在当前目录下得到cuda/include目录，里面只有cudnn.h这一个文件，将其拷贝到CUDA安装目录下的include目录中，&lt;br/&gt;#如前所述，/usr/local/cuda是指向/usr/local/cuda-8.0(即CUDA安装目录)的符号链接
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; cuda/lib64/libcudnn* /usr/local/cuda/lib64/   #解压后会在当前目录下得到cuda/&lt;span&gt;include目录，里面有几个以libcudnn开头的文件，将这些文件全部拷贝到CUDA安装目录下的lib64目录下
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; a+r /usr/local/cuda/include/&lt;span&gt;cudnn.h   #使所有用户都具有read权限，这是以防万一，实际上在下发现解压后的文件本身就对所有用户具有read权限
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; a+r /usr/local/cuda/lib64/libcudnn*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;附：解压后的文件列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018221755597-2038061300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，cuDNN6.0安装完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、安装Bazel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装Bazel是为了编译TensorFlow做准备。如文章最开始的图片显示的那样，我们需要安装Bazel 0.5.4版本。&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;I. 查看/卸载已有版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;

&lt;p&gt;若显示&lt;span&gt;bazel: command not found&lt;/span&gt; ，则说明目前系统上没有安装Bazel，直接转到&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#B_xz&quot;&gt;步骤II&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;若有如下输出，说明已安装Bazel0.5.4，直接进入“&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#title6&quot;&gt;六、相关准备工作&lt;/a&gt;”小节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011122550698-1573788519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若有不同于上述两种情况的输出（如显示安装的版本是0.17.2，并且有几个Warning），请按下述方法操作。&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;whereis&lt;/span&gt; bazel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011220359896-888901798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您将会看到类似上图中的输出，请使用rm -r命令将您看到的所有bazel目录及其子目录删除。然后再执行 &lt;span&gt;bazel &lt;/span&gt;命令，若看到&lt;span&gt;bazel: command not found&lt;/span&gt;，说明Bazel已卸载干净。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 下载安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问网址&lt;a title=&quot;https://github.com/bazelbuild/bazel/releases?after=0.7.0&quot; href=&quot;https://github.com/bazelbuild/bazel/releases?after=0.7.0&quot; target=&quot;_blank&quot;&gt;https://github.com/bazelbuild/bazel/releases?after=0.7.0&lt;/a&gt; ，Ctrl+F搜索关键字&quot;0.5.4-installer-linux-x86_64.sh&quot;，如图，点击第一个下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011223659197-645658904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您在上述网址指向的网页中没有找到您想要的版本，请将页面拉至最底端，点击Previous或Next按钮（如下图）向前/后翻页，从0.17.2版本到0.1.0版本都能找到。&lt;/p&gt;
&lt;p&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181011224202385-1836196034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在上面倒数第二幅图的下载链接（即蓝色字bazel-0.5.4-installer-linux-x86_64.sh）上右键，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令(如下)，使用该命令可直接在目标机上在线下载安装包，详见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/bazelbuild/bazel/releases/download/0.5.4/bazel-0.5.4-installer-linux-x86_64.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;III. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：在bazel-0.5.4-installer-linux-x86_64.sh所在目录下依次执行如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; &lt;span&gt;pkg-config zip g++ zlib1g-dev unzip&lt;/span&gt;&lt;span&gt; python   #安装依赖&lt;/span&gt;
&lt;span&gt;chmod&lt;/span&gt; +x bazel-&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-installer-linux-x86_64&lt;span&gt;.sh&lt;/span&gt;&lt;span&gt;   #增加执行权限
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; ./bazel-&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-installer-linux-x86_64.&lt;span&gt;sh&lt;/span&gt; --user   #安装      #The --user flag installs Bazel to the $HOME/bin(当前用户主目录/bin) directory on your system and sets the .bazelrc path to $HOME/.bazelrc.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim ~/.bashrc   #打开当前用户的配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在打开的文件末尾添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export PATH=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PATH:$HOME/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
source &lt;/span&gt;/root/.bazel/bin/bazel-complete.bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019181537955-1805116599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存并退出文件，执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source ~/.bashrc   #使配置文件立即生效
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：如果您想要使Bazel对所有用户都可用，请对/etc/profile这个配置文件进行和上面相同的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IV. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
bazel version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有类似如下的输出，说明Bazel安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018200146587-1300346131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Bazel安装完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、相关准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong/&gt;&lt;strong&gt;I. gcc降级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu安装时自带gcc，执行如下命令查看此gcc版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gcc&lt;/span&gt; --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181015222855564-277072422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译TensorFlow1.4.0需要gcc 4.x版本（如本文最开始的图片显示的那样，根据TensorFlow官网，需要4.8版本，但在下实测4.9版本也可以），如果您的系统的gcc版本是5.x或更高，需要降级到4.x版本（其实就是安装低版本的gcc并设置默认版本的过程）。由于在下没有实际做这一步工作，故不敢妄言，这里给出一些可能对您有用的链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.itread01.com/articles/1498658233.html&quot; href=&quot;https://www.itread01.com/articles/1498658233.html&quot; target=&quot;_blank&quot;&gt;https://www.itread01.com/articles/1498658233.html&lt;/a&gt; （推荐）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/f82a185f27d1&quot; href=&quot;https://www.jianshu.com/p/f82a185f27d1&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/f82a185f27d1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.cnblogs.com/in4ight/p/6626708.html&quot; href=&quot;https://www.cnblogs.com/in4ight/p/6626708.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/in4ight/p/6626708.html &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u014696921/article/details/73770887&quot; href=&quot;https://blog.csdn.net/u014696921/article/details/73770887&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u014696921/article/details/73770887&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/ytusdc/article/details/77980915&quot; href=&quot;https://blog.csdn.net/ytusdc/article/details/77980915&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/ytusdc/article/details/77980915&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 切换默认Python版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管TensorFlow官网表示TensorFlow1.4.0同时兼容python2和python3，但也有人表示，如果系统的默认python版本是python2，在编译TensorFlow时会出错（究竟会不会出错，在下并没有实践）。&lt;/p&gt;
&lt;p&gt;使用如下命令查询python默认版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
python --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181019182411602-1381731669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您的系统的默认Python版本是2.7，您可以在编译TensorFlow前将默认版本切换到3.3~3.6(见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#bbpz&quot;&gt;软件版本配置&lt;/a&gt;)，或者等到发现使用Python2.7编译TensorFlow出错时再切换。由于在下的系统的默认Python版本是Python3.5，所以并没有执行切换默认Python版本的操作（很可能是之前其他人做了切换版本的工作），这里只给出一些可能对您有用的链接：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/CYM_LMY/article/details/78315139&quot; href=&quot;https://blog.csdn.net/CYM_LMY/article/details/78315139&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/CYM_LMY/article/details/78315139&lt;/a&gt;   （切换Python默认版本，下同）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.jianshu.com/p/9d3033d1b26f&quot; href=&quot;https://www.jianshu.com/p/9d3033d1b26f&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/9d3033d1b26f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/fang_chuan/article/details/60958329&quot; href=&quot;https://blog.csdn.net/fang_chuan/article/details/60958329&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/fang_chuan/article/details/60958329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/White_Idiot/article/details/78240298&quot; href=&quot;https://blog.csdn.net/White_Idiot/article/details/78240298&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/White_Idiot/article/details/78240298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/u010426270/article/details/51059260&quot; href=&quot;https://blog.csdn.net/u010426270/article/details/51059260&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u010426270/article/details/51059260&lt;/a&gt;   （在线安装Python3.5并设置为默认）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.python.org/downloads/source/&quot; href=&quot;https://www.python.org/downloads/source/&quot; target=&quot;_blank&quot;&gt;https://www.python.org/downloads/source/&lt;/a&gt;   （Python各版本安装包下载地址）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://blog.51cto.com/4330156/1828604&quot; href=&quot;http://blog.51cto.com/4330156/1828604&quot; target=&quot;_blank&quot;&gt;http://blog.51cto.com/4330156/1828604&lt;/a&gt;   （编译安装Python）&lt;/p&gt;
&lt;p&gt;注：如果您是手动编译安装Python3（参考上面倒数第一个链接），在make前一定在安装包解压目录下使用如下命令将Python安装在/usr目录下（目的是为后边编译安装TensorFlow提供方便）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./configure --prefix=/usr
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装后，使用如下命令更新软连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rm&lt;/span&gt; /user/bin/&lt;span&gt;python
&lt;/span&gt;&lt;span&gt;ln&lt;/span&gt; -s /usr/bin/python3.&lt;span&gt;5&lt;/span&gt; /usr/bin/python
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，编译安装TensorFlow前的准备工作完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七、编译安装TensorFlow&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. 下载源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问网址 &lt;a title=&quot;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&quot; href=&quot;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&quot; target=&quot;_blank&quot;&gt;https://github.com/tensorflow/tensorflow/releases?after=v1.7.0-rc1&lt;/a&gt; ，页面跳转后Ctrl+F搜索关键字“TensorFlow 1.4.0”，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017091536088-729912982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，可以点击第二个链接（划红线的）下载，也可以在链接上右击，在弹出的菜单中选择“复制链接地址”，在复制得到的地址前加上“wget”构成一条命令（如下），使用该命令可以直接在目标机上在线下载（参考&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#zhu2&quot;&gt;第二节注2&lt;/a&gt;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/tensorflow/tensorflow/archive/v1.4.0.tar.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载后，将得到一个名为&lt;span&gt;v1.4.0.tar.gz&lt;/span&gt;的压缩文件，使用如下命令解压，解压后，将在解压目录下得到&lt;span&gt;tensorflow-1.4.0&lt;/span&gt;目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar&lt;/span&gt; -zxvf v&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.如果您在上述网址指向的页面中没有找到您想要的版本，请将页面拉至最底端，点击&lt;span&gt;Previous&lt;/span&gt;或&lt;span&gt;Next&lt;/span&gt;按钮（如下图）向前/后翻页，翻页后在新页面查找。&lt;/p&gt;
&lt;p&gt;                                                                             &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017100455559-1780028650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.TensorFlow官网教程（&lt;a title=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; href=&quot;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/install/install_sources#ConfigureInstallation&lt;/a&gt;）以及其它许多教程都使用git clone命令下载TensorFlow源码，这自然是可行的，但缺点是下载速度比wget方法至少慢一倍，所以这里不推荐。本人亲测，使用上述wget方法下载，解压后得到的源码和官网教程上使用git clone方法下载得到的源码完全一致。&lt;/p&gt;
&lt;p&gt;3.如果您使用wget方法下载源码，解压后将得到&lt;span&gt;tensorflow-1.4.0&lt;/span&gt;目录；如果使用git clone方法下载源码，将直接得到&lt;span&gt;tensorflow&lt;/span&gt;目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. 编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：安装TensorFlow Python依赖项&lt;/p&gt;
&lt;p&gt;根据您的Python版本执行下列命令之一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; python-numpy python-dev python-pip python-wheel      #&lt;span&gt;for&lt;/span&gt; Python2.&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; python3-numpy python3-dev python3-pip python3-wheel      #&lt;span&gt;for&lt;/span&gt; Python3.x
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2：其它准备&lt;/p&gt;
&lt;p&gt;在源码所在目录下执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd tensorflow           #如果您是用git clone方法下载的源码，使用该命令
#或
cd tensorflow&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;     #如果您是用wget方法下载，解压得到的源码，使用该命令
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; librdmacm-dev      #可选，在下实践发现，不加该命令，在编译源码时会报错，所以这里事先安装librdmacm-&lt;span&gt;dev安装包(简言之，librdmacm是一个通信接口，负责连接的建立和撤销)
bazel shutdown      #如果之前运行bazel而未关闭，在运行配置文件时会有警告“WARNING: Running Bazel server needs to be killed, because the startup options are different.”   
.&lt;/span&gt;/configure     #运行配置脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step3：配置选项&lt;/p&gt;
&lt;p&gt;运行配置脚本后，会有一系列问题让您回答，下面逐条解释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.418436703483&quot;&gt;
&lt;pre&gt;
root@ubuntu-xxx:/usr/local/tensorflow# ./&lt;span&gt;configure
You have bazel &lt;/span&gt;&lt;span&gt;0.5&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&lt;span&gt; installed.
Please specify the location of python. [Default &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; /usr/bin/&lt;span&gt;python]:    &lt;span&gt;&lt;span&gt;#如果您是按照上面&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#qhbb&quot;&gt;&lt;span&gt;第六节II&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;进行操作的话，/usr/bin/python是一个指向系统默认版本的Python的软连接（见图3-7-1），所以这里&lt;span&gt;直接回车&lt;/span&gt;；&lt;/span&gt;&lt;/span&gt;
                                                                        #如果您的情况例外，请使用whereis python和ll命令查看python的安装位置（见图3-7-1）                                                                        

&lt;/span&gt;Found possible Python library paths:
  /usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages
  /usr/lib/python3/dist-packages
Please input the desired Python library path to use.  Default &lt;span&gt;is&lt;/span&gt; [/usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages]   &lt;span&gt;#上面两个目录都是Python库的位置，分别包含不同的库，在下&lt;span&gt;选的是第一个&lt;/span&gt;，理由参考&lt;/span&gt;&lt;a title=&quot;该网页&quot; href=&quot;https://stackoverflow.com/questions/122327/how-do-i-find-the-location-of-my-python-site-packages-directory&quot; target=&quot;_blank&quot;&gt;该网页&lt;/a&gt;上&lt;span&gt;David Hollander的回答（即第五个回答）&lt;/span&gt;
/usr/local/lib/python3.&lt;span&gt;5&lt;/span&gt;/dist-packages
Do you wish to build TensorFlow with jemalloc &lt;span&gt;as&lt;/span&gt; malloc support? [Y/n]: Y   &lt;span&gt;#jemalloc是个内存分配管理器，在下并不了解，见官网教程上选了Y，也就&lt;span&gt;选了Y&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;jemalloc as malloc support will be enabled for TensorFlow.&lt;/span&gt;

Do you wish to build TensorFlow with Google Cloud Platform support? [Y/n]: Y   &lt;span&gt;&lt;span&gt;#在下选Y只是为了测试选Y后影不影响后边的编译（实测选Y可以正常编译），如果您不需要该功能，&lt;/span&gt;建议选N&lt;/span&gt;
&lt;span&gt;Google Cloud Platform support will be enabled for TensorFlow.

Do you wish to build TensorFlow with Hadoop File System support? [Y/n]: Y   #同上
Hadoop File System support will be enabled for TensorFlow.

Do you wish to build TensorFlow with Amazon S3 File System support? [Y/n]: Y   #同上
Amazon S3 File System support will be enabled for TensorFlow.

Do you wish to build TensorFlow with XLA JIT support? [y/N]: Y   #同上
XLA JIT support will be enabled for TensorFlow.

Do you wish to build TensorFlow with GDR support? [y/N]: Y   #同上
GDR support will be enabled for TensorFlow.

Do you wish to build TensorFlow with VERBS support? [y/N]: Y   #同上
VERBS support will be enabled for TensorFlow.

Do you wish to build TensorFlow with OpenCL support? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
No OpenCL support will be enabled for TensorFlow.

Do you wish to build TensorFlow with CUDA support? [y/N]: y   #这个&lt;span&gt;必须选y&lt;/span&gt;
CUDA support will be enabled for TensorFlow.
&lt;/span&gt;
&lt;span&gt;Please specify the CUDA SDK version you want to use, e.g. 7.0. [Leave empty to default to CUDA 8.0]:    #如果您的CUDA版本是8.0，请&lt;span&gt;直接回车&lt;/span&gt;，否则请输入您的CUDA版本


Please specify the location where CUDA 8.0 toolkit is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:    #如果您是按本教程安装的CUDA，/usr/local/cuda是指向CUDA安装目录的软连接（见&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#CUDA&quot;&gt;CUDA安装部分&lt;/a&gt;），所以这里&lt;span&gt;直接回车&lt;/span&gt;


Please specify the cuDNN version you want to use. [Leave empty to default to cuDNN 6.0]:    #如果您的cuDNN版本是6.0，请&lt;span&gt;直接回车&lt;/span&gt;，否则请输入您的cuDNN版本


Please specify the location where cuDNN 6 library is installed. Refer to README.md for more details. [Default is /usr/local/cuda]:   #如果您是按本教程安装的CUDA和cuDNN，请&lt;span&gt;直接回车
&lt;/span&gt;&lt;/span&gt;

Please specify a list of comma-separated Cuda compute capabilities you want to build with.
You can find the compute capability of your device at: &lt;a title=&quot;https://developer.nvidia.com/cuda-gpus&quot; href=&quot;https://developer.nvidia.com/cuda-gpus&quot; target=&quot;_blank&quot;&gt;https:&lt;span&gt;//&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;a title=&quot;https://developer.nvidia.com/cuda-gpus&quot; href=&quot;https://developer.nvidia.com/cuda-gpus&quot; target=&quot;_blank&quot;&gt;developer.nvidia.com/cuda-gpus&lt;/a&gt;.&lt;/span&gt;
Please note that each additional compute capability significantly increases your build time and binary size. [Default &lt;span&gt;is: 6.1&lt;/span&gt;]   #这个&lt;span&gt;一定要去上一行网址指向的网页去查&lt;/span&gt;您自己的GPU卡的计算能力，然后输入正确的数
                                                                                                                                 #在下之所以直接回车，是因为在下的GPU卡的计算能力恰好是6.1

Do you want to use clang &lt;span&gt;as&lt;/span&gt; CUDA compiler? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
nvcc will be used &lt;span&gt;as&lt;/span&gt; CUDA compiler.

&lt;span&gt;Please specify which gcc should be used by nvcc as the host compiler. [Default is /usr/bin/gcc]:   #正常情况下，/usr/bin/gcc是一个指向gcc编译器的符号链接（见下图7-3-2），所以&lt;span&gt;直接回车&lt;/span&gt;
                                                                                                   #如果您的情况例外，请使用&lt;span&gt;whereis gcc&lt;/span&gt;和&lt;span&gt;ll&lt;/span&gt;命令查找您的gcc编译器的位置（见下图7-3-2）

Do you wish to build TensorFlow with MPI support? [y/N]: N   #这个&lt;span&gt;必须选N&lt;/span&gt;，否则会出错
No MPI support will be enabled for TensorFlow.&lt;/span&gt;

Please specify optimization flags to use during compilation when bazel option &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--config=opt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; specified [Default &lt;span&gt;is&lt;/span&gt; -march=native]:    #根据官网教程，&lt;span&gt;直接回车&lt;/span&gt;


Add &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--config=mkl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to your bazel command to build with MKL support.
Please note that MKL on MacOS or windows &lt;span&gt;is &lt;/span&gt;still not supported.
If you would like to use a local MKL instead of downloading, please &lt;span&gt;set&lt;/span&gt; the environment variable &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TF_MKL_ROOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; every time before build.
Configuration finished
root@ubuntu-xxx:/usr/local/tensorflow# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017234739729-1719884841.png&quot; alt=&quot;&quot;/&gt;                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181017234928626-131335216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                  图7-3-1                                                                                                                                                                                              图7-3-2&lt;/p&gt;
&lt;p&gt;step4：正式编译&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bazel build --config=opt --config=cuda --copt=-mavx --copt=-msse4.&lt;span&gt;2&lt;/span&gt; --copt=-msse4.&lt;span&gt;1&lt;/span&gt; --copt=-msse3 --copt=-mavx2 --copt=-mfma &lt;span&gt;//&lt;/span&gt;&lt;span&gt;tensorflow/tools/pip_package:build_pip_package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就进入漫长的编译过程，大概耗时15~30分钟，编译过程会占用大量的RAM，所以在编译时尽量不要运行其它程序。同时，编译过程中会输出大量语句，也会有许多Warning，但不要管，只有编译不停止，就没有问题。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;1.上述编译命令比官网给的命令多出了许多参数，因为有资料显示使用这些选项编译安装的TensorFlow在运行TensorFlow程序时会加快CPU计算速度，实测表明加上这些参数并不会引起错误。更多详情请参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&quot; href=&quot;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&quot; target=&quot;_blank&quot;&gt;https://blog.xuite.net/abliou/linux/486757306-%E4%BD%BF%E7%94%A8tensorflow%E7%9A%84sse3+sse4.1+sse4.2%E6%8C%87%E4%BB%A4%E9%9B%86&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/xxy0118/article/details/77731641&quot; href=&quot;https://blog.csdn.net/xxy0118/article/details/77731641&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/xxy0118/article/details/77731641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://zhuanlan.zhihu.com/p/27286391&quot; href=&quot;https://zhuanlan.zhihu.com/p/27286391&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/27286391&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://pastebin.com/aQrxT4qZ&quot; href=&quot;https://pastebin.com/aQrxT4qZ&quot; target=&quot;_blank&quot;&gt;https://pastebin.com/aQrxT4qZ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.编译完成后会生成一个build_pip_package.sh文件，由当前目录下的符号链接&lt;span&gt;bazel-bin/tensorflow/tools/pip_package/build_pip_package&lt;/span&gt;指向，其中&lt;span&gt;bazel-bin&lt;/span&gt;也是一个符号链接，如图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018201453648-1125580995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;III. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1：构建安装包&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg   #使用上一步生成的脚本构建安装文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令的执行不会花很多时间，该命令执行后会在&lt;span&gt;/tmp/tensorflow_pkg&lt;/span&gt;目录下生成一个.whl文件，请使用  &lt;span&gt;ls /tmp/tensorflow_pkg&lt;/span&gt;  命令查看文件的名称，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018111222420-1127872513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2：正式安装&lt;/p&gt;
&lt;p&gt;在和上一步相同的目录下执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; pip &lt;span&gt;install&lt;/span&gt; /tmp/tensorflow_pkg/tensorflow-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cp35-cp35m-linux_x86_64.whl   #这里的文件名要和上图中查到的文件名相同
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装过程也会持续一段时间，有时看着好像是卡住了，不要担心，过一会进度条就会往前走，请您耐心等待。&lt;/p&gt;
&lt;p&gt;IV&lt;strong&gt;. 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意目录下依次执行下列命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里会输出python的版本信息，见下图&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; hello = tf.constant(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, TensorFlow!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sess =&lt;span&gt; tf.Session()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里会输出GPU的相关信息，表明TensorFlow是在GPU上运行的，见下图&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; sess.run(hello)
b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, TensorFlow!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; a = tf.constant(10&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; b = tf.constant(22&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; sess.run(a+&lt;span&gt;b)
&lt;/span&gt;32
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有类似下图的输出，表明TensorFlow安装成功。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/642223/201810/642223-20181018194841050-529109670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，TensorFlow安装完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;写在后面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个环境搭建过程参考了许多资料，在上文中已一一附上链接，再次对各位前辈表示感谢！在下才疏学浅，能力有限，文中难免有错误疏漏之处，恳请您批评指正，您的批评是在下进步的源泉和动力！未尽事宜：2661048959@qq.com。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/zpcdbky/p/9757821.html#ml&quot;&gt;回到目录&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 11:23:00 +0000</pubDate>
<dc:creator>同勉共进</dc:creator>
<og:description>本文是一篇保姆级教程，步骤非常详细，叙述了在Ubuntu16.04 Server下安装CUDA8.0，cuDNN6.0，Bazel0.5.4，以及源码编译安装TensorFlow1.4.0(GPU版)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zpcdbky/p/9757821.html</dc:identifier>
</item>
<item>
<title>.Net并行编程（一）-TPL之数据并行 - 范存威</title>
<link>http://www.cnblogs.com/fancunwei/p/9818244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9818244.html</guid>
<description>&lt;p&gt;许多个人计算机和工作站都有多个CPU核心，可以同时执行多个线程。利用硬件的特性，使用并行化代码以在多个处理器之间分配工作。&lt;br/&gt;&lt;img title=&quot;.NetFramework并行编程架构图&quot; src=&quot;https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/media/tpl-architecture.png&quot; alt=&quot;.NetFramework并行编程架构图&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;文件批量上传&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;并行上传单个文件。也可以把一个文件拆成几段分开上传，加快上传速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据分批计算&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如几百万数据可以拆成许多无关联的部分，并行计算处理。最后聚合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;数据推送&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也是需要将数据拆解后，并行推送。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果在一个循环内在每次迭代只执行少量工作或者它没有运行多次迭代，那么并行化的开销可能会导致代码运行的更慢。使用并行之前，应该对线程（锁，死锁，竞争条件）应该有基本的了解。&lt;/p&gt;
&lt;h2 id=&quot;4&quot;&gt;Parallel.For&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从下图对比接口可以看出当循环体内方法执行时间很短时，并行时间反而更长。这块会有更细致的补充。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;FormalDirRun-----&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;0,Dir:E:\LearnWall\orleans
ParallelForDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;6,Dir:E:\LearnWall\orleans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们追加一些延时操作如Thread.Sleep,但这应该不是好好例子...但我只想演示效果就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;Thread.Sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看结果得到，当方法内有阻塞延时一秒后，两者速度错了七倍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;FormalDirRun-----&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;20011,Dir:E:\LearnWall\orleans
ParallelForDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,time:&lt;span class=&quot;hljs-number&quot;&gt;3007,Dir:E:\LearnWall\orleans&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-write-a-simple-parallel-for-loop#matrix-and-stopwatch-example&quot;&gt;矩阵和秒表示例&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5&quot;&gt;Parallel.ForEach&lt;/h2&gt;
&lt;p&gt;为了并行速度的最大化，我们应该尽量减少在并行内对共享资源的访问，如Console.Write,文件日志等...但这里为了显示效果，就用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;ParallelForEachDirRun(&lt;span class=&quot;hljs-params&quot;&gt;)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;long totalSize = &lt;span class=&quot;hljs-number&quot;&gt;0;
            &lt;span class=&quot;hljs-keyword&quot;&gt;var dir = &lt;span class=&quot;hljs-string&quot;&gt;@&quot;E:\LearnWall\orleans&quot;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;name:.gitignore
name:build.sh
.
.
.
name:TestAll.cmd
ParallelForEachDirRun&lt;span class=&quot;hljs-number&quot;&gt;-20 files, &lt;span class=&quot;hljs-number&quot;&gt;255618 bytes,Time:&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6&quot;&gt;Parallel.For 线程局部变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;ParallelForForThreadLocalVariables(&lt;span class=&quot;hljs-params&quot;&gt;)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;int[] nums = Enumerable.Range(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;1000000).ToArray();
            &lt;span class=&quot;hljs-keyword&quot;&gt;long total = &lt;span class=&quot;hljs-number&quot;&gt;0;

            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The total is 499,999,509,000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个For方法的前两个参数指定开始和结束迭代值。在此方法的重载中，第三个参数是初始化本地状态的位置。在此上下文中，本地状态表示一个变量，其生命周期从当前线程上的循环的第一次迭代之前延伸到最后一次迭代之后。&lt;/p&gt;
&lt;p&gt;第三个参数的类型是Func ，其中TResult是将存储线程本地状态的变量的类型。它的类型由调用泛型For （Int32，Int32，Func ，Func ，Action ）方法时提供的泛型类型参数定义，在这种情况下是Int64。type参数告诉编译器将用于存储线程局部状态的临时变量的类型。在此示例中，表达式() =&amp;gt; 0（或Function() 0在Visual Basic中）将线程局部变量初始化为零。如果泛型类型参数是引用类型或用户定义的值类型，则表达式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;() =&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new MyClass()  &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这块内容比较繁琐，一句话来说：前两个参数是开始和结束值，第三个是根据For泛型而初始化的值。我其实也没看太懂这块。.net Framework源码如下,.netcore的不知道：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static ParallelLoopResult For&amp;lt;TLocal&amp;gt;(
            &lt;span class=&quot;hljs-keyword&quot;&gt;int fromInclusive, &lt;span class=&quot;hljs-keyword&quot;&gt;int toExclusive,
            Func&amp;lt;TLocal&amp;gt; localInit,
            Func&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int, ParallelLoopState, TLocal, TLocal&amp;gt; body,
            Action&amp;lt;TLocal&amp;gt; localFinally)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (body == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;body&quot;);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (localInit == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;localInit&quot;);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (localFinally == &lt;span class=&quot;hljs-literal&quot;&gt;null)
            {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new ArgumentNullException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;localFinally&quot;);
            }
 
            &lt;span class=&quot;hljs-keyword&quot;&gt;return ForWorker(
                fromInclusive, toExclusive, s_defaultParallelOptions,
                &lt;span class=&quot;hljs-literal&quot;&gt;null, &lt;span class=&quot;hljs-literal&quot;&gt;null, body, localInit, localFinally);
        }
        
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7&quot;&gt;Parallel.ForEach线程局部变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ForEach的源码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8&quot;&gt;取消 Parallel.ForEach或Parallel.For&lt;/h2&gt;
&lt;p&gt;通过CancellationTokenSource来获取token&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CancellationTokenSource cts = new CancellationTokenSource();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过ParallelOptions.CancellationToken属性来控制取消状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ParallelOptions po = new ParallelOptions();&lt;/p&gt;
&lt;p&gt;po.CancellationToken = cts.Token;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过Parallel.For或Foreach的ParallelOptions值来控制并行内方法的取消。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int[] nums = Enumerable.Range(&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;10000000).ToArray();
            CancellationTokenSource cts = &lt;span class=&quot;hljs-keyword&quot;&gt;new CancellationTokenSource();

            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，键盘输入c时，并行取消。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1937.41838537782 on &lt;span class=&quot;hljs-number&quot;&gt;7
&lt;span class=&quot;hljs-number&quot;&gt;2739.95711645274 on &lt;span class=&quot;hljs-number&quot;&gt;8
&lt;span class=&quot;hljs-number&quot;&gt;2501.40660429287 on &lt;span class=&quot;hljs-number&quot;&gt;9
&lt;span class=&quot;hljs-number&quot;&gt;2958.47798707376 on &lt;span class=&quot;hljs-number&quot;&gt;10
.
.
.
press any key to exit111
The operation was canceled.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;9&quot;&gt;捕获并行体内的异常&lt;/h2&gt;
&lt;p&gt;示例方法采用ConcurrentQueue来接收异常集合，最后抛出一个聚合异常AggregateException。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;var exceptions = new ConcurrentQueue();&lt;/p&gt;
&lt;p&gt;exceptions.Enqueue(e);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;外部调用&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/AggregateException.cs,96eb05ad168f3513,references&quot;&gt;AggregateException.Flatten&lt;/a&gt;方法获取异常信息。&lt;/p&gt;
&lt;p&gt;这为我以后捕获异常提供了一个好思路。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;10&quot;&gt;对微小执行体提速&lt;/h2&gt;
&lt;p&gt;当Parallel.For循环有一个很快的执行体，它可能比同等顺序循环执行更慢。较慢的性能是由分区数据所涉及的开销和每次循环迭代调用委托的成本引起的。为了解决这种情况，Partitioner类提供了Partitioner.Create方法，该方法使您能够为委托主体提供顺序循环，以便每个分区仅调用一次委托，而不是每次迭代调用一次。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;var rangePartitioner = Partitioner.Create(0, source.Length);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;csharp hljs&quot;&gt;        &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fancunwei/CsharpFanDemo&quot;&gt;CsharpFanDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本篇文章沿着微软官方文档步骤熟悉了第一部分数据并行的用法。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Parallel.For和Parallel.ForEach实现并行。&lt;/p&gt;
&lt;p&gt;Parallel.For和Parallel.ForEach线程局部变量。&lt;/p&gt;
&lt;p&gt;取消并行ParallelOptions.CancellationToken&lt;/p&gt;
&lt;p&gt;捕捉异常ConcurrentQueue累加并行体内的异常，外部接收。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont655687.i1.644b374fqT9gMX&quot;&gt;加速Partitioner.Create&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont655687.i2.644b374fqT9gMX&quot;&gt;感谢观看！&lt;/p&gt;
</description>
<pubDate>Fri, 19 Oct 2018 11:10:00 +0000</pubDate>
<dc:creator>范存威</dc:creator>
<og:description>前言 许多个人计算机和工作站都有多个CPU核心，可以同时执行多个线程。利用硬件的特性，使用并行化代码以在多个处理器之间分配工作。 应用场景 文件批量上传 并行上传单个文件。也可以把一个文件拆成几段分开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9818244.html</dc:identifier>
</item>
</channel>
</rss>