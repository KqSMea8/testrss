<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>太原，这是我曾经和现在居住的城市，记录一个前端仔的三年。 - 闰土少年</title>
<link>http://www.cnblogs.com/running-runtu/p/7976802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/7976802.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171204140646466-1832329275.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这篇文章写给准备踏入互联网的萌新，写给从培训出来之后回到二三线城市的童鞋，也写给在太原切图三年的自己，致敬这三年，致敬太原。&lt;/p&gt;

&lt;p&gt;接下来，正文从这开始~&lt;/p&gt;

&lt;p&gt;2011年，太原火车站前交通拥堵无秩序，此时我误打误撞进了编程培训班，一学就是两年。&lt;/p&gt;
&lt;p&gt;2013年，培训班毕业出来，从太原火车站，踏上了去杭州求职的绿皮火车。&lt;/p&gt;
&lt;p&gt;2014年，我离开了工作一年的杭州。&lt;/p&gt;
&lt;p&gt;2015年，我已回来太原coding一年，火车站已建好地下通道及道路规划。&lt;/p&gt;
&lt;p&gt;你以为我在写高新区码农的太原生活指南，其实，你猜的是对的。太原高新区、南中环周边，是太原程序猿聚集最集中的地段，素有太原西二旗美称。&lt;/p&gt;
&lt;p&gt;假如你此刻正在太原，你知道在外地码农心中，太原这个City是什么样子么？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;迎泽大街上有怒吼的1路大黄河&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解放路上摇摇晃晃的是610的双巴&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有那拖着大辫子环绕府城的4路电车&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;太原的各种面很好吃。馒头很好吃。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;山西的醋真的是好吃，太原的同学吃面条要加醋。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以为柳巷是种满柳树的巷子 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;觉得圪僚沟是很诗意的名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“是了～?”是表示很亲切的反问带一点赞同。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在太原，程序猿圈子里大约分两派：一种是技术控派，一种是文艺范儿派。&lt;/p&gt;
&lt;p&gt;让我们先来说说这文艺范儿派的码农，这一派的码农哥哥们，他们只相信玄学类的东西。&lt;/p&gt;
&lt;p&gt;如果在太原，你没有去过青年路、看过银杏树，你怎么好意思说自己是一枚具有文艺细胞的太原Coder呢？&lt;/p&gt;
&lt;p&gt;早晨七点二十骑车经过，从火车站到五一广场，再到柳南左拐，然后就一头骑进诗一样的岁月里，在银杏树旁依偎了三年，也留下了最好的年华。&lt;/p&gt;
&lt;p&gt;秋天的落叶很美，如果你是来自南方的姑娘，你会第一次感受到课本上写的__秋天树叶落了，干枯的树叶落满一地，走在上面簌簌地响。树叶真的可以落光。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171204142656341-1900756845.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可能很多人说太原不是那么发达，可是却给了人一种别样的古朴，像是一位平和的有故事的老人。&lt;/p&gt;
&lt;p&gt;2011年 北美新天地建成开业 成为了太原的地标性建筑 年轻人从此逛街不再只是去柳巷 北美成为首选 也是因为北美的建成 让我这种时尚白痴开始了解一些潮牌 比如Zara 比如bershka。&lt;/p&gt;
&lt;p&gt;2011年 蒙山大佛景点免费开放 景色秀美 风景怡人 并且到了现在依然免费 是近郊旅游的好去处 一度成为了很多大学宿舍一起旅游的首选。&lt;/p&gt;
&lt;p&gt;2013年 初夏 太原全城修路 扩路和修高架桥 整个太原交通几乎瘫痪 一年过后再到太原 焕然一新的城市。&lt;/p&gt;

&lt;p&gt;说完文艺范儿派，再来聊聊技术控派的码农们，他们只关注硬件设施，数字指标等硬通货。&lt;/p&gt;
&lt;p&gt;如果你问我，闰土啊，你在太原这座城市生活了这么久，究竟在太原做前端开发是种怎么样的体验？&lt;/p&gt;
&lt;p&gt;这是一个沉重的话题，每每聊到这时，我便陷入了深思。说实话，从杭州回到老家太原，如果我跟你说心理上没有落差，那是骗人的。太原大部分能和互联网沾点边的公司， 整体的技术栈还是相对来说比较陈旧的，当然这个是由项目性质决定的，面向互联网的项目比较少，优秀的产品基本没有，技术氛围不算浓厚，公司内部的技术交流会是少之又少。&lt;/p&gt;
&lt;p&gt;比如和我同在太原的童鞋小Z，最近就跟我诉苦，说他们公司以前的项目都是jsp,jq写的。他面试的时候和经理聊过,这家公司从去年就开始用vue1.x.x系列开发项目了。但是小Z进组以后发现他们对前端自动化没有什么了解，只是知道 npm run build 能打包项目，但是不知道为什么。知其然不知其所以然，说的就是这个。基本上只是用vue代替了以前jq的dom操作，并没有优化工作流程。还有最近在对接口的时候接触到了前任封装的ajax方法，是用jq的ajax搭配promise。原本几十行代码,他换成axios以后只有不到十行，在项目中经常能见到这种新旧混杂的地方。&lt;/p&gt;
&lt;p&gt;对于小Z的吐槽，我已经司空见惯了。最后他跟我说了句，用vue的页面仔还是页面仔，哈哈~&lt;/p&gt;
&lt;p&gt;吐槽完了劣势，我们再来说说优势。相比于一线城市，在太原撸代码的优势，则是体现在了生活层面。比如说不用租房，不用天天吃外卖，同事都是山西人,很容易交流。在一个生活了十几年的城市，无时无刻都能感觉到放松和亲切。&lt;/p&gt;
&lt;p&gt;还有一个优势，相对于一线城市来说，工作没有太大的压力，有什么比较困难的需求都会让找个成品或者用个第三方，没有那种让造轮子的领导。我在杭州的时候为了压缩首屏加载时间，连UI框架都没用，全是手写，不过那段日子也是我成长最快的时候。&lt;/p&gt;
&lt;p&gt;总之，离家近，便利又心安。&lt;/p&gt;
&lt;p&gt;对于常年混迹于太原前端圈的我，发现最近两年太原招聘市场的一个发展趋势是，前端开发已经和Java、PHP一样，成为公司招聘的标配。总体来说，后端的薪资依旧比前端的要高一些。不过还是有一小部分公司认为前端就是会切页面的程序员，当然，未来几年关于对前端的这种片面印象有没有改观，我就不得而知了，拭目以待吧！&lt;/p&gt;
&lt;p&gt;因此，在太原coding，记住一句话：no choice is the best choice。&lt;/p&gt;
&lt;p&gt;通常聊这些话题的时候，技术控派的码农们眼睛里才会散发出别样的光芒，感觉打通任督二脉，他们只喜欢在代码里寻找高潮，追求刺激。当你在太原的互联网公司里，看到有个程序猿哥哥，代码敲着敲着，突然浑身一颤抖，十指从键盘抽离，间接性地吐出一口一口的长气流时，恭喜你，这个码农哥哥，刚调通了一个bug。&lt;/p&gt;

&lt;p&gt;如果你在太原，恰巧你也是码农，你归哪一派？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/701424/201712/701424-20171204143433966-643537895.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;太原并不大，也不繁华，但她是我生活的城市，我很热爱她。&lt;/p&gt;
&lt;p&gt;一草一木，山川河岳，那是我的家乡。&lt;/p&gt;
&lt;p&gt;这是一段太原土著码农的故事，以后你们也可以叫我闰土后生，好哇。&lt;/p&gt;
&lt;p&gt;这次就先聊到这儿了，后会有期。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Dec 2017 07:34:00 +0000</pubDate>
<dc:creator>闰土少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/7976802.html</dc:identifier>
</item>
<item>
<title>免费人脸识别APi - 北冥大帝</title>
<link>http://www.cnblogs.com/minsons/p/7977195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minsons/p/7977195.html</guid>
<description>&lt;p&gt;今天对应一些免费的人脸识别的api 做了一下简单的对比，觉得百度开发出来的人脸识别接口还是最符合的我的要求，简单易用，容易上手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150506060-1854048020.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;据说百度的一些门禁也使用上了人脸识别的功能了，功能很强大，而且能识别出是实时人物还是图片。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;对于一些初创公司来说，只要有机器学习的员工搭建一套人脸检测系统也不难，主要是这个训练和调优上花些时间，但是要用在互联网上供能多人使用，那对服务器的性能要求十分高，要用到GPU服务，在网上稍微看了一下，租一个月普遍最低价都是2.5k/月以上，而且是GPU里的低配，相比之下，直接购买接口来的便宜多了，百度是按QPS计费，默认免费的2个QPS；首先，我们来看一下有哪些免费的人脸识别API吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个：百度api&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;我比较喜欢的也是我首先还是百度人脸识别API，功能强大，简单易用；&lt;br/&gt;http://ai.baidu.com/tech/face 至少有很多人工智能的大师是在百度工作过，也是国内最早进军人工的企业之一，虽然后来大师都从百度出走，但是人家积累的根基还是很厚的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;第二个：face++&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Face++.com 号称是一个提供免费人脸检测、人脸识别、人脸属性分析等服务的云端服务平台，但感觉免费是骗人的；听说在一场黑马大赛中，赢得冠军。所以在人脸识别技术上还是很牛逼的一家公司。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150527544-1505179389.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;有点恶心的是所谓的免费其实就是注册和试用。&lt;br/&gt;价格上应该还是可以接受的；&lt;br/&gt;国内类似牛逼的公司还有 云从科技的人脸识别也是很牛逼的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三： EyeKey&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;感觉这个网站做的很简单，同时也提供一些硬件供开发使用，不知道价格如何，网上有介绍如何使用他们的api&lt;br/&gt;https://jingyan.baidu.com/article/bea41d439e11dab4c51be612.html&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四：虹软技术&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;号称提供免费的sdk，到底是怎么收费不清楚，当时对于这种不是很知名，试用就要提供一大堆个人信息还是不要用为妙。&lt;br/&gt;http://www.arcsoft.com.cn/ai/arcface.html?utm_source=baiduad&amp;amp;utm_medium=cpc&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;还有很多其他的有限免费的api接口提供，可以自己慢慢去百度，如果想购买现有的接口，可以考虑知乎查到的内容：&lt;br/&gt;国际人脸识别评估集LFW榜， face++ 99.5% , 商汤 99.53% ， 腾讯 99.65% , 百度 99.77%，中科奥森 99.77% , 中科云从 99.5%， 颜鉴99.64%，北京飞搜科技 99.4% ,宇泛智能 99%&lt;br/&gt;这些都是基于国内的，也可以看看国外提供的api；人脸识别基本都可以高达99以上的识别率，也不用过分苛求了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接下来以百度的人脸识别api为例做一下讲解：&lt;/p&gt;
&lt;p&gt;1，申请百度AI开放平台账户：http://ai.baidu.com/&lt;br/&gt;不多讲，就直接注册&lt;br/&gt;2，进入人脸识别页面，创建应用（在导航中【产品服务】-【人脸识别】）&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150548638-1224194062.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击按钮【立即使用】：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150603294-749548847.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【创建应用】按照要求填写资料之后就为你生成app id ，key 和secret等信息&lt;/p&gt;
&lt;p&gt;3）查看文档进行开发&lt;br/&gt;在https://ai.baidu.com/sdk 可以查看供下载的sdk，还有使用说明&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150619310-141812915.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【使用说明】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204150628576-2029105167.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在这里会指导你怎么使用SDK，很简单：&lt;br/&gt;我用的是python：可以手动下载zip包也可以在线安装python的可以在线安装&lt;br/&gt;下载sdk库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install baidu-aip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;人脸识别一定要先注册后识别；&lt;/p&gt;
&lt;p&gt;我提供一个测试代码的压缩可供直接下载，这里就不再重复了 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/minsons/baiduApi.7z&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;下载&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt; https://files.cnblogs.com/files/minsons/baiduApi.7z&lt;/p&gt;
&lt;p&gt;以胡歌和杨洋作为训练分类&lt;/p&gt;
&lt;p&gt;总体效果特别好：&lt;/p&gt;
&lt;p&gt;测试集：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204151400107-1230504582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检测结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201712/1171146-20171204151521701-432728658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;other04.jpg的图片只有17左右的得分，很准确；（hege其实是huge（胡歌）的分类 写错拼音了）&lt;/p&gt;


&lt;p&gt;百度人脸识别Python版本的接口 ：http://ai.baidu.com/docs#/Face-Python-SDK/top&lt;br/&gt;EyeKey 应用：http://www.eyekey.com/devcenter/index.html&lt;/p&gt;
</description>
<pubDate>Mon, 04 Dec 2017 07:18:00 +0000</pubDate>
<dc:creator>北冥大帝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minsons/p/7977195.html</dc:identifier>
</item>
<item>
<title>基于iframe的移动端嵌套 - calmound</title>
<link>http://www.cnblogs.com/zsboy/p/7977070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zsboy/p/7977070.html</guid>
<description>&lt;h2 id=&quot;需求描述&quot;&gt;需求描述&lt;/h2&gt;
&lt;p&gt;上上周接到了新的项目，移动端需要做一个底部有五个导航，点击不同的导航页面主体显示不同的页面，其中两个页面是自己做，而另外三个页面是引用另外三个网址，其中两个网址为内部项目，另外一个为外部（涉及跨域）。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;考虑再三后最省时间成本的就是使用iframe，虽然在移动端使用，我的内心是很拒绝的，不过其他方案调研了下都不太符合现状。每点击一次加载一个新的iframe，比较懒，所以两个新页面也做成了iframe，在做的过程中出现了如下问题，这里总结一下：&lt;br/&gt;1.嵌入的iframe页面无法滚动&lt;br/&gt;2.meta元素的ontent不一致，外部的页面使用width=device-width,而引用的其中一个页面的width=640，这导致那个页面渲染的时候无法全屏缩小&lt;br/&gt;3.ios下其中的一个页面莫名其妙的扩大&lt;br/&gt;4.iframe的页面a标签的锚点失效&lt;br/&gt;5.当我点击a加载了a的iframe页面，在切换到b，这个时候b页面字体莫名的变大&lt;br/&gt;6.导航栏有个样式要求，active的时候icon是为红色的icon，其他状态下则为灰色的。其中的一个需求为返回的时候从哪里点出去返回到哪里&lt;br/&gt;7.某个安卓机后返回无法重新加载iframe&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;h4 id=&quot;声明嵌入的iframe页面其中4个都是内部项目同源的所以大部分处理的问题不存在跨域问题&quot;&gt;声明嵌入的iframe页面其中4个都是内部项目，同源的，所以大部分处理的问题不存在跨域问题。&lt;/h4&gt;
&lt;h3 id=&quot;嵌入的iframe页面无法滚动&quot;&gt;1.嵌入的iframe页面无法滚动&lt;/h3&gt;
&lt;p&gt;在iframe外层包裹一个div,然后将其设置为可滚动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div style=&quot;webkit-overflow-scrolling: touch;overflow-y: scroll;&quot;&amp;gt;
    &amp;lt;iframe&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且在禁止浏览器的默认行为，不然类似于微信滑动到底部的时候会和回弹的效果进行冲突&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$('body').on('touchmove',function(e){
    e.preventDefault();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;meta元素的ontent不一致&quot;&gt;2.meta元素的ontent不一致&lt;/h3&gt;
&lt;p&gt;这个暂时没有好办法，iframe渲染的meta也是默认走的最上层的meta，所以他自己的内部meta是失效的，由于该项目属于自己部门，有权限可以修改代码，所以最后我重新设置该页面的meta，重写了这个页面的样式。&lt;/p&gt;
&lt;h3 id=&quot;ios下其中的一个页面莫名其妙的扩大&quot;&gt;3.ios下其中的一个页面莫名其妙的扩大&lt;/h3&gt;
&lt;p&gt;经排查我发现对于标题这类的设置了white-space:nowrap, 以及iframe页面用了swiper设置的宽度为100%,而移动端为了自适应body也设置的为100%这种情况下，ios下iframe而里面的页面会扩大。&lt;br/&gt;我的解决办法是在原项目下页面html,body依旧设置为100%，而初始化的时候js获取屏幕的宽度再设置body的宽度。&lt;/p&gt;
&lt;h3 id=&quot;iframe的页面a标签的锚点失效&quot;&gt;4.iframe的页面a标签的锚点失效&lt;/h3&gt;
&lt;p&gt;若iframe不涉及跨域，网上有兼容代码可以重新设置a标签，跨域解决不了，因为跨域的情况下，外部页面是无法获取到iframe下的元素的，最后这个导航做了外部跳转。&lt;/p&gt;
&lt;h3 id=&quot;iframe页面切换的时候切换后的页面样式莫名变大&quot;&gt;5.iframe页面切换的时候，切换后的页面样式莫名变大&lt;/h3&gt;
&lt;p&gt;之前我做页面切换，是用过不重新加载iframe,而是直接修改了iframe的url，但是好像在这种情况下，可能之前上一个页面加载的css没有完全清除掉，所以导致css混乱。所以最后每次切换的时候，豆浆iframe给remove掉，在append加载新的iframe。&lt;/p&gt;
&lt;h3 id=&quot;页面点击跳转之后返回的状态标记&quot;&gt;6.页面点击跳转之后，返回的状态标记&lt;/h3&gt;
&lt;p&gt;使用了localStorage记录了url，navIndex&lt;/p&gt;
&lt;h3 id=&quot;某个安卓机后返回无法重新加载iframe&quot;&gt;7.某个安卓机后返回无法重新加载iframe&lt;/h3&gt;
&lt;p&gt;返回后再append的iframe的代码下再让其重新渲染下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#iframe&quot;).attr(&quot;src&quot;,url).ready()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;8.其他&lt;/h2&gt;
&lt;h4 id=&quot;获取iframe内部元素&quot;&gt;获取iframe内部元素&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;document.getElementById('iframe').onload = function(){
let doc = document.getElementById('iframe').contentDocument;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;中间涉及到了跨域请求但是由于后台接口之前就写了无法修改接口但是传过来的时候中文乱码&quot;&gt;中间涉及到了跨域请求，但是由于后台接口之前就写了，无法修改接口，但是传过来的时候中文乱码&lt;/h4&gt;
&lt;p&gt;接口默认的解析为gbk，所以需要设置scriptCharset: 'gbk',&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$.ajax({
    type: &quot;GET&quot;,
    url: url,
    dataType: &quot;jsonp&quot;,
    jsonp: &quot;callback&quot;,
    jsonpCallback: &quot;data_callback&quot;,
    contentType: &quot;application/x-javascript,charset-type=gbk&quot;,
    scriptCharset: 'gbk',
    crossDomain: true,
    success: function (json) {});
});&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 04 Dec 2017 07:16:00 +0000</pubDate>
<dc:creator>calmound</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zsboy/p/7977070.html</dc:identifier>
</item>
<item>
<title>Python——Scrapy初学 - 闪电gogogo</title>
<link>http://www.cnblogs.com/wwf828/p/7716410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwf828/p/7716410.html</guid>
<description>&lt;p&gt;&lt;span&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。Scrapy最初是为了页面抓取（更确切来说, 网络抓取）所设计的，也可以应用在获取API所返回的数据（例如Amazon Associates Web Services）或者通用的网络爬虫。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1 安装&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;简要说明下Scrapy的安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载网址：http://www.lfd.uci.edu/~gohlke/pythonlibs/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载后缀名为whl的scrapy文件，在cmd中进入Scripts所在的位置，输入pip install scrapy文件名.whl（可参考《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wwf828/p/7282210.html&quot;&gt;Python初学基础&lt;/a&gt;》中的7.1 模块安装），注意scrapy依赖twiste，同样使用whl格式的包进行安装。安装完这两个模块后我在进行爬虫操作的时候提示没有win32api，该文件为exe，下载地址为https://sourceforge.net/projects/pywin32/files/pywin32/Build%20220/。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在安装好模块后要注意环境变量的配置，以我自己的安装目录为例，应当将D:\Program Files (x86)\Python\Scripts以及D:\Program Files (x86)\Python\Lib\site-packages加入环境变量中，否则模块只能在安装目录下运行，在别的目录下运行时会提示不是内部或者外部命令。在cmd下输入scrapy查看是否安装成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述简单介绍了scrapy的安装，在安装的过程中不要着急，如果安装出错，要注意查看错误信息，根据这些信息一个一个去解决。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2 Scrapy架构及组件介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用Scrapy抓取一个网站一共需要四个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 创建一个Scrapy项目；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 定义Item容器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 编写爬虫；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 存储内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习怎么使用Scrapy之前，我们需要先来了解一下Scrapy的架构以及组件之间的交互。下图展现的是Scrapy的架构，包括组件及在系统中发生的数据流（图中绿色箭头）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023135459441-975605625.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面对每个组件都做了简单介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Scrapy Engine&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Scrapy引擎是爬虫工作的核心，负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度器（Scheduler）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调度器从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下载器（Downloader）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载器负责获取页面数据并提供给引擎，而后提供给spider。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spiders&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spider是Scrapy用户编写用于分析由下载器返回的response，并提取出item和额外跟进的URL的类。 Item Pipeline Item Pipeline负责处理被spider提取出来的item。典型的处理有清理、验证及持久化（例如存取到数据库中）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来是两个中间件，它们用于提供一个简便的机制，通过插入自定义代码来扩展Scrapy的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;下载器中间件（Downloader middlewares）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载器中间件是在引擎及下载器之间的特定钩子（specific hook），处理Downloader传递给引擎的response。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Spider中间件（Spider middlewares）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spider中间件是在引擎及Spider之间的特定钩子（specific hook），处理spider的输入（就是接收来自下载器的response）和输出（就是发送items给item pipeline以及发送requests给调度器）。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3 Scrapy爬虫框架入门实例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;例程参考《&lt;a href=&quot;http://blog.csdn.net/zjiang1994/article/details/52779537&quot; target=&quot;_blank&quot;&gt;scrapy爬虫框架入门实例&lt;/a&gt;》，该例子是抓取慕课网（http://blog.csdn.net/zjiang1994/article/details/52779537）。慕课网的页面结构已经变了，所以说该案例实际上已经不能达到抓取目的。但是关于scrapy爬虫框架整体的使用方式和流程目前还是正确的，可以进行参考。根据慕课网现有的页面结构做了一些改动可以成功实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要抓取的内容是全部的课程名称，课程图片，课程人数，课程简介，课程URL：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023151342519-1357279634.png&quot; alt=&quot;&quot; width=&quot;928&quot; height=&quot;473&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右键审查元素查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023151248848-2100455312.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果response是网页资源的话，下面的代码可以帮助我们获得div&lt;/span&gt;
divs = response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;course-card-container&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以如果div已经获得的话通过如下获得信息（详解介绍见下文）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#获取每个div中的课程路径&lt;/span&gt;&lt;br/&gt;&lt;span&gt;item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.imooc.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程标题&lt;/span&gt;
item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//h3[@class=&quot;course-card-name&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0].strip()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的标题图片地址&lt;/span&gt;
item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的学生人数&lt;/span&gt;
item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract()[1&lt;span&gt;].strip()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程简介&lt;/span&gt;
item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//p/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract()[0].strip()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;工作流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Scrapy框架抓取的基本流程是这样：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20161010171426872&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然了，还有一些中间件等等，这里是入门例子，所以不涉及。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1）创建一个Scrapy项目&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在开始爬取之前，您必须创建一个新的Scrapy项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入您打算存储代码的目录中，运行下列命令: scrapy startproject tutorial&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该命令将会创建包含下列内容的tutorial目录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tutorial/&lt;span&gt;
    scrapy.cfg
    tutorial&lt;/span&gt;/
        &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
        items.py
        pipelines.py
        settings.py
        spiders&lt;/span&gt;/
            &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
            ...
&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这些文件构成Scrapy爬虫框架，它们分别的作用是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scrapy.cfg – 项目的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tutorial/ – 该项目的python模块，之后您将在此加入代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tutorial/items.py – 项目中的item文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tutorial/pipelines.py – 项目中的pipelines文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tutorial/settings.py – 项目的设置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tutorial/spiders/ – 放置spider代码的目录&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2）定义Item容器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Item是保存爬取到的数据的容器，其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先根据需要获取到的数据对item进行建模。比如我们需要从慕课网中获取课程名称，课程图片，课程人数，课程简介，课程URL。对此，我们需要在item中定义相应的字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在工程目录下可以看到一个items文件，我们可以更改这个文件或者创建一个新的文件来定义我们的item。将item.py中的内容修改如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入文件&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CourseItem(scrapy.Item):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;课程标题&lt;/span&gt;
    title =&lt;span&gt; scrapy.Field()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;课程url&lt;/span&gt;
    url =&lt;span&gt; scrapy.Field()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;课程标题图片&lt;/span&gt;
    image_url =&lt;span&gt; scrapy.Field()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;课程描述&lt;/span&gt;
    introduction =&lt;span&gt; scrapy.Field()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;学习人数&lt;/span&gt;
    student =&lt;span&gt; scrapy.Field()
    image_path &lt;/span&gt;= scrapy.Field()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;根据如上的代码，我们创建了一个名为item的容器，用来保存、抓取的信息， title-&amp;gt;课程标题, url-&amp;gt;课程url, image_url-&amp;gt;课程标题图片, introduction-&amp;gt;课程描述, student-&amp;gt;学习人数。在创建完item文件后我们可以通过类似于词典(dictionary-like)的API以及用于声明可用字段的简单语法。常用方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个item&lt;/span&gt;
course =&lt;span&gt; CourseItem()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;赋值&lt;/span&gt;
course[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;语文&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取值&lt;/span&gt;
course[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
course.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取全部键&lt;/span&gt;
&lt;span&gt;course.keys()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取全部值&lt;/span&gt;
course.items()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3) 创建一个爬虫&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们要编写爬虫，首先是创建一个Spider我们在&lt;code&gt;tutorial/spiders/&lt;/code&gt;目录下创建一个文件&lt;code&gt;MySpider.py&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件包含一个MySpider类，它必须继承scrapy.Spider类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时它必须定义一下三个属性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建完成后MySpider.py的代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入文件&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySpider(scrapy.Spider):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用于区别Spider&lt;/span&gt;
    name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MySpider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;允许访问的域&lt;/span&gt;
    allowed_domains =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取的地址&lt;/span&gt;
    start_urls =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;爬取方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了简单清晰，我们先抓取一个页面中的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们编写爬取代码。我们在上文说过，爬取的部分在MySpider类的parse()方法中进行。 parse()方法负责处理response并返回处理的数据以及(/或)跟进的URL。该方法及其他的Request回调函数必须返回一个包含 Request 及(或) Item 的可迭代的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在网页中提取我们所需要的数据，之前所学习的是根据正则表达式来获取，在Scrapy中是使用一种基于Xpath和CSS的表达式机制：Scrapy Selectors。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Selector是一个选择器，它有四个基本的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;xpath() – 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;css() – 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;extract() – 序列化该节点为unicode字符串并返回list。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;re() – 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Shell中尝试Selector选择器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了介绍Selector的使用方法，接下来我们将要使用内置的Scrapy shell。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你需要先进入项目的根目录，执行下列命令来启动Scrapy shell：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scrapy shell “http://www.imooc.com/course/list”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shell的输出类似：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023160139598-455481266.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Shell载入后，你将获得response回应，存储在本地变量response中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以如果你输入response.body，你将会看到response的body部分，也就是抓取到的页面内容，或者输入response.headers 来查看它的 header部分。现在就像是一大堆沙子握在手里，里面有我们想要的金子，所以下一步我们就要用筛子把沙子去掉，淘出金子。selector选择器就是这样一个筛子，正如我们刚才讲到的，你可以使用response.selector.xpath()、response.selector.css()、response.selector.extract()和response.selector.re()这四个基本方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用XPath&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是XPath？XPath是一门在网页中查找特定信息的语言。所以用XPath来筛选数据，要比使用正则表达式容易些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里给出XPath表达式的例子及对应的含义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/html/head/title – 选择HTML文档中&amp;lt;head&amp;gt;标签内的&amp;lt;title&amp;gt;元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/html/head/title/text() – 选择上面提到的&amp;lt;title&amp;gt;元素的文字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//td – 选择所有的&amp;lt;td&amp;gt;元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//div[@class=”mine”] – 选择所有具有class=”mine”属性的div元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上边仅仅是几个简单的XPath例子，XPath实际上要比这远远强大的多。如果你想了解更多关于XPath的内容，推荐学习这篇文章http://www.w3school.com.cn/xpath/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得一提的是，response.xpath()、response.css()已经被映射到response.selector.xpath()、response.selector.css()，所以直接使用response.xpath()即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Python编写时，由于没有学习过Xpath，所以我先在cmd中编写试验得到正确的返回结果后再写入代码中，注意shell根据response的类型自动为我们初始化了变量&lt;strong&gt;sel&lt;/strong&gt;，我们可以直接使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如获取每个div中的课程路径：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023161330004-2032279830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，我们希望Spiders将爬取并筛选后的数据存放到item容器中，所以我们MySpider.py的代码应该是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入容器&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; tutorial.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CourseItem


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySpider(scrapy.Spider):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置name&lt;/span&gt;
    name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MySpider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设定域名&lt;/span&gt;
    allowed_domains = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imooc.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;填写爬取地址&lt;/span&gt;
    start_urls = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.imooc.com/course/list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编写爬取方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例一个容器保存爬取的信息&lt;/span&gt;
        item =&lt;span&gt; CourseItem()  
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这部分是爬取部分，使用xpath的方式选择信息，具体方法根据网页结构而定&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先获取每个课程的div&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; box &lt;span&gt;in&lt;/span&gt; response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;course-card-container&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取每个div中的课程路径&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.imooc.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程标题&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//h3[@class=&quot;course-card-name&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的标题图片地址&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的学生人数&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract()[1&lt;span&gt;].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程简介&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//p/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回信息&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在parse()方法中response参数返回一个下载好的网页信息，我们然后通过xpath来寻找我们需要的信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在scrapy框架中，可以使用多种选择器来寻找信息，这里使用的是xpath，同时我们也可以使用BeautifulSoup，lxml等扩展来选择，而且框架本身还提供了一套自己的机制来帮助用户获取信息，就是Selectors。 &lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在执行完以上步骤之后，我们可以运行一下爬虫，看看是否出错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在命令行下进入工程文件夹，然后运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrapy crawl MySpider&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果操作正确会显示如下信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023162657426-1875975457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面信息表示，我们已经获取了信息，接下来我们开始进行信息的储存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最简单存储爬取的数据的方式是使用Feed exports，主要可以导出四种格式：JSON，JSON lines，CSV和XML。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这里将结果导出为最常用的JSON格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scrapy crawl dmoz -o items.json -t json&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-o 后边是导出的文件名，-t 指定导出类型 成功执行命令后，根目录出现了一个叫 items.json 的文件，内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023162903832-1354066267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;使用pipeline处理数据&quot;&gt;&lt;span&gt;&lt;strong&gt;或者使用Pipeline处理数据：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们成功获取信息后，要进行信息的验证、储存等工作，这里以储存为例。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当Item在Spider中被收集之后，它将会被传递到Pipeline，一些组件会按照一定的顺序执行对Item的处理。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Pipeline经常进行以下一些操作：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;清理HTML数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;验证爬取的数据(检查item包含某些字段)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;查重(并丢弃)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;将爬取结果保存到数据库中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里只进行简单的将数据储存在json文件的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改写在&lt;code&gt;tutorial/&lt;/code&gt;目录下文件pipelines.py的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Define your item pipelines here&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; Don't forget to add your pipeline to the ITEM_PIPELINES setting&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入文件&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; scrapy.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DropItem
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyPipeline(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开文件&lt;/span&gt;
        self.file = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;该方法用于处理数据&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取item中的数据&lt;/span&gt;
        line = json.dumps(dict(item), ensure_ascii=False) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入文件&lt;/span&gt;
&lt;span&gt;        self.file.write(line)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回item&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;该方法在spider被开启时被调用。&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;该方法在spider被关闭时被调用。&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;要使用Pipeline，首先要注册Pipeline&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到settings.py文件,这个文件时爬虫的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在其中添加：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ITEM_PIPELINES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tutorial.pipelines.MyPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的代码用于注册Pipeline，其中'tutorial.pipelines.MyPipeline为你要注册的类，右侧的’1’为该Pipeline的优先级，范围1～1000，越小越先执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进行完以上操作，我们的一个最基本的爬取操作就完成了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时我们再运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;scrapy crawl MySpider&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就可以在项目根目录下发现data.json文件，里面存储着爬取的课程信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212449/201710/1212449-20171023163453035-455270002.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的代码只进行了比较简单的爬取，并没有完成爬取慕课网全部课程的目标。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面进行一些简单的扩展完成我们的目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;url跟进&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面我们介绍了如何进行简单的单页面爬取，但是我们可以发现慕课网的课程是分布在去多个页面的，所以为了完整的爬取信息课程信息，我们需要进行url跟进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了完成这个目标需要对&lt;code&gt;MySpider.py&lt;/code&gt;文件进行如下更改&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入容器&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; tutorial.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CourseItem


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySpider(scrapy.Spider):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置name&lt;/span&gt;
    name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MySpider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设定域名&lt;/span&gt;
    allowed_domains = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imooc.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;填写爬取地址&lt;/span&gt;
    start_urls = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.imooc.com/course/list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;编写爬取方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例一个容器保存爬取的信息&lt;/span&gt;
        item =&lt;span&gt; CourseItem()  
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这部分是爬取部分，使用xpath的方式选择信息，具体方法根据网页结构而定&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先获取每个课程的div&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; box &lt;span&gt;in&lt;/span&gt; response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;course-card-container&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取每个div中的课程路径&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.imooc.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程标题&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//h3[@class=&quot;course-card-name&quot;]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的标题图片地址&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image_url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的学生人数&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract()[1&lt;span&gt;].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取div中的课程简介&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = box.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//p/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract()[0].strip()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回信息&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; item

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;url跟进开始&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取下一页的url信息&lt;/span&gt;
        url = response.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//a[contains(text(),'下一页')]/@href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).extract()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; url :
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将信息组合成下一页的url&lt;/span&gt;
            page = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.imooc.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; url[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回url&lt;/span&gt;
            &lt;span&gt;yield&lt;/span&gt; scrapy.Request(page, callback=&lt;span&gt;self.parse)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;url跟进结束&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改成功后就可以自动进行url跟进了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Dec 2017 06:57:00 +0000</pubDate>
<dc:creator>闪电gogogo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwf828/p/7716410.html</dc:identifier>
</item>
<item>
<title>Unity3D手机斗地主游戏开发实战（04）_出牌判断大小（已完结） - Lancel0t</title>
<link>http://www.cnblogs.com/lizzie-xhu/p/7977040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizzie-xhu/p/7977040.html</guid>
<description>&lt;p&gt;之前我们实现了叫地主、玩家和电脑自动出牌主要功能，但是还有个问题，出牌的时候，没有有效性检查和比较牌力大小。比如说，出牌3,4,5，目前是可以出牌的，然后下家可以出任何牌如3,6,9。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;问题1：出牌检查有效性，就是出牌类型判断，像单张、对子、顺子、炸弹等等类型；&lt;/li&gt;
&lt;li&gt;问题2：上家出牌后，下家再出牌的时候，要判断当前牌力是否大于上家的牌力；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那本篇我们主要解决以上2个问题。&lt;/p&gt;
&lt;h3&gt;卡牌信息类重构&lt;/h3&gt;
&lt;p&gt;首先，原先的卡牌类，已经实现了单张卡牌牌力的比较，但是有些复杂，我们先对这个比较逻辑进行优化。思路是卡牌的cardIndex就表示在此类型卡牌中的大小权重，所有，在初始化卡牌的过程中，对cardIndex进行特殊的处理：&lt;/p&gt;
&lt;p&gt;cardIndex=（卡牌的原始索引+10）%13&lt;/p&gt;
&lt;p&gt;比如：普通牌3--cardIndex=（3+10）%13=0，转换后排最小&lt;/p&gt;
&lt;p&gt;普通牌J--cardIndex=（11+10）%13=8,转换后排第8张，如此，我们就可以轻松比较cardIndex，来判断单牌的实际大小了。&lt;/p&gt;
&lt;p&gt;再看看优化后的代码，是不是比以前简洁很多？更主要的是，为了方便后面的复杂组合牌力的判断。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c70ea66f-5f8a-41d3-aa0b-fe5a4d05aced')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_c70ea66f-5f8a-41d3-aa0b-fe5a4d05aced&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c70ea66f-5f8a-41d3-aa0b-fe5a4d05aced&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c70ea66f-5f8a-41d3-aa0b-fe5a4d05aced',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c70ea66f-5f8a-41d3-aa0b-fe5a4d05aced&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CardInfo : IComparable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; cardName; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;卡牌图片名&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CardTypes cardType; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌的类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cardIndex;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌在所在类型的索引3-10,J,Q,K,A,2(0-12)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isSelected;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否选中&lt;/span&gt;


    &lt;span&gt;public&lt;/span&gt; CardInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; cardName)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cardName =&lt;span&gt; cardName;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; splits = cardName.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (splits[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Hearts;
                cardIndex &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;]) + &lt;span&gt;10&lt;/span&gt;) % &lt;span&gt;13&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Spades;
                cardIndex &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;]) + &lt;span&gt;10&lt;/span&gt;) % &lt;span&gt;13&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Diamonds;
                cardIndex &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;]) + &lt;span&gt;10&lt;/span&gt;) % &lt;span&gt;13&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Clubs;
                cardIndex &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;]) + &lt;span&gt;10&lt;/span&gt;) % &lt;span&gt;13&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;joker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Joker;
                cardIndex &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;]) + &lt;span&gt;10&lt;/span&gt;) % &lt;span&gt;13&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;卡牌文件名{0}非法！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cardName));
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卡牌大小比较&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareTo(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
    {
        CardInfo other &lt;/span&gt;= obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CardInfo;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (other == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;比较对象类型非法！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前是大小王&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (cardType ==&lt;span&gt; CardTypes.Joker)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方也是大小王&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (other.cardType ==&lt;span&gt; CardTypes.Joker)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cardIndex.CompareTo(other.cardIndex);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方不是大小王&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是一般的牌&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方是大小王&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (other.cardType ==&lt;span&gt; CardTypes.Joker)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果对方也是一般的牌&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算牌力&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cardIndex ==&lt;span&gt; other.cardIndex)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;cardType.CompareTo(other.cardType);
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cardIndex.CompareTo(other.cardIndex);
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;出牌类型基类&lt;/h3&gt;
&lt;p&gt;接下来，那怎么判断出牌有效性和出牌的牌力大小判断呢？&lt;/p&gt;
&lt;p&gt;我们这样想，每次出牌都是一组牌堆，那我们首先要判断这一组牌堆的类型，比如3带1，单张、炸弹等等；&lt;/p&gt;
&lt;p&gt;其次，确定牌堆类型后，我们需要判断这个牌堆是否是合法的，其实就遍历验证是否符合上述的牌堆类型，如果满足，就认为合法，如果所有类型都不满足，则出牌无效，不允许出牌；&lt;/p&gt;
&lt;p&gt;再者，怎么判断下家出牌的牌力要大于上家呢，这里我们还得有一个方法，判断相同类型的2个牌堆，牌堆1是否比牌堆2牌力大；&lt;/p&gt;
&lt;p&gt;最后，为了实现电脑出牌的AI，还得有自动查找1个跟上家出牌类型一样的牌堆，而且比上家的牌堆大，如果有这种牌，则可以压住上家，否则自动过牌；&lt;/p&gt;
&lt;p&gt;有了整体思路，我们这样设计，先定义一个虚基类--出牌类型基类，这里定义了所有需要子类牌堆类型实现的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('829eb792-03c7-4be0-b09c-5c968a7e6475')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_829eb792-03c7-4be0-b09c-5c968a7e6475&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_829eb792-03c7-4be0-b09c-5c968a7e6475&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('829eb792-03c7-4be0-b09c-5c968a7e6475',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_829eb792-03c7-4be0-b09c-5c968a7e6475&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出牌类型基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FollowCardsBase
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Validate(List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 找到最小满足的牌组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; List&amp;lt;CardInfo&amp;gt; FindBigger(List&amp;lt;CardInfo&amp;gt; handCardInfos, List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 判断是否牌大过要比较的牌组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;handCardInfos&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cardInfos&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsBigger(List&amp;lt;CardInfo&amp;gt; handCardInfos, List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Validate方法：子类实现验证出牌是否满足此类型；&lt;/p&gt;
&lt;p&gt;IsBigger方法：给定2个出牌的牌堆，判断此类型牌堆1是否满足牌力大于牌堆2；&lt;/p&gt;
&lt;p&gt;FindBigger方法：在给定的手牌中，找出符合类型中满足牌力大于给定牌堆的组合；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，我们定义好基类，再利用子类去实现各自的方法，比如对子牌类型的子类，我们判断如果是对子，出牌的时候Validate判断是否也是对子，如果出牌是对子，而且IsBigger&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，就允许出牌；当然AI出牌的时候，通过FindBigger，找到满足对子类型，且比给定的对子牌力大的牌组，进行后续出牌操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;定义各个类型牌型&lt;/h3&gt;
&lt;p&gt;因为斗地主涉及的牌型有很多，我们可以简单归纳一下。&lt;/p&gt;
&lt;p&gt;我这里把单张和顺子作为一种牌组类型来实现，因为考虑顺子其实就是一种单张的特殊情景，只是约束条件是大于等于连续5张的单张牌。所以对子和连对、3带1或3带1的飞机等等，就都可以归为一类，个人感觉实现会简单些。&lt;/p&gt;
&lt;p&gt;这里还是以单张和顺子举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e83fe61b-e402-47cb-a692-0553798c6f5f')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e83fe61b-e402-47cb-a692-0553798c6f5f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e83fe61b-e402-47cb-a692-0553798c6f5f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e83fe61b-e402-47cb-a692-0553798c6f5f',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e83fe61b-e402-47cb-a692-0553798c6f5f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Validate(List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos)
        {
            cardInfos.Sort();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cardInfos.Count == &lt;span&gt;1&lt;/span&gt;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单张&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cardInfos.Count &amp;gt;= &lt;span&gt;5&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺子&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果最大的牌是王或者2，则不是顺子&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cardInfos.Last().cardType == CardTypes.Joker || cardInfos.Last().cardIndex == &lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cardInfos.Count - &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cardInfos[i].cardIndex + &lt;span&gt;1&lt;/span&gt; != cardInfos[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;].cardIndex)
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;按照上一节所述，我们牌组类型子类，首先需要实现Validate方法，来验证是否属于单张或顺子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是一张牌，毫无疑问，是单张&lt;/li&gt;
&lt;li&gt;如果是大于等于5张牌，最大的牌不是王或者2，而且是连续的牌，则是顺子&lt;/li&gt;
&lt;li&gt;其他情况肯定不是单张或顺子&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('368224a1-1145-4f49-a3aa-088f9dd967f4')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_368224a1-1145-4f49-a3aa-088f9dd967f4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_368224a1-1145-4f49-a3aa-088f9dd967f4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('368224a1-1145-4f49-a3aa-088f9dd967f4',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_368224a1-1145-4f49-a3aa-088f9dd967f4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 判断是否牌大过要比较的牌组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;handCardInfos&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cardInfos&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsBigger(List&amp;lt;CardInfo&amp;gt; handCardInfos, List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos)
        {
            cardInfos.Sort();
            handCardInfos.Sort();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌数一样且最小牌比要比较的牌组的最小牌大&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (handCardInfos.Count == cardInfos.Count &amp;amp;&amp;amp; Validate(handCardInfos) &amp;amp;&amp;amp;&lt;span&gt; Validate(cardInfos))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handCardInfos[&lt;span&gt;0&lt;/span&gt;].CompareTo(cardInfos[&lt;span&gt;0&lt;/span&gt;]) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;接着，怎么判断2组牌组的牌力大小呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，将2牌组按照从小到大排序&lt;/li&gt;
&lt;li&gt;判断2牌组的牌数是否一样&lt;/li&gt;
&lt;li&gt;判断2牌组的类型是否都是单张或顺子&lt;/li&gt;
&lt;li&gt;如果满足以上2个条件，再判断2牌组的第一张大小&lt;/li&gt;
&lt;li&gt;如果牌组1的第一张大于牌组2的第一张，则可以认为牌组1牌力大于牌组2&lt;/li&gt;
&lt;li&gt;反之也成立&lt;/li&gt;
&lt;li&gt;否则，如果相等，则牌力一样&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1d47b0e9-192c-4b7c-adad-9ca8aa819ec8')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1d47b0e9-192c-4b7c-adad-9ca8aa819ec8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1d47b0e9-192c-4b7c-adad-9ca8aa819ec8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1d47b0e9-192c-4b7c-adad-9ca8aa819ec8',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1d47b0e9-192c-4b7c-adad-9ca8aa819ec8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 找到最小满足的牌组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; List&amp;lt;CardInfo&amp;gt; FindBigger(List&amp;lt;CardInfo&amp;gt; handCardInfos, List&amp;lt;CardInfo&amp;gt;&lt;span&gt; cardInfos)
        {
            cardInfos.Sort();
            handCardInfos.Sort();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cardInfos.Count == &lt;span&gt;1&lt;/span&gt;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单张&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cardInfo = handCardInfos.FirstOrDefault(s =&amp;gt; s.CompareTo(cardInfos[&lt;span&gt;0&lt;/span&gt;]) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; s.cardIndex != cardInfos[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].cardIndex);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cardInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt; List&amp;lt;CardInfo&amp;gt;&lt;span&gt;();
                    result.Add(cardInfo);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cardInfos.Count &amp;gt;= &lt;span&gt;5&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺子&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = handCardInfos.Count -&lt;span&gt; cardInfos.Count;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手牌比牌组多count，则有count + 1可能满足牌组&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count + &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mayBiggerCardInfos =&lt;span&gt; handCardInfos.Skip(i).Take(cardInfos.Count).ToList();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是顺子，且最小的牌比要比较的牌组最小牌要大&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (Validate(mayBiggerCardInfos) &amp;amp;&amp;amp; mayBiggerCardInfos[&lt;span&gt;0&lt;/span&gt;].CompareTo(cardInfos[&lt;span&gt;0&lt;/span&gt;]) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; mayBiggerCardInfos[&lt;span&gt;0&lt;/span&gt;].cardIndex != cardInfos[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].cardIndex)

                        {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mayBiggerCardInfos;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;再来看，我们怎么根据给定的单张或顺子，在手牌中找到对应牌力大于上家的牌组；&lt;/p&gt;
&lt;p&gt;这里提供了一个简单的实现方式，找到最小满足的牌组，当然，如果要实现智能的电脑出牌的AI，或者智能提示出牌，肯定要复杂很多，就不在探讨范围内了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，将2牌组按照从小到大排序&lt;/li&gt;
&lt;li&gt;如果上家牌是单张，那简单，从手牌中找到第1张满足牌力大于上家牌的单张即可；&lt;/li&gt;
&lt;li&gt;如果上家牌是顺子，判断手牌比上家牌的牌数只差，比如手牌17张，上家牌是5张的顺子，那就是17-5=12，理论上有12+1最多可能满足的牌组组合；&lt;/li&gt;
&lt;li&gt;那从第一张手牌开始，遍历12+1次，每次取当前手牌后的5张牌，判断是否比上家牌牌力大，如果不满足，则继续下轮遍历；&lt;/li&gt;
&lt;li&gt;如果找到，则返回该牌组，可以认为这牌组牌力大于上家牌，且类型为单张或顺子，牌数跟上家牌一样；&lt;/li&gt;
&lt;li&gt;如果遍历完还没找到，认为手牌中没有大于上家牌的牌组，游戏玩家可以跳过次回合；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，我们的单张和顺子类型的出牌检验逻辑，大体上就完成了。接下来，我们只需要稍微修改下之前的出牌逻辑~&lt;/p&gt;
&lt;h3&gt;出牌逻辑调整&lt;/h3&gt;
&lt;p&gt;这里需要调整2处，一方面，在玩家出牌时，要增加判断，如果玩家选择的牌堆，牌力不够，需要提示玩家，很简单，不在复述；&lt;/p&gt;
&lt;p&gt;再来看电脑出牌的逻辑，我们在PlayOthre类中，增加以下这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d0a39308-3297-48d1-9365-c200d43f57ab')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d0a39308-3297-48d1-9365-c200d43f57ab&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d0a39308-3297-48d1-9365-c200d43f57ab&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d0a39308-3297-48d1-9365-c200d43f57ab',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d0a39308-3297-48d1-9365-c200d43f57ab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (CardManager._instance.cardManagerState ==&lt;span&gt; CardManagerStates.Playing)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Input.GetKeyDown(KeyCode.Q)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出牌&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; singleCards = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingleCards();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cardInfos = singleCards.FindBigger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cardInfos, CardManager._instance.currentCardInfos);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cardInfos != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        cardInfos.ForEach(s &lt;/span&gt;=&amp;gt; s.isSelected = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        ForFollow();
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        NotFollow();
                    }
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;电脑AI出牌的时候，通过FindBigger，去匹配手牌中有没有满足牌力大于上家牌的牌组类型，如果有，将返回的牌组出出去，如果没有，则自动过牌。&lt;/p&gt;
&lt;p&gt;那现在玩家出牌、电脑AI出牌就可以正常处理了，我们来看一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/371995/201712/371995-20171204145106951-402076610.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;我们的斗地主游戏开发有段时间了，本文就作为阶段性的结束篇~当然，远算不上是一个成品游戏，我只是简单的实现了部分功能，有些代码现在看来还是偷工减料。要完成一个成品游戏，需要大量的精力和时间，条件也不允许，以后有机会的话，可能会对这个项目完善和优化。&lt;/p&gt;
&lt;p&gt;这是我第一次写一个系列的东西，写得不好请大家多多包涵~推出这个系列，我的主旨是想和大家分享下Unity3D开发一个斗地主游戏的整体架构和设计模式，虽然是个半成品，但是有些代码我是真的用心去写的，尽量的把我实现的思路和对游戏的理解展现给大家。就像一千个人眼中有一千个哈姆雷特，由于我们对游戏理解的不同，同样的斗地主游戏，不同的开发者，实现的方法可能就是不同的。我能做的，我希望做的，就是把个人的思想剖析给你们，如果你们能理解，或者对你们有所帮助，也是我的幸事。&lt;/p&gt;
&lt;p&gt;最后，谢谢各位的一路陪伴。也欢迎大家关注，我们一同学习，共同进步，以后会坚持出新的系列！&lt;/p&gt;
&lt;h3&gt;资源&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lizzie2008/ChinesePoker.git&quot; target=&quot;_blank&quot;&gt;项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Dec 2017 06:52:00 +0000</pubDate>
<dc:creator>Lancel0t</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lizzie-xhu/p/7977040.html</dc:identifier>
</item>
<item>
<title>深入理解ES6之——JS类的相关知识 - 寻找石头鱼</title>
<link>http://www.cnblogs.com/xzsty/p/7976929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xzsty/p/7976929.html</guid>
<description>&lt;p&gt;类声明以class关键字开始，其后是类的名称；剩余部分的语法看起来像对象字面量中的方法简写，并且在方法之间不需要使用逗号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person {
    //等价于prototype的构造器
    constructor(name) {
        this.name = name;
    }

    SayName() {
        console.log(this.name);
    }
}

let per = new Person(&quot;cf&quot;);
per.SayName();//cf

console.log(typeof Person);//function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;类声明不会被提升。类声明的行为类似let，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。&lt;/li&gt;
&lt;li&gt;类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式&lt;/li&gt;
&lt;li&gt;类的所有方法都是不可枚举的&lt;/li&gt;
&lt;li&gt;类的所有方法内部都没有[[Construct]],因此使用new来调用他们会抛出错误&lt;/li&gt;
&lt;li&gt;调用类构造器时不使用new会抛出错误。&lt;/li&gt;
&lt;li&gt;试图在类的内部修改重写类名，会抛出错误。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类与函数有相似之处，即它们都有两种形式：声明与表达式&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;let PersonClass = class {
    constructor(name) {
        this.name = name;
    }

    SayName() {
        console.log(this.name);
    }
}

let per = new PersonClass(&quot;cc&quot;);
per.SayName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类表达式和类声明都不会被提升&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;let PersonClass = class PersonClass2 {
    constructor(name) {
        this.name = name;
    }

    SayName() {
        console.log(this.name);
        console.log(PersonClass2);
    }
}

let per = new PersonClass(&quot;cc&quot;);
per.SayName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此例中的类表达式被命名为PersonClass2.PersonClass2只在类定义内部存在，因此只能用在类方法内部。&lt;/p&gt;

&lt;p&gt;在编程中，能被当做值来使用的就成为一级公民，意味着他能作为参数，能作为函数返回值，能用来给变量赋值。js的函数就是一级公民。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let createObject = function (classDef) {
    return new classDef();
}

let obj = new createObject(class {
    SayHi() {
        console.log(&quot;hi&quot;);
    }
})

obj.SayHi();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自有属性需要在类构造器中创建，而类还允许你在原型上定义访问器属性。为了创建一个getter ，要使用 get 关键字，并要与后方标识符之间留出空格；创建 setter 用相同方式，只是要换用 set 关键字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class CustomHtmlElement {
    constructor(element) {
        this.element = element;
    }
    get html() {
        return this.element.innerHTML;
    }

    set html(value) {
        this.element.innerHTML = value;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;类方法与类访问器属性也能使用需计算的名称。语法相同于对象字面量中的需计算名称：无须使用标识符，而是用方括号来包裹一个表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let methodName = &quot;SayName&quot;;
class PersonClass {
    constructor(name) {
        this.name = name;
    }

    [methodName]() {
        console.log(this.name);
    }
}

let per = new PersonClass(&quot;cc&quot;);
per.SayName();&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以使用Symbol.iterator来定义生成器方法，从而定义出类的默认迭代器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Collection {
    constructor() {
        this.items = [];
    }

    *[Symbol.iterator]() {
        yield this.items;
    }
}

let collection = new Collection();

collection.items.push(1);
collection.items.push(2);
collection.items.push(3);

for (let num of collection.items) {
    console.log(num);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;静态成员不能通过实例来访问，你始终需要直接用类自身来访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class PersonClass {
    constructor(name) {
        this.name = name;
    }

    SayName() {
        console.log(this.name);
    }

    static create() {
        return new PersonClass(name);
    }
}

let per = new PersonClass.create(&quot;cc&quot;);&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }
}

class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }
}

let sq = new Square(10);
console.log(sq.getArea());//100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承了其他类的类被称为派生类。如果派生类指定了构造器，就需要使用super(),否则就会出错。如果不定义构造器，super()方法会被自动调用，并会使用创建新实例时提供的所有参数。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Square extends Rectangle {

}

let sq = new Square(10, 10);
console.log(sq.getArea());//100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用super需要牢记以下几点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你只能在派生类中使用super。&lt;/li&gt;
&lt;li&gt;在构造器中，你必须在访问this之前调用super()。由于super()负责初始化this，因此试图先访问this自然后报错。&lt;/li&gt;
&lt;li&gt;唯一能避免调用super()的办法，是从类构造器中返回一个对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;派生类中的方法总是会屏蔽基类的同名方法。例如：你可以将getArea()方法添加到Square类，以便重新定义它的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }
}

class Square extends Rectangle {
    constructor(length, name) {
        super(length, length);
        this.name = name;
    }

    getArea() {
        return `this is ${this.name} input ${this.length}`
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用super.getArea()方法来调用基类中的同名方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }

    getArea() {
        return super.getArea();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }

    getArea() {
        return this.length * this.width;
    }

    static create(length, width) {
        return new Rectangle(length, width);
    }
}
      
        
class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }
}
let sqr = Square.create(10, 10);

console.log(sqr.getArea());//100&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在ES6中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有[[Constructor]]属性以及原型的函数，你就可以对其使用extends。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Rectangle(length,width){
    this.length = length;
    this.width = width;
}

Rectangle.prototype.getArea = function(){
    return this.length * this.width;
}

class Square extends Rectangle{
    constructor(length){
        super(length,length);
    }
}
let x = new Square(10);

console.log(x.getArea());//100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;extends后面能接受任意类型的表达式，这带来了巨大的可能性，例如动态的决定要继承的类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function Rectangle(length, width) {
    this.length = length;
    this.width = width;
}

Rectangle.prototype.getArea = function () {
    return this.length * this.width;
}

function getBase() {
    return Rectangle;
}

class Square extends getBase() {
    constructor(length) {
        super(length, length);
    }
}

let x = new Square(10);

console.log(x.getArea());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任意表达式都能在extends关键字后使用，但并非所有表达式的结果都是一个有效的类。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;生成器函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在ES6类的继承中，this的值会先被基类创建，随后才被派生类的构造器所修改。结果是this初始就拥有作为基类的内置对象的所有功能，并能正确的接收与之关联的所有功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyArray extends Array {

}

let arr = new MyArray();
arr[0] = 'red';
console.log(arr.length);

arr.length = 0;
console.log(arr[0]);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;继承内置对象的一个有趣方面是：任意能返回内置对象实例的方法，在派生类上却会自动返回派生类的实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyArray extends Array {

}

let arr = new MyArray(1, 2, 3);
let subitems = arr.slice(1, 2);
console.log(subitems);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 04 Dec 2017 06:48:00 +0000</pubDate>
<dc:creator>寻找石头鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xzsty/p/7976929.html</dc:identifier>
</item>
<item>
<title>【javaFX学习】（一） 建一个简单的界面 - lensener</title>
<link>http://www.cnblogs.com/lensener/p/7976953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lensener/p/7976953.html</guid>
<description>&lt;p&gt;转载注明出处：&lt;a&gt;http://www.cnblogs.com/lensener/p/7976953.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用过swing都知道有多蛋疼，界面有多丑。自从用了javaFX，腰也不酸了，腿也不疼了。&lt;/p&gt;
&lt;p&gt;废话不多说，开撸！&lt;/p&gt;
&lt;p&gt;工具： IntelliJ IDEA   （其实我也习惯用eclipse，但是一样东西能流行起来自然有它的道理）&lt;/p&gt;
&lt;p&gt;jdk   :   1.8&lt;/p&gt;

&lt;p&gt;先从最简单的开始,新建一个类，写一个main函数（简单的我想打自己）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一件事，继承application类以获得javaFX的所有功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.application.Application;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.stage.Stage;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Main &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Application{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        launch(args);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动程序时，初始化javaFX设置&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Stage primaryStage) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; start()方法就按字面意思理解就好了，程序启动执行的方法，所以我们的初始化界面的方法都写在里面。&lt;/p&gt;
&lt;p&gt; 那界面都有哪些东西呢，最外面那个带 - □ x 的部分，在javaFX中叫&lt;strong&gt;stage&lt;/strong&gt;。 所以，我们至少需要一个&lt;strong&gt;stage&lt;/strong&gt;，才能看见界面。而上面可以看到，在start(String primaryStage)中，已经有了一个stage，如何让&lt;/p&gt;
&lt;p&gt;stage显示呢，调用stage.show()方法；&lt;/p&gt;
&lt;p&gt;后面尽量写注释，就不多bb了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.application.Application;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.Scene;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.control.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.layout.StackPane;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.stage.Stage;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Main &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Application{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        launch(args);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动程序时，初始化javaFX设置&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Stage primaryStage) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        Button button &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Button(&quot;点击按钮&quot;&lt;span&gt;);

        StackPane layout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StackPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;布局&lt;/span&gt;
&lt;span&gt;
        layout.getChildren().add(button);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将按钮添加入布局&lt;/span&gt;
&lt;span&gt;
        Scene scene &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Scene(layout,300,300);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置布局、大小&lt;/span&gt;
&lt;span&gt;
        primaryStage.setScene(scene);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将场景添加到stage&lt;/span&gt;
&lt;span&gt;
        primaryStage.show();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示stage&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092310/201712/1092310-20171204141137091-975305387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看图就很好理解了，控件添加到布局里面，布局添加到secen中，设置scene大小，scene添加到stage，显示stage。&lt;/p&gt;
&lt;p&gt;下面给我们的按钮添加一个点击事件：实现EventHandler&amp;lt;ActionEvent&amp;gt;接口，重写hanle()方法，这里我为了方便就写在一个类里了，实际开发中最好分开，一个类只干一类事，一个方法只干一件事。&lt;/p&gt;
&lt;p&gt;给按钮绑定事件:button.setOnAction(this);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.application.Application;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.event.ActionEvent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.event.EventHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.Scene;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.control.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.scene.layout.StackPane;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javafx.stage.Stage;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Main &lt;span&gt;extends&lt;/span&gt; Application &lt;span&gt;implements&lt;/span&gt; EventHandler&amp;lt;ActionEvent&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        launch(args);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动程序时，初始化javaFX设置&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start(Stage primaryStage) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        Button button &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Button(&quot;点击按钮&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;button.setOnAction(this::handle);&lt;/span&gt;
        button.setOnAction(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定事件&lt;/span&gt;
&lt;span&gt;
        StackPane layout &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StackPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
&lt;span&gt;
        layout.getChildren().add(button);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将按钮添加入布局&lt;/span&gt;
&lt;span&gt;
        Scene scene &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Scene(layout,300,300);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置容器、大小&lt;/span&gt;
&lt;span&gt;
        primaryStage.setScene(scene);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将场景添加到stage&lt;/span&gt;
&lt;span&gt;
        primaryStage.show();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示stage&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handle(ActionEvent event) {
        System.out.println(&lt;/span&gt;&quot;Click button !&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092310/201712/1092310-20171204143811466-713352871.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 转载注明出处：&lt;a&gt;http://www.cnblogs.com/lensener/p/7976953.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Dec 2017 06:39:00 +0000</pubDate>
<dc:creator>lensener</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lensener/p/7976953.html</dc:identifier>
</item>
<item>
<title>CYQ.Data 正式支持 DotNET Core 版本发布 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/7969062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/7969062.html</guid>
<description>&lt;p&gt;自从上周开始，IOS人员逝去，就开始接手IOS的代码了。&lt;/p&gt;
&lt;p&gt;并开始整理IOS的代码（包括当时一开始设计的开发框架）。&lt;/p&gt;
&lt;p&gt;在未来不远的日子里，设想是有一个系列详细的介绍I恋App和IT连App及前后端所有涉及的技术系列。&lt;/p&gt;
&lt;p&gt;同时还准备发布一个IOS的开发框架，为十二星座再凑一个成员。&lt;/p&gt;
&lt;p&gt;闲话结束，下面看正文： &lt;/p&gt;

&lt;p&gt;大约是上周五，在提交CYQ.Data V5.5.8.1版本到Nuget后，看着C盘还有7G发了一会呆。&lt;/p&gt;
&lt;p&gt;之后做了一个决定，卸载了VS2015，现在C盘有10个G。&lt;/p&gt;
&lt;p&gt;到了微软官网，下载了社区版，把VS2017给装上了，好在可以选组件，只挑.NET Core 相关的，5个多G就完事。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204024549466-1808477334.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204024713294-1610537091.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好之后，建一个类库工程，把整套源码Copy过去，依赖项就是我们平时引用dll的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204015204982-1583147395.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204015516122-261629256.jpg&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始编绎，并见证奇迹：一堆错误。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204015531435-1326088603.jpg&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还好，VS2017在错误提示方面很人性化，分批给你显示错误数，让你解决一批再出来一批。&lt;/p&gt;
&lt;p&gt;不像当初在VS2015折腾.NET Core 1.1的时候，一下子出来几百个错误，梁静如都救不了你。&lt;/p&gt;

&lt;h2&gt;折腾.NET Core 1.1的时候：&lt;/h2&gt;
&lt;p&gt;那时候是把CYQ.Data的源码给重构整理了一次，把不支持的都单独给抽离出来。&lt;/p&gt;
&lt;p&gt;像这样，比如那时候不支持序列化，就把涉及序列化的都抽出来放到一个文件：&lt;/p&gt;
&lt;p&gt;通常一个类，会分拆出几个partial的部分类（不支持的用于被排除）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204021735357-569733503.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;想法挺好：&lt;/p&gt;
&lt;p&gt;通过排除某些文件夹的方式，来达到切换的状态，这样可以不用维护两份代码。&lt;/p&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;p&gt;要达到去掉文件夹还能编绎完整通过的解O方式，由于有些是强关系，关是业务整理，工作量大的出奇。&lt;/p&gt;
&lt;p&gt;一些代码还得修改为反射的动态调用，才能达到分离文件也正常，好不麻烦。&lt;/p&gt;
&lt;p&gt;关键还是那时候的版本缺失的类库太多，折腾没几天，放下了，回头才是岸。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;折腾.NET Core 2.0：&lt;/h2&gt;
&lt;p&gt;1：想过针对性的写一个迷你版本。&lt;/p&gt;
&lt;p&gt;但没那么简单，要有激情，要有大量时间，这些条件要同时满足不容易。&lt;/p&gt;
&lt;p&gt;同时意味着又多一个要维护的框架，虽然我维护中的框架已数不过来，多一个也不算多。&lt;/p&gt;
&lt;p&gt;可时间对于认真的人，总是不够用啊！！！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2：通过增量方式，解决版本支持问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面说到，折腾 .NET Core 1.1 时，是想通过减量排除来解决问题，结果不得其门。&lt;/p&gt;
&lt;p&gt;事情放一放，一回头，解决问题的方式，就是来的那么巧，那么妙。&lt;/p&gt;
&lt;p&gt;这回很理所当然的，就想到用增量的方式来解决问题。&lt;/p&gt;

&lt;p&gt;对于每一个提示不存在的类，VS环境中鼠标放上去时，都会有一个提示重构，通过它可以减少不少工作量。&lt;/p&gt;
&lt;p&gt;1：为每一个不支持的类、方法、或属性，都用重构的方式，重新生成一个类文件，并用对应的名称空间整理放好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204023403935-927528508.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这种方式，整理出不支持有差异化的类库，而且也可以清楚知道，框架里引用了哪些类是 .NET Core所没有的。&lt;/p&gt;
&lt;p&gt;然后先顺利编绎通过。&lt;/p&gt;

&lt;p&gt;2：重写新建类库的实现，比如，重写读配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:false;&quot;&gt;
using CYQ.Data;
using System.IO;
using CYQ.Data.Tool;
using System.Collections.Specialized;

namespace System.Configuration
{
    internal class ConfigurationManager
    {
        static string appSettingJson = string.Empty;
        static ConfigurationManager()
        {
            string filePath = AppConfig.WebRootPath + &quot;appsettings.json&quot;;
            if (System.IO.File.Exists(filePath))
            {
                appSettingJson = File.ReadAllText(filePath, Text.Encoding.UTF8);
                if (!string.IsNullOrEmpty(appSettingJson))
                {
                    appSettingJson = appSettingJson.Replace(&quot;\\\\&quot;, &quot;\\&quot;);
                }
            }
        }
        private static NameValueCollection _AppSettings;
        public static NameValueCollection AppSettings
        {
            get
            {
                if (_AppSettings == null &amp;amp;&amp;amp; !string.IsNullOrEmpty(appSettingJson))
                {
                    string settingValue = JsonHelper.GetValue(appSettingJson, &quot;appsettings&quot;);
                    if (!string.IsNullOrEmpty(settingValue))
                    {
                        _AppSettings = JsonHelper.ToEntity&amp;lt;NameValueCollection&amp;gt;(settingValue);
                    }
                }
                if (_AppSettings == null)
                {
                    return new NameValueCollection();
                }
                return _AppSettings;
            }
        }
        private static ConnectionStringSettingsCollection _ConnectionStrings;
        public static ConnectionStringSettingsCollection ConnectionStrings
        {
            get
            {
                if (_ConnectionStrings == null)
                {
                    _ConnectionStrings = new ConnectionStringSettingsCollection();
                    if (!string.IsNullOrEmpty(appSettingJson))
                    {
                        string settingValue = JsonHelper.GetValue(appSettingJson, &quot;connectionStrings&quot;);
                        if (!string.IsNullOrEmpty(settingValue))
                        {
                            NameValueCollection nv = JsonHelper.ToEntity&amp;lt;NameValueCollection&amp;gt;(settingValue);
                            if (nv != null &amp;amp;&amp;amp; nv.Count &amp;gt; 0)
                            {
                                foreach (string key  in nv.Keys)
                                {
                                    ConnectionStringSettings cs = new ConnectionStringSettings();
                                    cs.Name = key;
                                    cs.ConnectionString = nv[key];
                                    _ConnectionStrings.Add(cs);
                                }
                            }

                        }
                    }
                }
               
                return _ConnectionStrings;
            }
        }
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件和System.Web这两个是经常用到的东西。&lt;/p&gt;
&lt;p&gt;相对配置文件的读取，System.Web的，麻烦了一些，需要Nuget上引用Microsoft.AspNetCore：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204024156544-1445452139.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引用好后，再重写里面的内容，具体的内容，这里就不贴代码了，代码可以见源码处。&lt;/p&gt;
&lt;p&gt;由于这周末两天临时集中处理，刚处理好，只做了简单的MSSQL的测试。&lt;/p&gt;
&lt;p&gt;所以来不及发布Nuget上，先写文了，等哪天测试稳定了再上Nuget。&lt;/p&gt;

&lt;p&gt;1：GitHub下载CYQ.Data的源码（会发现多了一个文件夹）&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/cyq1162/cyqdata&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/cyqdata&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201712/17408-20171204025920513-900099890.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于目前还没提交解决方案文件可以直接运行项目，所以现在提前提前体验的需要自己建类库项目了：&lt;/p&gt;
&lt;p&gt;2：自己新建一个类库项目，取名叫CYQ.Data，把源码都Copy过去（包括DotNetCore）&lt;/p&gt;
&lt;p&gt;3：Nuget上引用Microsoft.AspNetCore。&lt;/p&gt;
&lt;p&gt;编绎，然后就大功告成了，在你的.NET Core 项目里引用类库项目就可以了。&lt;/p&gt;
&lt;p&gt;如果涉及到Web，还需要有两个注入的地方：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
在MVC项目中调用app.UseStaticHttpContext()。

        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            app.UseStaticHttpContext();
            .....
         }
在没有注入 HttpContextAccessor的项目中，还需在ConfigureServices 方法中调用
services.AddHttpContextAccessor();
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;一个周末，一个巧合，一个连续的激情奋战。&lt;/p&gt;
&lt;p&gt;CYQ.Data 的.NET Core支持工作，就这样告一段落了。&lt;/p&gt;
&lt;p&gt;测试了MSSQL是基本通过，剩下的都好说了！！！&lt;/p&gt;
&lt;p&gt;后面Taurus.MVC还是Aries，估计离支持.NET Core也不远了。&lt;/p&gt;

&lt;p&gt;不过，接下来，又要进入IT连创业的状态了。&lt;/p&gt;
&lt;p&gt;对于IT连，结合一些网友的建议，最近也有不少思考。&lt;/p&gt;
&lt;p&gt;对接下来的产品优化及走向，又一波伤脑估计是在所难免。&lt;/p&gt;
&lt;p&gt;另外，运营还缺的一篇文章，回头也还得补上。&lt;/p&gt;
&lt;p&gt;最后的最后，仍是感谢大伙的关注！！！&lt;/p&gt;
</description>
<pubDate>Mon, 04 Dec 2017 06:37:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/7969062.html</dc:identifier>
</item>
<item>
<title>CNCC2017中的深度学习与跨媒体智能 - 梦里风林</title>
<link>http://www.cnblogs.com/hellocwh/p/7976875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellocwh/p/7976875.html</guid>
<description>&lt;p&gt;转载请注明作者：&lt;a href=&quot;https://github.com/ahangchen&quot;&gt;梦里茶&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;机器学习与跨媒体智能&lt;/li&gt;
&lt;li&gt;传统方法与深度学习
&lt;ul&gt;&lt;li&gt;图像分割&lt;/li&gt;
&lt;li&gt;小数据集下的深度学习&lt;/li&gt;
&lt;li&gt;语音前沿技术&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成模型
&lt;ul&gt;&lt;li&gt;基于贝叶斯的视觉信息编解码&lt;/li&gt;
&lt;li&gt;珠算：基于别噎死推断的深度生成模型库&lt;/li&gt;
&lt;li&gt;图像与视频生成的规则约束&lt;/li&gt;
&lt;li&gt;景深风景生成&lt;/li&gt;
&lt;li&gt;骨架约束的人体视频生成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;跨媒体智能
&lt;ul&gt;&lt;li&gt;视频检索的哈希学习&lt;/li&gt;
&lt;li&gt;多媒体与知识图谱&lt;/li&gt;
&lt;li&gt;基于锚图的视觉数据分析&lt;/li&gt;
&lt;li&gt;视频问答&lt;/li&gt;
&lt;li&gt;细粒度分类&lt;/li&gt;
&lt;li&gt;跨媒体关联与检索（待补充）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;正片开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;传统方法与深度学习&quot;&gt;传统方法与深度学习&lt;/h2&gt;
&lt;h3 id=&quot;图像分割&quot;&gt;图像分割&lt;/h3&gt;
&lt;p&gt;图像分割是医疗图像中一个很重要的任务，通常分为分割，配准，可视化几个子任务。这里贴一张广义的图像分割的图：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142743107-1310196233.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;存在的困难&quot;&gt;存在的困难：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;不同目标区域亮度一致，区分度小，&lt;/li&gt;
&lt;li&gt;不同目标区域边界模糊，&lt;/li&gt;
&lt;li&gt;图像采集存在噪声&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;常用分割步骤&quot;&gt;常用分割步骤&lt;/h4&gt;
&lt;p&gt;检测（定位）-&amp;gt; 边界寻优&lt;/p&gt;
&lt;h4 id=&quot;常用分割方法&quot;&gt;常用分割方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;按照图像中区域的能量与联系，建立&lt;code&gt;图模型&lt;/code&gt;，用图割，图搜索的方法对图像进行分割&lt;/li&gt;
&lt;li&gt;&lt;code&gt;外观模型&lt;/code&gt;：特定的目标区域往往具有特殊的外观，包括轮廓，形状，可以用外观模型进行匹配，做粗粒度的分割，或者对细粒度处理后的图像进行校正&lt;/li&gt;
&lt;li&gt;多模态图像处理：融合&lt;code&gt;结构信息&lt;/code&gt;和&lt;code&gt;功能信息&lt;/code&gt;进行分割&lt;/li&gt;
&lt;li&gt;对准两个模型（结构和功能）的图像，对两个模型的预测结果进行约束（比如希望两个模型的输出相近）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;双模型交互迭代优化&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多边形近似&lt;/li&gt;
&lt;li&gt;对于某种目标区域，有着固定的多边形外观，可通过多边形近似的方法，标记出图像中近似的特征点 &lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;语音前沿技术&quot;&gt;语音前沿技术&lt;/h3&gt;
&lt;h4 id=&quot;任务&quot;&gt;任务&lt;/h4&gt;
&lt;p&gt;降噪，增强，杂音分离，消除回响&lt;/p&gt;
&lt;h4 id=&quot;结合领域知识和dnn&quot;&gt;结合领域知识和DNN&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;数据标注：结合领域知识提出需要标注哪些数据&lt;/li&gt;
&lt;li&gt;不直接学习目标，而是根据领域知识将目标任务进行分解&lt;br/&gt; - 比如识别字母，分解为识别摩擦音，爆破音&lt;/li&gt;
&lt;li&gt;将传统模型中里程碑式的东西拿过来用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;移动端语音挑战&quot;&gt;移动端语音挑战&lt;/h4&gt;
&lt;p&gt;模型压缩，轻量化&lt;/p&gt;
&lt;h2 id=&quot;生成模型&quot;&gt;生成模型&lt;/h2&gt;
&lt;h3 id=&quot;基于贝叶斯的视觉信息编解码&quot;&gt;基于贝叶斯的视觉信息编解码&lt;/h3&gt;
&lt;h4 id=&quot;任务-1&quot;&gt;任务&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;视觉信息编码：视觉信息通过人脑转为神经活动的过程&lt;/li&gt;
&lt;li&gt;视觉信息解码：神经活动新号转为视觉信息的过程&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;模型基于卷积和反卷积的自编码器&quot;&gt;模型（基于卷积和反卷积的自编码器）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;推理网络：卷积神经网络，得到中间特征，建立中间特征与神经活动信号之间的关联，从而得到神经活动得到编码&lt;/li&gt;
&lt;li&gt;生成网络：将神经活动进行反卷积，得到图像&lt;/li&gt;
&lt;li&gt;对于两个信号，学习两个信号产生于同一对象的概率（相似度分析），建立起一个贝叶斯推断模型&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;多视图生成式自编码器&quot;&gt;多视图生成式自编码器&lt;/h4&gt;
&lt;p&gt;除了视觉数据之外，还有其他模态的数据，可以根据多个模态的数据构建多视图的生成时自编码器&lt;/p&gt;
&lt;h3 id=&quot;珠算基于贝叶斯推断的深度生成模型库&quot;&gt;珠算：基于贝叶斯推断的深度生成模型库&lt;/h3&gt;
&lt;h4 id=&quot;任务-2&quot;&gt;任务&lt;/h4&gt;
&lt;p&gt;大数据中有许多不确定因素，需要学习对不确定性建模&lt;/p&gt;
&lt;h4 id=&quot;模型&quot;&gt;模型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142759701-1697619178.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给定一个输入z，用神经网络学习变量x的分布的参数（均值和方差），约束生成样本与真实样本的相似性&lt;/p&gt;
&lt;h4 id=&quot;有约束的gan&quot;&gt;有约束的GAN&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142819779-748478817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在GAN的基础上，加一个分类器C，对生成器G生成的对象加中间约束，使得生成的对象更符合实际需求，比如生成不同姿态的人脸，要求不同人的人脸尽量不同，同个人的人脸尽量相同。&lt;/p&gt;
&lt;h4 id=&quot;珠算&quot;&gt;珠算&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;基于Tensorflow的python库，无监督生成模型&lt;/li&gt;
&lt;li&gt;贝叶斯推断&lt;/li&gt;
&lt;li&gt;适合传统多层贝叶斯推断模型以及深度生成模型&lt;/li&gt;
&lt;li&gt;可用于&lt;br/&gt; - 多变量回归&lt;br/&gt; - 变分自编码器实现&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zhusuan.readthedocs.io/&quot; class=&quot;uri&quot;&gt;http://zhusuan.readthedocs.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;图像与视频生成的规则约束学习&quot;&gt;图像与视频生成的规则约束学习&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;GAN成为无监督领域的新框架&lt;/li&gt;
&lt;li&gt;WGAN，DCGAN&lt;br/&gt; - 在生成中，往往通过随机性引入创意&lt;/li&gt;
&lt;li&gt;已有工作&lt;br/&gt; - 人脸姿态转换，人脸年龄转换，人脸表情转换&lt;br/&gt; - 图像超分辨率生成，画风转换，字体转换，图像转视频&lt;/li&gt;
&lt;li&gt;应用&lt;br/&gt; - 动画自动制作，手语生成&lt;br/&gt; - 视频自动编辑（如生成不同天气情况下的风景）&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创意+规则约束+复杂场景+复杂交互&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;难点&lt;br/&gt; - 解空间巨大：需要找出解所在的低维子空间&lt;br/&gt; - 宏观结构的一致性（视频生成需要的像素感受野（pooling）很大，难以预测长期运动变化）&lt;br/&gt; - 微观结构的清晰度，要同时逼近多模分布，避免单模生成的结果不够精确&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;解决方法&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用领域中的规则去约束GAN，加入破坏规则的代价&lt;br/&gt; - 缩小预测空间，保证宏观结构，加快细节生成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;景深风景生成&quot;&gt;景深风景生成&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;难点：要求空间结构合理，不能有严重的模糊&lt;/li&gt;
&lt;li&gt;约束：从现有风景图像中对景深关系建模（对区域进行标注， 不同区域，即图层，有不同的远近限制）&lt;/li&gt;
&lt;li&gt;建立位置和对象的关系，得到某个位置有某个对象的概率分布&lt;/li&gt;
&lt;li&gt;Hawkes过程模型&lt;/li&gt;
&lt;li&gt;根据对象对图层做分解，由概率约束建立图层约束（树在人之前的概率有多大）&lt;/li&gt;
&lt;li&gt;层内DCGAN，层间LSTM聚合出整图&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;骨架约束的人体视频生成&quot;&gt;骨架约束的人体视频生成&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;骨架运动有约束&lt;/li&gt;
&lt;li&gt;骨架提取很鲁棒，可以得到很多有标签知识（传统方法用来提取知识），作为约束条件&lt;/li&gt;
&lt;li&gt;静图+动作序列变动图&lt;/li&gt;
&lt;li&gt;CNN编码解码，孪生网络双输入进行生成&lt;/li&gt;
&lt;li&gt;判别器：对生成和实际帧做Triplet loss优化&lt;/li&gt;
&lt;li&gt;gan loss和视频相似度loss相加&lt;/li&gt;
&lt;li&gt;交互运动视频生成&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;视频检索的哈希学习&quot;&gt;视频检索的哈希学习&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Learning Multifunctional Binary Codes for Both Category and Attribute Oriented Retrieval Tasks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;视频检索基于图像检索，大规模图像检索对性能要求较高&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图像检索&lt;/li&gt;
&lt;li&gt;任务：通常图像特征很大，直接检索特征太慢&lt;br/&gt; - 方法：&lt;br/&gt;   - 用二进制编码出一个哈希值来表达特征&lt;br/&gt;   - 对哈希值做高效的异或运算求相似度&lt;br/&gt;   - 模型（添加了对二进制编码的约束，希望绝对值与1尽量相近）：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142902919-40144039.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;多媒体与知识图谱&quot;&gt;多媒体与知识图谱&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Cross-media analysis and reasoning: advances and directions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于锚图的视觉数据分析&quot;&gt;基于锚图的视觉数据分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;图学习&lt;br/&gt; - 对视觉数据可以计算相似度，对于整个数据集就可以得到一个相似度矩阵，学过图论的同学都知道，矩阵就是图&lt;br/&gt; - 相似度矩阵 -&amp;gt; 图的邻接矩阵 -&amp;gt; 用图的方法对邻接矩阵进行优化&lt;/li&gt;
&lt;li&gt;标号建模 标号平滑 标号学习&lt;/li&gt;
&lt;li&gt;锚图学习（速度+）&lt;br/&gt; - 这是一种coarse to fine的思路&lt;br/&gt; - 利用数据点图，生成锚点图，先采一部分有代表性的数据（例如聚类中心）生成一个图模型，然后推理出其他图&lt;br/&gt; - 图模型中需要建立表示矩阵（特征工程），邻接矩阵（度量学习），并加快相似度计算&lt;/li&gt;
&lt;li&gt;高效锚图（性能速度+）&lt;br/&gt; - 从数学上优化锚图的约束条件，使得优化问题的复杂度大大降低&lt;/li&gt;
&lt;li&gt;层次化锚图（速度++）&lt;br/&gt; - 建立多层的锚图，也就是对采样点再采样&lt;br/&gt; - 锚点是线性增加的，也会增加得很快&lt;/li&gt;
&lt;li&gt;对第一层采样的点做再采样，多层采样减少了锚点数目，从最少的锚点的层逐层推理&lt;/li&gt;
&lt;li&gt;标号预测器（速度+++）&lt;br/&gt; - 优化对锚点的标号（打伪标签进行半监督学习）&lt;br/&gt; - 对最小的锚点层接一个优化器进行标号预测&lt;/li&gt;
&lt;li&gt;主动学习（样本选择）&lt;br/&gt; - 是一种hard mining的思路，选择更有用的样本作为锚点&lt;br/&gt; - 减小标号的误差损失&lt;/li&gt;
&lt;li&gt;对比Google Expander Graph Learning平台：经典方法，并行运算，而锚图可以通过并行进一步提升速度&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;视频问答&quot;&gt;视频问答&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;任务：&lt;/li&gt;
&lt;li&gt;输入视频，问题，输出答案&lt;/li&gt;
&lt;li&gt;模型（层次记忆网络+视频时序推理）：&lt;/li&gt;
&lt;li&gt;对图像进行分层&lt;/li&gt;
&lt;li&gt;对问题进行记忆&lt;/li&gt;
&lt;li&gt;用文本和图像特征一同训练生成答案&lt;/li&gt;
&lt;li&gt;用LSTM做时序推理&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;细粒度分类&quot;&gt;细粒度分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;任务：&lt;br/&gt; - 识别图像同一大类中的子类&lt;/li&gt;
&lt;li&gt;挑战：&lt;br/&gt; - 姿态视角不同导致类内差异大，外形颜色相似导致类间差异小&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基于模型动态扩容的增量深度学习方法&quot;&gt;基于模型动态扩容的增量深度学习方法&lt;/h4&gt;
&lt;p&gt;论文：Error-Driven Incremental Learning in Deep Convolutional Neural Network for Large-Scale Image Classification&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将目标的多个类别按相似度划分为几个大类，&lt;/li&gt;
&lt;li&gt;增加一个新的类别时，将其归入最相近的大类中，重用大类的参数，扩展小类分类层参数&lt;/li&gt;
&lt;li&gt;利用类别子集合划分实现模型动态扩容，利用特征迁移学习实现训练加速（对类别做聚类）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142927091-781157668.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;局部两级注意力深度模型&quot;&gt;局部两级注意力深度模型&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The Application of Two-level Attention Models in Deep Convolutional Neural Network for Fine-grained Image Classification&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给定图片-类别，不给出对象位置（bounding box）和局部的位置(part location)，用Attention学习对象位置和局部特征&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object level: 首先用公开的数据集预训练模型，top-down地作用在整图上，选出跟目标相关的区域（响应度最高的区域），相当于抠图，对抠过的区域再加上类别标签进行迁移学习。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204142946966-1615514907.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Part level:&lt;/li&gt;
&lt;li&gt;对于Object level得到的模型，对卷积层的filter做相似度聚类，同一类的卷积层合为一个part detector，用来为具体的对象局部做识别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204143000029-2134614181.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结合总体评分和局部评分来对对象做细粒度分类&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;空间约束的显著性部件选择模型&quot;&gt;空间约束的显著性部件选择模型&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Weakly Supervised Learning of Part Selection Model with Spatial Constraints for Fine-grained Image Classification&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;显著性提取和协同分割定位对象&lt;/li&gt;
&lt;li&gt;先通过显著性聚类提出备选局部，&lt;/li&gt;
&lt;li&gt;再对局部位置关系提出两个空间约束：局部和整体必须有尽可能多的重叠，局部之间有尽可能少的重叠。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204143015247-1065961280.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两篇都是不需要局部组件的标注，就学到了局部的特征和约束&lt;/p&gt;
&lt;h4 id=&quot;显著性引导的细粒度辨识性定位方法&quot;&gt;显著性引导的细粒度辨识性定位方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Fine-grained Discriminative Localization via Saliency-guided Faster R-CNN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结合分类模型和检测模型做更高精度的细粒度分类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显著性模型提供弱标记的图片训练faster r-cnn检测模型&lt;/li&gt;
&lt;li&gt;检测模型提供更精确的备选区域进行分类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204143027091-1644227616.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;视觉文本联合建模的图像细粒度表示&quot;&gt;视觉文本联合建模的图像细粒度表示&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Fine-grained Image Classification via Combining Vision and Language&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在图片数据集的基础上，增加对图片的描述文本，利用这两个模态的数据提供更高精度的细粒度分类&lt;/li&gt;
&lt;li&gt;卷积做图像分类，CNN+LSTM做文本分类，两个分类结果合起来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/780612/201712/780612-20171204143039763-1384548789.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨媒体关联与检索&quot;&gt;跨媒体关联与检索&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;跨媒体统一表征学习：使用相同的特征类型表征不同媒体的数据&lt;/li&gt;
&lt;li&gt;跨媒体相似度计算：通过分析跨媒体关联关系，计算不同媒体数据的语义相似性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的六篇论文我还没读完，读完之后补具体的理解&lt;/p&gt;
&lt;h4 id=&quot;跨媒体关联传递方法&quot;&gt;跨媒体关联传递方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;IJCV2013： Exhaustive and Efficient Constraint Propagation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于稀疏和半监督的统一表征方法&quot;&gt;基于稀疏和半监督的统一表征方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Learning Cross-Media Joint Representation With Sparse and Semisupervised Regularization&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于跨媒体语义单元的统一表征方法&quot;&gt;基于跨媒体语义单元的统一表征方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Semi-Supervised Cross-Media Feature Learning with Unified Patch Graph Regularization&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于跨媒体多深度网络的统一表征方法&quot;&gt;基于跨媒体多深度网络的统一表征方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Cross-media Shared Representation by Hierarchical Learning with Multiple Deep Networks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于多粒度层级网络跨媒体关联学习方法&quot;&gt;基于多粒度层级网络跨媒体关联学习方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CCL: Cross-modal Correlation Learning with Multi-grained Fusion by Hierarchical Network&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;跨媒体混合迁移网络方法&quot;&gt;跨媒体混合迁移网络方法&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Cross-modal Common Representation Learning by Hybrid Transfer Network, IJCAI2017&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;跨媒体检索数据集pku-xmedia&quot;&gt;跨媒体检索数据集PKU-XMedia&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;www.icst.pku.edu.cn/mlpl/XMedia&lt;/li&gt;
&lt;li&gt;五种媒体类型（图像、文本、视频、音频、3D）&lt;/li&gt;
&lt;li&gt;10万标注数据，200个语义类别，基于wordNet的层次结构&lt;/li&gt;
&lt;li&gt;来自Wikipedia, Flickr, Youtube, Findsounds, Freesound, Yobi3D&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 04 Dec 2017 06:26:00 +0000</pubDate>
<dc:creator>梦里风林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellocwh/p/7976875.html</dc:identifier>
</item>
<item>
<title>程序员的自我救赎---1.4.2： 核心框架讲解(BLL&amp;Tool) - Near_wen</title>
<link>http://www.cnblogs.com/demon28/p/7976364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon28/p/7976364.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7886504.html&quot; target=&quot;_blank&quot;&gt;《前言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;《目录》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（一） Winner2.0 框架基础分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（二） 短信中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（三）SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（四）PLSQL报表系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（五）钱包系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（六）GPU支付中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（七）权限系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（八）监控系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（九）会员中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十）消息中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十一）Winner前端框架与RPC接口规范讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十二）上层应用案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt; （十三）番外篇&lt;/a&gt; &lt;/p&gt;


&lt;p&gt;《核心框架讲解》&lt;/p&gt;

&lt;p&gt;之前想用一篇文章讲完核心框架的三四个程序集，后来写着写着就发现一篇文章写不完，这才想了一下用最少要用三篇。&lt;/p&gt;
&lt;p&gt;上一篇讲了一下DAL，其实也没讲特别透，主要讲了一下DA部分的使用。这一篇文章主要来讲一下FacadeBase和常用工具。&lt;/p&gt;
&lt;p&gt;其实在之前讲《&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7919665.html&quot; target=&quot;_blank&quot;&gt;事务的使用&lt;/a&gt;》 的时候已经着重介绍过FacadeBase，不复杂。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.DataAccess;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.Interface;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.Facade
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通用三层架构的业务处理层(BLL)基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FacadeBase : IDisposable, IPromptInfo
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PromptInfo _promptInfo;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PromptInfo PromptInfo
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._promptInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._promptInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PromptInfo();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._promptInfo;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 分页控件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IChangePage ChangePage;

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 错误详情上报

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误详情&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Alert(PromptInfo result)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._promptInfo =&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Alert(ResultType restulType)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(restulType);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(msg);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误详情&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Alert(ResultType restulType, PromptInfo result)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(restulType, result);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(ResultType restulType, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(restulType, msg);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;上级错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, PromptInfo result)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(msg, result);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误详情&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(ResultType restulType, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg, PromptInfo result)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PromptInfo.Alert(restulType, msg, result);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 事务
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Transaction Transaction { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTransaction()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.Transaction == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Transaction = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.DataAccess.Transaction();
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.BeginTransaction();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提示事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Commit()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.Commit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 强制回滚事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RealRollback()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.RealRollback();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物串联
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;transaction&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;事物对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReferenceTransactionFrom(Transaction transaction)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Transaction =&lt;span&gt; transaction;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回滚事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Rollback()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.Rollback();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 对象销毁
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 销毁对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils.Model;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [DebuggerDisplay(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ResultType:{Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PromptInfo
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Property
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _customMessageStack;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _messageStack;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前自定义错误信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CustomMessage { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前自定义错误信息堆栈
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CustomMessageStack
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._customMessageStack))
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LoadResultStack(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._customMessageStack;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内部错误信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; PromptInfo InnerPromptInfo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前错误信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Message { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前错误信息堆栈
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; MessageStack
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._messageStack))
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LoadResultStack(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._messageStack;
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前错误类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ResultType ResultType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前错误类型编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Code { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ResultType; } }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Alert(ResultType restulType)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ResultType =&lt;span&gt; restulType;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Message = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{错误代码:{0} {1}}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)restulType, restulType);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CustomMessage =&lt;span&gt; message;
            ResultType &lt;/span&gt;=&lt;span&gt; ResultType.未指定;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Message = message + &lt;span&gt;@&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{错误代码:{0} {1}}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ResultType, ResultType);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;innerPromptInfo&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内部错误&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Alert(ResultType restulType, PromptInfo innerPromptInfo)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (innerPromptInfo == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.InnerPromptInfo =&lt;span&gt; innerPromptInfo;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Alert(restulType);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(ResultType restulType, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CustomMessage =&lt;span&gt; message;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ResultType =&lt;span&gt; restulType;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Message = message + &lt;span&gt;@&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{{错误代码:{0} {1}}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ResultType, ResultType);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;innerPromptInfo&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内部错误&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message, PromptInfo innerPromptInfo)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (innerPromptInfo == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.InnerPromptInfo =&lt;span&gt; innerPromptInfo;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Alert(message);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误详情上报
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;restulType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;错误信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;innerPromptInfo&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内部错误&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Alert(ResultType restulType, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; message, PromptInfo innerPromptInfo)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (innerPromptInfo != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.InnerPromptInfo =&lt;span&gt; innerPromptInfo;
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Alert(restulType, message);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LoadResultStack(PromptInfo promptInfo, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._customMessageStack = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._messageStack = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            }
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str1 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._customMessageStack;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(promptInfo.CustomMessage))
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._customMessageStack = &lt;span&gt;string&lt;/span&gt;.Concat(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { str1, index &amp;gt; &lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;string&lt;/span&gt;.Empty, index, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, promptInfo.CustomMessage });
            }
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str2 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._messageStack;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(promptInfo.Message))
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._messageStack = &lt;span&gt;string&lt;/span&gt;.Concat(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { str2, index &amp;gt; &lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;string&lt;/span&gt;.Empty, index, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, promptInfo.Message });
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (promptInfo.InnerPromptInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LoadResultStack(promptInfo.InnerPromptInfo, ++&lt;span&gt;index);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 转换为FuncResult对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FuncResult AsFuncResult()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; FuncResult.FailResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.MessageStack, Code);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;FacadeBase依赖DataAccess ，FacadeBase重点做的事情除了事务以外，就是错误详情上报，因为我们主旨是让&lt;/p&gt;
&lt;p&gt;业务流程返回True / False。 我见过有的为了上报错误详情，使用ref 、out 来实现，其实完全没毕业，这个功能太常用&lt;/p&gt;
&lt;p&gt;常用的功能就应该封装起来。&lt;/p&gt;

&lt;p&gt;这里说个额外的话题，其实上一篇中我讲到DA的SQL拼接的时候，其实那些功能很好用，但是后来由于使用“参数化”了，&lt;/p&gt;
&lt;p&gt;这就使得程序员要去自己写“like&quot;,&quot;%&quot;等等这样的关键字，有时间我还想安排人封装一下，参数化也要封装这些操作。开发起来&lt;/p&gt;
&lt;p&gt;才简单。&lt;/p&gt;

&lt;p&gt;说回正题，关于FacadeBase，“事务”已经讲过来，Alert 基本一看就懂，所以这里不做更细致的分析，看一下在项目中的应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171204102641544-711560047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 而在前端，调用Facade的时候，就只需要有取Facade 的 PromptInfo.Message 即可。 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171204103725060-1358396995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 关于Facade就介绍到这里，下面写一下今天的重点：Winner.Framework.Utils  和 Winner.Framework.Encrypt；  &lt;/p&gt;
&lt;p&gt;从字面上很好理解，一个是负责加密的，一个是工具集。 我们还是由浅入深的方式来讲一下先讲Utils吧，因为比较简单&lt;/p&gt;
&lt;p&gt;这个我不每个都做讲解。一张图贴明白：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171204110029185-1588391754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 目前就这些，作为一个工具集，其实网上有很多 Comon.dll下载，会内置很多工具，这里我简单介绍一下，我们Winner的工具集&lt;/p&gt;

&lt;p&gt;Configuration：  读取Web.Config 的配置，常规我们用于读取数据库连接字符串，和AppSetting的配置。（不支持配置文件写入）&lt;/p&gt;
&lt;p&gt;Json：  做Json的序列化与反序列化。这里引用的是系统框架 System.Web.Script.Serialization做的没有用Newtonsoft.json。&lt;/p&gt;
&lt;p&gt;Listener： 监听，可以用户执行监听等待，本质为一个监听服务。&lt;/p&gt;
&lt;p&gt;Log ： 引用log4net 写的日子记录工具。&lt;/p&gt;
&lt;p&gt;Map ： 映射工具类。&lt;/p&gt;
&lt;p&gt;Model： 常用的实体，如：基本Name，Value键值对封装。如： 常规的返回对象： 是否成功，错误信息，错误码。这样的常用实体。&lt;/p&gt;
&lt;p&gt;ModelVerify：实体验证，本身MVC的控制层可以使用系统自带的验证，但是如果放到业务层这不可用，这里封装后任意地方可使用。&lt;/p&gt;
&lt;p&gt;Network： 网络请求帮助类，内置如：上传文件，封装获取网址等网络请求中需要的操作方法。&lt;/p&gt;
&lt;p&gt;Photo：图片处理。&lt;/p&gt;
&lt;p&gt;Prompt：上报错误详情，上面已经讲到过了。&lt;/p&gt;
&lt;p&gt;Reflection： 获取成员特性（包括集合）。&lt;/p&gt;
&lt;p&gt;Sign：签名验证，如第三方Web服务调用中常用于防篡改。&lt;/p&gt;
&lt;p&gt;Text： 内置如：字符串格式化操作，安全码生成，后面单独讲该类操作。&lt;/p&gt;
&lt;p&gt;Track：Stopwatch  测试方法，执行过程中的时间，常用语检查程序性能。&lt;/p&gt;

&lt;p&gt;这里单讲一下Text：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171204111738201-1629681846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Text 里面包含的工具很多简单的 格式化时间类型，就不讲了重点讲一下安全转换 和 安全验证码：&lt;/p&gt;

&lt;p&gt; 安全转换 ：  正常情况下我们常见的将 String类型 转换成 int 类型一般都是用 Convert.ToInt 以及 int.Parse两种方式，&lt;/p&gt;
&lt;p&gt;使用Convert遇见如汉字这样的有可能会导致程序异常，而用int.Parse也一样，这时候最安全的做法是TryParse。而&lt;/p&gt;
&lt;p&gt;TryParse一旦用就要写if判断。有时候也不那么好用，所以Winner封装了安全转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 转换为ToInt32
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;defaultValue&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;默认值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ToInt32(&lt;span&gt;int&lt;/span&gt; defaultValue = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Value.HasValue())
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Convert.ToInt32(Value);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 类似这种封装还有很多。另外一个就是 生成安全码，我们知道身份证是带验证功能的，也就是说数字编号处理本身的顺序编号以外，&lt;/p&gt;
&lt;p&gt;要防止别人生成相关编号，来注入的情况下，就需要生成带验证功能的编号。Winner也做了相关封装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils.Text
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加权码
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SafeCode
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 45位加权因子(用Excle打乱顺序)
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] Factor = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;44&lt;/span&gt;, &lt;span&gt;43&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;, &lt;span&gt;34&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;36&lt;/span&gt;, &lt;span&gt;41&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;33&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;37&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;38&lt;/span&gt;, &lt;span&gt;39&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt; };

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 加权
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;code&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要加权编码&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Weighted(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; codeString =&lt;span&gt; code.ToString();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (codeString.Length &amp;lt;= &lt;span&gt;1&lt;/span&gt; || codeString.Length &amp;gt;&lt;span&gt; Factor.Length)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; codeString.Length; i++&lt;span&gt;)
            {
                sum &lt;/span&gt;+= &lt;span&gt;int&lt;/span&gt;.Parse(codeString[i].ToString()) *&lt;span&gt; Factor[i];
            }
            codeString &lt;/span&gt;+= sum %&lt;span&gt; codeString.Length;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;.Parse(codeString);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;code&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要验证的数字&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Validate(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; codeString =&lt;span&gt; code.ToString();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (codeString.Length &amp;lt;= &lt;span&gt;1&lt;/span&gt; || codeString.Length &amp;gt;&lt;span&gt; Factor.Length)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; original = codeString.Substring(&lt;span&gt;0&lt;/span&gt;, codeString.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; code == Weighted(&lt;span&gt;long&lt;/span&gt;&lt;span&gt;.Parse(original));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个编号本身自带校验功能，类似的功能还很多，我不一一列举。当然关于工具类，Winner其实还是有很多可以改进的地方，&lt;/p&gt;
&lt;p&gt;要囊括所有的攻击的话，Winner的工具类基本还是偏少但是够用，有时间Winner还可以继续扩展一下功能类。就比如之前我&lt;/p&gt;
&lt;p&gt;网上看到的&lt;a href=&quot;http://tool.sufeinet.com/CodePreview/CodeView.aspx&quot; target=&quot;_blank&quot;&gt;苏飞程序集&lt;/a&gt; 就有很多功能我们没有。 &lt;/p&gt;

&lt;p&gt;====================华丽的分割线=================&lt;/p&gt;
&lt;p&gt;接下来说一下Winner.Framework.Encrypt，字面意思好理解，就“加密类”常规的加密类网上有很多什么des，aes。&lt;/p&gt;
&lt;p&gt;Winner框架中也有封装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171204135207326-690684286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最常见的Sha1，Md5，RSA，这都没什么稀奇的。这里重点介绍一下SafePassword.cs 和 Hardware.cs&lt;/p&gt;

&lt;p&gt;首先介绍一下SafePassword：&lt;/p&gt;
&lt;p&gt;我们知道大部分的网站用户密码是用MD5做的密文，登录时对比密文是否一致。但是随着这几年MD5的&lt;/p&gt;
&lt;p&gt;撞库，以及专门有人以大硬盘大数据收集Md5，做匹配所以导致MD5做密码并不那么安全。&lt;/p&gt;

&lt;p&gt;我们Winner里面用于用户的密码加密则用的是Hardware这一套，首先Hardware 不是一套单纯的加密算法，而是融入用户的ID主键编号。&lt;/p&gt;
&lt;p&gt;所以，如果有人直接进入数据库，插入一条用户数据从其他账户复制一个密码过来，密文一样，但是登录不了，因为每个用户的主键id&lt;/p&gt;
&lt;p&gt;不一样，则对应的密文不一样，必须有算法才能加密，不然的话及时连接上数据库也没有用。这是其一。&lt;/p&gt;
&lt;p&gt;其二，密码是自带密文校验功能的。就像前面所说的如身份证最后一位就是用来校验身份证号码的真实性，&lt;/p&gt;
&lt;p&gt;其三，密文内部有版本号。如果密码被破解，我们随时可升级密码，并且站内可兼容多版本密文识别。 这是SafePassword。&lt;/p&gt;

&lt;p&gt;再来我们说一下Hardware：&lt;/p&gt;
&lt;p&gt;Hardware叫“硬加密”，这里设计的也很有意思，通常用于做数据库连接字符串的加密，本身这个没什么特别。加密一下，程序中去解密。&lt;/p&gt;
&lt;p&gt;然后我们读取了服务器CPU的序列号做为加密种子，也就是说如果能拿到这个项目的所有文件，首先看到数据库连接字符串是加密的，&lt;/p&gt;
&lt;p&gt;即便有解密程序集，是解不开的。需要项目所在的部署服务器的cpu序列号作为key才能解密，而程序集中是读取的本机cpu序列号。&lt;/p&gt;
&lt;p&gt;即便拿到整个密文，也破解了我们的数据库连接。&lt;/p&gt;

&lt;p&gt;这里有人会说，那要是远程攻破服务器呢？  确实我们之前也吃过类似的亏，后期我们的服务器数据库服务器现在只开放数据库端口，而远程&lt;/p&gt;
&lt;p&gt;必须要走内网，以Oralc举例，等于我们数据库服务器只开放了1521端口，本质上来说我们连1521的端口都没必要向外网开放。只是公司的业务&lt;/p&gt;
&lt;p&gt;特殊，有操作通过程序员单独操作线上数据库的需求，所以对外开放了1521。&lt;/p&gt;

&lt;p&gt;而应用服务器，只开放了80端口，所有服务器 都只能通过内网远程，不提供外网。（当然还有一台神秘的服务器是开放外网，作为跳板连接内网的。）&lt;/p&gt;

&lt;p&gt;这里再说回Hardware，这就意味着我们所有的项目在部署的时候都需要单独通过加密工具群生成加密字符串，并且配置在程序中，而不是每个项目复制粘贴&lt;/p&gt;
&lt;p&gt;就可以部署。&lt;/p&gt;

&lt;p&gt;========================华丽的分割线====================&lt;/p&gt;

&lt;p&gt;关于BLL &amp;amp; Tool就写到这里，有兴趣与我们交流Winner的可以加我们的QQ群261083244 或者扫描左侧二维码加群。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Dec 2017 06:20:00 +0000</pubDate>
<dc:creator>Near_wen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon28/p/7976364.html</dc:identifier>
</item>
</channel>
</rss>