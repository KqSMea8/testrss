<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IOC容器在web容器中初始化过程——（二）深入理解Listener方式装载IOC容器方式 - 毛球和小花</title>
<link>http://www.cnblogs.com/WangYunShuaiBaoLe/p/8135961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WangYunShuaiBaoLe/p/8135961.html</guid>
<description>&lt;p&gt;先来看一下ContextServletListener的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ContextLoaderListener &lt;span&gt;extends&lt;/span&gt; ContextLoader &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletContextListener {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContextLoaderListener() {
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContextLoaderListener(WebApplicationContext context) {
&lt;/span&gt;&lt;span&gt;        super&lt;/span&gt;&lt;span&gt;(context);
    }
&lt;/span&gt;&lt;span&gt;    /**&lt;/span&gt;&lt;span&gt;
    　　这个方法就是用来初始化web application context的&lt;br/&gt;　　服务器启动时，检测到此监听类，系统会调用此方法。
&lt;/span&gt;&lt;span&gt;    */&lt;/span&gt;&lt;span&gt;      
    @Override
&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }   
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    　　服务器关闭时，这个方法调用，用来销毁容器&lt;br/&gt;&lt;/span&gt;    */&lt;br/&gt;&lt;span&gt;　　@Override&lt;/span&gt;&lt;span&gt;    &lt;br/&gt;　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextDestroyed(ServletContextEvent event) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　closeWebApplicationContext(event.getServletContext());&lt;br/&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　　　ContextCleanupListener.cleanupAttributes(event.getServletContext());&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　}&lt;br/&gt;}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;初始化方法contextInitialized里调用了父类ContextLoader的initWebApplicationContext方法&lt;/p&gt;
&lt;p&gt;下面我们看下initWebApplicationContext方法的代码&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             webApplicationContext只能存在一个，若重复会抛出IllegalStateException异常
             从servletContext中获取ApplicationContext容器;如果已经存在,则提示初始化容器失败,检查web.xml文件中是否定义有多个容器加载器
             ServletContext接口的简述：public interface ServletContext
             定义了一系列方法用于与相应的servlet容器通信，比如：获得文件的MIME类型，分派请求，或者是向日志文件写日志等。
             每一个web-app只能有一个ServletContext，web-app可以是一个放置有web application 文件的文件夹，也可以是一个.war的文件。
             ServletContext对象包含在ServletConfig对象之中，ServletConfig对象在servlet初始化时提供servlet对象。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                    &lt;/span&gt;&quot;Cannot initialize context because there is already a root application context present - &quot; +
                            &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;&lt;span&gt;);
        }

        Log logger &lt;/span&gt;= LogFactory.getLog(ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        servletContext.log(&lt;/span&gt;&quot;Initializing Spring root WebApplicationContext&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
            logger.info(&lt;/span&gt;&quot;Root WebApplicationContext: initialization started&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Store context in local instance variable, to guarantee that
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; it is available on ServletContext shutdown.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若WebApplicationContext容器为空，则创建一个WebApplicationContext容器&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; createWebApplicationContext(servletContext);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是可配置的对象，若可配置则进行一系列配置&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableWebApplicationContext) {
                ConfigurableWebApplicationContext cwac &lt;/span&gt;= (ConfigurableWebApplicationContext) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cwac.isActive()) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The context has not yet been refreshed -&amp;gt; provide services such as
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setting the parent context, setting the application context id, etc&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (cwac.getParent() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The context instance was injected without an explicit parent -&amp;gt;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; determine parent for root web application context, if any.&lt;/span&gt;
                        ApplicationContext parent =&lt;span&gt; loadParentContext(servletContext);
                        cwac.setParent(parent);
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置完成后，进行配置和刷新WebApplicationContext&lt;/span&gt;
&lt;span&gt;                    configureAndRefreshWebApplicationContext(cwac, servletContext);
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把容器放入到servletContext中&lt;/span&gt;
            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);

            ClassLoader ccl &lt;/span&gt;=&lt;span&gt; Thread.currentThread().getContextClassLoader();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ccl == ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader()) {
                currentContext &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ccl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                currentContextPerThread.put(ccl, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +&lt;span&gt;
                        WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE &lt;/span&gt;+ &quot;]&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; elapsedTime = System.currentTimeMillis() -&lt;span&gt; startTime;
                logger.info(&lt;/span&gt;&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException ex) {
            logger.error(&lt;/span&gt;&quot;Context initialization failed&quot;&lt;span&gt;, ex);
            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Error err) {
            logger.error(&lt;/span&gt;&quot;Context initialization failed&quot;&lt;span&gt;, err);
            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面的代码可以看出，我们创建好的applicationContext容器会放在servletContext中。servletContext是什么  呢？  &lt;/p&gt;

&lt;p&gt;在web容器中，通过ServletContext为Spring的IOC容器提供宿主环境，对应的建立起一个IOC容器的体系。其中，首先需要建立的是根上下文，这个上下文持有的对象可以有业务对象，数据存取对象，资源，事物管理器等各种中间层对象。在这个上下文的基础上，和web MVC相关还会有一个上下文来保存控制器之类的MVC对象，这样就构成了一个层次化的上下文结构。&lt;/p&gt;


&lt;p&gt;真正创建ApplicationContext的方法是在createWebApplicationContext方法中完成的。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WebApplicationContext createWebApplicationContext(ServletContext sc) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先决定要创建的applicationContext容器的类&lt;/span&gt;
        Class&amp;lt;?&amp;gt; contextClass =&lt;span&gt; determineContextClass(sc);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果获取到的类不是ConfigurableWebApplicationContext类型的,则创建容器失败,所以这里创建的容器必须是ConfigurableWebApplicationContext类型的&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (!ConfigurableWebApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(contextClass)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +
                    &quot;] is not of type [&quot; + ConfigurableWebApplicationContext.&lt;span&gt;class&lt;/span&gt;.getName() + &quot;]&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过BeanUtils的instantiateClass方法创建&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
determineContextClass()方法获取了要创建的容器类
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; Class determineContextClass(ServletContext servletContext) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ApplicationContextException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从web.xml中获取需要初始化的容器的类名&lt;/span&gt;
        String contextClassName =&lt;span&gt; servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果获取到的类名不为空,则创建该容器的Class对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (contextClassName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ClassUtils.forName(contextClassName);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationContextException(
                        &lt;/span&gt;&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;&lt;span&gt;, ex);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则创建默认的容器的Class对象,即:org.springframework.web.context.support.XmlWebApplicationContext
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在创建ContextLoader时,defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);这句代码已经准备好默认的容器类&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            contextClassName &lt;/span&gt;= defaultStrategies.getProperty(WebApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ClassUtils.forName(contextClassName);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationContextException(
                        &lt;/span&gt;&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;&lt;span&gt;, ex);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    该方法首先判断从web.xml文件的初始化参数CONTEXT_CLASS_PARAM(的定义为public static final String CONTEXT_CLASS_PARAM = &quot;contextClass&quot;;)获取的的类名是否存在，如果存在，则容器的Class；否则返回默认的Class。如何获取默认的容器Class，注意看创建contextLoader时的代码注释就知道了。&lt;/p&gt;
&lt;p&gt;    由此看来，spring不仅有默认的applicationContext的容器类，还允许我们自定义applicationContext容器类，不过Spring不建义我们自定义applicationContext容器类。&lt;/p&gt;

&lt;p&gt;   在通过createWebApplicationContext（）方法创建WebApplicationContext容器之后，会调用configureAndRefreshWebApplicationContext（）方法为容器初始化配置文件中定义的bean类，它的实现过程还没搞清楚，下一章节再来做解释（=_=）。&lt;/p&gt;

&lt;p&gt;   最后放上前辈的两张图，帮助大家更容易理解此配置的实现原理。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223697/201712/1223697-20171228152944194-1434321567.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;701&quot;/&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1223697/201712/1223697-20171228152916647-640438100.png&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;579&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 28 Dec 2017 07:30:00 +0000</pubDate>
<dc:creator>毛球和小花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WangYunShuaiBaoLe/p/8135961.html</dc:identifier>
</item>
<item>
<title>IEEE Trans 2009 Stagewise Weak Gradient Pursuits论文学习 - 闪电gogogo</title>
<link>http://www.cnblogs.com/wwf828/p/7770875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwf828/p/7770875.html</guid>
<description>&lt;div readability=&quot;96&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
&lt;span&gt;%压缩感知重构算法测试 
clear all;close all;clc; 
M = 128;%观测值个数 
N = 256;%信号x的长度 
K = 30;%信号x的稀疏度 
Index_K = randperm(N); 
x = zeros(N,1); 
x(Index_K(1:K)) = 5*randn(K,1);%x为K稀疏的，且位置是随机的 
Psi = eye(N);%x本身是稀疏的，定义稀疏矩阵为单位阵x=Psi*theta 
Phi = randn(M,N)/sqrt(M);%测量矩阵为高斯矩阵 
A = Phi * Psi;%传感矩阵  clear all;close all;clc; 
%% 参数配置初始化 
CNT = 1000;%对于每组(K,M,N)，重复迭代次数 
N = 256;%信号x的长度 
Psi = eye(N);%x本身是稀疏的，定义稀疏矩阵为单位阵x=Psi*theta 
alpha_set = 0.1:0.1:1; 
K_set = [4,12,20,28,36];%信号x的稀疏度集合 
Percentage = zeros(N,length(K_set),length(alpha_set));%存储恢复成功概率 
%% 主循环，遍历每组(alpha,K,M,N) 
tic 
for tt = 1:length(alpha_set) 
    alpha = alpha_set(tt); 
    for kk = 1:length(K_set) 
        K = K_set(kk);%本次稀疏度 
        %M没必要全部遍历，每隔5测试一个就可以了 
        M_set=2*K:5:N; 
        PercentageK = zeros(1,length(M_set));%存储此稀疏度K下不同M的恢复成功概率 
        for mm = 1:length(M_set) 
           M = M_set(mm);%本次观测值个数 
           fprintf('alpha=%f,K=%d,M=%d\n',alpha,K,M); 
           P = 0; 
           for cnt = 1:CNT %每个观测值个数均运行CNT次 
                Index_K = randperm(N); 
                x = zeros(N,1); 
                x(Index_K(1:K)) = 5*randn(K,1);%x为K稀疏的，且位置是随机的                 
                Phi = randn(M,N)/sqrt(M);%测量矩阵为高斯矩阵 
                A = Phi * Psi;%传感矩阵 
                y = Phi * x;%得到观测向量y 
                theta = CS_SWOMP(y,A,10,alpha);%恢复重构信号theta 
                x_r = Psi * theta;% x=Psi * theta 
                if norm(x_r-x)&amp;lt;1e-6%如果残差小于1e-6则认为恢复成功 
                    P = P + 1; 
                end 
           end 
           PercentageK(mm) = P/CNT*100;%计算恢复概率 
        end 
        Percentage(1:length(M_set),kk,tt) = PercentageK; 
    end 
end 
toc 
save SWOMPMtoPercentage1000 %运行一次不容易，把变量全部存储下来 
%% 绘图 
for tt = 1:length(alpha_set) 
    S = ['-ks';'-ko';'-kd';'-kv';'-k*']; 
    figure; 
    for kk = 1:length(K_set) 
        K = K_set(kk); 
        M_set=2*K:5:N; 
        L_Mset = length(M_set); 
        plot(M_set,Percentage(1:L_Mset,kk,tt),S(kk,:));%绘出x的恢复信号 
        hold on; 
    end 
    hold off; 
    xlim([0 256]); 
    legend('K=4','K=12','K=20','K=28','K=36'); 
    xlabel('Number of measurements(M)'); 
    ylabel('Percentage recovered'); 
    title(['Percentage of input signals recovered correctly(N=256,alpha=',... 
        num2str(alpha_set(tt)),')(Gaussian)']); 
end 
for kk = 1:length(K_set) 
    K = K_set(kk); 
    M_set=2*K:5:N; 
    L_Mset = length(M_set); 
    S = ['-ks';'-ko';'-kd';'-k*';'-k+';'-kx';'-kv';'-k^';'-k&amp;lt;';'-k&amp;gt;']; 
    figure; 
    for tt = 1:length(alpha_set) 
        plot(M_set,Percentage(1:L_Mset,kk,tt),S(tt,:));%绘出x的恢复信号 
        hold on; 
    end 
    hold off; 
    xlim([0 256]); 
    legend('alpha=0.1','alpha=0.2','alpha=0.3','alpha=0.4','alpha=0.5',... 
        'alpha=0.6','alpha=0.7','alpha=0.8','alpha=0.9','alpha=1.0'); 
    xlabel('Number of measurements(M)'); 
    ylabel('Percentage recovered'); 
    title(['Percentage of input signals recovered correctly(N=256,K=',... 
        num2str(K),')(Gaussian)']);     
end 
y = Phi * x;%得到观测向量y 
%% 恢复重构信号x 
tic 
theta = CS_SWOMP( y,A); 
x_r = Psi * theta;% x=Psi * theta 
toc 
%% 绘图 
figure; 
plot(x_r,'k.-');%绘出x的恢复信号 
hold on; 
plot(x,'r');%绘出原信号x 
hold off; 
legend('Recovery','Original') 
fprintf('\n恢复残差：'); 
norm(x_r-x)%恢复残差
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;本程序在联想ThinkPadE430C笔记本（4GBDDR3内存，i5-3210）上运行共耗时8430.877154秒（时间较长，运行时可以干点别的事情了），程序中将所有数据均通过“save SWOMPMtoPercentage1000”存储了下来，以后可以再对数据进行分析，只需“load SWOMPMtoPercentage1000”即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;程序运行结束会出现10+5=11幅图，前10幅图分别是α分别为0.1、0.2、0.3、0.4、0.5、0.6、0.7、0.8、0.9和1.0时的测量数M与重构成功概率关系曲线（类似于OMP此部分，这里只是对每一个不同的α画出一幅图），后5幅图是分别将稀疏度K为4、12、20、28、32时将十种α取值的测量数M与重构成功概率关系曲线绘制在一起以比较α对重构结果的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是α分别为0.1、0.2、0.3、0.4、0.5、0.6、0.7、0.8、0.9和 1.0时的测量数M与重构成功概率关系曲线：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 以下是稀疏度K为4、12、20、28、32时将十种α取值的测量数M与重构成功概率关系曲线放在一起的五幅图：&lt;/span&gt;&lt;/p&gt;</description>
<pubDate>Thu, 28 Dec 2017 07:29:00 +0000</pubDate>
<dc:creator>闪电gogogo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwf828/p/7770875.html</dc:identifier>
</item>
<item>
<title>Fragment多重嵌套实现电影，影院展示页 - 丁先森</title>
<link>http://www.cnblogs.com/dingxiansen/p/8135888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dingxiansen/p/8135888.html</guid>
<description>&lt;p&gt;转载请标明出处：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dingxiansen/p/8135888.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/dingxiansen/p/8135888.html&lt;/a&gt;&lt;br/&gt;本文出自:&lt;a href=&quot;http://www.cnblogs.com/dingxiansen/&quot; target=&quot;_blank&quot;&gt;丁先森-博客园&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公司以前的app是用H5封的，由于一个模块效果用H5实现出来的效果不太理想，所以boss要求用原生的来实现，高(ni)兴(ma)的脑仁疼，先来看一下要实现的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228135858538-663604343.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;583&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228140020600-1659862450.png&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;584&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228140254709-101711976.png&quot; alt=&quot;&quot; width=&quot;285&quot; height=&quot;584&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后下边的是我实现的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228143314428-776803994.gif&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;667&quot;/&gt;&lt;/p&gt;

&lt;p&gt;视频弄了半天没弄好，尴尬，只有转换成gif图了(clever)，哈哈哈，继续说内部的这个滑动效果呢，我以前的博客也写过，这里附上地址了：&lt;a href=&quot;http://www.cnblogs.com/dingxiansen/p/7649930.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/dingxiansen/p/7649930.html &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下拉刷新还没写，可以直接加刷新的代码，也挺简单的。&lt;/p&gt;
&lt;p&gt;下边有下载地址，现在这些数据都是死数据，但是图片是使用的Picasso加载的网络图片，绑定数据的时候只需要你传入json就可以，对了，然后给你们推荐一个根据json自动生成&lt;/p&gt;
&lt;p&gt;实体类的一个As插件GsonFormat:把json复制进去，然后就可以生成对应的实体类了，没图说啥都白说，看图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228145449366-148506522.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;190&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1058389/201712/1058389-20171228145506225-441913924.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;

&lt;p&gt;format可以格式化，然后点击OK就可以自动生成所需的实体类了。&lt;/p&gt;
&lt;p&gt;在下边介绍使用方法&lt;/p&gt;

&lt;p&gt;原先使用的H5封装的，跳转影院的时候，会重新创建一个，没有原生的那种切换效果，返回的时候竟然还是跳的影片的页面，这种效果用户体验感觉是肯定不好的，好在Android有Fragment可以使用啊，但是又出现问题了，Fragment中还有一个切换热映和即将上映的页面，里边还得要使用Fragment，哎，那就写吧，说一下实现的思路。&lt;/p&gt;
&lt;p&gt;第一、先实现影片和影院的切换，这里使用的是&lt;span&gt;RadioGroup&lt;/span&gt;+Fragment来实现的 ，这个效果像以前的QQ的一个效果，点击切换&lt;/p&gt;
&lt;p&gt;主要是使用的RadioGroup的&lt;span&gt;setOnCheckedChangeListener来控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主要代码实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
rg_movie.setOnCheckedChangeListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RadioGroup.OnCheckedChangeListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onCheckedChanged(RadioGroup group, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; checkedId) {
                ft &lt;/span&gt;=&lt;span&gt; fm.beginTransaction();
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (checkedId) {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.rb_movie_film:
                        ft.hide(cinemaFragment).show(filmFragment);
                        ft.commit();
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.rb_movie_cinema:
                        ft.hide(filmFragment).show(cinemaFragment);
                        ft.commit();
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二、内部的Fragment实现，点击影片之后，显示的是正在热映和即将热映&lt;/p&gt;
&lt;p&gt;内部的这个呢是我封装的一个类库，导入这个类库就可以使用，主要是怎么在fragment中添加进去，代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initView(View v) {
        cttl_film_tab &lt;/span&gt;=&lt;span&gt; v.findViewById(R.id.cttl_film_tab);
        vp_film_viewpager &lt;/span&gt;=&lt;span&gt; v.findViewById(R.id.vp_film_viewpager);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initTab(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Fragment&amp;gt;&lt;span&gt; fragments) {
        titles &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;正在热映&quot;, &quot;即将热映&quot;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; titles.length; i++&lt;span&gt;) {
            fragments.add(MyFragment.newInstance());
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要使用getChildFragmentManager()
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为InputAddPhotoFragment属于我当期的Fragment，所以需要用我当前Fragment的FragmentManager去管理，而不是使用Activity的FragmentManager去管理。使用到的获取方法 就是getChildFragmetManager()。&lt;/span&gt;
        vp_film_viewpager.setAdapter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FragmentPagerAdapter(getChildFragmentManager()) {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Fragment getItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fragments.get(position);
            }
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; titles.length;
            }
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CharSequence getPageTitle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; titles[position];
            }
        });
        cttl_film_tab.setupWithViewPager(vp_film_viewpager);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实现setAdapter的时候注意，new FragmentPagerAdapter(getChildFragmentManager())这里要注意，使用的是getChildFragmentManager而不是getSupportFragmentManager&lt;/p&gt;
&lt;p&gt;来说一下原因：&lt;/p&gt;
&lt;p&gt;getFragmentManager()和getSupportFragmentManager()的区别很容易理解，android的v4扩展包中的FragmentActivity中获取FragmentManager使用的就是getSupportFragmentManager()，android.app中获取管理类的方法就是getFragmentManager()。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后getChildFragmentManager()和getFragmentManager()属于两个不同的类，前者属于Fragment，看源码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
        * Return a private FragmentManager for placing and managing Fragments 
        * inside of this Fragment. 
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
       &lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FragmentManager getChildFragmentManager() {  
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mChildFragmentManager == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
               instantiateChildFragmentManager();  
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState &amp;gt;=&lt;span&gt; RESUMED) {  
                   mChildFragmentManager.dispatchResume();  
               } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mState &amp;gt;=&lt;span&gt; STARTED) {  
                   mChildFragmentManager.dispatchStart();  
               } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mState &amp;gt;=&lt;span&gt; ACTIVITY_CREATED) {  
                   mChildFragmentManager.dispatchActivityCreated();  
               } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (mState &amp;gt;=&lt;span&gt; CREATED) {  
                   mChildFragmentManager.dispatchCreate();  
               }  
           }  
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mChildFragmentManager;  
       }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;android官方对它的解释是，返回一个FragmentManager为了设置和管理当前Fragment内部的Fragment的们。举个例子，在我的Fragment布局中添加了一个Fragment容器，我的目的是在Fragment执行的过程中动态的添加一个Fragment，并且对他进行操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为InputAddPhotoFragment属于我当期的Fragment，所以需要用我当前Fragment的FragmentManager去管理，而不是使用Activity的FragmentManager去管理。使用到的获取方法 就是getChildFragmetManager()。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   最后我们来看一下getFragmentManager()的源码，它是属于FragmentActivity，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
         * Return the FragmentManager for interacting with fragments associated 
         * with this activity. 
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FragmentManager getSupportFragmentManager() {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mFragments;  
        }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看它的官方注释，是为了获取能管理和当前Activity有关联的Fragment的FragmentManager。&lt;span&gt;总结，需要管理相互独立的并且隶属于Activity的Fragment使用FragmentManager（），而在Fragment中动态的添加Fragment要使用getChildFragmetManager（）来管理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;说的再多，看看代码就明白了，项目下载地址：链接：&lt;a href=&quot;https://pan.baidu.com/s/1nvL0BJN&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1nvL0BJN&lt;/a&gt; 密码：frbq (其实可烦CSDN了，非要什么分，一般的哪有那么多分，有的还是诈分的，真的气人)&lt;/p&gt;

</description>
<pubDate>Thu, 28 Dec 2017 07:20:00 +0000</pubDate>
<dc:creator>丁先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dingxiansen/p/8135888.html</dc:identifier>
</item>
<item>
<title>老生常谈之Block - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/8135790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/8135790.html</guid>
<description>&lt;p&gt;前面有一篇介绍&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/4656440.html&quot;&gt;Block的博客&lt;/a&gt;，主要介绍了Block的简单使用技巧。这篇博客主要更加深入地了解一下Block。包括：Block的实现、__Block的原理以及Block的存储域三方面。&lt;/p&gt;
&lt;h4 id=&quot;block的实现&quot;&gt;Block的实现&lt;/h4&gt;
&lt;p&gt;首先我们使用Xcode创建一个Project,点击File--&amp;gt;New--&amp;gt;Project，选择macOS中Application的Command Line Tool，然后设置Project Name即可。你好发现这个工程值包含了一个main.m文件，然后我们做如下更改（更改后的代码如下）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#import &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是我们最常见的C代码，导入stdio.h，然后打印出来Hello World。接下来我们写一个最简单的block，没有返回值，没有传入参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#import &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (^blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ^{
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello Worldddd&quot;&lt;/span&gt;);
    };
    blk();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出来的结果相当于调用了blk输出的结果。接下来我们在item中跳转到main.m所在文件夹然后执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;sehll&quot;&gt;
&lt;code&gt;clang -rewrite-objc main.m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现在当前文件夹下生成了一个.cpp文件，它是经过clang编译器编译之后的文件，打开之后里面大概有5百多行，其实我们看下面的这些代码就足够了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 {
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl impl;
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0* Desc;
  __main_block_impl_0(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *fp, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 *desc, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
&lt;span class=&quot;ot&quot;&gt;#ifndef BLOCK_IMPL&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define BLOCK_IMPL&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *isa;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Flags;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Reserved;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *FuncPtr;
};
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_func_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *__cself) {

        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello Worldddd&quot;&lt;/span&gt;);
    }

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0)};
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)())&amp;amp;__main_block_impl_0((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA));
    ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中包含三个结构体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;__main_block_impl_0、__block_impl、__main_block_desc_0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;__main_block_func_0、main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main就是我们写的main函数。&lt;br/&gt;至此，你能知道的就是：Block看上去很特别，其实就是作为及其普通的C语言源代码来处理的。编译器会把Block的源代码转换成一般的C语言编译器能处理的源代码，并作为极为普通的C语言源代码被编译。&lt;br/&gt;接下来对编译的内容来一个分解，首先是&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;^{printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello Worldddd&quot;&lt;/span&gt;)};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变换后的源代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_func_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *__cself) {

        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello Worldddd&quot;&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是现在变成了一个静态方法，其命名方式为：Block所属的函数名(main)和该Block语法在函数出现的顺序值(0)来给经过clang变换的函数命名。该方法的参数相当于我们在OC里面的指向自身的self。我们看一下该参数的声明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *__cself&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现它其实是一个结构体，该结构体的声明如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 {
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl impl;
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0* Desc;
  __main_block_impl_0(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *fp, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 *desc, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该结构体中你会发现里面有一个构造函数，你忽略构造函数，会发现该结构体就很简单了，只是包含了impl和 Desc两个属性变量。其中impl也是一个结构体，它的结构如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *isa;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Flags;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Reserved;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *FuncPtr;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从属性变量的名字我们可以猜测出该结构体各个属性的含义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;isa：isa指针，指向父类的指针。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Flags：一个标记&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Reserved：预留区域，用于以后的使用。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;FuncPtr：这个很重要，是一个函数指针。后面会详细说明它的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二个变量是Desc，也是一个结构体：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0)};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结构体就比较简单了，一个预留位，一个是指代该Block大小的属性，后面又包含了一个该实例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;__main_block_desc_0_DATA = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0)};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;预留位为0，大小为传入结构体的大小。接下来就是很重要的构造函数了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt; __main_block_impl_0(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *fp, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 *desc, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的&amp;amp;_NSConcreteStackBlock用于初始化impl的isa指针；flags为0；FuncPtr是构造函数传过来的fp函数指针；Desc为一个block的描述。到这里三个结构体和一个函数就介绍完了。接下来看一下main函数里面上述构造函数是如何调用的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)())&amp;amp;__main_block_impl_0((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感觉好复杂，我们先做一个转换：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 tmpeImpl = __main_block_impl_0((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA)

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *blk = &amp;amp;tmpeImpl;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说把结构体的实例的指针赋值给blk。接下来再看一下构造函数的的初始化，其实赋值就变成了这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;impl.isa = &amp;amp;_NSConcreteStackBLock;
impl.Flags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
impl.FuncPtr = __main_block_func_0;
Desc = &amp;amp;__main_block_desc_0_DATA;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在在看一下调用block的那句代码：&lt;/p&gt;

&lt;p&gt;转换成了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这个转换不是太明白，但是知道他的作用就是把blk当做参数传进去，调用的FuncPtr所指向的函数，也就是__ block _ block _ func _ 0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这里就大体了解了Block的实现，其实就是C的几个结构体和方法，经过赋值和调用，进而实现了Block。&lt;br/&gt;另外Block其实实质上也是OC的对象。&lt;/p&gt;
&lt;h4 id=&quot;block的原理-先看一个简单的例子&quot;&gt;__Block的原理&lt;br/&gt;先看一个简单的例子：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#import &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (^blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ^{
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello World,%d&quot;&lt;/span&gt;,i);
    };
    blk();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用clang编译后是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 {
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl impl;
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0* Desc;
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
  __main_block_impl_0(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *fp, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 *desc, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) : i(_i) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_func_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *__cself) {
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = __cself-&amp;gt;i; &lt;span class=&quot;co&quot;&gt;// bound by copy&lt;/span&gt;

        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello World,%d&quot;&lt;/span&gt;,i);
    }

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)())&amp;amp;__main_block_impl_0((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, i));
    ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是在main函数调用的时候把i传到了构造函数里，然后通过i(_i)对结构体的属性变量i赋值，i变量现在已经成为了结构体的一个树形变量。在构造函数执行时把i赋值。在 &lt;strong&gt;main _ block_func _ 0里面通过&lt;/strong&gt; cself调用，这个变量实际是在声明block时，被复制到了结构体变量i，因此不会影响变量i的值。当我们尝试在Block中去修改时，你会得到如下错误：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;Variable is not assignable(missing __block type specifier)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示我们加上__block,接下来我们将源代码做如下修改：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    __block &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (^blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ^{
        i = i + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello World,%d&quot;&lt;/span&gt;,i);
    };
    blk();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一下你会发现你成功对i的值进行了修改！用clang进行编译，结果如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __Block_byref_i_0 {
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *__isa;
__Block_byref_i_0 *__forwarding;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; __flags;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; __size;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
};

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 {
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __block_impl impl;
  &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0* Desc;
  __Block_byref_i_0 *i; &lt;span class=&quot;co&quot;&gt;// by ref&lt;/span&gt;
  __main_block_impl_0(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *fp, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 *desc, __Block_byref_i_0 *_i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) : i(_i-&amp;gt;__forwarding) {
    impl.isa = &amp;amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_func_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0 *__cself) {
  __Block_byref_i_0 *i = __cself-&amp;gt;i; &lt;span class=&quot;co&quot;&gt;// bound by ref&lt;/span&gt;

        (i-&amp;gt;__forwarding-&amp;gt;i) = (i-&amp;gt;__forwarding-&amp;gt;i) + &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Hello World,%d&quot;&lt;/span&gt;,(i-&amp;gt;__forwarding-&amp;gt;i));
    }
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_copy_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*dst, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*src) {_Block_object_assign((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)&amp;amp;dst-&amp;gt;i, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)src-&amp;gt;i, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*BLOCK_FIELD_IS_BYREF*/&lt;/span&gt;);}

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __main_block_dispose_0(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*src) {_Block_object_dispose((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)src-&amp;gt;i, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/*BLOCK_FIELD_IS_BYREF*/&lt;/span&gt;);}

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*copy)(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*);
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*dispose)(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0*);
} __main_block_desc_0_DATA = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; * argv[]) {
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,(__Block_byref_i_0 *)&amp;amp;i, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(__Block_byref_i_0), &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;};
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*blk)(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;) = ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)())&amp;amp;__main_block_impl_0((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *)__main_block_func_0, &amp;amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;amp;i, &lt;span class=&quot;dv&quot;&gt;570425344&lt;/span&gt;));
    ((&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*)(__block_impl *))((__block_impl *)blk)-&amp;gt;FuncPtr)((__block_impl *)blk);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你会发现多了一个__ Block _ byref &lt;em&gt;i&lt;/em&gt; 0的结构体，然后多了两个copy和dispose函数。&lt;br/&gt;看一下main函数里面的i，此时也不再是一个简单的基本类型int，而是一个初始化的 __ Block _ byref _ i _ 0的结构体，该结构体有个属性变量为i，然后把3赋值给了那个属性变量。该结构体还有一个指向自己的指针 __ forwarding，它被赋值为i的地址。&lt;br/&gt;现在 __ main _ block _ func _ 0在实现中使用了指向该变量的指针，所以达到了修改外部变量的作用。&lt;/p&gt;
&lt;h4 id=&quot;block的存储域&quot;&gt;Block的存储域&lt;/h4&gt;
&lt;p&gt;Block的存储域有以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;_ NSConcreteStackBlock,该类的对象Block设置在栈上&lt;/li&gt;
&lt;li&gt;_ NSConcreteGlobalBlock,该类的Block设置在程序的数据区(.data)域中。&lt;/li&gt;
&lt;li&gt;_ NSConcreteMallocBlcok,该类的Block设置在堆上&lt;br/&gt;下面这张图展示了Block的存储域:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/block_save_area.jpeg&quot; alt=&quot;Block的存储域&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们前面看到的都是在Stack的Block，但是你可以在OC工程中打印一下你声明的block的isa，你会发现它其实是Malloc的block，也就是在堆上的block。如图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/malloc_block.png&quot; alt=&quot;堆上的block&quot;/&gt;&lt;br/&gt;还有一种情况是Global的block：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/global_block.png&quot; alt=&quot;global的block&quot;/&gt;&lt;br/&gt;在ARC中，只有NSConcreteGlobalBlock和NSConcreteMallockBlock两种类型的block。因为我们最简单的block在工程中打印出来的都是MallocBlock。也许是因为苹果把对象都放到了堆管理，而Block也是对象，所以也放到了堆上。&lt;/p&gt;
&lt;p&gt;此时我们也许会有个疑问：Block超出了变量作用域为什么还能存在呢？&lt;br/&gt;对于Global的Block，变量作用域之外也可以通过指针安全使用，但是设置在栈上的就比较尴尬了，作用域结束后，Block也会 被废弃。为了使Block超出变量作用域还可以存在，Block提供了将Block和 __ block变量从栈上复制到堆上的方法来解决这个问题。这样就算栈上的废弃，堆上的Block还可以继续存在。&lt;/p&gt;
&lt;p&gt;看一下对Block进行复制，结果如何：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/block/block_copy.jpeg&quot; alt=&quot;Block进行copy操作&quot;/&gt;&lt;br/&gt;如果对Block进行了copy操作，__ block的变量也会受到影响，当 __ block的变量配置在栈上，复制之后它将从栈复制到堆上并被Blcok持有，如果是堆上的 __ block变量，Blcok复制之后该变量被Block持有。&lt;br/&gt;如果两个block（block1,block2）同时都是用 __ block变量，如果block1被复制到了堆上，那么 __ block变量也会在block1复制到堆的同时复制到堆上，当block2再是用到 __ block变量的时候，只是增加堆上 __ block变量的引用计数，不会再次复制。如果堆上的block1和block2被废弃了，那么它所是用的 __ block变量也就被释放了（如果block1被废弃，而block2没有被废弃，那么 __ block变量的引用计数-1，直到最后使用 __ block变量的block被废弃的同时，堆上的 __ block也会被释放）。&lt;br/&gt;理解了上面刚才说的复制之后，现在回过来思考另一个问题： __ block的时候转换的结构体中的 __ forwarding指针有什么作用呢？（下面代码中的 __ forwarding）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __Block_byref_i_0 {
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *__isa;
__Block_byref_i_0 *__forwarding;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; __flags;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; __size;
 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实是这样的：栈上的 __ block变量用结构体实例在 __ block变量从栈复制到堆上的时候，会将成员变量 __ forwarding的值替换为复制目标堆上的 __ block变量用结构体实例的地址。通过该操作之后，无论是在Block语法中、Block语法外使用 __ block变量，还是 __ block变量配置在栈上或者堆上，都可以顺利地访问同一个 __ block变量。&lt;/p&gt;
&lt;p&gt;以上便是对block的进一步介绍，主要参考了《Objective-C高级编程 iOS与OS X多线程和内存管理》一书。&lt;/p&gt;
&lt;p&gt;转载请标明来源：&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/8135790.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhanggui/p/8135790.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 07:07:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/8135790.html</dc:identifier>
</item>
<item>
<title>前端MVC Vue2学习总结（三）——模板语法、过滤器、计算属性、观察者、Class 与 Style 绑定 - 张果</title>
<link>http://www.cnblogs.com/best/p/8135735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/best/p/8135735.html</guid>
<description>&lt;p&gt;Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。&lt;/p&gt;
&lt;p&gt;在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。&lt;/p&gt;
&lt;p&gt;如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染（render）函数，使用可选的 JSX 语法。&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;1.1、插值&lt;/h2&gt;
&lt;h3 id=&quot;2&quot;&gt;1.1.1、文本&lt;/h3&gt;
&lt;p&gt;数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Message: {{ msg }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新&lt;/p&gt;
&lt;p&gt;通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;This will never change: {{ msg }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;v-text指令：&lt;/strong&gt;更新元素的 textContent。如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 和下面的一样 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-once&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3 &lt;/span&gt;&lt;span&gt;v-text&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    msg:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227140427847-1900887623.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;1.1.2、纯HTML&lt;/h3&gt;
&lt;p&gt;双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-html&lt;/span&gt;&lt;span&gt;=&quot;rawHtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元&lt;/p&gt;
&lt;p&gt;&lt;span&gt;站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 &lt;strong&gt;XSS&lt;/strong&gt; 攻击&lt;/span&gt;。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容插值&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;textarea &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt; rows&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; cols&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;textarea&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-html&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    msg:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;span style='color:blue;font-weight:bold'&amp;gt;zhangguo&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227141355456-726604285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;1.1.3、属性&lt;/h3&gt;
&lt;p&gt;Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:id&lt;/span&gt;&lt;span&gt;=&quot;dynamicId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-bind:disabled&lt;/span&gt;&lt;span&gt;=&quot;someDynamicCondition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Button&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;someDynamicCondition为true是disabled出现，为false时移除disabled&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;disabled=!disabled&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;反转{{disabled}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-bind:disabled&lt;/span&gt;&lt;span&gt;=&quot;disabled&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    disabled:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227142620081-1843396523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改disabled的值为false&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227142710706-71934641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;1.1.4、javascript表达式&lt;/h3&gt;
&lt;p&gt;迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:id&lt;/span&gt;&lt;span&gt;=&quot;'list-' + id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，&lt;span&gt;每个绑定都只能包含&lt;strong&gt;单个&lt;/strong&gt;表达式&lt;/span&gt;，所以下面的例子都不会生效，&lt;span&gt;&lt;strong&gt;不需要在属性前使用this&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{{ var a = 1 }}     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这是语句，不是表达式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
{{ if (ok) { return message } }}     &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 流控制也不会生效，请使用三元表达式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量&lt;/p&gt;
&lt;h2 id=&quot;6&quot;&gt;1.2、指令&lt;/h2&gt;
&lt;p&gt;指令（Directives）是带有 v- 前缀的特殊属性。指令属性的值预期是单一 JavaScript 表达式。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;seen&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Now you see me&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里， v-if 指令将根据表达式 seen 的值的真假来移除/插入元素&lt;/p&gt;
&lt;p&gt;常用的指令有：&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;isShow=!isShow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;反转{{isShow}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-if&lt;/span&gt;&lt;span&gt;=&quot;isShow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交v-if&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; v-show&lt;/span&gt;&lt;span&gt;=&quot;isShow&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提交v-show&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                等级A-C：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;type&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;type === 'A'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                A优秀
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-else-if&lt;/span&gt;&lt;span&gt;=&quot;type === 'B'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                B良好
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-else-if&lt;/span&gt;&lt;span&gt;=&quot;type === 'C'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                C及格
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                D其它
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    isShow: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227151746816-1391299400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227151829831-1445401869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事件处理指令非常强大，说明如下：&lt;/p&gt;
&lt;p id=&quot;v-on&quot; data-scroll-id=&quot;v-on&quot;&gt;&lt;strong&gt;指令&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li&gt;
&lt;p&gt;缩写：&lt;code&gt;@&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;预期：&lt;code&gt;Function | Inline Statement | Object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;code&gt;event&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修饰符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.stop&lt;/code&gt; - 调用 &lt;code&gt;event.stopPropagation()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.prevent&lt;/code&gt; - 调用 &lt;code&gt;event.preventDefault()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.capture&lt;/code&gt; - 添加事件侦听器时使用 capture 模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.self&lt;/code&gt; - 只当事件是从侦听器绑定的元素本身触发时才触发回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.{keyCode | keyAlias}&lt;/code&gt; - 只当事件是从特定键触发时才触发回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.native&lt;/code&gt; - 监听组件根元素的原生事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.once&lt;/code&gt; - 只触发一次回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.left&lt;/code&gt; - (2.2.0) 只当点击鼠标左键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.right&lt;/code&gt; - (2.2.0) 只当点击鼠标右键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.middle&lt;/code&gt; - (2.2.0) 只当点击鼠标中键时触发。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.passive&lt;/code&gt; - (2.3.0) 以 &lt;code&gt;{ passive: true }&lt;/code&gt; 模式添加侦听器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;2.4.0&lt;/code&gt; 开始，&lt;code&gt;v-on&lt;/code&gt; 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。&lt;/p&gt;
&lt;p&gt;用在普通元素上时，只能监听 原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。&lt;/p&gt;
&lt;p&gt;在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 &lt;code&gt;$event&lt;/code&gt; 属性：&lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方法处理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对象语法 (2.4.0+) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on&lt;/span&gt;&lt;span&gt;=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 内联语句 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThat('hello', $event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 停止冒泡 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为，没有表达式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;@submit.prevent&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  串联修饰符 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键别名 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.enter&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键代码 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.13&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 点击回调只会触发一次 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click.once&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;@my-event&lt;/span&gt;&lt;span&gt;=&quot;handleThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 内联语句 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;@my-event&lt;/span&gt;&lt;span&gt;=&quot;handleThis(123, $event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 组件中的原生事件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;@click.native&lt;/span&gt;&lt;span&gt;=&quot;onClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                等级A-C：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;type&quot;&lt;/span&gt;&lt;span&gt; @keyup.13&lt;/span&gt;&lt;span&gt;=&quot;submit_click($event)&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    isShow: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                },
                methods: {
                    submit_click: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(confirm(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确证要提交吗？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
                            console.log(e);
                        }
                    }
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227152513331-703572754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;7&quot;&gt;1.2.1、参数&lt;/h3&gt;
&lt;p&gt;一些指令能接受一个“参数”，在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-bind:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定&lt;/p&gt;
&lt;p&gt;v-on 指令用于监听 DOM 事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doSomething&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;8&quot;&gt;1.2.2、修饰符&lt;/h3&gt;
&lt;p&gt;修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;v-on:submit.prevent&lt;/span&gt;&lt;span&gt;=&quot;onSubmit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;.stop - 调用 event.stopPropagation()。&lt;/li&gt;
&lt;li&gt;.prevent - 调用 event.preventDefault()。&lt;/li&gt;
&lt;li&gt;.capture - 添加事件侦听器时使用 capture 模式。&lt;/li&gt;
&lt;li&gt;.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。&lt;/li&gt;
&lt;li&gt;.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。&lt;/li&gt;
&lt;li&gt;.native - 监听组件根元素的原生事件。&lt;/li&gt;
&lt;li&gt;.once - 只触发一次回调。&lt;/li&gt;
&lt;li&gt;.left - (2.2.0) 只当点击鼠标左键时触发。&lt;/li&gt;
&lt;li&gt;.right - (2.2.0) 只当点击鼠标右键时触发。&lt;/li&gt;
&lt;li&gt;.middle - (2.2.0) 只当点击鼠标中键时触发。&lt;/li&gt;
&lt;li&gt;.passive - (2.3.0) 以 { passive: true } 模式添加侦听器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方法处理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对象语法 (2.4.0+) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on&lt;/span&gt;&lt;span&gt;=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 内联语句 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThat('hello', $event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 停止冒泡 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为，没有表达式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;@submit.prevent&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  串联修饰符 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键别名 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.enter&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键代码 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.13&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 点击回调只会触发一次 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click.once&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;9&quot;&gt;1.3、过滤器&lt;/h2&gt;
&lt;p&gt;Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：&lt;span&gt;mustache 插值和 v-bind 表达式&lt;/span&gt;。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{{ message | capitalize }}     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; in mustaches &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:id&lt;/span&gt;&lt;span&gt;=&quot;rawId | formatId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; in v-bind &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vue 2.x 中，过滤器只能在 mustache 绑定和 v-bind 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用计算属性&lt;/p&gt;
&lt;p&gt;过滤器函数总接受表达式的值作为第一个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  filters: {
    capitalize: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (value) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!value) &lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;
      value &lt;/span&gt;=&lt;span&gt; value.toString()
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.charAt(0).toUpperCase() + value.slice(1&lt;span&gt;)
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过滤器可以串联：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{{ message | filterA | filterB }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过滤器是 JavaScript 函数，因此可以接受参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{{ message | filterA('arg1', arg2) }}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，字符串 'arg1' 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在vue1中有一些内置的过滤器，而vue2中需要自定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vue2模板语法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg | toUpper | toLower(&quot; zhuhai&quot;)}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-bind:title&lt;/span&gt;&lt;span&gt;=&quot; 'Hello Filter!' | toUpper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg | toUpper | toLower}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局过滤器&lt;/span&gt;
&lt;span&gt;            Vue.filter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toUpper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.toUpperCase();
            });
            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    msg:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;China&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                filters:{  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带参数的当前实例过滤器&lt;/span&gt;
&lt;span&gt;                    toLower:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value,add){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value.toLowerCase()&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;add;
                    }
                }
            });
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以使用全局过滤器&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    msg:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171228091246081-1217901473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;10&quot;&gt;1.4、缩写&lt;/h2&gt;
&lt;p&gt;v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 SPA 时，v- 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写：&lt;/p&gt;
&lt;h3 id=&quot;11&quot;&gt;1.4.1、v-bind 缩写&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-bind:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 完整语法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;:href&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;12&quot;&gt;1.4.2、v-on 缩写&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doSomething&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 完整语法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;doSomething&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/syntax.html&quot; target=&quot;_blank&quot;&gt;官方原文&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;计算属性&quot;&gt;2.1、计算属性&lt;/h2&gt;
&lt;p&gt;在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  {{ message.split('').reverse().join('') }}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，模板不再简单和清晰。在实现反向显示 &lt;code&gt;message&lt;/code&gt; 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。&lt;/p&gt;
&lt;p&gt;这就是为什么任何复杂逻辑，你都应当使用计算属性。&lt;/p&gt;
&lt;h3&gt;2.1.1、基础例子&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Original message: &quot;{{ message }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#example'&lt;span&gt;,
  data: {
    message: &lt;/span&gt;'Hello'&lt;span&gt;
  },
  computed: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a computed getter&lt;/span&gt;
    reversedMessage: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `this` points to the vm instance&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message.split('').reverse().join(''&lt;span&gt;)
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div id=&quot;example&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;Original message: &quot;Hello&quot;&lt;/p&gt;
&lt;p&gt;Computed reversed message: &quot;olleH&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里我们声明了一个计算属性 &lt;code&gt;reversedMessage&lt;/code&gt; 。我们提供的函数将用作属性&lt;code&gt;vm.reversedMessage&lt;/code&gt; 的 getter 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(vm.reversedMessage) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'olleH'&lt;/span&gt;
vm.message = 'Goodbye'&lt;span&gt;
console.log(vm.reversedMessage) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; 'eybdooG'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以打开浏览器的控制台，修改 vm 。 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的值始终取决于&lt;code&gt;vm.message&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;你可以像绑定普通属性一样在模板中绑定计算属性。 Vue 知道 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 依赖于 &lt;code&gt;vm.message&lt;/code&gt; ，因此当 &lt;code&gt;vm.message&lt;/code&gt; 发生改变时，依赖于 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 的绑定也会更新。而且最妙的是我们是声明式地创建这种依赖关系：计算属性的 getter 是干净无副作用的，因此也是易于测试和理解的。&lt;/p&gt;
&lt;h3 id=&quot;计算缓存-vs-Methods&quot;&gt;2.1.2、计算缓存 vs Methods&lt;/h3&gt;
&lt;p&gt;你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Reversed message: &quot;{{ reverseMessage() }}&quot;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in component&lt;/span&gt;
&lt;span&gt;methods: {
  reverseMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message.split('').reverse().join(''&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 &lt;code&gt;message&lt;/code&gt; 没有发生改变，多次访问 &lt;code&gt;reversedMessage&lt;/code&gt; 计算属性会立即返回之前的计算结果，而不必再次执行函数。&lt;/p&gt;
&lt;p&gt;这也同样意味着如下计算属性将不会更新，因为 &lt;code&gt;Date.now()&lt;/code&gt; 不是响应式依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;computed: {
  now: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Date.now()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相比而言，每当重新渲染的时候，method 调用总会执行函数。&lt;/p&gt;
&lt;p&gt;我们为什么需要缓存？假设我们有一个重要的计算属性 A ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter ！如果你不希望有缓存，请用 method 替代。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算属性只能当作属性用，不能带参数，有缓存，效率高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法可以直接调用，可带参数，没有缓存，每次调用都会执行，效率不如计算属性高。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算属性-vs-Watched-Property&quot;&gt;2.1.3、计算属性 vs Watched Property&lt;/h3&gt;
&lt;p&gt;Vue.js 提供了一个方法 &lt;code&gt;$watch&lt;/code&gt; ，它用于观察 Vue 实例上的数据变动。当一些数据需要根据其它数据变化时， &lt;code&gt;$watch&lt;/code&gt; 很诱人 —— 特别是如果你来自 AngularJS 。不过，通常更好的办法是使用计算属性而不是一个命令式的 &lt;code&gt;$watch&lt;/code&gt; 回调。思考下面例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;demo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ fullName }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#demo'&lt;span&gt;,
  data: {
    firstName: &lt;/span&gt;'Foo'&lt;span&gt;,
    lastName: &lt;/span&gt;'Bar'&lt;span&gt;,
    fullName: &lt;/span&gt;'Foo Bar'&lt;span&gt;
  },
  watch: {
    firstName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fullName = val + ' ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
    },
    lastName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (val) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fullName = &lt;span&gt;this&lt;/span&gt;.firstName + ' ' +&lt;span&gt; val
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面代码是命令式的和重复的。跟计算属性对比：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#demo'&lt;span&gt;,
  data: {
    firstName: &lt;/span&gt;'Foo'&lt;span&gt;,
    lastName: &lt;/span&gt;'Bar'&lt;span&gt;
  },
  computed: {
    fullName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.firstName + ' ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
    }
  }
})&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样更好，不是吗？&lt;/p&gt;
&lt;h3 id=&quot;计算-setter&quot;&gt;2.1.4、计算 setter&lt;/h3&gt;
&lt;p&gt;计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;computed: {
  fullName: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getter&lt;/span&gt;
    get: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.firstName + ' ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lastName
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setter&lt;/span&gt;
    set: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newValue) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; names = newValue.split(' '&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.firstName = names[0&lt;span&gt;]
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lastName = names[names.length - 1&lt;span&gt;]
    }
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;现在在运行 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; 时， setter 会被调用， &lt;code&gt;vm.firstName&lt;/code&gt; 和&lt;code&gt;vm.lastName&lt;/code&gt; 也会被对应更新。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;计算属性和观察者&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            姓：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;x&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt; 名：
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;m&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt; 姓名：
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;xm&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    x: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                    m: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                },
                computed:{
                    xm:{
                        get:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.m;
                        },
                        set:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;value.substring(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;value.substring(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                        }
                    }
                }
            });
            app1.xm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171228095303972-178270128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;观察-Watchers&quot;&gt;2.2、观察 Watchers&lt;/h2&gt;
&lt;p&gt;虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 &lt;code&gt;watch&lt;/code&gt; 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或昂贵操作时，这是很有用的。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;watch-example&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    Ask a yes/no question:
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;question&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ answer }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Since there is already a rich ecosystem of ajax libraries    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; and collections of general-purpose utility methods, Vue core &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; is able to remain small by not reinventing them. This also   &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; gives you the freedom to just use what you're familiar with. &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; watchExampleVM &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#watch-example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  data: {
    question: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
    answer: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I cannot give you an answer until you ask a question!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  },
  watch: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 question 发生改变，这个函数就会运行&lt;/span&gt;
&lt;span&gt;    question: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newQuestion) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Waiting for you to stop typing...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAnswer()
    }
  },
  methods: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.debounce 是一个通过 lodash 限制操作频率的函数。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个例子中，我们希望限制访问yesno.wtf/api的频率&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ajax请求直到用户输入完毕才会发出&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学习更多关于 _.debounce function (and its cousin&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.throttle), 参考: https://lodash.com/docs#debounce&lt;/span&gt;
&lt;span&gt;    getAnswer: _.debounce(
      &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.question.indexOf(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
          vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Questions usually contain a question mark. ;-)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
          &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
        vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Thinking...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        axios.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://yesno.wtf/api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (response) {
            vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _.capitalize(response.data.answer)
          })
          .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
            vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Error! Could not reach the API. &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; error
          })
      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是我们为用户停止输入等待的毫秒数&lt;/span&gt;
      &lt;span&gt;500&lt;/span&gt;&lt;span&gt;
    )
  }
})
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;

&lt;p&gt;在这个示例中，使用 &lt;code&gt;watch&lt;/code&gt; 选项允许我们执行异步操作（访问一个 API），限制我们执行该操作的频率，并直到我们得到最终结果时，才设置中间状态。这是计算属性无法做到的。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;watch&lt;/code&gt; 选项之外，您还可以使用  &lt;a href=&quot;http://cn.vuejs.org/v2/api/#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt; 命令。&lt;/p&gt;
&lt;p&gt;官方帮助： &lt;a href=&quot;http://vuejs.org/guide/computed.html&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://vuejs.org/guide/computed.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;南方机器人&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                请输入您的问题:
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;question&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ answer }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;v-bind:src&lt;/span&gt;&lt;span&gt;=&quot;src&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/lodash@4.13.1/lodash.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://unpkg.com/axios@0.12.0/dist/axios.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; watchExampleVM &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                data: {
                    question: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
                    answer: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;您问我一个问题我会给您一个答案！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    url:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                },
                watch: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 question 发生改变，这个函数就会运行&lt;/span&gt;
&lt;span&gt;                    question: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newQuestion) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;等待您的输入...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAnswer()
                    }
                },
                methods: {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.debounce 是一个通过 lodash 限制操作频率的函数。&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这个例子中，我们希望限制访问yesno.wtf/api的频率&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ajax请求直到用户输入完毕才会发出&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学习更多关于 _.debounce function (and its cousin&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.throttle), 参考: https://lodash.com/docs#debounce&lt;/span&gt;
&lt;span&gt;                    getAnswer: _.debounce(
                        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.question.indexOf(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;===&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                                vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;问题请以问号（？）结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;
                            }
                            vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;让我想想...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                            axios.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://yesno.wtf/api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                                .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response) {
                                    vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _.capitalize(response.data.answer);
                                    vm.src&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;response.data.image;
                                    console.log(response);
                                })
                                .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
                                    vm.answer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;发生了错误，不能调用该应用程序接口&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; error
                                })
                        },
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是我们为用户停止输入等待的毫秒数&lt;/span&gt;
                        &lt;span&gt;500&lt;/span&gt;&lt;span&gt;
                    )
                }
            })
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171228103813972-504439854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用&lt;code&gt;v-bind&lt;/code&gt; 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 &lt;code&gt;v-bind&lt;/code&gt; 用于 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;style&lt;/code&gt; 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。&lt;/p&gt;
&lt;h2 id=&quot;绑定-HTML-Class&quot;&gt;3.1、绑定 HTML Class&lt;/h2&gt;
&lt;h3 id=&quot;对象语法&quot;&gt;3.1.1、对象语法&lt;/h3&gt;
&lt;p&gt;我们可以传给 &lt;code&gt;v-bind:class&lt;/code&gt; 一个对象，以动态地切换 class 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;{ active: isActive }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的语法表示 class&lt;code&gt;active&lt;/code&gt; 的更新将取决于数据属性 &lt;code&gt;isActive&lt;/code&gt; 是否为 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;真值&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;我们也可以在对象中传入更多属性用来动态切换多个 class 。此外， &lt;code&gt;v-bind:class&lt;/code&gt; 指令可以与普通的 class 属性共存。如下模板:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;static&quot;&lt;/span&gt;&lt;span&gt;
     v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;{ active: isActive, 'text-danger': hasError }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下 data:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  isActive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  hasError: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渲染为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;static active&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当 &lt;code&gt;isActive&lt;/code&gt; 或者 &lt;code&gt;hasError&lt;/code&gt; 变化时，class 列表将相应地更新。例如，如果 &lt;code&gt;hasError&lt;/code&gt;的值为 &lt;code&gt;true&lt;/code&gt; ， class列表将变为 &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你也可以直接绑定数据里的一个对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;classObject&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  classObject: {
    active: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;'text-danger': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;渲染的结果和上面一样。我们也可以在这里绑定返回对象的 &lt;a href=&quot;http://cn.vuejs.org/v2/guide/computed.html&quot;&gt;计算属性&lt;/a&gt;。这是一个常用且强大的模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;classObject&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  isActive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  error: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
},
computed: {
  classObject: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      active: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isActive &amp;amp;&amp;amp; !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.error,
      &lt;/span&gt;'text-danger': &lt;span&gt;this&lt;/span&gt;.error &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.error.type === 'fatal'&lt;span&gt;,
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Class 与 Style 绑定&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            .valide&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
            .priceRequired&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
            .priceRange&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
                display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bgGreen&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;{bgRed:isShow,bgBlue:isActive}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bgGreen&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;classObj1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;价格：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;price&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valide&quot;&lt;/span&gt;&lt;span&gt;  v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;priceValide1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;必填&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;valide&quot;&lt;/span&gt;&lt;span&gt;  v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;priceValide2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;介于0.1-99999之间&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data:{
                    isShow:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    isActive:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    classObj1:{
                        isHide:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        isRight:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    },
                    price:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
                },
                computed:
                {
                    priceValide1:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                            priceRequired:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.price&lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                        }
                    },
                    priceValide2:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                            priceRange:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.price&lt;/span&gt;&lt;span&gt;!=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.price&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;99999&lt;/span&gt;&lt;span&gt;)
                        }
                    }
                }
            });
            
        
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171228142102663-1680464420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;数组语法&quot;&gt;3.1.2、数组语法&lt;/h3&gt;
&lt;p&gt;我们可以把一个数组传给 &lt;code&gt;v-bind:class&lt;/code&gt; ，以应用一个 class 列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[activeClass, errorClass]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  activeClass: &lt;/span&gt;'active'&lt;span&gt;,
  errorClass: &lt;/span&gt;'text-danger'&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渲染为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你也想根据条件切换列表中的 class ，可以用三元表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[isActive ? activeClass : '', errorClass]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此例始终添加 &lt;code&gt;errorClass&lt;/code&gt; ，但是只有在 &lt;code&gt;isActive&lt;/code&gt; 是 true 时添加 &lt;code&gt;activeClass&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[{ active: isActive }, errorClass]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Class 与 Style 绑定&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bgGreen&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[isHide,isRight]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bgGreen&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[(isShow?'bg3':''),isRight,bg4]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;bgGreen&quot;&lt;/span&gt;&lt;span&gt; v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;[{bg3:isShow},isRight,bg4]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;span5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../js/vue.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    isShow: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    isHide: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bg1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    isRight: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bg2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    price: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
                }

            });
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;h3&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171228142818288-1424064351.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;

&lt;h3 id=&quot;With-Components&quot;&gt;3.1.3、With Components&lt;/h3&gt;
&lt;blockquote readability=&quot;4.247311827957&quot;&gt;
&lt;p&gt;This section assumes knowledge of  &lt;a href=&quot;http://cn.vuejs.org/v2/guide/components.html&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component’s root element. Existing classes on this element will not be overwritten.&lt;/p&gt;
&lt;p&gt;For example, if you declare this component:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Vue.component('my-component'&lt;span&gt;, {
  template: &lt;/span&gt;'&amp;lt;p class=&quot;foo bar&quot;&amp;gt;Hi&amp;lt;/p&amp;gt;'&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then add some classes when using it:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;baz boo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rendered HTML will be:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;foo bar baz boo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The same is true for class bindings:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-component &lt;/span&gt;&lt;span&gt;v-bind:class&lt;/span&gt;&lt;span&gt;=&quot;{ active: isActive }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;foo bar active&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;绑定内联样式&quot;&gt;3.2、绑定内联样式&lt;/h2&gt;
&lt;h3 id=&quot;对象语法-1&quot;&gt;3.2.1、对象语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;v-bind:style&lt;/code&gt; 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:style&lt;/span&gt;&lt;span&gt;=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  activeColor: &lt;/span&gt;'red'&lt;span&gt;,
  fontSize: &lt;/span&gt;30&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接绑定到一个样式对象通常更好，让模板更清晰：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:style&lt;/span&gt;&lt;span&gt;=&quot;styleObject&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;data: {
  styleObject: {
    color: &lt;/span&gt;'red'&lt;span&gt;,
    fontSize: &lt;/span&gt;'13px'&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot; onclick=&quot;copyCnblogsCode(this)&quot; href=&quot;javascript:void(0);&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;同样的，对象语法常常结合返回对象的计算属性使用。&lt;/p&gt;
&lt;h3 id=&quot;数组语法-1&quot;&gt;3.2.2、数组语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;v-bind:style&lt;/code&gt; 的数组语法可以将多个样式对象应用到一个元素上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;v-bind:style&lt;/span&gt;&lt;span&gt;=&quot;[baseStyles, overridingStyles]&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;自动添加前缀&quot;&gt;3.2.3、自动添加前缀&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;v-bind:style&lt;/code&gt; 使用需要特定前缀的 CSS 属性时，如 &lt;code&gt;transform&lt;/code&gt; ，Vue.js 会自动侦测并添加相应的前缀。&lt;/p&gt;
&lt;p&gt;官方帮助： &lt;a href=&quot;http://vuejs.org/guide/class-and-style.html&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://vuejs.org/guide/class-and-style.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://git.coding.net/zhangguo5/vue2.git&quot; target=&quot;_blank&quot;&gt;https://git.coding.net/zhangguo5/vue2.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av17503637/&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/av17503637/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.1、请把v-on指令的每一种“修饰符”与调用方式都应用一遍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方法处理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对象语法 (2.4.0+) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on&lt;/span&gt;&lt;span&gt;=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 内联语句 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click&lt;/span&gt;&lt;span&gt;=&quot;doThat('hello', $event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 缩写 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 停止冒泡 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 阻止默认行为，没有表达式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;@submit.prevent&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  串联修饰符 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;@click.stop.prevent&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键别名 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.enter&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 键修饰符，键代码 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;@keyup.13&lt;/span&gt;&lt;span&gt;=&quot;onEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 点击回调只会触发一次 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;v-on:click.once&lt;/span&gt;&lt;span&gt;=&quot;doThis&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.2、请完成一个商品管理模块，要求如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用bootstrap+vue2技术实现&lt;/li&gt;
&lt;li&gt;添加与修改功能使用模式窗口&lt;/li&gt;
&lt;li&gt;支持全选与反选，隔行换色与光棒效果&lt;/li&gt;
&lt;li&gt;详细是点击时在弹出层中显示当前商品的所有信息&lt;/li&gt;
&lt;li&gt;尝试分页（选做）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/63651/201712/63651-20171227154811894-611924750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.3、增强商品管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据从后台加载，请注意跨域（axios）&lt;/li&gt;
&lt;li&gt;实现搜索功能（Lodash）&lt;/li&gt;
&lt;li&gt;有验证、有错误提示&lt;/li&gt;
&lt;li&gt;增加删除与添加时的动画效果（选作）&lt;/li&gt;
&lt;li&gt;了解UIKit（选作）&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 28 Dec 2017 07:00:00 +0000</pubDate>
<dc:creator>张果</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/best/p/8135735.html</dc:identifier>
</item>
<item>
<title>Aop介绍及几种实现方式 - huangwww</title>
<link>http://www.cnblogs.com/flyingaway/p/8126178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyingaway/p/8126178.html</guid>
<description>&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label1&quot; target=&quot;_blank&quot;&gt;Aop介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label2&quot; target=&quot;_blank&quot;&gt;Aop的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label3&quot; target=&quot;_blank&quot;&gt;Aop的织入方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label4&quot; target=&quot;_blank&quot;&gt;Aop之静态织入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label5&quot; target=&quot;_blank&quot;&gt;Aop之动态织入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  a.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label5&quot; target=&quot;_blank&quot;&gt;使用.net真实代理实现织入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  b.&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8126178.html#label6&quot; target=&quot;_blank&quot;&gt;使用Unity框架的拦截器实现织入&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Aop介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     我们先看一下wiki百科的介绍&lt;br/&gt;     Traditional software development focuses on decomposing systems into units of primary functionality, while recognizing that there are other issues of concern that do not fit well into the primary decomposition. The traditional development process leaves it to the programmers to code modules corresponding to the primary functionality and to make sure that all other issues of concern are addressed in the code wherever appropriate. Programmers need to keep in mind all the things that need to be done, how to deal with each issue, the problems associated with the possible interactions, and the execution of the right behavior at the right time. These concerns span multiple primary functional units within the application, and often result in serious problems faced during application development and maintenance. The distribution of the code for realizing a concern becomes especially critical as the requirements for that concern evolve – a system maintainer must find and correctly update a variety of situations.&lt;/p&gt;
&lt;p&gt;    Aspect-oriented software development focuses on the identification, specification and representation of cross-cutting concerns and their modularization into separate functional units as well as their automated composition into a working system.&lt;/p&gt;
&lt;p&gt;     传统的软件开发关注将系统分解成为一个主要的功能单元，然而却发现一些问题并不适合分解方式。这种传统的开发过程让编码人员合作编写主要的功能模块，以此保证那些主要的关注点能够正确的被编码。编码人员需要记住所有需要被完成的事情，如何处理每个问题，问题可能的关联关系，以此确定代码在正确的时候以正确的方式被执行。这些关注点在应用里面跨域了多个主要供单元，这经常在开发和维护时引发一些严重的问题。这些分布式代码导致的问题变得越来越迫切得需要得到解决-一个系统维护人员必须解决这种问题。&lt;/p&gt;
&lt;p&gt;    面向切面软件开发需要关注这些识别的，详细的，具有代表性的切面问题，将其模块化到功能捣衣并且自动将这些代码组合到一个工作中的系统。&lt;/p&gt;

&lt;p&gt;    英语比较蹩脚，翻译比较涩，总结起来的意思就是，Aop是将一些已经识别的切面关注的功能封装，并能自动将该功能组合到需要的地方。&lt;/p&gt;
&lt;p&gt;    我对Aop的理解就是，一些被封装好的，通用的业务单元，真正的编程人员不需要关注的部分，并能动态或静态的将这部分功能组合到业务中去。举个简单的例子，我们在代码中，经常要判断是否用户登录，如果未登录，就需要跳转到指定的页面，伪代码如下:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public &lt;span&gt;string&lt;span&gt; GetNews(){
            &lt;span&gt;/*&lt;span&gt;判断是否登录，如果已经登录，则执行后面的业务代码
             如果没有登录，则跳转到登录页面&lt;span&gt;*/
             
            &lt;span&gt;//&lt;span&gt;业务代码&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    我们可以来看一下简单的流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1294228/201712/1294228-20171228133756100-1419198632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    从图中我们可以将代码中的登录的判断业务分解成一个单独的业务单元，在需要的地方打上一个标签，告诉系统这里需要执行，那么其他编码人员就不需要再写重复类似的代码了。这就是Aop解决的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aop的基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;   在介绍Aop的实现方式前，我们先了解一下Aop的几个知识点，这有助于我们理解Aop的实际技术。&lt;/p&gt;

&lt;p&gt;1）aspect（切面）：实现了cross-cutting功能，是针对切面的模块。最常见的是logging模块，这样，程序按功能被分为好几层，如果按传统的继承的话，商业模型继承日志模块的话根本没有什么意义，而通过创建一个logging切面就可以使用AOP来实现相同的功能了。&lt;/p&gt;
&lt;p&gt;2）jointpoint（连接点）：连接点是切面插入应用程序的地方，该点能被方法调用，而且也会被抛出意外。连接点是应用程序提供给切面插入的地方，可以添加新的方法。比如以上我们的切点可以认为是findInfo(String)方法。&lt;/p&gt;
&lt;p&gt;3）advice（处理逻辑）：advice是我们切面功能的实现，它通知程序新的行为。如在logging里，logging advice包括logging的实现代码，比如像写日志到一个文件中。advice在jointpoint处插入到应用程序中。以上我们在MyHandler.java中实现了advice的功能&lt;/p&gt;
&lt;p&gt;4）pointcut（切点）：pointcut可以控制你把哪些advice应用于jointpoint上去。决定了那个jointpoint会获得通知。&lt;/p&gt;
&lt;p&gt;5）introduction：允许添加新的方法和属性到类中。&lt;/p&gt;
&lt;p&gt;6）target（目标类）：是指那些将使用advice的类，一般是指独立的那些商务模型。比如以上的StudentInfoServiceImpl.&lt;/p&gt;
&lt;p&gt;7)proxy（代理类）：使用了proxy的模式。是指应用了advice的对象，看起来和target对象很相似。&lt;/p&gt;
&lt;p&gt;8）weaving(插入）：是指应用aspects到一个target对象创建proxy对象的过程：complie time，classload time，runtime&lt;/p&gt;

&lt;p&gt;以上这几点是从百度百科中找来的，如果暂时不理解没有关系，后面我会结合实际代码讲解，看完具体代码，再回来这里来对号入座，相信大家可以很快理解这接概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aop的俩种织入方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   目前在.NET平台中，支持的织入方式有俩中，一种是静态织入，即编译时织入，另外一个是动态织入，即运行时织入。俩中方式各有优缺点，使用静态织入，可以不破坏代码结构，这里的破坏代码结构是你需要使用多余配置，写一些多余的代码，或必须依赖某种方式(这里大家也许也还不太明白，可以看完后面俩种方式的具体代码比较，再回头来看，会比较好理解)。使用动态织入的优点就是可以动态调试。俩中织入方式是互补的，即动态织入的优点也是静态织入的缺点，同理，静态织入的优点亦是动态织入的缺点。大家在做技术选型时可以根据自己的实际情况进行选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aop之静态织入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 目前成熟的框架有&lt;a title=&quot;PostSharp&quot; href=&quot;https://www.postsharp.net/&quot; target=&quot;_blank&quot;&gt;PostSharp&lt;/a&gt;，这个框架是商业框架，意思就是需要付费，这里就不具体介绍了，需要了解的土豪请到官网查看，具体如何使用请查阅&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/文档&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;    BSF.Aop  .Net &lt;strong&gt;免费开源，静态Aop织入&lt;/strong&gt;（直接修改IL中间语言）框架，类似PostSharp(收费)，实现前后Aop切面和INotifyPropertyChanged注入方式。其原理是在编译生成IL后，借助Mono.Cecil的AssemblyDefinition读取程序集，并检测需要注入的点，并将指定的代码注入到程序集中。有想具体深入研究的同学，可以到 &lt;a href=&quot;https://gitee.com/chejiangyi/BSF.Aop&quot; target=&quot;_blank&quot;&gt;BSF.Aop&lt;/a&gt;中下载源码进行研究。遗憾的是这个只实现了俩个切入点，并没有在异常时提供切入点。&lt;/p&gt;
&lt;p&gt;    我们模拟一个日志记录的例子，我们先建一个项目。&lt;/p&gt;
&lt;p&gt;1.    在项目中引用BSF.Aop.dll,Mono.Cecil.dll，Mono.Cecil.Pdb.dll，Microsoft.Build.dll；&lt;/p&gt;
&lt;p&gt;2.    添加一个类LogAttribute并继承Aop.Attributes.Around.AroundAopAttribute（切面）；&lt;/p&gt;
&lt;p&gt;3.    重写AroundAopAttribute的Before和After方法，并写入逻辑代码；&lt;/p&gt;
&lt;p&gt;4.    新建一个测试类LogTest，并添加Execute方法，并在Execute方法上面添加LogAttribute标签；&lt;/p&gt;
&lt;p&gt;5.    我们在main里面new一个LogTest对象并调用看看输出结果；&lt;/p&gt;
&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public &lt;span&gt;class&lt;span&gt; LogTest
    {
        [LogAttribute]
        &lt;span&gt;public &lt;span&gt;void Execute(&lt;span&gt;int&lt;span&gt; a)
        {
            a = a * &lt;span&gt;100&lt;span&gt;;
            System.Console.WriteLine(&lt;span&gt;&quot;&lt;span&gt;Hello world!&lt;span&gt;&quot; +&lt;span&gt; a);
        }
    }

    &lt;span&gt;public &lt;span&gt;class&lt;span&gt; LogAttribute : AroundAopAttribute
    {
        &lt;span&gt;public &lt;span&gt;virtual &lt;span&gt;void&lt;span&gt; Before(AroundInfo info)
        {
            System.Console.WriteLine(&lt;span&gt;&quot;&lt;span&gt;Log before executed value is&lt;span&gt;&quot; + info.Params[&lt;span&gt;&quot;&lt;span&gt;a&lt;span&gt;&quot;&lt;span&gt;]);
        }
        
        &lt;span&gt;public &lt;span&gt;virtual &lt;span&gt;void&lt;span&gt; After(AroundInfo info)
        {
            System.Console.WriteLine(&lt;span&gt;&quot;&lt;span&gt;Log after executed value is&lt;span&gt;&quot; + info.Params[&lt;span&gt;&quot;&lt;span&gt;a&lt;span&gt;&quot;&lt;span&gt;]);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static &lt;span&gt;void Main(&lt;span&gt;string&lt;span&gt;[] args)
{
    Aop.AopStartLoader.Start(&lt;span&gt;null&lt;span&gt;);

     &lt;span&gt;new LogTest().Execute(&lt;span&gt;2&lt;span&gt;);

     Console.ReadLine();
}    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行代码输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1294228/201712/1294228-20171227154911675-2064197044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    上例代码中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;    aspect 日志&lt;/li&gt;
&lt;li&gt;    join point 即AroundAopAttribute中的Before和After，即方法执行前和方法执行后&lt;/li&gt;
&lt;li&gt;    advice 即日志的逻辑部分&lt;/li&gt;
&lt;li&gt;    pointcut 即我们LogAttribute中的Before（上面的例子故意没有重写After，是因为怕大家误解）&lt;/li&gt;
&lt;li&gt;    target 这里我们是对方法进行切入的，即Execute方法&lt;/li&gt;
&lt;li&gt;    weaving 这个例子中我们采用的是编译时的织入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Aop之动态织入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt; 使用.NET提供的远程代理，即RealProxies来实现。&lt;/p&gt;
&lt;p&gt;1.先建一个Aop代理类AopClassAttribute继承于ProxyAttribute，这个标签会告诉代理，这个类需要被代理创建调用；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标记一个类为Aop类，表示该类可以被代理注入
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopClassAttribute : ProxyAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; MarshalByRefObject CreateInstance(Type serverType)
        {
            AopProxy realProxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AopProxy(serverType);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; realProxy.GetTransparentProxy() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MarshalByRefObject;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.定义Aop的属性，并定义织入点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Attribute基类，通过实现该类来实现切面的处理工作
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopAttribute : Attribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用之前会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1.如果不需要修改输出结果，请返回null
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2.如果返回值不为null，则不会再调用原始方法执行，而是直接将返回的参数作为结果
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;args&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resultType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的返回值类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; PreCall(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args, Type resultType);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用之后会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resultValue&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的返回值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;args&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Called(&lt;span&gt;object&lt;/span&gt; resultValue, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用出现异常时会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;异常值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;args&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnException(Exception e, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.定义代理的逻辑过程，这里我对returnvalue做了判断，是为了实现缓存更新和添加的切面代码做的，在这里我实现了三个切入点的调用，具体可看注释部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 主要代理处理类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopProxy : RealProxy
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AopProxy(Type serverType)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(serverType)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IMessage Invoke(IMessage msg)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;is&lt;/span&gt; IConstructionCallMessage) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; InvokeConstruction(msg);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; InvokeMethod(msg);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IMessage InvokeMethod(IMessage msg)
        {
            IMethodCallMessage callMsg &lt;/span&gt;= msg &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMethodCallMessage;
            IMessage returnMessage;
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] args =&lt;span&gt; callMsg.Args;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; returnType = (callMsg.MethodBase &lt;span&gt;as&lt;/span&gt; System.Reflection.MethodInfo).ReturnType;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法返回类型&lt;/span&gt;
            &lt;span&gt;object&lt;/span&gt; returnValue = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法返回值&lt;/span&gt;
            AopAttribute[] attributes = callMsg.MethodBase.GetCustomAttributes(&lt;span&gt;typeof&lt;/span&gt;(AopAttribute), &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; AopAttribute[];
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attributes == &lt;span&gt;null&lt;/span&gt; || attributes.Length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; InvokeActualMethod(callMsg);
　　　　　　　　  &lt;span&gt;//&lt;span&gt;前切点&lt;/span&gt;&lt;/span&gt;
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    returnValue &lt;/span&gt;=&lt;span&gt; attribute.PreCall(args, returnType);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果以前切面属性都没有返回值，则调用原始的方法；否则不调用
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主要是做缓存类似的业务&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (returnValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    returnMessage &lt;/span&gt;=&lt;span&gt; InvokeActualMethod(callMsg);
                    returnValue &lt;/span&gt;= (returnMessage &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ReturnMessage).ReturnValue;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; returnMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReturnMessage(returnValue, args, args.Length, callMsg.LogicalCallContext, callMsg);
　　　　　　　　  &lt;span&gt;//&lt;span&gt;后切点&lt;/span&gt;&lt;/span&gt;
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    attribute.Called(returnValue,args);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {&lt;br/&gt;　　　　　　　　　&lt;span&gt;//&lt;span&gt;异常切入点&lt;/span&gt;&lt;/span&gt;
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    attribute.OnException(e, args);

                returnMessage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReturnMessage(e, callMsg);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnMessage;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IMessage InvokeActualMethod(IMessage msg)
        {
            IMethodCallMessage callMsg &lt;/span&gt;= msg &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IMethodCallMessage;
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] args =&lt;span&gt; callMsg.Args;
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; o =&lt;span&gt; callMsg.MethodBase.Invoke(GetUnwrappedServer(), args);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReturnMessage(o, args, args.Length, callMsg.LogicalCallContext, callMsg);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IMessage InvokeConstruction(IMessage msg)
        {
            IConstructionCallMessage constructCallMsg &lt;/span&gt;= msg &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IConstructionCallMessage;
            IConstructionReturnMessage constructionReturnMessage &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.InitializeServerObject((IConstructionCallMessage)msg);
            RealProxy.SetStubData(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, constructionReturnMessage.ReturnValue);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; constructionReturnMessage;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 4.定义上下文边界对象，想要使用Aop的类需要继承此类(这个是这种Aop方式破坏性最大的地方，因为需要继承一个类，而面向对象单继承的特性导致了业务类不能再继承其他的类。可以想象一下你有一个查询基类，然后另一个查询类想要继承查询基类，而又想使用Aop，这时就尴尬了)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Aop基类，需要注入的类需要继承该类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对代码继承有要求，后续可以改进一下
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注意，需要记录的不支持上下文绑定，如果需要记录，使用代理模式解决
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseAopObject : ContextBoundObject
    {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 5.定义Advice部分，即实际的业务逻辑，继承于&lt;span&gt;AopAttribute&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IncreaseAttribute : AopAttribute
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Max = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IncreaseAttribute(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; max)
        {
            Max &lt;/span&gt;=&lt;span&gt; max;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; PreCall(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args, Type resultType)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args == &lt;span&gt;null&lt;/span&gt; || args.Count() == &lt;span&gt;0&lt;/span&gt; || !(args[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;is&lt;/span&gt; ExampleData)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = args[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ExampleData;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; numString = args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString();
            data.Num &lt;/span&gt;= data.Num * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(data.Num);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Called(&lt;span&gt;object&lt;/span&gt; resultValue, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args == &lt;span&gt;null&lt;/span&gt; || args.Count() == &lt;span&gt;0&lt;/span&gt; || !(args[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;is&lt;/span&gt; ExampleData)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = args[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ExampleData;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; numString = args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].ToString();
            data.Num &lt;/span&gt;= data.Num * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(data.Num);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnException(Exception e, &lt;span&gt;object&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;[] args)
        {

        }
    }&lt;p&gt;public class ExampleData&lt;br/&gt;{&lt;br/&gt;public int Num { get; set; }&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 6.完成了上面的部分，我们就可以来使用Aop了，定义一个需要使用Aop的类，继承于BaseAopObject，并在类上面加上[AopClass]，在需要切入的方法上加上刚才定义的[IncreaseAttribute]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AopClass]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Example : BaseAopObject
    {
        [IncreaseAttribute(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Do(ExampleData data)
        {
            Add(data);
        }

        [IncreaseAttribute(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExampleData Add(ExampleData data)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ExampleData { Num = ++&lt;span&gt;data.Num };
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    可以看到，使用上面这种织入方式，对代码的侵入性太大，会限制代码的可扩展性。所以我比较不建议使用。&lt;/p&gt;
&lt;p&gt;    另一种方式是借助Ioc的代理来做Aop切面注入，这里我们以Unity作为Ioc容器，以之前写的关于&lt;a href=&quot;http://www.cnblogs.com/flyingaway/p/8078463.html&quot; target=&quot;_blank&quot;&gt;Unity Ioc&lt;/a&gt;中的例子来介绍Aop。&lt;/p&gt;
&lt;p&gt;   1.添加AopAttribute(定义连接点),这里有个循环引用，就是AopHandler和AopAttribute之间，不过并不影响使用，如有需要大家可以自己解决一下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标记一个类或方法为代理，表示该类或方法可以被代理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [AttributeUsage(AttributeTargets.Method, Inherited = &lt;span&gt;true&lt;/span&gt;, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopAttribute : HandlerAttribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请勿重写该方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;container&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ICallHandler CreateHandler(IUnityContainer container)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AopHandler();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用之前会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1.如果不需要修改输出结果，请返回null,ouputs返回new object[0]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2.如果返回值不为null，则不会再调用原始方法执行，而是直接将返回的参数作为结果
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inputArgs&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;outputs&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法中的out值,如果没有请返回null&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; PreCall(&lt;span&gt;object&lt;/span&gt;[] inputArgs, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] outputs);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用之后会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resultValue&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的返回值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inputArgs&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;outputs&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法中的out值，如果没有则该参数值为null&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Called(&lt;span&gt;object&lt;/span&gt; resultValue, &lt;span&gt;object&lt;/span&gt;[] inputArgs, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] outputs);
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调用出现异常时会调用的方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;异常值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inputArgs&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;方法的输入参数列表，键为参数名，值为参数值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnException(Exception e, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; inputArgs);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 2.添加AopHandler(代理类)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 主要代理处理类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopHandler : ICallHandler
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IMethodReturn Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext)
        {
            IMethodReturn returnValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; attrReturnValue = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] outputs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; inputs = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假如有忽略特性，直接忽略，不进行AOP代理&lt;/span&gt;
            IgnoreAttribute[] ignoreAttributes = input.MethodBase.GetCustomAttributes(&lt;span&gt;typeof&lt;/span&gt;(IgnoreAttribute), &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IgnoreAttribute[];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ignoreAttributes != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ignoreAttributes.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; input.CreateMethodReturn(attrReturnValue, outputs);

            AopAttribute[] attributes &lt;/span&gt;= input.MethodBase.GetCustomAttributes(&lt;span&gt;typeof&lt;/span&gt;(AopAttribute), &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; AopAttribute[];
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attributes == &lt;span&gt;null&lt;/span&gt; || attributes.Length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getNext()(input, getNext);

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; input.Arguments.Count; i++&lt;span&gt;) inputs.Add(input.Inputs.ParameterName(i), input.Inputs[i]);

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    attrReturnValue &lt;/span&gt;= attribute.PreCall(inputs.Values.ToArray(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; outputs);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果以前切面属性都没有返回值，则调用原始的方法；否则不调用
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主要是做缓存类似的业务&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (attrReturnValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    returnValue &lt;/span&gt;=&lt;span&gt; getNext()(input, getNext);
                    outputs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[returnValue.Outputs.Count];
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; returnValue.Outputs.Count; i++) outputs[i] =&lt;span&gt; returnValue.Outputs[i];
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; returnValue =&lt;span&gt; input.CreateMethodReturn(attrReturnValue, outputs);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (returnValue.Exception != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; returnValue.Exception;

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    attribute.Called(returnValue.ReturnValue, inputs.Values.ToArray(), outputs);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (AopAttribute attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
                    attribute.OnException(e, inputs);
                returnValue &lt;/span&gt;=&lt;span&gt; input.CreateExceptionMethodReturn(e);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnValue;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3..定义一个我们自己的功能块(业务逻辑)，这里还是以日志为例；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;span readability=&quot;9&quot;&gt;public class LogAttribute : AopAttribute&lt;br/&gt;{&lt;br/&gt;public override void Called(object resultValue, object[] inputArgs, object[] outputs)&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;Called&quot;);&lt;br/&gt;}&lt;p&gt;public override void OnException(Exception e, Dictionary&amp;lt;string, object&amp;gt; inputArgs)&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;exception:&quot; + e.Message);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public override object PreCall(object[] inputArgs, out object[] outputs)&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&quot;PreCall&quot;);&lt;br/&gt;outputs = new object[0];&lt;br/&gt;return null;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 5.接下来我们稍微改造一下我们的印钞机；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 印钞机
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CashMachine
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CashMachine() { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Print(ICashTemplate template)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; templateContent = template.GetTemplate(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民币&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            System.Console.WriteLine(templateContent);
        }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 印钞模块
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICashTemplate
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取钞票模板
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [Log]
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GetTemplate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; flag);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 人民币钞票模板
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CNYCashTemplate : ICashTemplate
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CNYCashTemplate() { }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetTemplate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; flag)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是人民币模板!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + flag + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  这是返回值。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 美钞钞票模板
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; USDCashTemplate : ICashTemplate
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; USDCashTemplate() { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetTemplate(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; flag)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哎呀，美钞模板有问题呀！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.然后我们在命令行的Main里改造一下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                ICashTemplate usdTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; USDCashTemplate();
                ICashTemplate rmbTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CNYCashTemplate();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CashMachine().Print(rmbTemplate);
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CashMachine().Print(usdTemplate);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
            }
            Console.ReadLine();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.启动一下看看结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1294228/201712/1294228-20171228104838113-2125325654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.可以看到，只输出了GetTemplate方法的输出，并没有输出日志，我们要使用Ioc来注册对象才能使用，继续改造Main方法；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            UnityContainer container &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnityContainer();
            container.AddNewExtension&lt;/span&gt;&amp;lt;Interception&amp;gt;().RegisterType&amp;lt;ICashTemplate, CNYCashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            container.Configure&lt;/span&gt;&amp;lt;Interception&amp;gt;().SetInterceptorFor&amp;lt;ICashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterfaceInterceptor());
            container.AddNewExtension&lt;/span&gt;&amp;lt;Interception&amp;gt;().RegisterType&amp;lt;ICashTemplate, USDCashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            container.Configure&lt;/span&gt;&amp;lt;Interception&amp;gt;().SetInterceptorFor&amp;lt;ICashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterfaceInterceptor());

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CashMachine().Print(container.Resolve&amp;lt;ICashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CashMachine().Print(container.Resolve&amp;lt;ICashTemplate&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
            }
            Console.ReadLine();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 9.启动运行，看一下结果；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1294228/201712/1294228-20171228110125238-1587208909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，三个方法都执行了，而在抛出异常时是不会执行Called的方法的；&lt;/p&gt;
&lt;p&gt;10.上面我们是直接使用了UnityContainer来注册对象，而没有使用我们之前封装的Ioc，我们还有更简单的方式，就是采用配置的方式来注册对象和拦截器实现Aop。在实际，使用一个单独的文件来配置ioc会更易于维护。我们先添加一个unity.config文件；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;unity xmlns= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.microsoft.com/practices/2010/unity &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;sectionExtension type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Practices.Unity.InterceptionExtension.Configuration.InterceptionConfigurationExtension, Unity.Interception.Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
  &amp;lt;!--注入对象--&amp;gt;
  &amp;lt;typeAliases&amp;gt;
    &amp;lt;!--表示单例--&amp;gt;
    &amp;lt;typeAlias alias=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;singleton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity.Lifetime.ContainerControlledLifetimeManager,Unity.Abstractions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;!--表示每次使用都进行创建--&amp;gt;
    &amp;lt;typeAlias alias=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity.Lifetime.TransientLifetimeManager,Unity.Abstractions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/typeAliases&amp;gt;
  &amp;lt;container name= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;extension type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Interception&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;!--type表示接口 格式为 带命名空间的接口,程序集名 mapTo表示需要注入的实体类 name表示注入实体的name--&amp;gt;
    &amp;lt;register type= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IocWithUnity.ICashTemplate,IocWithUnity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; mapTo= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IocWithUnity.CNYCashTemplate,IocWithUnity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;!--定义拦截器--&amp;gt;
      &amp;lt;interceptor type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterfaceInterceptor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
      &amp;lt;policyInjection/&amp;gt;
      &amp;lt;!--定义对象生命周期--&amp;gt;
      &amp;lt;lifetime type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;singleton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/register&amp;gt;
    &amp;lt;!--type表示接口 格式为 带命名空间的接口,程序集名 mapTo表示需要注入的实体类 name表示注入实体的name--&amp;gt;
    &amp;lt;register type= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IocWithUnity.ICashTemplate,IocWithUnity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; mapTo= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IocWithUnity.USDCashTemplate,IocWithUnity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;!--定义拦截器--&amp;gt;
      &amp;lt;interceptor type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterfaceInterceptor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
      &amp;lt;policyInjection/&amp;gt;
      &amp;lt;!--定义对象生命周期--&amp;gt;
      &amp;lt;lifetime type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;singleton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/register&amp;gt;
  &amp;lt;/container&amp;gt;
&amp;lt;/unity&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;11.再配置app.config(WEB项目应该是web.config)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Unity.Configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;unity configSource=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unity.config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;startup&amp;gt; 
        &amp;lt;supportedRuntime version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v4.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sku=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.NETFramework,Version=v4.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/startup&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;12.将我们之前写的IocContainer修改一下读取配置；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IocContainer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IUnityContainer _container = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; IocContainer()
        {
            _container &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnityContainer();

            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; unitySection = ConfigurationManager.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (unitySection == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            UnityConfigurationSection section &lt;/span&gt;=&lt;span&gt; (UnityConfigurationSection)unitySection;
            section.Configure(_container, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注册一个实例作为T的类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要注册的类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;instance&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要注册的实例&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register&amp;lt;T&amp;gt;&lt;span&gt;(T instance)
        {
            _container.RegisterInstance&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;(instance);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注册一个名为name的T类型的实例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要注册的类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;关键字名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;instance&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, T instance)
        {
            _container.RegisterInstance(name, instance);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将类型TFrom注册为类型TTo
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TFrom&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TTo&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register&amp;lt;TFrom, TTo&amp;gt;() &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TTo : TFrom
        {
            _container.RegisterType&lt;/span&gt;&amp;lt;TFrom, TTo&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将类型TFrom注册为类型TTo
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TFrom&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TTo&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;lifetime&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register&amp;lt;TFrom, TTo&amp;gt;(LifetimeManager lifetime) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TTo : TFrom
        {
            _container.RegisterType&lt;/span&gt;&amp;lt;TFrom, TTo&amp;gt;&lt;span&gt;(lifetime);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将类型TFrom注册名为name类型TTo
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TFrom&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TTo&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Register&amp;lt;TFrom, TTo&amp;gt;(&lt;span&gt;string&lt;/span&gt; name) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; TTo : TFrom
        {
            _container.RegisterType&lt;/span&gt;&amp;lt;TFrom, TTo&amp;gt;&lt;span&gt;(name);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过关键字name来获取一个实例对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Resolve&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _container.Resolve&amp;lt;T&amp;gt;&lt;span&gt;(name);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取一个为T类型的对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Resolve&amp;lt;T&amp;gt;&lt;span&gt;()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _container.Resolve&amp;lt;T&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有注册类型为T的对象实例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;需要获取的类型的对象&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;T&amp;gt; ResolveAll&amp;lt;T&amp;gt;&lt;span&gt;()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _container.ResolveAll&amp;lt;T&amp;gt;&lt;span&gt;();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    注意：配置时有一个坑 &amp;lt;section name=&quot;unity&quot; type=&quot;Microsoft.Practices.Unity.Configuration.UnityConfigurationSection, Unity.Configuration&quot;/&amp;gt; 这句话在5.0版本后dll的名称改了，以前是Microsoft.Practices.Unity.Configuration，现在是Unity.Configuration，如果你在运行时碰到找不到文件或程序集xxx时，可以注意看一下你的具体的dll的文件名。包括后面的unity.config里面的lifetime的配置也是，大家需要注意一下自己的版本，然后找到对应的命名空间和dll文件进行配置。&lt;/p&gt;
&lt;p&gt;13.接下来我们运行一下看看结果如何；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1294228/201712/1294228-20171228132050381-1826663601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    总结：可以看到，静态织入方式相对较简单，对代码破坏性近乎于0，其原理大致是在编译前，将需要的代码添加到我们添加了Attribute的地方，如果用反编译工具反编译生成的dll就可以看到实际编译后的代码。这种织入方式的缺点是不易于调试工作，因为生成的pdb文件与我们的源代码文件实际上是不一样的。而采用真实代理的方式进行织入，这种方式比较原生，但对代码侵入性较大，而且效率也较低。使用ioc框架的拦截器进行拦截织入的方式，是当下比较好的一种方式，但是也是有一个约束，就是对象必须经过ioc容器来委托创建。基于这些比较，各位看官可以选择适合自己的织入方式。&lt;/p&gt;

&lt;p&gt;本文原创，如有转载，请注明出处。&lt;/p&gt;

</description>
<pubDate>Thu, 28 Dec 2017 05:28:00 +0000</pubDate>
<dc:creator>huangwww</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyingaway/p/8126178.html</dc:identifier>
</item>
<item>
<title>Android开发——使用LitePal开源数据库 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8127146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8127146.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言：之前使用Android内置的数据库，感觉一大堆SQL语句，一不小心就错了，很难受，学习了这个LItePal的开源数据库，瞬间觉得Android内置的数据库简直是垃圾般的存在&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;LitePal GitHub首页：https://github.com/LitePalFramework/LitePal&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;配置步骤&lt;/h2&gt;
&lt;h3&gt;1.添加依赖&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;切换project模式，展开APP的文件夹，找到build.gradle文件，去里面添加依赖，这里我用的是最新版本，可以在LitePal的Github官网上找到最新的版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227172427628-1268956244.png&quot; alt=&quot;&quot; width=&quot;982&quot; height=&quot;627&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;2.配置LitePal.xml文件及相关设置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在main文件夹中新建一个asstes文件夹，之后，创建LitePal.xml，复制LitePal上的GItHub给出的代码，这里我就直接写了，其中，&lt;span&gt;dbname代表数据库的名称，version代表版本号，list标签之下有表&lt;/span&gt;（专业术语为映射模型类），这里之后会提及&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227175403191-512597799.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 此外&lt;span&gt;，我们还需要在AndroidMainfest文件中添加一行代码&lt;span&gt;android:name=&lt;span&gt;&quot;org.litepal.LitePalApplication&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227175946519-863697369.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 3.创建一个Java Bean类&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里创建了一个书的bean类，有着三个成员变量，之后，使用alt+insert，选择getter and setter，添加get与set方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227180437581-824466108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4.在LItePal.xml文件中list标签下配置表（映射模型类）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;记得包名要写完整&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227181011597-1982338814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 使用步骤：&lt;/h2&gt;
&lt;h3&gt;1.创建和升级数据库&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在相关activity的java文件直接使用&lt;span&gt;LitePal&lt;/span&gt;的&lt;span&gt;getDatabase&lt;/span&gt;方法创建数据库，即是添加下面的代码即可，写在onClick事件中即可，这里就不放截图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　LitePal.getDatabase();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;升级数据库，&lt;span&gt;直接在Bean的java文件中添加新的成员变量及其的get与set方法即可&lt;/span&gt;，升级数据库的代码还是使用上面的那一行代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，例如上述，我们想要添加一个出版社的列，我们只需要在Book里面创建一个成员变量，及get与set方法，之后，去LitePal.xml文件中，将version的版本加1，也就是改为2即可，其他的都不需要更改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，我们想要再加一张表，也是类似的操作，创建一个Bean类，之后，在LitePal.xml文件中使用mapping标签，同时，将版本号加一，也就是改为2即可，其他的也是不需要改变&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.添加数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改模型类（也就是Book），使其继承DataSupport&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228122250847-461611883.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后，我们只需要新建一个对象，调用其set方法，为其里面的成员变量赋值，之后，调用save方法，就是成功地往数据库中添加了数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228122603066-1604441694.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;3.修改（更新）数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;更新的操作其实很简单，使用udateAll方法即可，例如，我们要将上面书名为The Last的作者改为&lt;span&gt;John，&lt;/span&gt;价格改成16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228123215722-700387571.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;updateAll里面写了约束条件，也就是书名为The Last的那一条数据，修改，如果updateAll里面无参数，就是将表里面的数据的作者与价格更改为John和16&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.删除数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;调用DataSupport的deleteAll方法，与上面的updateAll类似，参数里填约束条件，如果不写，就是删除整张表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　　　　DataSupport.deleteAll(Book.&lt;span&gt;class&lt;/span&gt;,&quot;naem is ?&quot;,&quot;The Last&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除名字为The Last的数据&lt;/span&gt;
       　DataSupport.deleteAll(Book.&lt;span&gt;class&lt;/span&gt;,&quot;price &amp;lt; ?&quot;,&quot;16&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除价格低于16的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5.查找数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;查找方法调用的DataSupport的findAll方法即可，下面给出示例代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;select指定查询列，where查找出符合约束条件的数据，order将查询结果排序，limit限制查询数据数目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　　　　List&amp;lt;Book&amp;gt; books = DataSupport.findAll(Book.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找Book这张表的全部数据，返回的是一个List&lt;/span&gt;
        List&amp;lt;Book&amp;gt; books1 = DataSupport.select(&quot;name&quot;,&quot;price&quot;).find(Book.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询Book这张表中的name与price两列的数据，返回的也是一个List&lt;/span&gt;
        List&amp;lt;Book&amp;gt; books2 = DataSupport.where(&quot;price &amp;gt; ?&quot;,&quot;16&quot;).find(Book.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定在Book这张表查找符合价格大于16（约束条件）的数据，返回的是一个List&lt;/span&gt;
        List&amp;lt;Book&amp;gt; books4 = DataSupport.order(&quot;price desc&quot;).find(Book.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将查询结果按照价格从高到低排序（desc 降序），不写或者asc则是升序&lt;/span&gt;
        List&amp;lt;Book&amp;gt; books5 = DataSupport.limit(3).find(Book.&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询Book表中的前三条数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;值得一提的是，可以使用findBySQL方法进行原生的查询，也就是之前使用内置数据库的方法，返回的是一个Cursor对象，这里我就不使用了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228130315394-1493259055.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 28 Dec 2017 05:04:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8127146.html</dc:identifier>
</item>
<item>
<title>Mac OS 终端利器 iTerm2 - 田园里的蟋蟀</title>
<link>http://www.cnblogs.com/xishuai/p/mac-iterm2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xishuai/p/mac-iterm2.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228130441550-1699845986.jpg&quot; width=&quot;600px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前一直使用 Mac OS 自带的终端，用起来虽然有些不太方便，但总体来说还是可以接受的，是有想换个终端的想法，然后今天偶然看到一个终端利器 iTerm2，发现真的很强大，也非常的好用，按照网上配置了主题什么的，还是有些坑的，这边再记录下，以便后面查阅。&lt;/p&gt;
&lt;h2 id=&quot;安装-iterm2&quot;&gt;1. 安装 iTerm2&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.iterm2.com/downloads.html&quot; class=&quot;uri&quot;&gt;https://www.iterm2.com/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。&lt;/p&gt;
&lt;p&gt;或者你可以直接使用 Homebrew 进行安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;brew&lt;/span&gt; cask install iterm2&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;配置-iterm2-主题&quot;&gt;2. 配置 iTerm2 主题&lt;/h2&gt;
&lt;p&gt;iTerm2 最常用的主题是 Solarized Dark theme，下载地址：&lt;a href=&quot;http://ethanschoonover.com/solarized&quot; class=&quot;uri&quot;&gt;http://ethanschoonover.com/solarized&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载的是压缩文件，你先解压一下，然后打开 iTerm2，按&lt;code&gt;Command + ,&lt;/code&gt;键，打开 Preferences 配置界面，然后&lt;code&gt;Profiles -&amp;gt; Colors -&amp;gt; Color Presets -&amp;gt; Import&lt;/code&gt;，选择刚才解压的&lt;code&gt;solarized-&amp;gt;iterm2-colors-solarized-&amp;gt;Solarized Dark.itermcolors&lt;/code&gt;文件，导入成功，最后选择 Solarized Dark 主题，就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124549144-520902143.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-oh-my-zsh&quot;&gt;3. 配置 Oh My Zsh&lt;/h2&gt;
&lt;p&gt;Oh My Zsh 是对主题的进一步扩展，地址：&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot; class=&quot;uri&quot;&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一键安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;sh&lt;/span&gt; -c &lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;chsh&lt;/span&gt; -s /bin/zsh&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们编辑&lt;code&gt;vim ~/.zshrc&lt;/code&gt;文件，将主题配置修改为&lt;code&gt;ZSH_THEME=&quot;agnoster&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124617863-587540558.png&quot; width=&quot;700px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;agnoster&lt;/code&gt;是比较常用的 zsh 主题之一，你可以挑选你喜欢的主题，zsh 主题列表：&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/themes&quot; class=&quot;uri&quot;&gt;https://github.com/robbyrussell/oh-my-zsh/wiki/themes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;效果如下（配置了声明高亮）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124626363-735900072.png&quot; width=&quot;900px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-meslo-字体&quot;&gt;4. 配置 Meslo 字体&lt;/h2&gt;
&lt;p&gt;使用上面的主题，需要 Meslo 字体支持，要不然会出现乱码的情况，字体下载地址：&lt;a href=&quot;https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf&quot;&gt;Meslo LG M Regular for Powerline.ttf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载好之后，直接在 Mac OS 中安装即可。&lt;/p&gt;
&lt;p&gt;然后打开 iTerm2，按&lt;code&gt;Command + ,&lt;/code&gt;键，打开 Preferences 配置界面，然后&lt;code&gt;Profiles -&amp;gt; Text -&amp;gt; Font -&amp;gt; Chanage Font&lt;/code&gt;，选择 Meslo LG M Regular for Powerline 字体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124638503-196536251.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果你觉得默认的&lt;code&gt;12px&lt;/code&gt;字体大小不合适，可以自己进行修改。&lt;/p&gt;
&lt;p&gt;另外，VS Code 的终端字体，也需要进行配置，打开 VS Code，按&lt;code&gt;Command + ,&lt;/code&gt;键，打开用户配置，搜索&lt;code&gt;fontFamily&lt;/code&gt;，然后将右边的配置增加&lt;code&gt;&quot;terminal.integrated.fontFamily&quot;: &quot;Meslo LG M for Powerline&quot;&lt;/code&gt;，示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124651285-113264887.png&quot; width=&quot;900px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明高亮&quot;&gt;5. 声明高亮&lt;/h2&gt;
&lt;p&gt;效果就是上面截图的那样，特殊命令和错误命令，会有高亮显示。&lt;/p&gt;
&lt;p&gt;使用 Homebrew 安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;brew&lt;/span&gt; install zsh-syntax-highlighting&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功之后，编辑&lt;code&gt;vim ~/.zshrc&lt;/code&gt;文件，在最后一行增加下面配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;source&lt;/span&gt; /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124702378-701306768.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自动建议填充&quot;&gt;6. 自动建议填充&lt;/h2&gt;
&lt;p&gt;这个功能是非常实用的，可以方便我们快速的敲命令。&lt;/p&gt;
&lt;p&gt;配置步骤，先克隆&lt;code&gt;zsh-autosuggestions&lt;/code&gt;项目，到指定目录：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后编辑&lt;code&gt;vim ~/.zshrc&lt;/code&gt;文件，找到&lt;code&gt;plugins&lt;/code&gt;配置，增加&lt;code&gt;zsh-autosuggestions&lt;/code&gt;插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124716003-211091713.png&quot; width=&quot;900px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：上面声明高亮，如果配置不生效的话，在&lt;code&gt;plugins&lt;/code&gt;配置，再增加&lt;code&gt;zsh-syntax-highlighting&lt;/code&gt;插件试试。&lt;/p&gt;
&lt;p&gt;有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置，我修改的颜色值为：&lt;code&gt;586e75&lt;/code&gt;，示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124726566-1303342612.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124741660-319157353.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;左右键跳转&quot;&gt;7. 左右键跳转&lt;/h2&gt;
&lt;p&gt;主要是按住&lt;code&gt;option + → or ←&lt;/code&gt;键，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。&lt;/p&gt;
&lt;p&gt;打开 iTerm2，按&lt;code&gt;Command + ,&lt;/code&gt;键，打开 Preferences 配置界面，然后&lt;code&gt;Profiles → Keys → Load Preset... → Natural Text Editing&lt;/code&gt;，就可以了。&lt;/p&gt;
&lt;h2 id=&quot;iterm2-快速隐藏和显示&quot;&gt;8. iTerm2 快速隐藏和显示&lt;/h2&gt;
&lt;p&gt;这个功能也非常使用，就是通过快捷键，可以快速的隐藏和打开 iTerm2，示例配置（&lt;code&gt;Commond + .&lt;/code&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124752394-498404916.png&quot; width=&quot;800px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;iterm2-隐藏用户名和主机名&quot;&gt;9. iTerm2 隐藏用户名和主机名&lt;/h2&gt;
&lt;p&gt;有时候我们的用户名和主机名太长，比如我的&lt;code&gt;xishuai@xishuaideMacBook-Pro&lt;/code&gt;，终端显示的时候会很不好看（上面图片中可以看到），我们可以手动去除。&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;vim ~/.zshrc&lt;/code&gt;文件，增加&lt;code&gt;DEFAULT_USER=&quot;xishuai&quot;&lt;/code&gt;配置，示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124824566-107795143.png&quot; width=&quot;700px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;whoami&lt;/code&gt;命令，查看当前用户，效果（另外分屏的效果）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/435188/201712/435188-20171228124832113-143056841.png&quot; width=&quot;900px&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;iterm2-快捷命令&quot;&gt;10. iTerm2 快捷命令&lt;/h2&gt;
&lt;p&gt;快捷命令说明：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;command + t&lt;/td&gt;
&lt;td&gt;新建标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;command + w&lt;/td&gt;
&lt;td&gt;关闭标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;command + 数字 command + 左右方向键&lt;/td&gt;
&lt;td&gt;切换标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;command + enter&lt;/td&gt;
&lt;td&gt;切换全屏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;command + f&lt;/td&gt;
&lt;td&gt;查找&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;command + d&lt;/td&gt;
&lt;td&gt;垂直分屏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;command + shift + d&lt;/td&gt;
&lt;td&gt;水平分屏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;command + option + 方向键 command + [ 或 command + ]&lt;/td&gt;
&lt;td&gt;切换屏幕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;command + ;&lt;/td&gt;
&lt;td&gt;查看历史命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;command + shift + h&lt;/td&gt;
&lt;td&gt;查看剪贴板历史&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ctrl + u&lt;/td&gt;
&lt;td&gt;清除当前行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ctrl + l&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ctrl + a&lt;/td&gt;
&lt;td&gt;到行首&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ctrl + e&lt;/td&gt;
&lt;td&gt;到行尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ctrl + f/b&lt;/td&gt;
&lt;td&gt;前进后退&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ctrl + p&lt;/td&gt;
&lt;td&gt;上一条命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ctrl + r&lt;/td&gt;
&lt;td&gt;搜索命令历史&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;参考资料：&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 05:02:00 +0000</pubDate>
<dc:creator>田园里的蟋蟀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xishuai/p/mac-iterm2.html</dc:identifier>
</item>
<item>
<title>深度学习在文本分类中的应用 - llhthinker</title>
<link>http://www.cnblogs.com/llhthinker/p/8127788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/llhthinker/p/8127788.html</guid>
<description>&lt;blockquote readability=&quot;6.8285163776493&quot;&gt;
&lt;p&gt;近期阅读了一些深度学习在文本分类中的应用相关论文（&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers&quot;&gt;&lt;strong&gt;论文笔记&lt;/strong&gt;&lt;/a&gt;)，同时也参加了CCF 大数据与计算智能大赛（BDCI）2017的一个文本分类问题的比赛：让AI当法官，并取得了最终评测第四名的成绩(比赛的具体思路和代码参见&lt;a href=&quot;https://github.com/llhthinker/BDCI2017-MingLue&quot;&gt;&lt;strong&gt;github项目repo&lt;/strong&gt;&lt;/a&gt;)。因此，本文总结了文本分类相关的深度学习模型、优化思路以及今后可以进行的一些工作。欢迎转载，请保留本文链接：&lt;a href=&quot;http://www.cnblogs.com/llhthinker/p/8127788.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/llhthinker/p/8127788.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;文本分类是自然语言处理的一个基本任务，试图推断出给定的文本（句子、文档等）的标签或标签集合。&lt;/strong&gt;&lt;br/&gt;文本分类的应用非常广泛。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;垃圾邮件分类：二分类问题，判断邮件是否为垃圾邮件&lt;/li&gt;
&lt;li&gt;情感分析
&lt;ul&gt;&lt;li&gt;二分类问题，判断文本情感是积极(positive)还是消极(negative)&lt;/li&gt;
&lt;li&gt;多分类问题，判断文本情感属于{非常消极，消极，中立，积极，非常积极}中的哪一类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新闻主题分类：判断新闻属于哪个类别，如财经、体育、娱乐等&lt;/li&gt;
&lt;li&gt;自动问答系统中的问句分类&lt;/li&gt;
&lt;li&gt;社区问答系统中的问题分类：多标签分类，如&lt;a href=&quot;https://www.biendata.com/competition/zhihu/&quot;&gt;知乎看山杯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;更多应用：
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同类型的文本分类往往有不同的评价指标，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;二分类：accuracy，&lt;a href=&quot;http://www.cnblogs.com/llhthinker/p/5402870.html&quot;&gt;precision，recall，f1-score&lt;/a&gt;，...&lt;/li&gt;
&lt;li&gt;多分类: Micro-Averaged-F1， Macro-Averaged-F1, ...&lt;/li&gt;
&lt;li&gt;多标签分类：Jaccard相似系数, ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的机器学习方法主要利用自然语言处理中的n-gram概念对文本进行特征提取，并且使用TFIDF对n-gram特征权重进行调整，然后将提取到的文本特征输入到Logistics回归、SVM等分类器中进行训练。但是，上述的特征提取方法存在&lt;strong&gt;数据稀疏&lt;/strong&gt;和&lt;strong&gt;维度爆炸&lt;/strong&gt;等问题，这对分类器来说是灾难性的，并且使得训练的模型泛化能力有限。因此，往往需要采取一些策略进行降维：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;人工降维：停用词过滤，低频n-gram过滤等&lt;/li&gt;
&lt;li&gt;自动降维：LDA等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得指出的是，将深度学习中的word2vec，&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/distributed%20representations/2017-11/Distributed%20Representations%20of%20Sentences%20and%20Documents/note.md&quot;&gt;doc2vec&lt;/a&gt;作为文本特征与上文提取的特征进行融合，常常可以提高模型精度。&lt;/p&gt;

&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-10/Convolutional%20Neural%20Networks%20for%20Sentence%20Classification/note.md&quot;&gt;Convolutional Neural Networks for Sentence Classification&lt;/a&gt;提出了使用CNN进行句子分类的方法。&lt;/p&gt;
&lt;h2 id=&quot;cnn模型推导&quot;&gt;3.1 CNN模型推导&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个句子是由多个词拼接而成的，如果一个句子有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个词，且第i个词表示为&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;，词&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;通过embedding后表示为k维的向量，即&lt;span class=&quot;math inline&quot;&gt;\(x_i\in\Re^k\)&lt;/span&gt;，则一个句子&lt;span class=&quot;math inline&quot;&gt;\(x_{1:n}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(n*k\)&lt;/span&gt;的矩阵，可以形式化如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[X_{1:n}=x_1\oplus x_2\oplus \dots \oplus x_n\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一个包含&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;个的词的词窗口表示为：&lt;span class=&quot;math display&quot;&gt;\[X_{i:i+h-1}\in\Re^{hk}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一个filter是大小为&lt;span class=&quot;math inline&quot;&gt;\(h*k\)&lt;/span&gt;的矩阵，表示为:&lt;span class=&quot;math display&quot;&gt;\[W\in\Re^{hk}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;通过一个filter作用一个词窗口提取可以提取一个特征&lt;span class=&quot;math inline&quot;&gt;\(c_i\)&lt;/span&gt;，如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[c_i=f(W \cdot X_{i:i+h-1}+b)\]&lt;/span&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(b\in\Re\)&lt;/span&gt;是bias值，&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;为激活函数如Relu等。&lt;/li&gt;
&lt;li&gt;卷积操作：通过一个filter在整个句子上从句首到句尾扫描一遍，提取每个词窗口的特征，可以得到一个特征图(feature map) &lt;span class=&quot;math inline&quot;&gt;\(c\in\Re^{n-h+1}\)&lt;/span&gt;，表示如下(这里默认不对句子进行padding)：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[c= [c_1, c_2, \dots , c_{n-h+1}]\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;池化操作：对一个filter提取到的feature map进行max pooling，得到&lt;span class=&quot;math inline&quot;&gt;\(\hat{c}\in\Re\)&lt;/span&gt;即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{c}=max(c)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个filter，则通过一层卷积、一层池化后可以得到一个长度为&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;的向量&lt;span class=&quot;math inline&quot;&gt;\(z\in\Re^m\)&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[z = [\hat{c}_1, \hat{c}_2, \dots, \hat{c}_m]\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最后，将向量&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;输入到全连接层，得到最终的特征提取向量&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; (这里的&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;为全连接层的权重，注意与filter进行区分):&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[y=W \cdot z+b\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;优化cnn模型&quot;&gt;3.2 优化CNN模型&lt;/h2&gt;
&lt;h3 id=&quot;词向量&quot;&gt;3.2.1 词向量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;随机初始化 （CNN-rand）&lt;/li&gt;
&lt;li&gt;预训练词向量进行初始化，在训练过程中固定 (CNN-static)&lt;/li&gt;
&lt;li&gt;预训练词向量进行初始化，在训练过程中进行微调 (CNN-non-static)&lt;/li&gt;
&lt;li&gt;多通道(CNN-multichannel):将固定的预训练词向量和微调的词向量分别当作一个通道(channel)，卷积操作同时在这两个通道上进行，可以类比于图像RGB三通道。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-10/Convolutional%20Neural%20Networks%20for%20Sentence%20Classification/model.png&quot; alt=&quot;model&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图为模型架构示例，在示例中，句长&lt;span class=&quot;math inline&quot;&gt;\(n=9\)&lt;/span&gt;，词向量维度&lt;span class=&quot;math inline&quot;&gt;\(k=6\)&lt;/span&gt;，filter有两种窗口大小（或者说kernel size），每种有2个，因此filter总个数&lt;span class=&quot;math inline&quot;&gt;\(m=4\)&lt;/span&gt;，其中:
&lt;/li&gt;
&lt;li&gt;Dropout: 对全连接层的输入&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;向量进行dropout&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[y=W \cdot (z \circ r)+b\]&lt;/span&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(r\in\Re^m\)&lt;/span&gt;为&lt;strong&gt;masking&lt;/strong&gt;向量（每个维度值非0即1，可以通过伯努利分布随机生成），和向量&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;进行元素与元素对应相乘，让&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;向量值为0的位置对应的&lt;span class=&quot;math inline&quot;&gt;\(z\)&lt;/span&gt;向量中的元素值失效（梯度无法更新）。&lt;/li&gt;
&lt;li&gt;L2-norms: 对L2正则化项增加限制：当正则项&lt;span class=&quot;math inline&quot;&gt;\(\lVert W \rVert_2 &amp;gt; s\)&lt;/span&gt;时, 令&lt;span class=&quot;math inline&quot;&gt;\(\lVert W \rVert_2 = s\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;为超参数。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一些结论&quot;&gt;3.3 一些结论&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Multichannel vs. Single Channel Models: 虽然作者一开始认为多通道可以预防过拟合，从而应该表现更高，尤其是在小规模数据集上。但事实是，单通道在一些语料上比多通道更好；&lt;/li&gt;
&lt;li&gt;Static vs. Non-static Representations: 在大部分的语料上，CNN-non-static都优于CNN-static，一个解释：预训练词向量可能认为‘good’和‘bad’类似（可能它们有许多类似的上下文），但是对于情感分析任务，good和bad应该要有明显的区分，如果使用CNN-static就无法做调整了；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Dropout可以提高2%–4%性能(performance)；&lt;/li&gt;
&lt;li&gt;对于不在预训练的word2vec中的词，使用均匀分布&lt;span class=&quot;math inline&quot;&gt;\(U[-a,a]\)&lt;/span&gt;随机初始化，并且调整&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;使得随机初始化的词向量和预训练的词向量保持相近的方差，可以有微弱提升；&lt;/li&gt;
&lt;li&gt;可以尝试其他的词向量预训练语料，如Wikipedia[Collobert et al. (2011)]&lt;/li&gt;
&lt;li&gt;Adadelta(Zeiler, 2012)和Adagrad(Duchi et al., 2011)可以得到相近的结果，但是所需epoch更少。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;进一步思考cnn&quot;&gt;3.4 进一步思考CNN&lt;/h2&gt;
&lt;h3 id=&quot;为什么cnn能够用于文本分类nlp&quot;&gt;3.4.1 为什么CNN能够用于文本分类（NLP）？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为什么CNN能够用于文本分类（NLP）？
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/38544669&quot;&gt;filter相当于N-gram ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;filter只提取局部特征？全局特征怎么办？可以融合吗？
&lt;ul&gt;&lt;li&gt;RNN可以提取全局特征&lt;/li&gt;
&lt;li&gt;RCNN（下文说明）: RNN和CNN的结合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;超参数怎么调&quot;&gt;3.4.2 超参数怎么调？&lt;/h3&gt;
&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-10/A%20Sensitivity%20Analysis%20of%20(and%20Practitioners%E2%80%99%20Guide%20to)%20Convolutional/note.md&quot;&gt;A Sensitivity Analysis of (and Practitioners' Guide to) Convolutional Neural Networks for Sentence Classification&lt;/a&gt;提供了一些策略。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用什么样的词向量
&lt;ul&gt;&lt;li&gt;使用预训练词向量比随机初始化的效果要好&lt;/li&gt;
&lt;li&gt;采取微调策略（non-static）的效果比固定词向量（static）的效果要好&lt;/li&gt;
&lt;li&gt;无法确定用哪种预训练词向量(Google word2vec / GloVe representations)更好，不同的任务结果不同，应该对于你当前的任务进行实验；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;filter窗口大小、数量
&lt;ul&gt;&lt;li&gt;每次使用一种类型的filter进行实验，表明filter的窗口大小设置在1到10之间是一个比较合理的选择。&lt;/li&gt;
&lt;li&gt;首先在一种类型的filter大小上执行搜索，以找到当前数据集的“最佳”大小，然后探索这个最佳大小附近的多种filter大小的组合。&lt;/li&gt;
&lt;li&gt;每种窗口类型的filter对应的“最好”的filter个数(feature map数量)取决于具体数据集；&lt;/li&gt;
&lt;li&gt;但是，可以看出，当feature map数量超过600时，performance提高有限，甚至会损害performance，这可能是过多的feature map数量导致过拟合了；
&lt;ul&gt;&lt;li&gt;在实践中，100到600是一个比较合理的搜索空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;激活函数 (tanh, relu, ...)
&lt;ul&gt;&lt;li&gt;Sigmoid, Cube, and tanh cube相较于Relu和Tanh的激活函数，表现很糟糕；&lt;/li&gt;
&lt;li&gt;tanh比sigmoid好，这可能是由于tanh具有zero centering property(过原点);&lt;/li&gt;
&lt;li&gt;与Sigmoid相比，ReLU具有&lt;strong&gt;非饱和形式(a non-saturating form)&lt;/strong&gt;的优点，并能够加速SGD的收敛。&lt;/li&gt;
&lt;li&gt;对于某些数据集，线性变换(Iden，即不使用非线性激活函数)足够捕获词嵌入与输出标签之间的相关性。（但是如果有多个隐藏层，相较于非线性激活函数，Iden就不太适合了，因为完全用线性激活函数，即使有多个隐藏层，组合后整个模型还是线性的，表达能力可能不足，无法捕获足够信息）；&lt;/li&gt;
&lt;li&gt;因此，建议首先考虑ReLU和tanh，也可以尝试Iden&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;池化策略：最大池化就是最好的吗
&lt;ul&gt;&lt;li&gt;对于句子分类任务，1-max pooling往往比其他池化策略要好；&lt;/li&gt;
&lt;li&gt;这可能是因为上下文的具体位置对于预测Label可能并不是很重要，而句子某个具体的n-gram(1-max pooling后filter提取出来的的特征)可能更可以刻画整个句子的某些含义，对于预测label更有意义；&lt;/li&gt;
&lt;li&gt;(但是在其他任务如&lt;strong&gt;释义识别&lt;/strong&gt;，k-max pooling可能更好。)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正则化
&lt;ul&gt;&lt;li&gt;0.1到0.5之间的非零dropout rates能够提高一些performance（尽管提升幅度很小），具体的最佳设置取决于具体数据集；&lt;/li&gt;
&lt;li&gt;对l2 norm加上一个约束往往不会提高performance（除了Opi数据集）；&lt;/li&gt;
&lt;li&gt;当feature map的数量大于100时，可能导致过拟合，影响performance，而dropout将减轻这种影响；&lt;/li&gt;
&lt;li&gt;在卷积层上进行dropout帮助很小，而且较大的dropout rate对performance有坏的影响。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;字符级别的cnn用于文本分类&quot;&gt;3.5 字符级别的CNN用于文本分类&lt;/h2&gt;
&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-10/Character-level%20Convolutional%20Networks%20for%20Text%20Classification/note.md&quot;&gt;Character-level convolutional networks for text classification&lt;/a&gt;将文本看成字符级别的序列，使用字符级别（Character-level）的CNN进行文本分类。&lt;/p&gt;
&lt;h3 id=&quot;字符级cnn的模型设计&quot;&gt;3.5.1 字符级CNN的模型设计&lt;/h3&gt;
&lt;p&gt;首先需要对字符进行数字化（quantization）。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义字母表(Alphabet)：大小为&lt;span class=&quot;math inline&quot;&gt;\(m​\)&lt;/span&gt; (对于英文&lt;span class=&quot;math inline&quot;&gt;\(m=70​\)&lt;/span&gt;，如下图，之后会考虑将大小写字母都包含在内作为对比)&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-10/Character-level%20Convolutional%20Networks%20for%20Text%20Classification/alphabet.png&quot; alt=&quot;alphabet&quot;/&gt;&lt;/li&gt;
&lt;li&gt;字符数字化（编码）： &quot;one-hot&quot;编码&lt;/li&gt;
&lt;li&gt;序列（文本）长度：&lt;span class=&quot;math inline&quot;&gt;\(l_0\)&lt;/span&gt; (定值)&lt;br/&gt;然后论文设计了两种类型的卷积网络：Large和Small（作为对照实验）&lt;/li&gt;
&lt;li&gt;它们都有9层，其中6层为卷积层(convolutional layer)；3层为全连接层(fully-connected layer)：&lt;/li&gt;
&lt;li&gt;Dropout的概率都为0.5&lt;/li&gt;
&lt;li&gt;使用高斯分布(Gaussian distribution)对权重进行初始化：&lt;/li&gt;
&lt;li&gt;最后一层卷积层单个filter输出特征长度(the output frame length)为 &lt;span class=&quot;math inline&quot;&gt;\(l_6 = (l_0 - 96) / 27\)&lt;/span&gt;，推&lt;/li&gt;
&lt;li&gt;第一层全连接层的输入维度(其中1024和256为filter个数或者说frame/feature size):
&lt;ul&gt;&lt;li&gt;Large: &lt;span class=&quot;math inline&quot;&gt;\(l_6 * 1024\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Small: &lt;span class=&quot;math inline&quot;&gt;\(l_6 * 256\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;下图为模型的一个图解示例。其中文本长度为10，第一层卷积的kernel size为3（半透明黄色正方形），卷积个数为9（Feature=9），步长为1，因此Length=10-3+1=8，然后进行非重叠的max-pooling（即pooling的stride=size），pooling size为2，因此池化后的Length = 8 / 2 = 4。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-10/Character-level%20Convolutional%20Networks%20for%20Text%20Classification/model.png&quot; alt=&quot;model&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字符级cnn的相关总结与思考&quot;&gt;3.5.2 字符级CNN的相关总结与思考&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字符级CNN是一个有效的方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据集的大小可以为选择传统方法还是卷积网络模型提供指导&lt;/strong&gt;：对于几百上千等小规模数据集，可以优先考虑传统方法，对于百万规模的数据集，字符级CNN开始表现不错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符级卷积网络很适用于用户生成数据(user-generated data)&lt;/strong&gt;（如拼写错误，表情符号等），&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有免费的午餐(There is no free lunch)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中文怎么办&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将字符级和词级进行结合是否结果更好&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;英文如何结合&lt;/li&gt;
&lt;li&gt;中文如何结合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用同义词表进行数据增强&quot;&gt;3.5.3 使用同义词表进行数据增强&lt;/h3&gt;
&lt;p&gt;对于深度学习模型，采用适当的&lt;strong&gt;数据增强&lt;/strong&gt;(Data Augmentation)技术可以提高模型的泛化能力。数据增强在计算机视觉领域比较常见，例如对图像进行旋转，适当扭曲，随机增加噪声等操作。对于NLP，最理想的数据增强方法是使用人类复述句子（human rephrases of sentences），但是这比较不现实并且对于大规模语料来说代价昂贵。&lt;br/&gt;一个更自然的选择是使用词语或短语的同义词或同义短语进行替换，从而达到数据增强的目的。具体做法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;英文同义词典: from the &lt;em&gt;mytheas&lt;/em&gt; component used in LibreOffice1 project. &lt;a href=&quot;http://www.libreoffice.org/&quot; class=&quot;uri&quot;&gt;http://www.libreoffice.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;从给定的文本中抽取出所有可以替换的词，然后随机选择&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;个进行替换，其中&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;由一个参数为&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;的几何分布(geometric distribution)确定，即&lt;span class=&quot;math inline&quot;&gt;\(P[r] \sim p^r\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;给定一个待替换的词，其同义词可能有多个（一个列表），选择第&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;个的概率也通过另一个几何分布确定，即&lt;span class=&quot;math inline&quot;&gt;\(P[s] \sim q^s\)&lt;/span&gt;。这样是为了当前词的同义词列表中的距离较远(&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;较大)的同义词被选的概率更小。&lt;/li&gt;
&lt;li&gt;论文实验设置: &lt;span class=&quot;math inline&quot;&gt;\(p=0.5, q=0.5\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;策略1：直接使用RNN的最后一个单元输出向量作为文本特征&lt;/li&gt;
&lt;li&gt;策略2：使用双向RNN的两个方向的输出向量的连接（concatenate）或均值作为文本特征&lt;/li&gt;
&lt;li&gt;策略3：将所有RNN单元的输出向量的均值pooling或者max-pooling作为文本特征&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-10/Character-level%20Convolutional%20Networks%20for%20Text%20Classification/lstm.png&quot; alt=&quot;lstm&quot;/&gt;&lt;/li&gt;
&lt;li&gt;策略4：层次RNN+Attention, &lt;a href=&quot;https://www.cs.cmu.edu/~diyiy/docs/naacl16.pdf&quot;&gt;Hierarchical Attention Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-10/Recurrent%20Convolutional%20Neural%20Networks%20for%20Text%20Classification/note.md&quot;&gt;Recurrent Convolutional Neural Networks for Text Classification&lt;/a&gt;设计了一种RNN和CNN结合的模型用于文本分类。&lt;/p&gt;
&lt;h2 id=&quot;rcnn模型推导&quot;&gt;5.1 RCNN模型推导&lt;/h2&gt;
&lt;h3 id=&quot;词表示学习&quot;&gt;5.1.1 词表示学习&lt;/h3&gt;
&lt;p&gt;使用双向RNN分别学习当前词&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的左上下文表示&lt;span class=&quot;math inline&quot;&gt;\(c_l(w_i)\)&lt;/span&gt;和右上下文表示&lt;span class=&quot;math inline&quot;&gt;\(c_r(w_i)\)&lt;/span&gt;，再与当前词自身的表示&lt;span class=&quot;math inline&quot;&gt;\(e(w_i)\)&lt;/span&gt;连接，构成卷积层的输入&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;。具体如下:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} c_l(w_i) = f(W^{(l)}c_l(w_{i-1})+W^{(sl)}e(w_{i-1})) ; \\ c_r(w_i) = f(W^{(r)}c_r(w_{i-1})+W^{(sr)}e(w_{i-1})) ; \\ x_i = [c_l(w_i);e(w_i);c_r(w_i)] ; \\ \end{align} \]&lt;/span&gt;&lt;br/&gt;然后将&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;作为&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的表示，输入到激活函数为tanh,kernel size为1的卷积层，得到&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的潜在语义向量(latent semantic vector) $y^{(2)}_i=tanh(W^{(2)}x_i+b^{(2)}) $&lt;br/&gt;将kernel size设置为1是因为&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;中已经包含&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;左右上下文的信息，无需再使用窗口大于1的filter进行特征提取。但是需要说明的是，在实践中仍然可以同时使用多种kernel size的filter，如[1, 2, 3]，可能取得更好的效果，一种可能的解释是窗口大于1的filter强化了&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的左右最近的上下文信息。此外，实践中可以使用更复杂的RNN来捕获&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的上下文信息如LSTM和GRU等。&lt;/p&gt;
&lt;h3 id=&quot;文本表示学习&quot;&gt;5.1 2 文本表示学习&lt;/h3&gt;
&lt;p&gt;经过卷积层后，获得了所有词的表示，然后在经过最大池化层和全连接层得到文本的表示，最后通过softmax层进行分类。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Max-pooling layer: &lt;span class=&quot;math inline&quot;&gt;\(y^{(3)}=\max \limits_{i=1}^{n} y^{(2)}_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Fully connected layer: &lt;span class=&quot;math inline&quot;&gt;\(y^{(4)}=W^{(4)}y^{(3)}+b^{(4)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Softmax layer: &lt;span class=&quot;math inline&quot;&gt;\(p_i=\frac{\exp(y^{(4)}_i)}{\sum_{k=1}^n \exp(y^{(4)}_k)}\)&lt;/span&gt;&lt;br/&gt;下图为上述过程的一个图解:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-10/Recurrent%20Convolutional%20Neural%20Networks%20for%20Text%20Classification/model.png&quot; alt=&quot;model&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;rcnn相关总结&quot;&gt;5.2 RCNN相关总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NN vs. traditional methods: 在该论文的所有实验数据集上，神经网络比传统方法的效果都要好&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convolution-based vs. RecursiveNN: 基于卷积的方法比基于递归神经网络的方法要好&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RCNN vs. CFG and C&amp;amp;J: The RCNN可以捕获更长的模式(patterns)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RCNN vs. CNN: 在该论文的所有实验数据集上，RCNN比CNN更好&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNNs使用固定的词窗口(window of words), 实验结果受窗口大小影响&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RCNNs使用循环结构捕获广泛的上下文信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述的深度学习方法通过引入CNN或RNN进行特征提取，可以达到比较好的效果，但是也存在一些问题，如参数较多导致训练时间过长，超参数较多模型调整麻烦等。下面两篇论文提出了一些简单的模型用于文本分类，并且在简单的模型上采用了一些优化策略。&lt;/p&gt;
&lt;h2 id=&quot;深层无序组合方法&quot;&gt;6.1 深层无序组合方法&lt;/h2&gt;
&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-11/Deep%20Unordered%20Composition%20Rivals%20Syntactic%20Methods%20for%20Text%20Classification/note.md&quot;&gt;Deep Unordered Composition Rivals Syntactic Methods for Text Classification&lt;/a&gt;提出了&lt;strong&gt;NBOW&lt;/strong&gt;(Neural Bag-of-Words)模型和&lt;strong&gt;DAN&lt;/strong&gt;(Deep Averaging Networks)模型。对比了&lt;strong&gt;深层无序组合方法&lt;/strong&gt;(Deep Unordered Composition)和&lt;strong&gt;句法方法&lt;/strong&gt;(Syntactic Methods)应用在文本分类任务中的优缺点，强调深层无序组合方法的有效性、效率以及灵活性。&lt;/p&gt;
&lt;h3 id=&quot;neural-bag-of-words-models&quot;&gt;6.1.1 Neural Bag-of-Words Models&lt;/h3&gt;
&lt;p&gt;论文首先提出了一个最简单的无序模型Neural Bag-of-Words Models (&lt;strong&gt;NBOW&lt;/strong&gt; model)。该模型直接将文本中所有词向量的平均值作为文本的表示，然后输入到softmax 层，形式化表示如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Word embedding average : &lt;span class=&quot;math inline&quot;&gt;\(z=g(w \in X)=\frac{1}{X} \sum\limits_{w \in X} v_w\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Softmax Layer: &lt;span class=&quot;math inline&quot;&gt;\(\hat{y} = softmax(W_s \cdot z + b)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Loss function: cross-entropy error, $\iota(\hat{y}) =\sum\limits_{p=1}^{k}y_p\log(\hat{y_p}) $&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;considering-syntax-for-composition&quot;&gt;6.1.2 Considering Syntax for Composition&lt;/h3&gt;
&lt;p&gt;一些考虑语法的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Recursive neural networks (&lt;strong&gt;RecNNs&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;可以考虑一些复杂的语言学现象，如否定、转折等 (&lt;strong&gt;优点&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;实现效果依赖输入序列（文本）的句法树（可能不适合长文本和不太规范的文本）&lt;/li&gt;
&lt;li&gt;需要更多的训练时间&lt;/li&gt;
&lt;li&gt;Using a convolutional network instead of a RecNN&lt;/li&gt;
&lt;li&gt;时间复杂度同样比较大，甚至更大（通过实验结果得出的结论，这取决于filter大小、个数等超参数的设置）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;deep-averaging-networks&quot;&gt;6.1.3 Deep Averaging Networks&lt;/h3&gt;
&lt;p&gt;Deep Averaging Networks (&lt;strong&gt;DAN&lt;/strong&gt;)是在&lt;strong&gt;NBOW&lt;/strong&gt; model的基础上，通过增加多个隐藏层，增加网络的深度(Deep)。下图为带有两层隐藏层的DAN与RecNN模型的对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-11/Deep%20Unordered%20Composition%20Rivals%20Syntactic%20Methods%20for%20Text%20Classification/DAN.png&quot; alt=&quot;DAN&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;word-dropout-improves-robustness&quot;&gt;6.1.4 Word Dropout Improves Robustness&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;针对DAN模型，论文提出一种word dropout策略：在求平均词向量前，随机使得文本中的某些单词(token)失效。形式化表示如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} r_w \sim Bernoulli(p) ; \\ \hat{X} = \{w|w \in X and r_w &amp;gt; 0\} ; \\ z = g(w \in X ) = \frac{\sum_{w \in \hat{X}}v_w}{|\hat{X}|} ; \\ \end{align} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Word Dropout可能会使得某些非常重要的token失效。然而，使用word dropout往往确实有提升，这可能是因为，一些对标签预测起到关键性作用的word数量往往小于无关紧要的word数量。例如，对于情感分析任务，中立(neutral)的单词往往是最多的。&lt;/li&gt;
&lt;li&gt;Word dropout 同样可以用于其他基于神经网络的方法。&lt;/li&gt;
&lt;li&gt;Word Dropout或许起到了类似数据增强(Data Augmentation)的作用?&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;fasttext&quot;&gt;6.2 fastText&lt;/h2&gt;
&lt;p&gt;论文&lt;a href=&quot;https://github.com/llhthinker/NLP-Papers/blob/master/text%20classification/2017-09/Bag%20of%20Tricks%20for%20Efficient%20Text%20Classification/note.md&quot;&gt;Bag of Tricks for Efficient Text Classification&lt;/a&gt;提出一个快速进行文本分类的模型和一些trick。&lt;/p&gt;
&lt;h3 id=&quot;fasttext模型架构&quot;&gt;6.2.1 fastText模型架构&lt;/h3&gt;
&lt;p&gt;fastText模型直接对所有进行embedded的特征取均值，作为文本的特征表示，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/NLP-Papers/master/text%20classification/2017-09/Bag%20of%20Tricks%20for%20Efficient%20Text%20Classification/model.png&quot; alt=&quot;model&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;6.2.2 特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当类别数量较大时，使用Hierachical Softmax&lt;/li&gt;
&lt;li&gt;将N-gram融入特征中，并且使用Hashing trick&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=1553516&quot;&gt;[Weinberger et al.2009]&lt;/a&gt;提高效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;br/&gt;[1] Le and Mikolov - 2014 - Distributed representations of sentences and documents&lt;br/&gt;[2] Kim - 2014 - Convolutional neural networks for sentence classification&lt;br/&gt;[3] Zhang and Wallace - 2015 - A Sensitivity Analysis of (and Practitioners' Guide to) Convolutional Neural Networks for Sentence Classification&lt;br/&gt;[4] Zhang et al. - 2015 - Character-level convolutional networks for text classification&lt;br/&gt;[5] Lai et al. - 2015 - Recurrent Convolutional Neural Networks for Text Classification&lt;br/&gt;[6] Iyyer et al. - 2015 - Deep unordered composition rivals syntactic methods for Text Classification&lt;br/&gt;[7] Joulin et al. - 2016 - Bag of tricks for efficient text classification&lt;br/&gt;[8] Liu and Lapata - 2017 - Learning Structured Text Representations&lt;br/&gt;[9] Yin and Schütze - 2017 - Attentive Convolution&lt;br/&gt;[10] Zhang et al. - 2017 - Multi-Task Label Embedding for Text Classification&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 04:55:00 +0000</pubDate>
<dc:creator>llhthinker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/llhthinker/p/8127788.html</dc:identifier>
</item>
<item>
<title>采用Opserver来监控你的ASP.NET项目系列(三、监控你的服务器状态) - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/8135096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/8135096.html</guid>
<description>&lt;p&gt;&lt;span&gt;前&lt;/span&gt;&lt;span&gt;言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前有过2篇关于&lt;a href=&quot;http://www.cnblogs.com/GuZhenYin/p/7170010.html&quot; target=&quot;_blank&quot;&gt;如何监控ASP.NET core项目&lt;/a&gt;的文章,有兴趣的也可以看看.&lt;/p&gt;

&lt;p&gt;今天我们主要来介绍一下,如何使用Opserver监控我们的服务器状态.&lt;/p&gt;
&lt;p&gt;Opserver的功能其实很强大,他可以用于连接任何支持Bosun, Orion, or direct WMI监控数据。&lt;/p&gt;
&lt;p&gt;大概效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201712/653851-20171228121259472-1811186895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.通过Windows自带的WMI监控服务器&lt;/h2&gt;
&lt;p&gt;首先,我们找到相关的配置文件,修改配置文件的名称 &lt;code&gt;DashboardSettings.json.example&lt;/code&gt; 为 &lt;code&gt;DashboardSettings.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;然后修改DashboardSettings.json设置连接地址&lt;/code&gt; &lt;code&gt;providers,这里我们以WMI为例,如下:&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;providers&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;wmi&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;nodes&quot;: [ &quot;USER-20170316IW&quot; ], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; List of nodes to monitor&lt;/span&gt;
      &quot;staticDataTimeoutSeconds&quot;: 300, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (Optional) How long to cache static data (node name, hardware, etc.) - defaults to 5 minutes&lt;/span&gt;
      &quot;dynamicDataTimeoutSeconds&quot;: 5, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (Optional) How long to cache dynamic data (utilizations, etc.) - defaults to 30 seconds&lt;/span&gt;
      &quot;historyHours&quot;: 2, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (Optional) How long to retain data (in memory) - defaults to 24 hours&lt;/span&gt;
      &quot;username&quot;: &quot;Administrator&quot;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释一下参数说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;nodes&lt;/code&gt; 可以有多台，可以填 服务器名称 或是 IP地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StaticDataTimeoutSeconds&lt;/code&gt; 缓存静态数据（节点名称、硬件等）要多长时间-默认为5分钟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DynamicDataTimeoutSeconds&lt;/code&gt; 缓存动态数据（CPU,加载时间等）要多长时间-默认为30秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HistoryHours&lt;/code&gt; 保留记录的时长，默认为 2 小时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Username&lt;/code&gt; 远程服务器的账户名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Password&lt;/code&gt; 远程服务器的密码(PS,我这里因为连接的是本机 所以就不需要了.)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置完连接之后,我们可以设置我们的警戒值,如下:&lt;/p&gt;
&lt;p&gt;設定警戒值&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;cpuWarningPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cpu 用量警戒(黄色)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;cpuCriticalPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;cpu 用量危险(红色)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;memoryWarningPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内存用量警戒(黄色)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;memoryCriticalPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内存用量危险(红色)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;diskWarningPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;磁盘空间 用量警戒(黄色)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;diskCriticalPercent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;磁盘空间 用量危险(红色)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;JSON配置直接添加在providers节点下即可.&lt;/p&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&quot;providers&quot;&lt;span&gt;:{
 &lt;/span&gt;&quot;cpuWarningPercent&quot;: 50&lt;span&gt;,
  &lt;/span&gt;&quot;cpuCriticalPercent&quot;: 60&lt;span&gt;,
  &lt;/span&gt;&quot;memoryWarningPercent&quot;: 90&lt;span&gt;,
  &lt;/span&gt;&quot;memoryCriticalPercent&quot;: 95&lt;span&gt;, 
  &lt;/span&gt;&quot;diskWarningPercent&quot;: 85&lt;span&gt;,
  &lt;/span&gt;&quot;diskCriticalPercent&quot;: 95&lt;span&gt;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多台服务器的情况下,服务器的配置不一定相同,所以需要根据服务器配置 单独设置报警值,我们可以添加categories节点,并配置如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&quot;categories&quot;&lt;span&gt;: [
    {
     &lt;/span&gt;&quot;name&quot;: &quot;第一台&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Name for this group of servers&lt;/span&gt;
     &quot;pattern&quot;: &quot;-sql&quot;,
     &quot;cpuWarningPercent&quot;: 20, 
     &quot;cpuCriticalPercent&quot;: 60,
      &quot;memoryWarningPercent&quot;: 98, 
     &quot;memoryCriticalPercent&quot;: 99.2
&lt;span&gt; },
     &lt;/span&gt;&quot;name&quot;: &quot;第二台&quot;, 
     &quot;pattern&quot;: &quot;-sql&quot;, 
     &quot;cpuWarningPercent&quot;: 20, 
     &quot;cpuCriticalPercent&quot;: 60,
      &quot;memoryWarningPercent&quot;: 98,
     &quot;memoryCriticalPercent&quot;: 99.2
&lt;span&gt; }
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样,我们就完成了我们使用WMI采集信息,并展示在OpServer上的全部工作.&lt;/p&gt;
&lt;p&gt;当然,官方推荐的是使用bosun +scollector+OpServer的形式来采集和显示&lt;/p&gt;
&lt;p&gt;所以,我们下面就来讲讲(不过我本人并没有实践..资源实在有限)&lt;/p&gt;
&lt;h2&gt;2.通过bosun +scollector监控服务器&lt;/h2&gt;
&lt;p&gt;1、bosun 快速安装&lt;strong&gt;(当然,也有不使用Docker的..不过说实话..太复杂了..也许就是因为太复杂了,才放到容器里简化安装了吧)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;     安装docker&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      ..具体我就不说了，直接移步安装步骤官网:https://docs.docker.com/engine/installation/&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;     在docker中安装bosun&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     使用命令“&lt;code&gt;docker run -d -p 4242:4242 -p 8070:8070 stackexchange/bosun&lt;/code&gt;”，安装bosun,文件大概200多M，等待完成即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;     检查是否安装成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     访问网站http://docker-server-ip:8070，显示bosun界面，即安装成功。此时，本机监控数据已经被采集，可以查看相应数据。&lt;/p&gt;

&lt;p&gt;2、服务器agent数据采集器（scollector)&lt;/p&gt;
&lt;p&gt;   可以到 http://bosun.org/scollector/   下载scollector.&lt;/p&gt;
&lt;p&gt;    以windows 为例，下载“scollector-windows-amd64.exe&quot;后，用管理员身份运行”cmd.exe&quot;。cd 到文件目录，在命令窗口输入“scollector-windows-amd64 -h  docker-server-ip:8070&quot;&lt;/p&gt;
&lt;p&gt;    显示如下信息，表示与bosun服务建立连接。命令如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
C:\&amp;gt;scollector-windows-amd64 -h 192.168.1.101:8070
2016/11/18 15:59:19 info: main.go:213: OpenTSDB host: http://192.168.1.101:8070
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可在bosun items 界面看到此服务器信息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;至此我们就完成了监控服务器的所有操作.喜欢的请关注一下,~觉得不错的可以点个推荐,当然也欢迎大神批评指正.~&lt;/p&gt;
</description>
<pubDate>Thu, 28 Dec 2017 04:41:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/8135096.html</dc:identifier>
</item>
</channel>
</rss>