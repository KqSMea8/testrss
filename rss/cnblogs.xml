<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于会计科目 - 慵懒渔夫</title>
<link>http://www.cnblogs.com/wisever/p/9385528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wisever/p/9385528.html</guid>
<description>&lt;p&gt;日前跟同事聊起会计科目的问题，大家居然一致认为应该按照金蝶自带的科目体系来设置。但我认为默认的体系只是为了方便快速上线的一套会计科目，要想体现顾问的价值，还是应该用心为客户定制一套专属科目。说到底，顾问的价值在于让客户更好地受益于ERP软件。&lt;/p&gt;
&lt;p&gt;标准体系中的资产负债类科目的个性化空间不大，可以根据需要增加以下科目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在其他应收、其他应付分别增设客户、供应商、职员、关联公司几个科目。因为这几个科目挂接的是不同的核算项目；&lt;/li&gt;
&lt;li&gt;应付账款下可以增加一个固定资产类的科目。这是为了自动出现金流量表；&lt;/li&gt;
&lt;li&gt;应收账款、应付账款下分别增加关联交易科目。这是为了合并报表的方便。之前的公司还区分了国内关联公司、和国外关联公司。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里要着重说明的是损益类科目。6001-6999近1000个号码段 只有16个科目，作为重头戏的销售、管理费用居然只占用了两个代码位。欲知详情如何，且看二级科目。国家的科目体系肯定是无法规范每个费用科目，但如果实施顾问也认同所有费用科目需要通过二级科目来表现，就有些说不过去了。无论是录入凭证还是查询，大家都要输入无用的一级科目代码。是的，就是无用的。现在的软件都支持会计科目与核算项目-部门的组合了，我们还需要两个专门的一级科目来区分销售、管理费用吗？&lt;/p&gt;
&lt;p&gt;以下示例，供大家参考。前两位代码是费用类别，可以根据出相应的费用汇总报告。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394051/201807/1394051-20180729153804236-1029642615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 29 Jul 2018 07:42:00 +0000</pubDate>
<dc:creator>慵懒渔夫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wisever/p/9385528.html</dc:identifier>
</item>
<item>
<title>微信通讯录不见了？或者只显示部分？删掉它就解决了！ - LY客栈</title>
<link>http://www.cnblogs.com/lykezhan/p/9385529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lykezhan/p/9385529.html</guid>
<description>&lt;p&gt;微信的通讯录显示不全，只有部分或者都不见了，这种情况，一般是一个电脑有几个微信版本造成的！&lt;/p&gt;
&lt;p&gt;    今天下午，有个同事居然还用着1.5版本的微信，而现在最新的已经是2.6版本的了，也是服了，还出现微信的图片发不出去，按回车，图片就不见了，这个问题，升级到最新版微信就可以了，但是通讯录问题，却是不能解决，我研究了下，删掉以下文件夹，问题就可以完美解决了！&lt;/p&gt;
&lt;p&gt;    删掉文件夹路径为“C:\User\Administrator\Documents\WeChat Files\”，目录下以你的微信号命名的文件夹，重新登录即可！（有重要文件或者聊天记录自行备份）&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;1532848886453206.png&quot; src=&quot;http://blog.lykezhan.com/ueditor/php/upload/image/20180729/1532848886453206.png&quot; alt=&quot;&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;


&lt;p&gt;本文章已参与维权行动，如需转载请与我联系沟通！谢谢！&lt;/p&gt;
&lt;p&gt;本文出自LY客栈-袁建军-博客：微信通讯录不见了？或者只显示部分？删掉它就解决了！，原文网址：http://blog.lykezhan.com/jishu/biji/2018/0729/378.html &lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 07:42:00 +0000</pubDate>
<dc:creator>LY客栈</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lykezhan/p/9385529.html</dc:identifier>
</item>
<item>
<title>JQuery强大的操控标签能力 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/9385473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/9385473.html</guid>
<description>&lt;p&gt;&lt;span&gt;jquery选择器 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;$(&quot;#myId&quot;)          选择id为myId的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;.myClass&quot;)     选择class为myClass的元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;li&quot;)　　　　　选择所有的li元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;#ul1 li span&quot;)   选择id为ul1元素下面的所有li下的span元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;input[name=first]&quot;)  选择name属性为first的input元素&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;选择器的过滤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;$(&quot;div&quot;).has(&quot;p&quot;)                  选择包含p元素的div元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;div&quot;).not(&quot;.myClass&quot;)     选择class不等于myClass的div元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 $(&quot;div&quot;).eq(5)                     选择第6个div元素&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;选择器转移&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;$(&quot;#box&quot;).prev()       选择id是box的元素前面紧挨的同辈元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).prevAll()   选择id是box的元素之前所有的同辈元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).next()       选择id是box的元素后面紧挨的同辈元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).nextAll()   选择id是box的元素后面所有的同辈元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).parent()    选择id是box的元素的父元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).children()   选择id是box的元素的所有子元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).siblings()    选择id是box的元素的同级元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#box&quot;).find(&quot;.myClass&quot;)   选择id是box的元素内的class等于myClass的元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断是否选中元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;用length属性来判断是否找到了元素,length等于0，就是没选择到元素，length大于0，就是选择到了元素。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var $div1 = $(&quot;#div1&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 alert($div1.length)    弹出1表示选中了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;jQuery操作样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;// 获取div的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;div&quot;).css(&quot;width&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;div&quot;).css(&quot;color&quot;)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　//设置div的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;div&quot;).css(&quot;width&quot;, &quot;30px&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;div&quot;).css(&quot;height&quot;, &quot;30px&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;div&quot;).css({fontSize:&quot;30px&quot;, color:&quot;red&quot;})&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;$(&quot;#div1&quot;).addClass(&quot;divClass2&quot;)    为id为div1的对象追加样式divClass2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#div1&quot;).removeClass(&quot;divClass&quot;)    移除id为div1的对象的class名为divClass的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#div1&quot;).removeClass(&quot;divClass divClass2&quot;)   移除多个样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$(&quot;#div1&quot;).toggleClass(&quot;anotherClass&quot;)      重复切换anotherClass样式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;code&gt;　&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jQuery操作属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1、html() 取出或设置html内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　// 取出html内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var $htm = $('#div1').html()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　// 设置html内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$('#div1').html('&amp;lt;span&amp;gt;添加文字&amp;lt;/span&amp;gt;')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　2、prop() 取出或设置某个属性的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　// 取出图片的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var $src = $('#img1').prop('src')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　// 设置图片的地址和alt属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　$('#img1').prop({src: &quot;test.jpg&quot;, alt: &quot;Test Image&quot; })&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 操作value属性可以使用封装好的方法  val()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. 操作自定义属性使用 attr()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;code&gt;　　&lt;/code&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 07:34:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skaarl/p/9385473.html</dc:identifier>
</item>
<item>
<title>vue.js table组件封装 - 风随心动*</title>
<link>http://www.cnblogs.com/husfBK/p/9385429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/husfBK/p/9385429.html</guid>
<description>&lt;p&gt;&lt;strong&gt;table组件 和 分页组件来自iview，在这里我根据公司业务再次做了一次封装，使用slot进行内容分发，可以随意放置input输入框和button按钮 ，再使用props向子组件传递参数，使用emit属性向父组件传递事件，代码如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《子组件》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;template&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&quot;search-bar run-search-bar&quot; style=&quot;background:none;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- align=&quot;right&quot; style=&quot;margin:5px&quot; --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;slot name=&quot;handle-bar&quot;&amp;gt;&amp;lt;/slot&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;slot name=&quot;search-bar&quot;&amp;gt;&amp;lt;/slot&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&quot;single-table-con&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&quot;table-bar&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;slot name=&quot;table-bar&quot;&amp;gt;&amp;lt;/slot&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Table size=&quot;small&quot; ref=&quot;table&quot; :loading=&quot;loading&quot; @on-current-change=&quot;onCurrentChange&quot; :highlight-row=&quot;highlightRow&quot; :data=&quot;tableData&quot; :columns=&quot;tableColumns&quot; @on-selection-change=&quot;selectionChange&quot; @on-sort-change=&quot;sortHandle&quot; @on-row-click=&quot;rowClickHandle&quot; stripe&amp;gt;&amp;lt;/Table&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;margin: 10px;overflow: hidden&quot; v-if=&quot;isPage&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div style=&quot;float: right;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Page :placement=&quot;placement&quot; :total=&quot;total&quot; :show-total=&quot;showTotal&quot; :page-size-opts=&quot;pageSizeOpts&quot; :show-sizer=&quot;showSizer&quot; :page-size=&quot;param.page.pageSize&quot; :current=&quot;param.page.currentPage&quot; @on-change=&quot;changePage&quot; size=&quot;small&quot; @on-page-size-change=&quot;changePageSize&quot;&amp;gt;&amp;lt;/Page&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/template&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script&amp;gt;&lt;/p&gt;
&lt;p&gt;export default {&lt;/p&gt;
&lt;p&gt;name: &quot;EasyVueTable&quot;,&lt;/p&gt;
&lt;p&gt;components: {},&lt;/p&gt;
&lt;p&gt;props: {&lt;/p&gt;
&lt;p&gt;resource: {&lt;/p&gt;
&lt;p&gt;type: Array,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return [];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;useCatch: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return false;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;catchParams: {&lt;/p&gt;
&lt;p&gt;type: Object,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return {};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;highlightRow: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return false;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;action: {&lt;/p&gt;
&lt;p&gt;type: String,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return &quot;&quot;;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;params: {&lt;/p&gt;
&lt;p&gt;type: Object,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return {};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;server: {&lt;/p&gt;
&lt;p&gt;type: Object,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return {};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;columns: {&lt;/p&gt;
&lt;p&gt;type: Array,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return [];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;columnsFn: {&lt;/p&gt;
&lt;p&gt;type: Function&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;initParam: {&lt;/p&gt;
&lt;p&gt;type: Object,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return {};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;loadCallback: {&lt;/p&gt;
&lt;p&gt;type: Function,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return function(data) {&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;autoFirst: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return true;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;pageSize: {&lt;/p&gt;
&lt;p&gt;type: Number,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return 10;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;showTotal: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return true;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;showSizer: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return true;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;pageSizeOpts: {&lt;/p&gt;
&lt;p&gt;type: Array,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return [10, 20, 50, 100];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;isPage: {&lt;/p&gt;
&lt;p&gt;type: Boolean,&lt;/p&gt;
&lt;p&gt;default() {&lt;/p&gt;
&lt;p&gt;return true;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;onSelectionChange: {&lt;/p&gt;
&lt;p&gt;type: Function&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;rowClickHandle: {&lt;/p&gt;
&lt;p&gt;type: Function&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;data() {&lt;/p&gt;
&lt;p&gt;return {&lt;/p&gt;
&lt;p&gt;tableData: [],&lt;/p&gt;
&lt;p&gt;tableColumns: [],&lt;/p&gt;
&lt;p&gt;total: 0,&lt;/p&gt;
&lt;p&gt;currentPage: 1,&lt;/p&gt;
&lt;p&gt;selection: [],&lt;/p&gt;
&lt;p&gt;loading: false,&lt;/p&gt;
&lt;p&gt;param: {&lt;/p&gt;
&lt;p&gt;page: {&lt;/p&gt;
&lt;p&gt;currentPage: 1,&lt;/p&gt;
&lt;p&gt;// pageNum: 0,&lt;/p&gt;
&lt;p&gt;pageSize: this.pageSize&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;params: this.params,&lt;/p&gt;
&lt;p&gt;sortDTO: {&lt;/p&gt;
&lt;p&gt;fieldName: &quot;&quot;,&lt;/p&gt;
&lt;p&gt;orderBy: &quot;&quot;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;messageJob: undefined,&lt;/p&gt;
&lt;p&gt;isSelectionChange: false,&lt;/p&gt;
&lt;p&gt;currentRow: undefined&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;computed: {&lt;/p&gt;
&lt;p&gt;placement() {&lt;/p&gt;
&lt;p&gt;let pageTotal = 0;&lt;/p&gt;
&lt;p&gt;if (this.total % this.pageSize == 0) {&lt;/p&gt;
&lt;p&gt;pageTotal = this.total / this.pageSize;&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;pageTotal = this.total / this.pageSize + 1;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;pageTotal = parseInt(pageTotal);&lt;/p&gt;
&lt;p&gt;return this.total % this.pageSize &amp;lt; 3 &amp;amp;&amp;amp; this.currentPage == pageTotal&lt;/p&gt;
&lt;p&gt;? &quot;bottom&quot;&lt;/p&gt;
&lt;p&gt;: &quot;top&quot;;&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;lang() {&lt;/p&gt;
&lt;p&gt;return $store.state.lang;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;created: function() {&lt;/p&gt;
&lt;p&gt;if (!!this.action &amp;amp;&amp;amp; this.autoFirst) {&lt;/p&gt;
&lt;p&gt;this.load(this.initParam);&lt;/p&gt;
&lt;p&gt;} else if(!this.action) {&lt;/p&gt;
&lt;p&gt;this.loadLocal();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;for (let c of this.columns) {&lt;/p&gt;
&lt;p&gt;if (!~&quot;selection&quot;.indexOf(c.type)) {&lt;/p&gt;
&lt;p&gt;c.ellipsis = true;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.getColumns();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;beforeMount: function() {},&lt;/p&gt;
&lt;p&gt;mounted: function() {},&lt;/p&gt;
&lt;p&gt;beforeDestroy: function() {},&lt;/p&gt;
&lt;p&gt;destroyed: function() {},&lt;/p&gt;
&lt;p&gt;methods: {&lt;/p&gt;
&lt;p&gt;onCurrentChange(currentRow, oldCurrentRow) {&lt;/p&gt;
&lt;p&gt;this.currentRow = Object.assign({}, currentRow);&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;getHighlightRow() {&lt;/p&gt;
&lt;p&gt;return this.currentRow;&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;getColumns() {&lt;/p&gt;
&lt;p&gt;if (typeof this.columnsFn == &quot;function&quot;) {&lt;/p&gt;
&lt;p&gt;this.tableColumns = [].concat(this.columnsFn());&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;this.tableColumns = [].concat(this.columns);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;refresh() {&lt;/p&gt;
&lt;p&gt;this.param.page.currentPage = 1;&lt;/p&gt;
&lt;p&gt;this.$nextTick(() =&amp;gt; {&lt;/p&gt;
&lt;p&gt;this.load();&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;load(param = {}, page) {&lt;/p&gt;
&lt;p&gt;this.selection = [];&lt;/p&gt;
&lt;p&gt;for (let p in param) {&lt;/p&gt;
&lt;p&gt;this.param.params[p] = param[p];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.loading = true;&lt;/p&gt;
&lt;p&gt;if (!!page &amp;amp;&amp;amp; typeof page == &quot;number&quot;) {&lt;/p&gt;
&lt;p&gt;this.param.page.currentPage = page;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.param.page.recordCount = this.total;&lt;/p&gt;
&lt;p&gt;!!this.action ? this.loadAjax() : this.loadLocal();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;loadLocal() {&lt;/p&gt;
&lt;p&gt;this.loadCallback(this.resource);&lt;/p&gt;
&lt;p&gt;if (!this.isPage) {&lt;/p&gt;
&lt;p&gt;this.$nextTick(() =&amp;gt; {&lt;/p&gt;
&lt;p&gt;this.tableData = [].concat(this.resource);&lt;/p&gt;
&lt;p&gt;this.loading = false;&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;return;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.total = this.resource.length;&lt;/p&gt;
&lt;p&gt;let start = (this.param.page.currentPage - 1) * this.param.page.pageSize;&lt;/p&gt;
&lt;p&gt;let end = start + this.param.page.pageSize;&lt;/p&gt;
&lt;p&gt;end = this.resource.length &amp;gt; end ? end : this.resource.length;&lt;/p&gt;
&lt;p&gt;this.tableData = [];&lt;/p&gt;
&lt;p&gt;for (let i = start; i &amp;lt; end; i++) {&lt;/p&gt;
&lt;p&gt;this.tableData.push(this.resource[i]);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.$nextTick(() =&amp;gt; {&lt;/p&gt;
&lt;p&gt;this.loading = false;&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;loadAjax() {&lt;/p&gt;
&lt;p&gt;if (this.server[this.action]) {&lt;/p&gt;
&lt;p&gt;this.server[this.action](this.param).then(res =&amp;gt; {&lt;/p&gt;
&lt;p&gt;this.loading = false;&lt;/p&gt;
&lt;p&gt;if (!res) return;&lt;/p&gt;
&lt;p&gt;this.currentPage = res.data.pageNum;&lt;/p&gt;
&lt;p&gt;this.total = res.data.total;&lt;/p&gt;
&lt;p&gt;this.tableData = [];&lt;/p&gt;
&lt;p&gt;let _list = [];&lt;/p&gt;
&lt;p&gt;this.loadCallback(res.data.list);&lt;/p&gt;
&lt;p&gt;for (let item of res.data.list) {&lt;/p&gt;
&lt;p&gt;this.tableData.push(item);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;$store.dispatch(this.action, this.param).then(res =&amp;gt; {&lt;/p&gt;
&lt;p&gt;this.loading = false;&lt;/p&gt;
&lt;p&gt;if (!res) return;&lt;/p&gt;
&lt;p&gt;this.currentPage = res.data.pageNum;&lt;/p&gt;
&lt;p&gt;this.total = res.data.total;&lt;/p&gt;
&lt;p&gt;this.tableData = [];&lt;/p&gt;
&lt;p&gt;let _list = [];&lt;/p&gt;
&lt;p&gt;this.loadCallback(res.data.list);&lt;/p&gt;
&lt;p&gt;for (let item of res.data.list) {&lt;/p&gt;
&lt;p&gt;this.tableData.push(item);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;changePage(page) {&lt;/p&gt;
&lt;p&gt;this.param.page.currentPage = page;&lt;/p&gt;
&lt;p&gt;this.load();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;changePageSize(page) {&lt;/p&gt;
&lt;p&gt;this.param.page.pageSize = page;&lt;/p&gt;
&lt;p&gt;this.load();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;selectionChange(selection) {&lt;/p&gt;
&lt;p&gt;this.isSelectionChange = true;&lt;/p&gt;
&lt;p&gt;this.selection = selection;&lt;/p&gt;
&lt;p&gt;if (typeof this.onSelectionChange == &quot;function&quot;) {&lt;/p&gt;
&lt;p&gt;this.onSelectionChange(selection);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.$emit(&quot;on-selection-change&quot;,selection);&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;getSelectioned() {&lt;/p&gt;
&lt;p&gt;return this.isSelectionChange ? this.selection : undefined;&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;sortHandle(obj) {&lt;/p&gt;
&lt;p&gt;this.param.sortDTO.fieldName = obj.key;&lt;/p&gt;
&lt;p&gt;this.param.sortDTO.orderBy = obj.order;&lt;/p&gt;
&lt;p&gt;if (this.param.sortDTO.orderBy == &quot;normal&quot;) {&lt;/p&gt;
&lt;p&gt;this.param.sortDTO = {&lt;/p&gt;
&lt;p&gt;fieldName: &quot;&quot;,&lt;/p&gt;
&lt;p&gt;orderBy: &quot;&quot;&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;this.refresh();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;getSortData() {&lt;/p&gt;
&lt;p&gt;return this.param.sortDTO;&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;getTableObj() {&lt;/p&gt;
&lt;p&gt;return this.$refs[&quot;table&quot;];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;watch: {&lt;/p&gt;
&lt;p&gt;lang() {&lt;/p&gt;
&lt;p&gt;this.getColumns();&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;resource(newVal, oldVal) {&lt;/p&gt;
&lt;p&gt;this.resource = newVal;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;},&lt;/p&gt;
&lt;p&gt;directives: {}&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;style lang=&quot;less&quot; scoped&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/style&amp;gt;&lt;/p&gt;

&lt;p&gt;使用如下：（如有疑问随时联系博主）&lt;/p&gt;
&lt;p&gt;《父组件》&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;p&gt;&amp;lt;template&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&quot;run-mod-box&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;EasyVueTable:params=&quot;searchForm&quot; ref=&quot;BankInfoTable&quot; :server=&quot;server&quot; action=&quot;queryBanks&quot; :columns=&quot;columns&quot; :initParams=&quot;searchForm&quot; :highlight-row=&quot;true&quot; @on-selection-change=&quot;onSelectionChange&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Form :model=&quot;searchForm&quot; ref=&quot;searchForm&quot; slot=&quot;search-bar&quot; label-position=&quot;top&quot; class=&quot;ivu-form-no-margin-bottom&quot; inline&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Form-item prop=&quot;vendorName&quot; label=&quot;供应商名称&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Input type=&quot;text&quot; v-model=&quot;searchForm.vendorName&quot; size=&quot;small&quot;&amp;gt;&amp;lt;/Input&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/Form-item&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Form-item prop=&quot;bankName&quot; label=&quot;开户行&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Input type=&quot;text&quot; v-model=&quot;searchForm.bankName&quot; size=&quot;small&quot;&amp;gt;&amp;lt;/Input&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/Form-item&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/Form&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;div slot=&quot;handle-bar&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Button size=&quot;small&quot; @click.native=&quot;search&quot; type=&quot;warning&quot; icon=&quot;search&quot;&amp;gt;搜索&amp;lt;/Button&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Button size=&quot;small&quot; @click.native=&quot;reset&quot; type=&quot;info&quot; icon=&quot;loop&quot;&amp;gt;重置&amp;lt;/Button&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/EasyVueTable&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/template&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Sun, 29 Jul 2018 07:21:00 +0000</pubDate>
<dc:creator>风随心动*</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/husfBK/p/9385429.html</dc:identifier>
</item>
<item>
<title>让LED程序在片外SDRAM中运行 - icuic</title>
<link>http://www.cnblogs.com/outs/p/9385081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/outs/p/9385081.html</guid>
<description>&lt;h2 id=&quot;一引子&quot;&gt;一、引子&lt;/h2&gt;
&lt;p&gt;在前一篇文章中，我们已经成功点亮过LED了，为什么还要再重复一次呢？&lt;/p&gt;
&lt;p&gt;我们已经知道，Mini2440开发板有两种启动模式：从NorFlash启动和从NandFlash启动。&lt;/p&gt;
&lt;p&gt;这里着重说明一下从NandFlash启动的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在S3C2440片内有一块被称为SteppingStone的片内SRAM，它的大小为4K。将开发板设置为从NandFlash启动之后，SteppingStone会被映射成为0地址，并且在上电后，NandFlash前4K的数据会被自动拷贝至SteppingStone中。然后，系统从地址0处开始执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上一篇文章中的LED程序很小，所以它在大小仅为4K的SteppingStone中运行是可行的。但是如果我们编写的应用程序超过了4K,那该怎么办？&lt;/p&gt;
&lt;p&gt;答案就是，利用SteppingStone，将NandFlash中的应用程序拷贝至片外SDRAM中去运行。当然，对于大小没有超过4K的程序，我们同样也能这样做。&lt;/p&gt;
&lt;p&gt;接下来，我们就来实现LED程序在片外SDRAM中运行。&lt;/p&gt;
&lt;h2 id=&quot;二代码&quot;&gt;二、代码&lt;/h2&gt;
&lt;h3 id=&quot;led.s&quot;&gt;1. led.S&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@*************************************************************************
@ File：head.S
@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行
@*************************************************************************       

.equ        MEM_CTL_BASE,       0x48000000
.equ        SDRAM_BASE,         0x30000000

.text
.global _start
_start:
    bl  disable_watch_dog               @ 关闭WATCHDOG，否则CPU会不断重启
    bl  memsetup                        @ 设置存储控制器
    bl  copy_steppingstone_to_sdram     @ 复制代码到SDRAM中
    ldr pc, =on_sdram                   @ 跳到SDRAM中继续执行
on_sdram:
    ldr sp, =0x34000000                 @ 设置堆栈
    bl  main
halt_loop:
    b   halt_loop

disable_watch_dog:
    @ 往WATCHDOG寄存器写0即可
    mov r1,     #0x53000000
    mov r2,     #0x0
    str r2,     [r1]
    mov pc,     lr      @ 返回

copy_steppingstone_to_sdram:
    @ 将Steppingstone的4K数据全部复制到SDRAM中去
    @ Steppingstone起始地址为0x00000000，SDRAM中起始地址为0x30000000
    
    mov r1, #0
    ldr r2, =SDRAM_BASE
    mov r3, #4*1024
1:  
    ldr r4, [r1],#4     @ 从Steppingstone读取4字节的数据，并让源地址加4
    str r4, [r2],#4     @ 将此4字节的数据复制到SDRAM中，并让目地地址加4
    cmp r1, r3          @ 判断是否完成：源地址等于Steppingstone的未地址？
    bne 1b              @ 若没有复制完，继续
    mov pc,     lr      @ 返回

memsetup:
    @ 设置存储控制器以便使用SDRAM等外设

    mov r1,     #MEM_CTL_BASE       @ 存储控制器的13个寄存器的开始地址
    adrl    r2, mem_cfg_val         @ 这13个值的起始存储地址
    add r3,     r1, #52             @ 13*4 = 54
1:  
    ldr r4,     [r2], #4            @ 读取设置值，并让r2加4
    str r4,     [r1], #4            @ 将此值写入寄存器，并让r1加4
    cmp r1,     r3                  @ 判断是否设置完所有13个寄存器
    bne 1b                          @ 若没有写成，继续
    mov pc,     lr                  @ 返回


.align 4
mem_cfg_val:
    @ 存储控制器13个寄存器的设置值
    .long   0x22011110      @ BWSCON
    .long   0x00000700      @ BANKCON0
    .long   0x00000700      @ BANKCON1
    .long   0x00000700      @ BANKCON2
    .long   0x00000700      @ BANKCON3  
    .long   0x00000700      @ BANKCON4
    .long   0x00000700      @ BANKCON5
    .long   0x00018005      @ BANKCON6
    .long   0x00018005      @ BANKCON7
    .long   0x008C07A3      @ REFRESH
    .long   0x000000B1      @ BANKSIZE
    .long   0x00000030      @ MRSRB6
    .long   0x00000030      @ MRSRB7
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码依次做了以下几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关闭看门狗&lt;/li&gt;
&lt;li&gt;配置存储控制器，以便接下来读写SDRAM&lt;/li&gt;
&lt;li&gt;将SteppingStoen中所有内容拷贝至片外SDRAM中&lt;/li&gt;
&lt;li&gt;设置SP&lt;/li&gt;
&lt;li&gt;跳至Main函数，控制LED&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要说明的是“ ldr pc, =on_sdram ”这一句，为什么执行这一句代码后，PC指针就跳到了sdram，以及ldr与同样做为跳转指令的bl的区别，可以参考如下两篇文章：&lt;/p&gt;
&lt;h3 id=&quot;led.c&quot;&gt;2. led.c&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
#define GPBCON      (*(volatile unsigned long *)0x56000010)
#define GPBDAT      (*(volatile unsigned long *)0x56000014)

#define GPB5_out    (1&amp;lt;&amp;lt;(5*2))
#define GPB6_out    (1&amp;lt;&amp;lt;(6*2))
#define GPB7_out    (1&amp;lt;&amp;lt;(7*2))
#define GPB8_out    (1&amp;lt;&amp;lt;(8*2))

void  wait(unsigned long dly)
{
    for(; dly &amp;gt; 0; dly--);
}

int main(void)
{
    unsigned long i = 5;
    
    GPBCON = GPB5_out|GPB6_out|GPB7_out|GPB8_out;       // 将LED1-4对应的GPB5/6/7/8四个引脚设为输出

    while(1){
        wait(30000);
        GPBDAT = (~(1&amp;lt;&amp;lt;i)) &amp;amp; 0xFFFFFFFF;        // 根据i的值，点亮LED1-4
        if(++i == 9)
            i = 5;
    }

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的main函数，即为led.S中调用的main。其作用为依次点亮4个LED。&lt;/p&gt;
&lt;h3 id=&quot;makefile&quot;&gt;3. makefile&lt;/h3&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;sdram.bin : head.S  leds.c
    arm-linux-gcc  -c -o head.o head.S
    arm-linux-gcc -c -o leds.o leds.c
    arm-linux-ld -Ttext 0x30000000 head.o leds.o -o sdram_elf
    arm-linux-objcopy -O binary -S sdram_elf sdram.bin
    arm-linux-objdump -D -m arm  sdram_elf &amp;gt; sdram.dis
clean:
    rm -f   sdram.dis sdram.bin sdram_elf *.o
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是makefile的内容，需要注意的一点是，程序的&lt;a href=&quot;https://blog.csdn.net/qingkongyeyue/article/details/52298640&quot; target=&quot;_blank&quot;&gt;链接地址&lt;/a&gt;被指定为0x30000000，它与led.S中的SDRAM_BASE值应一致。&lt;/p&gt;
&lt;h2 id=&quot;三烧录&quot;&gt;三、烧录&lt;/h2&gt;
&lt;p&gt;将Mini2440通过串口线、USB线与电脑连接，设置为从NandFlash启动（假定NandFlash中已经烧录了supervivi），按住开发板上任意一个按键，然后上电，这时串口会打印出以下信息,提示你输入指令：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;##### FriendlyARM BIOS for 2440 #####
[x] bon part 0 320k 2368k
[v] Download vivi 
[k] Download linux kernel 
[y] Download root_yaffs image 
[a] Absolute User Application
[n] Download Nboot 
[l] Download WinCE boot-logo
[w] Download WinCE NK.bin 
[d] Download &amp;amp; Run 
[z] Download zImage into RAM 
[g] Boot linux from RAM 
[f] Format the nand flash 
[b] Boot the system 
[s] Set the boot parameters 
[u] Backup NAND Flash to HOST through USB(upload) 
[r] Restore NAND Flash from HOST through USB 
[q] Goto shell of vivi 
[i] Version: 1026-12
Enter your selection: &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在电脑键盘上敲击a，在dnw中选择由以上3个文件make生成的sdram.bin文件，将其烧录至NandFlash中。&lt;br/&gt;烧录完成后，重新给开发板上电，可以看到4个LED灯被依次点亮。&lt;/p&gt;
&lt;p&gt;烧录过程中需要注意的是，指令a是将bin文件烧录至Nandflash中，此时dnw中的Download Address是没有作用的。而指令d则是将bin文件烧录至SDRAM中，此时设置的Download Address才起作用。&lt;/p&gt;
&lt;p&gt;如果使用指令d将生成的sdram.bin烧录至sdram中，有可能达不到实验效果。因为在烧录完成后，sdram.bin被执行，它会将0地址即steppingstone处的4K内容拷贝至0x30000000处，而要知道，被拷贝的steppingstone中的4K数据，并不是我们的sdram.bin，而是本次上电时NandFlash前4K的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715231526345-1133554053.png&quot; width=&quot;205&quot; hegiht=&quot;205&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;施主，能让我尝尝通过写博客赚到一分钱的甜头吗? :D&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 07:13:00 +0000</pubDate>
<dc:creator>icuic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/outs/p/9385081.html</dc:identifier>
</item>
<item>
<title>Codeforces 1009G - 温和的提比略</title>
<link>http://www.cnblogs.com/tiberius/p/9385355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiberius/p/9385355.html</guid>
<description>&lt;p&gt;&lt;span&gt;题意略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是贪心， 我们从前往后依次从小到大考虑放哪个字符， 重点是判断放了这个字符后， 对于剩下的后缀是否存在合法解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑每个位置的允许放的字符集合只有2 ^ 6&lt;span id=&quot;MathJax-Element-2-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-16&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-17&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-18&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-19&quot; class=&quot;mn&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;种， 我们预处理一个后缀和f[i][j]， 表示i~n中被集合j包含的个数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span id=&quot;MathJax-Element-2-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;考虑第i个位置放了字符c后， 要使得f[i+1][j]都 &amp;lt;= &lt;span id=&quot;MathJax-Element-3-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-21&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-22&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-23&quot; class=&quot;mo&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;对应的剩下的个数才能是合法的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;这里涉及到一个霍尔定理：二部图G中的两部分顶点组成的集合分别为X, Y;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;G中有一组无公共点的边，一端恰好为组成X的点的充分必要条件是：X中的任意k个点至少与Y中的k个点相邻。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;由于是选择任意k个(1 &amp;lt;= k &amp;lt;= |x|)，所以我们需要考虑的是极端情况，如果极端情况满足了，那么剩余的情况也会被满足。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;现在假设我们在当前位置填上了某个字符，我们最关心的是剩下能否合法，也就是剩下的位置能否被剩余字符填满。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mn&amp;gt;6&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2264;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;其实所有的位置可以分为2 ^ 6 = 64种，如果我们选择的k个来自不同的种类，也就会给我们带来更多可以填入这k个位子的字符。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我所说的极端情况就是尽量减少可以填入这k个位子的字符，扩大我的k个位子。如果这种情况可以被满足，那么其他情况自然也就满足了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开始我认为选择来自同一种的位子就是最极端的，其实这仅仅做到了字符数最小，没有做到位子最多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我选择了状态为j的位子，我可以选择j的子集来扩大我的k，而且这不会给字符数带来任何增益。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;详见代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn1 = 1e5 + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn2 = (&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; f[maxn1][maxn2],mask[maxn1],cnt[maxn2],m;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; str[maxn1],tmp[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;],ans[maxn1];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,str,&amp;amp;&lt;span&gt;m);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; strlen(str);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(m == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
        sort(str,str &lt;/span&gt;+&lt;span&gt; len);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; len;++&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j &amp;lt; maxn2;++&lt;span&gt;j){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j &amp;amp; (&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;(str[i] - &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))) ++&lt;span&gt;cnt[j];
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= len;++i) mask[i] = maxn2 - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; m;++&lt;span&gt;i){
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;pos,tmp);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l =&lt;span&gt; strlen(tmp);
        mask[pos] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; l;++&lt;span&gt;j)
            mask[pos] &lt;/span&gt;+= (&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;(tmp[j] - &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = len;i &amp;gt;= &lt;span&gt;1&lt;/span&gt;;--&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j &amp;lt; maxn2;++&lt;span&gt;j){
            f[i][j] &lt;/span&gt;= f[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;][j];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((mask[i] &amp;amp; j) == mask[i]) f[i][j] += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= len;++&lt;span&gt;i){
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; finish = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; &lt;span&gt;6&lt;/span&gt;;++&lt;span&gt;j){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((mask[i] &amp;amp; (&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;j)) == &lt;span&gt;0&lt;/span&gt; || !cnt[&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;j]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ok = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;1&lt;/span&gt;;k &amp;lt; maxn2 &amp;amp;&amp;amp; ok;++&lt;span&gt;k){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(f[i + &lt;span&gt;1&lt;/span&gt;][k] &amp;gt; cnt[k] - ((k&amp;gt;&amp;gt;j) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)){
                    ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            } 
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ok){
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;1&lt;/span&gt;;k &amp;lt; maxn2;++&lt;span&gt;k)
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((k&amp;gt;&amp;gt;j) &amp;amp; &lt;span&gt;1&lt;/span&gt;) cnt[k] -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                ans[i] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; j;
                finish &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;finish){
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Impossible\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= len;++i) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans[i]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 29 Jul 2018 06:57:00 +0000</pubDate>
<dc:creator>温和的提比略</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiberius/p/9385355.html</dc:identifier>
</item>
<item>
<title>网络编程中重要的几个数据结构和函数 - 沈七</title>
<link>http://www.cnblogs.com/shenlinken/p/9385346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenlinken/p/9385346.html</guid>
<description>&lt;h3 id=&quot;ipv4相关结构&quot;&gt;IPv4相关结构：&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct in_addr
{
    in_addr_t          s_addr;  //表示32位的IP地址，32位无符号整型
}

struct sockaddr_in
{
    uint8_t            sin_len;       //表示该结构体的长度，8位无符号整型
    sa_family_t        sin_family;    //表示套接口使用的协议族，8位无符号整型
    in_port_t          sin_port;      //表示套接口使用的端口号，16位无符号整型
    struct in_addr     sin_addr;      //表示IP地址，32位无符号整型
    char               sin_zero[8];   //该成员基本不使用，总是置为0
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sin_len成员是不要求一定存在的，即便这个成员存在，也无需设置它或者检查它。换句话说就是一般情况下，我们用不到这个成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;sin_family,sin_addr,sin_port这三个成员是必须的。并且几乎所有的实现都增加了sin_zero成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sin_family的类型与sin_len成员有关，如果结构体中定义了成员sin_len，那么sin_family一般就是8位无符号整型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果结构体中没有定义成员sin_len，那么sin_family一般就是16位无符号整型，这样一来整个结构体的大小至少是16字节（1+1+2+4+8）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ipv6相关结构&quot;&gt;IPv6相关结构：&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct in6_addr
{
    unit8_t              s6_addr[16]; //表示128位的IP地址，这里采用数组的形式  
}

struct sockaddr_in6
{
    uint8_t              sin6_len;         //表示该结构体的长度，8位无符号整型
    sa_family_t          sin6_family;      //表示套接口使用的协议族，8位无符号整型
    in_port_t            sin_port;         //表示套接口使用的端口号，16位无符号整型
    uint32_t             sin_flowinfo;     //低序20位是流标签，高序12位保留
    struct in6_addr      sin6_addr         //表示128位的IP地址
    uint32_t             sin6_scope_id;    //标识对于具备范围的地址而言有意义的范围
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;28个字节&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;通用套接口地址结构&quot;&gt;通用套接口地址结构：&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct sockaddr
{
    uint8_t              sa_len;
    sa_family_t          sa_family;
    char                 sa_data[14];        //表示14字节的协议地址

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当作为参数传递给任一个套接口函数时，套接口地址结构总是通过指针来传递，但通过指针来取得此参数的套接口函数必须处理来自所支持的任何协议族的套接口地址结构。因此通过定义sockaddr来获取不同的套接口地址结构。&lt;/li&gt;
&lt;li&gt;大小16个字节&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;新的通用套接口地址结构&quot;&gt;新的通用套接口地址结构：&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct sockaddr_storage
{
    uint8_t              ss_len;             //表示该结构的长度
    sa_family_t          ss_family;          //表示协议族
    char __ss_padding[_SS_PADSIZE];          
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;原有的通用数据结构sockaddr只有16个字节，无法兼容ipv6格式，sockaddr_storage足够大，可以容纳任何套接字接口地址&lt;/li&gt;
&lt;li&gt;sockaddr_storage 能满足最苛刻的对齐要求&lt;/li&gt;
&lt;li&gt;想使用sockaddr_storage中，除了ss_len和ss_family外的其他字段，必须强制转换成其他类型（如sockaddr）,再获取。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;inet_pton和inet_ntop函数&quot;&gt;inet_pton和inet_ntop函数&lt;/h2&gt;
&lt;p&gt;这两个是随ipv6一起出现的新函数，支持ipv4和ipv6，函数名称中p的意思是表达(presentation)，n的意思是数值(numeric)，表达是ACSII字符串，数值是内存里的二进制值，顾名思义，inet_pton，将字符串转为数值，inet_ntop，将数值转为字符串。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;arpa/inet.h&amp;gt;
int inet_pton(int family, const char *strptr, void *addrstr); //成功返回1，strptr格式错误返回0，失败返回-1
const char *inet_ntop(int family, const void *addrstr, char *strptr, size_t len); //成功则返回指向结果的指针，失败返回NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;family参数根据协议族的不同，选择AF_INET或AF_INET6&lt;/li&gt;
&lt;li&gt;inet_pton 将strptr指向的字符串，转为数值，存放在addstr指向的内存中&lt;/li&gt;
&lt;li&gt;inet_ntop 做相反的运算，len参数是strptr单元的大小，防止溢出。为有助于指定大小，C语言中有做如下定义。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#incldue &amp;lt;arpa/inet.h&amp;gt;
#define INET_ADDRSTRLEN    16
#define INET6_ADDRSTRLEN   46&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 06:53:00 +0000</pubDate>
<dc:creator>沈七</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenlinken/p/9385346.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——依赖注入 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9384835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9384835.html</guid>
<description>&lt;p&gt;依赖注入(DI)不是一个新的话题，它的出现是伴随着系统解耦的需要而几乎必然产生的。&lt;/p&gt;
&lt;p&gt;在SOLID设计原则中，DIP(Dependency inversion principle)——依赖倒置，规定了“需依赖抽象，而非实现”的准则，该原则主要目的是通过引入抽象(比如接口)的方式降低模块之间的耦合性。与此原则相拟而又有所不同的是IoC(inversion of control)——控制反转设计原则。这项原则定义了应该由通用框架而非外部代码决定控制流(control flow)的概念。对控制反转的实现有数种技术，DI(Dependency injection)——依赖注入便是其中之一，而依赖注入技术同时又支持依赖倒置的设计原则，所以它被广泛使用并不是件令人意外的事情。&lt;/p&gt;
&lt;p&gt;依赖注入的基本特性是借由一个对象提供对另一对象的依赖。这样的一个对象通常又被称为容器。容器负责被依赖对象的注册(register)，解析(resolve)与释放(release)，并具有将被依赖对象注入到依赖对象内部的功能。&lt;/p&gt;
&lt;p&gt;在之前的ASP.NET开发过程中，要想使用到依赖注入技术必需依赖第三方类库，而在ASP.NET Core中，这项技术已经被引入到其自身的框架中。&lt;/p&gt;

&lt;p&gt;ASP.NET Core中使用ServiceProvider作为依赖注入的容器，它是在WebHostBuilder类中被引入的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IWebHost Build()
{
    ...

    IServiceProvider GetProviderFromFactory(IServiceCollection collection)
    {
        var provider = collection.BuildServiceProvider();
        var factory = provider.GetService&amp;lt;IServiceProviderFactory&amp;lt;IServiceCollection&amp;gt;&amp;gt;();

        if (factory != null)
        {
            using (provider)
            {
                return factory.CreateServiceProvider(factory.CreateBuilder(collection));
            }
        }

        return provider;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;所需依赖的对象通过ServiceCollectionServiceExtensions中的各种扩展方法被加入到ServiceCollection类中。ServiceCollection类内部维护着一个ServiceDescriptor集合。而ServiceCollection又会被传入ServiceProvider的构造方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IServiceCollection AddTransient(
    this IServiceCollection services,
    Type serviceType,
    Type implementationType)
{
    ...

    return Add(services, serviceType, implementationType, ServiceLifetime.Transient);
}

public static IServiceCollection AddScoped(
    this IServiceCollection services,
    Type serviceType,
    Type implementationType)
{
    ...

    return Add(services, serviceType, implementationType, ServiceLifetime.Scoped);
}

public static IServiceCollection AddSingleton(
    this IServiceCollection services,
    Type serviceType,
    Type implementationType)
{
    ...

    return Add(services, serviceType, implementationType, ServiceLifetime.Singleton);
}

private static IServiceCollection Add(
    IServiceCollection collection,
    Type serviceType,
    Type implementationType,
    ServiceLifetime lifetime)
{
    var descriptor = new ServiceDescriptor(serviceType, implementationType, lifetime);
    collection.Add(descriptor);
    return collection;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;要想获得已注册的对象，可以通过ServiceProviderServiceExtensions类的扩展方法GetService。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static T GetService&amp;lt;T&amp;gt;(this IServiceProvider provider)
{
    if (provider == null)
    {
        throw new ArgumentNullException(nameof(provider));
    }

    return (T)provider.GetService(typeof(T));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServiceProvider的GetService方法其实是调用了它内部各种引擎的父类ServiceProviderEngine的方法。这些引擎间区别在于实现方式以及性能上，功能方面都是一样的。默认引擎是DynamicServiceProviderEngine。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly IServiceProviderEngine _engine;

internal ServiceProvider(IEnumerable&amp;lt;ServiceDescriptor&amp;gt; serviceDescriptors, ServiceProviderOptions options)
{
  IServiceProviderEngineCallback callback = null;
  if (options.ValidateScopes)
  {
      callback = this;
      _callSiteValidator = new CallSiteValidator();
  }
  switch (options.Mode)
  {
      case ServiceProviderMode.Dynamic:
          _engine = new DynamicServiceProviderEngine(serviceDescriptors, callback);
          break;
      case ServiceProviderMode.Runtime:
          _engine = new RuntimeServiceProviderEngine(serviceDescriptors, callback);
          break;
#if IL_EMIT
      case ServiceProviderMode.ILEmit:
          _engine = new ILEmitServiceProviderEngine(serviceDescriptors, callback);
          break;
#endif
      case ServiceProviderMode.Expressions:
          _engine = new ExpressionsServiceProviderEngine(serviceDescriptors, callback);
          break;
      default:
          throw new NotSupportedException(nameof(options.Mode));
  }
}

public object GetService(Type serviceType) =&amp;gt; _engine.GetService(serviceType);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServiceProviderEngine类的CreateServiceAccessor方法创建了CallSite。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal object GetService(Type serviceType, ServiceProviderEngineScope serviceProviderEngineScope)
{
    if (_disposed)
    {
        ThrowHelper.ThrowObjectDisposedException();
    }

    var realizedService = RealizedServices.GetOrAdd(serviceType, _createServiceAccessor);
    _callback?.OnResolve(serviceType, serviceProviderEngineScope);
    return realizedService.Invoke(serviceProviderEngineScope);
}

private Func&amp;lt;ServiceProviderEngineScope, object&amp;gt; CreateServiceAccessor(Type serviceType)
{
    var callSite = CallSiteFactory.CreateCallSite(serviceType, new CallSiteChain());
    if (callSite != null)
    {
        _callback?.OnCreate(callSite);
        return RealizeService(callSite);
    }

    return _ =&amp;gt; null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设注册是用的&lt;code&gt;public static IServiceCollection AddSingleton(this IServiceCollection services, Type serviceType, Type implementationType)&lt;/code&gt;方法，那么之后的处理会生成一个SingletonCallSite对象并且包含ConstructorCallSite参数值。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private IServiceCallSite TryCreateExact(ServiceDescriptor descriptor, Type serviceType, CallSiteChain callSiteChain)
{
    if (serviceType == descriptor.ServiceType)
    {
        IServiceCallSite callSite;
        if (descriptor.ImplementationInstance != null)
        {
            callSite = new ConstantCallSite(descriptor.ServiceType, descriptor.ImplementationInstance);
        }
        else if (descriptor.ImplementationFactory != null)
        {
            callSite = new FactoryCallSite(descriptor.ServiceType, descriptor.ImplementationFactory);
        }
        else if (descriptor.ImplementationType != null)
        {
            callSite = CreateConstructorCallSite(descriptor.ServiceType, descriptor.ImplementationType, callSiteChain);
        }
        else
        {
            throw new InvalidOperationException(&quot;Invalid service descriptor&quot;);
        }

        return ApplyLifetime(callSite, descriptor, descriptor.Lifetime);
    }

    return null;
}

private IServiceCallSite CreateConstructorCallSite(Type serviceType, Type implementationType, CallSiteChain callSiteChain)
{
    callSiteChain.Add(serviceType, implementationType);

    var constructors = implementationType.GetTypeInfo()
        .DeclaredConstructors
        .Where(constructor =&amp;gt; constructor.IsPublic)
        .ToArray();

    IServiceCallSite[] parameterCallSites = null;

    if (constructors.Length == 0)
    {
        throw new InvalidOperationException(Resources.FormatNoConstructorMatch(implementationType));
    }
    else if (constructors.Length == 1)
    {
        var constructor = constructors[0];
        var parameters = constructor.GetParameters();
        if (parameters.Length == 0)
        {
            return new CreateInstanceCallSite(serviceType, implementationType);
        }

        parameterCallSites = CreateArgumentCallSites(
            serviceType,
            implementationType,
            callSiteChain,
            parameters,
            throwIfCallSiteNotFound: true);

        return new ConstructorCallSite(serviceType, constructor, parameterCallSites);
    }

    ...
}

private IServiceCallSite ApplyLifetime(IServiceCallSite serviceCallSite, object cacheKey, ServiceLifetime descriptorLifetime)
{
    if (serviceCallSite is ConstantCallSite)
    {
        return serviceCallSite;
    }

    switch (descriptorLifetime)
    {
        case ServiceLifetime.Transient:
            return new TransientCallSite(serviceCallSite);
        case ServiceLifetime.Scoped:
            return new ScopedCallSite(serviceCallSite, cacheKey);
        case ServiceLifetime.Singleton:
            return new SingletonCallSite(serviceCallSite, cacheKey);
        default:
            throw new ArgumentOutOfRangeException(nameof(descriptorLifetime));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServiceProvider真正解析的是这个生成出来的CallSite对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override Func&amp;lt;ServiceProviderEngineScope, object&amp;gt; RealizeService(IServiceCallSite callSite)
{
    var callCount = 0;
    return scope =&amp;gt;
    {
        if (Interlocked.Increment(ref callCount) == 2)
        {
            Task.Run(() =&amp;gt; base.RealizeService(callSite));
        }
        return RuntimeResolver.Resolve(callSite, scope);
    };
}

public object Resolve(IServiceCallSite callSite, ServiceProviderEngineScope scope)
{
    return VisitCallSite(callSite, scope);
}

protected virtual TResult VisitCallSite(IServiceCallSite callSite, TArgument argument)
{
    switch (callSite.Kind)
    {
        case CallSiteKind.Factory:
            return VisitFactory((FactoryCallSite)callSite, argument);
        case  CallSiteKind.IEnumerable:
            return VisitIEnumerable((IEnumerableCallSite)callSite, argument);
        case CallSiteKind.Constructor:
            return VisitConstructor((ConstructorCallSite)callSite, argument);
        case CallSiteKind.Transient:
            return VisitTransient((TransientCallSite)callSite, argument);
        case CallSiteKind.Singleton:
            return VisitSingleton((SingletonCallSite)callSite, argument);
        case CallSiteKind.Scope:
            return VisitScoped((ScopedCallSite)callSite, argument);
        case CallSiteKind.Constant:
            return VisitConstant((ConstantCallSite)callSite, argument);
        case CallSiteKind.CreateInstance:
            return VisitCreateInstance((CreateInstanceCallSite)callSite, argument);
        case CallSiteKind.ServiceProvider:
            return VisitServiceProvider((ServiceProviderCallSite)callSite, argument);
        case CallSiteKind.ServiceScopeFactory:
            return VisitServiceScopeFactory((ServiceScopeFactoryCallSite)callSite, argument);
        default:
            throw new NotSupportedException($&quot;Call site type {callSite.GetType()} is not supported&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为上例中CallSite的类型是Constructor，所以最终通过VisitConstructor方法获得所依赖的对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected override object VisitConstructor(ConstructorCallSite constructorCallSite, ServiceProviderEngineScope scope)
{
    object[] parameterValues = new object[constructorCallSite.ParameterCallSites.Length];
    for (var index = 0; index &amp;lt; parameterValues.Length; index++)
    {
        parameterValues[index] = VisitCallSite(constructorCallSite.ParameterCallSites[index], scope);
    }

    try
    {
        return constructorCallSite.ConstructorInfo.Invoke(parameterValues);
    }
    catch (Exception ex) when (ex.InnerException != null)
    {
        ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
        // The above line will always throw, but the compiler requires we throw explicitly.
        throw;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于创建对象的方法是用反射，表达式树(Expression Tree)还是IL Emit，则取决于所使用的内部引擎。&lt;/p&gt;

&lt;p&gt;创建ServiceProviderEngine的时候会为其Root属性绑定ServiceProviderEngineScope类型的值，&lt;code&gt;Root = new ServiceProviderEngineScope(this);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在ServiceProviderEngineScope类内部有着用于释放资源的Dispose方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Dispose()
{
    lock (ResolvedServices)
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        if (_disposables != null)
        {
            for (var i = _disposables.Count - 1; i &amp;gt;= 0; i--)
            {
                var disposable = _disposables[i];
                disposable.Dispose();
            }

            _disposables.Clear();
        }

        ResolvedServices.Clear();
    }
}

internal object CaptureDisposable(object service)
{
    _captureDisposableCallback?.Invoke(service);

    if (!ReferenceEquals(this, service))
    {
        if (service is IDisposable disposable)
        {
            lock (ResolvedServices)
            {
                if (_disposables == null)
                {
                    _disposables = new List&amp;lt;IDisposable&amp;gt;();
                }

                _disposables.Add(disposable);
            }
        }
    }
    return service;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并不是所有对象都会通过ServiceProvider容器释放资源，只有容器自己创建的才可以。如果是新建对象再传入容器，容器不会为其作处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // 容器创建了实例所以会释放它。
    services.AddScoped&amp;lt;Service1&amp;gt;();
    services.AddSingleton&amp;lt;Service2&amp;gt;();
    services.AddSingleton&amp;lt;ISomeService&amp;gt;(sp =&amp;gt; new SomeServiceImplementation());

    // 容器没有创建实例所以不会释放它。
    services.AddSingleton&amp;lt;Service3&amp;gt;(new Service3());
    services.AddSingleton(new Service3());
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;ASP.NET Core中最常用的是Constructor Inject(构造器注入)方式。在其MVC框架中，通过DefaultControllerActivator生成Controller时，就可以跟踪到依赖注入是如何被其使用的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual object Create(ControllerContext controllerContext)
{
    ...

    var serviceProvider = controllerContext.HttpContext.RequestServices;
    return _typeActivatorCache.CreateInstance&amp;lt;object&amp;gt;(serviceProvider, controllerTypeInfo.AsType());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DefaultControllerActivator的Create方法使用了TypeActivatorCache类，其内部用到了ActivatorUtilities.CreateFactory方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TypeActivatorCache : ITypeActivatorCache
{
    private readonly Func&amp;lt;Type, ObjectFactory&amp;gt; _createFactory =
        (type) =&amp;gt; ActivatorUtilities.CreateFactory(type, Type.EmptyTypes);
    private readonly ConcurrentDictionary&amp;lt;Type, ObjectFactory&amp;gt; _typeActivatorCache =
           new ConcurrentDictionary&amp;lt;Type, ObjectFactory&amp;gt;();

    public TInstance CreateInstance&amp;lt;TInstance&amp;gt;(
        IServiceProvider serviceProvider,
        Type implementationType)
    {
        ...

        var createFactory = _typeActivatorCache.GetOrAdd(implementationType, _createFactory);
        return (TInstance)createFactory(serviceProvider, arguments: null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ActivatorUtilities类位于ServiceProvider同样的程序集中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static ObjectFactory CreateFactory(Type instanceType, Type[] argumentTypes)
{
    FindApplicableConstructor(instanceType, argumentTypes, out ConstructorInfo constructor, out int?[] parameterMap);

    var provider = Expression.Parameter(typeof(IServiceProvider), &quot;provider&quot;);
    var argumentArray = Expression.Parameter(typeof(object[]), &quot;argumentArray&quot;);
    var factoryExpressionBody = BuildFactoryExpression(constructor, parameterMap, provider, argumentArray);

    var factoryLamda = Expression.Lambda&amp;lt;Func&amp;lt;IServiceProvider, object[], object&amp;gt;&amp;gt;(
        factoryExpressionBody, provider, argumentArray);

    var result = factoryLamda.Compile();
    return result.Invoke;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;留意BuildFactoryExpression方法中GetServiceInfo变量。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static Expression BuildFactoryExpression(
    ConstructorInfo constructor,
    int?[] parameterMap,
    Expression serviceProvider,
    Expression factoryArgumentArray)
{
    var constructorParameters = constructor.GetParameters();
    var constructorArguments = new Expression[constructorParameters.Length];

    for (var i = 0; i &amp;lt; constructorParameters.Length; i++)
    {
        var constructorParameter = constructorParameters[i];
        var parameterType = constructorParameter.ParameterType;
        var hasDefaultValue = ParameterDefaultValue.TryGetDefaultValue(constructorParameter, out var defaultValue);

        if (parameterMap[i] != null)
        {
            constructorArguments[i] = Expression.ArrayAccess(factoryArgumentArray, Expression.Constant(parameterMap[i]));
        }
        else
        {
            var parameterTypeExpression = new Expression[] { serviceProvider,
                Expression.Constant(parameterType, typeof(Type)),
                Expression.Constant(constructor.DeclaringType, typeof(Type)),
                Expression.Constant(hasDefaultValue) };
            constructorArguments[i] = Expression.Call(GetServiceInfo, parameterTypeExpression);
        }

        ...
    }

    return Expression.New(constructor, constructorArguments);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GetServiceInfo变量申明了对GetService方法的调用，而此GetService其实正是对ServiceProvider的调用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static readonly MethodInfo GetServiceInfo =
    GetMethodInfo&amp;lt;Func&amp;lt;IServiceProvider, Type, Type, bool, object&amp;gt;&amp;gt;((sp, t, r, c) =&amp;gt; GetService(sp, t, r, c));

private static object GetService(IServiceProvider sp, Type type, Type requiredBy, bool isDefaultParameterRequired)
{
    var service = sp.GetService(type);
    ...
    
    return service;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上的处理，在创建Controller时，其构造方法中所需参数的类型也会被容器解析，创建相应实例，从而实现依赖注入功能。&lt;/p&gt;

&lt;p&gt;ASP.NET Core容器可以创建三种生命周期的对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transient， 每次取得的都是新的对象。&lt;/li&gt;
&lt;li&gt;Scoped， 每次ASP.NET请求生成不同的对象。&lt;/li&gt;
&lt;li&gt;Singleton，同一对象只会生成一次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;检视这三者类型的构造方法，可以很容易理解Scoped与Singleton是通过缓存的方式实现对象的重用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public TransientCallSite(IServiceCallSite serviceCallSite)
{
    ServiceCallSite = serviceCallSite;
}

public ScopedCallSite(IServiceCallSite serviceCallSite, object cacheKey)
{
    ServiceCallSite = serviceCallSite;
    CacheKey = cacheKey;
}

public SingletonCallSite(IServiceCallSite serviceCallSite, object cacheKey) : base(serviceCallSite, cacheKey)
{
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于ServiceProvider容器使用了反射，表达式树以及IL Emit方式创建对象，可能会对其性能有所担忧，但实际检测的结果，除了Runtime引擎表现不尽如人意外，其它引擎的性能还是在可接受范围内的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class GetServiceBenchmark
{
    private const int OperationsPerInvoke = 50000;

    private IServiceProvider _transientSp;
    private ServiceProviderMode _mode;

    [Params(&quot;Expressions&quot;, &quot;Dynamic&quot;, &quot;Runtime&quot;, &quot;ILEmit&quot;)]
    public string Mode {
        set {
            _mode = (ServiceProviderMode)Enum.Parse(typeof(ServiceProviderMode), value);
        }
    }

    [Benchmark(Baseline = true, OperationsPerInvoke = OperationsPerInvoke)]
    public void NoDI()
    {
        for (int i = 0; i &amp;lt; OperationsPerInvoke; i++)
        {
            var temp = new A(new B(new C()));
            temp.Foo();
        }
    }

    [GlobalSetup(Target = nameof(Transient))]
    public void SetupTransient()
    {
        var services = new ServiceCollection();
        services.AddTransient&amp;lt;A&amp;gt;();
        services.AddTransient&amp;lt;B&amp;gt;();
        services.AddTransient&amp;lt;C&amp;gt;();
        _transientSp = services.BuildServiceProvider(new ServiceProviderOptions()
        {
            Mode = _mode
        });
    }

    [Benchmark(OperationsPerInvoke = OperationsPerInvoke)]
    public void Transient()
    {
        for (int i = 0; i &amp;lt; OperationsPerInvoke; i++)
        {
            var temp = _transientSp.GetService&amp;lt;A&amp;gt;();
            temp.Foo();
        }
    }

    private class A
    {
        public A(B b)
        {

        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public void Foo()
        {

        }
    }

    private class B
    {
        public B(C c)
        {

        }
    }

    private class C
    {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;// ***** BenchmarkRunner: Finish  *****

// * Export *

// * Detailed results *
GetServiceBenchmark.NoDI: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Dynamic]
Runtime = ; GC = 
Mean = 5.5175 ns, StdErr = 0.0116 ns (0.21%); N = 15, StdDev = 0.0449 ns
Min = 5.4490 ns, Q1 = 5.4860 ns, Median = 5.5207 ns, Q3 = 5.5641 ns, Max = 5.5972 ns
IQR = 0.0781 ns, LowerFence = 5.3688 ns, UpperFence = 5.6813 ns
ConfidenceInterval = [5.4695 ns; 5.5654 ns] (CI 99.9%), Margin = 0.0480 ns (0.87% of Mean)
Skewness = 0.15, Kurtosis = 1.67


GetServiceBenchmark.Transient: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Dynamic]
Runtime = ; GC = 
Mean = 43.1601 ns, StdErr = 0.0677 ns (0.16%); N = 15, StdDev = 0.2620 ns
Min = 42.7731 ns, Q1 = 42.9117 ns, Median = 43.2403 ns, Q3 = 43.3580 ns, Max = 43.5392 ns
IQR = 0.4464 ns, LowerFence = 42.2421 ns, UpperFence = 44.0276 ns
ConfidenceInterval = [42.8800 ns; 43.4402 ns] (CI 99.9%), Margin = 0.2801 ns (0.65% of Mean)
Skewness = -0.2, Kurtosis = 1.59


GetServiceBenchmark.NoDI: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Expressions]
Runtime = ; GC = 
Mean = 5.6964 ns, StdErr = 0.0388 ns (0.68%); N = 33, StdDev = 0.2226 ns
Min = 5.5148 ns, Q1 = 5.5603 ns, Median = 5.6042 ns, Q3 = 5.6769 ns, Max = 6.2460 ns
IQR = 0.1166 ns, LowerFence = 5.3854 ns, UpperFence = 5.8518 ns
ConfidenceInterval = [5.5561 ns; 5.8368 ns] (CI 99.9%), Margin = 0.1404 ns (2.46% of Mean)
Skewness = 1.48, Kurtosis = 3.69


GetServiceBenchmark.Transient: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Expressions]
Runtime = ; GC = 
Mean = 43.6662 ns, StdErr = 0.0995 ns (0.23%); N = 13, StdDev = 0.3586 ns
Min = 43.1083 ns, Q1 = 43.5089 ns, Median = 43.6051 ns, Q3 = 43.7178 ns, Max = 44.6669 ns
IQR = 0.2089 ns, LowerFence = 43.1956 ns, UpperFence = 44.0311 ns
ConfidenceInterval = [43.2368 ns; 44.0957 ns] (CI 99.9%), Margin = 0.4295 ns (0.98% of Mean)
Skewness = 1.41, Kurtosis = 5.18


GetServiceBenchmark.NoDI: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=ILEmit]
Runtime = ; GC = 
Mean = 5.6016 ns, StdErr = 0.0071 ns (0.13%); N = 13, StdDev = 0.0255 ns
Min = 5.5547 ns, Q1 = 5.5896 ns, Median = 5.5996 ns, Q3 = 5.6226 ns, Max = 5.6400 ns
IQR = 0.0330 ns, LowerFence = 5.5401 ns, UpperFence = 5.6721 ns
ConfidenceInterval = [5.5712 ns; 5.6321 ns] (CI 99.9%), Margin = 0.0305 ns (0.54% of Mean)
Skewness = -0.47, Kurtosis = 2.12


GetServiceBenchmark.Transient: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=ILEmit]
Runtime = ; GC = 
Mean = 43.1397 ns, StdErr = 0.0726 ns (0.17%); N = 15, StdDev = 0.2812 ns
Min = 42.7061 ns, Q1 = 42.9064 ns, Median = 43.1052 ns, Q3 = 43.3093 ns, Max = 43.6443 ns
IQR = 0.4028 ns, LowerFence = 42.3022 ns, UpperFence = 43.9135 ns
ConfidenceInterval = [42.8392 ns; 43.4403 ns] (CI 99.9%), Margin = 0.3006 ns (0.70% of Mean)
Skewness = 0.28, Kurtosis = 1.9


GetServiceBenchmark.NoDI: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Runtime]
Runtime = ; GC = 
Mean = 6.4814 ns, StdErr = 0.0762 ns (1.18%); N = 100, StdDev = 0.7617 ns
Min = 5.4979 ns, Q1 = 5.8327 ns, Median = 6.3039 ns, Q3 = 6.9775 ns, Max = 8.0420 ns
IQR = 1.1448 ns, LowerFence = 4.1155 ns, UpperFence = 8.6947 ns
ConfidenceInterval = [6.2231 ns; 6.7397 ns] (CI 99.9%), Margin = 0.2583 ns (3.99% of Mean)
Skewness = 0.52, Kurtosis = 1.94


GetServiceBenchmark.Transient: Job-NHLENA(Toolchain=InProcessToolchain, RunStrategy=Throughput) [Mode=Runtime]
Runtime = ; GC = 
Mean = 581.5066 ns, StdErr = 1.6962 ns (0.29%); N = 15, StdDev = 6.5695 ns
Min = 571.4934 ns, Q1 = 576.3829 ns, Median = 580.8121 ns, Q3 = 587.2645 ns, Max = 596.3317 ns
IQR = 10.8816 ns, LowerFence = 560.0605 ns, UpperFence = 603.5869 ns
ConfidenceInterval = [574.4834 ns; 588.5297 ns] (CI 99.9%), Margin = 7.0232 ns (1.21% of Mean)
Skewness = 0.58, Kurtosis = 2.48


Total time: 00:03:11 (191.85 sec)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果想用第三方容器替换ASP.NET Core原有的容器也是可以办到的。以最常见的Autofac为例，有两种实现方式：&lt;/p&gt;
&lt;p&gt;借助ConfigureContainer方法，要先在Program类中挂载AddAutofac方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args).ConfigureServices(services =&amp;gt; services.AddAutofac())
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Startup类中加入ConfigureContainer方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureContainer(ContainerBuilder builder)
{
    builder.RegisterModule(new DefaultModule());

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例中的DefaultModule类按照Autofac的通用方式实现。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class DefaultModule : Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterType&amp;lt;HelloWorld&amp;gt;().As&amp;lt;IHelloWorld&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想使用ConfigureContainer方法，也可以直接利用ConfigureServices方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    var containerBuilder = new ContainerBuilder();
    containerBuilder.RegisterModule&amp;lt;DefaultModule&amp;gt;();
    containerBuilder.Populate(services);
    var container = containerBuilder.Build();
    return new AutofacServiceProvider(container);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，使用这种方式时，ConfigureServices方法的返回类型要从void改成IServiceProvider。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 06:38:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9384835.html</dc:identifier>
</item>
<item>
<title>阻塞队列分析 - XuMinzhe</title>
<link>http://www.cnblogs.com/xmzJava/p/9380649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmzJava/p/9380649.html</guid>
<description>&lt;p&gt;&lt;span&gt;转载请标注来源：https://www.cnblogs.com/xmzJava/p/9380649.html&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt; 在分析多线程的文章中，我们知道了Executors是通过阻塞队列接受任务。例如 FixedThreadPool 使用的是 LinkedBlockingQueue, CachedThreadPool 使用的是 SynchronousQueue。阻塞队列的基类是 BlockingQueue，他的实现类如下所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728091217125-1342664384.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BlockingQueue的api我们需要重点关注下，理解了这些api的作用，对于实现类的分析会轻松很多。&lt;/p&gt;
&lt;table border=&quot;5&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;api名称&lt;/td&gt;
&lt;td&gt;是否阻塞&lt;/td&gt;
&lt;td&gt;简述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;3&quot;&gt;放入数据&lt;/td&gt;
&lt;td&gt;offer(anObject)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;offer(E o, long timeout, TimeUnit unit)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;put(anObject)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;是&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;获取数据&lt;/td&gt;
&lt;td&gt;poll(time)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;poll(long timeout, TimeUnit unit)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;是&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;drainTo()&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;p&gt;重点关注表中的阻塞类型的方法，他们是阻塞队列的核心。接下来讲述几个常用的阻塞队列的存取数据api。&lt;/p&gt;
&lt;h3&gt;ArrayBolckingQueue&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象。我们先看offer方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728101100324-267512557.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再看下 enqueue&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728102357670-211321850.png&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是非阻塞的存放。我们再看阻塞版本的存放&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728102653405-776849611.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，两种方式的差别其实很小，一个是阻塞一段时间后直接返回false，一个是无限期的阻塞。我们再看下取数据的api。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728103759521-1722724325.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看下dequeue&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728104221126-877289668.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以上就是ArrayBlockingQunue的具体分析。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt; LinkedBlockingQueue是基于链表的阻塞队列，首先需要注意的是LinkedBlockingQueue是可以无界的,当你不指定容量时他默认的大小是 Integer.MAX_VALUE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728104907192-336218131.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;77&quot;/&gt;&lt;/p&gt;
&lt;p&gt;链表通过内部的Node来实现，可以看出这是个单项链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728110431441-283064706.png&quot; alt=&quot;&quot; width=&quot;226&quot; height=&quot;142&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们再看下具体的api &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728112943423-1380099245.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;528&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看下 enqueue，就是一个简单的链表操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728113107354-164624.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;put的操作和offer相似，这里就省略了，再看下poll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728114630564-2057005620.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下dequeue，把头结点取出来，把下个节点设为头结点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728114841936-439468262.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是LinkedBlockingQueue。&lt;/p&gt;
&lt;p&gt;通过上述两种队列的讲解，我们大概知道了队列存取元素的大致过程，其他队列和上述两种队列的api大致相同，所以接下重点讲述队列的大致特点，不再对api进行详细的描述。&lt;/p&gt;

&lt;h3&gt;PriorityQueue&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;     PriorityQueue并不是阻塞队列，在这里讲述是因为，接下来的几个队列都是基于他的扩展。PriorityQueue和ArrayBlockingQueue一样，内部维护了一个定长数组，如果不指定长度，默认长度就是11。PriorityQueue是一个优先级队列，元素的顺序并不是按照插入顺序而来，而是按照元素的大小来判断。默认的比较器是从小到大，即队首的元素总是最小的。当然。可以自定义比较器。&lt;/p&gt;
&lt;p&gt;    PriorityQueue的优先级通过二叉小顶堆实现，他的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。这里借鉴网上的一幅图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728120852706-1652812889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看下添加元素的过程，这里重点是siftUp方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728121905308-706870104.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;336&quot;/&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728122017363-1581514369.png&quot; alt=&quot;&quot; width=&quot;421&quot; height=&quot;143&quot;/&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728122956275-873437573.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，PriorityQunue 最关键的便是 &lt;span&gt;比较-交换 &lt;/span&gt;步骤。 添加元素都是先放到最后，然后再与自己的父节点比较&lt;/p&gt;
&lt;p&gt;再看下获取元素的步骤&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728124104876-1622283239.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;295&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728125902008-213467396.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;162&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728125807196-1498212643.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里还有种情况，就是&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728130421399-1397175370.png&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;23&quot;/&gt;方法，删除中间的某个元素，这就是上述两种变化的结合，首先删除 i 下标的元素，然后把末尾的元素放置到 i 坐标，先向下比较看看，再向上比较。具体的代码这里就省略了。&lt;/p&gt;
&lt;p&gt; 以上就是PriorityQueue的具体分析。&lt;/p&gt;

&lt;h3&gt;DelayQueue&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;DelayQueue 是延迟阻塞队列，队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。&lt;/p&gt;
&lt;p&gt;DelayQueue内部通过PriorityQueue实现延迟的权重排序 ，其比较器是 Comparable&amp;lt;Delayed&amp;gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728134116108-740779311.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要看存元素的api&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728134722472-406579410.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里关键的是  &lt;/p&gt;
&lt;pre&gt;
first.getDelay(NANOSECONDS)&amp;gt;0
&lt;/pre&gt;
&lt;p&gt; 所以我们在实现 Delayed的时候 实现类里面一定得要有时间可以记录到什么过期，如果过期了一定要返回负数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728135325490-664394865.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DelayQueue平时比较少见，但是我们可以用它做一些很灵活的事情，例如缓存过期，空闲连接去除。按照DelayQueue的特性，队首的元素总是最先过期的，我们可以用一个后台线程监听DelayQueue的队首元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jobs/archive/2007/04/27/730255.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;  大家可以参考下用 DelayQueue实现一个过期缓存清除的功能。&lt;/p&gt;

&lt;h3&gt;PriorityBlockingQueue&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt; PriorityBlockingQueue是优先级阻塞队列，他和我们上文讲的PriorityQueue非常相似。但是呢他又多了点阻塞的东西，准确来说是多了半点。因为在做put操作的时候是不会有阻塞的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728141301438-38299344.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;53&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就算我们给他一个初始大小，但是如果容量不够还会去扩容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180728141705601-440558672.png&quot; alt=&quot;&quot; width=&quot;630&quot; height=&quot;68&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们在往里面put的时候要注意，万一生产者一直在生产，消费者挂了，那么内存很容易就会被耗尽&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt; 在线程池里面，大家一定见到过这个队列。这是一个不直接存放元素的队列，他存储的实际上是他内置的Node。它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品。具体的流程我举个例子&lt;/p&gt;
&lt;p&gt;步骤一，调用put线程，存储元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729135852687-1741841470.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;

&lt;p&gt;步骤二，再次调用put线程，存储元素 ，在调用一个take线程，取出一个元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729135959784-526795263.png&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候take线程会和put(&quot;b&quot;)配对，配对成功后put(&quot;a&quot;)线程就会成为头结点，整个流程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729140223772-2009654642.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SynchronousQueue有两种模式，公平和非公平，默认是非公平的。内部有两种数据结构，分别是是队列和栈来表示公平和非公平两种模式。上图所描述的是非公平模式，即先进后出。具体细节还是得从代码里看。&lt;/p&gt;
&lt;p&gt;首先看下存取元素的api&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729140825804-1834673275.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;135&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729140844718-1835345702.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;

&lt;p&gt;两个方法都调用的  transfer 方法，这就是一个配对的方法。这里截取核心部分的transfer方法供大家参考&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138295/201807/1138295-20180729142733125-818709814.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;785&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里采用了大量的CAS操作进行更新，初看有点乱，但是心中熟记这是个配对方法，再debug几次。代码就会很清晰了。&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u013309870/article/details/71189189 【Java堆结构PriorityQueue完全解析】&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/leesf456/p/5560362.html 【SynchronousQueue分析】&lt;/p&gt;

</description>
<pubDate>Sun, 29 Jul 2018 06:38:00 +0000</pubDate>
<dc:creator>XuMinzhe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmzJava/p/9380649.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz day05——深入理解保护模式与进入方法 - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/antz05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz05.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在前几天的任务中，我们已经简单实现了MBR，直接操作显示器和硬盘操作来加载其他扇区的程序，我们这些任务都是为了进入保护模式做准备，虽然我们已经给出了jmp到保护模式的方法，但是我们还是需要理解保护模式下的一些特性，才能更好的实现我们操作系统的功能。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;　　以下是实模式的不足。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）操作系统和用户程序属于同一特权级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）用户程序可以自由修改段基址，可以访问任意内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4）访问超过64KB的内存区域时要切换段基址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5）一次只能运行一个程序，无法充分利用计算机资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6）共20跟地址线，最大可用内存为1MB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1~3是安全缺陷，4~5是使用方面的缺陷，第6条简直就是不能忍受的硬伤，1MB内存真的太束缚手脚了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来为了解决这些问题，厂商开发处保护模式。这时，物理内存地址不能被程序直接访问，程序内部的地址(虚拟地址)需要被转换为物理地址后再去访问，程序对此一无所知。而且地址的转换时由处理器和操作系统共同协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程需要的页表。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;　&lt;span&gt;　计算机的发展必须遵守兼容的特点，CPU发展到32位之后，地址总线和数据总线也发展到了32位，寻址空间更是达到了4GB。寻址空间大了，但寻址方式还是得兼容老方法，就是“段基址：偏移地址”，如果还是16位的话，不能承受4GB寻址的重任，所以寄存器也得跟上。为了让一个寄存器就可以寻址4GB空间，寄存器扩展到了32位。除了段寄存器，其他寄存器均扩展到了32位，因为段寄存器16位就够用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729095126847-326911375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　寄存器的低16位都是为了兼容模式，高16位无法单独使用，只能在用32位寄存器时才可以用到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　偏移地址还是和实模式下一样，但段基址为了安全，在其内添加了约束信息，这些约束信息就是内存段的描述信息，由于这些信息在寄存器中放不下，所以用了一个专门的数据结构——全局描述符表。其中有表项，用来描述各个内存段的起始地址,大小,权限等信息，每个表项大小是64字节，因为全局描述符表很大，只能放在内存中，由寄存器指向它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至此，段寄存器中再也不是段基址了，里面保存的叫做选择子(selector) ，它是一个数，用来索引全局描述符表中的段描述符，把全局描述符表当作数组，选择子就像是下标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符是放在内存中的，访问内存对于CPU而言效率不高，而且段描述符的格式很奇怪，一个数据要分三个地方存，所以CPU把这些数组合并成一个完整数据也是需要花时间的。既然如此花费时间，在保护模式中，CPU为了提高效率，采取了对段寄存器的缓存技术，将段信息用一个寄存器来存储，这就是段描述符缓冲寄存器(对程序员不可见)。在获得一个段描述符之后，以后访问相同段时，会直接访问该寄存器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面是三种段描述符寄存器的结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729100556649-424012169.png&quot; alt=&quot;&quot;/&gt;  　　&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;　　保护模式如何分辨16位和32位指令和操作数呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　汇编产生的机器码机器并不能识别是运行在16位还是32位系统下，在编译时可以通过[bits 16]和[bits 32]来确定编译器将代码编译为多少位的机器码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　[bis]是伪指令，编译并无具体机器码，那么在编译之后机器如何识别呢？　 这里引入前缀，在指令前加入前缀指令重复前缀rep，段跨越前缀&quot;段寄存器&quot;，还有操作数反转前缀0x66，寻址方式反转前缀0x67。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;行号&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;指令&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;机器码&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;[bits 16]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;伪指令&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mov ax,0x1234&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;B83412&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mov eax,0x1234&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;66B834120000&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;[bits 32]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;伪指令&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mov ax,0x1234&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;66B83412&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mov eax,0x1234&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;B834120000&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;span&gt;　　如果32位的代码被编译为16位的代码就会在机器码前加入前缀。即一种模式下要用另一中模式的操作数大小，需要在指令前加入指令前缀0x66。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上是操作数大小的改变时的前缀，如果是寻址方式改变，则添加前缀0x67。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;　　上面我们已经提到过全局描述符表了，它可以当作一个数组，而段描述符就是这个数组的下标。其结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729124147774-1732795805.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　段描述符是8字节的，专门用来描述一个内存段，8字节也就是64位，而且是连续的8个字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　保护模式下地址总线是32位，段基址需要32位地址表示，段界限用20位表示，不过这个段界限只是个单位量，它的单位要么是字节，要么是4KB，这是感觉描述符的G位来确定的。最终段的边界是此段界限值*单位，故段的大小要么是2的20次方1MB要么是2的32次方（4KB==2的12次方）4GB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里说的1MB和4GB只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从0开始算，所以实际的段界限边界值等于（描述符中段界限+1）*（段界限的粒度大小：4KB或1） -1  。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个公式的意思就是表示有多少个4KB或1 。由于描述符中的段界限是从0起的，所以左边第1个括号中要加个1,表示实际数量，由于地址是从0开始的，所以最后减1 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内存访问需要用到“段基址：偏移地址”，段界限其实就是用来限制段内偏移地址的，段内偏移地址必须位于段内，否则CPU会抛异常，“段界限*单位”就是限定偏移地址的最值的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　仔细观察上面段描述符，你会发现段界限属性被分为了两部分，32位的段基址属性居然被分为了三份，这是为了兼容性考虑的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;段描述符的低32位分为了两部分，前16位来存储段的段界限的前0~15位，后16位存储段基址的0~15位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　主要属性都是在段描述符的高32位，0~7位是段基址的16~23位，24~31位是段基址的24~31位，加上段描述符的低32位的0~15位，这下32位的基地址才算完整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　8~11位的type属性，四位，用来指定本描述符的类型。一个段描述符在CPU眼中分为两类，要么是系统段，要么是数据段。这是感觉段描述符的S位决定的，它用来指示是否是系统段，CPU眼中，硬件运行需要的都是系统，软件需要的都是数据，S是0表示系统段，S是1是数据段。type字段是和S字段配合才能确定段描述符的确切类型，至有S确定了，type才有具体意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再来看type字段，它用于表示内存段或门的子类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729131721241-523404026.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;776&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是type在S确定之后的意义，我们需要注意的是非系统段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第13~14位就是DPL字段，即描述符特权符，这是保护模式提供的安全解决方案，将计算机世界分为不同等级。这两位可以代表四种特权级，分别是0~4，数字越小特权越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第15位的P字段，即段是否存在，如果段存在于内存中，P为1，否则P为0。P是由CPU检查的，如果为0，CPU将抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第16~19位是段界限的第16~19位。这样段界限就齐全了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第20位是AVL，这位是相对用户的，暂不用理会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第21位是L，是用来检查是否是64位代码段，在我们32位CPU时，将其置0即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第22位是D/B字段，用来表示有效地址及操作数的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第23位是G，用来指定段界限的大小，粒度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段描述符的第24~31位是段基址的24~31位，是段基址的最后8位。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;　　一个段描述符只能用来定义一个内存段，代码段要占用一个段描述符,数据段和栈段等，多个内存段也要各自占用一个段描述符，这些描述符会放在全局描述符表中，也就是GDT，GDT是公用的，它位于内存中，需要专门的寄存器指向。这个寄存器就是GDTR，一个48位寄存器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729134733158-144830236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　gdtr不能直接用mov gdtr，xxxx的方式初始化，而是有专门的指令，就是lgdt。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　lgdt指令格式是： lgdt 48位内存数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这48位内存数据分为两部分，前16位是GDT以字节为单位的界限值，后32位是GDT的其实地址，由于GDT的大小是16位，所以范围是65536字节，每个描述符大小是8字节，所以一个GDT中有8192个段或门。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在保护模式下，原本存在段寄存器的段基址，现在放在了段描述符中，而段寄存器中放入的是选择子，就是一个索引，在描述符表中索引描述符的索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　段寄存器是16位的，所以选择子也是16位的，在其低2位即0~1位，用来存储RPL，即请求特权级，可以表示四种特权。高13位，即3~15是索引部分，2的13次方是8192，故可以索引8192个段，正好吻合GDT的8192个段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下图是描述符表和内存段的关系，还有选择子的结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729134755849-1302022171.png&quot; alt=&quot;&quot;/&gt;         &lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729134859716-1434723208.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;　　1. 打开A20地址线&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　打开A20Gate的方式极其简单，只需要将0x92端口的第一个位置置1就好了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; al,0x92
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;or&lt;/span&gt;&lt;span&gt; al,0000_0010B
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;out&lt;/span&gt; 0x92,al
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;　　2.保护模式的开关，CR0寄存器的PE位&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　这是进入保护模式的最后一步，CR0寄存器的PE位置1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729135909057-593321958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180729135926655-1407459277.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　PE为0表示在实模式下运行，PE为1表示在保护模式运行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax,cr0
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;or&lt;/span&gt;&lt;span&gt; eax,0x00000001
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; cr0,eax
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　　　写入完毕，接下来可以让我们进入保护模式了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;boot.inc :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt;-------------     loader和kernel   ----------&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;LOADER_BASE_ADDR equ 0x900 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;LOADER_START_SECTOR equ 0x2
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt;--------------   gdt描述符属性  -------------&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;DESC_G_4K   equ      1_00000000000000000000000b   
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;DESC_D_32   equ       1_0000000000000000000000b
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; DESC_L        equ        0_000000000000000000000b    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;  64位代码标记，此处标记为0便可。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; DESC_AVL    equ         0_00000000000000000000b    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;  cpu不用此位，暂置为0  &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;DESC_LIMIT_CODE2  equ 1111_0000000000000000b
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;DESC_LIMIT_VIDEO2  equ 0000_000000000000000b
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;DESC_P        equ          1_000000000000000b
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;DESC_DPL_0  equ           00_0000000000000b
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;DESC_DPL_1  equ           01_0000000000000b
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;DESC_DPL_2  equ           10_0000000000000b
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;DESC_DPL_3  equ           11_0000000000000b
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;DESC_S_CODE equ             1_000000000000b
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;DESC_S_DATA equ      DESC_S_CODE
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;DESC_S_sys  equ             0_000000000000b
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; DESC_TYPE_CODE  equ          1000_00000000b    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  &lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; DESC_TYPE_DATA  equ          0010_00000000b    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; DESC_CODE_HIGH4 equ (0x00 &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;&lt;span&gt;) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; DESC_DATA_HIGH4 equ (0x00 &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;&lt;span&gt;) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; DESC_VIDEO_HIGH4 equ (0x00 &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;&lt;span&gt;) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt;--------------   选择子属性  ---------------&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; RPL0  equ   &lt;span&gt;00b&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; RPL1  equ   &lt;span&gt;01b&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; RPL2  equ   1&lt;span&gt;0b&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;RPL3  equ   11b
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; TI_GDT     equ   &lt;span&gt;000b&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; TI_LDT     equ   1&lt;span&gt;00b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;loader.asm：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    %include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boot.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   section loader vstart=LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   LOADER_STACK_TOP equ LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; loader_start                
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;GDT_BASE:&lt;/span&gt;&lt;span&gt;   dd    0x00000000 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;           dd    0x00000000
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;CODE_DESC:&lt;/span&gt;&lt;span&gt;  dd    0x0000FFFF 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;           dd    DESC_CODE_HIGH4
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;    &lt;span&gt;DATA_STACK_DESC:&lt;/span&gt;&lt;span&gt;  dd    0x0000FFFF
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;             dd    DESC_DATA_HIGH4
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;VIDEO_DESC:&lt;/span&gt; dd    0x80000007           &lt;span&gt;;&lt;/span&gt;&lt;span&gt;limit=(0xbffff-0xb8000)/4k=0x7&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;           dd    DESC_VIDEO_HIGH4  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   GDT_SIZE   equ   $ - GDT_BASE
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;    GDT_LIMIT   equ   GDT_SIZE -    &lt;span&gt;1&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;    times &lt;span&gt;60&lt;/span&gt; dq &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    SELECTOR_CODE equ (0x0001&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) + TI_GDT + RPL0         
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    SELECTOR_DATA equ (0x0002&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) + TI_GDT + RPL0    
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    SELECTOR_VIDEO equ (0x0003&amp;lt;&amp;lt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) + TI_GDT + RPL0     
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;   gdt_ptr  dw  GDT_LIMIT 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        dd  GDT_BASE
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;    loadermsg db &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2 loader in real.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;loader_start:&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     sp, LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     bp, loadermsg           
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;     cx, &lt;span&gt;17&lt;/span&gt;            
&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     ax, 0x1301        
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     bx, 0x001f         
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     dx, 0x1800        
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;     0x10                    
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;in&lt;/span&gt;&lt;span&gt; al,0x92
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;    &lt;span&gt;or&lt;/span&gt;&lt;span&gt; al,0000_0010B
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;    &lt;span&gt;out&lt;/span&gt;&lt;span&gt; 0x92,al
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;    &lt;span&gt;lgdt&lt;/span&gt;&lt;span&gt; [gdt_ptr]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax, cr0
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;    &lt;span&gt;or&lt;/span&gt;&lt;span&gt; eax, 0x00000001
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; cr0, eax
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;    &lt;span&gt;;&lt;/span&gt;&lt;span&gt;jmp dword SELECTOR_CODE:p_mode_start&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;    &lt;span&gt;jmp&lt;/span&gt;  &lt;span&gt;SELECTOR_CODE:&lt;/span&gt;&lt;span&gt;p_mode_start     
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; [bits &lt;span&gt;32&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;p_mode_start:&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax, SELECTOR_DATA
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ds, ax
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; es, ax
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ss, ax
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; esp,LOADER_STACK_TOP
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax, SELECTOR_VIDEO
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; gs, ax
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;    &lt;span&gt;jmp&lt;/span&gt; $
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Antz_mbr.asm：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; %include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boot.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;SECTION MBR vstart=0x7c00
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,cs
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ds,ax
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; es,ax
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ss,ax
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; fs,ax
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; sp,0x7c00
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,0xb800
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; gs,ax
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     ax, 0600h
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     bx, 0700h
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;     cx, &lt;span&gt;0&lt;/span&gt;                
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     dx, 184fh        
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;&lt;span&gt;     10h                    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x00],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x01],0xA4
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x02],&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x03],0xA4
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x04],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x05],0xA4    
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x06],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x07],0xA4
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x08],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x09],0xA4
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax,LOADER_START_SECTOR     
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; bx,LOADER_BASE_ADDR      
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;    &lt;span&gt;mov&lt;/span&gt; cx,&lt;span&gt;4&lt;/span&gt;             
&lt;span&gt;36&lt;/span&gt;    &lt;span&gt;call&lt;/span&gt;&lt;span&gt; rd_disk_m_16         
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;    &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;rd_disk_m_16:&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt; esi,eax      &lt;span&gt;;&lt;/span&gt;&lt;span&gt;备份eax&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; di,cx        
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f2
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; al,cl
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al           
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax,esi       
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f3
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt; cl,&lt;span&gt;8&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;       &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f4
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;       &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f5
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;       &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;       &lt;span&gt;and&lt;/span&gt;&lt;span&gt; al,0x0f      
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;       &lt;span&gt;or&lt;/span&gt;&lt;span&gt; al,0xe0      
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f6
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f7
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; al,0x20
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;       &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;   .&lt;span&gt;not_ready:&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;       &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;       &lt;span&gt;in&lt;/span&gt;&lt;span&gt; al,dx
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;       &lt;span&gt;and&lt;/span&gt;&lt;span&gt; al,0x88       
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;       &lt;span&gt;cmp&lt;/span&gt;&lt;span&gt; al,0x08
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;       &lt;span&gt;jnz&lt;/span&gt;&lt;span&gt; .not_ready     
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; 
&lt;span&gt;82&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax, di
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt; dx, &lt;span&gt;256&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;       &lt;span&gt;mul&lt;/span&gt;&lt;span&gt; dx
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; cx, ax       
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; 
&lt;span&gt;87&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx, 0x1f0
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;   .&lt;span&gt;go_on_read:&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt;       &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ax,dx
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;       &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; [bx],ax
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;       &lt;span&gt;add&lt;/span&gt; bx,&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;      loop .go_on_read
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;       &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt; 
&lt;span&gt;95&lt;/span&gt;    times &lt;span&gt;510&lt;/span&gt;-($-$$) db &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;96&lt;/span&gt;    db 0x55,0xaa
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 29 Jul 2018 06:21:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz05.html</dc:identifier>
</item>
</channel>
</rss>