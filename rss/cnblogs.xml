<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WebService短信网关配置 - 不是植物</title>
<link>http://www.cnblogs.com/zhuziyu/p/8359963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuziyu/p/8359963.html</guid>
<description>&lt;p&gt;&lt;strong&gt;第一步：WebService框架选择【以CXF为例】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、下载地址：http://cxf.apache.org/download.html，请事先安装好JDK（本人使用的是apache-cxf-2.7.18，JDK1.7）&lt;/p&gt;
&lt;p&gt;2、第二步：解压apache-cxf-2.7.11.zip到指定目录，环境变量设置：创建CXF_HOME并加到path下&lt;/p&gt;
&lt;p&gt;3、在cmd下加入wsdl2java–h&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1019160/201801/1019160-20180126152822975-1962848498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;显示以上结果，成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：解析wsdl文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、使用短信方提供的wsdl地址，右键另存为wsdl文件（以wsdl.wsdl为例）&lt;/p&gt;
&lt;p&gt;2、在cmd输入以下命令&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;wsdl2java -p com.ucp -d D:\\ucp -all D:\\cxf\\wsdl.wsdl  根据D:\\cxf\\wsdl.wsdl文件生成代码，com.ucp是指定包名，方便复制到实际项目中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、将生成的代码拷贝到实际项目中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1019160/201801/1019160-20180126152741694-1839524672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第三步：代码导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般只需要用到这个ExtCommandServicePortType_ExtCommandServiceHttpPort_Client.java类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ucp;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Please modify this class to meet your needs
 * This class is not complete
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.MalformedURLException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URL;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.namespace.QName;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jws.WebMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jws.WebParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jws.WebResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.jws.WebService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.annotation.XmlSeeAlso;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.ws.RequestWrapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.ws.ResponseWrapper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * This class was generated by Apache CXF 2.7.18
 * 2017-10-12T11:23:03.075+08:00
 * Generated source version: 2.7.18
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtCommandServicePortType_ExtCommandServiceHttpPort_Client {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; QName SERVICE_NAME = &lt;span&gt;new&lt;/span&gt; QName(&quot;http://service.message.wiscom.com&quot;, &quot;ExtCommandService&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ExtCommandServicePortType_ExtCommandServiceHttpPort_Client() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String args[]) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.lang.Exception {
        URL wsdlURL &lt;/span&gt;=&lt;span&gt; ExtCommandService.WSDL_LOCATION;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.length &amp;gt; 0 &amp;amp;&amp;amp; args[0] != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&quot;&quot;.equals(args[0&lt;span&gt;])) { 
            File wsdlFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(args[0&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (wsdlFile.exists()) {
                    wsdlURL &lt;/span&gt;=&lt;span&gt; wsdlFile.toURI().toURL();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    wsdlURL &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; URL(args[0&lt;span&gt;]);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MalformedURLException e) {
                e.printStackTrace();
            }
        }
      
        ExtCommandService ss &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtCommandService(wsdlURL, SERVICE_NAME);
        ExtCommandServicePortType port &lt;/span&gt;=&lt;span&gt; ss.getExtCommandServiceHttpPort();  
        
        {
        System.out.println(&lt;/span&gt;&quot;Invoking createMo...&quot;&lt;span&gt;);
        java.lang.String _createMo_in0 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.String _createMo_in1 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.String _createMo_in2 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.Long _createMo__return &lt;/span&gt;=&lt;span&gt; port.createMo(_createMo_in0, _createMo_in1, _createMo_in2);
        System.out.println(&lt;/span&gt;&quot;createMo.result=&quot; +&lt;span&gt; _createMo__return);


        }
        {
        System.out.println(&lt;/span&gt;&quot;Invoking createMessage...&quot;&lt;span&gt;);
        com.ucp.ArrayOfString _createMessage_in0 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        java.lang.String _createMessage_in1 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.String _createMessage_in2 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.String _createMessage_in3 &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        java.lang.Long _createMessage__return &lt;/span&gt;=&lt;span&gt; port.createMessage(_createMessage_in0, _createMessage_in1, _createMessage_in2, _createMessage_in3);
        System.out.println(&lt;/span&gt;&quot;createMessage.result=&quot; +&lt;span&gt; _createMessage__return);

        }
        System.exit(&lt;/span&gt;0&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第四步：根据代码的接口调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;推荐使用配置文件加载参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = Logger.getLogger(&quot;DefaultSmsSender&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String ucpSmsUrl;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String ucpMsg;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String apiKey;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; QName SERVICE_NAME = &lt;span&gt;new&lt;/span&gt; QName(&quot;http://service.message.wiscom.com&quot;, &quot;ExtCommandService&quot;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        Properties prop &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            prop.load(UcpSmsSender.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/registerConf.properties&quot;&lt;span&gt;));
            ucpSmsUrl&lt;/span&gt;=prop.getProperty(&quot;ucpSmsUrl&quot;&lt;span&gt;);
            apiKey&lt;/span&gt;=prop.getProperty(&quot;apiKey&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            logger.error(&lt;/span&gt;&quot;加载配置文件异常&quot;&lt;span&gt;, e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送短信&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; send(String mobile, String msg) {
        logger.info(String.format(&lt;/span&gt;&quot;请求发送短信[%s, %s]&quot;&lt;span&gt;, mobile, msg));
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            msg &lt;/span&gt;= URLEncoder.encode(msg, &quot;UTF-8&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;start to send sms&quot;&lt;span&gt;);
            String tmp &lt;/span&gt;=httpPost(smsUrl, &quot;id=&quot;+smsAccount+&quot;&amp;amp;psw=&quot;+smsPassword+&quot;&amp;amp;mobile=&quot;+mobile+&quot;&amp;amp;msg=&quot;+&lt;span&gt;msg);
            System.out.println(tmp);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(tmp!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;tmp.contains(&quot;\&quot;msg\&quot;: \&quot;Success\&quot;&quot;&lt;span&gt;)){
                System.out.println(&lt;/span&gt;&quot;success to send sms&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
            System.out.println(&lt;/span&gt;&quot;fail to send sms&quot;&lt;span&gt;);
            e.printStackTrace();
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据返回结果，匹配&lt;/p&gt;
&lt;blockquote&gt;
&lt;table class=&quot;MsoNormalTable&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;返回值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;错误描述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;成功&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;提交参数不能为空&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;账号无效&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;账号密码错误&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;时间格式不正确&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;格式为：&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm:ss&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;span&gt;20&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;系统错误&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;

</description>
<pubDate>Fri, 26 Jan 2018 07:52:00 +0000</pubDate>
<dc:creator>不是植物</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuziyu/p/8359963.html</dc:identifier>
</item>
<item>
<title>JavaScript语法基础：数组的常用方法详解 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8359654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8359654.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;https://www.cnblogs.com/smyhvae/p/8359654.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数组的定义&quot;&gt;数组的定义&lt;/h2&gt;
&lt;p&gt;之前学习的数据类型，只能存储一个值（字符串为一个值）。如果我们想存储多个值，就可以使用数组。&lt;/p&gt;
&lt;h3 id=&quot;数组的定义-1&quot;&gt;数组的定义&lt;/h3&gt;
&lt;p&gt;（1）字面量定义。举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var arr = [1,2,3];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）对象定义（数组的构造函数）。格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var arr = new Array(参数);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数位置是一个数值时，表示数组长度；多个数值时，表示数组中的元素。&lt;/p&gt;
&lt;h3 id=&quot;数组的操作&quot;&gt;数组的操作&lt;/h3&gt;
&lt;p&gt;1、求数组的长度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    数组的长度 = 数组名.length；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过修改数组的长度来改变数组中元素的个数，如果改小了，数组将从后面删除元素。（伪数组arguments的长度可以修改，但是不能修改里面的元素，后面单独讲）&lt;/p&gt;
&lt;p&gt;2、获取数组中的元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    数组中的指定元素 = 数组名[索引值];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组的索引代表的是数组中的元素在数组中的位置，从0开始。&lt;/p&gt;
&lt;p&gt;如果索引值有误（比如元素没那么多），系统不报错，而是会给定值为undefined。&lt;/p&gt;
&lt;h3 id=&quot;遍历数组重要&quot;&gt;遍历数组（重要）&lt;/h3&gt;
&lt;p&gt;遍历数组即：获取并操作数组中的每一个元素。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;生命壹号&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;许嵩&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;永不止步&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr[i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// arr[i]代表的是数组中的每一个元素i&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180124_2008.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数组array的常用方法&quot;&gt;数组Array的常用方法&lt;/h2&gt;
&lt;p&gt;Array数组是属于&lt;strong&gt;内置对象&lt;/strong&gt;，我们可以在下面的网站上查询各种方法。&lt;/p&gt;
&lt;p&gt;Array有各种api接口（Application Programming Interface，应用程序编程接口），下面分别介绍。&lt;/p&gt;
&lt;p&gt;（1）判断是否为数组：instanceof&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    布尔类型值 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; A &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; B&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：判断A是否为B类型（instanceof 是一个关键字）。&lt;/p&gt;
&lt;p&gt;在数组里，这种方法已经用的不多了，因为有下面这种方法。&lt;/p&gt;
&lt;p&gt;（2）判断是否为数组：isArray()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    布尔类型值 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt;(被检测的值) &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PS：属于HTML5中新增的方法。&lt;/p&gt;
&lt;p&gt;（3）转换数组：toString()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    字符串 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：把数组转换成字符串，每一项用&lt;code&gt;,&lt;/code&gt;分割。&lt;/p&gt;
&lt;p&gt;（4）返回数组本身：valueOf()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    数组本身 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;valueOf&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的意义不大。因为我们指直接写数组对象的名字，就已经是数组本身了。&lt;/p&gt;
&lt;p&gt;（5）将数组中的元素用符号连接成字符串：join()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    字符串 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(参数)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数决定用什么符号进行连接。如果不写参数，则和toString()的效果一致。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;生命壹号&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;许嵩&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;棒棒哒&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//无参数&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//用空格进行连接&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//用空字符串进行连接&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//用符号&quot;&amp;amp;&quot;进行连接&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    生命壹号,许嵩,棒棒哒

    生命壹号 许嵩 棒棒哒

    生命壹号许嵩棒棒哒

    生命壹号&amp;amp;许嵩&amp;amp;棒棒哒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;join方法有一定的实际用途：当我们需要把一堆字符串进行连接时，我们可以把他们转换成数组，然后调用数组的join()方法。这样做有个好处是：内存不会溢出。&lt;/p&gt;
&lt;h2 id=&quot;伪数组arguments&quot;&gt;伪数组：arguments&lt;/h2&gt;
&lt;p&gt;arguments代表的是实参。有个讲究的地方是：arguments&lt;strong&gt;只在函数中使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（1）返回函数&lt;strong&gt;实参&lt;/strong&gt;的个数：arguments.length&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(a&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;b) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arguments)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;//获取形参的个数&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//获取实参的个数&lt;/span&gt;

        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;----------------&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180125_2140.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）返回正在执行的函数：arguments.callee&lt;/p&gt;
&lt;p&gt;在使用函数&lt;strong&gt;递归&lt;/strong&gt;调用时，推荐使用arguments.callee代替函数名本身。&lt;/p&gt;
&lt;p&gt;（3）之所以说arguments是伪数组，是因为：&lt;strong&gt;arguments可以修改元素，但不能改变数组的长短&lt;/strong&gt;。举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(a&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;b) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        arguments[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//将实参的第一个数改为99&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//此方法不通过，因为无法增加元素&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;数组的添加和删除&quot;&gt;数组的添加和删除&lt;/h2&gt;
&lt;p&gt;（1）push()：在数组&lt;strong&gt;最后面&lt;/strong&gt;插入项，返回数组的长度&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    数组改后的长度 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(元素)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）pop()：取出数组中的&lt;strong&gt;最后一个&lt;/strong&gt;元素，返回被删除的元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    被删除的元素 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;pop&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）unshift()：在数组&lt;strong&gt;最前面&lt;/strong&gt;插入项，返回数组的长度&lt;/p&gt;
&lt;p&gt;数组改后的长度 = 数组.unshift(元素);&lt;/p&gt;
&lt;p&gt;（4）shift()：取出数组中的&lt;strong&gt;第一个&lt;/strong&gt;元素，返回被删除的元素&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    被删除的元素 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;shift&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;数组的反转和排序&quot;&gt;数组的反转和排序&lt;/h2&gt;
&lt;p&gt;（1）reverse()：翻转数组（返回值是反转后的数组，而且&lt;strong&gt;原数组也已经被反转了&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    反转后的数组  =  数组.reverse();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;co&quot;&gt;//反转前打印&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;reverse&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//反转&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;co&quot;&gt;//反转后打印&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180125_2220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：反转后，打印原来的数组发现，原来的数组已经被反转了。&lt;/p&gt;
&lt;p&gt;（2）sort()：给数组排序，返回排序后的数组（排序的规则看参数）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    从小到大排序后的数组 = 数组.sort(function(a,b){
                                      return a-b;
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的这个带参的排序，其实是调用了底层的&lt;strong&gt;冒泡排序&lt;/strong&gt;，小的排前面，大的排后面。&lt;/p&gt;
&lt;p&gt;PS：sort方法的功能非常强大，能对数字和字母进行排列。&lt;/p&gt;
&lt;h2 id=&quot;数组的一些其他方法&quot;&gt;数组的一些其他方法&lt;/h2&gt;
&lt;p&gt;（1）concat() ：把参数拼接到当前数组（原数组不会被修改）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    新数组 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组&lt;span class=&quot;fl&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;concat&lt;/span&gt;(数组&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;concat&lt;/span&gt;(arr2))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//把参数拼接到当前数组&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1040.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从打印结果中可以看到，原数组（数组1、数组2）并没有被修改。&lt;/p&gt;
&lt;p&gt;（2）slice()：从当前数组中截取一个新的数组（不影响原来的数组）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    新数组 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 原数组.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(开始位置index，结束位置index)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//注意：索引值包括左边的，不包括右边的&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//从第二个值开始截取&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//截取从第二个到第四个之间的值（不包括第四个值）&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//截取最后两个值&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//空&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）splice()：删除当前数组的某些元素（原数组会被改变）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    新数组 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组&lt;span class=&quot;fl&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;splice&lt;/span&gt;(起始索引index，需要操作的个数，弥补的值)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr11 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr12 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr11&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;splice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//从第一个位置开始，删除元素&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;原数组：&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;arr11)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;新数组：&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;arr12)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-----------&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr21 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr22 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr21&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;splice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//从第一个元素开始删除，一共删除3个元素&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr21)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr22)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1113.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：第三个参数很少用，这里先不讲。&lt;/p&gt;
&lt;p&gt;（3）获取数据的索引：indexOf()、lastIndexOf()&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    索引值 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 数组.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;/&lt;span class=&quot;at&quot;&gt;lastIndexOf&lt;/span&gt;(数组中的元素内容)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PS：如果没找到返回-1。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;//从前往后，找&quot;c&quot;在哪个位置&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lastIndexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//从前往后，找&quot;d&quot;在哪个位置&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1125.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数组迭代方法&quot;&gt;数组迭代方法&lt;/h2&gt;
&lt;p&gt;数组迭代方法包括：every()、filter()、forEach()、map()、some()&lt;/p&gt;
&lt;p&gt;PS：这几个方法&lt;strong&gt;不会修改原数组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数组/boolean/无 = 数组.every/filter/forEach/map/some(
                            function(element,index,arr){
                                            程序和返回值；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这几种方法，就可以替代一些for循环了。下面依次来介绍。&lt;/p&gt;
&lt;h3 id=&quot;every方法&quot;&gt;every()方法&lt;/h3&gt;
&lt;p&gt;解释：对数组中每一项运行回调函数，如果都返回true，every就返回true；如果有一项返回false，则停止遍历，此方法返回false。&lt;/p&gt;
&lt;p&gt;注意：every()方法的返回值是boolean值，参数是回调函数。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;南山忆&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; bool1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;every&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (element&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(bool1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;南山&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; bool2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;every&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (element&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(bool2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//输出结果：true。因为每个元素的长度都是两个字符。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;some方法&quot;&gt;some()方法&lt;/h3&gt;
&lt;p&gt;解释：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。&lt;/p&gt;
&lt;h3 id=&quot;filter方法&quot;&gt;filter()方法&lt;/h3&gt;
&lt;p&gt;解释：对数组中每一项运行回调函数，该函数返回结果是true的项，将组成新的数组（返回值就是这个新的数组）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;南山忆&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (element&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//arr1中的元素，如果是长度超过2个字符的，我就把它放到arr2中去&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1410.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;foreach方法&quot;&gt;forEach()方法&lt;/h3&gt;
&lt;p&gt;解释：遍历数组。&lt;/p&gt;
&lt;p&gt;注意：无返回值，纯粹操作数组中的元素，所以应用场景并不多。&lt;/p&gt;
&lt;h3 id=&quot;map方法&quot;&gt;map()方法&lt;/h3&gt;
&lt;p&gt;解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回值就是这个新的数组）。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;南山忆&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (element&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; element &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;vae&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//给arr1中所有的元素增加字符串&quot;vae&quot;，放到arr2中。&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1425.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;清空数组&quot;&gt;清空数组&lt;/h2&gt;
&lt;p&gt;清空数组，有以下几种方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; array &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;splice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;//方式1：删除数组中所有项目&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;//方式1：length属性可以赋值，在其它语言中length是只读&lt;/span&gt;
    array &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;//方式3：推荐&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;数组练习&quot;&gt;数组练习&lt;/h2&gt;
&lt;h3 id=&quot;练习1&quot;&gt;练习1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：将一个字符串数组输出为&lt;code&gt;|&lt;/code&gt;分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;方式1：（不推荐）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; str &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; arr[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; separator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;|&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        str &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; separator&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;arr[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//从第1个数组元素开始，每个元素前面加上符号&quot;|&quot;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(str)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不推荐这种方式，因为：由于字符串的不变性，str拼接过多的话，容易导致内存溢出（很多个str都堆放在栈里）。&lt;/p&gt;
&lt;p&gt;方式2：（推荐。通过array数组自带的api来实现）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;千古&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;宿敌&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;素颜&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;|&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1339.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;练习2&quot;&gt;练习2&lt;/h3&gt;
&lt;p&gt;题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第i个和第length-i-1个进行交换。&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;p&gt;方式1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;   &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;reverse&lt;/span&gt;(array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; newArr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
           newArr[&lt;span class=&quot;va&quot;&gt;newArr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; newArr&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2：（算法里比较常见的方式）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;   &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;reverse&lt;/span&gt;(array)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; temp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
           array[i] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[&lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
           array[&lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;i] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; temp&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
       &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; array&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式3：（数组自带的reverse方法）&lt;/p&gt;
&lt;p&gt;现在我们学习了数组自带的api，我们就可以直接使用reverse()方法。&lt;/p&gt;
&lt;h3 id=&quot;练习3&quot;&gt;练习3&lt;/h3&gt;
&lt;p&gt;问题：针对工资的数组[1500,1200,2000,2100,1800]，把工资超过2000的删除。&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1500&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1800&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;arr1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (ele&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; array) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (ele &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1435.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;练习4&quot;&gt;练习4&lt;/h3&gt;
&lt;p&gt;问题：找到数组[&quot;c&quot;,&quot;a&quot;,&quot;z&quot;,&quot;a&quot;,&quot;x&quot;,&quot;a&quot;]中每一个元素出现的次数。&lt;/p&gt;
&lt;p&gt;分析：这道题建议用json数据来做，因为我们想知道a出现了几次，c出现了几次，x出现了几次。恰好&lt;code&gt;k:v .. k:v&lt;/code&gt;这种键值对的形式就比数组方便很多了。&lt;/p&gt;
&lt;p&gt;键值对的形式：用key代表数组中的元素，用value代表元素出现的次数。&lt;/p&gt;
&lt;p&gt;略难，答案暂略。&lt;/p&gt;
&lt;h3 id=&quot;练习5&quot;&gt;练习5&lt;/h3&gt;
&lt;p&gt;问题：编写一个方法去掉一个数组中的重复元素。&lt;/p&gt;
&lt;p&gt;分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//    编写一个方法 去掉一个数组的重复元素&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; aaa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(aaa)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;(array)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; newArr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//开闭原则&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//每次都要判断新数组中是否有旧数组中的值。&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;newArr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(array[i] &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; newArr[j])&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    bool &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(bool)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                newArr[&lt;span class=&quot;va&quot;&gt;newArr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; array[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; newArr&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 07:12:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8359654.html</dc:identifier>
</item>
<item>
<title>MySQL复制以及调优 - {-）大傻逼</title>
<link>http://www.cnblogs.com/s-b-b/p/8359355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/s-b-b/p/8359355.html</guid>
<description>&lt;h2 id=&quot;一.-简介&quot;&gt;一. 简介&lt;/h2&gt;
&lt;p&gt;MySQL自带复制方案，带来好处有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据备份。&lt;/p&gt;&lt;p&gt;负载均衡。&lt;/p&gt;&lt;p&gt;分布式数据。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;概念介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;主机（master）：被复制的数据库。&lt;/p&gt;&lt;p&gt;从机（slave）：复制主机数据的数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复制步骤：&lt;br/&gt;(1). master记录更改的明细，存入到二进制日志（binary log）。&lt;br/&gt;(2). master发送同步消息给slave。&lt;br/&gt;(3). slave收到消息后，将master的二进制日志复制到本地的中继日志（relay log）。&lt;br/&gt;(4). slave重现中继日志中的消息，从而改变数据库的数据。&lt;/p&gt;
&lt;p&gt;下面放一张经典的图片来说明这一过程：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799055/201801/799055-20180126142708928-553004344.png&quot; alt=&quot;复制原理图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二.-实现复制&quot;&gt;二. 实现复制&lt;/h2&gt;
&lt;p&gt;实现复制有以下步骤：&lt;/p&gt;
&lt;h4 id=&quot;设置mysql主库的二进制日志以及server-id&quot;&gt;1.设置MySQL主库的二进制日志以及server-id&lt;/h4&gt;
&lt;p&gt;MySQL配置文件一般存放在/etc/my.cnf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在[mysqld]下面添加配置选项
[mysqld]
server-id=1
log-bin=mysql-bin.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;server-id是数据库在整个数据库集群中的唯一标示，必须保持唯一。&lt;br/&gt;重启MySQL。&lt;br/&gt;&lt;code&gt;注：如果MySQL配置文件中已经配置过此文件，则可以跳过此步。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;新建复制账号&quot;&gt;2.新建复制账号&lt;/h4&gt;
&lt;p&gt;在主库里面新建用于从库复制主库数据的账号，并授予复制权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO user_name@'host' IDENTIFIED BY 'password';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置mysql主库server-id&quot;&gt;3.设置MySQL主库server-id&lt;/h4&gt;
&lt;p&gt;和第二步配置一样，要注意的地方有两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果不需要从库作为别的从库的主库的话，则不需要配置二进制日志。&lt;/li&gt;
&lt;li&gt;很多时候复制并不需要复制主库的全部数据库（特别是mysql的信息配置库）。因此可以配置replicate_do_db来指定复制的数据库&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;从库初始化主库的数据&quot;&gt;4.从库初始化主库的数据&lt;/h4&gt;
&lt;p&gt;如果数据量不算大的情况下，可以使用mysqldump工具导出主库数据，然后导入到从库里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump --single-transaction --triggers --master-data databasename &amp;gt; data.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果数据量大的情况下应该使用Xtrabackup去进行数据库的导出，此处不做介绍。&lt;br/&gt;可能会有同学问，为什么不直接使用二进制日志进行初始化呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果我们主库运行了比较长的一段时间，并不太适合使用从库根据二进制日志进行复制数据，直接使用二进制日志去初始化从库会比较耗费时间和性能。&lt;/li&gt;
&lt;li&gt;更多的情况下，主库的二进制日志的配置项没有打开，因此也就不存在以前操作的二进制日志。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;开启复制&quot;&gt;5.开启复制&lt;/h4&gt;
&lt;p&gt;从库执行下面命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; CHANGE MASTER TO MASTER_HOST='host',
-&amp;gt; MASTER_USER='user',
-&amp;gt; MASTER_PASSWORD='password',
-&amp;gt; MASTER_LOG_FILE='mysql-bin.000001',
-&amp;gt; MASTER_LOG_POS=0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意最后的两个命令：MASTER_LOG_FILE和MASTER_LOG_POS，表示从库的从哪个二进制文件开始读取，偏移量从那里开始，这两个参数可以从我们导入的SQL里面找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799055/201801/799055-20180126142716334-553376331.png&quot; alt=&quot;导入注意&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启复制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start slave;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候就完成了复制，在主库更新一个数据或者新增数据在从库都可以查询到结果。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799055/201801/799055-20180126142728881-1343883684.png&quot; alt=&quot;查看复制&quot;/&gt;&lt;br/&gt;在主库上也可以查询的到复制线程的状态。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/799055/201801/799055-20180126143212615-1271193861.png&quot; alt=&quot;线程状态&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三.-复制的日志格式&quot;&gt;三. 复制的日志格式&lt;/h2&gt;
&lt;p&gt;MySQL复制的日志格式有三种，根据主库存放数据的方式不同有以下三种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;基于行的格式复制，记录需要修改的每行的数据信息。 如果一个SQL修改了2w行的数据，那么就会记录2w行的日志格式&lt;/td&gt;
&lt;td&gt;保证了数据的强一致性，且由于记录的是执行后的结果，在从库上执行还原也会比较快&lt;/td&gt;
&lt;td&gt;日志记录数量很多，主从之间的传输需要更多的时间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;statement&lt;/td&gt;
&lt;td&gt;基于段的日志格式复制，也就是记录下更改的SQL记录，而不是更改的行的记录。&lt;/td&gt;
&lt;td&gt;日志记录量最小。&lt;/td&gt;
&lt;td&gt;对于一些输出结果不确定的函数，在从库上执行一遍很可能会出现问题，如uuid，从库根据日志还原主库数据的时候需要执行一遍SQL，时间相对较慢。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;mixed&lt;/td&gt;
&lt;td&gt;混合上面两种日志格式记录记录日志，至于什么时候使用哪种日志方式由MySQL本身决定。&lt;/td&gt;
&lt;td&gt;可以平衡上面两种日志格式的优缺点。&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;mysql5.7以前默认使用statement格式。&lt;br/&gt;设置方式，可以在配置文件设置（首选）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;binlog_format=ROW&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或临时设置全局变量（当前mysql连接有效）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;查看日志格式
mysql &amp;gt; show variables like 'binlog_format';

设置日志格式
mysql &amp;gt; set binlog_format='row';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于两个主从服务器一般都会放在同一个机房里面，两者之间同步的速度会会比较快，为保证强一致性，应该首选行的日志格式记录（row），保证传输素速度可以选择混合方式（mixed）。&lt;br/&gt;而行的日志格式有下面三种记录方式：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;minimal&lt;/td&gt;
&lt;td&gt;只记录被修改列的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;full&lt;/td&gt;
&lt;td&gt;记录被修改的行的全部列的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;noblob&lt;/td&gt;
&lt;td&gt;特点同上，只是如果没有修改blob和text类型的列的情况下，不会记录这些列的数据（也就是大数据列）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;mysql默认是full，最好修改成minimal。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;binlog_row_image=minimal&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四.-主从复制延迟&quot;&gt;四. 主从复制延迟&lt;/h2&gt;
&lt;p&gt;由于主库和从库之间不在同一个主机上，数据同步之间不可以避免地具有延迟，解决的方法有添加缓存，业务层的跳转等待，如果非得从数据库层面去减缓延迟问题，可以从复制时候的三大步骤（主库产生日志，主从传输日志，从库还原日志内容）入手：&lt;br/&gt;1.主库写入到日志的速度&lt;br/&gt;控制主库的事务大小，分割大事务为多个小事务。&lt;br/&gt;如插入20w的数据，改成插入多次5000行（可以利用分页的思路）&lt;/p&gt;
&lt;p&gt;2.二进制日志在主从之间传输时间&lt;br/&gt;主从之间尽量在同一个机房或地域。&lt;br/&gt;日志格式改用MIXED，且设置行的日志格式未minimal，原理详见上面的日志格式介绍。&lt;/p&gt;
&lt;p&gt;3.减少从库还原日志的时间&lt;br/&gt;在MySQL5.7版本后可以利用逻辑时钟方式分配SQL多线程。&lt;br/&gt;设置逻辑时钟：slave_parallel_type=‘logical_clock’;&lt;br/&gt;设置复制线程个数：slave_parallel_workers=4;&lt;/p&gt;
&lt;h2 id=&quot;五.-需要注意的地方&quot;&gt;五. 需要注意的地方&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;重启MySQL最好切换未MySQL用户再进行操作，不然文件启动后会有权限问题。&lt;/li&gt;
&lt;li&gt;搭建好MySQL的环境后就设置好配置里的log-bin选项，这样以后如果数据库需要从库的复制，就不需要重启数据库，打断业务的进行。&lt;/li&gt;
&lt;li&gt;需要打开主库的防火墙的对应的mysql端口。&lt;/li&gt;
&lt;li&gt;由于从库同步主库的方式，监听主库发送的信息，而不是轮询，因此如果出现通信出现了故障，重新连接后如果主库没有进行数据更改的操作，从库不会同步数据，因此可以通过插入空事务的方式同步数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;欢迎各位来我博客查看&lt;a href=&quot;http://blog.sbb.fun/blog/SQL/replication.html&quot;&gt;本文&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 06:34:00 +0000</pubDate>
<dc:creator>{-）大傻逼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/s-b-b/p/8359355.html</dc:identifier>
</item>
<item>
<title>物流一站式查询之快递100篇 - 潇十一郎</title>
<link>http://www.cnblogs.com/zhangxiaoyong/p/8317251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoyong/p/8317251.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;连载篇提前看&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8229003.html&quot;&gt;物流一站式查询之TrackingMore篇&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8317229.html&quot;&gt;物流一站式查询之顺丰接口篇&lt;/a&gt;&lt;/h3&gt;
&lt;h3 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/8317251.html&quot;&gt;物流一站式查询之快递100&lt;/a&gt;&lt;/h3&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前两篇我们已经讲了TrackingMore和顺丰接口的场景应用和对接示例，本篇，&lt;span&gt;将会对项目中如何使用快递100物流平台进行物流信息跟踪的对接进行一个全面详细的讲解&lt;/span&gt;。同样，我们会分为&lt;strong&gt;&lt;span&gt;申请接入、&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;物流信息订阅、物流消息推送、物流消息查询&lt;/strong&gt;&lt;/span&gt;等几个步骤分别讲解。各位看官，请拿好你们的板凳和瓜子。我们要开始了，&lt;/p&gt;
&lt;h2&gt;接口申请&lt;/h2&gt;
&lt;p&gt;进入快递100官网&lt;a href=&quot;https://www.kuaidi100.com/&quot; target=&quot;_blank&quot;&gt;https://www.kuaidi100.com/ &lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 在快递接口(API)菜单中，我们可以看到接口申请这个菜单，点击进去会有免费版和企业版两种功能和资费介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126104812428-677063276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们选择企业版，点击企业版，会要求填一些基本信息，我们按要求填完然后点击提交申请即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126104913006-2036162851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;申请之后，有客服会通过联系方式联系所填号码，然后进行需求确认。这时候我们可以注册一个快递100的账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126105036287-271132571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册完之后就可以进行登录了，登录之后在主页面，就可以看到再快递100平台中的账户余额情况，以及下面表格给出的可用的产品、服务等开通的状态(具体开通流程和客服取得联系之后他会协助你完成的)，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126105311053-1950669601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开通各个接口是需要快递100 那边进行审核的，审核通过之后会发邮件出来，附件里面会带有一些接口文档，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126110006694-541545684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 较为重要的是审核结果中会有一个分配好的Key密匙，请求接口的时候需要用到。所以需要妥善保管。&lt;/p&gt;
&lt;p&gt;首先来看一下快递100 给出的订阅和推送的流向示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126104332881-1584171265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;物流订阅&lt;/h2&gt;
&lt;p&gt;拿到接口文档相关秘籍和查阅请求调用流程图之后，我们便可以进行开发了，下面是物流订阅的相关示例步骤：&lt;/p&gt;
&lt;blockquote readability=&quot;58.466304839439&quot;&gt;
&lt;h2&gt;2.1订阅请求&lt;/h2&gt;
&lt;p&gt;发起方:本服务用户，即贵公司&lt;/p&gt;
&lt;p&gt;地址:http://www.kuaidi100.com/poll&lt;/p&gt;
&lt;p&gt;通信协议:HTTP&lt;/p&gt;
&lt;p&gt;请求类型:POST&lt;/p&gt;
&lt;p&gt;字符集:utf-8&lt;/p&gt;
&lt;p&gt;请求内容:&lt;/p&gt;
&lt;p&gt;schema= json/xml             (或者xml,选择json则推送也是json，选择xml则推送也是xml，默认是json)&lt;/p&gt;
&lt;p&gt;param=body&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;&lt;strong&gt;格式(json)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;company&quot;:&quot;yuantong&quot;,          &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;订阅的快递公司的编码，一律用小写字母，见章五《快递公司编码》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;number&quot;:&quot;12345678&quot;,          &lt;/strong&gt; &lt;strong&gt; //&lt;/strong&gt;&lt;strong&gt;订阅的快递单号，单号的最大长度是32个字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;from&quot;:&quot;&lt;/strong&gt;&lt;strong&gt;广东省深圳市南山区&quot;,    &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;出发地城市&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;to&quot;:&quot;&lt;/strong&gt;&lt;strong&gt;北京市朝阳区&quot;,            &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;目的地城市，到达目的地后会加大监控频率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;key&quot;:&quot;&lt;span&gt;*********&lt;/span&gt;&quot;,             &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;授权码，签订合同后发放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;parameters&quot;:{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &quot;callbackurl&quot;:&quot;&lt;/strong&gt; &lt;a href=&quot;http://www&quot;&gt;&lt;strong&gt;http://www&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;您的域名.com/kuaidi?callbackid=&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;...&quot;,&lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;回调地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &quot;salt&quot;:&quot;any string&quot;,    &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;签名用随机字符串（可选）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&quot;resultv2&quot;:&quot;&lt;/strong&gt;1&lt;strong&gt;&quot;          &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;添加此字段表示开通行政区域解析功能（仅对开通签收状态服务用户有效），见章3.1《推送请求》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    }&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;&lt;strong&gt;格式(xml)&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;orderRequest&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;company&amp;gt;yuantong&amp;lt;/company&amp;gt;      &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;订阅的快递公司的编码，一律用小写字母，见章五《快递公司编码》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;number&amp;gt;123123123123&amp;lt;/number&amp;gt;          &lt;/strong&gt; &lt;strong&gt;  //&lt;/strong&gt;&lt;strong&gt;订阅的快递单号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;from&amp;gt;&lt;/strong&gt;&lt;strong&gt;北京市朝阳区东直门外大街&amp;lt;/from&amp;gt;     &lt;/strong&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;出发地城市&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;to&amp;gt;&lt;/strong&gt;&lt;strong&gt;广东省深圳市南山区科技园&amp;lt;/to&amp;gt;        &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;目的地城市，到达目的地后会加大监控频率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;key&amp;gt;**********&amp;lt;/key&amp;gt;                 &lt;/strong&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;授权码，签订合同后发放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;parameters&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&amp;lt;callbackurl&amp;gt;&lt;/strong&gt;&lt;a href=&quot;http://www&quot;&gt;&lt;strong&gt;http://www&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;你的域名.com/kuaidi/push?XXXXX=ZZZZ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&amp;lt;/callbackurl&amp;gt;&lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;回调地址&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&amp;lt;salt&amp;gt;any string&amp;lt;/salt&amp;gt;           &lt;/strong&gt; &lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;签名用随机字符串（可选）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;resultv2&amp;gt;1&amp;lt;/ resultv2&amp;gt;      &lt;/strong&gt;&lt;strong&gt;//&lt;/strong&gt;&lt;strong&gt;添加此字段表示开通行政区域解析功能（仅对开通签收状态服务用户有效），见章3.1《推送请求》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;/parameters&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;/orderRequest&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;①根据订阅请求文档编写请求方法，首先我们编写两个类，一个是快递订阅信息类，另一个是快递100返回信息类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('053d080a-10ff-479d-8d5d-176fe6ea1150')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_053d080a-10ff-479d-8d5d-176fe6ea1150&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_053d080a-10ff-479d-8d5d-176fe6ea1150&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('053d080a-10ff-479d-8d5d-176fe6ea1150',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_053d080a-10ff-479d-8d5d-176fe6ea1150&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递订阅信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KuaiDiInput
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ExpressNumber;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递公司编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CompanyNumber;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 收货地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Address;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回调接口Url
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CallBackUrl;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1c068b5d-3f80-46aa-b490-e6eb13ddb8bc')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1c068b5d-3f80-46aa-b490-e6eb13ddb8bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c068b5d-3f80-46aa-b490-e6eb13ddb8bc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1c068b5d-3f80-46aa-b490-e6eb13ddb8bc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c068b5d-3f80-46aa-b490-e6eb13ddb8bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递100查询公司返回信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KuaiDiOut
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递公司编码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; comCode;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内部字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Id;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内部字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; noCount;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内部字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; noPre;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 内部字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; startTime;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;②编写快递100订阅接口请求类 KuaiDi100，此类中包含的请求方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ade3b484-692e-432c-b62f-99debbdbecee')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_ade3b484-692e-432c-b62f-99debbdbecee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ade3b484-692e-432c-b62f-99debbdbecee&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ade3b484-692e-432c-b62f-99debbdbecee',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ade3b484-692e-432c-b62f-99debbdbecee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 订阅快递单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;input&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; OperationResult Subscibe(KuaiDiInput input)
        {
            WebClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();
            NameValueCollection postVars &lt;/span&gt;=
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameValueCollection();

            String param &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;company\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + input.CompanyNumber + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;number\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + input.ExpressNumber + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;from\&quot;:\&quot;\&quot;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;to\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + TrimAddress(input.Address) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;key\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ConfigHelper.GetKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SendKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;parameters\&quot;:{\&quot;callbackurl\&quot;:\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + input.CallBackUrl + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            param &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            postVars.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;schema&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            postVars.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, param);

            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] byRemoteInfo = client.UploadValues(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.kuaidi100.com/poll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, postVars);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; output =&lt;span&gt; Encoding.UTF8.GetString(byRemoteInfo).ToLower();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GetValueFromJson(output, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; message = GetValueFromJson(output, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (message.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;重复订阅&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OperationResult(message);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OperationResult();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;方法的返回值是自定义的一个 OperationResult类，当前框架业务操作结果 此类返回操作成功或者操作失败，类部分内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aee687f4-50dd-4a24-be10-1a34c9a68b73')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_aee687f4-50dd-4a24-be10-1a34c9a68b73&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aee687f4-50dd-4a24-be10-1a34c9a68b73&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aee687f4-50dd-4a24-be10-1a34c9a68b73',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aee687f4-50dd-4a24-be10-1a34c9a68b73&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 框架业务操作结果
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationResult
    {
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认操作成功
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationResult()
       {
           IsSuccess &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
       }

       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 以操作失败信息实例操作结果
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;failMessage&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;操作失败信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
       &lt;span&gt;public&lt;/span&gt; OperationResult(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; failMessage)
        {
            IsSuccess &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            FailMessage &lt;/span&gt;=&lt;span&gt; failMessage;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另外请求方法中的GetValueFromJson 方法是表示从Json字符串中取出某个值，再前两篇文章中我们也提到过这个方法，这里再贴一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('af39e3ba-23b4-445b-8794-c80727c8e714')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_af39e3ba-23b4-445b-8794-c80727c8e714&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_af39e3ba-23b4-445b-8794-c80727c8e714&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('af39e3ba-23b4-445b-8794-c80727c8e714',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_af39e3ba-23b4-445b-8794-c80727c8e714&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从json字符串中获取字段值
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;json&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;json字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;field&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要解析出值的字段&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetValueFromJson(&lt;span&gt;string&lt;/span&gt; json, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; field)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = json.IndexOf(field + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            start &lt;/span&gt;+= field.Length + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end = json.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, start);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                end &lt;/span&gt;= json.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, start);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; json.Substring(start, end - start).Trim(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;另外，请求方法中的地址我们使用了一个方法去除地址中的特殊字符，方法如下“：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 去除地址中的特殊字符
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;address&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TrimAddress(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; address)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (String.IsNullOrEmpty(address))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; address.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们请求方法就完成了，现在只剩下调用，一般项目中可以写一个服务，定时查询数据库，根据一些特定条件筛选，然后进行接口调用。调用示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
OperationResult result = KuaiDi100.Subscibe(&lt;span&gt;new&lt;/span&gt; KuaiDiInput() { ExpressNumber = item.ExpressNumber, Address = item.Address, CompanyNumber = item.CompanyNumber, CallBackUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;此处是回调地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.IsSuccess)
{
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅成功，记录一些状态&lt;/span&gt;
}&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
{
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅失败，记录一些状态&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;订阅返回的接口示例我们看一下&lt;/p&gt;
&lt;blockquote readability=&quot;32&quot;&gt;
&lt;h2&gt;2.2订阅返回&lt;/h2&gt;
&lt;p&gt;由快递100直接通过订阅请求的response返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回格式（json&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;result&quot;:&quot;true&quot;,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;returnCode&quot;:&quot;200&quot;,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &quot;message&quot;:&quot;&lt;/strong&gt;&lt;strong&gt;提交成功&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回格式（xml&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;orderResponse&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;result&amp;gt;true&amp;lt;/result&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;returnCode&amp;gt;200&amp;lt;/returnCode&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &amp;lt;message&amp;gt;&lt;/strong&gt;&lt;strong&gt;订阅成功&amp;lt;/message&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;/orderResponse&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;result: &quot;true&quot;表示成功，false表示失败&lt;/p&gt;
&lt;p&gt;returnCode:&lt;/p&gt;
&lt;p&gt;         200: 提交成功&lt;/p&gt;
&lt;p&gt;         701: 拒绝订阅的快递公司&lt;/p&gt;
&lt;p&gt;         700: 订阅方的订阅数据存在错误（如不支持的快递公司、单号为空、单号超长等）&lt;/p&gt;
&lt;p&gt;         600: 您不是合法的订阅者（即授权Key出错）&lt;/p&gt;
&lt;p&gt;         500: 服务器错误（即快递100的服务器出理间隙或临时性异常，有时如果因为不按规范提交请求，比如快递公司参数写错等，也会报此错误）&lt;/p&gt;
&lt;p&gt;501:重复订阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;订阅成功后，我们再快递100后台是可以看到订阅记录的，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126123922412-71531937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;物流推送&lt;/h2&gt;
&lt;p&gt;那推送就比较好处理了，推送即是 当物流信息有发生变化时，快递100 就会向请求订阅时所填的回调地址，发送此条变化的所有物流信息。推送请求示例如下(body太长了，这里就不贴出来了)&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;h2&gt;3.1推送请求&lt;/h2&gt;
&lt;p&gt;发起方:             快递100&lt;/p&gt;
&lt;p&gt;请求地址:        在订阅请求中提供（即回调servlet的互联网地址）&lt;/p&gt;
&lt;p&gt;通信协议:        HTTP&lt;/p&gt;
&lt;p&gt;请求类型:        POST&lt;/p&gt;
&lt;p&gt;字符集:             utf-8&lt;/p&gt;
&lt;p&gt;请求内容:       param=body或者&lt;strong&gt;param=body&amp;amp;sign=signvalue&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; 查看了推送请求之后，我们根据快递100的推送请求，我们先写出相关的返回结果模型ModPushRequest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f255ace7-c8ca-436b-b10a-83209c02d2d7')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f255ace7-c8ca-436b-b10a-83209c02d2d7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f255ace7-c8ca-436b-b10a-83209c02d2d7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f255ace7-c8ca-436b-b10a-83209c02d2d7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f255ace7-c8ca-436b-b10a-83209c02d2d7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递100传回快递结果模型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModPushRequest
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 监控状态相关消息，如:3天查询无记录，60天无变化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; message { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 包括got、sending、check三个状态，由于意义不大，已弃用，请忽略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; billstatus { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 监控状态:polling:监控中，shutdown:结束，abort:中止，updateall：重新推送。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 其中当快递单为已签收时status=shutdown，当message为“3天查询无记录”或“60天无变化时”status= abort ，对于stuatus=abort的状度，需要增加额外的处理逻辑，详见本节最后的说明
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; status { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最新查询结果，全量，倒序（即时间最新的在最前）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ModLastResult lastResult { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中 ModLastResult是 快递100传回快递状态模型如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d6da4a7d-6459-4e18-8c3a-2b26fabbfeaf')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_d6da4a7d-6459-4e18-8c3a-2b26fabbfeaf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d6da4a7d-6459-4e18-8c3a-2b26fabbfeaf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d6da4a7d-6459-4e18-8c3a-2b26fabbfeaf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d6da4a7d-6459-4e18-8c3a-2b26fabbfeaf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递100传回快递状态模型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModLastResult
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消息体，请忽略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; message { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递单当前签收状态，包括0在途中、1已揽收、2疑难、3已签收、4退签、5同城派送中、6退回、7转单等7个状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; state { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递单明细状态标记，暂未实现，请忽略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; condition { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 否签收标记，明细状态请参考state字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ischeck { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递公司编码,一律用小写字母
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; com { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递单号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; nu { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通讯状态，请忽略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; status { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递物流信息，时间到序
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;ModData&amp;gt; data { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; } 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中 ModData 是物流信息 如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递100传回快递记录模型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModData
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递物流内容
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; context { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递原始时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; time { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 快递格式化时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ftime { &lt;span&gt;set&lt;/span&gt;; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了推送模型，那此时我们要做的就是接收快递100的请求数据即可，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新订单快递信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;form&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult UpdateMessage(FormCollection form)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; json = form.Get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                JavaScriptSerializer serializer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaScriptSerializer();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Json字符串转换为ModPushRequest类型对象&lt;/span&gt;
                ModPushRequest pustRequest = serializer.Deserialize&amp;lt;ModPushRequest&amp;gt;&lt;span&gt;(json);
　　　　　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;
　　　　　　　&lt;span&gt;}
　　　　　　　&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;{}
　　　　　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上我们就将收到的数据成功转换成了我们的模型数据，剩下的就是具体业务需求了，这个可以根据实际项目情况，做不同的处理。例如：TODO可以 先拿到返回的快递单号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; number = pustRequest.lastResult.nu;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以去查询数据库中找到此单号的订单信息。再循环物流信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;string&lt;/span&gt; senderMessage = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; lastMessage = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (ModData item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pustRequest.lastResult.data)
  {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有物流信息&lt;/span&gt;
    senderMessage += item.ftime + &lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt; + item.context + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
  }
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pustRequest.lastResult.data.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
   {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最近一条物流信息&lt;/span&gt;
       lastMessage = pustRequest.lastResult.data[&lt;span&gt;0&lt;/span&gt;].ftime + &lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                     pustRequest.lastResult.data[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].context;
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以再根据不同的物流返回状态做不同的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快递单当前签收状态，包括0在途中、1已揽收、2疑难、3已签收、4退签、5同城派送中、6退回、7转单等7个状态&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (pustRequest.lastResult.state == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO   &lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pustRequest.lastResult.state == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || pustRequest.lastResult.state == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;温馨提示，设计订单表的时候，可以多加三个字段，一个字段是订阅时间，一个是物流平台推送回来的时候推送时间，再一个是物流平台推送过来时的推送状态。可以记录用于后面物流数据分析。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 物流消息查询&lt;/h2&gt;

&lt;blockquote readability=&quot;12.869955156951&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;、整体使用流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一步，后台创建链接，调用：&lt;a href=&quot;http://www.kuaidi100.com/applyurl?key=%5b%5d&amp;amp;com=%5b%5d&amp;amp;nu=%5b&quot;&gt;http://www.kuaidi100.com/applyurl?key=[]&amp;amp;com=[]&amp;amp;nu=[&lt;/a&gt;] ，调用后系统会返回一个url地址，如：&lt;a href=&quot;http://www.kuaidi100.com/kuaidiresult?id=23&quot;&gt;http://www.kuaidi100.com/kuaidiresult?id=23&lt;/a&gt; 。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二步：在要显示结果的页面添加一个iframe标签，将上述结果url地址传入该iframe标签的的src值，即可在该页面查看到结果（如果要实现系统自动地将结果url传入iframe标签的src，请参考下面第五章），iframe代码示范:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;iframe name=&quot;kuaidi100&quot; src=&quot;结果url地址&quot; width=&quot;600&quot; height=&quot;380&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; hspace=&quot;0&quot; vspace=&quot;0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 使用场景，项目中的订单，我们一定不是每次都直接去调接口查询，那样太慢，效率也不高，只有部分，数据表中物流信息没有且平台订单不为空的时候，查询物流信息时，我们需要去实时调用查询接口，将数据返回出来。根据整体使用流程介绍，我们很容知道，是通过返回html绑定再iframe上实现的。实现如下：&lt;/p&gt;
&lt;p&gt;前台页面(传入快递公司对应的公司编码和物流单号)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  ajaxGetContent(&quot;@Url.Action(&quot;ViewExpress&quot;)&quot; + &quot;?companyNumber=&quot; + company + &quot;&amp;amp;expressNumber=&quot; + number, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d =&lt;span&gt; dialog({
                    title: &lt;/span&gt;'物流最新跟踪'&lt;span&gt;,
                    content: data,
                    okValue: &lt;/span&gt;'确定'&lt;span&gt;,
                    ok: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                });
                d.show(obj);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Action&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; ActionResult ViewExpress(&lt;span&gt;string&lt;/span&gt; expressNumber, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; companyNumber)
 {
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 快递100 获取方式
            &lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.kuaidi100.com/applyurl?key=974498a9701a6c9b&amp;amp;com=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + companyNumber + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;nu=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                         expressNumber;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化获取HTML动作&lt;/span&gt;
            GetHtmlFromUrl getHtml = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetHtmlFromUrl(url);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求的url中html字符串&lt;/span&gt;
&lt;span&gt;            getHtml.StartWork();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据绑定&lt;/span&gt;
            ViewData.Model =&lt;span&gt; getHtml.ResultHtml;
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中初始化html方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化一个获取html动作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要请求的url地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; GetHtmlFromUrl(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; requestUrl)
        {
            ArgumentChecker.ThrowExceptionWhenStringIsNullOrEmpty(requestUrl, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;requestUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestUrl.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                requestUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; requestUrl;
            }
            RequestUrl &lt;/span&gt;=&lt;span&gt; requestUrl;
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取请求url地址的html字符串方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开始获取请求url地址的html字符串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartWork()
        {            
            WebRequest request &lt;/span&gt;=&lt;span&gt; WebRequest.Create(RequestUrl);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (WebResponse response =&lt;span&gt; request.GetResponse())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (Stream stream =&lt;span&gt; response.GetResponseStream())
                {
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (StreamReader reader = &lt;span&gt;new&lt;/span&gt; StreamReader(stream, System.Text.Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
                    {
                        ResultHtml &lt;/span&gt;=&lt;span&gt; reader.ReadToEnd();
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回的ViewExpress视图如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@model string
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;kuaidi100&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;@Model&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;380&quot;&lt;/span&gt;&lt;span&gt; marginwidth&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; marginheight&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; hspace&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; vspace&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; frameborder&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; scrolling&lt;/span&gt;&lt;span&gt;=&quot;no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就按照文档中所说的将返回html呈现出来了&lt;/p&gt;
&lt;blockquote readability=&quot;9.1022964509395&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;返回结果说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;提交请求后，快递100会给您返回一个可以看到结果的url地址，如：&lt;a href=&quot;http://www.kuaidi100.com/kuaidiresult?id=23&quot;&gt;http://www.kuaidi100.com/kuaidiresult?id=23&lt;/a&gt; ，您直接访问或用iframe页调用该url（调用方法见后面第四章），即可以看到结果。效果：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/762349/201801/762349-20180126131113178-1062942549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为EMS、顺丰和申通偶尔会不稳定， &lt;strong&gt;不稳定时会先显示验证码&lt;/strong&gt; （如下图所示），所以请勿直接将这个页面直接解析成JSON等形式，否则会出错&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; 至此，我们在通过快递100平台 完成了快递订阅、接收了快递消息的推送以及我们自主通过快递100接口查询最新的物流信息。&lt;/p&gt;

&lt;p&gt;到这里，三篇关于快递接口的文章已经全部结束，文中给出的只是根据官方文档要求，编写的部分代码，可能不尽完善，能够优化的地方还有很多，大家能借鉴的地方借鉴一下就好～&lt;/p&gt;

&lt;p&gt;     End!&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 05:17:00 +0000</pubDate>
<dc:creator>潇十一郎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoyong/p/8317251.html</dc:identifier>
</item>
<item>
<title>ZooKeeper 分布式共享锁的实现 - crawl+</title>
<link>http://www.cnblogs.com/crawl/p/8352919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crawl/p/8352919.html</guid>
<description>&lt;p&gt;原创播客，如需转载请注明出处。原文地址：&lt;span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ZooKeeper 分布式共享锁的实现&quot; href=&quot;http://www.cnblogs.com/crawl/p/8352919.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/crawl/p/8352919.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;笔记中提供了大量的代码示例，需要说明的是，大部分代码示例都是本人所敲代码并进行测试，不足之处，请大家指正~&lt;/p&gt;
&lt;p&gt;本博客中所有言论仅代表博主本人观点，若有疑惑或者需要本系列分享中的资料工具，敬请联系 &lt;span&gt;qingqing_crawl@163.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;GitHub：&lt;a href=&quot;https://github.com/QingqingQi&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/QingqingQi&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;前言：ZooKeeper 是提供少量数据存储和管理的分布式协调服务。适合存储状态管理信息，可以进行数据的读写，同步，提供对数据节点的监听功能。利用 ZooKeeper 可以实现很多功能，比如：Hadoop2.0,使用 Zookeeper 的事件处理确保整个集群只有一个活跃的 NameNode,存储配置信息等；可以利用 ZooKeeper 感知集群中哪台主机宕机或者下线等等。今天介绍另一个常用的功能，利用 Zookeeper 实现分布式共享锁。&lt;/p&gt;
&lt;h3&gt;一、简要介绍&lt;/h3&gt;
&lt;p&gt;利用 Zookeeper 实现分布式共享锁，可以做到一次只有指定个数的客户端访问服务器的某些资源。&lt;/p&gt;
&lt;h3&gt;二、实现步骤&lt;/h3&gt;
&lt;p&gt;利用 Zookeeper 实现分布式共享锁的步骤大致可以分为以下几步：&lt;/p&gt;
&lt;p&gt;1. 客户端上线即向 Zookeeper 注册，创建一把锁&lt;/p&gt;
&lt;p&gt;2. 判断是否只有一个客户端工作，若只有一个客户端工作，此客户端可以处理业务&lt;/p&gt;
&lt;p&gt;3. 获取父节点下注册的所有锁，通过判断自己是否是号码最小的那一把锁，若是则可以处理业务，否则等待&lt;/p&gt;
&lt;p&gt;值的注意的是，&lt;span&gt;&lt;strong&gt;在某一客户端获取到锁处理完业务后，必须释放锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;三、实现代码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 新建一个 DistributedLock 类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; ZooKeeper zkClient = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接字符串&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String connectString = &quot;zookeeper01:2181,zookeeper02:2181,zookeeper03:2181&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sessionTimeout = 2000&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String parentNode = &quot;/locks&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录自己创建子节点的路径&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; String thisPath;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取 ZooKeeper 的客户端连接&lt;/span&gt;
        DistributedLock distLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DistributedLock();
        distLock.getZKClient();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.注册一把锁&lt;/span&gt;
&lt;span&gt;        distLock.regiestLock();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.监听父节点，判断是否只有自己在线&lt;/span&gt;
&lt;span&gt;        distLock.watchParent();
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. main 方法中定义了三个方法&lt;/p&gt;
&lt;p&gt;1）getZKClient():用来获取 Zookeeper 客户端的连接&lt;/p&gt;
&lt;p&gt;其中 process 方法是当监听节点发生变化时调用，其中获取定义的父节点的所有子节点，然后判断当前节点是否是最小节点，若是则进行业务逻辑处理阶段，并重新注册一把新的锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 zk 客户端&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getZKClient() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        zkClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(connectString, sessionTimeout, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Watcher() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(WatchedEvent event) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断事件类型，只处理子节点变化事件&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(event.getType() == EventType.NodeChildrenChanged &amp;amp;&amp;amp;&lt;span&gt; event.getPath().equals(parentNode)) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        List&lt;/span&gt;&amp;lt;String&amp;gt; childrens = zkClient.getChildren(parentNode, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断自己是否是最小的&lt;/span&gt;
                        String thisNode = thisPath.substring((parentNode + &quot;/&quot;&lt;span&gt;).length());
                        Collections.sort(childrens);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(childrens.indexOf(thisNode) == 0&lt;span&gt;){
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理业务逻辑&lt;/span&gt;
&lt;span&gt;                            dosomething();
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新注册一把新的锁&lt;/span&gt;
                            thisPath = zkClient.create(parentNode + &quot;/lock&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
                        }
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）main 中的第二个方法是 rediestLock()&lt;/p&gt;
&lt;p&gt;调用 Zookeeper 客户端的 create() 方法，建立一个新的节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册一把锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; regiestLock() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        thisPath &lt;/span&gt;= zkClient.create(parentNode + &quot;/lock&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）第三个是 watchParent() 方法&lt;/p&gt;
&lt;p&gt;在此方法中判断是否只有一个节点在线，若只有自己一个节点，则调用业务处理的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听父节点，判断是否只有自己在线&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; watchParent() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        List&lt;/span&gt;&amp;lt;String&amp;gt; childrens = zkClient.getChildren(parentNode, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childrens != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; childrens.size() == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有自己在线，处理业务逻辑(处理完业务逻辑，必须删释放锁)&lt;/span&gt;
&lt;span&gt;            dosomething();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是只有自己在线，说明别人已经获取到锁，等待&lt;/span&gt;
&lt;span&gt;            Thread.sleep(Long.MAX_VALUE);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4）最后一个是自定义的业务逻辑方法&lt;/p&gt;
&lt;p&gt;需要注意的是，当处理完业务逻辑后，必须释放锁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑方法，注意：需要在最后释放锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dosomething() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;或得到锁:&quot; +&lt;span&gt; thisPath);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;释放锁:&quot; +&lt;span&gt; thisPath);
            zkClient.delete(thisPath, &lt;/span&gt;-1&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 最后贴一下全部代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.software.bigdata.zkdistlock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.CreateMode;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.WatchedEvent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.Watcher.Event.EventType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.ZooDefs.Ids;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.zookeeper.ZooKeeper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Description: 分布式共享锁
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Crawl
 * @date 2018年1月25日 下午5:02:42
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DistributedLock {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZooKeeper zkClient = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接字符串&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String connectString = &quot;zookeeper01:2181,zookeeper02:2181,zookeeper03:2181&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sessionTimeout = 2000&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String parentNode = &quot;/locks&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录自己创建子节点的路径&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; String thisPath;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取 ZooKeeper 的客户端连接&lt;/span&gt;
        DistributedLock distLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DistributedLock();
        distLock.getZKClient();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.注册一把锁&lt;/span&gt;
&lt;span&gt;        distLock.regiestLock();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.监听父节点，判断是否只有自己在线&lt;/span&gt;
&lt;span&gt;        distLock.watchParent();
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑方法，注意：需要在最后释放锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dosomething() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;或得到锁:&quot; +&lt;span&gt; thisPath);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;2000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;释放锁:&quot; +&lt;span&gt; thisPath);
            zkClient.delete(thisPath, &lt;/span&gt;-1&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听父节点，判断是否只有自己在线&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; watchParent() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        List&lt;/span&gt;&amp;lt;String&amp;gt; childrens = zkClient.getChildren(parentNode, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childrens != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; childrens.size() == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有自己在线，处理业务逻辑(处理完业务逻辑，必须删释放锁)&lt;/span&gt;
&lt;span&gt;            dosomething();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是只有自己在线，说明别人已经获取到锁，等待&lt;/span&gt;
&lt;span&gt;            Thread.sleep(Long.MAX_VALUE);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册一把锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; regiestLock() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        thisPath &lt;/span&gt;= zkClient.create(parentNode + &quot;/lock&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 zk 客户端&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getZKClient() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        zkClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ZooKeeper(connectString, sessionTimeout, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Watcher() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(WatchedEvent event) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断事件类型，只处理子节点变化事件&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(event.getType() == EventType.NodeChildrenChanged &amp;amp;&amp;amp;&lt;span&gt; event.getPath().equals(parentNode)) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        List&lt;/span&gt;&amp;lt;String&amp;gt; childrens = zkClient.getChildren(parentNode, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断自己是否是最小的&lt;/span&gt;
                        String thisNode = thisPath.substring((parentNode + &quot;/&quot;&lt;span&gt;).length());
                        Collections.sort(childrens);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(childrens.indexOf(thisNode) == 0&lt;span&gt;){
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理业务逻辑&lt;/span&gt;
&lt;span&gt;                            dosomething();
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新注册一把新的锁&lt;/span&gt;
                            thisPath = zkClient.create(parentNode + &quot;/lock&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
                        }
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        });
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 26 Jan 2018 04:35:00 +0000</pubDate>
<dc:creator>crawl+</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crawl/p/8352919.html</dc:identifier>
</item>
<item>
<title>一步一步从原理跟我学邮件收取及发送 5.C语言的socket示例 - clq</title>
<link>http://www.cnblogs.com/-clq/p/8358874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-clq/p/8358874.html</guid>
<description>&lt;td id=&quot;main&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/-clq/p/8358874.html&quot;&gt;一步一步从原理跟我学邮件收取及发送 5.C语言的socket示例&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;postText&quot; readability=&quot;106&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;455.5&quot;&gt;
&lt;p&gt;    说到 C 语言版本的程序,首先要解决的问题就是兼容性. 作为 20 年开发有 10 多年是在服务端的程序员,我深刻地感受到服务端平台的两极分化之严重,linux 派对 windows 那是超级的不屑一顾:那都是没技术的人才用的,没能力维护 linux 的人才用 windows. 与此同时 windows 派对 linux 也是嗤之以鼻,我曾经的一位经理就时常不屑对我说,我就不信那几个人写的东西能比公司写的好. 奇怪的这两派其实都很能挣钱,BAT 什么的都用 linux 我们就不说了,但股票期货交易这样重要的而且性能要求一样很高的行业内几乎一水的 windows + sql server 恐怕大家就不知道了吧. 所以我真不太同意 linux 性能就比 windows 高的说法.&lt;/p&gt;&lt;p&gt;    我觉得形成这种说法的很重要的一个因素是很多高性能的软件没有 windows 版本,比如 nginx 长期不推荐在 windows 下使用, redis 下的 windows 版本居然是微软自己拿过来修改过才能用的.到底真相如何我们就不讨论了,单就为什么这些软件没有 windows 版本,我觉得一个很重要的原因是 C/C++ 语言在两种平台下的兼容性问题.开源界现在大量的用 gcc,而 gcc 的语法现在和 vc 的语法差别是越来越大,我过去经常在 pc 中引用开源代码,有些代码花上一整天的没法在 vc 中编译通过(印象中最好编译的是 apache 的代码).我个人觉得既然开源了,还是应该考虑一下 vc 的兼容性(当然了个人时间是有限的,我写的很多东西也都没有考虑,基本上手上的平台下能编译过去也就算了...).&lt;/p&gt;&lt;p&gt;    这种兼容性体现在很多方面,第一步选择 ide (或者称不上 ide 的开发工具) 时基本上都会要求引入库文件. linux 下是 so 或者 a 文件,这里就不说了,单只讨论 windows 下的就有很多区别. 传统 vc 下是要引入 lib 文件,而现在有大量基于 gcc 的多种开发工具,它们要引入的是 a 文件,它们是不通用的(小提示:有些版本的 gcc 能使用 lib 文件).所以如果是拿一个 vc 的示例,那么在 gcc 系的开发工具中是用不了的. 我的解决办法是不用 socket 的库文件! 初学者还没什么,有经验的同学们又要炸锅了:可能吗! 没什么的可能的,前面已经说了这些 socket 函数是操作系统提供的,与开发语言无关,我们其实可以直接使用操作系统的功能,这种&quot;直接使用&quot;也没什么稀奇的就是直接调用 dll  文件罢了,delphi 的所有 socket 都是这样使用的.具体的调用方法就是直接调用 dll 中的函数指针,这在所有的 windows api 开发书籍中都会讲到,一点也不稀奇.本质上各个编译器最后也是要这样调用的,只不过它们按照传统把这种操作弄到了库文件中了而已.&lt;/p&gt;&lt;p&gt;我先上代码,大家先别急着看,我后面会讲解,其实也都挺简单的.&lt;/p&gt;
&lt;p&gt;(文件名 socketplus.c)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;216&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个方便测试 socket 程序的小文件,省得老是找 lib a 文件 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前是 gcc 专用,如果 vc 要用另外弄一个好了,不要在这上面弄条件编译 &lt;/span&gt;
&lt;span&gt;

#ifndef _SOCKET_PLUS_C_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt;    _SOCKET_PLUS_C_&lt;span&gt;

#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;windows.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;winsock.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;&amp;gt;&lt;/span&gt;
&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lstring.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;*.lib&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;libwsock32.a&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;libwsock32.a&quot;)


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统错误信息提示&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintError(DWORD last_err);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接引入的 dll 函数 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SOCKET PASCAL socket(int,int,int);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char * (*fun1)(char * p1,char * p2);&lt;/span&gt;
&lt;span&gt;#ifndef _MSC_VER
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;很多同学不会写函数指针声明&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数指针的写法是,先写正常的函数声明,然后将函数名加上括号,然后在函数名前再加上*号即可!!! &lt;/span&gt;
SOCKET PASCAL (*_socket)(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SOCKET (PASCAL *_socket)(int,int,int); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vc 要这样写,vc6,vc2010 都是如此 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是将 PASCAL 或者 stdcall 放到函数名的括号中 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; PASCAL (*&lt;span&gt;_WSAStartup)(WORD,LPWSADATA);
unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; PASCAL (*_inet_addr)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;);
u_short PASCAL (&lt;/span&gt;*&lt;span&gt;_htons)(u_short);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; PASCAL (*_connect)(SOCKET,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; sockaddr*,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; PASCAL (*_WSAGetLastError)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; PASCAL (*_send)(SOCKET,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; PASCAL (*_recv)(SOCKET,&lt;span&gt;char&lt;/span&gt;*,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; PASCAL (*_select)(&lt;span&gt;int&lt;/span&gt; nfds,fd_set*,fd_set*,fd_set*,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; timeval*&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; hostent * PASCAL (*_gethostbyname)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

#ifdef _MSC_VER
SOCKET (PASCAL &lt;/span&gt;*_socket)(&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;vc 要这样写,vc6,vc2010 都是如此&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是将 PASCAL 或者 stdcall 放到函数名的括号中 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;  (PASCAL *&lt;span&gt;_WSAStartup)(WORD,LPWSADATA);
unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;  (PASCAL*_inet_addr)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;);
u_short  (PASCAL&lt;/span&gt;*&lt;span&gt;_htons)(u_short);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  (PASCAL *_connect)(SOCKET,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; sockaddr*,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  (PASCAL *_WSAGetLastError)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  (PASCAL *_send)(SOCKET,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  (PASCAL *_recv)(SOCKET,&lt;span&gt;char&lt;/span&gt;*,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  (PASCAL *_select)(&lt;span&gt;int&lt;/span&gt; nfds,fd_set*,fd_set*,fd_set*,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; timeval*&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; hostent *  (PASCAL *_gethostbyname)(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------------------------------------------- &lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; CreateTcpClient()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LoadLibrary(&quot;wsock32.dll&quot;);&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; InitWinSocket()
{
  WSADATA wData;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Result := WSAStartup(MakeWord(2, 2), wData) = 0;&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; _WSAStartup(MAKEWORD(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), &amp;amp;&lt;span&gt;wData);
  
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ConnectIP(SOCKET so, &lt;span&gt;char&lt;/span&gt; * ip, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port)
{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sock: TSocket;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SockAddr: TSockAddr;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;struct sockaddr SockAddr;&lt;/span&gt;
  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in SockAddr;


  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; err;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Result = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;


  memset(&lt;/span&gt;&amp;amp;SockAddr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(SockAddr));

  SockAddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
  SockAddr.sin_port &lt;/span&gt;=&lt;span&gt; _htons(port);
  SockAddr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; _inet_addr(ip);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (_connect(so, (struct sockaddr *)(&amp;amp;SockAddr), sizeof(SOCKADDR_IN)) == SOCKET_ERROR) &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (_connect(so, &amp;amp;SockAddr, &lt;span&gt;sizeof&lt;/span&gt;(SOCKADDR_IN)) == SOCKET_ERROR) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实是不用转换的 &lt;/span&gt;
&lt;span&gt;  {
      PrintError(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    err &lt;/span&gt;= _WSAGetLastError(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实这个和 GetLastError 是一样的
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ShowMessageFmt('connect socket error，[%d]', [WSAGetLastError]);&lt;/span&gt;
    MessageBox(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connect socket error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    Result &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int err = _WSAGetLastError();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前面调用了别的 api 这里是取到 0 的,而不是错误信息码 &lt;/span&gt;
&lt;span&gt;    
    PrintError(err);
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (INVALID_SOCKET == so) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connect error:INVALID_SOCKET\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  }
  
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;clq 这是我新加的函数，目的是可以根据域名来访问，并且原来的代码只能访问局域网&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; ConnectHost(SOCKET so, &lt;span&gt;char&lt;/span&gt; * host, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port)
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; * address =&lt;span&gt; host;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; is_connect = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create an address structure and clear it&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in addr;
    memset(&lt;/span&gt;&amp;amp;addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(addr));
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fill in the address if possible&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先尝试当做IP来解析&lt;/span&gt;
    addr.sin_family =&lt;span&gt; AF_INET;
    addr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; _inet_addr(address);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Was the string a valid IP address?&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是IP就当做域名来解析&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (addr.sin_addr.s_addr == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No, so get the actual IP address of the host name specified&lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt; hostent *&lt;span&gt;pHost;
        pHost &lt;/span&gt;=&lt;span&gt; _gethostbyname(address);
    
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pHost !=&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pHost-&amp;gt;h_addr ==&lt;span&gt; NULL)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false;&lt;/span&gt;
&lt;span&gt;                
            addr.sin_addr.s_addr &lt;/span&gt;= ((&lt;span&gt;struct&lt;/span&gt; in_addr *)pHost-&amp;gt;h_addr)-&amp;gt;&lt;span&gt;s_addr;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false;&lt;/span&gt;
&lt;span&gt;    }    

    addr.sin_port &lt;/span&gt;=&lt;span&gt; _htons(port);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回：-1 连接失败；0 连接成功&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (_connect(so, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;addr, &lt;span&gt;sizeof&lt;/span&gt;(addr)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        is_connect &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true;&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        is_connect &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接失败
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printfd3(&quot;WSAGetLastError:%d, WSAEWOULDBLOCK:%d\r\n&quot;, WSAGetLastError()-WSABASEERR, WSAEWOULDBLOCK-WSABASEERR);&lt;/span&gt;
&lt;span&gt;        
          PrintError(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        err &lt;/span&gt;= _WSAGetLastError(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实这个和 GetLastError 是一样的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ShowMessageFmt('connect socket error，[%d]', [WSAGetLastError]);&lt;/span&gt;
        MessageBox(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connect socket error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        is_connect &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int err = _WSAGetLastError();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前面调用了别的 api 这里是取到 0 的,而不是错误信息码 &lt;/span&gt;
&lt;span&gt;        
        PrintError(err);
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (INVALID_SOCKET == so) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connect error:INVALID_SOCKET\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);        
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; is_connect;
}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;

#ifndef faveLoadFunction
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; faveLoadFunction&lt;span&gt;
FARPROC WINAPI LoadFunction(HINSTANCE h, LPCSTR fun_name)
{
    FARPROC WINAPI r &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    r &lt;/span&gt;=&lt;span&gt; GetProcAddress(h, fun_name);
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;0&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load function %s error\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, fun_name);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load function %s ok\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, fun_name);    

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;


&lt;span&gt;void&lt;/span&gt;&lt;span&gt; LoadFunctions_Socket()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HINSTANCE hs = LoadLibrary(&quot;wsock32.dll&quot;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据不同的编译环境,有可能要从 LoadLibrary 改成 LoadLibraryA&lt;/span&gt;
    HINSTANCE hs = LoadLibraryA(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wsock32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据不同的编译环境,有可能要从 LoadLibrary 改成 LoadLibraryA&lt;/span&gt;
    
    &lt;span&gt;if&lt;/span&gt; (hs == &lt;span&gt;0&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load wsock32.dll error\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hs);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load wsock32.dll ok\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hs);
    
    _socket &lt;/span&gt;= GetProcAddress(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_socket:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _socket);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_socket == &lt;span&gt;0&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;load _socket error\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hs);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------------------------------------------- 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接装载各个 dll 函数 &lt;/span&gt;
    _socket = LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _WSAStartup &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WSAStartup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _inet_addr &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inet_addr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _htons &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;htons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _connect &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;connect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _WSAGetLastError &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WSAGetLastError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _send &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _recv &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _select &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _gethostbyname &lt;/span&gt;= LoadFunction(hs, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gethostbyname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统错误信息提示&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintError(DWORD last_err)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行出错。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (!CreateDirectory(_T(&quot;c:\\&quot;),0))&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;512&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;char buf[128];&lt;/span&gt;
&lt;span&gt;        LPVOID lpMsgBuf;
        DWORD dw;
        
        memset(&lt;/span&gt;&amp;amp;buf, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
        
        dw &lt;/span&gt;= last_err;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GetLastError();&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (dw == &lt;span&gt;0&lt;/span&gt;) dw = GetLastError(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际上是可以代替 WSAGetLastError 的 
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dw = 5;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10035;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6000054;&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (dw == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        
        FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FORMAT_MESSAGE_ALLOCATE_BUFFER 是指要分配内存 &lt;/span&gt;
&lt;span&gt;            NULL,
            dw,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR) &lt;/span&gt;&amp;amp;buf,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(LPTSTR) &amp;amp;lpMsgBuf,&lt;/span&gt;
            &lt;span&gt;500&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为是自己分配的内存,所以要指出分配了多大 &lt;/span&gt;
&lt;span&gt;            NULL );
            
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PrintError(出错码=%d):%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, dw, buf); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;奇怪,这里就是不对&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是倒数第 2 个 参数的问题 &lt;/span&gt;
&lt;span&gt;            
        FormatMessage (
            FORMAT_MESSAGE_ALLOCATE_BUFFER &lt;/span&gt;| FORMAT_MESSAGE_FROM_SYSTEM, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FORMAT_MESSAGE_ALLOCATE_BUFFER 是指要分配内存 &lt;/span&gt;
&lt;span&gt;            NULL,
            dw,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR) &lt;/span&gt;&amp;amp;&lt;span&gt;lpMsgBuf,
            &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, NULL );
            
         wsprintf(buf,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出错信息 (出错码＝%d): %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    dw, lpMsgBuf);             
            
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PrintError(出错码=%d):%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dw, lpMsgBuf);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;PrintError(出错码=%d):%s\r\n&quot;, dw, &amp;amp;buf); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;奇怪,这个是不对的 &lt;/span&gt;
        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PrintError(出错码=%d):%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dw, buf);
            
        LocalFree(lpMsgBuf);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出提示
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OutputDebugString(szBuf);&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尚未精测试,可能有误&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; SendBuf(SOCKET so, &lt;span&gt;char&lt;/span&gt; * s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len)
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p =&lt;span&gt; s;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r := 0;&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; Result = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;count := 0;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p := @s[1];&lt;/span&gt;

  &lt;span&gt;while&lt;/span&gt; (Result&amp;lt;&lt;span&gt;len)
  {
    r &lt;/span&gt;= _send(so, p, len - Result, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;  (r &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
      Result &lt;/span&gt;= Result +&lt;span&gt; r;
      p &lt;/span&gt;= p +&lt;span&gt; r;
      
    };


    count&lt;/span&gt;++&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count&amp;gt;&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超过多少次就不发送了 &lt;/span&gt;
&lt;span&gt;    {
      MessageBox(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result;
    }

  }
  
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result;

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意,返回的字符串要自己释放 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring RecvBuf(SOCKET so)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;算了,还是传可自动释放的字符串进去方便点 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void RecvBuf(SOCKET so, lstring * buf)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用这个格式也可以,不过与其他语言不通用 &lt;/span&gt;
lstring * RecvBuf(SOCKET so, &lt;span&gt;struct&lt;/span&gt; MemPool *&lt;span&gt; pool)
{
  &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring s = String(&quot;&quot;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring * s = NewString(&quot;&quot;, _buf-&amp;gt;pool);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CheckPString(_buf);&lt;/span&gt;
  lstring * s = NewString(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, pool);

  memset(&lt;/span&gt;&amp;amp;buf, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));


  r &lt;/span&gt;= _recv(so, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf)-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;留下一个 #0 结尾&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (r &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
  {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SetLength(s, r);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Move(buf, s[1], r);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s.Append(&amp;amp;s, StringConst(buf, r));&lt;/span&gt;
&lt;span&gt;    LString_AppendCString(s, buf, r);
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般都是断开了&lt;/span&gt;
&lt;span&gt;  {
    MessageBox(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv error.[socket close]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return String(&quot;&quot;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不应该再生成一个新的&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否可读取&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; SelectRead(SOCKET so)
{
  fd_set fd_read; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fd_read:TFDSet;&lt;/span&gt;
  &lt;span&gt;struct&lt;/span&gt; timeval timeout; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; : TTimeVal;&lt;/span&gt;

  &lt;span&gt;int&lt;/span&gt; Result = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

  FD_ZERO( &lt;/span&gt;&amp;amp;&lt;span&gt;fd_read );
  FD_SET(so, &lt;/span&gt;&amp;amp;fd_read ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;个数受限于 FD_SETSIZE &lt;/span&gt;
&lt;span&gt;
  timeout.tv_sec &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒&lt;/span&gt;
  timeout.tv_usec = &lt;span&gt;500&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;毫秒&lt;/span&gt;
  timeout.tv_usec = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;毫秒
  
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;linux 第一个参数一定要赋值&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/int r = ::select(socket_handle+1, &amp;amp;fd_read, NULL, NULL, &amp;amp;l_timeout);&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if select( 0, &amp;amp;fd_read, nil, nil, &amp;amp;timeout ) &amp;gt; 0 then &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;至少有1个等待Accept的connection&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (_select( so+&lt;span&gt;1&lt;/span&gt;, &amp;amp;fd_read, NULL, NULL, &amp;amp;timeout ) &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;至少有1个等待Accept的connection&lt;/span&gt;
    Result = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result;    

}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然,我这些代码倒也不是为了写示例方便大家测试,而是因为工作的关系我需要在多个 ide 和多种编译器中切换,早就写好用来测试网络应用的(主要是xmpp协议,所以以后我们也顺便介绍一下 xmpp 协议的一些简单实现).&lt;/p&gt;&lt;p&gt;其中有以下几点需要说明一下:&lt;br/&gt;1.函数需要从 dll 中取出其地址,在代码中实现为 LoadFunctions_Socket();&lt;br/&gt;2.LoadLibraryA/LoadLibrary 函数可以理解为将一个 dll 中的代码读取到程序的内存中;&lt;br/&gt;3.GetProcAddress 函数可以理解为找到一个函数的地址;&lt;br/&gt;4.不能直接使用原始的 socket 函数名,要使用时,在前面加一个划线;&lt;br/&gt;5.只引入了我用到的少数几个 socket 函数,有需要的网友可以自己引入:方法是先声明一个同原型的函数指针,然后加入到 LoadFunctions_Socket() 中就可以了.&lt;br/&gt;6.代码主要工作在 windows 版本的 gcc, vc6 和 vc2010 下也做过测试. 随着代码的增加 vc 下如果不能运行,大家可以自己改下函数指针的声明和 api 函数的版本(换下 a 和 w 的版本). 至于 a/w 版本是什么意思,不懂的同学我们以后再说明吧.&lt;br/&gt;7.我直接 include 了 c 的文件,方便在各个开发工具中切换,不喜欢这种方式的同学请自己改成 h 文件的方式吧.&lt;/p&gt;&lt;p&gt;我主要的工作环境是 cfree,原因主要是 vc 产生的临时文件实在是太大了,设置不产生临时文件又会产生别的问题,而用 dev c++ 这些传统的 gcc 环境的话,代码提示又是一个问题. 找了很久我最终选用了 cfree 软件,不过要说明的是 cfree 是收费的,但费用不足百元,所以虽然网上有很多注册码可以用我还是推荐大家注册一下.遗憾的是,国内的共享环境之恶劣导致我付费时很是花了几天时候,最终是找作者要到了他的淘宝账号直接转的钱,作者一度以为我是骗子让我去联系第三方的注册网站,我觉得那个第三方的注册网站更象骗子,所以坚持直接转给他.之所以我认为第三方注册机构更象骗子是因为我也写过共享软件 ...&lt;/p&gt;&lt;p&gt;cfree 对我来说有以下吸引力的优点:&lt;br/&gt;1.没有太大的临时文件;&lt;br/&gt;2.代码提示还不错;&lt;br/&gt;3.不需要建立工程文件;&lt;br/&gt;4.注册费用低,我是它的正版用户;&lt;br/&gt;5.通过配置可以把编辑器界面弄得象我喜欢的 vscode;&lt;br/&gt;6.我有一个 32 位的 windows 2003 工作环境,那里用不了 vscode,也不用了现在最新的 vc;&lt;br/&gt;7.作为 gcc 系,几乎不需要配置编译环境.&lt;/p&gt;&lt;p&gt;这里要提一下开源的 codelite,也是不错的软件,代码提示也做得很好,但生成的临时文件大了点,而且需要配置编译环境(对初学者很致命),如果没有 cfree 我就用它了.&lt;/p&gt;&lt;p&gt;另外一定要说的是它们的调试都很差,如果有无法理解的代码,请打开您的 VC ... 不过我现在调试用的是我能找到的最简便的网友简化版的非官方版本 BCB2009 (其实人家叫 CodeGear C++ Builder 2009,bcb 的称呼只是历史原因),因为这个版本安装非常方便,要不我就用 bcb6 了.原版 bcb2009 是否方便我就不清楚了. 找不到简化版本的同学用最常见的 vc6 调试就行了,一样好用.&lt;/p&gt;&lt;p&gt;好了,下面给出测试的 demo 代码. c 语言中还有些要注意的字节对齐等问题也来不及说了,我们下篇再说吧.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    gSo =&lt;span&gt; CreateTcpClient();
    r &lt;/span&gt;= ConnectHost(gSo, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newbt.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;1&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接成功!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    s &lt;/span&gt;= NewString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EHLO\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, m);

    SendBuf(gSo, s&lt;/span&gt;-&amp;gt;str, s-&amp;gt;&lt;span&gt;len);


    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);
    s&lt;/span&gt;-&amp;gt;&lt;span&gt;Append(s, s);
    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);

    s&lt;/span&gt;-&amp;gt;AppendConst(s, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中文\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);

    rs &lt;/span&gt;= RecvBuf(gSo, m); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个并不只是收取一行 &lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nRecvBuf:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(rs&lt;/span&gt;-&amp;gt;&lt;span&gt;str);
    
    rs &lt;/span&gt;= RecvBuf(gSo, m); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个并不只是收取一行 &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nRecvBuf:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(rs&lt;/span&gt;-&amp;gt;str);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是通讯过程,代码并不复杂,大家可以看到简单封装后并不复杂,所以按自己顺手的封装一下很有必要.&lt;/p&gt;
&lt;p&gt;以下是完整代码:&lt;/p&gt;
&lt;p&gt;(文件名 socket_test1.c)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;windows.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;winsock.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lstring.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socketplus.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lstring_functions.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vc 下要有可能要加 lib 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;*.lib&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;libwsock32.a&quot;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#pragma comment (lib,&quot;libwsock32.a&quot;)



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SOCKET gSo = 0;&lt;/span&gt;
SOCKET gSo = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r;
    mempool mem, &lt;/span&gt;*&lt;span&gt; m;
    lstring &lt;/span&gt;*&lt;span&gt; s;
    lstring &lt;/span&gt;*&lt;span&gt; rs;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------&lt;/span&gt;
&lt;span&gt;
    mem &lt;/span&gt;= makemem(); m = &amp;amp;mem; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存池,重要 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接装载各个 dll 函数&lt;/span&gt;
&lt;span&gt;    LoadFunctions_Socket();

    InitWinSocket(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化 socket, windows 下一定要有 &lt;/span&gt;
&lt;span&gt;

    gSo &lt;/span&gt;=&lt;span&gt; CreateTcpClient();
    r &lt;/span&gt;= ConnectHost(gSo, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;newbt.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;1&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接成功!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    s &lt;/span&gt;= NewString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EHLO\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, m);

    SendBuf(gSo, s&lt;/span&gt;-&amp;gt;str, s-&amp;gt;&lt;span&gt;len);


    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);
    s&lt;/span&gt;-&amp;gt;&lt;span&gt;Append(s, s);
    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);

    s&lt;/span&gt;-&amp;gt;AppendConst(s, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中文\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    printf(s&lt;/span&gt;-&amp;gt;&lt;span&gt;str);

    rs &lt;/span&gt;= RecvBuf(gSo, m); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个并不只是收取一行 &lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nRecvBuf:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(rs&lt;/span&gt;-&amp;gt;&lt;span&gt;str);
    
    rs &lt;/span&gt;= RecvBuf(gSo, m); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个并不只是收取一行 &lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nRecvBuf:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(rs&lt;/span&gt;-&amp;gt;&lt;span&gt;str);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------&lt;/span&gt;
&lt;span&gt;    
    Pool_Free(&lt;/span&gt;&amp;amp;mem); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放内存池 &lt;/span&gt;
&lt;span&gt;    
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gMallocCount:%d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, gMallocCount); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;看看有没有内存泄漏&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的检测而已  
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------------------------------------------- &lt;/span&gt;
&lt;span&gt;
    getch(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;getch().不过在VC中好象要用getch()，必须在头文件中加上&amp;lt;conio.h&amp;gt; &lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了通讯 demo 部分外,其他代码大家都不用细看,都是临时的辅助封装函数而已,用到生产环境中后果我可不负责(虽然我认为改一改也是可以用的).就当是抛砖引玉吧.&lt;/p&gt;
&lt;p&gt;代码里其实还用到了一个很重要的字符串类,不过也是来不及解说了,先给出代码如下:&lt;br/&gt;(文件名为 lstring.c 和 lstring_functions.c,本来我是要放到 github 上的,不过估计也是没时间维护了,所以直接贴一下吧)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;211&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没办法还是得另定义一个字符串 &lt;/span&gt;
&lt;span&gt;
#ifndef _L_STRING_C_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt;    _L_STRING_C_&lt;span&gt;

#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;malloc&lt;/span&gt;.h&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有些编译,如果 malloc.h 在后面的话会报 malloc 函数冲突,解决办法很简单,把含有 malloc 的头文件放前面,好让我们的 malloc 定义能覆盖它就可以了&lt;/span&gt;
#include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;time.h&amp;gt;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;winsock.h&amp;gt;&lt;/span&gt;
#include &amp;lt;windows.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;crt/eh.h&amp;gt; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;据说 MinGW终于支持使用seh实现c++ eh了 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://sourceforge.net/p/mingw-w64/mingw-w64/ci/18a7e88bcbe8bc0de4e07dac934ebf0653c4da7c/tree/mingw-w64-headers/crt/eh.h&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; gMallocCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的内存泄漏检测&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; *&lt;span&gt; malloc_v2(size_t size)
{
    gMallocCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(size);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; * free_v2(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt; p)
{
    gMallocCount&lt;/span&gt;--&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
}

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; malloc malloc_v2
&lt;span&gt;#define&lt;/span&gt; free free_v2&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; LString _LString; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相互引用的提前声明好象必须用 typedef

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存池中的一项&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;算了, string 的自动释放就很复杂了,还是专注于 string 的吧&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool_Item{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void * data; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要释放的数据,可以是不同类型的&lt;/span&gt;
    _LString * data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要释放的数据,可以是不同类型的

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void (*FreeFunc)(struct MemPool_Item * item); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应节点的释放函数&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;太复杂,就当做原始的 free 函数释放就行了 &lt;/span&gt;
    
    &lt;span&gt;struct&lt;/span&gt; MemPool_Item *&lt;span&gt; next;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存池,用于释放一次函数过程中分配的内存 &lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool{

    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; MemPool_Item *&lt;span&gt; Items;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Count;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt; str;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; _const; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是只读的,如果是只读的就是从数组中构造的,不要释放它 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; id; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只是为调试释放而已 &lt;/span&gt;
&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString{

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * _init; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只是用来判断是否进行了初始化,不可靠的简单判断,为 0 就是初始化了&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt; str;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; _const;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是只读的,如果是只读的就是从数组中构造的,不要释放它&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; _malloc; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个结构是不是 malloc 生成的,如果是还要 free 掉结构体本身&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; MemPool * pool; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串所在的函数体自动释放内存池,如果是 NULL 就是要手工释放的
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在操作字符串的临时函数中可以使用它&lt;/span&gt;


    &lt;span&gt;void&lt;/span&gt; (*Append)(&lt;span&gt;struct&lt;/span&gt; LString * s, &lt;span&gt;struct&lt;/span&gt; LString *&lt;span&gt; add);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (*AppendConst)(&lt;span&gt;struct&lt;/span&gt; LString * s, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; add);


};

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; mempool struct MemPool 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数体临时使用字符串时 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define USEPOOL struct MemPool _function_mem_ = makemem();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define ENDUSEPOOL Pool_Free(&amp;amp;_function_mem_);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出打印的级别 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最普通的错误信息 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; printf_err printf
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最低级别的打印 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; printf_err1
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define printf_err1 printf&lt;/span&gt;
&lt;span&gt;
mempool makemem()
{
    mempool mem; 
    memset(&lt;/span&gt;&amp;amp;mem, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(mem));
    
    srand((unsigned) time(NULL)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用时间做种，每次产生随机数不一样&lt;/span&gt;
    mem.id = rand(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;number = rand() % 101; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生0-100的随机数&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mem;
}

mempool &lt;/span&gt;*&lt;span&gt; newmempool()
{
    mempool &lt;/span&gt;*&lt;span&gt; pmem; 
    pmem &lt;/span&gt;= &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool));
    memset(pmem, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool));
    
    srand((unsigned) time(NULL)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用时间做种，每次产生随机数不一样&lt;/span&gt;
    pmem-&amp;gt;id = rand(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;number = rand() % 101; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生0-100的随机数&lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pmem;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;太复杂,就当做一个字符串池,用在一个函数体结束时自动释放这个过程中产生的所有临时字符串,类似于 php 的自动释放原理  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入一个节点, pool 并不分配内存,只是把大家加到一个链表中统一释放而已 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数参数的定义的函数指针是一样的 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Pool_AddItem(&lt;span&gt;struct&lt;/span&gt; MemPool * pool, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt; p)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; MemPool_Item * item =&lt;span&gt; NULL;
    _LString &lt;/span&gt;* s =&lt;span&gt; NULL;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pool == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------------------------------------------- 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的验证 &lt;/span&gt;
&lt;span&gt;        
    s &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;item-&amp;gt;data; &lt;/span&gt;
    
    &lt;span&gt;if&lt;/span&gt; (s-&amp;gt;_init != NULL) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的初始化检测&lt;/span&gt;
&lt;span&gt;    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pool_AddItem: error 未初始化的字符串指针!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }     
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-------------------------------------------------- &lt;/span&gt;
&lt;span&gt;    

    item &lt;/span&gt;= &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool_Item));
    memset(item, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; MemPool_Item));
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;item-&amp;gt;FreeFunc = FreeFunc;&lt;/span&gt;
    item-&amp;gt;data =&lt;span&gt; p;
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面两步是替换掉头节点 &lt;/span&gt;
    item-&amp;gt;next = pool-&amp;gt;&lt;span&gt;Items;
    pool&lt;/span&gt;-&amp;gt;Items =&lt;span&gt; item;
    
    pool&lt;/span&gt;-&amp;gt;Count++&lt;span&gt;;

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放一大片,可以做些简单的检测&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Pool_Free(&lt;span&gt;struct&lt;/span&gt; MemPool *&lt;span&gt; pool)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; MemPool_Item * item =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    _LString &lt;/span&gt;* s =&lt;span&gt; NULL;
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;pool-&amp;gt;Count; i++&lt;span&gt;)
    {
        printf_err1(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pool_Free:%d, %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pool-&amp;gt;&lt;span&gt;Count, i);
        item &lt;/span&gt;= pool-&amp;gt;&lt;span&gt;Items;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;item-&amp;gt;FreeFunc(item-&amp;gt;data);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;item-&amp;gt;FreeFunc(item); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样更清晰一点&lt;/span&gt;
&lt;span&gt;        
        s &lt;/span&gt;= item-&amp;gt;&lt;span&gt;data; 
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s-&amp;gt;_init != NULL) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单的初始化检测&lt;/span&gt;
&lt;span&gt;        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pool_Free: error 未初始化的字符串指针!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        } 
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;free(item-&amp;gt;data);&lt;/span&gt;
        &lt;span&gt;free&lt;/span&gt;(s-&amp;gt;&lt;span&gt;str);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s-&amp;gt;_malloc == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体本身也要释放的话 &lt;/span&gt;
        &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s);
        
        
        pool&lt;/span&gt;-&amp;gt;Items = pool-&amp;gt;Items-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向下移动一个指针位置 &lt;/span&gt;
        &lt;span&gt;free&lt;/span&gt;(item); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点自己的内存也要释放&lt;/span&gt;
&lt;span&gt;    }
    
    pool&lt;/span&gt;-&amp;gt;Count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动释放 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void autofree(struct MemPool * pool, void * p)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Pool_AddItem(pool, p);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; freemempool(mempool *&lt;span&gt; pool)
{

    Pool_Free(pool);

    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pool);
}

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; freemem Pool_Free




&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LStringRef{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;const struct LBuf * buf; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是保存内存内容的地方,不应该变 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本意是让这个指针值固定,但这样导致里面的值也变不了 &lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; LString * buf; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是保存内存内容的地方,不应该变 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;C 语言的特点,为了在传递参数时不使用指针,只能是把指针放到成员中 &lt;/span&gt;
    
    &lt;span&gt;void&lt;/span&gt; (*Append)(&lt;span&gt;struct&lt;/span&gt; LString * s, &lt;span&gt;struct&lt;/span&gt; LString *&lt;span&gt; add);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int (*AppendConst)(struct LString * s, const char * add);&lt;/span&gt;
&lt;span&gt;
};



&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; lstring struct LString 

&lt;span&gt;#define&lt;/span&gt; PLString struct LString *

&lt;span&gt;#define&lt;/span&gt; stringref struct LStringRef 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define GetStr  s.str 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面这几个宏可是可以用,不过太容易冲突了,最好是逻辑清晰度要求很高的地方才用 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GetStr  buf-&amp;gt;str 
&lt;span&gt;#define&lt;/span&gt; GetLen  buf-&amp;gt;len 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define str()  buf-&amp;gt;str 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define len()  buf-&amp;gt;len &lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; str__  buf-&amp;gt;str 
&lt;span&gt;#define&lt;/span&gt; len__  buf-&amp;gt;len 



&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了能自动释放,只能是指针,结构体在参数传递时会丢失字段值,所以完全的模仿 C++ 是不可能的 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; BindStringFunctions(lstring *&lt;span&gt; s);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring String(char * str);


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动释放&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只释放字符串 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; autofree_s(&lt;span&gt;struct&lt;/span&gt; MemPool * pool, &lt;span&gt;struct&lt;/span&gt; LString *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    
    s&lt;/span&gt;-&amp;gt;pool = pool; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加上这个标志,这样根据这个 s 操作出来的 string 都可以通过它自动释放了 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pool_AddItem(pool, p);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pool_AddItem(pool, s-&amp;gt;str);&lt;/span&gt;
&lt;span&gt;    Pool_AddItem(pool, s);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动释放&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不只释放字符串,连指针一起释放 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; autofree_pstring(&lt;span&gt;struct&lt;/span&gt; MemPool * pool, &lt;span&gt;struct&lt;/span&gt; LString *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    
    s&lt;/span&gt;-&amp;gt;pool = pool; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加上这个标志,这样根据这个 s 操作出来的 string 都可以通过它自动释放了 &lt;/span&gt;
&lt;span&gt;
    Pool_AddItem(pool, s);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Pool_AddItem(pool, s-&amp;gt;str);&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/分配并返回一个字符串 &lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stringref MakeString(char * str)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    stringref s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.buf = malloc(sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(s.buf, 0, sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.buf-&amp;gt;_const = 0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.buf-&amp;gt;len = strlen(str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.buf-&amp;gt;str = NULL;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (str != NULL)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        s.buf-&amp;gt;str = malloc(s.buf-&amp;gt;len + 1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要留最后 \0 的位置 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        memset(s.buf-&amp;gt;str, 0, s.buf-&amp;gt;len + 1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;        
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        strcpy(s.buf-&amp;gt;str, str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;BindStringFunctions(&amp;amp;s);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/分配并返回一个字符串指针&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring * PString(lstring s)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring s = String(str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring * p = malloc(sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    *p = s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    p-&amp;gt;_malloc = 1; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要释放结构体本身 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    autofree_pstring(s-&amp;gt;pool, p);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return p;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//
&lt;/span&gt;

&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/释放 //pfree 是否释放指针本身 &lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void FreeStringRef(stringref * s, int pfree)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (s-&amp;gt;buf == NULL || s-&amp;gt;buf-&amp;gt;str == NULL)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        printf(&quot;FreeString() error: string is NULL&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (s-&amp;gt;buf-&amp;gt;_const != 0)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        printf(&quot;FreeString() error: string is readonly&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    else
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        free(s-&amp;gt;buf-&amp;gt;str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        s-&amp;gt;buf-&amp;gt;str = NULL;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    free(s-&amp;gt;buf);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (pfree)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        free(s);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; _FreeString(lstring * s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pfree)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FreeString() error: lstring * s is NULL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s-&amp;gt;str ==&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FreeString() error: s-&amp;gt;str is NULL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s-&amp;gt;_const != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FreeString() error: string is readonly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return;&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(s-&amp;gt;&lt;span&gt;str);
        s&lt;/span&gt;-&amp;gt;str =&lt;span&gt; NULL;
    }

    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pfree)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否释放指针本身&lt;/span&gt;
        &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s);

}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; FreeString(lstring s)
{
    _FreeString(&lt;/span&gt;&amp;amp;s, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只释放数据 &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; FreePString(lstring *&lt;span&gt; s)
{
    _FreeString(s, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放数据和指针&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/释放//给内存池调用的 &lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void FreeString_ForPool(struct MemPool_Item * poolitem)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;void * p = poolitem-&amp;gt;data;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring * p = poolitem-&amp;gt;data;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (p == NULL) return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;准备释放:%s\r\n&quot;, p-&amp;gt;str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    FreePString(p);    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配一个内存池释放的 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring * StringPool(struct MemPool * pool, char * str)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring * s = PString(str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Pool_AddItem(pool, s, FreeString_ForPool);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配一个内存池释放的 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stringref StringRef(struct MemPool * pool, char * str)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring * s = PString(str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Pool_AddItem(pool, s, FreeString_ForPool);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return *s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用结构体就做不了自动释放,所以还是用指针吧,毕竟不是 C++ 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring String(char * str, struct MemPool * pool)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(&amp;amp;s, 0, sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.len = strlen(str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s.str = malloc(s.len+1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(s.str, 0, s.len+1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memcpy(s.str, str, s.len);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    BindStringFunctions(&amp;amp;s);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    autofree_s(pool, s);    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return s;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;各个常用函数中尽量使用这个函数分配新字符串,因为它生成的可自动释放,避免 autofree 满天飞
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个应该是基础函数,不要使用其他函数实现 &lt;/span&gt;
lstring * NewString(&lt;span&gt;char&lt;/span&gt; * str, &lt;span&gt;struct&lt;/span&gt; MemPool *&lt;span&gt; pool)
{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring s = String(str);&lt;/span&gt;
    lstring * p = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString));
    
    memset(p, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString)); 
    
    p&lt;/span&gt;-&amp;gt;_malloc = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    p&lt;/span&gt;-&amp;gt;len =&lt;span&gt; strlen(str);
    p&lt;/span&gt;-&amp;gt;str = &lt;span&gt;malloc&lt;/span&gt;(p-&amp;gt;len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    memset(p&lt;/span&gt;-&amp;gt;str, &lt;span&gt;0&lt;/span&gt;, p-&amp;gt;len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    memcpy(p&lt;/span&gt;-&amp;gt;str, str, p-&amp;gt;&lt;span&gt;len);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
&lt;span&gt;    BindStringFunctions(p);    

    autofree_pstring(pool, p);
    

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般用于参数传递&lt;/span&gt;
&lt;span&gt;lstring StringCopy(lstring str)
{
    
    lstring s;
    
    memset(&lt;/span&gt;&amp;amp;s, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString));
    
    s.len &lt;/span&gt;=&lt;span&gt; str.len;

    s.str &lt;/span&gt;= &lt;span&gt;malloc&lt;/span&gt;(s.len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    memset(s.str, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, s.len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    memcpy(s.str, str.str, str.len);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
    BindStringFunctions(&amp;amp;&lt;span&gt;s);    
    

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
}



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制一个字符串给另外一个内存池,如果对方为 NULL 那么就变成自由的字符串了,不过最好是不要这样做,应当从设计上要求每个字符串生成时都有medh池 &lt;/span&gt;
lstring * PStringCopyToPool(lstring * s, &lt;span&gt;struct&lt;/span&gt; MemPool *&lt;span&gt; pool)
{
    
    lstring &lt;/span&gt;* p = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString));
    
    memset(p, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LString));
    
    p&lt;/span&gt;-&amp;gt;_malloc = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体本身是分配的内存,也要释放 &lt;/span&gt;
&lt;span&gt;    
    p&lt;/span&gt;-&amp;gt;len = s-&amp;gt;&lt;span&gt;len;

    p&lt;/span&gt;-&amp;gt;str = &lt;span&gt;malloc&lt;/span&gt;(s-&amp;gt;len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    memset(p&lt;/span&gt;-&amp;gt;str, &lt;span&gt;0&lt;/span&gt;, s-&amp;gt;len+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    memcpy(p&lt;/span&gt;-&amp;gt;str, s-&amp;gt;str, s-&amp;gt;&lt;span&gt;len);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
&lt;span&gt;    BindStringFunctions(p);    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (autofree == 1) autofree_pstring(s-&amp;gt;pool, p);&lt;/span&gt;
&lt;span&gt;    autofree_pstring(pool, p);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制一个字符串 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring * PStringCopy(lstring * s, int autofree)&lt;/span&gt;
lstring * PStringCopy(lstring *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; PStringCopyToPool(s, s-&amp;gt;&lt;span&gt;pool);
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring * p = malloc(sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(p, 0, sizeof(struct LString));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    p-&amp;gt;_malloc = 1; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体本身是分配的内存,也要释放 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    p-&amp;gt;len = s-&amp;gt;len;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    p-&amp;gt;str = malloc(s-&amp;gt;len+1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(p-&amp;gt;str, 0, s-&amp;gt;len+1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memcpy(p-&amp;gt;str, s-&amp;gt;str, s-&amp;gt;len);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    BindStringFunctions(p);    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (autofree == 1) 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    autofree_pstring(s-&amp;gt;pool, p);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return p;&lt;/span&gt;
}&lt;span&gt;//&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不分配内存,只是将一个缓冲区按 string 方式操作而已,类似 golang 的 bytes ,所以不要释放它 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个也是基础函数 ,虽然它的内存不用释放,但也还是要传 pool ,以便给生成的子字符串自动释放的机会 &lt;/span&gt;
lstring StringConst(&lt;span&gt;char&lt;/span&gt; * str, &lt;span&gt;int&lt;/span&gt; len, &lt;span&gt;struct&lt;/span&gt; MemPool *&lt;span&gt; pool)
{
    lstring s;
    

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s._const = 0;&lt;/span&gt;
&lt;span&gt;    
    s._const &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    s.len &lt;/span&gt;= len; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;strlen(str);&lt;/span&gt;
    s.str = str; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;malloc(s.len);&lt;/span&gt;
&lt;span&gt;    
    s.pool &lt;/span&gt;=&lt;span&gt; pool;
    

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
    BindStringFunctions(&amp;amp;&lt;span&gt;s);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;

}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; LString_Append(lstring * _s, lstring *&lt;span&gt; _add)
{
    lstring s &lt;/span&gt;= (*_s); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牺牲一点点性能来换语法&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;golang 就没有 -&amp;gt; &lt;/span&gt;
    lstring add = (*_add);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;牺牲一点点性能来换语法&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;golang 就没有 -&amp;gt; &lt;/span&gt;
    
    
    &lt;span&gt;char&lt;/span&gt; * tmp = &lt;span&gt;malloc&lt;/span&gt;(s.len + add.len + &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要留最后 \0 的位置 &lt;/span&gt;
    memset(tmp, &lt;span&gt;0&lt;/span&gt;, s.len + add.len + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    memcpy(tmp, s.str, s.len);
    memcpy(tmp &lt;/span&gt;+ s.len, add.str, add.len); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要注意&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加上后半段 &lt;/span&gt;
    
    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(s.str);

    s.str &lt;/span&gt;=&lt;span&gt; tmp;
    s.len &lt;/span&gt;= s.len +&lt;span&gt; add.len;
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    char * tmp = malloc(s-&amp;gt;len + add-&amp;gt;len + 1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要留最后 \0 的位置 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memset(tmp, 0, s-&amp;gt;len + add-&amp;gt;len + 1);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memcpy(tmp, s-&amp;gt;str, s-&amp;gt;len);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    memcpy(tmp + s-&amp;gt;len, add-&amp;gt;str, add-&amp;gt;len); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要注意&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加上后半段 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    free(s-&amp;gt;str);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s-&amp;gt;str = tmp;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s-&amp;gt;len = s-&amp;gt;len + add-&amp;gt;len;    &lt;/span&gt;


    *_s =&lt;span&gt; s;
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;



&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入传统 C 字符串&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; LString_AppendCString(lstring * s, &lt;span&gt;char&lt;/span&gt; * str, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len)
{
    lstring add &lt;/span&gt;= StringConst(str, len, s-&amp;gt;&lt;span&gt;pool);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add len:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, add.len);
    LString_Append(s, &lt;/span&gt;&amp;amp;&lt;span&gt;add);
    
}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; LString_AppendConst(lstring * s, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; add)
{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;add len:%d&quot;, add-&amp;gt;len);&lt;/span&gt;
&lt;span&gt;    LString_AppendCString(s, add, strlen(add));
    
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int LString_AppendConst(lstring * _s, const char * _add)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;ok4 \r\n&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    lstring add = StringConst((char *)_add, strlen(_add));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;ok1&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    LString_Append(_s, &amp;amp;add);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;ok&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查字符串指针是否合法,只是简单的方法,不可靠,但有一定作用 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; CheckPString(lstring *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CheckPString: error, string is NULL!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就目前的要自动释放的需求来说,是不能为 NULL 的,因为那样 pool 就没有传入了 &lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    printf_err1(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CheckPString: s-&amp;gt;_init != NULL\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s-&amp;gt;_init != NULL) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实对于现代的编译器和操作系统来说,如果 s 没有初始化,在这里就很可能崩溃,所以实际上是检测不出来的,所以首尾都打印一下看看这个过程没结束就是这里出错了,对性能要求高的地方,去掉 printf 宏就可以不打印了&lt;/span&gt;
&lt;span&gt;    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CheckPString: error, string is not init!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就目前的要自动释放的需求来说,是不能为 NULL 的,因为那样 pool 就没有传入了 &lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    printf_err1(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CheckPString: s-&amp;gt;_init != NULL ok.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;



&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定各个成员函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; BindStringFunctions(lstring *&lt;span&gt; s) 
{
    printf_err1(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BindStringFunctions \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    s&lt;/span&gt;-&amp;gt;Append =&lt;span&gt; LString_Append;
    s&lt;/span&gt;-&amp;gt;AppendConst =&lt;span&gt; LString_AppendConst;

}&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;



&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;125&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作 lstring * 的各种底层函数 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为 lstring 包含了传统 C 的 0 结尾,所以大部分可以直接代用 C 的函数,当然最好参照 golang 重写&lt;/span&gt;
&lt;span&gt;
#ifndef _L_STRING_FUNCTIONS_C_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt;    _L_STRING_FUNCTIONS_C_&lt;span&gt;

#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lstring.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;delphi 转换方便函数&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但 C 语言索引是从 0 开始,不是 d7 的从 1 开始,一定要注意
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找子串位置 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;php 的 strpos 基本上也是这样 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; pos(lstring * substr, lstring *&lt;span&gt; s) 
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p = strstr(s-&amp;gt;str, substr-&amp;gt;&lt;span&gt;str);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == NULL) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p - (s-&amp;gt;&lt;span&gt;str);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;substr(字符串,截取开始位置,截取长度)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 0 开始 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lstring * substr(lstring * s, int start, int len) &lt;/span&gt;
lstring * substring(lstring * s, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) 
{
    lstring r;
    lstring &lt;/span&gt;*&lt;span&gt; sub;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p =&lt;span&gt; NULL;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (start + len &amp;gt; s-&amp;gt;len) return NULL;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果太多&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (start + len &amp;gt; s-&amp;gt;len) len = (s-&amp;gt;len) - start;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果太多返回后面的 &lt;/span&gt;
&lt;span&gt;     
    p &lt;/span&gt;= s-&amp;gt;str +&lt;span&gt; start;
    
    r &lt;/span&gt;= StringConst(p, len, s-&amp;gt;&lt;span&gt;pool);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r = StringCopy(r); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;StringConst 不分配内存的,所以要复制一个新的出来 
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sub = PString(r);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;autofree_pstring(s-&amp;gt;pool, sub);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回字符串跟着 s 一起释放 &lt;/span&gt;
&lt;span&gt;    
    sub &lt;/span&gt;= PStringCopy(&amp;amp;&lt;span&gt;r);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sub;

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串是否相等 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似 java 的 equals&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; str_equals(lstring * s1, lstring *&lt;span&gt; s2)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s1 == NULL &amp;amp;&amp;amp; s2 == NULL) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s1 == NULL || s2 == NULL) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两者不可能都为空的情况下有一个为空,那就是不相等了 &lt;/span&gt;
    
    &lt;span&gt;if&lt;/span&gt; (s1-&amp;gt;len != s2-&amp;gt;len) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度不等肯定也不是 &lt;/span&gt;
    
    &lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;0&lt;/span&gt; == strncmp(s1-&amp;gt;str, s2-&amp;gt;str, s1-&amp;gt;len) ) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; streq(lstring * s1, lstring *&lt;span&gt; s2)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str_equals(s1, s2); 
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; str_equals_c(lstring * s1, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; s2)
{
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;0&lt;/span&gt; == strcmp(s1-&amp;gt;str, s2) ) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3) 前加#，将标记转换为字符串．
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define C(x) #x
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;则C(1+1) 即 ”1+1”．

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define C(x) #x&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; C(x) 
&lt;span&gt;#define&lt;/span&gt; C1(a1, x, a2) strcmp(a1, a2)

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int ee_-()&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t()
{
    C(&lt;/span&gt;==&lt;span&gt;);
    C1(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,==,&lt;span&gt;&quot;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以这样模拟一个 == 号出来 &lt;/span&gt;
&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常用简写而已 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; seq(lstring * s1, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; s2)
{

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str_equals_c(s1, s2);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换单个字符,在需要高效时使用,因为替换一长串比较慢 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;str_replace &lt;/span&gt;
lstring * str_replace_ch(lstring * s, &lt;span&gt;char&lt;/span&gt; ch, &lt;span&gt;char&lt;/span&gt;&lt;span&gt; newch)
{
    lstring &lt;/span&gt;* r =&lt;span&gt; PStringCopy(s);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;r-&amp;gt;len; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r-&amp;gt;str[i] ==&lt;span&gt; ch)
            r&lt;/span&gt;-&amp;gt;str[i] =&lt;span&gt; newch;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主要用于判断空字符串&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;delphi 风格 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; length(lstring *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == NULL) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s-&amp;gt;&lt;span&gt;len;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;delphi 风格 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; Length(lstring *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; length(s);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主要用于判断空字符串&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;golang 风格 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; len(lstring *&lt;span&gt; s)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == NULL) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s-&amp;gt;&lt;span&gt;len;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为小写,注意这个在中文下会有问题&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了兼容字符串自动释放,当参数为空时只好返回空,要不找不到父节点 &lt;/span&gt;
lstring * lowercase(lstring *&lt;span&gt; s)
{
    lstring &lt;/span&gt;* r =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lowercase: error, string is NULL!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就目前的要自动释放的需求来说,是不能为 NULL 的,因为那样 pool 就没有传入了 &lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查字符串指针是否合法,只是简单的方法,不可靠,但有一定作用 &lt;/span&gt;
&lt;span&gt;    CheckPString(s);
    
    r &lt;/span&gt;=&lt;span&gt; PStringCopy(s);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r-&amp;gt;pool = s-&amp;gt;pool; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让原字符串释放它
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;autofree_pstring(s-&amp;gt;pool, r); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让原字符串释放它&lt;/span&gt;
    
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; r-&amp;gt;len; i++&lt;span&gt;) 
    {
        r&lt;/span&gt;-&amp;gt;str[i] = tolower(r-&amp;gt;&lt;span&gt;str[i]);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有返回值,确实有问题 &lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换为大写,注意这个在中文下会有问题&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了兼容字符串自动释放,当参数为空时只好返回空,要不找不到父节点 &lt;/span&gt;
lstring * uppercase(lstring *&lt;span&gt; s)
{
    lstring &lt;/span&gt;* r =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NULL)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lowercase: error, string is NULL!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就目前的要自动释放的需求来说,是不能为 NULL 的,因为那样 pool 就没有传入了 &lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查字符串指针是否合法,只是简单的方法,不可靠,但有一定作用 &lt;/span&gt;
&lt;span&gt;    CheckPString(s);
    
    r &lt;/span&gt;=&lt;span&gt; PStringCopy(s);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r-&amp;gt;pool = s-&amp;gt;pool; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让原字符串释放它
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;autofree_pstring(s-&amp;gt;pool, r); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让原字符串释放它&lt;/span&gt;
    
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; r-&amp;gt;len; i++&lt;span&gt;) 
    {
        r&lt;/span&gt;-&amp;gt;str[i] = toupper(r-&amp;gt;&lt;span&gt;str[i]);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有返回值,确实有问题 &lt;/span&gt;
    
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与传统 get_value 不同,这个的匹配结尾字符串为查找互的第一个而不是最后一个
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应该不区分大小写
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要注意 C 语言的字符串是从 0 起始,而原来 delphi 的是从 1 起始的,所以 d7 转换过来的算法不能全部照搬的&lt;/span&gt;
lstring * get_value_first(lstring *s, lstring * b_sp, lstring *&lt;span&gt; e_sp)
{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始复制的位置&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; b_pos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制结束的位置&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; e_pos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    lstring &lt;/span&gt;*&lt;span&gt; ls;
    lstring &lt;/span&gt;* r =&lt;span&gt; NULL;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len(e_sp) == &lt;span&gt;0&lt;/span&gt;) e_pos =&lt;span&gt; length(s);

    ls &lt;/span&gt;=&lt;span&gt; lowercase(s);
    b_sp &lt;/span&gt;=&lt;span&gt; lowercase(b_sp);
    e_sp &lt;/span&gt;=&lt;span&gt; lowercase(e_sp);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查字符串指针是否合法,只是简单的方法,不可靠,但有一定作用&lt;/span&gt;
&lt;span&gt;    CheckPString(ls);
    CheckPString(b_sp);
    CheckPString(e_sp);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------&lt;/span&gt;
&lt;span&gt;
    b_pos &lt;/span&gt;=&lt;span&gt; pos(b_sp, ls);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (length(b_sp) == 0) b_pos = 1;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (length(b_sp) == &lt;span&gt;0&lt;/span&gt;) b_pos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (b_pos == 0)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (b_pos == -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没找到&lt;/span&gt;
&lt;span&gt;    {
        r &lt;/span&gt;= NewString(&lt;span&gt;&quot;&quot;&lt;/span&gt;, s-&amp;gt;&lt;span&gt;pool);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;autofree_pstring(s-&amp;gt;pool, r); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的字符串跟着 s 一起释放&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
    };

    b_pos &lt;/span&gt;= b_pos +&lt;span&gt; length(b_sp);
    r &lt;/span&gt;=&lt;span&gt; substring(s, b_pos, length(s));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result = copy(s, b_pos, length(s));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e_pos = pos(e_sp, lowercase(r)) - 1;&lt;/span&gt;
    e_pos =&lt;span&gt; pos(e_sp, lowercase(r));

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e_pos == -&lt;span&gt;1&lt;/span&gt;) e_pos =&lt;span&gt; length(r);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r = substring(r, 1, e_pos);&lt;/span&gt;
    r = substring(r, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, e_pos);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c 语言的参数 &lt;/span&gt;
lstring * getValueFirst_c(lstring *s, &lt;span&gt;char&lt;/span&gt; * b_sp, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; e_sp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; get_value_first(s, NewString(b_sp, s-&amp;gt;pool), NewString(e_sp, s-&amp;gt;&lt;span&gt;pool));

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c 语言的参数 &lt;/span&gt;
lstring * get_value_first_c(lstring *s, &lt;span&gt;char&lt;/span&gt; * b_sp, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; e_sp)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; get_value_first(s, NewString(b_sp, s-&amp;gt;pool), NewString(e_sp, s-&amp;gt;&lt;span&gt;pool));

}





&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;



&lt;/td&gt;
</description>
<pubDate>Fri, 26 Jan 2018 03:57:00 +0000</pubDate>
<dc:creator>clq</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-clq/p/8358874.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】PaddlePaddle可视化之VisualDL - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8358194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8358194.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上篇文章我们讲了如何对模型进行可视化，用的keras手动绘图输出CNN训练的中途结果，本篇文章将讲述如何用PaddlePaddle新开源的VisualDL来进行可视化。在讲VisualDL之前，我们先了解一下常用的Tensorflow的可视化工具---Tensorboard。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Tensorflow的可视化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Tensorboard是Tensorflow自带的可视化模块，我们可以通过Tensorboard直观的查看神经网络的结构，训练的收敛情况等。要想掌握Tensorboard，我们需要知道一下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持的数据形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;具体的可视化过程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何对一个实例使用Tensorboard&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　&lt;span&gt;　数据形式&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）标量Scalars &lt;br/&gt;（2）图片Images &lt;br/&gt;（3）音频Audio &lt;br/&gt;（4）计算图Graph &lt;br/&gt;（5）数据分布Distribution &lt;br/&gt;（6）直方图Histograms &lt;br/&gt;（7）嵌入向量Embeddings&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt; 可视化过程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）建立一个graph。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）确定在graph中的不同节点设置summary operations。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）将(2)中的所有summary operations合并成一个节点，运行合并后的节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）使用tf.summary.FileWriter将运行后输出的数据都保存到本地磁盘中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）运行整个程序，并在命令行输入运行tensorboard的指令，打开web端可查看可视化的结果&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;使用Tensorborad的实例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我就不讲的特别详细啦，如果用过Tensorflow的同学其实很好理解，只需要在平时写的程序后面设置summary，tf.summary.scalar记录标量，tf.summary.histogram记录数据的直方图等等，&lt;/span&gt;&lt;span&gt;然后正常训练，最后把所有的summary合并成一个节点，存放到一个地址下面，在linux界面输入一下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tensorboard --logdir=‘存放的总summary节点的地址’
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;然后会出现以下信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Starting TensorBoard 41 on port 6006
&lt;span&gt;2&lt;/span&gt; (You can navigate to http://127.0.1.1:6006)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　将http://127.0.1.1:6006在浏览器中打开，就可以看到web端的可视化了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180126103104850-999617728.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;281&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　具体的参数表示的含义可以参照官网的解释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;MXNet的可视化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MXNet的可视化之前一直使用mx.viz.plot_network来构建一个神经网络图，但是后来有一位阿里的同学把tensorboard封装在了mxnet里，具体可以参照&lt;a href=&quot;https://github.com/dmlc/tensorboard&quot; target=&quot;_blank&quot;&gt;https://github.com/dmlc/tensorboard&lt;/a&gt;，可以对照他写的这篇文章来看&lt;/span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24660810&quot; target=&quot;_blank&quot;&gt;Bring TensorBoard to MXNet&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　ps：这个功能好像去年年初他们就开始搞了，看到他发的朋友圈才知道没过几个月就上线了，真效率，喜欢mxnet的同学可以尝试一下。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PaddlePaddle的可视化--EventHandler &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在PaddlePaddle发布VisualDL之前，我一直是用event_handler来可视化训练的收敛情况。我找了一段之前写的一个类里的小代码来展示如何使用event_handler&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start_trainer(self,X_train,Y_train,X_val,Y_val):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得训练器&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         trainer =&lt;span&gt; self.get_trainer()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         result_lists =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt;&lt;span&gt; event_handler(event):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(event, paddle.event.EndIteration):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; event.batch_id % 10 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nPass %d, Batch %d, Cost %f, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                        event.pass_id, event.batch_id, event.cost, event.metrics)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(event, paddle.event.EndPass):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存训练好的参数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;params_pass_%d.tar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % event.pass_id, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    parameters.to_tar(f)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; feeding = ['x','y']&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 result =&lt;span&gt; trainer.test(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         reader=&lt;span&gt;val_reader)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; feeding=feeding)&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTest with Pass %d, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (event.pass_id, result.metrics)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                result_lists.append((event.pass_id, result.cost,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         result.metrics[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始训练&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         train_reader =&lt;span&gt; paddle.batch(paddle.reader.shuffle(
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 reador.reader_creator(X_train,Y_train),buf_size=200&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 batch_size=16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         val_reader =&lt;span&gt; paddle.batch(paddle.reader.shuffle(
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 reador.reader_creator(X_val,Y_val),buf_size=200&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 batch_size=16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         trainer.train(reader=train_reader,num_passes=20,event_handler=&lt;span&gt;event_handler)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找到训练误差最小的一次结果&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     best = sorted(result_lists, key=&lt;span&gt;lambda&lt;/span&gt; list: float(list[1&lt;span&gt;]))[0]
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Best pass is %s, testing Avgcost is %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (best[0], best[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;The classification accuracy is %.2f%%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (100 - float(best[2]) * 100)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　trainer = self.get_trainer()不用管，因为之前写的一个函数叫get_trainer，你可以先定义trainer，然后放在这里，后面设一个空列表存放每次训练的结果，我这个代码里叫result_lists，然后定义event_handler函数，在开始训练，这样每次训练的结果都会传入result_lists这个列表里面，最后进行排序，把最优结果放到best里，输出就可以。最后用event_handler_plot画图，输出如下收敛的图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201801/853467-20180126105016475-6312516.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是这样不能观察到神经网络在训练过程中的每个神经元的具体变化情况，不如tensorboard的功能多，只能看到我们在训练过程中的loss下降的情况，训练是否收敛等。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PaddlePaddle的新版可视化工具--VisualDL&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大概就在上周，1.16日，PaddlePaddle和Echarts团队练手打造了VisualDL可视化工具 ，我试用了以后发现和tensorborad的功能好像！简单说说特性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持Scaler打点数据展示，可将训练信息以折线图的形式展现出来，方便观察整体趋势，还能在同一个可视化视图中呈现多条折线，方便用户对比分析。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持Image图片展示可轻松查看数据样本的质量，也可以方便地查看训练的中间结果，例如卷积层的输出或者GAN生成的图片。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持Histogram参数分布展示功能，方便用户查看参数矩阵中数值的分布曲线，并随时观察参数数值分布的变化趋势。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;支持Graph查看深度神经网络的模型结构。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这样一看，其实基本上实现了tensorboard的功能，或者应该简称“Bring TensorBorad To PaddlePaddle”。不知道博客园怎么放gif，具体的图片展示就直接看官网吧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/JZ2X27eVTVL5tAgeeDtoVQ&quot; target=&quot;_blank&quot;&gt;深度学习可视化工具Visual DL——“所见即所得”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　总的来说，Tensorboard是一个非常好的可视化工具，mxnet原来只能可视化神经网络结构图，paddlepaddle原来只能看loss下降的训练收敛图，但是后来mxnet把tensorborad搞进去了，paddlepaddle发布了一个新的工具VisualDL，实现了Tensorborad的功能，还是非常厉害的！大家可以多体验体验，这样就不用像上篇文章手动的去画每个网络结果中间的输出结果图，直接用VisualDL的Image展示就可以了，更加方便我们理解模型，观察模型训练的过程，简单来说，让我们不透明的“炼丹术”变得更加透明清楚了~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 03:09:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8358194.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：节点 CPU 波动引发 docker swarm 集群故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8358383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8358383.html</guid>
<description>&lt;p&gt;非常抱歉，今天 10:05-10:20 左右，我们用阿里云服务器搭建的 docker swarm 集群又出现故障，又是因为突然的节点 CPU 波动。&lt;/p&gt;
&lt;p&gt;受这次故障影响的站点有 &lt;a href=&quot;https://ing.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;闪存&lt;/a&gt;，&lt;a href=&quot;https://q.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博问&lt;/a&gt;，&lt;a href=&quot;https://edu.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;班级&lt;/a&gt;，&lt;a href=&quot;https://home.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;园子&lt;/a&gt;，&lt;a href=&quot;https://msg.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;短信息&lt;/a&gt;，&lt;a href=&quot;https://job.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;招聘&lt;/a&gt;，&lt;a href=&quot;https://group.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;小组&lt;/a&gt;，&lt;a href=&quot;https://wz.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;网摘&lt;/a&gt;，openapi ，由此给您带来很大的麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;故障前先是有一个 worker 节点出现 CPU 100% 报警：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;云服务器ECS实例：swarm1-node5，CPU使用率于10:00发生告警，值为100%，持续时间1分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;收到报警后，我们将这个节点下线并重启：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker node update --availability drain swarm1-node5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，3 个 manager 节点一个接一个地 ssh 无法登录，之后整个集群宕机，跑在集群上的所有站点无法访问。&lt;/p&gt;
&lt;p&gt;随后，我们通过阿里云控制台强制重启 manager 节点，但重启后集群无法恢复：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时别无选择，我们立即执行 shell 脚本重建集群：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ./rebuild-production-swarm.sh
Swarm initialized: current node (id6b69wj83ok2cf3tnsg7vm8l) is now a manager.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注：这也是我们选择自建 docker swarm 集群没有选择阿里云容器服务的原因之一，可以快速地用脚本重建集群）&lt;/p&gt;
&lt;p&gt;重建集群后，一切恢复正常。&lt;/p&gt;
&lt;p&gt;附1：docker 版本是 Docker version 17.12.0-ce, build c97c6d6 。&lt;/p&gt;
&lt;p&gt;附2：集群中各个节点的 CPU 监控图：&lt;/p&gt;
&lt;p&gt;1）swarm1-node1（manager节点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/35695/201801/35695-20180126105855303-783449179.png&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）swarm1-node2（manager节点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/35695/201801/35695-20180126110107256-93186838.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）swarm1-node3（manager节点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/35695/201801/35695-20180126110238819-1270430145.png&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）swarm1-node4（worker 节点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/35695/201801/35695-20180126110417662-957901550.png&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5）swarm1-node5（worker 节点）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/35695/201801/35695-20180126104048615-1809676865.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 03:08:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8358383.html</dc:identifier>
</item>
<item>
<title>正则入门实例拓展 - YourSimple</title>
<link>http://www.cnblogs.com/chao8888/p/8352476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chao8888/p/8352476.html</guid>
<description>&lt;p&gt;本篇主要介绍Perl(以及其他流派的正则)提供的简记法(shorthands)，以及修改文本中使用的正则环视特性，包括几个举例。在看这篇之前，不管你是否精通正则，建议首先看下这篇&lt;a href=&quot;http://www.cnblogs.com/chao8888/p/8311340.html&quot;&gt;《正则基础与细节回顾》&lt;/a&gt;，因为强大的正则里面，需要关注的细节太多了。&lt;/p&gt;
&lt;h2 id=&quot;常用空白和任意字符匹配&quot;&gt;1.常用空白和任意字符匹配&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;\s&lt;/code&gt;和&lt;code&gt;[ \t]*&lt;/code&gt;: 匹配空白&lt;br/&gt;&lt;code&gt;.*&lt;/code&gt;: 匹配任何字符. &lt;code&gt;.&lt;/code&gt;号通配符，&lt;code&gt;*&lt;/code&gt;任意个数，可以为零。&lt;/p&gt;
&lt;h2 id=&quot;perl以及其他流派的正则提供的简记法shorthands&quot;&gt;2.Perl(以及其他流派的正则)提供的简记法(shorthands):&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;\b&lt;/code&gt;: 单词分界符&lt;br/&gt;&lt;code&gt;\t&lt;/code&gt;: 制表符&lt;br/&gt;&lt;code&gt;\n&lt;/code&gt;: 换行符&lt;br/&gt;&lt;code&gt;\r&lt;/code&gt;: 回车符&lt;br/&gt;&lt;code&gt;\s&lt;/code&gt;: 匹配任何空白符 (space, tab, newline, formfeed, and such)&lt;br/&gt;&lt;code&gt;\S&lt;/code&gt;: 除&lt;code&gt;\s&lt;/code&gt;之外任何字符&lt;br/&gt;&lt;code&gt;\w&lt;/code&gt;: 相当于&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;\W&lt;/code&gt;: 除&lt;code&gt;\w&lt;/code&gt;之外任何字符，相当于&lt;code&gt;[ˆa-zA-Z0-9R]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;\d&lt;/code&gt;: 相当于&lt;code&gt;[0-9]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;\D&lt;/code&gt;: 除&lt;code&gt;\d&lt;/code&gt;之外任何字符，相当于&lt;code&gt;[ˆ0-9]&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用正则修改文本&quot;&gt;3.使用正则修改文本&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;捕获&quot;&gt;3.1捕获&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;Perl可以使用&lt;code&gt;$1,$2,$3&lt;/code&gt;之类的变量来保存相对应的&lt;code&gt;(···)&lt;/code&gt;括号内的子表达式匹配的文本。子表达式的编号按照开括号出现的先后顺序，从1开始，子表达式可以嵌套，比如&lt;code&gt;(Washington( DC)?)&lt;/code&gt;。我们修改文本，可能会保留某些原文本，那么使用&lt;code&gt;$1&lt;/code&gt;这类的变量就可以实现。简单的举一个例子，比如说我们想给所有的数字加上双引号，我们可以使用&lt;code&gt;(\d)+&lt;/code&gt;匹配到所有的数字后，替换结果用&lt;code&gt;&quot;$1&quot;&lt;/code&gt;取代，最终到达我们想要的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/912458/201801/912458-20180125180232522-1542886720.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/912458/201801/912458-20180125180247084-925229544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(?:···)&lt;/code&gt;这种写法可以用来分组文本，但是并不捕获。&lt;code&gt;(···)&lt;/code&gt;当然也可以分组，但是副作用就是他们捕获的文本依然会保存在特殊的变量中。比如&lt;code&gt;(A\d)+&lt;/code&gt;，我们只是想让字母A和一个数字组合起来，但是这样正则依旧会捕获到括号中的内容并且记录，虽然看似没有多大影响，但是对于文本量比较大的文件，为了增加匹配效率，我们可以使用&lt;code&gt;(?:A\d)+&lt;/code&gt;，这个时候再用类似&lt;code&gt;$1&lt;/code&gt;这样的变量，就获取不到引用的文本了。&lt;/p&gt;
&lt;h3 id=&quot;环视lookaround&quot;&gt;3.2环视(lookaround)&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;我们先来想一个问题，假如我们有诸如&lt;code&gt;3567657745&lt;/code&gt;这样一批代表数量的数字，一般为了方便，我们会这样写&lt;code&gt;3,567,657,745&lt;/code&gt;。为了解决这个问题，我们首先想到的是从右向左每隔3个数字加个逗号，并且逗号前面必须有数字，但是正则一般都是从左向右工作的。那么接下来我们就介绍正则的环视特性。&lt;/p&gt;
&lt;p&gt;首先强调的是，环视不匹配任何字符，只匹配文中的特定位置，这一点和单词分解符&lt;code&gt;\b&lt;/code&gt;、锚点&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;相似。但是，环视更加通用。&lt;/p&gt;
&lt;p&gt;环视有四种类型，参考以下表格&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;肯定顺序环视&lt;/td&gt;
&lt;td&gt;(?=···)&lt;/td&gt;
&lt;td&gt;子表达式能匹配右侧文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;否定顺序环视&lt;/td&gt;
&lt;td&gt;(?!···)&lt;/td&gt;
&lt;td&gt;子表达式不能匹配右侧文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;肯定逆序环视&lt;/td&gt;
&lt;td&gt;(?&amp;lt;=···)&lt;/td&gt;
&lt;td&gt;子表达式能匹配左侧文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;肯定逆序环视&lt;/td&gt;
&lt;td&gt;(?&amp;lt;!···)&lt;/td&gt;
&lt;td&gt;子表达式不能匹配左侧文本&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;了解这些后，我们继续回到给数字加逗号的问题，首先思考3的倍数，3的倍数很好处理，直接&lt;code&gt;(\d\d\d)+$&lt;/code&gt;，加上&lt;code&gt;$&lt;/code&gt;来保证数字后面不存在其他字符。&lt;code&gt;,&lt;/code&gt;在左边是数字，我们可以使用&lt;code&gt;(?&amp;lt;=\d)&lt;/code&gt;来限定匹配的位置，于是整个正则表达式就是&lt;code&gt;(?&amp;lt;=\d)(?=(\d\d\d)+$)&lt;/code&gt;。其实这样子还是不太好，因为里面存在括号，括号中的内容会被特定的变量&lt;code&gt;&amp;amp;1&lt;/code&gt;等引用，所以我们最好使用只是分组的&lt;code&gt;(?:···)&lt;/code&gt;来处理一下，于是变成了&lt;code&gt;(?&amp;lt;=\d)(?=(?:\d\d\d)+$)&lt;/code&gt;，猛一看上去有点难以理解，但是一步一步看，还是挺清晰的。我们已经知道，环视不会匹配任何字符，只是匹配位置，匹配到这样的位置后，我们只要插入一个逗号即可，于是替换文本只需要是&lt;code&gt;,&lt;/code&gt;就可以了，我们看下处理前后的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/912458/201801/912458-20180126104443115-1391781226.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/912458/201801/912458-20180126104508131-1917780174.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;掌握了环视，我们回头来想一下&lt;code&gt;\b&lt;/code&gt;这个单词分界符，如果单词分解符的意思是，一侧是&lt;code&gt;\w&lt;/code&gt;，另外一侧不是&lt;code&gt;\w&lt;/code&gt;，那么我们就可以用&lt;code&gt;(?&amp;lt;!\w)(?=\w)&lt;/code&gt;来表示单词的起始分解符，用&lt;code&gt;(?&amp;lt;=\w)(?!\w)&lt;/code&gt;来表示单词的结束分界符，那么两则结合起来，&lt;code&gt;(?&amp;lt;!\w)(?=\w)|(?&amp;lt;=\w)(?!\w)&lt;/code&gt;就等价于&lt;code&gt;\b&lt;/code&gt;。当然如果语言本身支持&lt;code&gt;\b&lt;/code&gt;就不要多此一举了，&lt;code&gt;\b&lt;/code&gt;简洁效率又高。&lt;/p&gt;
&lt;p&gt;补充一点，刚才我们给数字加逗点中，保证了结尾不是其他字符，那么像&lt;code&gt;23456323s&lt;/code&gt;是匹配不到的，使用了&lt;code&gt;$&lt;/code&gt;，千万要理解清楚，去掉&lt;code&gt;$&lt;/code&gt;后将会是这样子，图片中匹配到的灰色位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/912458/201801/912458-20180126104524959-892498704.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了匹配&lt;code&gt;23456323s&lt;/code&gt;，其实这里只需要结尾不是数字就可以了。我们使用简记法&lt;code&gt;\d&lt;/code&gt;来匹配数字，那么尾部不是数字就可以使用&lt;code&gt;(?!\d)&lt;/code&gt;来表示了，所以最终的正则可以这样写&lt;code&gt;(?&amp;lt;=\d)(?=(?:\d\d\d)+(?!\d))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里强调一点，非数字，我们可能会想到&lt;code&gt;\D&lt;/code&gt;，&lt;code&gt;\D&lt;/code&gt;的意思是，“匹配一个不是数字的字符”，而这个字符是必须的，假如正好处于行尾，没有任何字符，是匹配不到的。上一篇中我们已经强调过这一点。&lt;/p&gt;
&lt;p&gt;环视类型中，顺序和逆序所获取的支持十分有限（使用也不广泛），顺序比逆序早出现几年，尽管Perl支持两着，其他语言就难说了，所以接下来我们不使用逆序环视来解决给数值添加逗号问题。&lt;code&gt;(\d)(?=(?:\d\d\d)+(?!\d))&lt;/code&gt;左侧使用捕获型括号，替换文本只需要在逗号前面加上&lt;code&gt;$1&lt;/code&gt;即可，也就是&lt;code&gt;$1,&lt;/code&gt;，同样到达了我们预期的效果。&lt;/p&gt;
&lt;p&gt;更多实例，可以参考《Mastering Regular Expressions》第三版，里面使用Perl语言，举了诸多实例，有兴趣的朋友可以参考下，当然也可以参考中文翻译版本《精通正则表达式》。希望本篇文章可以帮组你更好的掌握正则。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 02:59:00 +0000</pubDate>
<dc:creator>YourSimple</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chao8888/p/8352476.html</dc:identifier>
</item>
<item>
<title>授人以渔不如授人以鱼 - HOYU_Z</title>
<link>http://www.cnblogs.com/hoyu/p/8358524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoyu/p/8358524.html</guid>
<description>&lt;p&gt;&lt;span&gt;标题写成这样我自然没有写错，原话是：授人以鱼不如授人以渔。两个字的颠倒，意思却千差万别。而我想说的是，我信奉&quot;授人以渔不如授人以鱼&quot;，并且我相信生活中有很多都是这么做的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/856591/201801/856591-20180126105913584-1315442376.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;授人以渔的故事有很多，比如：《还珠格格》中，紫薇一行人遇到小偷刘辉，在得知刘辉的具体情况后紫薇决定将阳春面的做法交给他，最后还叫皇阿玛题了字还给了银两。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于刘辉来说有了生产技术和启动资金，还有政府的题字倡导，开一家阳春面馆应该不是什么难事，但这绝对不是紫薇一行人的倾囊相授。对于紫薇一行人来说开一家阳春面馆难度几乎等于零。以他们的物力，财力，权利，完全可以送刘辉一个美食城，做一个轻松的掌柜，而不是每天从日出忙到日落换得一点点辛苦钱。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实这样的事情在生活中也比比皆是，发达地区总是喜欢把淘汰的技术输出到欠发达地区，最先进的东西永远掌握在有主权的人手中。其实这没什么不对，物竞天择，适者生存 ，不顾一切的生存是我们的天性，帮助别人，让别人也有一点生存技能是我们的人性。人性本就高于天性，但是由于自己的人性助长了他人的天性，最后得到反噬也算是自食其果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而我在工作生活中，就真真切切的感受到了有时候自己的倾囊相授并不一定能体现出自己拥有多么高尚的品行和道德。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我是一名程序猿（外包），平时喜欢研究一些和行业相关的东东（我并不油腻），在上一家公司的最后阶段充分感受到人的天性，说到底就是人心不光险恶还隔着肚皮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/856591/201801/856591-20180126105913897-452338550.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的任务是为这家公司的新项目完成起步阶段，眼看项目已经能正常运行，这意味着离开的时候到了。被客户公司留下是最理想的结果，因为工作环境相对熟悉，薪资待遇方面也会比在外包公司高出几个档次。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在离开工作环境的前一段时间，我和经理约了个饭，饭桌上我表露了想留在公司的想法，经理也一直嘬着嘴里的食物点头，嗯嗯嗯。最后叫我放心，说应该没什么问题。其实经理在公司工作的时间并没有我长，他刚开始来的时候基本也算是小白，遇到什么问题尽我所能帮其解决，告诉他所有业务流程还有要注意的问题，加班这种事情也是随叫随到。也算是&quot;授人以渔&quot;吧。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不就之后我们所有外包人员接到了要撤场的通知，信心满满的我以为留下来这件事已经是板上钉钉的事情，也就没有和经理太多提及。撤场的前一个星期，我被安排出差，出差回来之后接到的结果让我愤怒到想毁掉眼前的一切。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;结果留下了另外一个人，我则需要继续我的外包生活。过了一段时间之后，我才得知客户公司大领导当时对我的印象是非常不错的，只是在最后阶段由于我不在公司就和别的同事聊了这件事。不谈能力，我和那个同事之间确实显得我比较张扬，比较难以控制，所以在现在的公司我也时刻提醒自己谨慎做事，低调做人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键时刻被出差这件事，我已经释怀，毕竟领导都喜欢会干活的&quot;笨蛋&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/856591/201801/856591-20180126105914225-1390205942.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以如果我和要被帮助的人都生活在同一片湖旁，我也用小木船打鱼，那授人以鱼就好。如果我已经做到机械化规模化，那么把用小木船打鱼的方式作为&quot;渔&quot;传授给他就好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;谨以此文，纪念我丢失的几十个衣架和钱包。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 02:59:00 +0000</pubDate>
<dc:creator>HOYU_Z</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoyu/p/8358524.html</dc:identifier>
</item>
</channel>
</rss>