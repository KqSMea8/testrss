<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[深度学习]实现一个博弈型的AI，从五子棋开始（1） - xerwin</title>
<link>http://www.cnblogs.com/erwin/p/7828956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erwin/p/7828956.html</guid>
<description>&lt;p&gt;好久没有写过博客了，多久，大概8年？？？最近重新把写作这事儿捡起来……最近在折腾AI，写个AI相关的给团队的小伙伴们看吧。&lt;/p&gt;

&lt;p&gt;搞了这么多年的机器学习，从分类到聚类，从朴素贝叶斯到SVM，从神经网络到深度学习，各种神秘的项目里用了无数次，但是感觉干的各种事情离我们生活还是太远了。最近AlphaGo Zero的发布，深度学习又火了一把，小伙伴们按捺不住内心的躁动，要搞一个游戏AI，好吧，那就从规则简单、老少皆宜的五子棋开始讲起。&lt;/p&gt;

&lt;p&gt;好了，废话就说这么多，下面进入第一讲，实现一个五子棋。&lt;/p&gt;

&lt;p&gt;小伙伴：此处省去吐槽一万字，说好的讲深度学习，怎么开始扯实现一个五子棋程序了，大哥你不按套路出牌啊……&lt;/p&gt;
&lt;p&gt;我：工欲善其事必先利其器，要实现五子棋的AI，连棋都没有，AI个锤子！&lt;/p&gt;
&lt;p&gt;老罗：什么事？&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;五子棋分为有禁手和无禁手，我们先实现一个普通版本的无禁手版本作为例子，因为这个不影响我们实现一个AI。补充说明一下，无禁手黑棋必胜，经过比赛和各种研究，人们逐渐知道了这个事实就开始想办法来限制黑棋先手优势。于是出现了有禁手规则，规定黑棋不能下三三，四四和长连。但随着比赛的结果的研究的继续进行，发现其实即使是对黑棋有禁手限制，还是不能阻止黑棋开局必胜的事实，像直指开局中花月，山月，云月，溪月，寒星等，斜指开局中的名月，浦月，恒星，峡月，岚月都是黑棋必胜。于是日本人继续提出了交换和换打的思想，到了后来发展成了国际比赛中三手交换和五手二打规则，防止执黑者下出必胜开局或者在第五手下出必胜打。所以结论是，在不正规的比赛规则或者无禁手情况下，黑棋必胜是存在的。&lt;/p&gt;

&lt;p&gt;（1）五子棋下棋逻辑实现&lt;/p&gt;
&lt;p&gt;这里用Python来实现，因为之后的机器学习库也是Python的，方便一点。&lt;/p&gt;
&lt;p&gt;界面和逻辑要分开，解耦合，这个是毋庸置疑的，并且之后还要训练AI，分离这是必须的。所以我们先来实现一个五子棋的逻辑。&lt;/p&gt;
&lt;p&gt;我们先来考虑五子棋是一个15*15的棋盘，棋盘上的每一个交叉点（或格子）上一共会有3种状态：空白、黑棋、白棋，所以先建个文件 consts.py&lt;/p&gt;
&lt;p&gt;做如下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum

N &lt;/span&gt;= 15

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChessboardState(Enum):
    EMPTY &lt;/span&gt;=&lt;span&gt; 0
    BLACK &lt;/span&gt;= 1&lt;span&gt;
    WHITE &lt;/span&gt;= 2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;棋盘的状态，我们先用一个15*15的二维数组chessMap来表示，建一个类 gobang.py&lt;/p&gt;
&lt;p&gt;currentI、currentJ、currentState 分别表示当前这步着棋的坐标和颜色，再定义一个get和set函数，最基本的框架就出来了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; consts &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoBang(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt; = [[ChessboardState.EMPTY &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N)] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(N)]
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessMap(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessboard_state(self, i, j):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_chessboard_state(self, i, j, state):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt;[i][j] =&lt;span&gt; state
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; =&lt;span&gt; i
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; =&lt;span&gt; j
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; = state
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样界面端可以调用get函数来获取各个格子的状态来决定是否绘制棋子，以及绘制什么样的棋子；每次下棋的时候呢，在对应的格子上，通过坐标来设置棋盘Map的状态。&lt;/p&gt;
&lt;p&gt;所以最基本的展示和下棋，上面的逻辑就够了，接下来干什么呢，得考虑每次下棋之后，set了对应格子的状态，是不是需要判断当前有没有获胜。所以还需要再加两个函数来干这个事情，思路就是从当前位置从东、南、西、北、东南、西南、西北、东北8个方向，4根轴，看是否有连续的大于5颗相同颜色的棋子出现。假设我们目前落子在棋盘正中，需要判断的位置如下图所示的米字形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17518/201711/17518-20171113225927046-1792416204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那代码怎么写呢，最最笨的办法，按照字面意思来翻译咯，比如横轴，先看当前位置左边有多少颗连续同色的，再看右边有多少颗连续同色的，左边加右边，就是当前横轴上的连续数，如果大于5，则胜利。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, current_i, current_j):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;

        temp &lt;/span&gt;=&lt;span&gt; ChessboardState.EMPTY

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-左&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往左 from (current_j - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-右&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往右 from (current_j + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以此类推，再看竖轴、再看左斜、再看又斜，于是，have_five函数变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, current_i, current_j):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;
        vcount &lt;/span&gt;= 1&lt;span&gt;
        lbhcount &lt;/span&gt;= 1&lt;span&gt;
        rbhcount &lt;/span&gt;= 1&lt;span&gt;

        temp &lt;/span&gt;=&lt;span&gt; ChessboardState.EMPTY

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-左&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往左 from (current_j - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-右&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往右 from (current_j + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(current_i - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from (current_i - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][current_j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            vcount &lt;/span&gt;= vcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(current_i + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from (current_i + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][current_j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            vcount &lt;/span&gt;= vcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; vcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i - 1, -1, -1), range(current_j - 1, -1, -1&lt;span&gt;)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            lbhcount &lt;/span&gt;= lbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i + 1, N), range(current_j + 1&lt;span&gt;, N)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            lbhcount &lt;/span&gt;= lbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; lbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;RB-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i - 1, -1, -1), range(current_j + 1&lt;span&gt;, N)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            rbhcount &lt;/span&gt;= rbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;RB-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i + 1, N), range(current_j - 1, -1, -1&lt;span&gt;)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            rbhcount &lt;/span&gt;= rbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; rbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样是不是就写完了，五子棋的逻辑全部实现~ &lt;/p&gt;
&lt;p&gt;NO，别高兴得太早，我想说，我好恶心，上面那个代码，简直丑爆了，再看一眼，重复的写了这么多for，这么多if，这么多重复的代码块，让我先去吐会儿……&lt;/p&gt;
&lt;p&gt;好了，想想办法怎么改，至少分了4根轴，是重复的对不对，然后每根轴分别从正负两个方向去统计，最后加起来，两个方向，也是重复的对不对。&lt;/p&gt;
&lt;p&gt;于是我们能不能只写一个方向的代码，分别调2次，然后4根轴，分别再调4次，2*4=8，一共8行代码搞定试试。&lt;/p&gt;
&lt;p&gt;因为有45°和135°这两根斜轴的存在，所以方向上应该分别从x和y两个轴来控制正负，于是可以这样，先写一个函数，按照方向来统计：&lt;/p&gt;
&lt;p&gt;xdirection=0,ydirection=1       表示从y轴正向数；&lt;/p&gt;
&lt;p&gt;xdirection=0,ydirection=-1     表示从y轴负向数；&lt;/p&gt;
&lt;p&gt;xdirection=1,ydirection=1       表示从45°斜轴正向数；&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;不一一列举了，再加上边界条件的判断，于是有了以下函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_on_direction(self, i, j, xdirection, ydirection, color):
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; step &lt;span&gt;in&lt;/span&gt; range(1, 5): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;除当前位置外,朝对应方向再看4步&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; xdirection != 0 &lt;span&gt;and&lt;/span&gt; (j + xdirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; j + xdirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ydirection != 0 &lt;span&gt;and&lt;/span&gt; (i + ydirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; i + ydirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;[i + ydirection * step][j + xdirection * step] ==&lt;span&gt; color:
                count &lt;/span&gt;+= 1
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是乎，前面的have_five稍微长的好看了一点，可以变成这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;
        vcount &lt;/span&gt;= 1&lt;span&gt;
        lbhcount &lt;/span&gt;= 1&lt;span&gt;
        rbhcount &lt;/span&gt;= 1&lt;span&gt;

        hcount &lt;/span&gt;+= self.count_on_direction(i, j, -1&lt;span&gt;, 0, color)
        hcount &lt;/span&gt;+= self.count_on_direction(i, j, 1&lt;span&gt;, 0, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        vcount &lt;/span&gt;+= self.count_on_direction(i, j, 0, -1&lt;span&gt;, color)
        vcount &lt;/span&gt;+= self.count_on_direction(i, j, 0, 1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; vcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        lbhcount &lt;/span&gt;+= self.count_on_direction(i, j, -1, 1&lt;span&gt;, color)
        lbhcount &lt;/span&gt;+= self.count_on_direction(i, j, 1, -1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; lbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        rbhcount &lt;/span&gt;+= self.count_on_direction(i, j, -1, -1&lt;span&gt;, color)
        rbhcount &lt;/span&gt;+= self.count_on_direction(i, j, 1, 1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还是一大排重复的代码呀，我还是觉得它丑啊，我真的不是处女座，但是这个函数是真丑啊，能不能让它再帅一点，当然可以，4个重复块再收成一个函数，循环调4次，是不是可以，好，就这么干，于是have_five就又漂亮了一点点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        directions = [[(-1, 0), (1&lt;span&gt;, 0)], \
                      [(0, &lt;/span&gt;-1), (0, 1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, 1), (1, -1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, -1), (1, 1&lt;span&gt;)]]

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; axis &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directions:
            axis_count &lt;/span&gt;= 1
            &lt;span&gt;for&lt;/span&gt; (xdirection, ydirection) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; axis:
                axis_count &lt;/span&gt;+=&lt;span&gt; self.count_on_direction(i, j, xdirection, ydirection, color)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; axis_count &amp;gt;= 5&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;嗯，感觉好多了，这下判断是否有5颗相同颜色棋子的逻辑也有了，再加一个函数来给界面层返回结果，逻辑部分的代码就差不多了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chess_result(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.have_five(self.&lt;span&gt;__currentI&lt;/span&gt;, self.&lt;span&gt;__currentJ&lt;/span&gt;, self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__currentState&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ChessboardState.EMPTY
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是，五子棋逻辑代码就写完了，完整代码 gobang.py 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; consts &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoBang(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt; = [[ChessboardState.EMPTY &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N)] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(N)]
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessMap(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessboard_state(self, i, j):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_chessboard_state(self, i, j, state):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt;[i][j] =&lt;span&gt; state
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; =&lt;span&gt; i
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; =&lt;span&gt; j
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; state

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chess_result(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.have_five(self.&lt;span&gt;__currentI&lt;/span&gt;, self.&lt;span&gt;__currentJ&lt;/span&gt;, self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__currentState&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_on_direction(self, i, j, xdirection, ydirection, color):
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; step &lt;span&gt;in&lt;/span&gt; range(1, 5): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;除当前位置外,朝对应方向再看4步&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; xdirection != 0 &lt;span&gt;and&lt;/span&gt; (j + xdirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; j + xdirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ydirection != 0 &lt;span&gt;and&lt;/span&gt; (i + ydirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; i + ydirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;[i + ydirection * step][j + xdirection * step] ==&lt;span&gt; color:
                count &lt;/span&gt;+= 1
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        directions = [[(-1, 0), (1&lt;span&gt;, 0)], \
                      [(0, &lt;/span&gt;-1), (0, 1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, 1), (1, -1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, -1), (1, 1&lt;span&gt;)]]

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; axis &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directions:
            axis_count &lt;/span&gt;= 1
            &lt;span&gt;for&lt;/span&gt; (xdirection, ydirection) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; axis:
                axis_count &lt;/span&gt;+=&lt;span&gt; self.count_on_direction(i, j, xdirection, ydirection, color)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; axis_count &amp;gt;= 5&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;背景音：大哥，憋了半天，就憋出这么不到60行代码？&lt;/p&gt;
&lt;p&gt;我：代码不再多，实现则灵……&lt;/p&gt;

&lt;p&gt;明天来给它加个render，前端界面就有了，就是一个简单的完整游戏了，至于AI，别急嘛。&lt;/p&gt;
&lt;p&gt;好吧，就这样…&lt;/p&gt;

</description>
<pubDate>Mon, 13 Nov 2017 15:41:00 +0000</pubDate>
<dc:creator>xerwin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erwin/p/7828956.html</dc:identifier>
</item>
<item>
<title>【深度学习笔记】（一）TensorFlow安装及环境搭建 - 狼.wrz</title>
<link>http://www.cnblogs.com/wolfray/p/7828903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wolfray/p/7828903.html</guid>
<description>&lt;p&gt;在学习了一段时间台大李宏毅关于deep learning的课程，以及一些其他机器学习的书之后，终于打算开始动手进行一些实践了。&lt;/p&gt;
&lt;p&gt;感觉保完研之后散养状态下，学习效率太低了，于是便想白天学习，晚上对白天学习的知识做一些总结和记录，如果有不妥的地方，欢迎大家批评指教，共同进步。&lt;/p&gt;
&lt;h2 id=&quot;一深度学习框架的选择&quot;&gt;一、深度学习框架的选择&lt;/h2&gt;
&lt;p&gt;随着深度学习日趋火热，技术的逐渐兴起，各种深度学习框架也层出不穷。&lt;/p&gt;
&lt;p&gt;目前使用普遍的框架有Tensorflow、Caffe、PyTorch、Theano、CNTK等，那么在这么多框架中该如何选择呢？&lt;/p&gt;
&lt;p&gt;笔者作为一个初学者，架不住Tensorflow的名气之大，所以最开始便选择了Tensorflow。当然不仅仅只是因为名气大，Tensorflow作为谷歌主持的开源项目，它的社区热度目前看来是旺盛的，而且现在也最为流行。听说，它是在谷歌总结了DistBelief的经验教训上形成的；它运行高效、可扩展性强，可以运行在手机、普通电脑、计算机群上。&lt;/p&gt;
&lt;p&gt;下面再简单介绍一下其他深度学习框架的特点：&lt;/p&gt;
&lt;p&gt;（1） Caffe：卷积神经网络框架，专注于卷积神经网络和图像处理，因为是基于C++语言，所以执行速度非常的快。&lt;/p&gt;
&lt;p&gt;（2） PyTorch：动态computation graph！！！（笔者学习Tensorflow一段后，便会转学PyTorch试试看）&lt;/p&gt;
&lt;p&gt;（3） Theano：因其定义复杂模型很容易，在研究中比较流行。&lt;/p&gt;
&lt;p&gt;（4） CNTK：微软开发的，微软称其在语音和图像识别方面比其他框架更有优势。不过代码只支持C++.&lt;/p&gt;
&lt;p&gt;Tensorflow的一些特性就不再说了，网络上相关资料也有很多。&lt;/p&gt;
&lt;p&gt;下面就介绍一下Tensorflow的安装，笔者的安装顺序是首先安装Anaconda、然后安装Tensorflow、再安装Pycharm。&lt;/p&gt;
&lt;h2 id=&quot;二安装anaconda&quot;&gt;二、安装Anaconda&lt;/h2&gt;
&lt;p&gt;安装环境：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000041876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;机器配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然笔者用的是mac，自带了Python，但是还是先安装了Anaconda（&lt;a href=&quot;https://www.anaconda.com&quot; target=&quot;_blank&quot;&gt;点击进入官网&lt;/a&gt;）。因为它集成了很多Python的第三方库，而且可以方便的管理不同版本的Python，在不同版本的Python之间切换。而且Anaconda是一个科学计算环境，在电脑上安装完Anaconda之后，除了相当于安装了Python，也安装好了一些常用的库。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000649978?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;安装好Anaconda&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者安装的是Python 2.7版的Anaconda，在安装好Anaconda之后，就已经安装好了Python和一些常用的库了。此外，还自动安装了Spyder。&lt;/p&gt;
&lt;p&gt;Spyder是Python一个简单的集成开发环境，和其他的Python开发环境相比，它最大的优点就是模仿MATLAB的“工作空间”的功能，可以很方便地观察和修改数组的值。&lt;/p&gt;
&lt;p&gt;在终端中输入Spyder就可以打开它了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125532906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125541910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是笔者更喜欢使用Pycharm作为开发环境&lt;/p&gt;
&lt;h2 id=&quot;三建立激活安装tensorflow&quot;&gt;三、建立、激活、安装Tensorflow&lt;/h2&gt;
&lt;p&gt;打开终端，在上面输入：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs fix&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;conda create -n tensorflow python&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;2.7&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000845300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;建立Tensorflow运行环境&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后等执行完毕之后，再执行：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; activate tensorflow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此就激活了运行环境。&lt;/p&gt;
&lt;p&gt;然后再执行&lt;code&gt;pip install tensorflow&lt;/code&gt;以进行Tensorflow的安装。&lt;/p&gt;
&lt;p&gt;然后再执行以下Hello Tensorflow代码测试Tensorflow是否安装成&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs livecodeserver&quot;&gt;import tensorflow &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; tf
hello = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello Tensorflow!'&lt;/span&gt;)
sess = tf.Session()
print(sess.run(hello))

&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
b = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;)
printf(sess.run(&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt;+b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果正常的话会提示：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs erlang-repl&quot;&gt;    &lt;span class=&quot;hljs-variable&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;Tensorflow&lt;/span&gt;&lt;span class=&quot;hljs-exclamation_mark&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四pycharm-ide&quot;&gt;四、PyCharm IDE&lt;/h2&gt;
&lt;p&gt;一直使用终端开发的话，实在是太过难用了。笔者选择了PyCharm作为开发环境，&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot; target=&quot;_blank&quot;&gt;官网链接&lt;/a&gt;。这里笔者用的是社区版（free）。&lt;/p&gt;
&lt;p&gt;（1）首先新建一个Pycharm的工程&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125912459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;Pycharm新建工程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是做Tensorflow的开发，所以这里我们只需要选择图中所示的interpreter即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~/anaconda2/envs/tensorflow/bin/python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就把Tensorflow环境包括了进来，超级方便。&lt;/p&gt;
&lt;p&gt;如果平时开发，想用一些轻量级的环境，就选择其他Python解释器就可以了。&lt;/p&gt;
&lt;p&gt;（2）运行一个demo进行测试&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs livecodeserver&quot;&gt;import tensorflow &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; tf
hello = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello, Tensorflow!'&lt;/span&gt;)
sess = tf.Session()
print(sess.run(hello))

&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt;)
b = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;88&lt;/span&gt;)
print(sess.run(&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; + b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110130742447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现以下提示，就说明成功了，可以开始接下来的学习了~&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs erlang-repl&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;Hello&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;Tensorflow&lt;/span&gt;&lt;span class=&quot;hljs-exclamation_mark&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;154&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;至此，我们便在机器上安装好了Tensorflow以及其开发环境。&lt;/p&gt;
&lt;p&gt;总的来说，只需要以下几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Anaconda&lt;/li&gt;
&lt;li&gt;通过conda建立Tensorflow运行环境&lt;/li&gt;
&lt;li&gt;激活Tensorflow运行环境&lt;/li&gt;
&lt;li&gt;安装Pycharm IDE&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 13 Nov 2017 15:38:00 +0000</pubDate>
<dc:creator>狼.wrz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wolfray/p/7828903.html</dc:identifier>
</item>
<item>
<title>python爬虫(一)_爬虫原理和数据抓取 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/7828889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/7828889.html</guid>
<description>&lt;blockquote readability=&quot;3.8461538461538&quot;&gt;
&lt;p&gt;本篇将开始介绍Python原理，更多内容请参考：&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/7828889.html&quot;&gt;Python学习指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要做爬虫&quot;&gt;为什么要做爬虫&lt;/h3&gt;
&lt;p&gt;著名的革命家、思想家、政治家、战略家、社会改革的主要领导人物马云曾经在2015年提到由IT转到DT，何谓DT，DT即数据技术，由数据在推倒人们的衣食住行，当今时代是一个&lt;code&gt;大数据时代&lt;/code&gt;，数据从何而来？&lt;/p&gt;
&lt;h3 id=&quot;爬虫是什么&quot;&gt;爬虫是什么？&lt;/h3&gt;
&lt;p&gt;百度百科：&lt;a href=&quot;http://baike.baidu.com/link?url=3SeA6RcStie6o9T5XGMTBoHK-BGiO_0IqtnI4IkVjDBsoKrJL0aotjA4cjqbx8wF&quot;&gt;网络爬虫&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Python爬虫，我们需要学习的有：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Python基础语法学习(基础知识)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;HTML页面的内容抓取(数据抓取)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;HTML页面的数据提取(数据清洗)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Scrapy框架以及scrapy-redis分布式策略(第三方框架)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争。。。。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;通用爬虫和聚焦爬虫&quot;&gt;通用爬虫和聚焦爬虫&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;网络爬虫可分为&lt;strong&gt;通用爬虫&lt;/strong&gt;和&lt;strong&gt;聚焦爬虫&lt;/strong&gt;两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;通用搜索引擎(Search Enging)工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用网络爬虫&lt;/strong&gt; 从互联网中搜集网页，采集信息，这些网页信息用于为搜索引擎建立索引从而提供支持，它决定着整个引擎系统的内容是否丰富，信息是否及时，因此其性能的优劣直接影响着搜索引擎的效果。&lt;/p&gt;
&lt;h4 id=&quot;第一步抓取网页&quot;&gt;第一步：抓取网页&lt;/h4&gt;
&lt;p&gt;搜索引擎网络爬虫的基本工作流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先选取一部分的种子URL，将这些URL放入待抓取URL队列；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;取出待抓取URL，解析DNS得到主机的IP，并将URL对应的网页下载下来，存储进已下载网页库中，并且将这些URL放进已抓取URL队列。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;分析已抓取URL队列中的URL，分析其中的其它URL，并且将URL放入待抓取URL队列，从而进入下一个循环。。。&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/python%E7%88%AC%E8%99%AB_%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;通用爬虫流程&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;搜索引擎如何获取一个新网站的URL：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新网站向搜索引擎主动提交网址：(百度：&lt;a href=&quot;http://zhanzhang.baidu.com/linksubmit/url&quot; class=&quot;uri&quot;&gt;http://zhanzhang.baidu.com/linksubmit/url&lt;/a&gt;)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在其他网站上设置一个新网站链接(尽可能处于搜索引擎爬虫爬取范围)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;搜索引擎和DNS解析服务商(如DNSPod等)合作，新网站域名将被迅速抓取&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是搜索引擎蜘蛛的爬行是被输入了一定的规则的，它需要遵从一些命令或文件的内容，如标注为&lt;code&gt;nofollow&lt;/code&gt;的链接，或者是Robots协议。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6529968454259&quot;&gt;
&lt;p&gt;Robots协议(也叫爬虫协议、机器人协议等)，全称是“网络爬虫排除标准”(Robots Exclusion Protocol)，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;淘宝网：&lt;a href=&quot;https://www.taobao.com/robots.txt&quot; class=&quot;uri&quot;&gt;https://www.taobao.com/robots.txt&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;腾讯网：&lt;a href=&quot;http://www.qq.com/robots.txt&quot; class=&quot;uri&quot;&gt;http://www.qq.com/robots.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;第二步数据存储&quot;&gt;第二步：数据存储&lt;/h4&gt;
&lt;p&gt;搜索引擎通过爬虫爬取到网页，将数据存入原始页面数据库。其中的页面数据与用户浏览器得到的HTML是完全一样的。&lt;/p&gt;
&lt;p&gt;搜索引擎蜘蛛在抓取页面时，也做一定的重复内容检测，一旦遇到访问权重很低的网站上有大量抄袭、采集或者复制的内容，很可能就不再爬行。&lt;/p&gt;
&lt;h4 id=&quot;第三步预处理&quot;&gt;第三步：预处理&lt;/h4&gt;
&lt;p&gt;搜索引擎将爬虫抓取回来的页面，进行各种步骤的预处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取文字&lt;/li&gt;
&lt;li&gt;中文分词&lt;/li&gt;
&lt;li&gt;消除噪音(比如版权申明文字、导航条、广告等...)&lt;/li&gt;
&lt;li&gt;索引处理&lt;/li&gt;
&lt;li&gt;链接关系计算&lt;/li&gt;
&lt;li&gt;特殊文件处理&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了HTML文件外，搜索引擎还能抓取和索引以文字为基础的多种文件类型，如PDF、WORD、WPS、PPT、TXT等。我们在搜索结果中也经常会看到这种文件类型。&lt;/p&gt;
&lt;p&gt;但搜索引擎还不能处理图片、视频、Flash这类非文字内容，也不能执行脚本和程序。&lt;/p&gt;
&lt;h4 id=&quot;第四步提供检索服务网站排名&quot;&gt;第四步：提供检索服务，网站排名&lt;/h4&gt;
&lt;p&gt;搜索引擎在对信息进行组织和处理后，为用户提供关键字检索服务，将用户检索相关的信息展示给用户。&lt;/p&gt;
&lt;p&gt;同时会根据页面的PageRank值（链接的访问量排名）来进行网站排名，这样Rank值高的网站在搜索结果中会排名较前，当然也可以直接使用 Money 购买搜索引擎网站排名，简单粗暴。&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&quot; alt=&quot;搜索引擎工作原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;但是，这些通用搜索引擎也存在着一定的局限性&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通用搜索引擎所返回的结果都是网页，而大多情况下，网页里90%的内容对用户来说都是无用的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不同领域、不同背景的用户往往具有不同的检索目的和需求，搜索引擎无法提供针对具体某个用户的搜索结果。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;万维网数据形式的丰富和网络技术的不断发展，图片、数据库、音频、视频多媒体等不同数据大量出现，通用搜索引擎对这些文件无能为力，不能很好地发现和获取。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通用搜索引擎大多提供基于关键字的检索，难以支持根据语义信息提出的查询，无法准确理解用户的具体需求。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;针对这些情况，聚焦爬虫技术得以广泛使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;聚焦爬虫&quot;&gt;聚焦爬虫&lt;/h3&gt;
&lt;p&gt;聚焦爬虫，是&quot;面向特定主题需求&quot;的一种网络爬虫程序，它与通用搜索引擎爬虫的区别在于： &lt;em&gt;聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页信息。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/7828889.html</dc:identifier>
</item>
<item>
<title>android 人脸检测你一定会遇到的坑 - 喝着啤酒敲代码</title>
<link>http://www.cnblogs.com/cq-jiang/p/7823462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cq-jiang/p/7823462.html</guid>
<description>&lt;p&gt;      笔者今年做了一个和人脸有关的android产品，主要是获取摄像头返回的预览数据流，判断该数据流是否包含了人脸，有人脸时显示摄像头预览框，无人脸时摄像头预览框隐藏，看上去这个功能并不复杂，其实在开发过程中，遇到的问题也不多，全部都处理了，在正式推出前，这个产品在公司内部也测试了几个月，也没发现bug，但最近实施人员，在客户公司做实施时，反馈回来各种问题，这些问题有部分是程序bug,也有一部分是和硬件有关，因为测试环境有限，笔者无法对各种型号，各个厂家的硬件进行测试，这篇文章主要是记录，摄像头给我们带来的一些坑，分享给涉及到人脸开发的朋友，让大家少走弯路。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;android有原生的api做人脸检测，通过android.media.FaceDetector来检测bitmap是否包含人脸，android.media.FaceDetector.Face来检测人脸位置信息，我们需要在activity中实现Carema.PreviewCallBack接口，该接口有一个&lt;span&gt;onPreviewFrame方法，这个方法返回摄像头实时图像的数据流，由于这个方法返回的数据流时nv21格式，我们需要转换bitmap才能进行人脸检测，转换过程如下：byte[] --&amp;gt; YuvImage --&amp;gt; ByteArrayOutputStream --&amp;gt; byte[] --&amp;gt;  bitmap ，具体转换的代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
Camera.Size size =&lt;span&gt; mtCamera.getParameters().getPreviewSize();
YuvImage yuvImage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; YuvImage(mData, ImageFormat.NV21, size.width, size.height, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
yuvImage.compressToJpeg(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Rect(0, 0, size.width, size.height), 100&lt;span&gt;, mBitmapOutput);
options.inPreferredConfig &lt;/span&gt;=&lt;span&gt; Bitmap.Config.RGB_565;
bitmap &lt;/span&gt;= BitmapFactory.decodeByteArray(mBitmapOutput.toByteArray(), 0&lt;span&gt;, mBitmapOutput.toByteArray().length, options);
mBitmapOutput.reset();
bitmap &lt;/span&gt;= Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), mMatrix, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的转换，我们已经得到了人脸检测的bitmap,此时只需要进行人脸检测就ok了，代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
detector = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FaceDetector(source.getWidth(),source.getHeight(), maxFaceNum);
Face[] faces &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Face[maxFaceNum];&lt;br/&gt;detector.findFaces(source, faces);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码基本上就哪么多，由于受到硬件的影响，上面的代码有很多地雷。&lt;/p&gt;

&lt;p&gt;　　产品上线后，主要问题有，人站在摄像头面前，app无法识别人脸，软件运行性能也会下降，出现严重卡顿等问题，当前我比较郁闷，明明在测试环境都运行几个月了，都没有出现这些问题，正式实施的时候，问题不断，通过近两个月的整理，主要问题有以下几个。&lt;/p&gt;
&lt;h2&gt;　　2.1   无法识别人脸&lt;/h2&gt;
&lt;h3&gt;　　1）：相机角度问题&lt;/h3&gt;
&lt;p&gt;　　由于我在测试的时候，摄像头图像是垂直的，没有任何问题，但正式使用时，摄像头来自不同商家，导致摄像头图像是水平的了，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171112231108231-854272111.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;336&quot;/&gt;                               &lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171112231129325-271491698.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图像角度都不对了，当然无法识别人脸了，此时我们需要得到摄像头的默认旋转的角度，再作处理，特别声明：&lt;span&gt;&lt;strong&gt;setDisplayOrientation() 这个方法是逆时针旋转&lt;/strong&gt;&lt;/span&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCameraDisplayOrientation (Activity activity, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cameraId, android.hardware.Camera camera) {
        android.hardware.Camera.CameraInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; android.hardware.Camera.CameraInfo();
        android.hardware.Camera.getCameraInfo (cameraId , info);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rotation =&lt;span&gt; activity.getWindowManager ().getDefaultDisplay ().getRotation ();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; degrees = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (rotation) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_0:
                degrees &lt;/span&gt;= 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_90:
                degrees &lt;/span&gt;= 90&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_180:
                degrees &lt;/span&gt;= 180&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_270:
                degrees &lt;/span&gt;= 270&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info.facing ==&lt;span&gt; Camera.CameraInfo.CAMERA_FACING_FRONT) {
            result &lt;/span&gt;= (info.orientation + degrees) % 360&lt;span&gt;;
            result &lt;/span&gt;= (360 - result) % 360;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; compensate the mirror&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; back-facing&lt;/span&gt;
            result = ( info.orientation - degrees + 360) % 360&lt;span&gt;;
        }
        mOrienta &lt;/span&gt;=&lt;span&gt; result;//该值有其它用途
        camera.setDisplayOrientation (result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　2）：相机设置旋转后，预览图片和相机返回实时流角度问题&lt;/h3&gt;
&lt;p&gt;　　这个坑太恶心了，当我把相机角度旋转后，把app打包发一个给同事，结果同事告诉我，还是不行，还好在公司借到一个锐士达1080p的摄像头，然后我把&lt;strong&gt;onPreviewFrame返回的流画到imageView&lt;/strong&gt;，&lt;strong&gt;发现返回的图像，和预览的图像，根本不一样，我勒个去，虽然预览图像旋转了，我们还需要对onPreviewFrame返回的流进行处理&lt;/strong&gt;，这个坑也让我比较无语，害我找了好久。虽然说解决的代码只有简短的几句，但找出原因过程只有自己能体会，然后我使用Matrix来旋转onPreviewFrame返回的流，关于Matrix，完全是参考&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/flash129/article/details/8234599&quot; target=&quot;_blank&quot;&gt;android Matrix详细&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，这篇文章写得非常好，然而&lt;strong&gt;&lt;span&gt;matrix的postRotate是顺时针旋转，和camera.setDisplayOrientation()刚好相反&lt;/span&gt;，&lt;/strong&gt;我勒个去，这两个难兄难弟太不让人省心，一个顺时针，一个逆时针，超级无语,修改后的代码如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113214240718-1518249012.png&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
//mOrienta来源于setCameraDisplayOrientation
&lt;/pre&gt;
&lt;pre&gt;
mMatrix = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Matrix();
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (mOrienta){
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  90&lt;span&gt;:
                        mMatrix.postRotate(&lt;/span&gt;270&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 270&lt;span&gt;:
                        mMatrix.postRotate(&lt;/span&gt;90&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        mMatrix.postRotate(mOrienta);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　2.2   720p摄像头和1080p摄像头涉及到的问题&lt;/h2&gt;
&lt;h3&gt;　　1）：获取摄像头支持预览尺寸遇到的问题&lt;/h3&gt;
&lt;p&gt;　　　　　初始化相机时，我们需要设置摄像头支持的预览尺寸，如果不是相机支持的尺寸，会出现异常，根据项目需要，本地环境我直接指定一个下标，然后硬件变化后，这个值也跟着变了，如下图：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113214853406-1298168028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处根据实际情况获取，可以计算每一个尺寸的面积，通过一个基础面积获取适应的预览尺寸。具体代码就不帖了，只需要清楚有这一个坑就ok了。&lt;/p&gt;
&lt;h3&gt;　　2）：获取预览侦宽高大小带来的问题&lt;/h3&gt;
&lt;p&gt;　　如果程序的lock，和线程问题没处理好，性能问题显而易见。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113215339999-877905015.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　如果只是简单的识别人脸，我们可以通过压缩图片的方法来解决这个问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
BitmapFactory.Options options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapFactory.Options();
options.inSampleSize &lt;/span&gt;=2&lt;span&gt;;
options.inPreferredConfig &lt;/span&gt;=&lt;span&gt; Bitmap.Config.RGB_565;
bitmap &lt;/span&gt;= BitmapFactory.decodeByteArray(mBitmapOutput.toByteArray(), 0, mBitmapOutput.toByteArray().length, options);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3)：摄像头返回的流频率过快，导致人脸识别处理速度根不上的解决办法&lt;/h3&gt;
&lt;p&gt;　　最初软件运行的时候，运行一段时间，app直接崩溃了，最后发现是，onPreviewFrame返回的流太快，网上说可以在启动相机时，设置流的频率,常见设置的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Camera.Parameters parameters =&lt;span&gt; mCamera.getParameters();
parameters.setPreviewFrameRate(&lt;/span&gt;3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每秒3帧,没有效果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而这样设置后，完全没有用，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113220550827-928002324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理这个问题并不是很复杂，只是判断一个两次处理流的时候，大于300毫秒（具体时间，根据需求变动）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onPreviewFrame(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data, Camera camera) {
        Logger.i(TAG&lt;/span&gt;+&quot;收到相机回调：onpreviewframe()&quot;+&lt;span&gt;index);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;data.length&amp;gt;0&amp;amp;&amp;amp;System.currentTimeMillis()-time&amp;gt;200&lt;span&gt;){
            time&lt;/span&gt;=&lt;span&gt;System.currentTimeMillis();
            mFaceHandle.post(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FaceThread(data,camera,(++&lt;span&gt;index)));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　2.3 刷脸的人员走开后，屏幕仍然显示和人脸相关信息 &lt;/h2&gt;
&lt;p&gt; 　　通过以上描述我们知道，相机预览图尺寸过大，导致刷脸人员走开几秒钟内，android设备屏，仍然显示和人脸有关的信息，因为onPreviewFrame频率较快，而处理人脸的时间过长，导致人脸对列越来越大，所以人走开后，屏才会显示相关信息，这里需要控制，onPreviewFrame处理人脸的频率大于，以及提升人脸识别的时间.&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;a href=&quot;https://github.com/jlq023/democamera&quot; target=&quot;_blank&quot;&gt; 完整demo 下载地址:https://github.com/jlq023/democamera&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 13 Nov 2017 15:26:00 +0000</pubDate>
<dc:creator>喝着啤酒敲代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cq-jiang/p/7823462.html</dc:identifier>
</item>
<item>
<title>作为初级管理者必会的方法论和分析法 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/7764665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/7764665.html</guid>
<description>&lt;p&gt;　　最近都不怎么写些接地气的东西，因为拿捏不准哪些地方会涉及到信息安全。另外，如果我决定哪个地方的代码要自己写，那么可以肯定凌晨3点多，我还在公司。作为一个其实技术还不怎么精通的初级管理者，目前更大局的视角来看一些东西要比编程这些务实的东西更急迫。&lt;/p&gt;
&lt;p&gt;      我现在的领导是清华才子。经常发现人家看事情确实明白。虽然我当年高考的分数是可以考上北大医学部的，当然只是那年比较特殊，非典时期，北京的学校比较不吃香。但是从看事情的维度方面，确实看到了自己的差距。觉得凭自己的实际能力，考不上清华北大是应该的。现在得到高人指点，我家小鲜肉麻省理工还是有希望的。&lt;/p&gt;
&lt;p&gt;　　5w1h&lt;/p&gt;
&lt;p&gt;　　5w1h分析法也叫六何分析法，是一种思考方法。是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。&lt;/p&gt;
&lt;p&gt;　　四象限理论&lt;/p&gt;
&lt;p&gt;　　四象限法则是时间管理理论的一个重要观念是应有重点地把主要的精力和时间集中地放在处理那些重要但不紧急的工作上，这样可以做到未雨绸缪，防患于未然。在人们的日常工作中，很多时候往往有机会去很好地计划和完成一件事。但常常却又没有及时地去做，随着时间的推移，造成工作质量的下降。因此，应把主要的精力有重点地放在重要但不紧急这个“象限”的事务上是必要的。要把精力主要放在重要但不紧急的事务处理上，需要很好地安排时间。一个好的方法是建立预约。建立了预约，自己的时间才不会被别人所占据，从而有效地开展工作。&lt;/p&gt;
&lt;p&gt;     通俗一点说吧，四象限就是：象限1：紧急重要、象限2：重要不紧急、象限3：紧急不重要、象限4：不重要不紧急。如果在总体事情比较多的情况下，总是将象限3的事情优先于象限2，则事情会越来越多，重要的事情反而没做。&lt;/p&gt;
&lt;p&gt;　　漏斗分析法&lt;/p&gt;
&lt;p&gt;　　漏斗分析通俗的说：我要将事情按照一个维度统一的记录下来，再看转化率。比如说：我记录日志，比如一个请求其实需要经过多个部门的处理。在请求的每一步，我都需要记录下来请求、响应。由于网络等原因。每一步得到结果的响应率都不是百分之百。那么最后得到实际结果的响应率究竟是多少。&lt;/p&gt;
&lt;p&gt;      STAR法则&lt;/p&gt;
&lt;p&gt;      这是一个面试官常使用的工具。&lt;/p&gt;
&lt;p&gt;　　STAR法则,即为Situation Task Action Result的缩写，具体含义是:&lt;/p&gt;
&lt;p&gt;　　Situation: 事情是在什么情况下发生&lt;/p&gt;
&lt;p&gt;　　Task: 你是如何明确你的任务的&lt;/p&gt;
&lt;p&gt;　　Action: 针对这样的情况分析，你采用了什么行动方式&lt;/p&gt;
&lt;p&gt;　　Result: 结果怎样，在这样的情况下你学习到了什么&lt;/p&gt;
&lt;p&gt;　　简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。&lt;/p&gt;

&lt;p&gt;跑题时间：&lt;/p&gt;
&lt;p&gt;　　11月的天，阴冷。男神说：“开空调呗”。就像10点多下班我宁愿坐地铁不打车一样，我不喜欢开空调。不管是加氟的还是无氟的。就像不含铅的爆米花一样，只不过是用其他大家不太怎么听说的毒性更大的东西来代替。而保护环境节约资源这些，对我来说，就好像是在减缓发生的一些物理化学反应。比如呼吸生成二氧化氮、比如水烧开沸腾。其实在我们看不到的维度，别人在等着水更快的烧开。只是物理化学变化的完成，也是人类使命的完成，意味着人类的消亡。所以我自己不愿意做一些事情，但我不反对别人做一些事情。也许他们才是推动这个世界发展的动力，推动了下一个文明的到来。或者是长久的寂静的到来，就像是篝火化成了灰。&lt;/p&gt;
&lt;p&gt;　　年初的时候有一次我在面试，面试官让我写代码，我是第一次有人当场让我写代码。听着隔壁面试间的女孩子在那里侃着那些虚无的东西，我竟然一边写代码一边朝自己笑笑。我明明可以像其他女孩子一样，做些自己擅长的事情，却要让自己一次次的受煎熬，然后再走出来。&lt;/p&gt;
&lt;p&gt;      自从来了这边，见不到我家微微一笑很倾城的男神老大之后，越来越不会笑了。在公司天天面对一群管我叫姐的小鲜肉，生无可恋。最难忍受的是还有走路不长眼睛，见了我叫阿姨的。我只能怒视她们，姐姐们，你们长得比我还显老好不好。实在觉得活不下去了，就发给微信给我家微微一笑很倾城的男神老大，看到老大的消息，立刻觉得可以活下去了。&lt;/p&gt;
&lt;p&gt;      但是自从我家男神要换个离我近的工作，一想到天天可以回家睡，一睁眼左边一个帅哥右边一个帅哥，脸上又可以孩子般天真的笑了。但是在家睡觉我会经常失眠。失眠的原因是：我睡着睡着一睁眼看到我家小鲜肉，越看越觉得这小家伙太可爱了，实在是太可爱了。想着想着就激动的睡不着了。&lt;/p&gt;


</description>
<pubDate>Mon, 13 Nov 2017 15:25:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/7764665.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET Identity与授权 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7828326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7828326.html</guid>
<description>&lt;p&gt;　　一个完整的ASP.NET的请求中会存在身份验证（Authentication）阶段以及授权（Authorization）阶段，英文单词Authentication和Authorization非常相似，所以很多时候会混淆这两个概念。身份验证（Authentication）的目的是知道“你”是谁，而授权（Authorization）则是当“你”访问一个资源时是否符合访问条件，符合就将访问权限授权给你进行访问，否则拒绝访问。&lt;/p&gt;
&lt;p&gt;　　本文将从以下几点介绍ASP.NET MVC如何使用Identity完成资源访问的限制：&lt;br/&gt;　　● 资源访问的限制方式&lt;br/&gt;　　● ASP.NET中的访问限制&lt;br/&gt;　　● ASP.NET MVC中基的访问限制&lt;br/&gt;　　● ASP.NET MVC中的用户信息&lt;br/&gt;　　● ASP.NET Identity用户身份信息填充&lt;br/&gt;　　● ASP.NET MVC访问限制的实现&lt;br/&gt;　　● ASP.NET MVC基于用户声明的访问限制及自定义限制&lt;/p&gt;
&lt;h2&gt;资源访问的限制方式&lt;/h2&gt;
&lt;p&gt;　　什么是资源？在Web中通过URI(Uniform Resource Identifier，统一资源标识符)来对HTML文档、图片、图像等内容定位，反过来说在Web中HTML文档、图片、图像等内容就是资源，而资源访问的限制就是对在用户通过URI访问Web资源时，判断该用户是否有权限访问该资源，如果有则继续访问，否则拒绝访问。&lt;br/&gt;　　资源访问有以下几种限制方式：&lt;br/&gt;　　● 匿名访问限制：所有人都可以访问资源。&lt;br/&gt;　　● 根据用户名访问限制：指定特定的用户，让其能够或者不能访问资源。&lt;br/&gt;　　● 根据用户角色访问限制：指定特定角色，让拥有该角色的用户能够访问资源。&lt;br/&gt;　　● 根据用户声明(Claim)访问限制：指定特定的声明(Claim)，让身份信息中含有该声明的用户能够访问资源。&lt;br/&gt;　　● 使用其它用户信息进行访问限制：根据用户身份的其它信息来判断用户是否能够访问资源。&lt;br/&gt;　　从上面几点可以看出资源访问的限制或者说授权，实际上就是通过用户信息来判断用户是否有访问资源的权限，而常用的信息是用户名、用户角色以及用户声明。&lt;br/&gt;　　注：对于授权来说，它处于身份验证的后续阶段，所以可以认为在授权阶段时已经存在用户信息，所以可以直接使用用户信息来完成访问限制。&lt;/p&gt;
&lt;h2&gt;ASP.NET中的访问限制&lt;/h2&gt;
&lt;p&gt;　　ASP.NET中通过HTTPModule的方式实现了FileAuthorizationModule以及UrlAuthorizationModule来对用户访问文件以及其它资源进行权限控制，其中UrlAuthorizationModule可以通过在web.config中添加如下配置来通过用户名或者用户角色限制访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113201937390-2141855427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在ASP.NET中可以通过Forms验证+UrlAuthorizationModule来实现用户身份验证和访问授权，更多信息可参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/user-based-authorization-cs&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/user-based-authorization-cs&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中的访问限制&lt;/h2&gt;
&lt;p&gt;　　Forms验证+UrlAuthorizationModule的方式是用于基于ASP.NET Web Form的应用程序，而ASP.NET MVC虽然也可以使用Forms验证，但是ASP.NET MVC的授权方式是不一样的，它是通过过滤器的方式实现，下面代码为之前文章中用于限制后台管理页面需要登录的代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203241937-125088632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过在Controller上使用了一个名为Authorize的特性来实现的，这个特性的定义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203330390-1281206943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它用于当用户访问Controller或Action方法时可以通过用户信息对其访问进行限制。&lt;/p&gt;
&lt;p&gt;　　在Authorize特性的定义中可以看到名为Roles以及Users的属性，其作用就是设置可以访问该资源的用户或者角色：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203414781-783221026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用方法如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203446406-1413577341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中的用户信息&lt;/h2&gt;
&lt;p&gt;　　通过前面的介绍可以知道用户的授权是根据用户信息来的，无论是基于角色的、用户的、声明的甚至是自定义的，都需要依赖用户信息进行权限判断，那么ASP.NET MVC中到底包含什么用户信息？&lt;br/&gt;　　1. HttpContextBase与IPrincipal：&lt;br/&gt;　　首先可以知道的是在ASP.NET中有一个最核心的HTTP上下文对象HttpContextBase，它保存了整个Http请求到响应过程的所有相关数据，其定义如下:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210021874-1935222769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中就包含了一个名为User的IPrincipal类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210105281-946742438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该类型中的Identity属性就包含了用户的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210134093-1598482920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从接口中可以看到它仅仅包含了用户名、身份验证反射以及是否验证通过三个属性。&lt;/p&gt;
&lt;p&gt;　　注：IPrincipal的实现有多种而本例中使用的是ClaimPrincipal。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210742374-389874688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. ClaimsIdentity与AuthenticationTicket：&lt;br/&gt;　　通过前面的文章分析得知Identity基于Cookie的身份验证方式实际上是对一个AuthenticationTicket对象序列化加密、反序列化解密的过程，而这个AuthenticationTicket就携带了所有用户的信息，在AuthenticationTicket的定义中可以看到两个重要的对象，其中AuthenticationProperties保存了身份验证的会话信息，如过期时间、是否允许刷新等。而另一个ClaimsIdentity属性就是以声明(Claim)的方式实现的用户信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210835952-1012054741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ClaimsIdentity的部分定义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210907859-1432140731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中除了实现IIdentity接口的属性外，还有一个重要的属性是Claims，它用于以声明的方式来保存用户信息，那么Identity是如何完成用户数据填充的？&lt;/p&gt;
&lt;h2&gt;ASP.NET Identity用户身份信息填充&lt;/h2&gt;
&lt;p&gt;　　用户的获取填充主要是在&lt;span&gt;用户登录&lt;/span&gt;(注册用户后会自动登录)的时候完成的，因为在后续的请求中Identity仅需通过解析加密后的用户信息字符串即可获得用户信息(注：会存在重新生成刷新该信息的情况，如身份信息的滑动过期等)。&lt;/p&gt;
&lt;p&gt;　　通过前面文章的分析知道了在Identity中用户的登录是通过SignInManager对象完成的以下是用户登录的代码及注册代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211047562-1935415140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以下是注册代码，实际上是创建完成用户后执行了登录操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211112421-1074508610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：通过对源码分析，SignInManager.PasswordSignInAsync方法实际上最后也是调用SignInAsync方法完成的登录。&lt;/p&gt;
&lt;p&gt;　　那么SignInAsync到底做了什么？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211314312-1832097033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从代码中可以看到，该方法调用了一个名为CreateUserIdentityAsync的方法，根据其方法名、参数以及返回值类型来看就已经可以确定该方法就是通过用户对象生成上面提到的用于以声明的方式保存用户信息的方法。从它的实现中可以看出它实际上是通过UserManager生成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211350874-191777440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而UserManager又是通过ClaimsIdentityFactory完成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211638249-1702392986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ClaimsIdentityFactory.CreateAsync方法的实现：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211713968-981992321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：实际上身份信息的刷新也是通过UserManager完成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113230104671-1890811288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方法的实现仍然是UserManager的CreateIdentityAsync方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113230142843-1343788056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从实现中可以看出如果UserManager支持角色、声明等功能，它会从数据库中加载对应的信息以声明(Claim)的形式保存在ClaimsIdentity对象中。&lt;br/&gt;　　在数据库中添加以下数据(为了演示功能直接在数据库中添加角色、声明信息并与用户数据进行关联，如果要开发此功能可基于UserManager完成)：&lt;br/&gt;　　角色信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211845452-877358865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户声明(Claim)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211917109-495552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　角色与用户信息关联：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211947421-871904732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：由于此处Identity EF与MySQL，对象与表映射存在问题，所以多了一些ID列，暂时不管这个问题，关于Identity与MySQL用法可以参考这篇文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/aspnet-identity-using-mysql-storage-with-an-entityframework-mysql-provider&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/aspnet-identity-using-mysql-storage-with-an-entityframework-mysql-provider&lt;/a&gt;&lt;br/&gt;　　运行程序并登录后，在用户信息(ClaimsIdentity)中可找到添加的角色和声明信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212047781-1103509072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC访问限制的实现&lt;/h2&gt;
&lt;p&gt;　　上面介绍了用户信息的填充，那么访问的限制实际上就是对用户信息比较而已，下面是Authorize特性的核心方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212223109-742291940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中核心的三个判断为：&lt;br/&gt;　　● user.Identity.IsAuthenticated：必须通过身份验证。&lt;br/&gt;　　● (this._usersSplit.Length &amp;lt;= 0 || this._usersSplit.Contains(user.Identity.Name, StringComparer.OrdinalIgnoreCase))：特性没有指定用户或者当前用户存在于指定的用户列表中。&lt;br/&gt;　　● (this._rolesSplit.Length &amp;lt;= 0 || this._rolesSplit.Any(new Func&amp;lt;string, bool&amp;gt;(user.IsInRole))：特性没有指定角色或者当前用户拥有指定的角色。&lt;br/&gt;　　以上三个条件必须全部符合才能够访问。&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC基于用户声明的访问限制及自定义访问限制&lt;/h2&gt;
&lt;p&gt;　　ASP.NET MVC中虽然用户信息是基于声明的方式保存的，但是却没有实际的实现，所以需要自己动手实现一个(注：也可以参考ASP.NET Core中的实现&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims&lt;/a&gt;)。&lt;br/&gt;　　实现一个自定义的授权特性(注：之前分析过HttpContext中的User是一个IPrincipal类型，实际上MVC使用的是与ClaimsIdentity对应的ClaimsPrincipal)代码如下，该过滤器只是在原有的授权方式基础上添加了声明的检查：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212346281-1814198935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用方式如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212407702-1411132765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　登录后访问上面action得到下面结果，验证通过：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212446577-913717187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：需要注意的是以上介绍的授权方式，无论是通过角色、用户名还是声明，它都需要以硬编码的形式写在代码中，换句话说就是在开发时必须确定该功能或者Controller/Action访问需求。但是一些时候也会出现访问需求不确定的情况，访问权限的配置会在运行时通过配置文件或者数据库来动态配置，这样的话自定义的授权过滤器就需要依赖一些业务组件来实现自定义的授权流程。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本章介绍了授权与身份验证的关系以及在ASP.NET中的实现，并详细介绍了ASP.NET MVC中的Identity是如何使用身份验证数据来完成授权的。常见的授权方式一般是基于用户名、角色以及声明，但是它们使用的场景边界是不那么明确的，就是说用什么都行实际情况需要根据需求来看，一般权限控制较简单的使用基于角色的授权即可。但无论基于什么来对用户授权，这些信息都属于用户信息，所以在拓展用户的授权时首先要考虑的是用户的特征信息，其次是用户身份验证时如何获取填充这些信息，最后才是考虑如何使用这些信息来进行授权。&lt;/p&gt;
&lt;p&gt;参考：　　&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wce3kxhd.aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/wce3kxhd.aspx&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/21645323/what-is-the-claims-in-asp-net-identity&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/21645323/what-is-the-claims-in-asp-net-identity&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/98950/ASP-NET-authentication-and-authorization&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/98950/ASP-NET-authentication-and-authorization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET Identity与授权&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7828326.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7828326.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 15:09:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7828326.html</dc:identifier>
</item>
<item>
<title>css伪类的说明以及使用(css事件) - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/7670959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/7670959.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;CSS伪类的使用(css事件)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;转载请注明源地址:&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: css伪类的说明以及使用(css事件)&quot; href=&quot;http://www.cnblogs.com/funnyzpc/p/7670959.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/funnyzpc/p/7670959.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　之前有开发开发App的时候，有同事问我那个列表的条目按下去背景会变成淡黄色的效果是怎么做的，然后我若无其事的说了句：用CSS事件啊。。。╮(￣▽￣)╭，然后同事不解的回到座位后在代码中狂找...🤔，嗯~最终效果实现与否就不得而知啦~；最近稍仔细的翻翻相关文章才知道类似于JavaScript中的事件的东西叫做“伪类”，是CSS中特有的一种东西ヽ(^o^)丿，大多时候很少很少用到，这个叫做“&lt;span&gt;&lt;strong&gt;伪类&lt;/strong&gt;&lt;/span&gt;”的东东一般只有html的标签用到，很简单，。。。但，因为简单，所以要实现稍微复杂的功能还是依靠JavaScript哈~，嗯哼，先放张图把，到底什么是“伪类”，看过之后瞬间秒懂~ (｡♥‿♥｡)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113202242577-1926503806.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看完，我来先小小地总结下，CSS伪类在每一代CSS标准中都会扩充一些，由于暂时用得最多的大致有以下五个(只是对于我来说哈~（￣。。￣）)：&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;伪类&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;伪类描述&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:active&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;点按，向被激活的元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:focus&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;焦点输入，向拥有键盘输入焦点的元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:hover&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当鼠标悬浮在元素上方时，向元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:link&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;链接未访问，向未被访问的链接添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:visited&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;链接已访问，向已被访问的链接添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　要使用这些伪类的话，样式该怎么写呢，。。。以下举个🌰例子，比如说&lt;span&gt;&lt;strong&gt;:focus&lt;/strong&gt;&lt;/span&gt; --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; 这是一个输入框：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;999&quot;&lt;/span&gt;&lt;span&gt; nameo&lt;/span&gt;&lt;span&gt;=&quot;textInput&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;这是对输入框定义的默认CSS：
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;.body .input{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    width:100px;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    height:40px;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    border-radius: 13px;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;这是对输入框“获取焦点”后应用的CSS:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;.body .input:focus{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    background-color:mediumpurple;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;真实的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（默认样式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215515937-43987149.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;126&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（获取焦点后的样式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img alt=&quot;&quot;/&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215538437-57992333.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;124&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看完是不是超级简单，有木有~；这几需要说明几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;&lt;strong&gt;A&amp;gt;&lt;/strong&gt;以上可以只对输入框定义一个获取焦点后的(:focus)样式，就可以看出效果啦，遂，在开发的时候如果不是特别复杂的样式效果，切勿轻易动用JavaScript来控制dom的样式　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;B&amp;gt;&lt;/strong&gt;大多浏览器对于直接调试带有伪类的样式较为麻烦，比如Chrome的不同版本可以不会显示dom的伪类样式,建议大家先写成普通样式调试成功后再改回dom的伪类样式,这样较为nice&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;C&amp;gt;&lt;/strong&gt;dom(标签)的所有样式只能定义在样式文件或单独的&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;区域中，不可定义在dom中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些懂了吧~。。。&amp;lt;(￣︶￣)&amp;gt;；以上只是定义了所列举的部分伪类的样式效果，下面把剩余的几种伪类效果也展示下，方便读者参考👇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==&amp;gt;　&lt;span&gt;&lt;strong&gt;　:active&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　(点按之前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　    　&lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215326796-571552935.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;77&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（点按之后）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215426421-1011349755.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;123&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　:hover&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（鼠标位于dom之上前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215635843-2001950246.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;40&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（鼠标未于dom之上后）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215705843-563940130.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;56&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　:link&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（链接未访问）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215757312-2017142436.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;44&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　:visited&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　(链接未访问前)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215855062-1613750432.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;49&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　(链接已访问)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215927843-1958472188.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　OK👌，既已明白，我也该睡觉觉~\(≧▽≦)/~啦啦啦，现在是：2017-11-13 22:10:15&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;梦游中：&lt;/span&gt;啊~哈~~，明天又是工作日，真美好的一天😊 ( &lt;span&gt;明天迟到，看我怎么收拾你😡&lt;/span&gt; )&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 Nov 2017 14:19:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/7670959.html</dc:identifier>
</item>
<item>
<title>老板的两分钱 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/7828396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/7828396.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/815275/201711/815275-20171113214103921-2114254846.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近读到一篇英语文章，名叫 《Don’t add your 2 cents》，初一看对这个标题有些困惑，心想这是什么意思啊？后来读完文章内容，不仅学会了一个新的英语习惯用语，还收获一个很有启发的故事。&lt;/p&gt;
&lt;h2 id=&quot;原意&quot;&gt;原意&lt;/h2&gt;
&lt;p&gt;先来了解下这个习惯用语的背景。&lt;/p&gt;
&lt;p&gt;在维基百科的解释里 &quot;My two cents&quot; 或者说它的完整版 &quot;Put my two cents in&quot; 是一个美语的习惯表达，它用在表达一个人的试探性建议场景下。大概表达的感觉就是，我的建议或意见也就值两分钱，微不足道，你听听就可以了，以表明建议者的礼貌与谦卑，以期减少这种有争议的意见对被建议人的心理冲击。&lt;/p&gt;
&lt;p&gt;放在中文语境下，大概就是这样一些表达：“以我之浅见，你也许这样会...我有一些不同的看法，说出来大家参考参考...”，都是表达一种小心翼翼提出不同意见的方式。&lt;/p&gt;
&lt;p&gt;这本是一种让人更容易接受建议的语言技巧，但对于不同角色的人，特别是像老板这样的角色，其效果也许就变了味。&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;
&lt;p&gt;我们看看公司里常见的一种方案汇报或评审场景，老板也许会参与其中。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;员工：&lt;br/&gt;过去几周我们已经做了大量调研和设计，完成了我们新的某某方案...啪啦啪啦讲一堆，最后大家看看还有什么建议或意见。&lt;/p&gt;
&lt;p&gt;其他人：&lt;br/&gt;象征性的提点意见，最后大家都等着听老板的意见或者说拍板。&lt;/p&gt;
&lt;p&gt;老板：&lt;br/&gt;恩，不错，我喜欢。你们的工作做得很好，但是我觉着这里，这里，这里还可以这样、这样...完善修改下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再具体完善下这个场景，假如我们汇报或评审的是一个产品方案，老板也许会说：思路不错，但可以再参考下某个竞品的某某细节。再尝试下某种新的方向探索。如果是一个设计方案，老板也许会说：整体感觉不错，也许这个字体可以再大一点，那边的红色可以再浅一点，等等。&lt;/p&gt;
&lt;p&gt;如果是技术方案呢？恩，产品和设计方案一般可以靠常识性知识来判断，但技术方案不是，它需要专门的知识，所以技术方案老板就很少参与。但就怕老板是有技术背景的，好多年前也是做技术的。&lt;/p&gt;
&lt;p&gt;所有这些意见或建议，其实就是 “老板的两分钱”，老板也和任何人一样，不过是在尝试表达一些自己不成熟的浅见，以期作为参考。但是因为老板的角色不同于其他人，他的 “两分钱” 容易被员工解读成命令，需要被高效执行，使命必达。&lt;/p&gt;
&lt;p&gt;最后，老板的 “两分钱” 也许无意间就被放大成了团队的 “好几万”。&lt;/p&gt;
&lt;h2 id=&quot;反思&quot;&gt;反思&lt;/h2&gt;
&lt;p&gt;从意见本身来说，老板的意见并不一定优于任何人的，毕竟老板也不是万能的，区分只是身份。&lt;/p&gt;
&lt;p&gt;如果有朝一日你成了老板，你的意见或看法将不再是仅仅代表个人的意见或看法。在各种正式的汇报或评审会上，你得小心无意发表你自认为的 “两分钱” 个人意见或看法，但这并不代表老板在这样的场合就无法发表意见了。&lt;/p&gt;
&lt;p&gt;一种更好的适合老板的表达方式，也许是用疑问句来替代陈述句，因为老板的陈述句容易被解读成祈使句。用提问题来代替意见、看法或建议，把自己内心的疑惑与问题抛给原始方案的提出人（团队），他们才是需要去找到答案，执行过程并获得最好结果的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为老板，你不需要对所有事情都给出意见或看法，仅仅是因为你能够。&lt;br/&gt;作为老板，你自己偏好的答案也许并不重要，毕竟术业有专攻。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但如果老板认为自己的意见或看法并不仅仅是 “两分钱”，那就坚决直接的说出来，这就不再是建议而是命令，这就是老板做出的决策，并需要承担决策的成本与后果。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;任何人，也许都可能不是不同层面的老板，不是吗？&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 13:42:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/7828396.html</dc:identifier>
</item>
<item>
<title>Celery 源码解析三： Task 对象的实现 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/implement-of-Task.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/implement-of-Task.html</guid>
<description>&lt;p&gt;Task 的实现在 Celery 中你会发现有两处，一处位于 &lt;strong&gt;celery/app/task.py&lt;/strong&gt;，这是第一个；第二个位于 &lt;strong&gt;celery/task/base.py&lt;/strong&gt; 中，这是第二个。他们之间是有关系的，你可以认为第一个是对外暴露的接口，而第二个是具体的实现！所以，我们由简入繁，先来看看对外的接口：&lt;/p&gt;
&lt;p&gt;其实这就是个我们声明 Task 的对象，例如我们使用这么一段代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210551749-1887837925.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;我们可以看看 add 对象是啥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [1]: add
Out[1]: &amp;lt;@task: worker.add of tasks:0x10c9b06d0&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现其实他就是我们的一个 Task 对象，所以你就可以观察一下我们平时使用这个 add 的形式在里面是如何实现的了，例如我们最常使用的可能就两种方式了，分别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [2]: add.delay()
In [3]: add.apply_async()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他你看一下源码就会发现他们的实现是一样的，就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210551921-379723682.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;我们现在很清楚，调用 &lt;code&gt;apply_async&lt;/code&gt; 是将我们的 Task 提交到 MQ 中，然后获得一个 &lt;strong&gt;celery.result.AsyncResult&lt;/strong&gt; 对象，那么具体都做了哪些工作，还是需要进一步查看的。&lt;code&gt;apply_async&lt;/code&gt; 的参数有很多，所以我们需要先给他归个类，这样就好看多了，概括着看，可以分为这么几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AMQP 类：connection、queue、exchange、routing_key、producer、publisher、headers&lt;/li&gt;
&lt;li&gt;MQ 策略类：countdown、eta、expires、retry、retry_policy、priority、&lt;/li&gt;
&lt;li&gt;管理类：shadow、serializer、compression、add_to_parent&lt;/li&gt;
&lt;li&gt;其他：args、kwargs、link、link_error、&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样一看就感觉一目了然多了，AMQP 类的我们就不关注了，毕竟都看了这么多了，应该大家都熟悉了。这里的主要关注点还是在 MQ 策略类和管理类上，着重在 MQ 策略类上，因为管理类的功能稍微比较简单一些。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;async 发送消息&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;apply_async&lt;/code&gt; 中，我们可以看到有两处执行逻辑，第一处是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210551906-1229903930.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里是直接调用 &lt;code&gt;apply&lt;/code&gt;，然后这里的条件 &lt;code&gt;task_always_eager&lt;/code&gt; 是什么意思我们还没见过，可以看一下文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552015-107510417.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，了解，其实就是说这是个同步的接口，那么我们就可以对应着看到下面这处应该是异步的实现咯：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210551843-607560395.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;既然如此，我们一个个得来看。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;同步发送消息实现&lt;/h3&gt;
&lt;p&gt;同步执行消息的一层函数比较简单，只是简单的构建了一个 tracer，然后就从 tracer 调用中拿到调用结果，我们看上去会比较舒服：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210551999-370680782.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;但是，这个 tracer 的内容就复杂啦，但是这个 &lt;code&gt;build_tracer&lt;/code&gt; 的构建函数不需要太过关注，所以我们需要关注的是 &lt;code&gt;build_tracer&lt;/code&gt; 返回的这个 &lt;code&gt;tracer&lt;/code&gt; 函数，但是这个函数的内容很多，为了简约一下，所以给大家抽象了一番。同步调用过程中，可以分为几部分功能，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;信号处理：执行前/后/成功这几个时刻需要释放一些信号给感兴趣的成员&lt;/li&gt;
&lt;li&gt;失败处理：对于没有执行的情况需要进行细分处理，例如：reject/ignore/retry/exception 等&lt;/li&gt;
&lt;li&gt;依赖处理：因为 Celery 支持一些简单的依赖，所以执行完成之后需要执行被依赖的 tasks&lt;/li&gt;
&lt;li&gt;执行逻辑：这个就是正常的函数调用咯&lt;/li&gt;
&lt;li&gt;其他：例如统计执行时间，出入栈之类的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;@TODO：Q：这里 task 的 callbacks 是什么意思&lt;/p&gt;
&lt;p&gt;我们就看下任务的执行逻辑是怎么样的，在代码里面是很简单的一个函数调用，其实就是看 Task 对象有没有实现 &lt;code&gt;__call__&lt;/code&gt; 方法，如果没有就使用 &lt;code&gt;run&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552077-1128325559.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;那 task 的 &lt;code&gt;__call__&lt;/code&gt; 实现也不是太复杂，其实最后调用的也是 &lt;code&gt;run&lt;/code&gt; 方法，所以到最后都还是 &lt;code&gt;run&lt;/code&gt; 方法的责任啦，但是，这里的基类是不实现 &lt;code&gt;run&lt;/code&gt; 方法的，所以这个实现就落实到具体的实现类中了，那么你以为 &lt;code&gt;run&lt;/code&gt; 方法会在 &lt;strong&gt;celery/app/base.py&lt;/strong&gt; 中实现？我之前也是这么想的，但是，后来我发现不是的，这个实现其实就是我们在代码里面使用 &lt;code&gt;@app.task&lt;/code&gt; 装饰的函数，其实就是讲我们自定义的函数封装成 &lt;code&gt;run&lt;/code&gt;，这样调用 &lt;code&gt;run&lt;/code&gt; 不就执行的我们的函数了吗？有意思吧，这个封装的方式我们后面再说，也就是说同步的方式我们就到此吧，也差不多了。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;异步发送消息实现&lt;/h3&gt;
&lt;p&gt;看完同步的我们再来看看异步的，在说异步的之前，我们先思考一下，异步的应该是怎样？之前看的时候我猜想异步不就是把 Task 对象塞进 MQ 中么，就应该是这么简单，但是，看完之后发现还是 too young 了，因为从同步中我们就可以看出，还是有很多功课要完成的，不管怎样，一起来再看一遍。&lt;/p&gt;
&lt;p&gt;从前边我们说有同步和异步两种形式那里我们可以发现同步和异步的除了功能不一样之外，还有调用的对象也不一样，同步的是调用 Task 自己的方法，也就是说消息被 Task 自己消化了；而异步的确实使用的 Celery 对象的方法，也就是说还得依赖于 Celery 这个 Boss 来实现。这是为啥呢？很明显嘛，Task 自身没有关于 MQ 的任何消息，而只有一个绑定的 Celery 对象，所以从抽象层面就只能交给 Celery 了，而 Celery 却包含了所有你需要的信息，是可以完成这个任务的。&lt;/p&gt;
&lt;p&gt;所以，异步的消息到了 Celery 是这么被发出去的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552202-793694075.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里出现了一个我们还没怎么接触过的 &lt;code&gt;amqp&lt;/code&gt;，但是没关系，随着等下的了解，我们会认识到它的，这里的几个关键步骤都是通过 &lt;code&gt;amqp&lt;/code&gt; 来完成的，所以我们应该着重看看他们&lt;/p&gt;
&lt;h4 id=&quot;toc_3&quot;&gt;异步消息体的创建&lt;/h4&gt;
&lt;p&gt;在 Celery 中，异步消息体是通过 &lt;code&gt;create_task_message&lt;/code&gt; 来创建的，我们可以发现，这里是传了一大堆参数进去，但是，无妨，对于这些参数，我们大部分都在前面见过了，不怵，主要还是需要关注一下内部都为消息体做了什么工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552296-1634075922.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里可以发现两件事情&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息体的预处理都是在这里完成的，例如检验和转换参数格式&lt;/li&gt;
&lt;li&gt;构建消息就用了四个属性：&lt;code&gt;headers&lt;/code&gt;、&lt;code&gt;properties&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt; 和 &lt;code&gt;sent_event&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里其实就是所有的构建消息体的代码了，为什么呢，因为 task_message 是一个 nametuple：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552218-257106539.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;异步消息的发送&lt;/h4&gt;
&lt;p&gt;异步消息的发送这里不是直接就调用的一个函数，而是动态得创建了一个 sender ，然后才调用这个 sender 发送的（没搞懂为啥，为了扩展？）。而创建 sender 的逻辑倒是比较简单，所以忽略了，直接来看真正的 send 操作是如何完成的，其实之前提过了，这里真正的 send 操作就像之前我们看同步的执行逻辑一样尿性，又臭又长，真的，又臭又长，而且作者自己都加注释承认了，他的理由是为了性能！&lt;/p&gt;
&lt;p&gt;同样得，为了方便我们的理解，我还是采用抽丝剥茧的方式来给大家介绍一下，首先，我习惯性得分个类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MQ 的各项功能：routing_key/exchange/delivery_mode/retry&lt;/li&gt;
&lt;li&gt;任务执行的前后处理：发送前/发送后&lt;/li&gt;
&lt;li&gt;真正的发送逻辑&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实重头戏应该在 MQ 的参数确定上，因为只要这些参数都确定了，消息的发送只是一个 &lt;code&gt;producer.publish&lt;/code&gt; 就解决的事情，所以我们花些精力来看看 MQ 的参数都是怎么决定出来的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;queue_name
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;task.delay&lt;/code&gt; 的时候传的，没传并且也没传 &lt;code&gt;exchange&lt;/code&gt; 那就是 &lt;code&gt;default&lt;/code&gt; 了&lt;/li&gt;
&lt;li&gt;不会出现传了 &lt;code&gt;exchange&lt;/code&gt; 但是不传 &lt;code&gt;queue&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;routing_key
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;task.delay&lt;/code&gt; 的时候传的，没传就看 &lt;code&gt;exchange&lt;/code&gt; 有没有，没有就是 &lt;code&gt;queue&lt;/code&gt; 的值了&lt;/li&gt;
&lt;li&gt;如果参数传了 &lt;code&gt;exchange&lt;/code&gt;，那么就是配置中的默认 &lt;code&gt;routing_key&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;exchange：
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;task.delay&lt;/code&gt; 的时候传的，没传但是 &lt;code&gt;exchange_type&lt;/code&gt; 类型是 &lt;code&gt;direct&lt;/code&gt;，那么就是 &quot;&quot;&lt;/li&gt;
&lt;li&gt;如果类型不是 &lt;code&gt;direct&lt;/code&gt;，那么 queue 有 exchange 就用，没有就使用默认的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;delivery_mode
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;task.delay&lt;/code&gt; 的时候传的，没传就看 queue 里面有没有，有就用&lt;/li&gt;
&lt;li&gt;没有就使用默认的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;retry：
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;task.delay&lt;/code&gt; 的时候传了就用，没传就用默认的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等这些参数确认完之后，就使用这些参数发送了！&lt;/p&gt;
&lt;p&gt;然后这样子就将消息发出去了，等待 Worker 的接收，而 worker 的接受逻辑我们之前已经看到了，其实还是注册的 Consumer 的 &lt;code&gt;on_message&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;附加&lt;/h3&gt;
&lt;p&gt;在前面我们说如何构建异步消息体的时候，对于消息体只是简单的用几个 &lt;code&gt;...&lt;/code&gt; 忽略过，但是，对于整体理解来说，我们不应该忽略他们的实质内容，所以在最后我把他们都罗列出来，前后的会用到的。而且你会发现有点意思的是，对于我们的一个异步调用，&lt;code&gt;task&lt;/code&gt; 名和 &lt;code&gt;id&lt;/code&gt; 都是放在 &lt;code&gt;headers&lt;/code&gt; 里头的，而参数什么的却是放在 &lt;code&gt;body&lt;/code&gt; 里面，在我自己实现的异步 MQ 里面，这些都是放在 &lt;code&gt;body&lt;/code&gt; 里面的，这点我倒是不太欣赏 Celery 的。&lt;/p&gt;
&lt;h4 id=&quot;toc_6&quot;&gt;headers&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552374-1148873859.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;toc_7&quot;&gt;properties&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552343-1323883346.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;toc_8&quot;&gt;body&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552374-1309029459.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;toc_9&quot;&gt;send_event&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171113210552452-1635357389.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 13:06:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/implement-of-Task.html</dc:identifier>
</item>
<item>
<title>npm常用命令及版本号浅析 - 学习会让你青春永驻</title>
<link>http://www.cnblogs.com/blackgan/p/7828047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blackgan/p/7828047.html</guid>
<description>&lt;h3 id=&quot;npm-包管理器的常用命令&quot;&gt;npm 包管理器的常用命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试环境为node&amp;gt;=8.1.3&amp;amp;&amp;amp;npm&amp;gt;=5.0.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1， 首先是安装命令&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;co&quot;&gt;//全局安装&lt;/span&gt;
 npm install 模块名 &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;g
 &lt;span class=&quot;co&quot;&gt;//本地安装&lt;/span&gt;
 npm install 模块名
 &lt;span class=&quot;co&quot;&gt;//一次性安装多个&lt;/span&gt;
 npm install 模块&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; 模块&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; 模块&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; 
 &lt;span class=&quot;co&quot;&gt;//安装开发时依赖包&lt;/span&gt;
 npm install 模块名 &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;dev
 &lt;span class=&quot;co&quot;&gt;//安装运行时依赖包&lt;/span&gt;
 npm install 模块名 &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2， 查看安装的目录&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;co&quot;&gt;//查看项目中模块所在的目录&lt;/span&gt;
 npm root
 &lt;span class=&quot;co&quot;&gt;//查看全局安装的模块所在目录&lt;/span&gt;
 npm root &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;g&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3， 查看npm的所有命令命令&lt;/p&gt;

&lt;p&gt;4，查看某个包的各种属性&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//查看某个包对于各种包的依赖关系&lt;/span&gt;
 npm view 模块名 dependencies&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5，查看包的源文件地址&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;co&quot;&gt;//查看包的源文件地址&lt;/span&gt;
 npm view 模块名 &lt;span class=&quot;va&quot;&gt;repository&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;url&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查看当前模块依赖的node最低版本号&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm view 模块名 engines&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;查看模块的当前版本号&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm view 模块名 version
 &lt;span class=&quot;co&quot;&gt;//需要注意的是查看到的模块版本是该模块再远程仓库的版本号，并不是当前项目中所依赖的版本号。&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;//查看当前项目中应用的某个模块的版本号的命令为&lt;/span&gt;
 npm list 模块名 version&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查看模块的历史版本和当前版本&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm view 模块名 versions&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看一个模块的所有信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm view 模块名&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;7，查看npm使用的所有文件夹&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm help folders&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8，用于更改包内容后进行重建&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm rebuild 模块名&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9，检查包是否已经过时&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;co&quot;&gt;//此命令会列出所有已经过时的包，可以及时进行包的更新&lt;/span&gt;
 npm outdated&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10，更新node模块&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm update 模块名
 &lt;span class=&quot;co&quot;&gt;//当然你也可以update 该模块到指定版本&lt;/span&gt;
 npm update 模块名 @版本号
 &lt;span class=&quot;co&quot;&gt;//如果安装到最新版本可以使用以下命令&lt;/span&gt;
 npm install 模块名@latest 
 
 &lt;span class=&quot;co&quot;&gt;//如果当前的版本号为2.5.1，是没办法进行npm update 模块名 @2.3.1 将模块版本号变为2.3.1的，当然，你可以先uninstall，然后进行install @2.3.1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11，卸载node模块&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm uninstall 模块名&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;12，访问package.json的字段文档&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm help json&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;13，发布一个npm包的时候，需要检验某个包名是否已经存在&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm search 模块名&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;14，npm init：引导你创建一个package.json文件，包括名称、版本、作者这些信息&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;清除npm的缓存&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm cache clean
 &lt;span class=&quot;co&quot;&gt;//慎重使用改命令&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;15, npm root 查看当前包的安装路径，&lt;br/&gt;npm root -g 查看全局的包的安装路径&lt;/p&gt;
&lt;p&gt;16，npm -v 查看npm的版本&lt;/p&gt;
&lt;p&gt;17，查看某个模块的bugs列表界面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm bugs 模块名
 &lt;span class=&quot;co&quot;&gt;//例如运行npm bugs chai则会打开vue仓库的issue，效果如下图&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/npmBugs2.PNG&quot; alt=&quot;npm bugs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;18，打开某个模块的仓库界面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm repo 模块名
 &lt;span class=&quot;co&quot;&gt;//例如运行npm repo vue则会打开vue线上仓库，效果如下图&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/npmRepo.PNG&quot; alt=&quot;npm bugs&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开某个模块的文档&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm docs 模块名
 &lt;span class=&quot;co&quot;&gt;//例如运行npm docs vue则会打开vue的readme.md文档&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开某个模块的主页&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm home 模块名
 &lt;span class=&quot;co&quot;&gt;//例如运行npm home vue则会打开vue模块的主页&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查看当前已经安装的模块&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm list
 &lt;span class=&quot;co&quot;&gt;//当然我们也可以限制输入的模块层级，例如&lt;/span&gt;
 npm list &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;depth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/npmList.PNG&quot; alt=&quot;npm list&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;清除未被使用到的模块&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; &lt;span class=&quot;co&quot;&gt;//有时在我们使用npm list的时候，可能会碰到一些问题，就是有些模块并没有被项目引用使用，我们还是安装了这些模块，那么我们可以一键清除这些没有使用到的模块&lt;/span&gt;
 npm prune&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;版本控制&quot;&gt;版本控制&lt;/h4&gt;
&lt;p&gt;我们使用node开发时，经常需要依赖一些模块，我们进行了下载之后，便一直在该版本的模块环境下进行开发，但是线上的服务器一般都是根据依赖来配置文件，重新下载各个模块，但是保不齐某个模块的版本已经更新了，这时线上的包会更新到最新的版本，但你的代码还是依据老版本来写的，这时可能会产生一些不知名的Bug,&lt;/p&gt;
&lt;p&gt;首先看npm包的版本号的格式X.Y.Z,版本好的格式遵循semver 2.0规范，其中X为主版本号，只有更新了不向下兼容的API时进行修改主版本号，Y为次版本号，当模块增加了向下兼容的功能时进行修改，Z为修订版本号，当模块进行了向下兼容的bug修改后进行修改,这就是“语义化的版本控制”。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;默认情况下，当用--save或者--save-dev安装一个模块时，npm通过脱字符(^)来限定所安装模块的主版本号，而该脱字符对于不同的版本号有不同的更新机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;^1.2.1 代表的更新版本范围为 &amp;gt;=1.2.1 &amp;amp;&amp;amp; &amp;lt; 2.0.0&lt;/li&gt;
&lt;li&gt;^0.2.1 代表的更新版本范围为 &amp;gt;=0.2.1 &amp;amp;&amp;amp; &amp;lt; 0.3.0&lt;/li&gt;
&lt;li&gt;^0.0.2 代表的更新版本范围为 0.0.2（相当于锁定为了0.0.2版本）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对于上述字符的版本控制我们可以来进行一个尝试&quot;&gt;##### 对于上述字符的版本控制，我们可以来进行一个尝试:&lt;/h2&gt;
&lt;p&gt;首先可以看到package.json中对于vuex的版本依赖为^2.3.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version1.PNG&quot; alt=&quot;version1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看以下项目中安装的vuex模块的版本号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version2.PNG&quot; alt=&quot;version2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;果然没错，改版本号为2.3.1，接下来我们看一下vuex的历史版本（npm view vuex versions）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version3.PNG&quot; alt=&quot;version3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到2.3.1-2.5.0之后到了3.0.0，接下来运行npm update vuex,查看以下更新后的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version4.PNG&quot; alt=&quot;version3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们看到更新后的vuex版本号为2.5.0 &amp;lt; 3.0.0,可以验证第一条规范。&lt;/p&gt;
&lt;p&gt;我们再来验证下主版本号为0的版本控制情况，&lt;a href=&quot;mailto:先将当前项目依赖的vuex版本改为@0.6.1版本&quot;&gt;先将当前项目依赖的vuex版本改为@0.6.1版本&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;npm uninstall vuex
&lt;span class=&quot;co&quot;&gt;//卸载vuex成功&lt;/span&gt;
npm install vuex@&lt;span class=&quot;fl&quot;&gt;0.6.1&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save
&lt;span class=&quot;co&quot;&gt;//安装vuex0.6.1版本成功&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version5.PNG&quot; alt=&quot;version5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后更新当前项目中的vuex版本，执行代码 npm update vuex&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://blogpic.blackgan.cn/version6.PNG&quot; alt=&quot;version5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过npm view vuex versions看到vuex的版本历程，在0.6.3之上为0.7.0，所以当使用脱字符(^)来控制版本号时，当主版本号为0，即代表该模块在快速构建中时，更新项目时的版本范围只能更新修订版本号Z。&lt;/p&gt;
&lt;p&gt;对于第三种情况，当主版本和此版本都为0时，代表着该模块处于一个极其不稳定的状态，在执行update时并不会进行版本更新。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;波浪号(~)是限定模块的次要版本，（以下规则测试方法同上，便不一 一测试）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;~1.5.1允许安装版本号大于1.5.1但小于1.6.0版本的模块&lt;/li&gt;
&lt;li&gt;~0.5.1允许安装版本号为0.6.0&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当主版本号/次版本号/修订版本号为X or x or *时，那么update或install是会下载该分支最新的版本号&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(*)跟新或安装模块时会安装&amp;gt;=0.0.0的最新版本&lt;/li&gt;
&lt;li&gt;1.x 表示的更新范围为&amp;gt;=1.0.0&amp;amp;&amp;amp;&amp;lt; 2.0.0&lt;/li&gt;
&lt;li&gt;1.2.x 表示的更新范围为&amp;gt;=1.2.0&amp;amp;&amp;amp;&amp;lt; 1.3.0&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/npm/npm/blob/latest/doc/misc/semver.md&quot;&gt;更多版本规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1，当然我们也可以把项目依赖的包固定在某一个版本，强制大家安装相同的依赖树，如下所示：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; npm install react &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;E
 &lt;span class=&quot;co&quot;&gt;//此命令会将react的版本号进行固定，但是该方式只能控制项目中直接依赖的包的版本，无法控制项目模块中依赖的包的版本号，所以这种方式也无法让不同的使用者得到相同的依赖树。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2，此外我们还可以使用npm shrinkwrap,可以将项目中的模块版本进行精确锁定：&lt;/p&gt;
&lt;p&gt;这时候只需要运行命令 npm shrinkwrap,便会产生一个npm-shrinkwrap.json文件，这个文件保存了所有当前使用的依赖模块的版本：把该文件提交到git仓库中，这样其他人在clone你的项目的时候，执行npm install命令时，npm检测到该文件中的信息会完整的还原出完全相同的依赖树，具体的使用方法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;npm install &lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;save&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;dev react &lt;span class=&quot;co&quot;&gt;//安装react&lt;/span&gt;
npm prune    &lt;span class=&quot;co&quot;&gt;//清除未被使用的模块&lt;/span&gt;
npm shrinkwrap&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;但是使用这种方法，安装一个模块包的方式比较繁琐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3，使用yarn我们也可以得到模块包精确控制的结果&lt;/p&gt;
&lt;p&gt;yarn是一个与npm兼容的node包管理器，使用它安装npm包，会自动在项目目录创建一个yarn.lock文件，该文件包含了当前项目中所安装的依赖包的版本信息，其他人在使用yarn安装项目的依赖包时就可以通过该文件创建一个完全相同的依赖环境。&lt;/p&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt; yarn init  &lt;span class=&quot;co&quot;&gt;//使用yarn创建一个项目&lt;/span&gt;
 yarn add 模块名  &lt;span class=&quot;co&quot;&gt;//使用yarn 安装一个包&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;//还有很多yarn命令&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此外，yarn除了可以自动帮我们锁定依赖包的版本，yarn还在本地缓存已经安装过的包，当再次安装时，直接从本地读取即可。安装速度得到大大提升。但yarn的使用需要整个团队都去使用，还是有一定的成本的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上所述，目前大多数项目中较为简单的使用规范，在项目中依赖各个模块时，对于主版本号和次版本号都为0的不稳定的项目，我们可以使用精确版本（exact）,对于主版本号为0次版本号不为0的模块和主版本号不为0的模块，使用caret Range即脱字符(^)来控制版本。当然，我们也可以对项目依赖模块的版本进行精确锁定。&lt;/p&gt;
&lt;h4 id=&quot;semversemantic-versioning-2.0.0&quot;&gt;&lt;a href=&quot;https://github.com/mojombo/semver/blob/master/semver.md&quot;&gt;SemVer(Semantic Versioning) 2.0.0&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;SemVer是一个对npm包版本进行规范的模块，它对于npm包的版本号有着一系列的规则，以下为摘抄自SemVer 2.0.0中的规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在版本控制环节我们已经说过了，模块的版本号采用X.Y.Z的格式，且都必须为非负的正整数，依次为主版本号、次版本号，修改版本号。&lt;/li&gt;
&lt;li&gt;当规定版本的模块进行发布之后，对于该模块的任何修改，都必须发布新版本。&lt;/li&gt;
&lt;li&gt;主版本号为0.X.Y的模块处于开发阶段，模块并不稳定。&lt;/li&gt;
&lt;li&gt;主版本号在有不向下兼容的API发布时必须修改，在主版本号递增时，次版本号和修订版本号必须重新归零。&lt;/li&gt;
&lt;li&gt;次版本号再有向下兼容的API发布时进行递增修改，在模块中有API被弃用时也必须递增次版本号，当此版本号递增改变时，修订版本号Z必须归零。&lt;/li&gt;
&lt;li&gt;版本的优先级就是各个版本的排序规则，判断版本优先级时，必须把版本号从左至右分为主版本号、此版本号、修订版本号、以及先行版本号来进行比较&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 13 Nov 2017 12:47:00 +0000</pubDate>
<dc:creator>学习会让你青春永驻</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blackgan/p/7828047.html</dc:identifier>
</item>
</channel>
</rss>