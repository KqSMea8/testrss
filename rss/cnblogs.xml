<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>启动物联网项目所需的一切：关于流处理 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9039271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9039271.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本文中，我们将围绕物联网或流处理系统的一些技术问题建立完整的基础和多方面的理解，以便读者在规划物联网系统时能够做出明智的决策或是有根据地提出问题。我们的意图是为开始考虑流处理和物联网的人们建立多方面的基础，不管你是否真的需要一个流处理器，我们都将深入到流处理（物联网的核心）里面，然后讨论 Lambda 架构，并给出一些对传感器可以做什么的大致上的思考。&lt;/p&gt;

&lt;p&gt;事件流处理平台就像把瑞士军刀，你可以让在数据流里运动的数据（data-in-motion）做几乎任何你想做的事情。&lt;/p&gt;
&lt;p&gt;了解 ESP 体系结构的最简单的方法是将其视为三个层面或三个功能 —— 输入，处理和输出。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1094052/7zry7yhc3z.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;输入层会接受几乎所有类型的基于时间的流数据，并经常有存在多个输入流的情况。在主 ESP 处理器中会发生各种会被称为程序或操作的动作。这些程序的结果会传递给订阅者的一些接口，后者可以通过人机界面发送警报或创建机器来进行自动操作，并将数据传递给像 Fast 和 Forever 这样的数据存储服务里。&lt;/p&gt;
&lt;p&gt;流处理平台确实可以直接接收数据流，但要注意他们并不善于保存一些会意外丢失的数据，因此你仍然会需要像 Kafka 这样的一个能够回退并重放丢失的数据的数据采集端。在不久的将来，很多流处理器可能会解决这个问题，然后你就需要重新考虑 Kafka 端的必要性了。&lt;/p&gt;

&lt;p&gt;对流处理器常会有这些要求：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;&lt;strong&gt;高速&lt;/strong&gt;：视具体具体业务需求而定，通常每秒要能采集并处理数百万个事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易扩展&lt;/strong&gt;：全部东西都要在分布式集群上运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错&lt;/strong&gt;：这与保证不丢失数据不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定处理&lt;/strong&gt;：这有两种做法：每个事件至少处理一次，和每个事件正好处理一次。不过 “正好处理一次” 的标准很难保证。这是我们将放在稍后讨论的一个深入的主题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能执行你的应用程序运行的必需程序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在采集端进行数据清理的能力（类似于一种迷你 MDM）是其功能强大的真正体现。在数据清理之后会多次复制数据流，以便每个相同的数据流可以同时用于不同的分析程序中，而不用让这些程序程序排队等待前面的分析程序完成分析。下面是一个医疗业务示例的图表，该示例描述了一种在上一章提到过的工作方式，说明了多个数据流会由静态数据来扩大，并会由不同类型的逻辑同时处理。每个块都表示了在 ESP 中需要由你来编写的单独程序。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1094052/lmchj80ls4.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;有很多不同类型的逻辑可以通过这些 ESP 程序来得到应用，包括：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;计算&lt;/li&gt;
&lt;li&gt;复制，建立多个处理路径 —— 每个处理路径具有不同的保留时间，例如 5 - 15 分钟。&lt;/li&gt;
&lt;li&gt;统计&lt;/li&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;li&gt;过滤，它让你能只从数据流中保留有用的数据，并放弃其余数据，从而大大减少存储空间。&lt;/li&gt;
&lt;li&gt;函数（用于变换）&lt;/li&gt;
&lt;li&gt;合并多个流为一个&lt;/li&gt;
&lt;li&gt;通知性质的电子邮件，文字或多媒体形式&lt;/li&gt;
&lt;li&gt;模式（特定关注事件的 EOI，用于检测）&lt;/li&gt;
&lt;li&gt;流程（用于应用高级的预测模型）&lt;/li&gt;
&lt;li&gt;文本内容，用于检测例如受关注的推特模式这样的信息。&lt;/li&gt;
&lt;li&gt;文本情感，用于监控社交媒体流中的积极或消极的情绪。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开源的和专有的软件包在能做的工作上都有着一些区别，因此你应该根据你所需要完成的东西来核对这些软件包的内容。&lt;/p&gt;

&lt;p&gt;主要的开源框架选项（全是 Apache 的）如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Samza&lt;/strong&gt;： 一个分布式的流处理框架。它使用 Kafka 来进行消息传递，由 YARN 来提供容错性、处理器隔离、安全性，以及资源管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NiFi&lt;/strong&gt;：这是一个相当新兴的开源项目，仍处于完善之中。它与其他项目的区别在于它有用户友好的拖曳式的图形界面，以及我们可以轻松地根据特定需求来对它进行定制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Storm&lt;/strong&gt;：一款经过充分测试的基于事件的流处理器。它最初由推特开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPARK Streaming&lt;/strong&gt;： SPARK Streaming 是 SPARK 的四个组成部分之一，它是第一个能在单一企业级平台上整合批量处理和流处理的组件。&lt;/p&gt;

&lt;p&gt;SPARK 已被推出好几年了，但在去年它的使用率有了惊人的增长，现已在大多数新项目中取代了 Hadoop / MapReduce 的地位，并且许多既有的 Hadoop / MapReduce 系统也都迁移到了 SPARK。SPARK 的开发工作正在朝着成为物联网应用所需的唯一技术栈发展。&lt;/p&gt;
&lt;p&gt;SPARK 由五个组件组成，所有这些组件都支持 Scala，Java，Python 还有 R 语言。&lt;/p&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;&lt;strong&gt;SPARK&lt;/strong&gt;：作为一个在系统中处于核心地位的应用程序，它是一个与 HDFS 和其他 NoSQL DB 兼容的批处理引擎。它能比 Hadoop / MapReduce 快 10 倍到 100 倍，因此它十分流行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ML.lib&lt;/strong&gt;：一个自带的功能强大的数据科学以及机器学习算法库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SPARK SQL&lt;/strong&gt;：用于直接支持 SQL 查询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SPARK Streaming&lt;/strong&gt;：SPARK 集成的流处理引擎。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GraphX&lt;/strong&gt;：强大的图形数据库引擎，可用于流式应用程序之外。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1094052/1624z23omu.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;相比之下，Storm 就是一个纯粹的事件流处理器。Storm 和 SPARK Streaming 之间的差异不大，不过它们为传入数据分区的方式便截然不同了。这是后面讨论的一个进一步的话题。&lt;/p&gt;
&lt;p&gt;如果你已经熟悉了关于数据分区的知识并且确定这不会对你的应用造成损害，那么开源的 SPARK / SPARK Streaming 便是最好的选择。&lt;/p&gt;

&lt;p&gt;IoT 流处理应用的标准参考体系结构被称为&lt;strong&gt; Lambda 体系结构&lt;/strong&gt;，该体系结构包含一个&lt;strong&gt;加速层（Speed Layer）&lt;/strong&gt;和一个&lt;strong&gt;安全层（Safety Layer）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;传入数据流会由数据采集应用（Kafka）复制，并朝两个方向发送，一个是安全层，另一个是流处理平台（SPARK Streaming 或 Storm）。这可以确保丢失的数据都得以找回，以确保所有数据都至少得到了一次处理。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1094052/9tpolwnuw0.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;对流处理端的查询可能是提取静态数据来加到流处理器中的数据流，或者可能用于通过任意数量的媒体（包括电子邮件，SMS，客户的应用程序，还有仪表板）向下游的事件消费者发送消息、警报或数据。警报也是在流处理器中的本地环境生成的。&lt;/p&gt;
&lt;p&gt;对安全层的存储的查询将被批量用于创建进一步的分析过程并嵌入到流处理器中，或者用于响应特殊查询，例如开发新的预测模型。&lt;/p&gt;

&lt;p&gt;你应该在设计物联网平台时考虑到引入流处理器的必要性。对某些只需要很少数量或很少种类的传感器的情况，省掉流处理器自身会带来的系统复杂度可能会更好。&lt;/p&gt;

&lt;p&gt;当实时交互的时间相当长的时候，例如在通知终端用户任何新的发现只能每天发生一次或甚至更少时，对传感器的数据进行批量处理在一些情况下是完全合理的。&lt;/p&gt;
&lt;p&gt;从架构的立场来看，传感器数据将到达数据采集应用（Kafka）并直接发送到存储器里面。若使用常规的批处理程序，今天的数据会在夜里被分析，并且需要发送给用户的任何重要信号会放到第二天才发送。&lt;/p&gt;
&lt;p&gt;当 “实时” 会是 24 小时或更长的时间，在某些情况下至多缩短至 12 小时左右时，批处理会是一个可行的选择。如果实时交互的时间需求比这更短，流处理会是一个更具吸引力的选择。&lt;/p&gt;
&lt;p&gt;其实配置流处理来评估任何时间段（包括数天，数周甚至数月）的数据也是可以的，但在某些时候简化系统的价值会超过引入流处理的价值。&lt;/p&gt;

&lt;p&gt;传感器数据有四种范围很广的应用。这也可以为你决定是否引入流处理提供参考。以下举一些例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接使用&lt;/strong&gt;：例如，直接从传感器读取 GPS 坐标，然后把坐标放到地图上，就能轻松创建出一个 “手机去哪里” 的小应用。这一应用可能还需要引入与用户有关的静态数据（比如，需要知道用户的居住地址来限制显示地图的比例），而这可以通过标准表连接（standard table join）来在流处理器外部完成，也可以在流处理器里面完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专家规则&lt;/strong&gt;：不用数据科学，编写能为传入数据流赋予意义的规则也是可行的。例如，可以设计了一个专家规则来与患者的静态数据相结合，让这一规则在患者体温达到 103° 的时候呼叫医护帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预测分析&lt;/strong&gt;：接下来的两个应用程序都属于数据科学领域。数据科学家会使用预测分析技术来在数据中找到有意义的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无监督学习&lt;/strong&gt;： 在预测分析中，无监督学习意味着应用像聚类（clustering）和细分（segementation）这样的技术，而这些技术不需要指示了特定的结果的历史数据。例如，FitBit 里的加速度计可以很容易地了解到你现在的活动比最近活跃还是不活跃，或者你比其他一些你拿来比较的 FitBit 用户相对活跃还是不活跃。给阅读这一过程赋予一些内容就可能需要引入用户的静态数据。&lt;/p&gt;
&lt;p&gt;无监督学习的优势在于，它在放置传感器之后几乎就可以立即部署起来，毕竟它不需要花大量时间用训练数据来建立模型。&lt;/p&gt;
&lt;p&gt;给定发送警报的阈值会需要一些无监督建模方法的帮助。例如一个符合标准的消息的更改周期可以设为应该超出每天 20％ 或一个相似用户组的标准差。&lt;/p&gt;
&lt;p&gt;这些算法会由数据科学家根据批量处理数据进行完善并导出到流处理器中，作为公式应用于数据流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监督学习&lt;/strong&gt;：使用训练数据来开发预测模型，而在训练数据中结果是已知的。这又需要部分检测到了行为和当前状态的样例，还有一部分状态未知的样例。&lt;/p&gt;
&lt;p&gt;例如，我们可以记录电机的温度，振动和功耗，以及测量后 12 小时内电机是否发生故障。如果有足够多的训练数据，我们就可以开发出一个预测模型，提前 12 小时预测可能发生的障碍。&lt;/p&gt;
&lt;p&gt;然后将以代数公式（几行 C，Java，Python 或 R 代码）形式表示的模型导出到流处理器，以便在处理数据流时对数据进行评分，当分数显示即将发生故障时自动发送警报。&lt;/p&gt;
&lt;p&gt;在流处理中使用复杂的预测模型很有好处。不过如果想要预测的事件很罕见，比如这一事件占所有测量数据的比例很小，或者这一事件需要很长时间才可能发生一次（收集足够的训练数据要等上很长时间），那么收集足够的训练数据就会是个问题。&lt;/p&gt;

&lt;blockquote readability=&quot;1.1715976331361&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/55447?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;基于云计算的物联网应用场景有哪些？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1105838?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;启动物联网项目所需的一切：第 1 章&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1101505?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;启动物联网项目所需的一切：第 3 章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;col-article-title&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1098214?fromSource=waitui&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180330104936874-1573429539.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 07:23:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9039271.html</dc:identifier>
</item>
<item>
<title>深挖“窄带高清”的实现原理 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/9040963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/9040963.html</guid>
<description>&lt;div readability=&quot;56.845283018868&quot;&gt;
&lt;p&gt;过去几年，又拍云一直在点播、直播等视频应用方面潜心钻研，取得了不俗的成果。我们结合点播、直播、短视频等业务中的用户场景，推出了“省带宽、压成本”系列文章，从编码技术、网络架构等角度出发，结合又拍云的产品成果，向大家介绍节省流量，降低带宽成本的妙招。&lt;/p&gt;
&lt;p&gt;《降低30%视频码率，深挖“窄带高清”的实现原理》是“省带宽、压成本”系列文章的第3篇。本文将深挖又拍云最新技术窄带高清，讲解窄带高清是怎样在不改变视频主观质量的情况下，通过改变码率来降低视频播放的带宽成本。&lt;/p&gt;
&lt;p&gt;往期回顾：&lt;/p&gt;
&lt;p&gt;第一篇：&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/292/%25E3%2580%2590%25E7%259C%2581%25E5%25B8%25A6%25E5%25AE%25BD%25E3%2580%2581%25E5%258E%258B%25E6%2588%2590%25E6%259C%25AC%25E4%25B8%2593%25E9%25A2%2598%25E3%2580%2591%25E4%25BB%258E%25E4%25BA%25A7%25E5%2593%2581%25E6%259E%25B6%25E6%259E%2584%25E6%259D%25A5%25E7%259C%258BPCDN%25E5%25A6%2582%25E4%25BD%2595%25E8%258A%2582%25E6%25B5%258150%2525.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;《节省50%以上的流量成本，从产品架构看PCDN的节流能力》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二篇：&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/293/%25E3%2580%2590%25E7%259C%2581%25E5%25B8%25A6%25E5%25AE%25BD%25E3%2580%2581%25E5%258E%258B%25E6%2588%2590%25E6%259C%25AC%25E4%25B8%2593%25E9%25A2%2598%25E3%2580%2591%25E6%25B7%25B1%25E5%2585%25A5%25E8%25A7%25A3%25E6%259E%2590%2520H.265%2520%25E7%25BC%2596%25E7%25A0%2581%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%258C%25E5%25B8%25A6%25E4%25BD%25A0%25E4%25BA%2586%25E8%25A7%25A3Apple%25E5%2585%25A8%25E9%259D%25A2%25E6%258E%25A8%25E8%25BF%259BH.265%25E7%259A%2584%25E5%258E%259F%25E5%259B%25A0.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;《深入解析 H.265 编码模式，带你了解 Apple 全面推进 H.265 的原因》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三篇：&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/297/%25E3%2580%2590%25E7%259C%2581%25E5%25B8%25A6%25E5%25AE%25BD%25E3%2580%2581%25E5%258E%258B%25E6%2588%2590%25E6%259C%25AC%25E4%25B8%2593%25E9%25A2%2598%25E3%2580%2591%25E7%2588%25B1%25E5%25A5%2587%25E8%2589%25BA%25E7%25AC%25AC%25E4%25B8%2580%25E5%25AD%25A3%25E5%25BA%25A6%25E5%258F%2588%25E7%2583%25A7%25E4%25BA%258611%25E4%25B8%25AA%25E4%25BA%25BF%25E5%2585%2583%25EF%25BC%258C%25E4%25BB%2580%25E4%25B9%2588%25E6%2597%25B6%25E5%2580%2599%25E6%2598%25AF%25E4%25B8%25AA%25E5%25A4%25B4%25EF%25BC%259F.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;《爱奇艺第一季度又烧了11个亿元，什么时候是个头？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第四篇：《降低30%视频码率，深挖“窄带高清”的实现原理》&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;尽量降低视频码率又不影响视频的主观观看质量，这是视频平台最关心的问题之一，因为降低码率意味着视频播放带宽的下降，节约成本。&lt;/p&gt;
&lt;p&gt;2018年3月，又拍云自研的“窄带高清”功能，通过码率控制优化，让视频在主观质量不受影响的情况下，高效降低30%视频码率。窄带高清通过视频内容复杂度算法来确定视频应用场景，继而确定该场景下最优视频编码参数，辅助于码率控制算法，最终达到视频码率控制与带宽优化这个目的。&lt;/p&gt;
&lt;p&gt;窄带高清可以有效提升视频播放平台终端用户视频打开速度，并且减少视频分发在带宽成本的上的消耗。&lt;/p&gt;
&lt;h2&gt;为什么窄带高清可以节省流量&lt;/h2&gt;
&lt;p&gt;一般来说，视频转码所需的成本比视频播放带宽少很多。因此通过视频转码来降低带宽成本成为可能，窄带高清就是建立在这个大前提下的一个功能。通过窄带高清功能可以节省30%的视频码率，大大降低直播、点播等业务场景下的带宽成本。&lt;/p&gt;

&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-a1a06b02c2b65786501df1984106c907_hd.jpg&quot; alt=&quot;&quot; width=&quot;1179&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1179&quot; data-rawheight=&quot;666&quot; data-original=&quot;https://pic2.zhimg.com/v2-a1a06b02c2b65786501df1984106c907_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a1a06b02c2b65786501df1984106c907_b.jpg&quot;/&gt;&lt;/div&gt;&lt;div readability=&quot;45&quot;&gt;
&lt;h2&gt;窄带高清是如何实现&lt;/h2&gt;
&lt;p&gt;实现窄带高清有两个优化方向，1.在相同码率的情况下提升视频质量；2.在主观质量不受损失的情况下，尽可能降低视频码率。&lt;/p&gt;
&lt;p&gt;根据实际业务需求，又拍云的“窄带高清”功能采用了第二种思路，即保持视频质量，降低码率。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;场景划分&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先我们需要对视频进行内容复杂度分析，获取场景信息，取得视频空间域的复杂度和时间域的复杂度，然后获得视频序列最终的复杂度，最终确定视频编码场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要进行场景划分呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下文我们以场景运动剧烈和平缓的视频为例，跟大家解释一下场景划分的原因。&lt;/p&gt;

&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-f241078097d61ee15f4ccf11c698b122_hd.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;960&quot; data-original=&quot;https://pic1.zhimg.com/v2-f241078097d61ee15f4ccf11c698b122_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f241078097d61ee15f4ccf11c698b122_b.jpg&quot;/&gt;&lt;/div&gt;&lt;div readability=&quot;82.47476635514&quot;&gt;
&lt;p&gt;从上图可以看出，在相同质量下，场景运动缓慢的视频比场景运动剧烈的视频，所需码率少很多，这就是场景划分的意义所在。&lt;/p&gt;
&lt;p&gt;目前我们对手机拍摄视频、动画、商业动作大片、影视剧、在线教育、综艺节目等视频场景进行测试，获取常见场景下视频内容的编码复杂度。&lt;/p&gt;
&lt;p&gt;另外在高码率的时候，码率增加对视频质量的提升比较少，因此只要找到合适码率，那么视频低码率下的质量和高码率下的质量是相差无几的，这是窄带高清的理论基石。&lt;/p&gt;
&lt;h3&gt;码率控制算法研究&lt;/h3&gt;
&lt;p&gt;码率控制算法是视频编码器中非常重要的部分，学术上，码率控制算法分为两种：CBR（Constant Bit Rate，恒定码率）和VBR（Variable Bit Rate，可变码率）。考虑到业务需求是在主观质量不变的情况下，降低视频文件大小，又拍云“窄带高清”功能采用VBR的方式，并做了如下设定提升整体画质的表现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;视频运动缓慢的时候，使用更低的码率；运动剧烈的时候，使用更高的码率；&lt;/li&gt;
&lt;li&gt;视频图像内部，静止的部分分配更少的码率；运动的部分分配更多的码率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通俗的说，把码率放在该用的地方，不浪费每一个比特，实现更低的码率，更清晰的画质，更小的文件尺寸。&lt;/p&gt;
&lt;h3&gt;视频编码器优化&lt;/h3&gt;
&lt;p&gt;如何对视频编码器进行优化，又拍云通过客观质量评价加主观质量评价想结合的办法来制定视频编码器优化标准。&lt;/p&gt;
&lt;p&gt;视频质量评价作为视频领域热门的研究方向之一，分成&lt;strong&gt;主观质量评价和客观质量评价&lt;/strong&gt;两类。&lt;/p&gt;
&lt;p&gt;主观质量评价，即通过人工观察者直接观察视频，在主观打分，对视频质量的好坏进行分级，该方法必须严格的测试环境实施步骤复杂，而且对观察者要有一定的专业要求，因此实施起来需要巨大的代价，一般会用在科研机构小规模的算法验证。&lt;/p&gt;
&lt;p&gt;而对海量视频数据和工业界来说，客观质量评价是更好的选择。PSNR(Peak Signal to Noise Ratio，峰值信噪比)，是基于数学统计特性的评价方法，基于独立的像素差值，忽略序列内容对失真可见度的影响，因而会出现和主观感知的视频质量的一致性存在差异。但是算法简单，易于操作，且大规模应用。&lt;/p&gt;
&lt;p&gt;针对PSNR的缺点，Zhou Wang等人实现了亮度、对比度和结构失真相互独立的质量评价方法SSIM，得到更接近人眼视觉特性的评价指标。但是依然是过于简单，屏蔽掉了HVS的其他生理特性。&lt;/p&gt;
&lt;p&gt;视频编码器的参数数量很多，纷繁复杂，为了得到最佳的优化组合，我们用了客观质量评价算法PSNR（Peak Signal to Noise Ratio，峰值信噪比）和SSIM（Structural SIMilarity，结构相似度），主观质量评价算法VMAF（Video Multi-Method Assessment Fusion），再配合人工主观质量评价的方式，获取了常见场景下视频编码器的参数优化方案。&lt;/p&gt;
&lt;p&gt;又拍云窄带高清，融合了以上几种客观和主观的评价方法，在编码器优化过程中，获取码率和视频质量的平衡。&lt;/p&gt;
&lt;p&gt;目前，绝大多数视频还是使用H.264/AVC视频编码标准，更先进的H.265/HEVC和VP9的普及度还不够。因此又拍云“窄带高清”功能优先支持了H.264视频编码格式，未来将支持H.265格式。&lt;/p&gt;
&lt;p&gt;学术界还有许多码率方面的研究成果，比如基于ROI（Region of Interest，感兴趣区域）和HVS（Human Visual System，人眼视觉系统）的码率控制，这些成果和技术，又拍云也将积极融入到相关产品和解决方案中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;a class=&quot;LinkCard LinkCard--noImage&quot; href=&quot;https://link.zhihu.com/?target=https%3A//tech.upyun.com/article/297/%25E3%2580%2590%25E7%259C%2581%25E5%25B8%25A6%25E5%25AE%25BD%25E3%2580%2581%25E5%258E%258B%25E6%2588%2590%25E6%259C%25AC%25E4%25B8%2593%25E9%25A2%2598%25E3%2580%2591%25E7%2588%25B1%25E5%25A5%2587%25E8%2589%25BA%25E7%25AC%25AC%25E4%25B8%2580%25E5%25AD%25A3%25E5%25BA%25A6%25E5%258F%2588%25E7%2583%25A7%25E4%25BA%258611%25E4%25B8%25AA%25E4%25BA%25BF%25E5%2585%2583%25EF%25BC%258C%25E4%25BB%2580%25E4%25B9%2588%25E6%2597%25B6%25E5%2580%2599%25E6%2598%25AF%25E4%25B8%25AA%25E5%25A4%25B4%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-za-detail-view-id=&quot;172&quot;&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;爱奇艺第一季度又烧了11个亿元，什么时候是个头？&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;</description>
<pubDate>Tue, 15 May 2018 06:57:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/9040963.html</dc:identifier>
</item>
<item>
<title>Git分支合并冲突解决 - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/9022549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/9022549.html</guid>
<description>&lt;p&gt;前2天群里发了张git历史图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512102247688-860697223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据提交历史，可以看出图中所有分支合并都采用merge的方式，具体merge是怎么操作的，可以阅读下边文章。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;根据项目上的需求，如果要求git提交历史是比较简单的一条时间线，可以使用rebase的合并；如果没有这个要求，可以使用merge合并，其分支树是网状结构，但每个提交也都是比较明确清晰的。他们的区别，可参考&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/shuimuzhushui/p/9000253.html&quot;&gt;git merge与 git rebase区别及实例&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;       rebase合并：本质是先取消自己的提交，临时保存，然后把当前分支更新到最新的origin分支，最后应用自己的提交。&lt;/li&gt;
&lt;li&gt;       merge合并：将两个分支进行合并提交。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt; rebase合并&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）远程fetch的代码，本地没有修改，直接rebase即可；&lt;/p&gt;
&lt;p&gt;（2）若本地对文件修改，没有add，rebase时，会提示“Cannot rebase: You have unstaged changes.Please commit or stash them.”，add后没有commit，会提示“Cannot rebase: Your index contains uncommitted changes.Please commit or stash them.”。commit后，如果没有修改同一文件，rebase不会冲突。&lt;/p&gt;
&lt;p&gt;（3）若本地对同一个文件修改，commit后，rebase时，有2种情况：&lt;/p&gt;
&lt;p&gt;　　　　① 如果没有修改同一位置，则可以rebase，不会产生冲突；&lt;/p&gt;
&lt;p&gt;　　　　② 如果修改了同一处，则rebase时会出现冲突，也不用怕，此时git已经进行了合并，只是没有应用自己的提交，解决办法：&lt;strong&gt;修改冲突的文件，然后执行add和rebase --continue操作即可&lt;/strong&gt;。如果不小心，执行完add后执行了commit，此时本地仓库HEAD处于游离态，如何解决，后续再补充。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt; merge合并&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;merge合并也可能存在冲突，解决冲突与rebase相似，处理完冲突文件后，重新提交即可。&lt;/p&gt;
&lt;h2&gt;举例说明&lt;/h2&gt;
&lt;p&gt;假设现在有3个人（git1、git2、git3）合作开发一个项目。&lt;/p&gt;
&lt;p&gt;（1）git1创建项目，添加index.html文件，在index文件中添加“create by git1”，提交；&lt;/p&gt;
&lt;p&gt;         git2拉取文件后，在index中添加“add by git2”，提交；&lt;/p&gt;
&lt;p&gt;         git3拉取文件后，在index中添加“add by git3”，提交；&lt;/p&gt;
&lt;p&gt;         git1拉取最新代码后，在index中添加“add by git1  add1 by git1”，如下：&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512102932544-533316760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        提交远程仓库，分支树如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512102959903-1410090060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）git2在index文件中添加“add 1 by git2”，以实验冲突&lt;/p&gt;
&lt;p&gt;　　此时分支树如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103043442-1995368390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103101626-1101259628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提交后：&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103122559-1004054733.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　然后执行rebase发生冲突：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103219980-1078962081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分支树为（此时分支为(no branch, rebasing dev)）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103236863-1189236552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103248897-11528515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开冲突文件，冲突部分是以 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; =============  &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;标识，将此部分代码进行处理，处理后的文件为：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103326801-2119819810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行add和rebase --continue&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103344999-283645296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 rebase结束，分支树为：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103359939-441479861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103416184-1310292092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提交远程后，最终分支树如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103433224-1306731958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）git3的index文件如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;http://wiki.yonyou.com/download/attachments/94913487/image2018-5-11%2019%3A57%3A17.png?version=1&amp;amp;modificationDate=1526044332870&amp;amp;api=v2&quot; alt=&quot;&quot; data-image-src=&quot;/download/attachments/94913487/image2018-5-11%2019%3A57%3A17.png?version=1&amp;amp;modificationDate=1526044332870&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;94913382&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;image2018-5-11 19:57:17.png&quot; data-base-url=&quot;http://wiki.yonyou.com&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;94913487&quot; data-linked-resource-container-version=&quot;5&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       将index文件中的第一行修改为“create by git1  modifed in another place”，提交。&lt;/p&gt;
&lt;p&gt;　　 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;http://wiki.yonyou.com/download/attachments/94913487/image2018-5-11%2020%3A0%3A47.png?version=1&amp;amp;modificationDate=1526044332850&amp;amp;api=v2&quot; alt=&quot;&quot; data-image-src=&quot;/download/attachments/94913487/image2018-5-11%2020%3A0%3A47.png?version=1&amp;amp;modificationDate=1526044332850&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;94913384&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;image2018-5-11 20:0:47.png&quot; data-base-url=&quot;http://wiki.yonyou.com&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;94913487&quot; data-linked-resource-container-version=&quot;5&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       从远程拉取最新文件，执行rebase&lt;/p&gt;
&lt;p&gt;       &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;http://wiki.yonyou.com/download/attachments/94913487/image2018-5-11%2020%3A1%3A57.png?version=1&amp;amp;modificationDate=1526044332827&amp;amp;api=v2&quot; alt=&quot;&quot; data-image-src=&quot;/download/attachments/94913487/image2018-5-11%2020%3A1%3A57.png?version=1&amp;amp;modificationDate=1526044332827&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;94913385&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;image2018-5-11 20:1:57.png&quot; data-base-url=&quot;http://wiki.yonyou.com&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;94913487&quot; data-linked-resource-container-version=&quot;5&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       最终结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103538425-346868688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103547797-155003208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103556359-1128046141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）git1创建了一个index2.html文件，提交后push，远程拒绝push，原因是本地不是最新版本，需要更新后提交，拉取最新文件。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103631713-44739051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　git1执行merge操作，最终分支树如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103655897-1138013063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180512103703318-112131804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;修改同文件不同处，rebase和merge合并不会冲突&lt;/li&gt;
&lt;li&gt;修改同文件同一处，合并会冲突，解决方式：rebase，解决冲突，执行add+rebase continue；merge，解决冲突，重新提交&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 02:46:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/9022549.html</dc:identifier>
</item>
<item>
<title>PHP多进程消费队列 - 奔跑的Man</title>
<link>http://www.cnblogs.com/iforever/p/9039579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iforever/p/9039579.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近开发一个小功能，用到了队列mcq，启动一个进程消费队列数据，后边发现一个进程处理不过来了，又加了一个进程，过了段时间又处理不过来了......&lt;/p&gt;
&lt;p&gt;这种方式每次都要修改crontab，如果进程挂掉了，不会及时的启动，要等到下次crontab执行的时候才会启动。关闭（重启）进程的时候用的是kill，这可能会丢失正在处理的数据，比如下面这个例子，我们假设sleep过程就是处理逻辑，这里为了明显看出效果，将处理时间放大到10s：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;开始第[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$i}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]次循环&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;结束第[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$i}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]次循环&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;++&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们运行脚本之后，等到循环开始之后，给进程发送 &lt;code&gt;kill {$pid}&lt;/code&gt;，默认发送的是编号为15的&lt;code&gt;SIGTERM&lt;/code&gt;信号。假设&lt;code&gt;$i&lt;/code&gt;是从队列拿到的，拿到2的时候，正在处理，我们给程序发送了kill信号，和队列数据丢失一样，问题比较大，因此我要想办法解决这些问题。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;开始第[&lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;]次循环
结束第[&lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;]次循环
开始第[&lt;span class=&quot;kw&quot;&gt;2&lt;/span&gt;]次循环


[&lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;]    28372 terminated  php t.php&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;nginx进程模型&quot;&gt;nginx进程模型&lt;/h2&gt;
&lt;p&gt;这时候我想到了nginx，nginx作为高性能服务器的中流砥柱，为成千上万的企业和个人服务，他的进程模型比较经典，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675818/201805/675818-20180515102916197-1575197783.png&quot; alt=&quot;nginx 进程模型 图片来自网络&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管理员通过master进程和nginx进行交互，从&lt;code&gt;/path/to/nginx.pid&lt;/code&gt;读取nginx master进程的pid，发送信号给master进程，master根据不同的信号做出不同的处理，然后反馈信息给管理员。worker是master进程fork出来的，master负责管理worker，不会去处理业务，worker才是具体业务的处理者，master可以控制worker的退出、启动，当worker意外退出，master会收到子进程退出的消息，也会重新启动新的worker进程补充上来，不让业务处理受影响。nginx还可以平滑退出，不丢失任何一个正在处理的数据，更新配置时nginx可以做到不影响线上服务来加载新的配置，这在请求量很大的时候特别有用。&lt;/p&gt;
&lt;h2 id=&quot;进程设计&quot;&gt;进程设计&lt;/h2&gt;
&lt;p&gt;看了nginx的进模型，我们完全可以开发一个类似的类库来满足处理mcq数据的需求，做到单文件控制所有进程、可以平滑退出、可以查看子进程状态。不需要太复杂，因为我们处理队列数据接收一定的延迟，做到nginx那样不间断服务比较麻烦，费时费力，意义不是很大。设计的进程模型跟nginx类似，更像是nginx的简化版本。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675818/201805/675818-20180515102939979-168528828.png&quot; alt=&quot;多进程模型&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;进程信号量设计&quot;&gt;进程信号量设计&lt;/h4&gt;
&lt;p&gt;信号量是进程间通讯的一种方式，比较简单，单功能也比较弱，只能发送信号给进程，进程根据信号做出不同的处理。&lt;/p&gt;
&lt;p&gt;master进程启动的时候保存pid到文件&lt;code&gt;/path/to/daeminze.pid&lt;/code&gt;，管理员通过信号和master进程通讯，master进程安装3种信号，碰到不同的信号，做出不同的处理，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SIGINT  =&amp;gt; 平滑退出，处理完正在处理的数据再退出
SIGTERM =&amp;gt; 暴力退出，无论进程是否正在处理数据直接退出
SIGUSR1 =&amp;gt; 查看进程状态，查看进程占用内存，运行时间等信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;master进程通过信号和worker进程通讯，worker进程安装了2个信号，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SIGINT  =&amp;gt; 平滑退出
SIGUSR1 =&amp;gt; 查看worker进程自身状态&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么worker进程只安装2个信号呢，少了个&lt;code&gt;SIGTERM&lt;/code&gt;，因为master进程收到信号&lt;code&gt;SIGTERM&lt;/code&gt;之后，向worker进程发送&lt;code&gt;SIGKILL&lt;/code&gt;信号，默认强制关闭进程即可。&lt;/p&gt;
&lt;p&gt;worker进程是通过master进程fork出来的，这样master进程可以通过&lt;code&gt;pcntl_wait&lt;/code&gt;来等待子进程退出事件，当有子进程退出的时候返回子进程pid，做处理并启动新的进程补充上来。&lt;/p&gt;
&lt;p&gt;master进程也通过&lt;code&gt;pcntl_wait&lt;/code&gt;来等待接收信号，当有信号到达的时候，会返回&lt;code&gt;-1&lt;/code&gt;，这个地方还有些坑，在下文中会详细讲。&lt;/p&gt;
&lt;p&gt;PHP中有2种信号触发的方式，第一种方式是&lt;code&gt;declare(ticks = 1);&lt;/code&gt;，这种效率不高，Zend每执行一次低级语句，都会去检查进程中是否有未处理的信号，现在已经很少使用了，&lt;code&gt;PHP 5.3.0&lt;/code&gt;及之前的版本可能会用到这个。&lt;/p&gt;
&lt;p&gt;第二种是通过&lt;code&gt;pcntl_signal_dispatch&lt;/code&gt;来调用未处理的信号，&lt;code&gt;PHP 5.4.0&lt;/code&gt;及之后的版本适用，可以巧妙的将该函数放在循环中，性能上基本没什么损失，现在推荐适用。&lt;/p&gt;
&lt;h4 id=&quot;php安装修信号量&quot;&gt;PHP安装修信号量&lt;/h4&gt;
&lt;p&gt;PHP通过&lt;code&gt;pcntl_signal&lt;/code&gt;安装信号，函数声明如下所示：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;bool &lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; int &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;callback &lt;span class=&quot;kw&quot;&gt;$handler&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[,&lt;/span&gt; bool &lt;span class=&quot;kw&quot;&gt;$restart_syscalls&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三个参数&lt;code&gt;restart_syscalls&lt;/code&gt;不太好理解，找了很多资料，也没太查明白，经过试验发现，这个参数对&lt;code&gt;pcntl_wait&lt;/code&gt;函数接收信号有影响，当设置为缺省值&lt;code&gt;true&lt;/code&gt;的时候，发送信号，进程用&lt;code&gt;pcntl_wait&lt;/code&gt;收不到，必须设置为&lt;code&gt;false&lt;/code&gt;才可以，看看下面这个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&amp;lt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_fork&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$random&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$random&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    }
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;child &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$pid}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; sleep &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$random}\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;++&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}

&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;SIGINT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
     &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Ctrl + C&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_wait&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$status&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;var_dump&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    pcntl_signal_dispatch&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行之后，我们对父进程发送&lt;code&gt;kill -SIGINT {$pid}&lt;/code&gt;信号，发现pcntl_wait没有反应，等到有子进程退出的时候，发送过的&lt;code&gt;SIGINT&lt;/code&gt;会一个个执行，比如下面结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;child 29643 sleep 48
child 29644 sleep 24
child 29645 sleep 37
child 29646 sleep 20
child 29647 sleep 31
int(29643)
Ctrl + C
Ctrl + C
Ctrl + C
Ctrl + C
int(29646)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是运行脚本之后马上给父进程发送了四次&lt;code&gt;SIGINT&lt;/code&gt;信号，等到一个子进程推出的时候，所有信号都会触发。&lt;/p&gt;
&lt;p&gt;但当把安装信号的第三个参数设置为&lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pcntl_signal(SIGINT,  function($signo) {
     echo &quot;Ctrl + C\n&quot;;
}, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候给父进程发送&lt;code&gt;SIGINT&lt;/code&gt;信号，&lt;code&gt;pcntl_wait&lt;/code&gt;会马上返回&lt;code&gt;-1&lt;/code&gt;，信号对应的事件也会触发。&lt;/p&gt;
&lt;p&gt;所以第三个参数大概意思就是，是否重新注册此信号，如果为false只注册一次，触发之后就返回，&lt;code&gt;pcntl_wait&lt;/code&gt;就能收到消息，如果为true，会重复注册，不会返回，&lt;code&gt;pcntl_wait&lt;/code&gt;收不到消息。&lt;/p&gt;
&lt;h4 id=&quot;信号量和系统调用&quot;&gt;信号量和系统调用&lt;/h4&gt;
&lt;p&gt;信号量会打断系统调用，让系统调用立刻返回，比如&lt;code&gt;sleep&lt;/code&gt;，当进程正在sleep的时候，收到信号，sleep会马上返回剩余sleep秒数，比如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;SIGINT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
     &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Ctrl + C&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
    pcntl_signal_dispatch&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;123&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$limit&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;limit sleep [&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$limit}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;] s&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行之后，按&lt;code&gt;Ctrl + C&lt;/code&gt;，结果如下所示：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;123
^Climit sleep [1] s
Ctrl + C
123
limit sleep [0] s
123
^Climit sleep [1] s
Ctrl + C
123
^Climit sleep [2] s&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;daemon守护进程&quot;&gt;daemon（守护）进程&lt;/h4&gt;
&lt;p&gt;这种进程一般设计为daemon进程，不受终端控制，不与终端交互，长时间运行在后台，而对于一个进程，我们可以通过下面几个步骤把他升级为一个标准的daemon进程：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; daemonize&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_fork&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fork进程失败&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;elseif&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; == &lt;span class=&quot;fu&quot;&gt;posix_setsid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;())&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;新建立session会话失败&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_fork&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fork进程失败&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    }

    &lt;span class=&quot;fu&quot;&gt;umask&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;chdir&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拢共分五步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;fork子进程，父进程退出。&lt;/li&gt;
&lt;li&gt;设置子进程为会话组长，进程组长。&lt;/li&gt;
&lt;li&gt;再次fork，父进程退出，子进程继续运行。&lt;/li&gt;
&lt;li&gt;恢复文件掩码为&lt;code&gt;0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;切换当前目录到根目录&lt;code&gt;/&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第2步是为第1步做准备，设置进程为会话组长，必要条件是进程非进程组长，因此做第一次fork，进程组长（父进程）退出，子进程通过&lt;code&gt;posix_setsid()&lt;/code&gt;设置为会话组长，同时也为进程组长。&lt;/p&gt;
&lt;p&gt;第3步是为了不让进程重新控制终端，因为一个进程控制一个终端的必要条件是会话组长（pid=sid）。&lt;/p&gt;
&lt;p&gt;第4步是为了恢复默认的文件掩码，避免之前做的操作对文件掩码做了设置，带来不必要的麻烦。关于文件掩码， linux中，文件掩码在创建文件、文件夹的时候会用到，文件的默认权限为666，文件夹为777，创建文件（夹）的时候会用默认值减去掩码的值作为创建文件（夹）的最终值，比如掩码&lt;code&gt;022&lt;/code&gt;下创建文件&lt;code&gt;666 - 222 = 644&lt;/code&gt;，创建文件夹&lt;code&gt;777 - 022 = 755&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;umask(0)&lt;/td&gt;
&lt;td&gt;666 (-rw-rw-rw-)&lt;/td&gt;
&lt;td&gt;777 (drwxrwxrwx)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;umask(022)&lt;/td&gt;
&lt;td&gt;644 (-rw-r--r--)&lt;/td&gt;
&lt;td&gt;755 (drwxr-xr-x)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第5步是切换了当前目录到根目录&lt;code&gt;/&lt;/code&gt;，网上说避免起始运行他的目录不能被正确卸载，这个不是太了解。&lt;/p&gt;
&lt;p&gt;对应5步，每一步的各种id变化信息：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;开始&lt;/td&gt;
&lt;td&gt;17723&lt;/td&gt;
&lt;td&gt;31381&lt;/td&gt;
&lt;td&gt;17723&lt;/td&gt;
&lt;td&gt;31381&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;第一次fork&lt;/td&gt;
&lt;td&gt;17723&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;17723&lt;/td&gt;
&lt;td&gt;31381&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;posix_setsid()&lt;/td&gt;
&lt;td&gt;17740&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;17740&lt;/td&gt;
&lt;td&gt;17740&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;第二次fork&lt;/td&gt;
&lt;td&gt;17840&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;17740&lt;/td&gt;
&lt;td&gt;17740&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;另外，会话、进程组、进程的关系如下图所示，这张图有助于更好的理解。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675818/201805/675818-20180515103356071-144280313.png&quot; alt=&quot;会话、进程组、进程关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，你也可以轻松地造出一个daemon进程了。&lt;/p&gt;
&lt;h2 id=&quot;命令设计&quot;&gt;命令设计&lt;/h2&gt;
&lt;p&gt;我准备给这个类库设计6个命令，如下所示：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;start 启动命令&lt;/li&gt;
&lt;li&gt;restart 强制重启&lt;/li&gt;
&lt;li&gt;stop 平滑停止&lt;/li&gt;
&lt;li&gt;reload 平滑重启&lt;/li&gt;
&lt;li&gt;quit 强制停止&lt;/li&gt;
&lt;li&gt;status 查看进程状态&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;启动命令&quot;&gt;启动命令&lt;/h4&gt;
&lt;p&gt;启动命令就是默认的流程，按照默认流程走就是启动命令，启动命令会检测pid文件中是否已经有pid，pid对应的进程是否健康，是否需要重新启动。&lt;/p&gt;
&lt;h4 id=&quot;强制停止命令&quot;&gt;强制停止命令&lt;/h4&gt;
&lt;p&gt;管理员通过入口文件结合pid给master进程发送&lt;code&gt;SIGTERM&lt;/code&gt;信号，master进程给所有子进程发送&lt;code&gt;SIGKILL&lt;/code&gt;信号，等待所有worker进程退出后，master进程也退出。&lt;/p&gt;
&lt;h4 id=&quot;强制重启命令&quot;&gt;强制重启命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;强制停止命令&lt;/code&gt; + &lt;code&gt;启动命令&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;平滑停止命令&quot;&gt;平滑停止命令&lt;/h4&gt;
&lt;p&gt;平滑停止命令，管理员给master进程发送&lt;code&gt;SIGINT&lt;/code&gt;信号，master进程给所有子进程发送&lt;code&gt;SIGINT&lt;/code&gt;，worker进程将自身状态标记为&lt;code&gt;stoping&lt;/code&gt;，当worker进程下次循环的时候会根据&lt;code&gt;stoping&lt;/code&gt;决定停止，不在接收新的数据，等所有worker进程退出之后，master进程也退出。&lt;/p&gt;
&lt;h4 id=&quot;平滑重启命令&quot;&gt;平滑重启命令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;平滑停止命令&lt;/code&gt; + &lt;code&gt;启动命令&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;查看进程状态&quot;&gt;查看进程状态&lt;/h4&gt;
&lt;p&gt;查看进程状态这个借鉴了&lt;a href=&quot;https://github.com/walkor/Workerman.git&quot;&gt;workerman&lt;/a&gt;的思路，管理员给master进程发送&lt;code&gt;SIGUSR1&lt;/code&gt;信号，告诉主进程，我要看所有进程的信息，master进程，master进程将自身的进程信息写入配置好的文件路径A中，然后发送&lt;code&gt;SIGUSR1&lt;/code&gt;，告诉worker进程把自己的信息也写入文件A中，由于这个过程是异步的，不知道worker进程啥时候写完，所以master进程在此处等待，等所有worker进程都写入文件之后，格式化所有的信息输出，最后输出的内容如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜/dir /usr/local/bin/php DaemonMcn.php status
Daemon [DaemonMcn] 信息:
-------------------------------- master进程状态 --------------------------------
pid       占用内存       处理次数       开始时间                 运行时间
16343     0.75M          --             2018-05-15 09:42:45      0 天 0 时 3 分
12 slaver
-------------------------------- slaver进程状态 --------------------------------
任务task-mcq:
16345     0.75M          236            2018-05-15 09:42:45      0 天 0 时 3 分
16346     0.75M          236            2018-05-15 09:42:45      0 天 0 时 3 分
--------------------------------------------------------------------------------
任务test-mcq:
16348     0.75M          49             2018-05-15 09:42:45      0 天 0 时 3 分
16350     0.75M          49             2018-05-15 09:42:45      0 天 0 时 3 分
16358     0.75M          49             2018-05-15 09:42:45      0 天 0 时 3 分
16449     0.75M          1              2018-05-15 09:46:40      0 天 0 时 0 分
--------------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待worker进程将进程信息写入文件的时候，这个地方用了个比较trick的方法，每个worker进程输出一行信息，统计文件的行数，达到worker进程的行数之后表示所有worker进程都将信息写入完毕，否则，每个1s检测一次。&lt;/p&gt;
&lt;h2 id=&quot;其他设计&quot;&gt;其他设计&lt;/h2&gt;
&lt;p&gt;另外还加了两个比较实用的功能，一个是worker进程运行时间限制，一个是worker进程循环处理次数限制，防止长时间循环进程出现内存溢出等意外情况。时间默认是1小时，运行次数默认是10w次。&lt;/p&gt;
&lt;p&gt;除此之外，也可以支持多任务，每个任务几个进程独立开，统一由master进程管理。&lt;/p&gt;
&lt;p&gt;代码已经放到&lt;a href=&quot;https://github.com/aizuyan/daemon&quot;&gt;github&lt;/a&gt;中，有兴趣的可以试试，不支持windows哦，有什么错误还望指出来。&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 02:36:00 +0000</pubDate>
<dc:creator>奔跑的Man</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iforever/p/9039579.html</dc:identifier>
</item>
<item>
<title>python 闯关之路三（面向对象与网络编程） - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9023916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9023916.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;1，简述socket 通信原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511102403529-1243810078.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511102901496-1923634191.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图，socket通信建立在应用层与TCP/IP协议组通信（运输层）的中间软件抽象层，它是一组接口，在设计模式中，socket其实就是一个门面模式，它把复杂的TCP/IP协议组隐藏在Socket接口后面，对于用户来说，一组简单的接口就是全部，让socket去组织数据，以符合指定的协议。&lt;/p&gt;
&lt;p&gt;所以，经常对用户来讲，&lt;strong&gt;socket就是ip+prot 即IP地址（识别互联网中主机的位置）+port是程序开启的端口号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　socket通信如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511103650486-532245913.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# _*_ coding: utf-8 _*_ 
import socket

ip_port = ('127.0.0.1',9696)
link = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
link.connect(ip_port)
print(&quot;开始发送数据&quot;)
cmd = input(&quot;client请输入要发送的数据&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;).strip()
link.send(cmd.encode('utf-8'))
recv_data = link.recv(1024)
print(&quot;这是受到的消息：&quot;,recv_data)
link.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务端&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# _*_ coding: utf-8 _*_ 
import socket

ip_port = ('127.0.0.1',9696)
link = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
link.bind(ip_port)
link.listen(5)

conn,addr = link.accept()
#这里，因为我们知道自己写的少，所以1024够用
recv_data = conn.recv(1024)
print(&quot;这是受到的消息：&quot;,recv_data)
cmd = input(&quot;server请输入要发送的数据&amp;gt;&amp;gt;&amp;gt;&amp;gt;&quot;).strip()
conn.send(cmd.encode('utf-8'))
conn.close()
link.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;2，粘包的原因和解决方法？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　TCP是面向流的协议，发送文件内容是按照一段一段字节流发送的，在接收方看来不知道文件的字节流从和开始，从何结束。&lt;/p&gt;
&lt;p&gt;　　UDP是面向消息的协议，每个UDP段都是一个消息，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
直接原因：
    所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的

根本原因：
    发送方引起的粘包是由TCP协议本身造成的，TCP为了提高传送效率，发送方往往要收集到足够多的数据
才发送一个TCP段，若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成到一个TCP
段后一次发送过去，这样接收方就受到了粘包数据。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要一直收发消息，加一个while True即可。但是这里有个1024的问题，即粘包，&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　粘包的根源在于：接收端不知道发送端将要发的字节流的长度，所以解决粘包问题的方法就是围绕如何让发送端在发送数据前，把自己将要发送的字节流大小让接收段知道，然后接收端来一个死循环，接收完所有的数据即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　粘包解决的具体做法：为字节流加上自定义固定长度报头，报头中包含字节流长度，然后依次send到对端，对端在接受时，先从缓存中取出定长的报头，然后再取真是数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# _*_ coding: utf-8 _*_ 
import socket
import struct
import json
phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
phone.connect(('127.0.0.1',8080)) #连接服务器
while True:
    # 发收消息
    cmd = input('请你输入命令&amp;gt;&amp;gt;：').strip()
    if not cmd:continue
    phone.send(cmd.encode('utf-8')) #发送
    #先收报头的长度
    header_len = struct.unpack('i',phone.recv(4))[0]  #吧bytes类型的反解
    #在收报头
    header_bytes = phone.recv(header_len) #收过来的也是bytes类型
    header_json = header_bytes.decode('utf-8')   #拿到json格式的字典
    header_dic = json.loads(header_json)  #反序列化拿到字典了
    total_size = header_dic['total_size']  #就拿到数据的总长度了
    #最后收数据
    recv_size = 0
    total_data=b''
    while recv_size&amp;lt;total_size: #循环的收
        recv_data = phone.recv(1024) #1024只是一个最大的限制
        recv_size+=len(recv_data) #有可能接收的不是1024个字节，或许比1024多呢，
        # 那么接收的时候就接收不全，所以还要加上接收的那个长度
        total_data+=recv_data #最终的结果
    print('返回的消息：%s'%total_data.decode('gbk'))
phone.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务端&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# _*_ coding: utf-8 _*_ 
import socket
import subprocess
import struct
import json
phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机
phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
phone.bind(('127.0.0.1',8080)) #绑定手机卡
phone.listen(5) #阻塞的最大数
print('start runing.....')
while True: #链接循环
    coon,addr = phone.accept()# 等待接电话
    print(coon,addr)
    while True: #通信循环
        # 收发消息
        cmd = coon.recv(1024) #接收的最大数
        print('接收的是：%s'%cmd.decode('utf-8'))
        #处理过程
        res = subprocess.Popen(cmd.decode('utf-8'),shell = True,
                                          stdout=subprocess.PIPE, #标准输出
                                          stderr=subprocess.PIPE #标准错误
                                )
        stdout = res.stdout.read()
        stderr = res.stderr.read()
        # 制作报头
        header_dic = {
            'total_size': len(stdout)+len(stderr),  # 总共的大小
            'filename': None,
            'md5': None
        }
        header_json = json.dumps(header_dic) #字符串类型
        header_bytes = header_json.encode('utf-8')  #转成bytes类型(但是长度是可变的)
        #先发报头的长度
        coon.send(struct.pack('i',len(header_bytes))) #发送固定长度的报头
        #再发报头
        coon.send(header_bytes)
        #最后发命令的结果
        coon.send(stdout)
        coon.send(stderr)
    coon.close()
phone.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3，TCP／IP协议详情&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511102216677-254952615.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP和UDP协议在传输层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511102403529-1243810078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;br/&gt;4，简述3次握手，四次挥手？&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
三次握手：
    client发送请求建立通道；
    server收到请求并同意，同时也发送请求建通道；
    client收到请求并同意，建立完成
 
四次挥手：
    client发送请求断开通道；
    server收到请求并同意，同时还回复client上一条消息；
    server也发送请求断开通道；
    client受到消息结束
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180511102726949-1490489265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;5，定义一个学生类，然后。。。&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　__init__被称为构造方法或者初始化方法，在例实例化过程中自动执行，目的是初始化实例的一些属性，每个实例通过__init__初始化的属性都是独有的。&lt;/p&gt;
&lt;p&gt;　　self就是实例本身，你实例化时候python解释器就会自动把这个实例本身通过self参数传进去。&lt;/p&gt;
&lt;p&gt;　　这个object，就是经典类与新式类的问题了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1.只有在python2中才分新式类和经典类，python3中统一都是新式类

2.在python2中，没有显式的继承object类的类，以及该类的子类，都是经典类

3.在python2中，显式地声明继承object的类，以及该类的子类，都是新式类

4.在python3中，无论是否继承object，都默认继承object，即python3中所有类均为新式类
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# _*_ coding: utf-8 _*_ 
class Student(object):
    def __init__(self,name,age,sex):
        self.name = name
        self.sex = sex
        self.age = age

    def talk(self):
        print(&quot;hello,my name is %s &quot;%self.name)

p = Student('james',12,'male')
p.talk()
print(p.__dict__)
# 结果：
# hello,my name is james 
# {'name': 'james', 'sex': 'male', 'age': 12}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6，继承&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
继承：
    继承就是类与类的关系，是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类可以称为基类或超类，新建的类称为派生类或子类。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python中类的继承分为：单继承和多继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ParentClass1: #定义父类
    pass

class ParentClass2: #定义父类
    pass

class SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass
    pass

class SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类
    pass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看继承：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; SubClass1.__bases__ 
#__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类
(&amp;lt;class '__main__.ParentClass1'&amp;gt;,)
&amp;gt;&amp;gt;&amp;gt; SubClass2.__bases__
(&amp;lt;class '__main__.ParentClass1'&amp;gt;, &amp;lt;class '__main__.ParentClass2'&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7，多态&lt;/h3&gt;
&lt;p&gt;多态指一种事物有多种形态，那为什么要使用多态呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1.增加了程序的灵活性

　　以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)

2.增加了程序额可扩展性

　通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; class Cat(Animal): #属于动物的另外一种形态：猫
...     def talk(self):
...         print('say miao')
... 
&amp;gt;&amp;gt;&amp;gt; def func(animal): #对于使用者来说，自己的代码根本无需改动
...     animal.talk()
... 
&amp;gt;&amp;gt;&amp;gt; cat1=Cat() #实例出一只猫
&amp;gt;&amp;gt;&amp;gt; func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能
say miao

'''
这样我们新增了一个形态Cat，由Cat类产生的实例cat1，使用者可以在完全不需要修改
自己代码的情况下。使用和人、狗、猪一样的方式调用cat1的talk方法，即func(cat1)
'''
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;8，封装&lt;/h3&gt;
&lt;p&gt;首先说一下隐藏，在python中用双下划线开头的方式将属性隐藏起来（即设置成私有属性）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#其实这仅仅这是一种变形操作
#类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式：

class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置
成私有的如__N,会变形为_A__N
    def __init__(self):
        self.__X=10 #变形为self._A__X
    def __foo(self): #变形为_A__foo
        print('from A')
    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到.

#A._A__N是可以访问到的，即这种操作并不是严格意义上的限制外部访问，
仅仅只是一种语法意义上的变形
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;封装不是单纯意义上的隐藏&lt;/p&gt;
&lt;p&gt;1，封装数据&lt;/p&gt;
&lt;p&gt;　　将数据隐藏起来这不是目的。隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对数据属性操作的严格控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Teacher:
    def __init__(self,name,age):
        self.__name=name
        self.__age=age

    def tell_info(self):
        print('姓名:%s,年龄:%s' %(self.__name,self.__age))
    def set_info(self,name,age):
        if not isinstance(name,str):
            raise TypeError('姓名必须是字符串类型')
        if not isinstance(age,int):
            raise TypeError('年龄必须是整型')
        self.__name=name
        self.__age=age

t=Teacher('egon',18)
t.tell_info()

t.set_info('egon',19)
t.tell_info()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，封装方法，目的是隔离复杂度&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#取款是功能,而这个功能有很多功能组成:插卡、密码认证、输入金额、打印账单、取钱
#对使用者来说,只需要知道取款这个功能即可,其余功能我们都可以隐藏起来,很明显这么做
#隔离了复杂度,同时也提升了安全性

class ATM:
    def __card(self):
        print('插卡')
    def __auth(self):
        print('用户认证')
    def __input(self):
        print('输入取款金额')
    def __print_bill(self):
        print('打印账单')
    def __take_money(self):
        print('取款')

    def withdraw(self):
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

a=ATM()
a.withdraw()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;9，元类？ 使用元类定义一个对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
元类是类的类，是类的模板
元类是用来控制如何创建类的，正如类是创建对象的模板一样，而元类的主要目的是为了控制类的创建行为
元类的实例化的结果为我们用class定义的类，正如类的实例为对象(f1对象是Foo类的一个实例，
Foo类是 type 类的一个实例)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;10，说一下__new__和__init__的区别&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;根据官方文档：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;__init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是，__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。&lt;/p&gt;
&lt;p&gt;　　 在python2.x中，从object继承得来的类称为新式类（如class A(object)）不从object继承得来的类称为经典类（如class A()&lt;/p&gt;
&lt;p&gt;新式类跟经典类的差别主要是以下几点:&lt;/p&gt;
&lt;p&gt;　　1. 新式类对象可以直接通过__class__属性获取自身类型:type&lt;/p&gt;
&lt;p&gt;　　2. 继承搜索的顺序发生了改变,经典类多继承时属性搜索顺序: 先深入继承树左侧，再返回，开始找右侧（即深度优先搜索）;新式类多继承属性搜索顺序: 先水平搜索，然后再向上移动&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;经典类: 搜索顺序是(D,B,A,C)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; class A: attr = 1
...
&amp;gt;&amp;gt;&amp;gt; class B(A): pass
...
&amp;gt;&amp;gt;&amp;gt; class C(A): attr = 2
...
&amp;gt;&amp;gt;&amp;gt; class D(B,C): pass
...
&amp;gt;&amp;gt;&amp;gt; x = D()
&amp;gt;&amp;gt;&amp;gt; x.attr
1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新式类继承搜索程序是宽度优先&lt;/p&gt;
&lt;p&gt;新式类：搜索顺序是(D,B,C,A)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; class A(object): attr = 1
...
&amp;gt;&amp;gt;&amp;gt; class B(A): pass
...
&amp;gt;&amp;gt;&amp;gt; class C(A): attr = 2
...
&amp;gt;&amp;gt;&amp;gt; class D(B,C): pass
...
&amp;gt;&amp;gt;&amp;gt; x = D()
&amp;gt;&amp;gt;&amp;gt; x.attr
2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. 新式类增加了__slots__内置属性, 可以把实例属性的种类锁定到__slots__规定的范围之中。&lt;/p&gt;
&lt;p&gt;　　4. 新式类增加了__getattribute__方法&lt;/p&gt;
&lt;p&gt;　　5.新式类内置有__new__方法而经典类没有__new__方法而只有__init__方法&lt;/p&gt;
&lt;p&gt;注意：Python 2.x中默认都是经典类，只有显式继承了object才是新式类&lt;/p&gt;
&lt;p&gt;　　   而Python 3.x中默认都是新式类（也即object类默认是所有类的祖先），不必显式的继承object（可以按照经典类的定义方式写一个经典类并分别在python2.x和3.x版本中使用dir函数检验下。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class A()：
 
　　　　　　pass
 
　　　 print(dir(A))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;会发现在2.x下没有__new__方法而3.x下有。&lt;/p&gt;
&lt;p&gt;接下来说下__new__方法和__init__的区别：&lt;/p&gt;
&lt;p&gt;在python中创建类的一个实例时，如果该类具有__new__方法，会先调用__new__方法，__new__方法接受当前正在实例化的类作为第一个参数（这个参数的类型是type，这个类型在c和python的交互编程中具有重要的角色，感兴趣的可以搜下相关的资料），其返回值是本次创建产生的实例，也就是我们熟知的__init__方法中的第一个参数self。那么就会有一个问题，这个实例怎么得到？&lt;/p&gt;
&lt;p&gt;注意到有__new__方法的都是object类的后代，因此如果我们自己想要改写__new__方法（注意不改写时在创建实例的时候使用的是父类的__new__方法，如果父类没有则继续上溯）可以通过调用object的__new__方法类得到这个实例（这实际上也和python中的默认机制基本一致），如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class display(object):
  def __init__(self, *args, **kwargs):
    print(&quot;init&quot;)
  def __new__(cls, *args, **kwargs):
    print(&quot;new&quot;)
    print(type(cls))
    return object.__new__(cls, *args, **kwargs)  
a=display()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行上述代码会得到如下输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
new
 
&amp;lt;class 'type'&amp;gt;
 
init
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此我们可以得到如下结论：&lt;/p&gt;
&lt;p&gt;在实例创建过程中__new__方法先于__init__方法被调用，它的第一个参数类型为type。&lt;/p&gt;
&lt;p&gt;如果不需要其它特殊的处理，可以使用object的__new__方法来得到创建的实例（也即self)。&lt;/p&gt;
&lt;p&gt;于是我们可以发现，实际上可以使用其它类的__new__方法类得到这个实例，只要那个类或其父类或祖先有__new__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class another(object):
  def __new__(cls,*args,**kwargs):
    print(&quot;newano&quot;)
    return object.__new__(cls, *args, **kwargs)  
class display(object):
  def __init__(self, *args, **kwargs):
    print(&quot;init&quot;)
  def __new__(cls, *args, **kwargs):
    print(&quot;newdis&quot;)
    print(type(cls))
    return another.__new__(cls, *args, **kwargs)  
a=display()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的输出是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
newdis
&amp;lt;class 'type'&amp;gt;
newano
init
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有我们发现__new__和__init__就像这么一个关系，__init__提供生产的原料self(但并不保证这个原料来源正宗，像上面那样它用的是另一个不相关的类的__new__方法类得到这个实例)，而__init__就用__new__给的原料来完善这个对象（尽管它不知道这些原料是不是正宗的）&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;11，说一下深度优先和广度优先的区别&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
只有在python2中才分新式类和经典类，python3中统一都是新式类
2.在python2中，没有显式的继承object类的类，以及该类的子类，都是经典类
3.在python2中，显式地声明继承object的类，以及该类的子类，都是新式类
4.在python3中，无论是否继承object，都默认继承object，即python3中所有类均为新式类
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Java和C#中子类只能继承一个父类，而Python中子类可以同时继承多个父类，如果继承了多个父类，那么属性的查找方式有两种，分别是：深度优先和广度优先&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201803/1226410-20180330122137973-294138842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201803/1226410-20180330122146115-1381889823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示范代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class A(object):
    def test(self):
        print('from A')

class B(A):
    def test(self):
        print('from B')

class C(A):
    def test(self):
        print('from C')

class D(B):
    def test(self):
        print('from D')

class E(C):
    def test(self):
        print('from E')

class F(D,E):
    # def test(self):
    #     print('from F')
    pass
f1=F()
f1.test()
print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性

#新式类继承顺序:F-&amp;gt;D-&amp;gt;B-&amp;gt;E-&amp;gt;C-&amp;gt;A
#经典类继承顺序:F-&amp;gt;D-&amp;gt;B-&amp;gt;A-&amp;gt;E-&amp;gt;C
#python3中统一都是新式类
#pyhon2中才分新式类与经典类
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 12，说一下反射的原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;  反射就是通过字符串映射到对象的属性，python的一切事物都是对象（都可以使用反射）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1，hasattr(object,name)&lt;/strong&gt; &lt;code class=&quot;lang-py&quot;&gt;判断&lt;strong&gt;object中有没有对应的方法和属性&lt;/strong&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
判断object中有没有一个name字符串对应的方法或属性
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，getattr(object, name, default=None)  获取object中有没有对应的方法和属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3，setattr(x, y, v) 设置对象及其属性&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，delattr(x, y) 删除类或对象的属性&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;13，编写程序, 在元类中控制把自定义类的数据属性都变成大写.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Mymetaclass(type):
    def __new__(cls,name,bases,attrs):
        update_attrs={}
        for k,v in attrs.items():
            if not callable(v) and not k.startswith('__'):
                update_attrs[k.upper()]=v
            else:
                update_attrs[k]=v
        return type.__new__(cls,name,bases,update_attrs)
 
class Chinese(metaclass=Mymetaclass):
    country='China'
    tag='Legend of the Dragon' #龙的传人
    def walk(self):
        print('%s is walking' %self.name)
 
 
print(Chinese.__dict__)
'''
{'__module__': '__main__',
 'COUNTRY': 'China', 
 'TAG': 'Legend of the Dragon',
 'walk': &amp;lt;function Chinese.walk at 0x0000000001E7B950&amp;gt;,
 '__dict__': &amp;lt;attribute '__dict__' of 'Chinese' objects&amp;gt;,                                         
 '__weakref__': &amp;lt;attribute '__weakref__' of 'Chinese' objects&amp;gt;,
 '__doc__': None}
'''
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;14，编写程序, 在元类中控制自定义的类无需init方法.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　1.元类帮其完成创建对象，以及初始化操作；&lt;/p&gt;
&lt;p&gt;　　2.要求实例化时传参必须为关键字形式，否则抛出异常TypeError: must use keyword argument&lt;/p&gt;
&lt;p&gt;　　3.key作为用户自定义类产生对象的属性，且所有属性变成大写&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Mymetaclass(type):
    # def __new__(cls,name,bases,attrs):
    #     update_attrs={}
    #     for k,v in attrs.items():
    #         if not callable(v) and not k.startswith('__'):
    #             update_attrs[k.upper()]=v
    #         else:
    #             update_attrs[k]=v
    #     return type.__new__(cls,name,bases,update_attrs)
 
    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError('must use keyword argument for key function')
        obj = object.__new__(self) #创建对象，self为类Foo
 
        for k,v in kwargs.items():
            obj.__dict__[k.upper()]=v
        return obj
 
class Chinese(metaclass=Mymetaclass):
    country='China'
    tag='Legend of the Dragon' #龙的传人
    def walk(self):
        print('%s is walking' %self.name)
 
 
p=Chinese(name='egon',age=18,sex='male')
print(p.__dict__)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;15，简述静态方法和类方法&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1：绑定方法（绑定给谁，谁来调用就自动将它本身当作第一个参数传入）：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;strong&gt;　　绑定方法分为绑定到类的方法和绑定到对象的方法，具体如下：&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1. 绑定到类的方法：用classmethod装饰器装饰的方法。
                为类量身定制
                类.boud_method(),自动将类当作第一个参数传入
              （其实对象也可调用，但仍将类当作第一个参数传入）
 
2. 绑定到对象的方法：没有被任何装饰器装饰的方法。
               为对象量身定制
               对象.boud_method(),自动将对象当作第一个参数传入
             （属于类的函数，类可以调用，但是必须按照函数的规则来，没有自动传值那么一说）
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2：非绑定方法：用staticmethod装饰器装饰的方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1. 不与类或对象绑定，类和对象都可以调用，但是没有自动传值那么一说。就是一个普通工具而已
　　　　注意：与绑定到对象方法区分开，在类中直接定义的函数，没有被任何装饰器
    装饰的，都是绑定到对象的方法，可不是普通函数，对象调用该方法会自动传值，而
    staticmethod装饰的方法，不管谁来调用，都没有自动传值一说
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体见：&lt;a href=&quot;http://www.cnblogs.com/wj-1314/p/8675548.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/wj-1314/p/8675548.html&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;3，类方法与静态方法说明&lt;/h4&gt;
&lt;p&gt;　　1：self表示为类型为类的object，而cls表示为类也就是class&lt;/p&gt;
&lt;p&gt;　　2：在定义普通方法的时候，需要的是参数self,也就是把类的实例作为参数传递给方法，如果不写self的时候，会发现报错TypeError错误，表示传递的参数多了，其实也就是调用方法的时候，将实例作为参数传递了，在使用普通方法的时候，使用的是实例来调用方法，不能使用类来调用方法，没有实例，那么方法将无法调用。&lt;/p&gt;
&lt;p&gt;　　3：在定义静态方法的时候，和模块中的方法没有什么不同，最大的不同就是在于静态方法在类的命名空间之间，而且在声明静态方法的时候，使用的标记为@staticmethod，表示为静态方法，在叼你用静态方法的时候，可以使用类名或者是实例名来进行调用，一般使用类名来调用&lt;/p&gt;
&lt;p&gt;　　4：静态方法主要是用来放一些方法的，方法的逻辑属于类，但是有何类本身没有什么交互，从而形成了静态方法，主要是让静态方法放在此类的名称空间之内，从而能够更加有组织性。&lt;/p&gt;
&lt;p&gt;　　5：在定义类方法的时候，传递的参数为cls.表示为类，此写法也可以变，但是一般写为cls。类的方法调用可以使用类，也可以使用实例，一般情况使用的是类。&lt;/p&gt;
&lt;p&gt;　　6：在重载调用父类方法的时候，最好是使用super来进行调用父类的方法。静态方法主要用来存放逻辑性的代码，基本在静态方法中，不会涉及到类的方法和类的参数。类方法是在传递参数的时候，传递的是类的参数，参数是必须在cls中进行隐身穿&lt;/p&gt;
&lt;p&gt;　　7：python中实现静态方法和类方法都是依赖python的修饰器来实现的。静态方法是staticmethod，类方法是classmethod。&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 02:30:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9023916.html</dc:identifier>
</item>
<item>
<title>JSON Patch - 白细胞</title>
<link>http://www.cnblogs.com/Wddpct/p/9039466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wddpct/p/9039466.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;1.前言&lt;/h3&gt;
&lt;p&gt;可以这么说的是，任何一种非强制性约束同时也没有“标杆”工具支持的开发风格或协议（仅靠文档是远远不够的），最终的实现上都会被程序员冠上“务实”的名头，而不管成型了多少个版本，与最初的设计有什么区别。DDD 是如此，微服务是如此，REST 也是如此。&lt;/p&gt;
&lt;p&gt;虽然这也不难理解，风格从一开始被创造出来后，便不再属于作者了。所以仍然把你的符合以下标准&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;满足以资源形式定义定义 Uri&lt;/li&gt;
&lt;li&gt;满足以 HTTP 谓词语义增删改查资源&lt;/li&gt;
&lt;li&gt;符合命名要求&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;的“不标准” Web API 看作是 RESTful 的，也未尝不可。毕竟，谁在乎呢？&lt;/p&gt;
&lt;p&gt;更深层次的讨论参见&lt;a href=&quot;https://www.infoq.com/articles/web-api-rest&quot;&gt;Why Some Web APIs Are Not RESTful and What Can Be Done About It&lt;/a&gt;。什么才是真正的 REST Api 并不是本文的重点（&lt;a href=&quot;https://developer.github.com/v3/&quot;&gt;Github Rest API v3&lt;/a&gt;），笔者在后文讨论的具体实现，也只是符合目前流行的“RESTful”直觉设计。&lt;/p&gt;
&lt;h3 id=&quot;http-谓词&quot;&gt;2. HTTP 谓词&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;用于获取资源的 HTTP Header 信息&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;用于检索信息&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;用于创建资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;用于更新或替换完整资源或批量更新集合。对于没有 &lt;code&gt;Body&lt;/code&gt; 的 PUT 动作，请将 &lt;code&gt;Content-Length&lt;/code&gt; 设置为 0&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;用于删除资源&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;用于使用部分 JSON 数据更新资源信息（在一个请求里可搭载多个动作）。PATCH 是一个相对较新的 HTTP 谓词，在客户端或服务器不支持 PATCH 动作时，也可以使用 Post/Put 更新资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;patch-json-patch&quot;&gt;3. PATCH &amp;amp; JSON Patch&lt;/h3&gt;
&lt;p&gt;结合上述 HTTP 谓词，通常情况下，更新部分资源的部分数据时，有以下四种做法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 PUT 谓词， 尽可能使用完整对象来更新资源（即根本不使用 PATCH ）。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;JSON Merge Patch&lt;/a&gt; 更新部分资源的部分数据（需要使用指定 MIME &lt;code&gt;application/merge-patch+json&lt;/code&gt; 来表示）。&lt;/li&gt;
&lt;li&gt;使用 PATCH 谓词和 &lt;a href=&quot;https://tools.ietf.org/html/rfc6902&quot;&gt;JSON Patch&lt;/a&gt;（需要使用指定 MIME &lt;code&gt;application/json-patch+json&lt;/code&gt; 来表示）&lt;/li&gt;
&lt;li&gt;如果请求不以 MIME 的语义定义的方式修改资源，使用具有合理描述的 POST 谓词。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我相信大部分系统中，采取的都是第1种和第4种做法，而本文的主题则是第3种做法。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt;（PATCH method for HTTP） 中，有一个关于 PATCH 请求的小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: &quot;e0023aa4e&quot;
Content-Length: 100

[description of changes]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;[description of changes]&lt;/code&gt; 代表对目标资源的一系列操作，而&lt;code&gt;JSON Patch&lt;/code&gt;则是描述操作的文档格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// 示例 json 文档
{
    &quot;a&quot;:{
        &quot;b&quot;:{
            &quot;c&quot;:&quot;foo&quot;
        }
    }
}

// JSON Patch 操作
[
  { &quot;op&quot;: &quot;test&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: &quot;foo&quot; },
  { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/a/b/c&quot; },
  { &quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: [ &quot;foo&quot;, &quot;bar&quot; ] },
  { &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: 42 },
  { &quot;op&quot;: &quot;move&quot;, &quot;from&quot;: &quot;/a/b/c&quot;, &quot;path&quot;: &quot;/a/b/d&quot; },
  { &quot;op&quot;: &quot;copy&quot;, &quot;from&quot;: &quot;/a/b/d&quot;, &quot;path&quot;: &quot;/a/b/e&quot; }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个&lt;code&gt;JSON Patch&lt;/code&gt;的例子中，&lt;code&gt;op&lt;/code&gt;代表操作类型，&lt;code&gt;from&lt;/code&gt;和&lt;code&gt;path&lt;/code&gt;代表目标 json 的层级路径，&lt;code&gt;value&lt;/code&gt;代表操作值。相关语义想必大家都能直接读出来，更多的信息请参考&lt;a href=&quot;http://jsonpatch.com/&quot;&gt;What is JSON Patch?&lt;/a&gt;和 &lt;a href=&quot;https://tools.ietf.org/html/rfc6902&quot;&gt;RFC JSON Patch&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;示例应用&quot;&gt;示例应用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wddpct/articles/tree/master/JsonPatch/AspNetCoreJsonPatch&quot;&gt;示例程序&lt;/a&gt;引入了&lt;code&gt;swagger&lt;/code&gt;，&lt;code&gt;MongoDB&lt;/code&gt;，&lt;code&gt;docker-compose&lt;/code&gt;等功能，关于 JsonPatch 的部分则使用微软官方的 &lt;a href=&quot;https://github.com/aspnet/JsonPatch&quot;&gt;JsonPatch&lt;/a&gt; 编写，该库支持&lt;code&gt;add&lt;/code&gt;，&lt;code&gt;remove&lt;/code&gt;，&lt;code&gt;replace&lt;/code&gt;，&lt;code&gt;move&lt;/code&gt;，&lt;code&gt;copy&lt;/code&gt;方法，实现并不困难。实际使用时，直接以&lt;code&gt;JsonPatchDocument&amp;lt;T&amp;gt;&lt;/code&gt;作为包装即可。&lt;/p&gt;
&lt;p&gt;MongoDB 客户端推荐注册为单例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IMongoDatabaseProvider
{
    IMongoDatabase Database { get; }
}

public class MongoDatabaseProvider : IMongoDatabaseProvider
{
    private readonly IOptions&amp;lt;Settings&amp;gt; _settings;

    public MongoDatabaseProvider(IOptions&amp;lt;Settings&amp;gt; settings)
    {
        _settings = settings;
    }

    public IMongoDatabase Database
    {
        get
        {
            var client = new MongoClient(_settings.Value.ConnectionString);
            return client.GetDatabase(_settings.Value.Database);
        }
    }
}

/* Startup/ConfigureServices.cs */
public void ConfigureServices(IServiceCollection services)
{
    …
    services.AddSingleton&amp;lt;IMongoDatabaseProvider, MongoDatabaseProvider&amp;gt;();
    …
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;appsettings.json&lt;/code&gt;文件中的数据库配置部分则为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;ConnectionString&quot;: &quot;mongodb://mongodb&quot;,
  &quot;Database&quot;: &quot;ExampleDb&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;对 web 应用和 MongoDB 的配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3.4'

services:
  aspnetcorejsonpatch:
    image: aspnetcorejsonpatch
    build:
      context: .
      dockerfile: AspNetCoreJsonPatch/Dockerfile
    depends_on:
      - mongodb
    ports:
      - &quot;8080:80&quot;
  mongodb:
    image: mongo
    ports:
      - &quot;27017:27017&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动时，定位到&lt;code&gt;docker-compose.yml&lt;/code&gt;所在文件夹，运行&lt;code&gt;docker-compose up&lt;/code&gt;，然后在浏览器访问&lt;code&gt;localhost:8080/swagger&lt;/code&gt;，应用在启动后会自动创建&lt;code&gt;ExampleDb&lt;/code&gt;数据库并插入一条数据。笔者也写了一个获取信息的接口&lt;code&gt;/api/Persons&lt;/code&gt;，返回值如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
  {
    &quot;name&quot;: &quot;LeBron James&quot;,
    &quot;oId&quot;: &quot;5af995a5b8ea8500018d54b7&quot;
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再使用返回的&lt;code&gt;oId&lt;/code&gt;请求&lt;code&gt;/api/Persons/{id}&lt;/code&gt;（&lt;code&gt;UpdateThenAddThenRemoveAsync&lt;/code&gt;）接口，&lt;code&gt;body&lt;/code&gt;的 JsonPatch 描述则用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* body */
[
  {
    &quot;value&quot;: &quot;Daby&quot;,
    &quot;path&quot;: &quot;FirstName&quot;,
    &quot;op&quot;: &quot;replace&quot;
  },
  {
    &quot;value&quot;: &quot;Example Address&quot;,
    &quot;path&quot;: &quot;Address&quot;,
    &quot;op&quot;: &quot;add&quot;
  },
  {
    &quot;path&quot;: &quot;Mail&quot;,
    &quot;op&quot;: &quot;remove&quot;
  }
]

/* PersonsController.cs */
[HttpPatch(&quot;{id}&quot;)]
public async Task&amp;lt;PersonDto&amp;gt; UpdateThenAddThenRemoveAsync(string id,
    [FromBody] JsonPatchDocument&amp;lt;Person&amp;gt; personPatch)
{
    var objectId = new ObjectId(id);

    var person = await _personRepository.GetAsync(objectId);

    personPatch.ApplyTo(person);

    await _personRepository.UpdateAsync(person);

    return new PersonDto
    {
        OId = person.Id.ToString(),
        Name = $&quot;{person.FirstName} {person.LastName}&quot;
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他相关代码另请查阅。不过需要再提一点的是，Visual Studio 15.7 版本对&lt;code&gt;docker-compose.yml&lt;/code&gt;的文本语法解析有些问题，详见&lt;a href=&quot;https://github.com/Microsoft/DockerTools/issues/98&quot;&gt;MSBuild failing to parse a valid compose file&lt;/a&gt;，比如以下代码将无法编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://0.0.0.0:80
      - ConnectionString=${MONGODB:-mongodb://mongodb}
      - Database=ExampleDb&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://jsonpatch.com/&quot;&gt;JSON Patch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.github.com/v3/&quot;&gt;Github v3 API&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 15 May 2018 02:07:00 +0000</pubDate>
<dc:creator>白细胞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wddpct/p/9039466.html</dc:identifier>
</item>
<item>
<title>由清除float原理到BFC - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/8371314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/8371314.html</guid>
<description>&lt;h2 id=&quot;关于浮动&quot;&gt;关于浮动&lt;/h2&gt;
&lt;p&gt;设置为浮动的元素会脱离当前文档流，向左或向右移动直到边缘遇到另一个浮动元素或者到达边界。普通元素不会对齐造成影响。&lt;br/&gt;浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。如下图所示：&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.warper&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;#ff6633&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.float-1&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.float-2&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#ff0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;50px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
//html  
&amp;lt;div class=&lt;span class=&quot;st&quot;&gt;'warper'&lt;/span&gt;&amp;gt;
    &amp;lt;div class=&lt;span class=&quot;st&quot;&gt;&quot;float-1&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&lt;span class=&quot;st&quot;&gt;&quot;float-2&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/15/16361662e63b0dc5?w=558&amp;amp;h=248&amp;amp;f=png&amp;amp;s=8275&quot;/&gt;&lt;br/&gt;可以看到父元素的高度为0,为了解决这种状况就要清除浮动了。&lt;/p&gt;
&lt;h3 id=&quot;清楚浮动的方式&quot;&gt;清楚浮动的方式&lt;/h3&gt;
&lt;p&gt;总结了一下，大致有如下几类:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结尾空元素或者after等伪元素或者br 来clear&lt;/li&gt;
&lt;li&gt;父元素同样浮动&lt;/li&gt;
&lt;li&gt;父元素设置overflow为hidden或者auto&lt;/li&gt;
&lt;li&gt;父元素display：table&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;大致归类，可以分为两大类，1使用clear的属性，后面的可以归为一类，都是通过触发BFC来实现的。&lt;br/&gt;下面详细看一下这两大类清除浮动的方式及原理。&lt;/p&gt;
&lt;h4 id=&quot;clear属性&quot;&gt;clear属性&lt;/h4&gt;
&lt;p&gt;clear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。&lt;br/&gt;换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。&lt;br/&gt;第一种方式里我们的填补元素(我自己的称呼)，就是起这种作用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;//这里当然可以换成一个空的div，&amp;lt;br/&amp;gt;等，原理和效果都是一致的  
&lt;span class=&quot;fl&quot;&gt;.warper&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;:after&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;clear:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时after伪元素设置clear：both之后表明，我两边都不能接受浮动元素，原本受浮动元素影响，伪元素的位置在浮动元素下方如图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/15/16361691804ddc5a?w=464&amp;amp;h=252&amp;amp;f=png&amp;amp;s=14821&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样显然也不能撑起父元素的高度。设置之后，需要重新安排安排了。既然两边都不接受浮动元素，但浮动元素位置也确定了，那只能把伪元素放在下边，如图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/15/1636169181124ab4?w=558&amp;amp;h=336&amp;amp;f=png&amp;amp;s=16922&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，伪元素的位置在最下方了，距顶部的高度为float元素的高度，顺带撑起了父元素的高度。同样适用其他填充元素（display为block），都能达到相同的目的。&lt;br/&gt;在看后面几种原理之前我们需要先看一下BFC的定义。&lt;/p&gt;
&lt;h3 id=&quot;bfc&quot;&gt;BFC&lt;/h3&gt;
&lt;h4 id=&quot;块级格式化上下文bfcblock-formatting-contexts&quot;&gt;块级格式化上下文：BFC(block formatting contexts)&lt;/h4&gt;
&lt;p&gt;照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。&lt;br/&gt;借用张鑫旭大大的一句话，BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。&lt;/p&gt;
&lt;p&gt;正如下面的解释：&lt;/p&gt;
&lt;p&gt;In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats)&lt;br/&gt;在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。&lt;br/&gt;即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。&lt;/p&gt;
&lt;h4 id=&quot;bfc的特性&quot;&gt;BFC的特性&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;块级格式化上下文会阻止外边距叠加&lt;/li&gt;
&lt;li&gt;块级格式化上下文不会重叠浮动元素&lt;/li&gt;
&lt;li&gt;块级格式化上下文通常可以包含浮动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;换句话说创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然.&lt;br/&gt;同时BFC任然属于文档中的普通流。所以呢浮动也就解决了，关于BFC以后要专门搞个文章仔细研究一下。&lt;/p&gt;
&lt;p&gt;看到这里就可以知道了，为什么可以拿来清除浮动了&lt;br/&gt;表现为BFC的元素都是一个十分个性的存在，无论里面怎么折腾，对外表现始终如一。&lt;br/&gt;大家肯定可以猜到，上面几种利用了BFC的清除方式肯定是触发了BFC的条件，让父元素变为BFC。我们来看一下触发BFC的条件，看是不是如我们所想。&lt;/p&gt;
&lt;h4 id=&quot;bfc触发条件&quot;&gt;BFC触发条件&lt;/h4&gt;
&lt;p&gt;CSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;float 除了none以外的值 
 
overflow 除了visible 以外的值（hidden，auto，scroll ） 
 
&lt;span class=&quot;at&quot;&gt;display&lt;/span&gt; (table&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;cell，table&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;caption，inline&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;block) 
 
position（absolute，fixed） 
 
fieldset元素&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上面可以对比一下，我们提到那几种方法，就是触发了BFC而已。&lt;br/&gt;看个例子&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.warper&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;200px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;#ff6633&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;下面属性任选其一&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;overflow:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;overflow:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;float:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;inline-block&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;fixed&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/15/16361691813da284?w=640&amp;amp;h=324&amp;amp;f=png&amp;amp;s=14755&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/&quot;&gt;CSS深入理解流体特性和BFC特性下多栏自适应布局&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html&quot;&gt;理解CSS中BFC&lt;/a&gt;&lt;br/&gt;到这里清除float相关的内容就说完了，知其然更要知其所以然，清除float的方式繁多无比，掌握其中原理才能不人云亦云。当然抛砖引玉，更多的是共同学习共同进步,&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/blog&quot;&gt;更多请移步博客&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 01:38:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/8371314.html</dc:identifier>
</item>
<item>
<title>小隐隐于野：基于TCP反射DDoS攻击分析 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9039227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9039227.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：腾讯DDoS安全专家、腾讯云游戏安全专家 陈国&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;近期，腾讯云防护了一次针对云上某游戏业务的混合DDoS攻击。攻击持续了31分钟，流量峰值194Gbps。这个量级的攻击流量放在当前并没有太过引人注目的地方，但是腾讯云游戏安全专家团在详细复盘攻击手法时发现，混合攻击流量中竟混杂着利用TCP协议发起的反射攻击，现网极其少见。&lt;/p&gt;
&lt;p&gt;众所周知，现网黑客热衷的反射攻击，无论是传统的NTP、DNS、SSDP反射，近期大火的Memcached反射，还是近期出现的IPMI反射，无一例外的都是基于UDP协议。而本次攻击则是另辟蹊径地利用TCP协议发起反射攻击。本文将对这种攻击手法做简单分析和解读，并为广大互联网及游戏行业朋友分享防护建议。&lt;/p&gt;

&lt;p&gt;本轮攻击混合了SYNFLOOD、RSTFLOOD、ICMPFLOOD等常见的DDoS攻击，攻击流量峰值达到194Gbps。但是其中混杂着1.98Gbps/194wpps的syn/ack(syn、ack标志位同时置位，下同)小包引起研究人员的注意。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/v11e7uk8yp.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;首先，syn/ack源端口集聚在80、8080、23、22、443等常用的TCP端口，目的端口则是被攻击的业务端口80(而正常情况下客户端访问业务时，源端口会使用1024以上的随机端口)。&lt;/p&gt;
&lt;p&gt;除此之外，研究人员还发现这些源IP的syn/ack报文存在TCP协议栈超时重传行为。为此研究人员判断这次很有可能是利用TCP协议发起的TCP反射攻击，并非一般随机伪造源TCP DDoS。&lt;/p&gt;
&lt;p&gt;经统计分析：攻击过程中共采集到912726个攻击源，通过扫描确认开启TCP端口：21/22/23/80/443/8080/3389/81/1900的源占比超过95%，很明显这个就是利用现网TCP协议发起的反射攻击。攻击源IP端口存活情况如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201805/1112679-20180514154922752-146755656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;备注：由于存在单个IP可能存活多个端口，所以占比总和会超过100%。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从源IP归属地上分析，攻击来源几乎全部来源中国，国内源IP占比超过99.9%，攻击源国家分布如下:&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/yx3r98sym4.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从国内省份维度统计，源IP几乎遍布国内所有省市，其中TOP 3来源省份分布是广东(16.9%)、江苏(12.5%)、上海(8.8%)。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/xxg4zbmsez.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/g94tp2xggl.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在攻击源属性方面，IDC服务器占比58%， 而IoT设备和PC分别占比36%、6%。由此可见：攻击来源主要是IDC服务器。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/zzaxhn7ijj.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;与UDP反射攻击思路类似，攻击者发起TCP反射攻击的大致过程如下：&lt;/p&gt;
&lt;p&gt;1、 攻击者通过IP地址欺骗方式，伪造目标服务器IP向公网上的TCP服务器发起连接请求(即syn包)；&lt;/p&gt;
&lt;p&gt;2、 TCP服务器接收到请求后，向目标服务器返回syn/ack应答报文，就这样目标服务器接收到大量不属于自己连接进程的syn/ack报文，最终造成带宽、CPU等资源耗尽，拒绝服务。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1024461/eu32zjdpk1.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;可能有人会疑惑：反射造成的syn/ack报文长度比原始的syn报文更小，根本没有任何的放大效果，那为何黑客要采用这种攻击手法呢？其实这种攻击手法的厉害之处，不在于流量是否被放大，而是以下三点：&lt;/p&gt;
&lt;p&gt;1、 利用TCP反射，攻击者可以使攻击流量变成真实IP攻击，传统的反向挑战防护技术难以有效防护；&lt;/p&gt;
&lt;p&gt;2、 反射的syn/ack报文存在协议栈行为，使防护系统更难识别防护，攻击流量透传几率更高；&lt;/p&gt;
&lt;p&gt;3、 利用公网的服务器发起攻击，更贴近业务流量，与其他TCP攻击混合后，攻击行为更为隐蔽。&lt;/p&gt;
&lt;p&gt;为此，TCP反射攻击相比传统伪造源的TCP攻击手法，具有隐蔽性更强、攻击手法更难防御的特点。&lt;/p&gt;

&lt;p&gt;纵使这种TCP反射攻击手法小隐隐于野，要防范起来比一般的攻击手法困难一些，但成功应对并非难事。&lt;/p&gt;
&lt;p&gt;1、根据实际情况，封禁不必要的TCP源端口，建议接入腾讯云新一代高防解决方案，可提供灵活的高级安全策略；&lt;/p&gt;
&lt;p&gt;2、建议配置BGP高防IP+三网高防IP，隐藏源站IP，接入腾讯云新一代解决方案BGP高防；&lt;/p&gt;
&lt;p&gt;3、在面对高等级DDoS威胁时，接入云计算厂商的行业解决方案，必要时请求DDoS防护厂商的专家服务。&lt;/p&gt;

&lt;p&gt;腾讯云游戏安全团队在防护住一轮针对云上游戏业务的DDoS攻击后，对攻击手法做详细分析过程中发现黑客使用了现网极为少见的TCP反射攻击，该手法存在特性包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;攻击报文syn/ack置位；&lt;/li&gt;
&lt;li&gt;源端口集聚在80/443/22/21/3389等常用的TCP服务端口，而且端口的源IP+端口真实存活；&lt;/li&gt;
&lt;li&gt;syn/ack报文tcp协议栈行为超时重传行为；&lt;/li&gt;
&lt;li&gt;源IP绝大部分来源国内，且分散在全国各个省份；&lt;/li&gt;
&lt;li&gt;流量大部分来源于IDC服务器；&lt;/li&gt;
&lt;li&gt;由于攻击源真实，且存在TCP协议栈行为，防护难度更大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上所述：黑客利用互联网上的TCP服务器发起TCP反射攻击，相比常见的随机伪造源攻击，TCP反射攻击有着更为隐蔽，防护难度更大等特点，对DDoS安全防护将是一个新的挑战。&lt;/p&gt;
&lt;p&gt;腾讯云宙斯盾DDoS防护系统核心底层来自于腾讯安全平台部，沉淀腾讯业务十余年DDoS攻防对抗经验，具有业内先进的DDoS检测/防护算法，同时引入了AI、大数据领先的防护方案，服务于QQ、微信、王者荣耀、英雄联盟、CF、绝地求生等多款腾讯内部业务，能够有效抵御各类型DDoS和CC攻击行为，提供先进可靠的DDoS防护服务，致力于保障游戏客户业务的安全、稳定。&lt;/p&gt;
&lt;p&gt;腾讯安全应急响应中心也将携宙斯盾防护系统亮相&lt;strong&gt;5月2&lt;/strong&gt;&lt;strong&gt;3-24&lt;/strong&gt;&lt;strong&gt;日的腾讯云2018云&lt;/strong&gt;&lt;strong&gt;+未来峰会&lt;/strong&gt;展区和游戏分论坛，届时欢迎各位游戏行业和安全界人士一起莅临峰会，共话DDoS攻防。&lt;/p&gt;
&lt;p&gt;2018腾讯云云+未来峰会报名入口：&lt;a href=&quot;https://cloud.tencent.com/developer/summit/2018-guangzhou&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/developer/summit/2018-guangzhou&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5426829268293&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ask-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/24903?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;如何防范DDos攻击？&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;ask-title&quot;&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1090965?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;1.23T，腾讯云成功防御了国内最大流量DDoS攻击&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1116177?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;初识常见DDoS攻击手段&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1087955?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;深入浅出DDoS攻击防御&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1121916?fromSource=waitui&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180330104936874-1573429539.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 01:21:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9039227.html</dc:identifier>
</item>
<item>
<title>面对海量请求，缓存设计还应该考虑哪些问题？ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/how_to_deal_with_massive_request_in_redis.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/how_to_deal_with_massive_request_in_redis.html</guid>
<description>&lt;p&gt;从第一个缓存框架 Memcached 诞生以来，缓存就广泛地存在于互联网应用中。如果你的应用流量很小，那么使用缓存可能并不需要做多余的考虑。但如果你的应用流量达到了成百上千万，那么你就不得不考虑深层次的缓存问题：&lt;strong&gt;缓存穿透、缓存击穿与缓存雪崩&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;缓存穿透&quot;&gt;缓存穿透&lt;/h2&gt;
&lt;p&gt;缓存穿透是指查询一个一定不存在的数据，因为这个数据不存在，所以永远不会被缓存，所以每次请求都会去请求数据库。&lt;/p&gt;
&lt;p&gt;例如我们请求一个 UserID 为 -1 的用户数据，因为该用户不存在，所以该请求每次都会去读取数据库。在这种情况下，如果某些心怀不轨的人利用这个存在的漏洞去伪造大量的请求，那么很可能导致DB承受不了那么大的流量就挂掉了。&lt;/p&gt;
&lt;p&gt;对于缓存穿透，有几种解决方案，一种是事前预防，一种是事后预防。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事前预防。&lt;/strong&gt;其实就是对所有请求都进行参数校验，把绝大多数非法的请求抵挡在最外层。在我们举的这个例子中，那么就是做参数校验，对于 UserID 小于 0 的请求全部拒绝。但即使我们做了全面的参数校验，还是可能存在漏网之鱼，会出现一些我们没想到的情况。&lt;/p&gt;
&lt;p&gt;例如我们的 UserID 是递增的，那么如果有人请求一个 UserID 很大的用户信息（例如：1000000），而我们的 UserID 最大也就 10000。这个时候，你不可能限制 UserID 大于 1 万的就是非法的，或者说大于 10 万就是非法的，所以该用户ID肯定可以通过参数校验。但该用户确实不存在，所以每次请求都会去请求数据库。&lt;/p&gt;
&lt;p&gt;其实上面只是我所能想到的一种情况，我们没想到的情况肯定还有很多。对于这些情况，我们能做的就是时候预防。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事后预防。&lt;/strong&gt;事后预防说的就是当查询到一个空的结果时，我们仍然将这个空的结果进行缓存，但是设置一个很短的过期时间（例如一分钟）。在这里我们可以看到，其实我们并没有完全预防非法请求，只不过是将非法请求的风险让承受能力更强的redis去承担，让承受能力稍弱的数据库更安全。&lt;/p&gt;
&lt;p&gt;通过上面这两种处理方式，我们基本可以解决缓存穿透的问题。事前预防解决80%的非法请求，剩下的20%非法请求则使用Redis转移风险。&lt;/p&gt;
&lt;h2 id=&quot;缓存击穿&quot;&gt;缓存击穿&lt;/h2&gt;
&lt;p&gt;如果你的应用中有一些访问量很高的热点数据，我们一般会将其放在缓存中以提高访问速度。另外，为了保持时效性，我们通常还会设置一个过期时间。但是对于这些访问量很高的KEY，我们需要考虑一个问题：&lt;strong&gt;当热点KEY在失效的瞬间，海量的请求会不会产生大量的数据库请求，从而导致数据库崩溃？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如我们有一个业务 KEY，该 KEY 的并发请求量为 10000。当该 KEY 失效的时候，就会有 1 万个线程会去请求数据库更新缓存。这个时候如果没有采取适当的措施，那么数据库很可能崩溃。&lt;/p&gt;
&lt;p&gt;其实上面这个问题就是缓存击穿的问题，它发生在缓存KEY的过期瞬间。对于这种情况，现在常用的解决方式有这么两种：&lt;strong&gt;互斥锁、永远不过期。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;互斥锁&quot;&gt;互斥锁&lt;/h3&gt;
&lt;p&gt;互斥锁指的是在缓存KEY过期去更新的时候，先让程序去获取锁，只有获取到锁的线程才有资格去更新缓存KEY。其他没有获取到锁的线程则休眠片刻之后再次去获取最新的缓存数据。通过这种方式，同一时刻永远只有一个线程会去读取数据库，这样也就避免了海量数据库请求对于数据库的冲击。&lt;/p&gt;
&lt;p&gt;而对于上面说到的锁，我们可以使用缓存提供的一些原则操作来完成。例如对于 redis 缓存来说，我们可以使用其 SETNX 命令来完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String get(key) {  
    String value = redis.get(key);  
    if (value == null) { //缓存过期  
        if (redis.setnx(key_mutex, 1, 1 * 60) == 1) {   
                value = db.get(key);  
                redis.set(key, value, expireTime);  
                redis.del(key_mutex);  
            } else {  
                //休眠片刻后重试
                sleep(50);  
                get(key);   
            }  
        } else {  
            return value;        
    }  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 key_mutex 其实就是一个普通的 KEY-VALUE 值，我们使用 setnx 命令去设置其值为 1。如果这时候已经有人在更新缓存KEY了，那么 setnx 命令会返回 0，表示设置失败。&lt;/p&gt;
&lt;h3 id=&quot;永远不过期&quot;&gt;永远不过期&lt;/h3&gt;
&lt;p&gt;从缓存的角度来看，如果你设置了永远不过期，那么就不会有海量请求数据库的情形出现。此时我们一般通过新起一个线程的方式去&lt;strong&gt;定时将数据库中的数据更新到缓存中&lt;/strong&gt;，更加成熟的方式是通过&lt;strong&gt;定时任务去同步缓存和数据库的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但这种方案会出现数据的延迟问题，也就是线程读取到的数据并不是最新的数据。但对于一般的互联网功能来说，些许的延迟还是能接受的。&lt;/p&gt;
&lt;h2 id=&quot;缓存雪崩&quot;&gt;缓存雪崩&lt;/h2&gt;
&lt;p&gt;缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，最终导致数据库瞬时压力过大而崩溃。&lt;/p&gt;
&lt;p&gt;例如我们有 1000 个KEY，而每个 KEY 的并发请求不大，只有 10 次。而缓存雪崩指的就是这 1000 个 KEY 在同一时间，同时失效，这个时候就突然有 1000 ** 10 = 一万次查询。&lt;/p&gt;
&lt;p&gt;缓存雪崩导致的问题一般很难排查，如果没有事先预防，很可能要花很大力气才能找得到原因。对于缓存雪崩的情况，&lt;strong&gt;最简单的方案就是在原有失效时间的基础上增加一个随机时间（例如1-5分钟）&lt;/strong&gt;，这样每个缓存过期时间的重复率就会降低，从而减少缓存雪崩的发生。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对于缓存穿透、缓存击穿、缓存雪崩这三个情景，许多人会搞不明白，甚至会混淆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「缓存穿透」&lt;/strong&gt;指的是请求不存在的数据，从而使得缓存形同虚设，缓存层被穿透了。例如我们请求一个 UserID 为 -1 的用户数据，因为该用户不存在，所以该请求每次都会去读取数据库。在这种情况下，如果某些心怀不轨的人利用这个存在的漏洞去伪造大量的请求，那么很可能导致DB承受不了那么大的流量就挂掉了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「缓存击穿」&lt;/strong&gt;指的是并发量很高的 KEY，在该 KEY 失效的瞬间有很多请求同同时去请求数据库，更新缓存。例如我们有一个业务 KEY，该 KEY 的并发请求量为 10000。当该 KEY 失效的时候，就会有 1 万个线程会去请求数据库更新缓存。这个时候如果没有采取适当的措施，那么数据库很可能崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「缓存雪崩」&lt;/strong&gt;则是指缓存在同一时间同时过期，就像所有雪块同一时刻掉下来，像雪崩一样。例如我们有 1000 个KEY，而每个 KEY 的并发请求不大，只有 10 次。而缓存雪崩指的就是这 1000 个 KEY 在同一时间，同时失效，这个时候就突然有 1000 ** 10 = 一万次查询。&lt;/p&gt;
&lt;p&gt;对于它们出现的情形，我们可以做一些总结：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「缓存穿透」&lt;/strong&gt;是业务层面的漏洞导致非法请求，与请求量、缓存失效没关系。&lt;strong&gt;「缓存击穿」&lt;/strong&gt;则只会出现在热点数据上，发生在缓存失效的瞬间，与业务没多大关系。&lt;strong&gt;「缓存雪崩」&lt;/strong&gt;则是因为多个 KEY 同时失效，导致数据库请求太多。非热点数据也会导致缓存雪崩，只要同时失效的 KEY 足够多。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;如果觉得文章还不错，记得点赞评论，那我以后就会写更多类似的文章！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 15 May 2018 01:08:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/how_to_deal_with_massive_request_in_redis.html</dc:identifier>
</item>
<item>
<title>Java CAS 原理分析 - coolblog.xyz</title>
<link>http://www.cnblogs.com/nullllun/p/9039049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullllun/p/9039049.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1.简介&lt;/h2&gt;
&lt;p&gt;CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制（可以把 CAS 看做乐观锁）。CAS 操作包含三个操作数 -- 内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。&lt;/p&gt;
&lt;p&gt;在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用。关于实现上的细节，我将会在第3章进行分析。&lt;/p&gt;
&lt;p&gt;前面说了 CAS 操作的流程，并不是很难。但仅有上面的说明还不够，接下来我将会再介绍一点其他的背景知识。有这些背景知识，才能更好的理解后续的内容。&lt;/p&gt;
&lt;h2 id=&quot;背景介绍&quot;&gt;2.背景介绍&lt;/h2&gt;
&lt;p&gt;我们都知道，CPU 是通过总线和内存进行数据传输的。在多核心时代下，多个核心通过同一条总线和内存以及其他硬件进行通信。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15261871845901.jpg&quot;/&gt;&lt;br/&gt;图片出处：《深入理解计算机系统》&lt;/p&gt;
&lt;p&gt;上图是一个较为简单的计算机结构图，虽然简单，但足以说明问题。在上图中，CPU 通过两个蓝色箭头标注的总线与内存进行通信。大家考虑一个问题，CPU 的多个核心同时对同一片内存进行操作，若不加以控制，会导致什么样的错误？这里简单说明一下，假设核心1经32位带宽的总线向内存写入64位的数据，核心1要进行两次写入才能完成整个操作。若在核心1第一次写入32位的数据后，核心2从核心1写入的内存位置读取了64位数据。由于核心1还未完全将64位的数据全部写入内存中，核心2就开始从该内存位置读取数据，那么读取出来的数据必定是混乱的。&lt;/p&gt;
&lt;p&gt;不过对于这个问题，实际上不用担心。通过 Intel 开发人员手册，我们可以了解到自奔腾处理器开始，Intel 处理器会保证以原子的方式读写按64位边界对齐的四字（quadword）。&lt;/p&gt;
&lt;p&gt;根据上面的说明，我们可总结出，Intel 处理器可以保证单次访问内存对齐的指令以原子的方式执行。但如果是两次访存的指令呢？答案是无法保证。比如递增指令&lt;code&gt;inc dword ptr [...]&lt;/code&gt;，等价于&lt;code&gt;DEST = DEST + 1&lt;/code&gt;。该指令包含三个操作&lt;code&gt;读-&amp;gt;改-&amp;gt;写&lt;/code&gt;，涉及两次访存。考虑这样一种情况，在内存指定位置处，存放了一个为1的数值。现在 CPU 两个核心同时执行该条指令。两个核心交替执行的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;核心1 从内存指定位置出读取数值1，并加载到寄存器中&lt;/li&gt;
&lt;li&gt;核心2 从内存指定位置出读取数值1，并加载到寄存器中&lt;/li&gt;
&lt;li&gt;核心1 将寄存器中值递减1&lt;/li&gt;
&lt;li&gt;核心2 将寄存器中值递减1&lt;/li&gt;
&lt;li&gt;核心1 将修改后的值写回内存&lt;/li&gt;
&lt;li&gt;核心2 将修改后的值写回内存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过执行上述流程，内存中的最终值时2，而我们期待的是3，这就出问题了。要处理这个问题，就要避免两个或多个核心同时操作同一片内存区域。那么怎样避免呢？这就要引入本文的主角 - lock 前缀。关于该指令的详细描述，可以参考 Intel 开发人员手册 Volume 2 Instruction Set Reference，Chapter 3 Instruction Set Reference A-L。我这里引用其中的一段，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;LOCK—Assert LOCK# Signal Prefix&lt;br/&gt;Causes the processor’s LOCK# signal to be asserted during execution of the accompanying instruction (&lt;strong&gt;turns the instruction into an atomic instruction&lt;/strong&gt;). In a multiprocessor environment, the LOCK# signal &lt;strong&gt;ensures that the processor has exclusive use of any shared memory&lt;/strong&gt; while the signal is asserted.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面描述的重点已经用黑体标出了，在多处理器环境下，LOCK# 信号可以确保处理器独占使用某些共享内存。lock 可以被添加在下面的指令前：&lt;/p&gt;
&lt;p&gt;ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG.&lt;/p&gt;
&lt;p&gt;通过在 inc 指令前添加 lock 前缀，即可让该指令具备原子性。多个核心同时执行同一条 inc 指令时，会以串行的方式进行，也就避免了上面所说的那种情况。那么这里还有一个问题，lock 前缀是怎样保证核心独占某片内存区域的呢？答案如下：&lt;/p&gt;
&lt;p&gt;在 Intel 处理器中，有两种方式保证处理器的某个核心独占某片内存区域。第一种方式是通过锁定总线，让某个核心独占使用总线，但这样代价太大。总线被锁定后，其他核心就不能访问内存了，可能会导致其他核心短时内停止工作。第二种方式是锁定缓存，若某处内存数据被缓存在处理器缓存中。处理器发出的 LOCK# 信号不会锁定总线，而是锁定缓存行对应的内存区域。其他处理器在这片内存区域锁定期间，无法对这片内存区域进行相关操作。相对于锁定总线，锁定缓存的代价明显比较小。关于总线锁和缓存锁，更详细的描述请参考 Intel 开发人员手册 Volume 3 Software Developer’s Manual，Chapter 8 Multiple-Processor Management。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;3.源码分析&lt;/h2&gt;
&lt;p&gt;有了上面的背景知识，现在我们就可以从容不迫的阅读 CAS 的源码了。本章的内容将对 java.util.concurrent.atomic 包下的原子类 AtomicInteger 中的 compareAndSet 方法进行分析，相关分析如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AtomicInteger &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Number &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Serializable&lt;/span&gt; {

    &lt;span class=&quot;co&quot;&gt;// setup to use Unsafe.compareAndSwapInt for updates&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Unsafe unsafe = Unsafe.&lt;span class=&quot;fu&quot;&gt;getUnsafe&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; valueOffset;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 计算变量 value 在类对象中的偏移&lt;/span&gt;
            valueOffset = unsafe.&lt;span class=&quot;fu&quot;&gt;objectFieldOffset&lt;/span&gt;
                (AtomicInteger.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getDeclaredField&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;value&quot;&lt;/span&gt;));
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception ex) { &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(ex); }
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; value;
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareAndSet&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expect, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; update) {
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * compareAndSet 实际上只是一个壳子，主要的逻辑封装在 Unsafe 的 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * compareAndSwapInt 方法中&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; unsafe.&lt;span class=&quot;fu&quot;&gt;compareAndSwapInt&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, valueOffset, expect, update);
    }
    
    &lt;span class=&quot;co&quot;&gt;// ......&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Unsafe {
    &lt;span class=&quot;co&quot;&gt;// compareAndSwapInt 是 native 类型的方法，继续往下看&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compareAndSwapInt&lt;/span&gt;(Object o, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; offset,
                                                  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expected,
                                                  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x);
    &lt;span class=&quot;co&quot;&gt;// ......&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;// unsafe.cpp&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等一些类型也都是宏：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * jni.h&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef unsigned char   jboolean;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef unsigned short  jchar;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef short           jshort;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef float           jfloat;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef double          jdouble;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * jni_md.h&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     typedef int jint;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *     #ifdef _LP64 /* 64-bit */&lt;/span&gt;
 *     &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; jlong;
 *     &lt;span class=&quot;er&quot;&gt;#&lt;/span&gt;else
 *     &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; jlong;
 *     &lt;span class=&quot;er&quot;&gt;#&lt;/span&gt;endif
 *     &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; jbyte;
 */
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&lt;span class=&quot;st&quot;&gt;&quot;Unsafe_CompareAndSwapInt&quot;&lt;/span&gt;);
  oop p = JNIHandles::resolve(obj);
  &lt;span class=&quot;co&quot;&gt;// 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset&lt;/span&gt;
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  &lt;span class=&quot;co&quot;&gt;// 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END

&lt;span class=&quot;co&quot;&gt;// atomic.cpp&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; Atomic::cmpxchg(&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; exchange_value,
                         &lt;span class=&quot;dt&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;* dest, &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; compare_value) {
  assert(&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(jint), &lt;span class=&quot;st&quot;&gt;&quot;more work to do&quot;&lt;/span&gt;);
  &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * 函数。相关的预编译逻辑如下：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * atomic.inline.hpp：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #include &quot;runtime/atomic.hpp&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    // Linux&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #ifdef TARGET_OS_ARCH_linux_x86&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    # include &quot;atomic_linux_x86.inline.hpp&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #endif&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *   &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    // 省略部分代码&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    // Windows&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #ifdef TARGET_OS_ARCH_windows_x86&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    # include &quot;atomic_windows_x86.inline.hpp&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #endif&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    // BSD&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #ifdef TARGET_OS_ARCH_bsd_x86&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    # include &quot;atomic_bsd_x86.inline.hpp&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   *    #endif&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * 接下来分析 atomic_windows_x86.inline.hpp 中的 cmpxchg 函数实现&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   */&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)Atomic::cmpxchg((jint)exchange_value, (&lt;span class=&quot;dt&quot;&gt;volatile&lt;/span&gt; jint*)dest,
                                       (jint)compare_value);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的分析看起来比较多，不过主流程并不复杂。如果不纠结于代码细节，还是比较容易看懂的。接下来，我会分析 Windows 平台下的 Atomic::cmpxchg 函数。继续往下看吧。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;// atomic_windows_x86.inline.hpp&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define LOCK_IF_MP(mp) __asm cmp mp, 0  &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;                       __asm je L0      &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;                       __asm _emit 0xF0 &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;                       __asm L0:&lt;/span&gt;
              
&lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; jint Atomic::cmpxchg (jint exchange_value, &lt;span class=&quot;dt&quot;&gt;volatile&lt;/span&gt; jint* dest, jint compare_value) {
  &lt;span class=&quot;co&quot;&gt;// alternative for InterlockedCompareExchange&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mp = os::is_MP();
  __asm {
    mov edx, dest
    mov ecx, exchange_value
    mov eax, compare_value
    LOCK_IF_MP(mp)
    cmpxchg dword ptr [edx], ecx
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码由 LOCK_IF_MP 预编译标识符和 cmpxchg 函数组成。为了看到更清楚一些，我们将 cmpxchg 函数中的 LOCK_IF_MP 替换为实际内容。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; jint Atomic::cmpxchg (jint exchange_value, &lt;span class=&quot;dt&quot;&gt;volatile&lt;/span&gt; jint* dest, jint compare_value) {
  &lt;span class=&quot;co&quot;&gt;// 判断是否是多核 CPU&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mp = os::is_MP();
  __asm {
    &lt;span class=&quot;co&quot;&gt;// 将参数值放入寄存器中&lt;/span&gt;
    mov edx, dest    &lt;span class=&quot;co&quot;&gt;// 注意: dest 是指针类型，这里是把内存地址存入 edx 寄存器中&lt;/span&gt;
    mov ecx, exchange_value
    mov eax, compare_value
    
    &lt;span class=&quot;co&quot;&gt;// LOCK_IF_MP&lt;/span&gt;
    cmp mp, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 如果 mp = 0，表明是线程运行在单核 CPU 环境下。此时 je 会跳转到 L0 标记处，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 也就是越过 _emit 0xF0 指令，直接执行 cmpxchg 指令。也就是不在下面的 cmpxchg 指令&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 前加 lock 前缀。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    je L0
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 0xF0 是 lock 前缀的机器码，这里没有使用 lock，而是直接使用了机器码的形式。至于这样做的&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 原因可以参考知乎的一个回答：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *     https://www.zhihu.com/question/50878124/answer/123099923&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt; 
    _emit &lt;span class=&quot;bn&quot;&gt;0xF0&lt;/span&gt;
L0:
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *   cmpxchg: 即“比较并交换”指令&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *   dword: 全称是 double word，在 x86/x64 体系中，一个 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *          word = 2 byte，dword = 4 byte = 32 bit&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *   [edx]: [...] 表示一个内存单元，edx 是寄存器，dest 指针值存放在 edx 中。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *          那么 [edx] 表示内存地址为 dest 的内存单元&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *          &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 这一条指令的意思就是，将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 进行对比，如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    cmpxchg dword ptr [edx], ecx
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里 CAS 的实现过程就讲完了，CAS 的实现离不开处理器的支持。以上这么多代码，其实核心代码就是一条带lock 前缀的 cmpxchg 指令，即&lt;code&gt;lock cmpxchg dword ptr [edx], ecx&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;aba-问题&quot;&gt;4.ABA 问题&lt;/h2&gt;
&lt;p&gt;谈到 CAS，基本上都要谈一下 CAS 的 ABA 问题。CAS 由三个步骤组成，分别是“读取-&amp;gt;比较-&amp;gt;写回”。考虑这样一种情况，线程1和线程2同时执行 CAS 逻辑，两个线程的执行顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;时刻1：线程1执行读取操作，获取原值 A，然后线程被切换走&lt;/li&gt;
&lt;li&gt;时刻2：线程2执行完成 CAS 操作将原值由 A 修改为 B&lt;/li&gt;
&lt;li&gt;时刻3：线程2再次执行 CAS 操作，并将原值由 B 修改为 A&lt;/li&gt;
&lt;li&gt;时刻4：线程1恢复运行，将比较值（compareValue）与原值（oldValue）进行比较，发现两个值相等。&lt;br/&gt;然后用新值（newValue）写入内存中，完成 CAS 操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如上流程，线程1并不知道原值已经被修改过了，在它看来并没什么变化，所以它会继续往下执行流程。对于 ABA 问题，通常的处理措施是对每一次 CAS 操作设置版本号。java.util.concurrent.atomic 包下提供了一个可处理 ABA 问题的原子类 AtomicStampedReference，具体的实现这里就不分析了，有兴趣的朋友可以自己去看看。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5.总结&lt;/h2&gt;
&lt;p&gt;写到这里，这篇文章总算接近尾声了。虽然 CAS 本身的原理，包括实现都不是很难，但是写起来真的不太好写。这里面涉及到了一些底层的知识，虽然能看懂，但想说明白，还是有点难度的。由于我底层的知识比较欠缺，上面的一些分析难免会出错。所以如有错误，请轻喷，当然最好能说明怎么错的，感谢。&lt;/p&gt;
&lt;p&gt;好了，本篇文章就到这里。感谢阅读，再见。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;在前面源码分析一节中用到的几个文件，这里把路径贴出来。有助于大家进行索引，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Unsafe.java&lt;/td&gt;
&lt;td&gt;openjdk/jdk/src/share/classes/sun/misc/Unsafe.java&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;unsafe.cpp&lt;/td&gt;
&lt;td&gt;openjdk/hotspot/src/share/vm/prims/unsafe.cpp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;atomic.cpp&lt;/td&gt;
&lt;td&gt;openjdk/hotspot/src/share/vm/runtime/atomic.cpp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;atomic_windows_x86.inline.hpp&lt;/td&gt;
&lt;td&gt;openjdk/hotspot/src/os_cpu/windows_x86/vm/atomic_windows_x86.inline.hpp&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5.0491803278689&quot;&gt;
&lt;p&gt;本文在知识共享许可协议 4.0 下发布，转载需在明显位置处注明出处&lt;br/&gt;作者：coolblog.xyz&lt;br/&gt;本文同步发布在我的个人博客：&lt;a href=&quot;http://www.coolblog.xyz/?r=cb&quot; class=&quot;uri&quot;&gt;http://www.coolblog.xyz/?r=cb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;&lt;img src=&quot;http://blog-pictures.oss-cn-shanghai.aliyuncs.com/cc.png&quot; alt=&quot;cc&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 00:13:00 +0000</pubDate>
<dc:creator>coolblog.xyz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullllun/p/9039049.html</dc:identifier>
</item>
</channel>
</rss>