<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WPF自学入门（四）WPF路由事件之自定义路由事件 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8542761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8542761.html</guid>
<description>&lt;p&gt;       在上一篇博文中写到了内置路由事件，其实除了内置的路由事件，我们也可以进行自定义路由事件。接下来我们一起来看一下WPF中的自定义路由事件怎么进行创建吧。&lt;/p&gt;
&lt;p&gt;创建自定义路由事件分为3个步骤：&lt;/p&gt;
&lt;p&gt;1、声明并注册路由事件。&lt;/p&gt;
&lt;p&gt;2、利用CLR事件包装路由事件(封装路由事件)。&lt;/p&gt;
&lt;p&gt;3、创建可以激发路由事件的方法。&lt;/p&gt;
&lt;p&gt;      现在我们一起创建一个能够报告当前时间和当前位置信息的路由事件，一起去控件里面游览一番。现在开始创建自定义路由事件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 一、声明自定义路由事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       创建继承RoutedEventArgs类的派生类ReportCurrentLocationEventArgs用来携带时间和位置消息，ClickTime属性是用来存储时间，CurrentLocation属性是用来存放位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180310233058508-1706595287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、定义注册路由事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       我们用EventManager.RegisterRoutedEvent方法来注册的参数有4个。代码如下：&lt;/p&gt;
&lt;p&gt; public static readonly RoutedEvent ReportCurrentLocationEvent =EventManager.RegisterRoutedEvent&lt;/p&gt;
&lt;p&gt;                (&quot;ReportCurrentLocation&quot;, RoutingStrategy.Bubble, typeof(EventHandler&amp;lt;ReportCurrentLocationEventArgs&lt;/p&gt;
&lt;p&gt;     &amp;gt;), typeof(ButtonReportCurrentLocation));&lt;/p&gt;
&lt;p&gt;      第一个参数是路由事件的名称Name。&lt;/p&gt;
&lt;p&gt;      第二个参数是路由事件的传递方式，有三种方式：&lt;/p&gt;
&lt;p&gt;            第一种是Bubble是冒泡模式，这种模式是从触发点向上传递，知道最外层。&lt;/p&gt;
&lt;p&gt;             第二种是Direct就是传统的事件一样的，不会通过元素树。&lt;/p&gt;
&lt;p&gt;            第三种是Tunnel是预览模式（隧道模式），这和冒泡的相反，向下传递。&lt;/p&gt;
&lt;p&gt;     第三个参数是路由事件处理器类型，传递的参数是自定义类。&lt;/p&gt;
&lt;p&gt;     第四个参数是拥有这个路由事件的类型。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、封装路由事件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      CLR事件的封装器，不同于依赖属性的GetValue和SetValue，这里是利用Add和Remove两个函数来给路由事件分配事件处理器。&lt;/p&gt;
&lt;p&gt; public event RoutedEventHandler ReportCurrentLocation&lt;/p&gt;
&lt;p&gt;            {&lt;/p&gt;
&lt;p&gt;                add { this.AddHandler(ReportCurrentLocationEvent, value); }&lt;/p&gt;
&lt;p&gt;                remove { this.RemoveHandler(ReportCurrentLocationEvent, value); }&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、创建可以激发路由事件的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     重写OnClick方法触发设定路由事件，这是使用RaiseEvent（）方法来触发&lt;/p&gt;
&lt;p&gt; protected override void OnClick()&lt;/p&gt;
&lt;p&gt;            {&lt;/p&gt;
&lt;p&gt;                base.OnClick();&lt;/p&gt;
&lt;p&gt;                ReportCurrentLocationEventArgs args = new ReportCurrentLocationEventArgs(ReportCurrentLocationEvent, this);&lt;/p&gt;
&lt;p&gt;                args.ClickTime = DateTime.Now;&lt;/p&gt;
&lt;p&gt;                this.RaiseEvent(args);&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;

&lt;p&gt;完整代码如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180310233123746-1120877920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在界面XAML中，设计如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180310233131499-916034621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那么最后看一下事件处理器是怎样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180310233137728-1912053953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180310233144206-1042291354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Mar 2018 15:37:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8542761.html</dc:identifier>
</item>
<item>
<title>python基础 - 健林</title>
<link>http://www.cnblogs.com/jianlin/p/8542700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianlin/p/8542700.html</guid>
<description>&lt;p&gt;python是具有请打和丰富的库、他被称为胶水语言,能够把用其他语言制作的各种模块、很轻松的连接在一起、常见的一种应用场景是、使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[3] 有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。&lt;/p&gt;
&lt;h2&gt;python是一种什么语言呢？&lt;/h2&gt;
&lt;p&gt;严格的意思来说、python是一种脚本语言、编程语言有多重多样、但是开有开源和闭源之分、python就是一个开发核心源代码的编程语言、他开发代码的效率非常的高、代码编写后非常容易读、非常适合多人参与项目,他支持面向对象编程方式、同样也可以面向过程编程、非常的灵活,他不单免费、还可以任意的copy分发、python是由荷兰人Guido van Rossum在90年开发出来的、当初只是未了自己娱乐尝试编写一种替代ABC这些编程语言的脚本语言、没想到受到大家的喜爱、一直发展至今、后来引入了对多品台的支持。&lt;br/&gt;python语言的源代码的底层是用C语言进行编写的、他最强大之处就在于他丰富的第三方库、使得编写程序得速度非常快。python程序得扩展名是(.py),首先会将.py文件中的源代码编译程python的字节码、然后在由python虚拟机来执行这些编译好的字节码、在这一点上与JAVA等程序语言比起来比较相似、通常我们导入或者调用另一个程序、他的.py文件会生成一个.pyc文件、他是编译好的字节码文件、这样的程序运行起来速度更快。&lt;/p&gt;
&lt;h3&gt;一、编程与编程语言&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;为什么编程?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编程是为了用机器取代手工操作,编程的目的就是为了把人的思想传递给机器,让机器能够像人脑一样自动执行人们手工的操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是编程语言?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;语言就是计算机能够识别的表达方式,编程语言就是人与计算机的交流介质。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是编程?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;编程就是人将自己思想或者行为通过某种编程语言编写下来，他的产出就是一堆字符串文件。字符的执行结果就是编程所执行的结果。&lt;/p&gt;
&lt;h3&gt; 二、编程语言的分类&lt;/h3&gt;
&lt;p&gt;1. 机器语言&lt;br/&gt;机器语言就是站在机器的角度、机器能够直接识别的语言、也就是二进制数。&lt;br/&gt;2. 汇编语言&lt;br/&gt;汇编语言就是站机器的角度、用简单的英文标识取代二进制去编写程序。&lt;br/&gt;3. 高级语言&lt;br/&gt;高级语言就是站在人的角度、通过人能够识别的语言去编写程序、然后在让机器去执行。&lt;br/&gt;4. 编译型语言与解释型语言&lt;br/&gt;编译型语言就是需要编译、需要将所有的代码编译完成之后再执行。&lt;br/&gt;解释型语言是一边解释一边执行。&lt;br/&gt;5. 对比各种语言的优缺点&lt;br/&gt;机器语言==&amp;gt;执行速度最快==&amp;gt;开发效率最低&lt;br/&gt;汇编语言==&amp;gt;执行速度最快 ==&amp;gt;开发效率最低&lt;br/&gt;解释语言==&amp;gt;执行速度慢==&amp;gt;开发效率高、可跨平台&lt;/p&gt;
&lt;h3&gt; 三、python解释器&lt;/h3&gt;
&lt;p&gt;当python程序的安装包下载下来之后、安装到系统后会有一个解释器和Python的自带标准库程序。可以在解释器中编写执行Python源代码，也可以在Linux的终端模拟器中执行其它编辑器编写的代码，Windows系统可以在Dos中切换路径来，直接执行Python程序。&lt;/p&gt;
&lt;h3&gt; 四、第一个python程序&lt;/h3&gt;
&lt;p&gt;python的IDE安装过程很简单、需要你到python的官网(https://www.python.org/downloads/)下载python的程序、然后安装即可。&lt;br/&gt;我们以python2.7为例、安装完成之后的目录结构如下：&lt;br/&gt;![](https://scjianlin.github.io/shier/image/python_ide.png)&lt;br/&gt;然后我们打开这个IDE、在IDE中输入代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_dbb6dfd0-2a49-401b-8483-d19246a6654d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dbb6dfd0-2a49-401b-8483-d19246a6654d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dbb6dfd0-2a49-401b-8483-d19246a6654d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,Word! My name is shier!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194757/201803/1194757-20180310230750989-779365079.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;当然python的IDE的开发效率有限、后期建议大家使用pycharm来编写代码。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;python脚本&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们在python的IDE中写代码的时候是不需要加python的标识符、但是我们在写python脚本的时候就需要python的标识符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_8358b183-b34a-44f2-8cc3-e5ae53361b1c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8358b183-b34a-44f2-8cc3-e5ae53361b1c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8358b183-b34a-44f2-8cc3-e5ae53361b1c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; #！/usr/bin/&lt;span&gt;python env #指定系统python的解释器 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; print (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello,Word! My name is shier!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_84fbd10c-58ec-4b21-b6ed-66fed1f61958&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_84fbd10c-58ec-4b21-b6ed-66fed1f61958&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_84fbd10c-58ec-4b21-b6ed-66fed1f61958&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; G:\&amp;gt;&lt;span&gt;python3 test.py
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Hello,word! My name &lt;span&gt;is&lt;/span&gt; shier!
&lt;span&gt;3&lt;/span&gt; G:\&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;脚本运行方式&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt; py脚本的执行过程&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;启动py解释器&lt;/li&gt;
&lt;li&gt;将py脚本内容读取到内存&lt;/li&gt;
&lt;li&gt;解释器解释文件内容并执行&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;五、变量&lt;/h3&gt;
&lt;p&gt;1.什么是变量?&lt;br/&gt;变量字面意思就是变化的量、量指的是反映某种状态。变量是用来存放一中变化的状态,变是程序执行的直接体现。&lt;br/&gt;2.如何定义变量?&lt;br/&gt;变量的定义方式是由:变量名、赋值号、变量值组成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
name = 'shier'
sex = 'male'
age = '17'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.变量名的定义规范&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
1、变量名只能是数字、字面、数字或者下划线组成。
2、变量名的第一个字符不能是数字
3、Python中的关键字不能作为变量名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.变量的定义方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1、驼峰式
AgeShier=17
2、下划线
age_shier=17
注意:
1、变量名称最好不要用中文
2、变量名称过长
3、变量名称词不达意
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.常量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
常量不变化的量、常见的常量又数字、定义常量一般都是大写。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个变量都有id、type、value三要素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
但是需要注意的是:
1、id相同、意味着这个变量的type和value必定相同
2、value相同但是id可能不同
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_c30a0571-6e41-48e9-b0e2-6545d64a88de&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c30a0571-6e41-48e9-b0e2-6545d64a88de&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c30a0571-6e41-48e9-b0e2-6545d64a88de&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; x = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; y = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(x)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 54359208
&lt;span&gt;5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(y)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 54359328
&lt;span&gt;7&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;6.变量的回收机制&lt;br/&gt;当一个python解释器将一个值赋值给某一个变量的时候、此时这个变量名的引用计数会自动加1。如果变量名的引用计数为0、此时该变量就像没娘的孩子会被内存空间会被回收。&lt;/p&gt;
&lt;p&gt;7.变量的解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
l1 = ['Hello','word','ni','hao']
a,b,*_ = l1
print(a,b)
Hello word
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解压就是使用站位符的形式代替列表中的元素。&lt;/p&gt;
&lt;h3&gt;六、数据类型&lt;/h3&gt;
&lt;h4&gt;数字&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1、int整型
在python中数字一般用int表示、常用于标识一个人的年龄、等级、身份证号、qq号等等。 
age = 10
2、float浮点型
在python中浮点型一般用于表示小数、常用于标识工资、身高等等。
salary = 20000.10
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;字符串&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
在py中加了引号的字符就是字符串类型、py没有字符类型。字符串一般用于标识姓名、国籍等等。
name = 'shier'
需要解释一下在py中单引号、双引号、多引号的区别?
其实在python中单引号和双引号没有太大区别、但是需要注意不同情况下的使用。多引号可以打印换行。
print(&quot;Hello,word! I'm 17 years old!&quot;)
info = '''
相信别人就是
相信自己
'''
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;列表&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
列表是python中主要的数据类型之一、他可以被修改、可以增长和缩短、也可以嵌套。列表可以完成大多数集合类的数据结构实现、它支持,数字、字符、字符串甚至可以包含列表。列表数据类型是可变的数据类型。在py中列表类型是在[]内用逗号进行分割、可以存放n多个任意类型的值。列表常用于标识人的爱好等等。
student = ['张三','李四']
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;字典&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
字典是python中的另一种有序的可变的数据结构、且可以存储任意类型对象。
字典是一种键值对的数据容器,每个键值(key:value)对冒号(:)分割、每个对之间用逗号(,)分割、整个字典包括在花括号&quot;{}&quot;中。 
字典中的键必须是唯一的同时是不可变的、值没有限制。
info = {'name':'shier','age':'17'}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;布尔&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
在计算机中True就表示成立、False就标识不成立。
布尔类型的值有True和False两种。 
如果bool() #未传入参数则返回false
如果bool() #传入空字符串也返回false
如果bool() #传入数字0也返回false
如果bool() #传入对象只要是空返回都是false
&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 2
&amp;gt;&amp;gt;&amp;gt; a &amp;lt; b
True
&amp;gt;&amp;gt;&amp;gt; a &amp;gt; b
False
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;可变与不可变类型&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1.可变类型：在id不变的情况下，value可以变，则称为可变类型，如列表，字典
2. 不可变类型：value一旦改变，id也改变，则称为不可变类型（id变，意味着创建了新的内存空间） 
3. 在py中除了列表和字典是可变其他都不可变。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;七、格式化输出&lt;/h3&gt;
&lt;p&gt;在py中常会用到将输出信息打印成固定的格式。此时就涉及到字符串的格式化输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_70b399b8-f473-436d-9e38-970fa8a685ab&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_70b399b8-f473-436d-9e38-970fa8a685ab&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_70b399b8-f473-436d-9e38-970fa8a685ab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;一 占位符
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; age = 17
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My name is %s ,my age is %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name,age))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; My name &lt;span&gt;is&lt;/span&gt; shier ,my age &lt;span&gt;is&lt;/span&gt; 17
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; age = 17
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My name is %s ,my age is %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(name,age))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; My name &lt;span&gt;is&lt;/span&gt; shier ,my age &lt;span&gt;is&lt;/span&gt; 17
&lt;span&gt;11&lt;/span&gt; 以上方式是采用的站位符的方式打印的格式化输出、但是需要注意的是%s只能接受str、%d只能接收int、如果%&lt;span&gt;d接收str则会报错。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;二 format格式化
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; age = 17
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My name is {} ,My age is {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(name,age))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; ====================
&lt;span&gt;17&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shier&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; age = 17
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My name is {name} ,My age is {age}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(name=name,age=&lt;span&gt;age))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 他们俩的执行结果是一样的。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;八、基本运算&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
一、算术运算
在python中运算和正常的算术一样。
&amp;gt;&amp;gt;&amp;gt; a=2
&amp;gt;&amp;gt;&amp;gt; b=10
&amp;gt;&amp;gt;&amp;gt; a+b
12
&amp;gt;&amp;gt;&amp;gt; a-b
-8
&amp;gt;&amp;gt;&amp;gt; a*b
20
&amp;gt;&amp;gt;&amp;gt; b**a
100
&amp;gt;&amp;gt;&amp;gt; b/a
5.0
&amp;gt;&amp;gt;&amp;gt; b%a
0
&amp;gt;&amp;gt;&amp;gt; b//a
5
&amp;gt;&amp;gt;&amp;gt;
二、比较运算
&amp;gt;&amp;gt;&amp;gt; a &amp;gt; b
False
&amp;gt;&amp;gt;&amp;gt; a &amp;lt; b
True
&amp;gt;&amp;gt;&amp;gt; a !=b
True
&amp;gt;&amp;gt;&amp;gt; a == b
True
&amp;gt;&amp;gt;&amp;gt;
三、赋值运算
&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 2
&amp;gt;&amp;gt;&amp;gt; a+=b
&amp;gt;&amp;gt;&amp;gt; a
3
&amp;gt;&amp;gt;&amp;gt; a-=b
&amp;gt;&amp;gt;&amp;gt; a
1
&amp;gt;&amp;gt;&amp;gt; a*=b
&amp;gt;&amp;gt;&amp;gt; a
2
&amp;gt;&amp;gt;&amp;gt; a/=b
&amp;gt;&amp;gt;&amp;gt; a
1.0
&amp;gt;&amp;gt;&amp;gt; a%=b
&amp;gt;&amp;gt;&amp;gt; a
1.0
&amp;gt;&amp;gt;&amp;gt; a**=b
&amp;gt;&amp;gt;&amp;gt; a
1.0
&amp;gt;&amp;gt;&amp;gt; a//=b
&amp;gt;&amp;gt;&amp;gt; a
0.0
&amp;gt;&amp;gt;&amp;gt;
四、逻辑运算
常见的逻辑运算又and、not、or
&amp;gt;&amp;gt;&amp;gt; True or False and False
True
&amp;gt;&amp;gt;&amp;gt; (True or False) and False
False
&amp;gt;&amp;gt;&amp;gt;

身份运算(is)
&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 2
&amp;gt;&amp;gt;&amp;gt; a is b
False
&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;九、流程控制&lt;/h3&gt;
&lt;p&gt;流程控制就是根据不同的条件的变化而执行不同的代码、例如：登陆网站如果登陆未成功则不能进入到用户中心。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
一、if条件语句
没有分支判断、只有一种结果、如果不满足条件则退出。
age_of_shier=17
if age_of_shier == 17:
print('帅哥好！')
#单分支、如果不满足条件、则执行与条件相反的部分。
age_of_shier=16
if age_of_shier == 17:
print('帅哥好！')
else:
print('你好!')
#
age = 18
height = 180
wegiht = 60
is_pertty = True

if age &amp;lt; 20 and height &amp;gt; 175 and wegiht &amp;lt; 70 and is_pertty == True:
print('完美男人')
else:
print('继续深造吧!')
#嵌套if就是在if内部在加一层if判断。
age = 18
height = 180
wegiht = 60
is_pertty = True
sess = False

if age &amp;lt; 20 and height &amp;gt; 175 and wegiht &amp;lt; 70 and is_pertty == True:
if sess:
print('完美男人')
else:
print('好好锻炼吧！')
else:
print('继续深造吧!')
#小练习
info = input('&amp;gt;&amp;gt; ')
info = int(info)
if info &amp;gt;= 90:
print('优秀')
elif info &amp;gt;= 80:
print('良好')
elif info &amp;gt;= 70:
print('普通')
else:
print('很差')

#while 循环
while 条件: 
# 循环体
# 如果条件为真，那么循环体则执行，执行完毕后再次循环，重新判断条件。。。
# 如果条件为假，那么循环体不执行,循环终止

#改版的猜年龄
age_of_shier = 18
while True:
guess = input('&amp;gt;&amp;gt; ')
if not guess:continue
guess = int(guess)
if guess &amp;gt; age_of_shier:
print('没那么老！')
elif guess &amp;lt; age_of_shier:
print('太年轻了!')
else:
print('恭喜你、猜对了!')

#死循环
while True:
print('heheheh')

#打印10以内除了7的数字。
count = 0
while count&amp;lt;10:
count += 1
if count ==7:
continue
print(count)

#计算1-2+3-4……99的和
count = 1
Sum = 0
while count&amp;lt;100:
if count % 2 ==1:
Sum+=count
else:
Sum-=count
print(count)
count+=1
print('====')
print(Sum)

#嵌套循环
count=1
tag =True
while tag:
if count &amp;gt; 3:break
name = input('name: ')
passwd = input('password: ')
if name == 'shier' and passwd =='123123':
print('login sessfull')
while tag:
mes = input('&amp;gt;&amp;gt; ')
if mes == 'q':
tag = False
print(mes)
else:
print('log error')
count+=1

#while之break
number = 0
while number &amp;lt; 10:
if number &amp;gt;5:
break
print(number)
number+=1
break的作用是跳出本层循环。

#countinue
number = 0
while number &amp;lt; 10:
if number == 5:
continue
print(number)
number+=1
counitnue的作用是跳出本次循环继续执行下一次循环。
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 10 Mar 2018 15:17:00 +0000</pubDate>
<dc:creator>健林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianlin/p/8542700.html</dc:identifier>
</item>
<item>
<title>RobotFramework自动化测试框架-DatabaseLibrary库的使用(对数据库的操作) - 老清</title>
<link>http://www.cnblogs.com/laoqing/p/8542487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoqing/p/8542487.html</guid>
<description>&lt;p&gt;在自动化过程中，我们经常需要连接不同的数据库，并且对数据库进行很多不同的操作，RobotFramework中，提供了DatabaseLibrary这个库来操作数据库，我们可以按照官网中的说明来安装DatabaseLibrary库，在浏览器中访问&lt;a href=&quot;http://franz-see.github.io/Robotframework-Database-Library/&quot;&gt;http://franz-see.github.io/Robotframework-Database-Library/&lt;/a&gt; 页面，即可以看到该库的相关安装说明和API介绍。&lt;/p&gt;
&lt;p&gt;在使用DatabaseLibrary库时，需要在测试套件中，预先导入该库，才可以在用例中使用DatabaseLibrary库中的关键字，这里以Mysql数据库为例，讲述Databaselibrary库的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222332835-388450790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
要链接到&lt;span lang=&quot;EN-US&quot;&gt;mysql，除了要导入&lt;span lang=&quot;EN-US&quot;&gt;DatabaseLibrary库外，还需要安装&lt;span lang=&quot;EN-US&quot;&gt;pure-Python MySQL client library，可以通过&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://github.com/PyMySQL/PyMySQL&quot;&gt;https://github.com/PyMySQL/PyMySQL&lt;/a&gt; 下载该库，并且进行安装，或者直接通过&lt;span lang=&quot;EN-US&quot;&gt;cmd命令行&lt;span lang=&quot;EN-US&quot;&gt;pip install PyMySQL来进行安装&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222513989-692936646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1.1        如何连接数据库&lt;/h3&gt;
&lt;p&gt;1、可以通过DatabaseLibrary库中的Connect To Database关键字来链接一个mysql数据库，此处以链接本机mysql库为例&lt;/p&gt;
&lt;p&gt;数据库用户名：root&lt;/p&gt;
&lt;p&gt;数据库密码：root&lt;/p&gt;
&lt;p&gt;Mysql数据库端口：3306&lt;/p&gt;
&lt;p&gt;数据库名：world&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database&lt;/strong&gt;   pymysql    world  root   root   localhost  3306&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222616106-1245782740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222647931-1780823698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、还可以通过Connect To Database Using Custom Params关键字来连接mysql数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database&lt;/strong&gt; &lt;strong&gt;Using Custom Params&lt;/strong&gt;    pymysql    database='world', user='root', password='root', host='localhost', port=3306&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222727602-782415329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222815611-1986760597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 align=&quot;left&quot;&gt;1.1.2        如何断开数据库&lt;/h3&gt;
&lt;p&gt;可以通过关键字Disconnect From Database断开数据库连接，我们在操作数据库时，一定不要忘记在操作完成后，要断开数据库的连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database&lt;/strong&gt;   pymysql    world  root   root   localhost  3306&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disconnect From Database      &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222915418-2079754933.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310222957072-1857499790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 align=&quot;left&quot;&gt;2.1.3        如何对数据库的表进行查询&lt;/h3&gt;
&lt;p&gt;通过Query关键字可以对数据库中的表进行查询，此处以查询mysql数据库中某张表的数据为例，我们在world数据库中执行SELECT * FROM city LIMIT 5; 这条sql.&lt;/p&gt;
&lt;p&gt;我们先看下，我们在sql窗口中查询出来的结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223049212-1612605766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再使用Query关键字来进行查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database Using Custom Params&lt;/strong&gt;  pymysql  database='world', user='root', password='root', host='localhost', port=3306&lt;/p&gt;
&lt;p&gt;@{result}       &lt;strong&gt;Query&lt;/strong&gt;      SELECT * FROM city LIMIT 5;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Log Many&lt;/strong&gt; @{result}    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disconnect From Database               &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223125081-2018276218.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223157484-161324399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1.4        如何插入和删除数据&lt;/h3&gt;
&lt;p&gt;可以通过Execute Sql String关键字来执行数据库的插入操作和删除操作&lt;/p&gt;
&lt;p&gt;1、首先我们来看下如何向数据库中插入数据，此处以向表city中插入一条记录为例，通过&lt;strong&gt;Execute Sql Strin&lt;/strong&gt;g关键字来执行INSERT INTO city(NAME,countrycode,district,population) VALUES('beijing' ,'ZH','China',217100)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database Using Custom Params   &lt;/strong&gt; pymysql  database='world', user='root', password='root', host='localhost', port=3306&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Execute Sql String&lt;/strong&gt;  INSERT INTO city(NAME,countrycode,district,population) VALUES('beijing' ,'ZH','China',217100)    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disconnect From Database     &lt;/strong&gt;        &lt;/p&gt;
&lt;pre&gt;
&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223258599-695521872.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223336172-1215602069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在sql窗口，查询一下，刚刚执行的inset语句是否执行成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223416793-779945737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到已经成功插入了数据。&lt;/p&gt;
&lt;p&gt;2、然后我们再来看一下怎么删除表中的数据，我们将上面插入的'beijing' ,'ZH','China',217100 这条数据从数据库中删除掉&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Connect To Database Using Custom Params &lt;/strong&gt; pymysql  database='world', user='root', password='root', host='localhost', port=3306&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Execute Sql String&lt;/strong&gt;  delete from city where NAME='beijing'      &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disconnect From Database               &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223505823-304107352.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;执行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223539151-668782754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在sql窗口，查询一下，有没有将数据成功删除掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223610882-1806201734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从查询的结果看，我们看到数据已经成功的被删除掉了&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1.5        如何执行数据库脚本文件&lt;/h3&gt;
&lt;p&gt;在做自动化测试时，我们经常需要构造数据或者对库中的数据进行初始化，但是如果我们每次都是将要执行的数据库脚本按条写在用例中，将非常不好维护，因此我们需要直接执行数据库脚本文件，在Databaselibrary库中，可以通过Execute Sql Script关键字来执行数据库脚本文件。&lt;/p&gt;
&lt;p&gt;此处以执行本地F磁盘中的script.sql 为例，在script.sql 脚本中，放入需要执行的语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223708008-842085478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Connect To Database Using Custom Params&lt;/strong&gt;    pymysql  database='world',user='root', password='root', host='localhost', port=3306&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Execute Sql Script&lt;/strong&gt;       f:/script.sql  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disconnect From Database         &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223742938-365579273.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223819526-1440148644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行成功后，对数据库进行查询，会发现，脚本已经执行成功，数据已经成功插入&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201803/1200756-20180310223852538-2116419286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3 align=&quot;left&quot;&gt;2.1.6        数据库其他操作关键字&lt;/h3&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;关键字&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;使用描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Check If Exists In Database&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;检查数据库查询是否有返回结果，如果有返回结果，则用例执行成功，否则执行失败，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Check If Exists In Database&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;267&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' OR NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Check If Not Exists In Database&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;检查数据库查询是否有返回结果，如果有返回结果，则用例执行失败，否则执行成功，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Check If Not Exists In Database&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;267&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' and NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Delete All Rows From Table&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;删除数据库中某张表中的全部数据，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;270&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Delete All Rows From Table&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p&gt;World&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;描述数据库的查询结果，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;@{result}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Log Many&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;@{result}      &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;统计sql查询返回的记录数，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;${rowCount}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Log&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;${rowCount}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is 0&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查sql查询返回的记录数是否为0，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is 0&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Equal To X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查sql查询返回的记录数是否等于某个值，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Equal To X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Greater Than X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查sql查询返回的记录数是否大于某个值，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Greater Than X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Less Than X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查sql查询返回的记录数是否小于某个值，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Row Count Is Less Than X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT * FROM city WHERE NAME='beijing' or NAME='shanghai'&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;Table Must Exist&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;判断数据库中表是否存在，示例：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;134&quot;&gt;
&lt;p&gt;&lt;strong&gt;Table Must Exist&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;269&quot;&gt;
&lt;p&gt;city&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【原文归作者所有，欢迎转载，但是保留版权,并且转载时，需要注明出处&lt;/strong&gt;】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Mar 2018 14:41:00 +0000</pubDate>
<dc:creator>老清</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoqing/p/8542487.html</dc:identifier>
</item>
<item>
<title>Entity Framework 乐观并发处理 - SolidMango</title>
<link>http://www.cnblogs.com/pugang/p/8542393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pugang/p/8542393.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Entity Framework 乐观并发处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      有一段时间没有更新博客了，今天终于有一些时间，和大家讨论一个Entity Framework 乐观并发处理的问题。首先需要说明的是，这里提到的 “并发” 并不是指的多线程处理，也就是笔者这里要讨论的是另外一个问题场景，这个场景描述如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 系统用户A从数据库中取得一条记录Record-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 系统用户B从数据库中取得同一条记录Record-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 系统用户B修改记录Record-1，并保存到数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. 系统用户A修改记录Record-1，并保存到数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个场景里面的问题是系统用户B对数据路记录Record-1的修改被A的修改冲掉了，这种行为在某些业务场景中是正确的，但是在某些场景中可能会有问题，因为这样的场景中A可能希望感知Record-1的变化，并做出相应的代码策略处理。针对这种场景Entity Framework 专门有一种解决方案，Timestamp或者叫Rowersion，具体实现代码如下， 在需要支持乐观并发的model上增加Timestamp字段，字段的名字叫RowVersion，当然对应的数据库表上也要加上这个字段RowVersion，类型是timestamp, 这样在以上描述的场景发生时，系统就会捕获到相应的异常，从而有机会对这种场景进行相应的业务处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不喜欢Data Annotation，也可以使用 Fluent api 进行标记，具体代码如下，&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
modelBuilder.Entity&amp;lt;Department&amp;gt;().Property(p =&amp;gt; p.RowVersion).IsRowVersion();
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ContosoUniversity.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Department
    {&lt;br/&gt;[ConcurrencyCheck]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DepartmentID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [StringLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, MinimumLength = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [DataType(DataType.Currency)]
        [Column(TypeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Budget { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [DataType(DataType.Date)]
        [DisplayFormat(DataFormatString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0:yyyy-MM-dd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ApplyFormatInEditMode = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
        [Display(Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start Date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime StartDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? InstructorID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Timestamp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] RowVersion { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Instructor Administrator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;Course&amp;gt; Courses { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   try&lt;br/&gt;&lt;/span&gt;&lt;span&gt;   {
          db.Entry(departmentToUpdate).OriginalValues[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RowVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; rowVersion;
          &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; db.SaveChangesAsync();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToAction(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   }
   &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DbUpdateConcurrencyException ex)
   {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; entry =&lt;span&gt; ex.Entries.Single();
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clientValues =&lt;span&gt; (Department)entry.Entity;
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; databaseEntry =&lt;span&gt; entry.GetDatabaseValues();
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (databaseEntry == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unable to save changes. The department was deleted by another user.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
          {
              &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; databaseValues =&lt;span&gt; (Department)databaseEntry.ToObject();

              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (databaseValues.Name !=&lt;span&gt; clientValues.Name)
              ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               +&lt;span&gt; databaseValues.Name);
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (databaseValues.Budget !=&lt;span&gt; clientValues.Budget)
               ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Budget&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               + String.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0:c}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, databaseValues.Budget));
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (databaseValues.StartDate !=&lt;span&gt; clientValues.StartDate)
                ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;StartDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               + String.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0:d}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, databaseValues.StartDate));
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (databaseValues.InstructorID !=&lt;span&gt; clientValues.InstructorID)
               ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InstructorID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                +&lt;span&gt; db.Instructors.Find(databaseValues.InstructorID).FullName);
               ModelState.AddModelError(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Empty, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The record you attempted to edit &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                            + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;was modified by another user after you got the original value. The &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                            + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit operation was canceled and the current values in the database &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                            + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;have been displayed. If you still want to edit this record, click &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                            + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the Save button again. Otherwise click the Back to List hyperlink.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
               departmentToUpdate.RowVersion &lt;/span&gt;=&lt;span&gt; databaseValues.RowVersion;
              }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;当然Timestamp字段不是必须单独添加的，也可以使用model上的已有字段，假设这个字段是DepartmentID，我们可以使用ConcurrencyCheck注解进行标记，当然也可是使用Fluent api 进行标记，具体代码如下，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
modelBuilder.Entity&amp;lt;Person&amp;gt;().Property(p =&amp;gt; p.DepartmentID).IsConcurrencyToken();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文详细描述了一种Entity Framework 乐观并发处理的解决方案，并且通过Data Annotation和Fluent api 两种方式进行了详细的说明，希望对大家有所帮助。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Mar 2018 14:25:00 +0000</pubDate>
<dc:creator>SolidMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pugang/p/8542393.html</dc:identifier>
</item>
<item>
<title>你需要了解的高可用方案之使用keepalived搭建双机热备一览 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/8542323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/8542323.html</guid>
<description>
&lt;p&gt;             在之前一篇使用nginx搭建高可用的解决方案的时候，很多同学会问，如果nginx挂掉怎么办，比如下面这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201803/214741-20180310191155674-1355771140.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            你可以清楚的看到，如果192.168.2.100这台机器挂掉了，那么整个集群就下线了，这个问题该怎么解决呢？？？ 简单的想想确实不大好处理，因为你&lt;/p&gt;
&lt;p&gt;的webBrowser总得要访问一个ip地址，对吧。。这个问题怎么破呢？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一：问题分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果你有一些网络底子的话，就会明白，你给一个不在本网段的机器发送请求的话，这个请求会先经过你的网关IP，然后通过网关IP传给对方的网关IP，然&lt;/p&gt;
&lt;p&gt;后网关IP会将请求转给它所在局域网的主机，当然我的网关IP和对方的网关IP之间可能有很多跳的路由地址，大概的流程就是下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201803/214741-20180310192540253-1908734773.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你不信的话，可以用tracert 看看你到www.ctrip.com的路由总过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201803/214741-20180310193202094-1940070007.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到，从我当前主机到ctrip.com一共有20跳，第一条是192.168.2.1，这个就是我的路由器IP，也就是我的网关IP。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二：虚拟路由冗余协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　好了，说了这么多有什么用呢？其实大家仔细观察这张图，你会想我能不能在网关IP上做一些手脚呢？ 可喜的是如今的路由器基本上都支持一个叫做&lt;/p&gt;
&lt;p&gt;VRRP（虚拟路由冗余协议），这一协议的作用你可以理解成把网关IP虚拟化成一个网关IP集群，就好像兽族剑圣的镜像技能，这里面有master，也有slave，&lt;/p&gt;
&lt;p&gt;然后局域网内的主机设置的都是虚拟的masterIP（VIP），刚好keepealived就是一个实现VRRP的一款应用程序，你需要，我专业，大家就这样走到一块了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三：keepalived搭建一览&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 下载：从官网上找到当前最新的版本1.4.2。http://www.keepalived.org/software/keepalived-1.4.2.tar.gz。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     配置机器： 192.168.23.156 【centos】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　          192.168.23.157 【centos】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [root@localhost app]# wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.keepalived.org/software/keepalived-1.4.2.tar.gz&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; --&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;03&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;04&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;--  http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.keepalived.org/software/keepalived-1.4.2.tar.gz&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; Resolving www.keepalived.org (www.keepalived.org)... &lt;span&gt;37.59&lt;/span&gt;.&lt;span&gt;63.157&lt;/span&gt;, &lt;span&gt;2001&lt;/span&gt;:41d0:&lt;span&gt;8&lt;/span&gt;:7a9d::&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; Connecting to www.keepalived.org (www.keepalived.org)|&lt;span&gt;37.59&lt;/span&gt;.&lt;span&gt;63.157&lt;/span&gt;|:&lt;span&gt;80&lt;/span&gt;&lt;span&gt;... connected.
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; HTTP request sent, awaiting response... &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; Length: &lt;span&gt;738096&lt;/span&gt; (721K) [application/x-&lt;span&gt;gzip]
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; Saving to: ‘keepalived-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.tar.gz’
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;%[==================================================================&amp;gt;] &lt;span&gt;738&lt;/span&gt;,&lt;span&gt;096&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt;.24KB/s   &lt;span&gt;in&lt;/span&gt; 4m 44s 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2. 然后把相关依赖装起来：yum install -y openssl openssl-devel。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [root@localhost app]# yum install -y openssl openssl-&lt;span&gt;devel
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Loaded plugins: fastestmirror, langpacks
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Could not retrieve mirrorlist http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=os&amp;amp;infra=stock error was&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;: curl#&lt;span&gt;52&lt;/span&gt; - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Empty reply from server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;                                                                                 | &lt;span&gt;3.6&lt;/span&gt; kB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt; epel/x86_64/metalink                                                                 | &lt;span&gt;7.8&lt;/span&gt; kB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt; Could not retrieve mirrorlist http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrorlist.centos.org/?release=7&amp;amp;arch=x86_64&amp;amp;repo=extras&amp;amp;infra=stock error was&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;: curl#&lt;span&gt;52&lt;/span&gt; - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Empty reply from server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; extras                                                                               | &lt;span&gt;3.4&lt;/span&gt; kB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; updates                                                                              | &lt;span&gt;3.4&lt;/span&gt; kB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; updates/&lt;span&gt;7&lt;/span&gt;/x86_64/primary_db                                                          | &lt;span&gt;6.9&lt;/span&gt; MB  &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3. 接下来继续解压，最后安装三板斧： ./configure --prefix=/usr/app/keepalived &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@localhost app]# tar -zxvf keepalived-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.tar.gz
[root@localhost app]# ls
keepalived&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;  keepalived-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.tar.gz
[root@localhost app]# cd keepalived&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[root@localhost keepalived&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]# ls
aclocal.m4  bin_install  configure     COPYING  genhash     keepalived          Makefile.am  README.md
ar&lt;/span&gt;-lib      ChangeLog    configure.ac  depcomp  INSTALL     keepalived.spec.&lt;span&gt;in&lt;/span&gt;  Makefile.&lt;span&gt;in&lt;/span&gt;&lt;span&gt;  snap
AUTHOR      compile      CONTRIBUTORS  doc      install&lt;/span&gt;-&lt;span&gt;sh  lib                 missing      TODO
[root@localhost keepalived&lt;/span&gt;-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;]#
&lt;/pre&gt;
&lt;p&gt;[root@localhost keepalived-1.4.2]# ./configure --prefix=/usr/app/keepalived &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;安装好了之后，你就会看到如下的内容，那就恭喜你，安装成功了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Keepalived configuration
&lt;/span&gt;------------------------&lt;span&gt;
Keepalived version       : &lt;/span&gt;&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
Compiler                 : gcc
Preprocessor flags       : 
Compiler flags           : &lt;/span&gt;-Wall -Wunused -Wstrict-prototypes -Wextra -g -O2 -fPIE -&lt;span&gt;D_GNU_SOURCE
Linker flags             : &lt;/span&gt;-&lt;span&gt;pie
Extra Lib                :  &lt;/span&gt;-lcrypto  -&lt;span&gt;lssl 
Use IPVS Framework       : Yes
IPVS use libnl           : No
IPVS syncd attributes    : No
IPVS &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt; bit stats        : No
fwmark socket support    : Yes
Use VRRP Framework       : Yes
Use VRRP VMAC            : Yes
Use VRRP authentication  : Yes
With ip rules&lt;/span&gt;/&lt;span&gt;routes     : Yes
SNMP vrrp support        : No
SNMP checker support     : No
SNMP RFCv2 support       : No
SNMP RFCv3 support       : No
DBUS support             : No
SHA1 support             : No
Use Debug flags          : No
smtp&lt;/span&gt;-&lt;span&gt;alert debugging     : No
Use Json output          : No
Stacktrace support       : No
Memory alloc check       : No
libnl version            : None
Use IPv4 devconf         : No
Use libiptc              : No
Use libipset             : No
init type                : systemd
Build genhash            : Yes
Build documentation      : No&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4. 安装好了之后，在/usr/app/keepalived/etc/keepalived目录下有一个keepalived.conf文件，现在你要做的事情&lt;/span&gt;&lt;span&gt;就是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    将它copy到/etc/keepalived文件夹下&lt;/span&gt;&lt;span&gt;就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[root@localhost keepalived]# ls
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;keepalived.conf  samples
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;[root@localhost keepalived]# pwd
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; /usr/app/keepalived/etc/&lt;span&gt;keepalived
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; [root@localhost keepalived]# mkdir -p /etc/&lt;span&gt;keepalived
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; [root@localhost keepalived]# cp ./keepalived.conf /etc/keepalived/keepalived.conf
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;5. 接下来我们改一下配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   在192.168.23.156机器中的配置文件，修改如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【原来】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eth0
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
    virtual_ipaddress {
        &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.16&lt;/span&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.17&lt;/span&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.18&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;【修改】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;
   router_id NodeA
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}

vrrp_instance VI_1 {
    state MASTER
    &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;&lt;span&gt; ens33&lt;/span&gt;
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority 150&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }
   &lt;span&gt; virtual_ipaddress {
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168.2.200&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中要注意的就是：&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　《1》priority 150&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　 节点的优先级，master要比slave高。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　《2》interface ens33&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　 ens33大家可以通过ipconfig查看一下自己的网卡。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
[root@localhost ~&lt;span&gt;]# ifconfig
br&lt;/span&gt;-11757db6abf5: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:c2:e0:&lt;span&gt;52&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

br&lt;/span&gt;-875e3c64ec79: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:4e:&lt;span&gt;43&lt;/span&gt;:5b:a0  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

br&lt;/span&gt;-904f2c62861e: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.19&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:6d:&lt;span&gt;80&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt;:&lt;span&gt;58&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

br&lt;/span&gt;-b0028a425959: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.21&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;68&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;95&lt;/span&gt;:&lt;span&gt;99&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  bytes &lt;span&gt;1458&lt;/span&gt; (&lt;span&gt;1.4&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  bytes &lt;span&gt;3920&lt;/span&gt; (&lt;span&gt;3.8&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

br&lt;/span&gt;-c4a09a75fc67: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;92&lt;/span&gt;:f9:2d:&lt;span&gt;65&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  bytes &lt;span&gt;340&lt;/span&gt; (&lt;span&gt;340.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  bytes &lt;span&gt;340&lt;/span&gt; (&lt;span&gt;340.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

br&lt;/span&gt;-f0fb207788a0: flags=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        inet6 fe80::&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;:86ff:fe1e:c970  prefixlen &lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;86&lt;/span&gt;:1e:c9:&lt;span&gt;70&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

docker0: flags&lt;/span&gt;=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:8f:8c:a9:a7  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;&lt;span&gt;

ens33:&lt;/span&gt; flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.157&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;  broadcast &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.255&lt;/span&gt;&lt;span&gt;
        inet6 fe80::20c:29ff:fe54:4f5a  prefixlen &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:4f:5a  txqueuelen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;10899&lt;/span&gt;  bytes &lt;span&gt;11349012&lt;/span&gt; (&lt;span&gt;10.8&lt;/span&gt;&lt;span&gt; MiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;5575&lt;/span&gt;  bytes &lt;span&gt;599717&lt;/span&gt; (&lt;span&gt;585.6&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

lo: flags&lt;/span&gt;=&lt;span&gt;73&lt;/span&gt;&amp;lt;UP,LOOPBACK,RUNNING&amp;gt;  mtu &lt;span&gt;65536&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  prefixlen &lt;span&gt;128&lt;/span&gt;  scopeid &lt;span&gt;0x10&lt;/span&gt;&amp;lt;host&amp;gt;&lt;span&gt;
        loop  txqueuelen &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Local Loopback)
        RX packets &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  bytes &lt;span&gt;340&lt;/span&gt; (&lt;span&gt;340.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  bytes &lt;span&gt;340&lt;/span&gt; (&lt;span&gt;340.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

veth4d72ad4: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet6 fe80::d4fb:fcff:feeb:cd7c  prefixlen &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether d6:fb:fc:eb:cd:7c  txqueuelen &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  bytes &lt;span&gt;1248&lt;/span&gt; (&lt;span&gt;1.2&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;43&lt;/span&gt;  bytes &lt;span&gt;4130&lt;/span&gt; (&lt;span&gt;4.0&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

vethe634b1c: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet6 fe80::e0c6:88ff:fe1c:f4a1  prefixlen &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether e2:c6:&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;:1c:f4:a1  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  bytes &lt;span&gt;1458&lt;/span&gt; (&lt;span&gt;1.4&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  bytes &lt;span&gt;3920&lt;/span&gt; (&lt;span&gt;3.8&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

virbr0: flags&lt;/span&gt;=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;  broadcast &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

[root@localhost &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;span&gt;《3》virtual_ipaddress 192.168.23.200&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            设置好虚拟IP（VIP）为：192.168.23.200&lt;/p&gt;
&lt;p&gt;同样的道理，在192.168.23.157设置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   } 
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;200.1&lt;/span&gt;&lt;span&gt;
   smtp_connect_timeout &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&lt;span&gt;
   router_id NodeB&lt;/span&gt;
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
   vrrp_gna_interval &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
}  

vrrp_instance VI_1 {
    &lt;span&gt;state BACKUP
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;&lt;span&gt; ens33&lt;/span&gt;
    virtual_router_id &lt;/span&gt;&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
    priority &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
    advert_int &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    authentication {
        auth_type PASS
        auth_pass &lt;/span&gt;&lt;span&gt;1111&lt;/span&gt;&lt;span&gt;
    }   
&lt;span&gt;    virtual_ipaddress {
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168.23.200&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    }  &lt;/span&gt; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;7. 接下来就可以启动keepalived了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost sbin]# ./keepalived -&lt;span&gt;D
[root@localhost sbin]# ps &lt;/span&gt;-ef |&lt;span&gt; grep keepalived
root       &lt;/span&gt;&lt;span&gt;4661&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; ./keepalived -&lt;span&gt;D
root       &lt;/span&gt;&lt;span&gt;4662&lt;/span&gt;   &lt;span&gt;4661&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; ./keepalived -&lt;span&gt;D
root       &lt;/span&gt;&lt;span&gt;4663&lt;/span&gt;   &lt;span&gt;4661&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; ./keepalived -&lt;span&gt;D
root       &lt;/span&gt;&lt;span&gt;4673&lt;/span&gt;   &lt;span&gt;4300&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=auto keepalived
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;五：检测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 通过ip a  看看当前ens33网卡上是否绑定了192.168.23.200虚拟IP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201803/214741-20180310214557677-1853406483.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. 然后通过arp -a 查看当前的vip映射到的物理(mac)地址，可以看到当前的vip映射到的是192.168.23.156上面。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
C:\Users\hxc&amp;gt;arp -&lt;span&gt;a

接口: &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.1&lt;/span&gt; --- &lt;span&gt;0x6&lt;/span&gt;&lt;span&gt;
  Internet 地址         物理地址              类型
  &lt;/span&gt;&lt;span&gt;192.168.23.156        00-0c-29-75-7e-20     动态
  &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.157&lt;/span&gt;        &lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;54&lt;/span&gt;-4f-&lt;span&gt;5a     动态
  &lt;/span&gt;&lt;span&gt;192.168.23.200        00-0c-29-75-7e-20     动态
  &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.255&lt;/span&gt;        ff-ff-ff-ff-ff-&lt;span&gt;ff     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.22&lt;/span&gt;            &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.251&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;fb     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.252&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;fc     静态
  &lt;/span&gt;&lt;span&gt;239.11&lt;/span&gt;.&lt;span&gt;20.1&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-0b-&lt;span&gt;14&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;&lt;span&gt;     静态
  &lt;/span&gt;&lt;span&gt;239.255&lt;/span&gt;.&lt;span&gt;255.250&lt;/span&gt;       &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;5e-7f&lt;/span&gt;-ff-&lt;span&gt;fa     静态
  &lt;/span&gt;&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;       ff-ff-ff-ff-ff-ff     静态
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;  3. 然后我们把156这台机器关闭了，可以看到当前的vip已经漂移到了157这台机器上了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
C:\Users\hxc&amp;gt;arp -&lt;span&gt;a

接口: &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.1&lt;/span&gt; --- &lt;span&gt;0x6&lt;/span&gt;&lt;span&gt;
  Internet 地址         物理地址              类型
  &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.156&lt;/span&gt;        &lt;span&gt;00&lt;/span&gt;-0c-&lt;span&gt;29&lt;/span&gt;-&lt;span&gt;75&lt;/span&gt;-7e-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;     动态
  &lt;/span&gt;&lt;span&gt;192.168.23.157        00-0c-29-54-4f-5a     动态
  192.168.23.200        00-0c-29-54-4f-5a     动态
  &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.255&lt;/span&gt;        ff-ff-ff-ff-ff-&lt;span&gt;ff     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.22&lt;/span&gt;            &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.251&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;fb     静态
  &lt;/span&gt;&lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.252&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;fc     静态
  &lt;/span&gt;&lt;span&gt;239.11&lt;/span&gt;.&lt;span&gt;20.1&lt;/span&gt;           &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-5e-0b-&lt;span&gt;14&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;&lt;span&gt;     静态
  &lt;/span&gt;&lt;span&gt;239.255&lt;/span&gt;.&lt;span&gt;255.250&lt;/span&gt;       &lt;span&gt;01&lt;/span&gt;-&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;5e-7f&lt;/span&gt;-ff-&lt;span&gt;fa     静态
  &lt;/span&gt;&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;       ff-ff-ff-ff-ff-ff     静态
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      好了，这个就是本篇所说的所有内容，希望对您有帮助。&lt;/p&gt;

</description>
<pubDate>Sat, 10 Mar 2018 14:04:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangxincheng/p/8542323.html</dc:identifier>
</item>
<item>
<title>前端（HTML/CSS/JS）-HTML编码规范 - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/8542301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/8542301.html</guid>
<description>&lt;h2 data-id=&quot;heading-0&quot;&gt;一、HTML编码规范&lt;/h2&gt;
&lt;h3 data-id=&quot;heading-1&quot;&gt;1. img标签要写alt属性&lt;/h3&gt;
&lt;p&gt;根据W3C标准，img标签要写alt属性，如果没有就写一个空的。但是一般要写一个有内容的，根据图片想要表达的意思，因为alt是在图片无法加载时显示的文字&lt;/p&gt;
&lt;p&gt;如下不太好的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;company-logo.svg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;ABC Company Logo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更好的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;chime-logo.svg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;ABC Company&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就不用告诉用户它是一个Logo了，直接告诉它是ABC Compay就好了。再如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;user-head.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;User Portrait&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;user-head.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;Bolynga Team&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果图片显示不出来，就直接显示用户的名字。&lt;/p&gt;
&lt;p&gt;有些人偷懒就直接写个空的alt那也可以，但是在一些重要的地方还是要写一下，毕竟它还是有利于SEO.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-2&quot;&gt;2. 单标签不要写闭合标签&lt;/h3&gt;
&lt;p&gt;为什么？因为写了也没用，还显得你不懂html规范，我们不是写XHTML。常见的单标签有img、link、input、hr、br，&lt;/p&gt;
&lt;p&gt;如下不好的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;test.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;test.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-3&quot;&gt;3. 自定义属性要以data-开头&lt;/h3&gt;
&lt;p&gt;自己添加的非标准的属性要以data-开头，否则&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fvalidator.w3.org%2F&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;w3c validator&lt;/a&gt;会认为是不规范的，如下不好的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;data-count&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-4&quot;&gt;4. td要在tr里面，li要在ul/ol里面&lt;/h3&gt;
&lt;p&gt;如下不好的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更常见的是td没有写在tr里面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你写得不规范，有些浏览器会帮你矫正，但是有些可能就没有那么幸运。因为标准并没有说如果写得不规范应该怎么处理，各家浏览器可能有自己的处理方式。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-5&quot;&gt;5. ul/ol的直接子元素只能是li&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;123&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;a&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;b&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写也是不规范的，不能直接在ol里面写span，ol是一个列表，它的子元素应该都是display: list-item的，突然冒出来个span，你让浏览器如何自处。所以写得不规范就会导致在不同的浏览器会有不同的表现。&lt;/p&gt;
&lt;p&gt;同样，tr的直接子元素都应该是td，你在td里面写tr那就乱了。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-6&quot;&gt;6. section里面要有标题标签&lt;/h3&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;p&gt;如果你用了section/aside/article/nav这种标签的话，需要在里面写一个h1/h2/h3之类的标题标签，因为这四个标签可以划分章节，它们都是独立的章节，需要有标题，如果UI里面根本就没有标题呢？那你可以写一个隐藏的标题标签，如果出于SEO的目的，你不能直接display: none，而要用一些特殊的处理方式，如下套一个hidden-text的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;.hidden-text&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -9999px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -9999px&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;hidden-text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Listing Detail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-7&quot;&gt;7. 使用section标签增强SEO&lt;/h3&gt;
&lt;p&gt;使用section的好处是可以划分章节，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Listing Detail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;House Infomation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;LOCATION&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BUILDING&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Listing Picture&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就会被outline成这样的大纲：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180310214617846-985231153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-8&quot;&gt;8. 行内元素里面不可使用块级元素&lt;/h3&gt;
&lt;p&gt;例如下面的写法是不合法的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/listing?id=123&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a标签是一个行内元素，行内元素里面套了一个div的标签，这样可能会导致a标签无法正常点击。再或者是span里面套了div，这种情况下需要把inline元素显式地设置display为block，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/listing?id=123&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display: block&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-9&quot;&gt;9. 每个页面要写&amp;lt;!DOCType html&amp;gt;&lt;/h3&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;设置页面的渲染模式为标准模式，如果忘记写了会怎么样？忘记写了会变成怪异模式，怪异模式下很多东西渲染会有所不同，怪异模式下input/textarea的默认盒模型会变成border-box，文档高度会变成可视窗口的高度，获取window的高度时就不是期望的文档高度。还有一个区别，父容器行高在怪异模式下将不会影响子元素&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;test.jpg&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;height:100px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在标准模式下div下方会留点空白，而在怪异模式下会。这个就提醒我们在写邮件模板时需要在顶部加上&amp;lt;!DOCType html&amp;gt;，因为在本地开发邮件模板时是写html片段，没有这个的话就会变成怪异模式。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-12&quot;&gt;10. 特殊情况下才在html里面写script和style&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;通常来说，在html里面直接写script和style是一种不好的实践，这样把样式、结构和逻辑都掺杂在一起了。但是有时候为了避免闪屏的问题，可能会直接在相应的html后面跟上调整的script，这种script看起来有点丑陋，但是很实用，是没有办法的办法。&lt;/p&gt;
&lt;div readability=&quot;31.5&quot;&gt;
&lt;h3 data-id=&quot;heading-13&quot;&gt;11. 样式要写在head标签里&lt;/h3&gt;
&lt;div readability=&quot;66.5&quot;&gt;
&lt;p&gt;样式不能写在body里，写在body里会导致渲染两次，特别是写得越靠后，可能会出现闪屏的情况，例如上面的已经渲染好了，突然遇到一个style标签，导致它要重新渲染，这样就闪了一下，不管是从码农的追求还是用户的体验，在body里面写style终究是一种下策。&lt;/p&gt;
&lt;p&gt;同样地script不要写在head标签里面，会阻碍页面加载。&lt;/p&gt;
&lt;p&gt;而CSS也推荐写成style标签直接嵌在页面上，因为如果搞个外链，浏览器需要先做域名解析，然后再建立连接，接着才是下载，这一套下来可能已经过了0.5s/1s，甚至2~3秒。而写在页面的CSS虽然无法缓存，但是本身它也不会很大，再加gzip压缩，基本上在50k以内。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-14&quot;&gt;12. html要加上lang的属性&lt;/h3&gt;
&lt;p&gt;如下，如果是英文的网页，应该这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en-US&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一种表示它是英文的网页，第二种表示它是美国英语的网页，加上这个的好处是有利于SEO和屏幕阅读器使用者，他可以快速地知道这个网页是什么语言的，如果是中文可以这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-15&quot;&gt;13. 要在head标签靠前位置写上charset的meta标签&lt;/h3&gt;
&lt;p&gt;如下，一般charset的meta标签要写在head标签后的第一个标签：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个原因是避免网页显示unicode符号时乱码，写在前面是因为w3c有规定，语言编码要在html文档的前1024个字节。如果不写的话在老的浏览器会有utf-7攻击的隐患，具体可以自行查阅资料，只是现在的浏览器基本都去掉了对utf-7编码的支持了。&lt;/p&gt;
&lt;p&gt;charset的标签写成html5的这种比较简洁的写法就行了，不需要写成html4这种长长的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 data-id=&quot;heading-16&quot;&gt;14. 特殊符号使用html实体&lt;/h3&gt;
&lt;p&gt;不要直接把Unicode的特殊符号直接拷到html文档里面，要使用它对应的实体Entity&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180310215154632-715375390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特别是像©这种符号，不要从UI里面直接拷一个unicode的字符过去，如果直接拷过去会比较丑，它取的是用的字体里面的符号。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-17&quot;&gt;15. img空src的问题&lt;/h3&gt;
&lt;p&gt;有时候可能你需要在写一个空的img标签，然后在JS里面动态地给它赋src，所以你可能会这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;p&gt;但是这样写会有问题，如果你写了一个空的src，会导致浏览器认为src就是当前页面链接，然后会再一次请求当前页面，就跟你写一个a标签的href为空类似。如果是background-image也会有类似的问题。这个时候怎么办呢？如果你随便写一个不存在的url，浏览器会报404的错误。&lt;/p&gt;
&lt;p&gt;我知道的有两种解决方法，第一种是把src写成about:blank，如下：&lt;/p&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;about:blank&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样它会去加载一个空白页面，这个没有兼容问题，不会加载当前页面，也不会报错&lt;/p&gt;
&lt;p&gt;第二种办法是写一个1px的透明像素的base64，如下代码所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种可能比较符合规范，但是第一种比较简单，并且没有兼容性问题。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-18&quot;&gt;16. 关于行内元素空格和换行的影响&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;有时候换行可能会引入空格，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Email: &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在label和input中间会有一个空格，这样可能会导致设置lable的width和input 的width两者的和等于form的时候会导致input换行了，有时候你检查半天没查出原因，最后可能发现，原来是多了一个空格，而这个空格是换行引起的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么&amp;lt;form&amp;gt;和&amp;lt;label&amp;gt;之间以及&amp;lt;input&amp;gt;和&amp;lt;/form&amp;gt;之间的换行为什么没引入空格&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这是因为块级元素开始的空白文本将会被忽略,并且，块级元素后面的空白文本结点将不会参与渲染&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个div之间有textNode的文本节点，但是不会参与渲染。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-19&quot;&gt;17. 类的命名使用小写字母加中划线连接&lt;/h3&gt;
&lt;p&gt;如下使用-连接，不要使用驼峰式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;hello-world&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 10 Mar 2018 13:59:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/8542301.html</dc:identifier>
</item>
<item>
<title>I2C总线协议的软件模拟实现方法 - micro虾米</title>
<link>http://www.cnblogs.com/microxiami/p/8528459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/microxiami/p/8528459.html</guid>
<description>&lt;p&gt;在上一篇博客中已经讲过&lt;a href=&quot;http://www.cnblogs.com/microxiami/p/8527464.html&quot;&gt;I2C总线通信协议&lt;/a&gt;，本文讲述I2C总线协议的软件模拟实现方法。&lt;/p&gt;
&lt;h2 id=&quot;简述&quot;&gt;1. 简述&lt;/h2&gt;
&lt;p&gt;所谓的I2C总线协议的软件模拟实现方法，就是用软件控制GPIO的输入、输出和高低电平变化，来模拟I2C总线通讯过程中SCL、SDA的电平变化来实现的。&lt;/p&gt;
&lt;h2 id=&quot;i2c总线的封装&quot;&gt;2. I2C总线的封装&lt;/h2&gt;
&lt;p&gt;每个处理器对应的GPIO操作都有差异，即使是同一款处理器，不同的人也会有不同的GPIO封装风格，就以我个人习惯用的GPIO方法为例来进行讲解。我习惯上将GPIO的组和位封装为一个结构体，这样使用方便，看起来也更直观。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct {
    unsigned char group;
    unsigned char bit;
} gpio_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将I2C总线中使用的SCL和SDA的GPIO进一步进行封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct {
    gpio_t scl;
    gpio_t sda;
} i2c_gpio_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将I2C总线软件模拟部分当做驱动程序中的一个模块来使用，定义一个结构体来封装I2C模块中的一些全局变量，如：GPIO、锁等等。本文中的锁只是为了保证I2C的一个操作步骤是原子的，所有锁的使用可以忽略，如果想要了解更过关于锁的使用方法，请关注另外一篇博客（还没来得及写，以后会补充）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct {
    i2c_gpio_t gpio;
    spinlock_t lock;
    struct mutex i2c_mutex;
} i2c_info_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;软件模拟实现&quot;&gt;3. 软件模拟实现&lt;/h2&gt;
&lt;h3 id=&quot;i2c总线的初始化&quot;&gt;3.1 I2C总线的初始化&lt;/h3&gt;
&lt;p&gt;1）先初始化I2C总线，具体要做的内容是，先把外部调用I2C模块时要使用的GPIO引脚，作为参数传递到I2C模块，用来进行一系列的操作。在这里将GPIO作为参数传递到I2C模块后，保存在全局变量的结构体中。&lt;br/&gt;2）再初始化I2C总线的GPIO引脚，即将用来代替模拟I2C总线中SCL、SDA引脚的GPIO设置为输出，并输出高电平，因为两条线上都接有上拉电阻，I2C总线空闲时默认SCL、SDA都处于高电平，也就是空闲状态。&lt;br/&gt;3）如果要使用锁机制，需要在这一步中将锁初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C模块初始化
int i2c_init(i2c_gpio_t *gpio)
{
    i2c_debug(&quot;i2c_init&quot;);

    // 初始化锁
    spin_lock_init(&amp;amp;i2c_info.lock);
    mutex_init(&amp;amp;i2c_info.i2c_mutex);

    // 初始化全局变量中I2C的GPIO
    i2c_info.gpio.scl = gpio-&amp;gt;scl;
    i2c_info.gpio.sda = gpio-&amp;gt;sda;

    i2c_gpio_init();

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// I2C的GPIO初始化
static void i2c_gpio_init(void)
{
    i2c_debug(&quot;i2c_gpio_init&quot;);
    i2c_sda_init();
    i2c_scl_init();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// I2C的SCL初始化
static void i2c_scl_init(void)
{
    i2c_debug(&quot;scl init&quot;);
    SET_SCL_OUT;
    SET_SCL_HIGH;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// I2C的SDA初始化
static void i2c_sda_init(void)
{
    i2c_debug(&quot;sda init&quot;);
    SET_SDA_OUT;
    SET_SDA_HIGH;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i2c总线的起始位&quot;&gt;3.2 I2C总线的起始位&lt;/h3&gt;
&lt;p&gt;I2C总线在开始通信时要先发送一个起始位标志，起始位是在SCL为高电平时，SDA由高电平变为低电平。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线的起始位
int i2c_start(void)
{
    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    SET_SDA_HIGH;
    udelay(I2C_DELAY);

    SET_SCL_HIGH;
    udelay(I2C_DELAY);

    SET_SDA_LOW;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i2c总线的结束位&quot;&gt;3.3 I2C总线的结束位&lt;/h3&gt;
&lt;p&gt;I2C总线在数据传输完成后，需要发送一个结束位，来结束I2C通讯，并释放I2C总线，结束位是在SCL为高电平时，SDA由低电平变为高电平&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线的结束位
int i2c_stop(void)
{
    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);

    SET_SDA_LOW;
    udelay(I2C_DELAY);

    SET_SCL_HIGH;
    udelay(I2C_DELAY);

    SET_SDA_HIGH;
    udelay(I2C_DELAY);
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i2c总线的应答&quot;&gt;3.4 I2C总线的应答&lt;/h3&gt;
&lt;p&gt;为了统一管理和使用方便，将I2C总线的等待应答、发送应答信号、发送非应答信号封装在一起进行管理。&lt;/p&gt;
&lt;h4 id=&quot;i2c总线的等待应答&quot;&gt;1）I2C总线的等待应答&lt;/h4&gt;
&lt;p&gt;在I2C总线通讯时，主设备给从设备发送一个字节的数据后，要等待从设备的一个应答信号，这时候主设备处于等待应答状态，需要检测从设备的应答信号是否到来，如果从设备的应答信号到来，主设备就继续给从设备发送下一个字节的数据，或者发送停止位结束I2C通讯；如果在主设备等待超时后，从设备的应答信号时钟不到来，就说明I2C总线通讯中出现问题，主设备跳出等待，直接发送结束位，以结束I2C总线通讯。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线的等待应答
static int i2c_wait_ack(void)
{
    int ack_times = 0;
    int ret = 0;

    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    SET_SDA_HIGH;
    udelay(I2C_DELAY);

    SET_SDA_IN;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);

    SET_SCL_HIGH;
    udelay(I2C_DELAY);

    ack_times = 0;
    // 检测从设备应答信号
    while (GET_SDA_VAL) {
        ack_times++;
        // 判断等待是否超时
        if (ack_times == 10) {
            ret = 1;
            i2c_error(&quot;i2c ack error, no ack&quot;);
            break;
        }
    }

    SET_SCL_LOW;
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);

    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;i2c总线的发送应答&quot;&gt;2）I2C总线的发送应答&lt;/h4&gt;
&lt;p&gt;在I2C总线通信的时候，主设备每次接收到从设备发送的一个字节数据后，要给从设备发送应答信号（ACK）以继续接收从设备的数据，或者给从设备发送非应答信号（NOACK）以结束接收从设备的数据。&lt;br/&gt;应答信号（ACK）就是先拉低SDA线，并在SCL为高电平期间保持SDA线为低电平&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线发送应答信号
static int i2c_send_ack(void)
{
    i2c_debug(&quot;i2c_send_ack&quot;);

    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);

    SET_SDA_LOW;
    udelay(I2C_DELAY);

    SET_SCL_HIGH;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非应答信号（NOACK）就是不要拉低SDA线（此时SDA线为高电平），并在SCL为高电平期间保持SDA线为高电平。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线发送非应答信号
static int i2c_send_noack(void)
{
    i2c_debug(&quot;i2c_send_noack&quot;);

    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);

    SET_SDA_HIGH;
    udelay(I2C_DELAY);

    SET_SCL_HIGH;
    udelay(I2C_DELAY);

    SET_SCL_LOW;
    udelay(I2C_DELAY);
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i2c总线的写操作&quot;&gt;3.5 I2C总线的写操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线的写操作
int i2c_write_byte(u8 data)
{
    unsigned long flag = 0;
    u8 i = 0;

    local_irq_save(flag);
    preempt_disable();
    mutex_lock(&amp;amp;i2c_info.i2c_mutex);
    SET_SDA_OUT;
    udelay(I2C_DELAY);

    for (i = 0; i &amp;lt; 8; i++) {
        if (data &amp;amp; 0x80) {
            SET_SDA_HIGH;
        } else {
            SET_SDA_LOW;
        }
        udelay(I2C_DELAY);

        SET_SCL_HIGH;
        udelay(I2C_DELAY);

        SET_SCL_LOW;
        udelay(I2C_DELAY);

        data &amp;lt;&amp;lt;= 0x1;
    }
    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);
    preempt_enable();
    local_irq_restore(flag);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;int i2c_write_byte_with_ack(u8 data)
{
    i2c_write_byte(data);
    if (i2c_ack(I2C_WAIT_ACK)) {
        i2c_error(&quot;wait ack failed, no ack&quot;);
        i2c_stop();
        return -1;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i2c总线的读操作&quot;&gt;3.6 I2C总线的读操作&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// I2C总线的读操作
int i2c_read_byte(u8 *data)
{
    unsigned long flag = 0;
    u8 ret = 0;
    u8 i = 0;

    local_irq_save(flag);
    preempt_disable();
    mutex_lock(&amp;amp;i2c_info.i2c_mutex);

    SET_SDA_IN;
    udelay(I2C_DELAY);

    for (i = 0; i &amp;lt; 8; i++) {
        SET_SCL_HIGH;
        udelay(I2C_DELAY);

        ret &amp;lt;&amp;lt;= 1;

        if (GET_SDA_VAL) {
            ret |= 0x01;
        }

        SET_SCL_LOW;
        udelay(I2C_DELAY);
    }

    mutex_unlock(&amp;amp;i2c_info.i2c_mutex);
    preempt_enable();
    local_irq_restore(flag);

    *data = ret;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 10 Mar 2018 13:42:00 +0000</pubDate>
<dc:creator>micro虾米</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/microxiami/p/8528459.html</dc:identifier>
</item>
<item>
<title>docker进阶-搭建私有企业级镜像仓库Harbor - 进击的小羊驼</title>
<link>http://www.cnblogs.com/pass245939319/p/8542177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pass245939319/p/8542177.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://img.shepherd618.cn/harbor.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么要搭建私有镜像仓库&quot;&gt;为什么要搭建私有镜像仓库&lt;/h4&gt;
&lt;p&gt;  对于一个刚刚接触Docker的人来说,官方的Docker hub是用于管理公共镜像。既然官方提供了镜像仓库我们为什么还要去自己搭建私有仓库呢？虽然也可以托管私有镜像。我们可以非常方便的把我们自己镜像推送上去，但是Docker hub提供的私有仓库个数有限。对于个人来说Docker hub是个不错的选择，但是对于企业来说，相对于安全 ，成本和公司的架构来说搭建自己的私有镜像仓库才是正确的道路。&lt;/p&gt;
&lt;h4 id=&quot;什么是harbor为什么要选择harbor&quot;&gt;什么是Harbor?为什么要选择Harbor&lt;/h4&gt;
&lt;p&gt;  &lt;a href=&quot;https://vmware.github.io/harbor/cn/&quot;&gt;Harbor&lt;/a&gt;是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;基于角色的访问控制 - 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。&lt;/li&gt;
&lt;li&gt;镜像复制 - 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。&lt;/li&gt;
&lt;li&gt;图形化用户界面 - 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。&lt;/li&gt;
&lt;li&gt;AD/LDAP 支持 - Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。&lt;/li&gt;
&lt;li&gt;审计管理 - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。&lt;/li&gt;
&lt;li&gt;国际化 - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。&lt;/li&gt;
&lt;li&gt;RESTful API - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;部署简单 - 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。&lt;br/&gt;这就是官网原话。完美解释了什么是Harbor?为什么要选择Harbor。上面解释那么多的Harbor, 现在我们来开始安装吧。&lt;/p&gt;
&lt;h4 id=&quot;harbor安装&quot;&gt;Harbor安装&lt;/h4&gt;
&lt;p&gt;  要安装Harbor,有以下几个先决条件：&lt;br/&gt;    &lt;em&gt;Python版本大于或者等于2.7&lt;br/&gt;    &lt;/em&gt;Docker engine的版本大于等于1.10&lt;br/&gt;    Docker Compose的版本大于1.6.0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  首先我们需要检查自己服务器是否支持上面3个条件。输入以下代码检查&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#python2.7官网安装页面
https://www.python.org/downloads/release/python-2711/
#检查Python版本.Ubuntu 16.04已经集成了python2.7。
python -V
#检查Docker的版本
docker -v
#Docker Compose安装脚本
sudo curl -L https://github.com/docker/compose/releases/download/1.6.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
#检查Docker Compose的版
docker-compose --version
#如果提示Permission denied。执行以下语句赋权
sudo chmod +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  确保服务器上的软件版本已经满足以上要求之后。我们现在开始安装Harbor。如果不知道怎么安装docker 可以参考我博客之前的文章。&lt;a href=&quot;http://www.cnblogs.com/pass245939319/p/8473861.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;下载harbor&quot;&gt;下载Harbor&lt;/h5&gt;
&lt;pre class=&quot;dsconfig&quot;&gt;
&lt;code&gt;#下载安装包
wget https://github.com/vmware/harbor/releases/download/v1.1.2/harbor-offline-installer-v1.1.2.tgz
#解压
tar -xzf harbor-offline-installer-v1.1.2.tgz
cd harbor
#编辑配置文件
vi harbor.cfg&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置文件注释参考&quot;&gt;配置文件注释参考&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;## Configuration file of Harbor

#设置访问地址，支持IP，域名，主机名，禁止设置127.0.0.1
hostname = reg.mydomain.com

#访问方式，http或者https
ui_url_protocol = http

#邮件通知相关设置
email_server = smtp.mydomain.com
email_server_port = 25
email_username = sample_admin@mydomain.com
email_password = abc
email_from = admin &amp;lt;sample_admin@mydomain.com&amp;gt;
email_ssl = false

#用户登录密码
harbor_admin_password = Harbor12345

#harbor认证模式，默认为db_auth，本地mysql，也可以配置ldap认证 
auth_mode = db_auth

#ldap认证配置
ldap_url = ldaps://ldap.mydomain.com
ldap_basedn = ou=people,dc=mydomain,dc=com
ldap_uid = uid 
ldap_scope = 3 

#mysql数据库设置
db_password = root123
self_registration = on
use_compressed_js = on
max_job_workers = 3 
token_expiration = 30
verify_remote_cert = on
customize_crt = on

#显示的认证及组织信息 
crt_country = CN
crt_state = State
crt_location = CN
crt_organization = organization
crt_organizationalunit = organizational unit
crt_commonname = example.com
crt_email = example@example.com
project_creation_restriction = everyone

#SSL证书地址。只有开启https访问才生效
ssl_cert = /data/cert/server.crt
ssl_cert_key = /data/cert/server.key
#############
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  以上按照自己需求修改。如果想开启https模式访问需要自己申请ssl证书。harbor默认监听80端口。如果需要修改端口。请修改目录下的docker-compose.yml文件，&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/updatepro.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;修改完成之后。运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo ./install.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  进行安装。安装完成之后他会自己启动。这里他会自己下载一些他所需的images。过程有点慢。可以通过阿里云的镜像加速器来加速。&lt;a href=&quot;https://cr.console.aliyun.com/?spm=5176.2020520152.0.0.660c16ddODAIcD#/accelerator&quot;&gt;阿里云镜像加速器&lt;/a&gt; .打开链接登录之后点击镜像加速。然后你会得到一个专属加速地址。如图&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/aliyun_docker.png&quot; alt=&quot;enter image description here&quot;/&gt;可以根据自己的环境查看文档安装使用。然后等待命令执行结束。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/harbor_insert.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;开启https&quot;&gt;开启https&lt;/h5&gt;
&lt;p&gt;  如果使用http的这里可以跳过，我们把已经申请好的证书文件放到/data/cert 目录下面。然后修改harbor.cfg文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.shepherd618.cn/harbor_config.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;  安装成功之后打开之前自己设定的域名或者IP地址。&lt;a href=&quot;https://shepherd618.cn:3002/&quot;&gt;测试地址&lt;/a&gt; 。测试用户名:harbor_test，测试密码：Harbor_test123&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/harhub_index.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用harbor&quot;&gt;使用harbor&lt;/h4&gt;
&lt;h5 id=&quot;创建用户&quot;&gt;创建用户&lt;/h5&gt;
&lt;p&gt;harbor已经创建成功。现在我们来开始创建一个用户。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/add_user.gif&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建项目&quot;&gt;创建项目&lt;/h5&gt;
&lt;p&gt;创建项目，并添加用户&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/add_pro.gif&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;上传镜像&quot;&gt;上传镜像&lt;/h5&gt;
&lt;p&gt;  首先使用docker login命令登录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#登录
robin:~ robin$ sudo docker login shepherd618.cn
Username: admin
Password: 
Login Succeeded
#查看本地镜像
robin:docker_demo robin$ sudo docker images 
Password:
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker_demo         latest              fdd994bee741        19 seconds ago      283MB
node                8.9-alpine          406f227b21f5        2 weeks ago         68.1MB
#给dcoker_demo新增tag
robin:docker_demo robin$ sudo docker tag docker_demo shepherd618.cn/test/demo
#push images
robin:docker_demo robin$ docker push shepherd618.cn/test/demo
The push refers to repository [shepherd618.cn/test/demo]
f8387a884f73: Layer already exists 
d74f9d9e7013: Pushed 
f846841ed47f: Layer already exists 
0198944a9875: Layer already exists 
9dfa40a0da3b: Layer already exists 
latest: digest: sha256:5b33acc5edf6f48cbd8e7ccd216daa4a7da1ebd4871fbc68bc2517136f1ccf44 size: 1374
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后打开harbor,会看到刚刚上传的images和操作日志&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/push_images.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;当我们需要用到这个images的时候可以通过上面给的pull命令下载到本地。到此整个安装过程结束。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Mar 2018 13:39:00 +0000</pubDate>
<dc:creator>进击的小羊驼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pass245939319/p/8542177.html</dc:identifier>
</item>
<item>
<title>Struts2【配置】知识要点 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8542023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8542023.html</guid>
<description>&lt;p&gt;上篇Struts博文已经讲解了Struts的开发步骤以及执行流程了.....对Struts的配置文件有了了解.....本博文继续讲解&lt;strong&gt;Struts在配置的时候一些值得要学习的细节&lt;/strong&gt;...&lt;/p&gt;

&lt;h2 id=&quot;为什么要学习通配符&quot;&gt;为什么要学习通配符&lt;/h2&gt;
&lt;p&gt;在讲解通配符之前，我们来看一下需求.....&lt;/p&gt;
&lt;p&gt;现在我的&lt;strong&gt;Action中有两个方法&lt;/strong&gt;,处理登陆和处理注册：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PrivilegeAction &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ActionSupport {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;login&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是登陆&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是注册&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，我们就需要在struts.xml文件中配置两个action节点&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;register&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;register&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们发现：它们&lt;strong&gt;仅仅只有访问路径和方法的名称是不一样的&lt;/strong&gt;....但是这却要多配置一个action节点，会&lt;strong&gt;造成浪费&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;于是乎通配符就应运而生了...&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;使用通配符改造&quot;&gt;使用通配符改造&lt;/h2&gt;
&lt;p&gt;没有通配符之前，我们是需要配置两个action的...有了通配符，我们是这样做的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;package&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilige&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; extends=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts-default&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilege_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/package&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;name=privilege_*&lt;/code&gt;，我们用了_作为分隔符。*就是我们的通配符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{1}&lt;/code&gt;，就是代表着第一个通配符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来看一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427142727293?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理可得，当我们在地址栏访问login的时候，就会执行login的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427142823473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;有的时候，我们可能会在package节点中指定namespace名称空间，我们在&lt;strong&gt;访问对应的资源名称的时候，就需要在前面加入相对应名称空间的值&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名称空间的值为“/user”&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;package&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilige&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; extends=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts-default&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; namespace=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/user&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilege_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/package&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么在访问资源的时候，就需要在项目名称后边加上名称空间的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427143533726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就有一个很奇怪妙的事情发生了：&lt;strong&gt;在名称空间和资源路径的中间可添加任意的路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427143751244?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是呢，&lt;strong&gt;不能在名称空间之前加入不存在的路径&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427143925918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;其实这就涉及到了Struts中路径的匹配原则，我就拿随便拿个路径来举例子&lt;code&gt;http://localhost:8080/user/a/a/privilege_login&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，Struts会把请求的资源路径拿到，也就是&lt;code&gt;privilege_login&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;然后在看看有没有&lt;code&gt;/user/a/a&lt;/code&gt;这个名称空间；如果有，就返回结果&lt;/li&gt;
&lt;li&gt;如果没有，就看看有没有&lt;code&gt;/user/a&lt;/code&gt;这个名称空间；如果有，就返回结果&lt;/li&gt;
&lt;li&gt;如果没有，再看看有没有&lt;code&gt;/user&lt;/code&gt;这个名称空间；如果有，就返回结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直到最后，如果都没有找到，就报错！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看完这个例子，我们就可以知道为啥&lt;strong&gt;在名称空间和资源路径的中间可添加任意的路径&lt;/strong&gt;，而&lt;strong&gt;不能在名称空间之前加入不存在的路径&lt;/strong&gt;....这就是Struts的路径匹配原则..&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;Struts2默认的访问后缀是.action&lt;/strong&gt;......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427145058480?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改默认访问路径&quot;&gt;修改默认访问路径&lt;/h2&gt;
&lt;p&gt;有的时候，可能根据项目的需要...我想后缀名默认并不是.action，那我该怎么办呢？？&lt;/p&gt;
&lt;p&gt;我们在jar包上找到它的配置文件...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427145352485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现它的默认值是&lt;strong&gt;&lt;code&gt;action,,&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是：&lt;strong&gt;两个逗号并不是多余的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们不可能是直接修改jar包中的配置文件的，&lt;strong&gt;在struts.xml文件中提供了constant节点供我们修改struts的常量&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427150112067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面已经说了，两个逗号并不是多余的。那么&lt;strong&gt;直接在配置文件中配置action&lt;/strong&gt;时，会怎么样:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.action.extension&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427150525444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;“,”号能够匹配空格键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例子说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果配置后缀为&lt;code&gt;action&lt;/code&gt;。那么后缀一定要写action&lt;/li&gt;
&lt;li&gt;如果配置后缀为&lt;code&gt;action,do,&lt;/code&gt;。那么后缀可以是action，可以是do，也可以不写&lt;/li&gt;
&lt;li&gt;如果配置后缀为&lt;code&gt;action,,&lt;/code&gt;。那么后缀可以是action，可以不写&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;struts常用的常量&quot;&gt;Struts常用的常量&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427151104305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;struts&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 0. 请求数据编码 --&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.i18n.encoding&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 1. 修改Struts默认的访问后缀 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.action.extension&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;action,do,&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/constant&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 2. 修改xml自动重新加载 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.configuration.xml.reload&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 3. 开启动态方法调用 (默认不开启)--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.enable.DynamicMethodInvocation&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 4. 修改上传文件的最大大小为30M --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;constant&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts.multipart.maxSize&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;31457280&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/struts&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有动态方法调用是我们没有接触过的。&lt;br/&gt;那动态方法调用是怎么回事呢？？？这是样的：&lt;strong&gt;在action节点不配置method属性，在地址栏使用&lt;code&gt;资源名称!方法名&lt;/code&gt;的方式去调用业务方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427152315542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;为什么需要跳转全局视图&quot;&gt;为什么需要跳转全局视图？&lt;/h2&gt;
&lt;p&gt;首先，我们还是来看一个需求：现在我有两个Action，PrivilegeAction和CategoryAction&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PrivilegeAction&lt;br/&gt;```java&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;public class PrivilegeAction extends ActionSupport {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String login() {
    System.out.println(&quot;我是登陆&quot;);

    return &quot;success&quot;;
}

public String register() {
    System.out.println(&quot;我是注册&quot;);
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CategoryAction&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CategoryAction &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ActionSupport {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是添加&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;find&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是查找&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在struts.xml文件中配置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilege_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;category_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.CategoryAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现一个问题，&lt;strong&gt;只要是方法返回值是success，那么就跳转到首页&lt;/strong&gt;....如果有&lt;strong&gt;大量Action方法返回的都是success&lt;/strong&gt;，那么就要&lt;strong&gt;写很多很多个result节点了&lt;/strong&gt;..&lt;/p&gt;
&lt;h2 id=&quot;使用跳转全局视图&quot;&gt;使用跳转全局视图&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;代码就可以变成是这样子了，注意：&lt;strong&gt;&lt;code&gt;global-results&lt;/code&gt;节点需要在action节点的上面&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;package&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilige&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; extends=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;struts-default&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;global-results&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/global-results&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilege_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;category_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.CategoryAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;/package&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427153900472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;一份相对完整的action节点是这样子的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilege_*&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;privilegeaction.PrivilegeAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{1}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;method&quot;&gt;method&lt;/h2&gt;
&lt;p&gt;如果我们不写method的话，&lt;strong&gt;默认执行的是execute()方法,execute()方法默认返回值是SUCCESS&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BBAtion &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ActionSupport {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是execute()&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; SUCCESS;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170427154655513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;class&quot;&gt;class&lt;/h2&gt;
&lt;p&gt;如果不写class，&lt;strong&gt;class默认执行的action在struts-default有配置&lt;code&gt;&amp;lt;default-class-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot; /&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么时候会不写class？&lt;strong&gt;就是需要跳转到WEB-INF目录下的资源的时候&lt;/strong&gt;.....这就类似与Servlet需要跳转到WEB-INF下的资源。&lt;strong&gt;【Tomcat不允许直接访问WEB-INF资源】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 什么情况不配置class？ 即处理的aciton --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 答案： 当只是需要跳转到WEB-INF下资源的时候。 --&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;success&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;/WEB-INF/index.jsp&lt;span class=&quot;kw&quot;&gt;&amp;lt;/result&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;&amp;lt;/action&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。&lt;strong&gt;习惯在微信看技术文章，想要获取更多的Java资源的同学，可以关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 10 Mar 2018 13:07:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8542023.html</dc:identifier>
</item>
<item>
<title>Java并发编程-各种锁 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/8542008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/8542008.html</guid>
<description>&lt;p&gt;安全性和活跃度通常相互牵制。我们使用锁来保证线程安全，但是滥用锁可能引起&lt;strong&gt;锁顺序死锁&lt;/strong&gt;。类似地，我们使用线程池和信号量来约束资源的使用，&lt;/p&gt;
&lt;p&gt;但是缺不能知晓哪些管辖范围内的活动可能形成的资源死锁。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.死锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;经典的“哲学家进餐”问题很好的阐释了死锁。5个哲学家一起出门去吃中餐，他们围坐在一个圆桌边。他们只有五只筷子(不是5双)，每两个人中间放有一只。&lt;/p&gt;
&lt;p&gt;哲学家边吃边思考，交替进行。每个人都需要获得两只筷子才能吃东西，但是吃后要把筷子放回原处继续思考。有一些管理筷子的算法，使每一个人都能够或多或少，及时&lt;/p&gt;
&lt;p&gt;吃到东西(一个饥饿的哲学家试图获得两只临近的筷子，但是如果其中的一只正在被别人占用，那么他英爱放弃其中一只可用的筷子，等待几分钟再尝试)。但是这样做可能导致&lt;/p&gt;
&lt;p&gt;一些哲学家或者所有哲学家都饿死 (每个人都迅速捉住自己左边的筷子，然后等待自己右边的筷子变成可用，同时并不放下左边的筷子)。这最后一种情况，当每个人都拥有他人需要的&lt;/p&gt;
&lt;p&gt;资源，并且等待其他人正在占有的资源，如果大家一致占有资源，直到获得自己需要却没占有的其他资源，如果大家一致占有资源，直到获得自己需要却没被占有的其他资源，那么就会产生死锁。&lt;/p&gt;
&lt;p&gt;　　当一个线程永远占有一个锁，而其他线程尝试去获得这个锁，那么他们将永远被阻塞。当线程Thread1占有锁A时，想要获得锁B，但是同时线程Thread2持有B锁，并尝试获得A锁，两个线程将永远等待下去。&lt;/p&gt;
&lt;p&gt;这种情况是死锁最简单的形式.&lt;/p&gt;
&lt;p&gt;例子如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLock {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeadLock().deadLock();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deadLock() {

        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (lockA){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取A锁 ing！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;睡眠500ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;需要B锁！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (lockB){
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B锁获取成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
            }
        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thread1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (lockB){
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取B锁 ing！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;睡眠500ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;需要A锁！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (lockA){
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread().getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A锁获取成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
            }
        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thread2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        thread1.start();
        thread2.start();

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310121038816-1601285642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果很明显了，这两个线程陷入了死锁状态了，发生死锁的原因是，两个线程试图通过不同的顺序获得多个相同的锁。如果请求锁的顺序相同，&lt;/p&gt;
&lt;p&gt;就不会出现循环的锁依赖现象(你等我放锁，我等你放锁)，也就不会产生死锁了。如果你能够保证同时请求锁A和锁B的每一个线程，都是按照从锁A到锁B的顺序，那么就不会发生死锁了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果所有线程以通用的固定秩序获取锁，程序就不会出现锁顺序死锁问题了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么情况下会发生死锁呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.锁的嵌套容易发生死锁。解决办法：获取锁时，查看是否有嵌套。尽量不要用锁的嵌套，如果必须要用到锁的嵌套，就要指定锁的顺序，因为参数的顺序是超乎我们控制的，为了解决这个问题，我们必须指定锁的顺序，并且在整个应用程序中，&lt;/p&gt;
&lt;p&gt;获得锁都必须始终遵守这个既定的顺序。&lt;/p&gt;

&lt;p&gt;上面的例子出现死锁的根本原因就是获取所的顺序是乱序的，超乎我们控制的。上面例子最理想的情况就是把业务逻辑抽离出来，把获取锁的代码放在一个公共的方法里面，让这两个线程获取锁&lt;/p&gt;
&lt;p&gt;都是从我的公共的方法里面获取，当Thread1线程进入公共方法时，获取了A锁，另外Thread2又进来了，但是A锁已经被Thread1线程获取了，Thread1接着又获取锁B，Thread2线程就不能再获取不到了锁A，更别说再去获取锁B了，这样就有一定的顺序了。&lt;/p&gt;
&lt;p&gt;上面例子的改造如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLock {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeadLock().deadLock();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deadLock() {

        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                getLock();
            }
        },&lt;/span&gt;&quot;Thread1&quot;&lt;span&gt;);

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                getLock();
            }
        },&lt;/span&gt;&quot;Thread2&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getLock() {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lockA){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;获取A锁 ing！&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;睡眠500ms&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;需要B锁！！！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lockB){
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;B锁获取成功&quot;&lt;span&gt;);
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310143751536-774465696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到把业务逻辑抽离出来，把获取锁的代码放在一个公共的方法里面，获得锁都必须始终遵守这个既定的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.引入显式锁的超时机制特性来避免死锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;超时机制是监控死锁和从死锁中恢复的技术，是使用每个显式所Lock类中定时tryLock特性，来替代使用颞部所机制。在内部锁的机制中，只要没有获得锁，就永远保持等待，而&lt;/p&gt;
&lt;p&gt;显示的锁使你能狗定义超时的时间，在规定时间之后tryLock还没有获得锁就会返回失败。通过使用超时，尽管这段时间比你预期能够获得所的时间长很多，你仍然可以在意外发生后重新&lt;/p&gt;
&lt;p&gt;获得控制权。当尝试获得定时锁失败时，你并不需要知道原因。也许是因为有死锁发生，也许是线程在持有锁的时候错误地进入无限循环；也有可能是执行一些活动所花费的时间比你&lt;/p&gt;
&lt;p&gt;预期慢了许多。不过至少你有机会了解到你的尝试已经失败，记录下这次尝试中有用的信息，并重新开始计算，这远比关闭整个线程要优雅得多。&lt;/p&gt;
&lt;p&gt;　　即使定时锁并没有应用于整个系统，使用它来获得多重锁还是能够有效应对死锁。如果获取锁的请求超时，你可以释放这个锁，并后退，等待一会后再尝试，这很可能消除了死锁发生的条件，&lt;/p&gt;
&lt;p&gt;并且循序程序恢复。(这项技术只有在同时获得两个锁的时候才有效；如果多个锁是在嵌套的方法中被请求的，你无法仅仅释放外层的锁，尽管你知道自己已经持有该锁)&lt;/p&gt;

&lt;p&gt;显式锁Lock，Lock是一个接口，定义了一些抽象的所操作。与内部锁机制不同，Lock提供了无条件，可轮询，定时的，可中断的锁获取操作，所有加锁和解锁的方法都是显式的。&lt;/p&gt;
&lt;p&gt;Lock的实现必须提供举报与内部锁相同的内存可见性的语义。但是加锁的语义，调度算法，顺序保证，性能特性这些可以不同。&lt;/p&gt;
&lt;p&gt;Lock接口源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Lock {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可中断的锁，打算线程的等待状态，即A线程已经获取该锁，B线程又来获    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取，但是A线程会通知B，来打算B线程的等待。&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt; lockInterruptibly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException;   
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试去获取锁，失败返回False&lt;/span&gt;
     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; tryLock(); 


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时机制获取锁&lt;/span&gt;
     &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; 
     InterruptedException;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放锁&lt;/span&gt;
     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock();

     Condition newCondition();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ReentranLock实现了Lock接口，提供了与synchronized相同的互斥和内存可见性的保证。获得ReentrantLock的锁与进入synchronized块有着相同内存含义，释放ReentrantLock锁与退出synchronized块有着相同内存含义。&lt;/p&gt;
&lt;p&gt;ReentrantLock提供了与synchronized一样可重入加锁的语义。ReentrantLock支持Lock接口定义的所有获取锁的方式。与synchronized相比，ReentranLock为处理不可用的锁提供了更多灵活性。&lt;/p&gt;
&lt;p&gt;但是对于现在的JDK的更新，synchronized的性能被优化的越来越好，内部锁(synchronized)已经获得相当可观的性能，性能不仅仅是个不断变化的目标，而且变化的非常快。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310205946549-791706657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到图，随着JDK的更新迭代，内部锁的性能越来越快，这不是ReentrantLock的衰退，而是内部锁(synchronized)越来越快，特别在JDK目前跟新到现在1.9.&lt;/p&gt;

&lt;p&gt;下面用显式锁Lock再来改造上面的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLock {

    Lock lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object lockB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeadLock().deadLock();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deadLock() {

        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;获取A锁 ing！&quot;&lt;span&gt;);
                    Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;睡眠500ms&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    lock.unlock();
                }
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;需要B锁！！！&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;B锁获取成功&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    lock.unlock();
                }
            }
        }, &lt;/span&gt;&quot;Thread1&quot;&lt;span&gt;);

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;获取B锁 ing！&quot;&lt;span&gt;);
                    Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;睡眠500ms&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    lock.unlock();
                }
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;需要A锁！！！&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    lock.lock();
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;A锁获取成功&quot;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    lock.unlock();
                }
            }
        }, &lt;/span&gt;&quot;Thread1&quot;&lt;span&gt;);

        thread1.start();
        thread2.start();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310193706650-873261091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到显示锁Lock是可以避免死锁的。&lt;/p&gt;

&lt;p&gt;注意：Lock接口规范形式。这种模式在某种程度上比使用内部锁更加复杂：锁必须在finally块中释放。另一方面，如果锁守护的代码在try块之外抛出了异常，它将永远都不会被释放了；如果对象&lt;/p&gt;
&lt;p&gt;能够被置于不一致状态，可能需要额外的try-catch，或try-finally块。(当你在使用任何形式的锁时，你总是应该关注异常带来的影响，包括内部锁)。&lt;/p&gt;
&lt;p&gt;忘记时候finally释放Lock是一个定时炸弹。当不幸发生的时候，你将很难追踪到错误的发生点，因为根本没有记录锁本应该被释放的位置和时间。这就是ReentrantLock不能完全替代synchronized的原因：它更加危险，&lt;/p&gt;
&lt;p&gt;因为当程序的控制权离开守护的块，不会自动清除锁。尽管记得在finally块中释放锁并不苦难，但忘记的可能仍然存在。&lt;/p&gt;
&lt;p&gt;sy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可轮询的和可定时的锁请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;可定时的与可轮询的锁获取模式，是由tryLock方法实现，与物体爱建的锁获取相比，它具有更完善的错误恢复机制。在内部锁中，死锁是致命的，唯一的恢复方法是重新启动程序，唯一的预防方法是在构建程序时不要出错，&lt;/p&gt;
&lt;p&gt;所以不可能循序不一致的锁顺序。可定时的与可轮询的锁提供了另外一个选择：可以规避死锁的放生。&lt;/p&gt;
&lt;p&gt;　　如果你不能获得所有需要的锁，那么使用可定时的与可轮询的获取方式(tryLock)使你能够重新拿到控制权，它会释放你已经获得的这些锁，然后再重新尝试(或者至少会记录这个失败，抑或者采取其他措施)。使用tryLock试图获得两个锁，&lt;/p&gt;
&lt;p&gt;如果不能同时获得两个，就回退，并重新尝试。休眠时间由一个特定的组件管理，并由一个随机组件减少活锁发生的可能性。如果一定时间内，没有获得所有需要的锁，就会返回一个失败状态，这样操作就能优雅的失败了。&lt;/p&gt;
&lt;p&gt;tryLock（）经常与if esle一起使用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;读-写锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　ReentrantLock实现了标准的互斥锁：一次最多只有一个线程能够持有相同ReentrantLock。但是互斥通常做为保护数据一致性的很强的加锁约束，因此，过分的限制了并发性。互斥是保守的加锁策略，避免了&lt;/p&gt;
&lt;p&gt;“写/写”和“写/读&quot;的重读，但是同样避开了&quot;读/读&quot;的重叠。在很多情况下，数据结构是”频繁被读取“的——它们是可变的，有时候会被改变，但多数访问只进行读操作。此时，如果能够放宽，允许多个读者同时访问数据结构就&lt;/p&gt;
&lt;p&gt;非常好了。只要每个线程保证能够读到最新的数据(线程的可见性)，并且在读者读取数据的时候没有其他线程修改数据，就不会发生问题。这就是读-写锁允许的情况：一个资源能够被多个读者访问，或者被一个写者访问，两者不能同时进行。&lt;/p&gt;
&lt;p&gt;ReadWriteLock，暴露了2个Lock对象，一个用来读，另一个用来写。读取ReadWriteLock锁守护的数据，你必须首先获得读取的锁，当需要修改ReadWriteLock守护的数据，你必须首先获得写入锁。&lt;/p&gt;
&lt;p&gt;ReadWriteLock源码接口如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ReadWriteLock {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns the lock used for reading.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the lock used for reading
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Lock readLock();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns the lock used for writing.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the lock used for writing
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Lock writeLock();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读写锁实现的加锁策略允许多个同时存在的读者，但是只允许一个写者。与Lock一样，ReadWriteLock允许多种实现，造成性能，调度保证，获取优先，公平性，以及加锁语义等方面的不尽相同。&lt;/p&gt;
&lt;p&gt;读写锁的设计是用来进行性能改进的，使得特定情况下能够有更好的并发性。时间实践中，当多处理器系统中，频繁的访问主要为读取数据结构的时候哦，读写锁能够改进性能；在其他情况下运行的情况比独占&lt;/p&gt;
&lt;p&gt;的锁要稍微差一些，这归因于它更大的复杂性。使用它能否带来改进，最好通过对系统进行剖析来判断：好在ReadWriteLock使用Lock作为读写部分的锁，所以如果剖析得的结果发现读写锁没有能提高性能，把读写锁置换为独占锁是比较容易。&lt;/p&gt;

&lt;p&gt;下面我们用synchonized来进行读操作，对于读操作性能如何呢？&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadWriteLockTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ReentrantReadWriteLock rw1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReadWriteLockTest test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReadWriteLockTest();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; get(Thread thread) {

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() - start &amp;lt;= 1&lt;span&gt;){
            System.out.println(thread.getName() &lt;/span&gt;+ &quot;正在读操作&quot;&lt;span&gt;);
        }
        System.out.println(thread.getName() &lt;/span&gt;+ &quot;读操作完成&quot;&lt;span&gt;);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310201833644-1383265082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到要线程Thread0读操作完了，Thread1才能进行读操作。明显这样性能很慢。&lt;/p&gt;

&lt;p&gt;现在我们用ReadWriteLock来进行读操作，看一下性能如何&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadWriteLockTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ReentrantReadWriteLock rw1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReadWriteLockTest test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReadWriteLockTest();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; get(Thread thread) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            rw1.readLock().lock();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() - start &amp;lt;= 1&lt;span&gt;){
                System.out.println(thread.getName() &lt;/span&gt;+ &quot;正在读操作&quot;&lt;span&gt;);
            }
            System.out.println(thread.getName() &lt;/span&gt;+ &quot;读操作完成&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            rw1.readLock().unlock();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310202309642-409371681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到线程间是不用排队来读操作的。这样效率明显很高。&lt;/p&gt;

&lt;p&gt;我们再看一下写操作，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadWriteLockTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ReentrantReadWriteLock rw1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReadWriteLockTest test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReadWriteLockTest();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                test.get(Thread.currentThread());
            }
        }.start();

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; get(Thread thread) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            rw1.writeLock().lock();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() - start &amp;lt;= 1&lt;span&gt;){
                System.out.println(thread.getName() &lt;/span&gt;+ &quot;正在写操作&quot;&lt;span&gt;);
            }
            System.out.println(thread.getName() &lt;/span&gt;+ &quot;写操作完成&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            rw1.writeLock().unlock();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310202627186-1631965111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到ReadWriteLock只允许一个写者。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;公平锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ReentrantReadWriteLock为两个锁提供了可重入的加锁语义，它是继承了ReadWriteLock，扩展了ReadWriteLock。它与ReadWriteLock相同，ReentrantReadWriteLock能够被构造&lt;/p&gt;
&lt;p&gt;为非公平锁(构造方法不设置参数，默认是非公平)，或者公平。在公平锁中，选择权交给等待时间最长的线程；如果锁由读者获得，而一个线程请求写入锁，那么不再允许读者获得读取锁，直到写者被受理，平且已经释放了写锁。&lt;/p&gt;
&lt;p&gt;在非公平的锁中，线程允许访问的顺序是不定的。由写者降级为读者是允许的；从读者升级为写者是不允许的(尝试这样的行为会导致死锁)&lt;/p&gt;
&lt;p&gt;　　当锁被持有的时间相对较长，并且大部分操作都不会改变锁守护的资源，那么读写锁能够改进并发性。ReadWriteMap使用了ReentrantReadWriteLock来包装Map,使得它能够在多线程间&lt;/p&gt;
&lt;p&gt;被安全的共享，并仍然能够避免 &quot;读-写&quot; 或者 ”写-写“冲突。显示中ConcurrentHashMap并发容器的性能已经足够好了，所以你可以是使用他，而不必使用这个新的解决方案，如果你需要并发的部分&lt;/p&gt;
&lt;p&gt;只有哈希Map，但是如果你需要为LinkedHashMap这种可替换元素Map提供更好的并发访问，那么这项技术是非常有用的。&lt;/p&gt;
&lt;p&gt;用读写锁包装的Map如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310204831420-877443270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读写锁的性能如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201803/1202638-20180310204949786-348017052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;　　显式的Lock与内部锁相比提供了一些扩展的特性，包括处理不可用的锁时更好的灵活性，以及对队列行为更好的控制。但是ReentrantLock不能完全替代synchronized;只有当你需要&lt;/p&gt;
&lt;p&gt;synchronized没能提供的特性时才应该使用。&lt;/p&gt;
&lt;p&gt;　　读-写锁允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据库层面上的锁——悲观锁和乐观锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;乐观锁：&lt;/strong&gt;&lt;/span&gt;他对世界比较乐观，认为别人访问正在改变的数据的概率是很低的，所以直到修改完成准备提交所做的的修改到数据库的时候才会将数据锁住。完成更改后释放。&lt;/p&gt;
&lt;p&gt;我想一下一个这样的业务场景：我们从数据库中获取了一条数据，我们正要修改他的数据时，刚好另外一个用户此时已经修改过了这条数据，这是我们是不知道别人修改过这条数据的。&lt;/p&gt;
&lt;p&gt;　　解决办法，我们可以在表中增加一个version字段，让这个&lt;strong&gt;version自增或者自减&lt;/strong&gt;，或者&lt;strong&gt;用一个时间戳字段，这个时间搓字段是唯一的&lt;/strong&gt;。我们写数据的时候带上version，也就是每个人更新的时候都会判断当前的版本号是否跟我查询出来得到的版本号是否一致，不一致就更新失败，一致就更新这条记录并更改版本号。&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.查询出商品信息
select (status,status,version) from t_goods where id&lt;/span&gt;=&lt;span&gt;#{id}
&lt;/span&gt;2&lt;span&gt;.根据商品信息生成订单
&lt;/span&gt;3&lt;span&gt;.修改商品status为2
update t_goods 
set status&lt;/span&gt;=2,version=version+1&lt;span&gt;
where id&lt;/span&gt;=#{id} and version=#{version};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用户体验表现层面通常表现为系统繁忙之类的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这里还要注意乐观锁的一个细节：就是version字段要自增或者自减，否者会出现ABA问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;：线程Thread1拿到了version字段为A，由于CAS操作(即先进行比较然后设值)，线程Thread2先拿到的version,将version改成B，线程Thread3来拿到version，将version值又改回了A。此时Thread1的CAS(先比较后set值)操作结束了，继续执行，它发现version的值还是A，以为没有发生变化，所以就继续执行了。这个过程中，version从A变为B，再由B变为A就被形象地称为ABA问题了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;：&lt;/span&gt;也称排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操作该部分数据。这将防止其他进程读取或修改表中的数据。&lt;/p&gt;
&lt;p&gt;一般使用 select ...for update 对所选择的数据进行加锁处理，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * from account where name=”JAVA” &lt;span&gt;for&lt;/span&gt; update，
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 这条sql 语句锁定了account 表中所有符合检索条件（name=”JAVA”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。&lt;/p&gt;
&lt;p&gt;用户界面常表现为转圈圈等待。&lt;/p&gt;

&lt;p&gt;如果数据库分库分表了，不再是单个数据库了，那么我们可以用分布式锁，比如redis的setnx特性，zookeeper的节点唯一性和顺序性特性来做分布式锁。&lt;/p&gt;

</description>
<pubDate>Sat, 10 Mar 2018 13:04:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/8542008.html</dc:identifier>
</item>
</channel>
</rss>