<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MongoDB更需要好的模式设计 及 案例赏析 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9637158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9637158.html</guid>
<description>&lt;h2&gt;一  挑战&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;设计从来就是个挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们第一次接触数据库，学习数据库基础理论时，都需要学习范式，老师也一再强调范式是设计的基础。范式是这门课程中的重要部分，在期末考试中也一定是个重要考点。如果我们当年大学挂科了，说不定就是范式这道题没有做好。毕业后，当我们面试时，往往也有关于表设计方面拷问。&lt;/p&gt;
&lt;p&gt;很多时候，我们错误地认为，花费大量时间用在设计上，问题根源在于关系数据库(RDBMS)，在于二维表及其之间的联系组成的一个数据组织。而真实的环境中，我们正在大量使用noSQL或者NewSQL，按照目前的趋势（DB-Engines Ranking 得分），将来还会越来越普遍。选用noSQL或者NewSQL 就不需要模式设计了。并且，随着公司、行业数字化程度的加深，智能化触角逐渐延伸，数据量越来越大，结构越来越复杂。 例如现在很火的IOT行业，复杂的业务信息、多样的传输协议、不断升级的传感器，都需要灵活的数据模型来应对。在这种呼唤声中，MongoDB闪亮登场了。MongoDB支持灵活的数据模型。主要体现在以下2点：&lt;/p&gt;
&lt;p&gt;（1）自由模式，无需提前声明、创建表结构，即不用先创建表、添加字段，然后才可以Insert数据。默认情况下MongoDB无需这样操作，除非开启了模式验证。&lt;/p&gt;
&lt;p&gt;（2）键值类型自由，MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MongoDB不需要模式设计时错误的，其实面对复杂的结构对象，模式的自由带来更大的挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式的自由是对数据insert这个动作而言，它去除很多限制了，可以快速讲对象的存进来，并且易于扩展。但是不一定就会带来好的查询性能，&lt;strong&gt;好的查询性能还要来自于好的模式设计、来自于好的集合文档的设计。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;二  模式设计&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;MongoDB可以将模式设计划分为内嵌模式（Embedded）和 引用模式（References）&lt;/p&gt;
&lt;h3 class=&quot;Default&quot;&gt;&lt;strong&gt;内嵌模式&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;Default&quot;&gt;简单来讲，内嵌模式就是将关联数据，放在一个文档中。例如以下员工信息采用内嵌模式了而存储在了一个文档中：&lt;/p&gt;
&lt;p class=&quot;Default&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180912203114854-1622472883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;Default&quot;&gt;引用模式&lt;/h3&gt;
&lt;p&gt;引用模式是将数据存储在不同集合的文档中，而通过关系数据进行关联。例如，这里采用引用模式将员工信息存储在了3个文档中，基本信息一个文档，联系方式一个文档，登录权限放在了一个文档中。每个文档之前通过user_id来关联。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180912203138544-1142693289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 三  案例 &lt;/h2&gt;
&lt;p&gt;下面我们通过一些业务场景，一些具体的案例，来分析、品味一下MongoDB模式设计的选择。&lt;/p&gt;

&lt;h3&gt;案例 1&lt;/h3&gt;

&lt;p&gt; 假如现在我们描述来顾客（patron）和顾客的地址（address），其ER图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180913005156329-937701800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我们可以将patron和address设计成两个集合(collection,类似于RDBMS数据库中的table)，其具体信息如下：&lt;/p&gt;
&lt;p&gt; patron 集合&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   _id: &quot;joe&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   name: &quot;Joe Bookreader&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; address 集合&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   patron_id: &quot;joe&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   street: &quot;123 Fake Street&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   city: &quot;Faketon&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   state: &quot;MA&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   zip: &quot;12345&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 在设计address 集合时，内嵌了patron集合的_id字段，通过这个字段进行关联。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但这种实体关系为1:1，强关联的关系&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;推荐设计成如下模式：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   _id: &quot;joe&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   name: &quot;Joe Bookreader&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   address: {&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;              street: &quot;123 Fake Street&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;              city: &quot;Faketon&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;              state: &quot;MA&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;              zip: &quot;12345&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;            }&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 即使用内嵌模式，将数据存储在一个集合中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;案例2&lt;/h3&gt;

&lt;p align=&quot;left&quot;&gt; 一个顾客维护一个地址是理想的状况，回头看看我们淘宝账号，就会发现收货地址一般都是2个以上 ( 流泪 ╥╯^╰╥)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180913005114046-1656900669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt; patron 集合顾客joe的文档记录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   _id: &quot;joe&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   name: &quot;Joe Bookreader&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; address 集合joe顾客的&lt;strong&gt;地址1&lt;/strong&gt;的文档记录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   patron_id: &quot;joe&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   street: &quot;123 Fake Street&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   city: &quot;Faketon&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   state: &quot;MA&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   zip: &quot;12345&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  address 集合中joe顾客的&lt;strong&gt;地址2&lt;/strong&gt;的文档记录&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   patron_id: &quot;joe&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   street: &quot;1 Some Other Street&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   city: &quot;Boston&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   state: &quot;MA&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   zip: &quot;12345&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 像这种1：N的关系，并且N可以预见不是很多的情况下，我们推荐采用内嵌模式，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;将集合文档设计成如下模式：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   _id: &quot;joe&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   name: &quot;Joe Bookreader&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   addresses: [&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  street: &quot;123 Fake Street&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  city: &quot;Faketon&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  state: &quot;MA&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  zip: &quot;12345&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                },&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  street: &quot;1 Some Other Street&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  city: &quot;Boston&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  state: &quot;MA&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                  zip: &quot;12345&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              ]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 与案例1的不同就是地址信息采用了数组类型，数组的字段值又为内嵌子文档。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;案例3&lt;/h3&gt;

&lt;p align=&quot;left&quot;&gt; 上面介绍的是1对多的关系（1：N），但是N值不是很大。但是现实世界中，有时候会遇到N值比较大的情况。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;比如 出版社和书籍的关系，一个出版社可能已将出版了成千上万本书籍了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180913002430534-382511139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其设计模式可以如下（内嵌模式），将出版社的信息作为一个子文档，来内嵌到书籍的文档中，具体信息如下：&lt;/p&gt;
&lt;p&gt;以下书籍《MongoDB: The Definitive Guide》的文档信息： &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   title: &quot;MongoDB: The Definitive Guide&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   author: [ &quot;Kristina Chodorow&quot;, &quot;Mike Dirolf&quot; ],&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   published_date: ISODate(&quot;2010-09-24&quot;),&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   pages: 216,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   language: &quot;English&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   publisher: {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              name: &quot;O'Reilly Media&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              founded: 1980,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              location: &quot;CA&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 以下书籍《50 Tips and Tricks for MongoDB Developer》的文档信息： &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   title: &quot;50 Tips and Tricks for MongoDB Developer&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   author: &quot;Kristina Chodorow&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   published_date: ISODate(&quot;2011-05-06&quot;),&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   pages: 68,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   language: &quot;English&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   publisher: {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              name: &quot;O'Reilly Media&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              founded: 1980,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;              location: &quot;CA&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从中可以看出，publisher信息描述比较多，并且都相同，每个文档中都存放，浪费太多的存储空间，显得无用臃肿，还有个明显的缺点就是 当publisher数据更新时，需要对所有的书籍文档进行刷新。理所当然地，就会想到将出版社独立出来，单独设计一个文档。（引用模式）。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt; 引用模式1&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;我们可以这样设计：出版社单独设计为一个集合文档（&lt;strong&gt;文档中引用书籍的编号&lt;/strong&gt;），如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   name: &quot;O'Reilly Media&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   founded: 1980,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   location: &quot;CA&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;strong&gt;&lt;span&gt;  books: [123456789, 234567890, ...]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 书籍集合中编号为123456789的书籍的文档：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    _id: 123456789,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    title: &quot;MongoDB: The Definitive Guide&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    author: [ &quot;Kristina Chodorow&quot;, &quot;Mike Dirolf&quot; ],&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    published_date: ISODate(&quot;2010-09-24&quot;),&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    pages: 216,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    language: &quot;English&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  书籍集合中编号为234567890的书籍的文档：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   _id: 234567890,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   title: &quot;50 Tips and Tricks for MongoDB Developer&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   author: &quot;Kristina Chodorow&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   published_date: ISODate(&quot;2011-05-06&quot;),&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   pages: 68,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   language: &quot;English&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此设计中，将出版社出版的书的编号，保存在了出版社这个集合中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但是这种设计还是有问题，例如，&lt;strong&gt;数组的更新、删除相对比较困难&lt;/strong&gt;。还有就是，每增加一个书籍集合的文档，同时还要修改这个出版社结合的文档。 所以，我们还可以将这种集合文档设计优化如下。&lt;/p&gt;
&lt;h4 align=&quot;left&quot;&gt;引用模式2&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;此时出版社的文档记录如下：（不再应用书籍文档的编号）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   _id: &quot;oreilly&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   name: &quot;O'Reilly Media&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   founded: 1980,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   location: &quot;CA&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此时书籍的文档记录如下：（书籍为123456789，文档引用了出版社的_ID）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   _id: 123456789,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   title: &quot;MongoDB: The Definitive Guide&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   author: [ &quot;Kristina Chodorow&quot;, &quot;Mike Dirolf&quot; ],&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   published_date: ISODate(&quot;2010-09-24&quot;),&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   pages: 216,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   language: &quot;English&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt; &lt;span&gt;&lt;strong&gt;  publisher_id: &quot;oreilly&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此时书籍的文档记录如下：（书籍为234567890，文档引用了出版社的_ID） &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   _id: 234567890,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   title: &quot;50 Tips and Tricks for MongoDB Developer&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   author: &quot;Kristina Chodorow&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   published_date: ISODate(&quot;2011-05-06&quot;),&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   pages: 68,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   language: &quot;English&quot;,&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;   &lt;strong&gt;&lt;span&gt;publisher_id: &quot;oreilly&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt; 案例 4&lt;/h3&gt;

&lt;p&gt;上面三个例子，在关系型数据库中都可以用我们学习过的关系（例如1：1；1：N）来描述，那么我们再举一个关系型数据库难以描述的关系 -- &lt;span&gt;&lt;strong&gt;树状关系&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;例如，我们在电商网站上常见的商品分类关系，一级商品、二级商品、三级商品、四级商品关系。我们简化此例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180913011753391-2032829743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 那么在MongoDB中可以轻松实现他们关系的查询。&lt;/p&gt;
&lt;h4&gt;情景1  查询节点的父节点（或称为查询上一级分类）；或者查询节点的子节点（或者为查询下一级分类）&lt;/h4&gt;
&lt;p&gt;文档的设计为：&lt;/p&gt;

&lt;p&gt;db.categories.insert( { _id: &quot;MongoDB&quot;, parent: &quot;Databases&quot; } )&lt;br/&gt;db.categories.insert( { _id: &quot;dbm&quot;, parent: &quot;Databases&quot; } )&lt;br/&gt;db.categories.insert( { _id: &quot;Databases&quot;, parent: &quot;Programming&quot; } )&lt;br/&gt;db.categories.insert( { _id: &quot;Languages&quot;, parent: &quot;Programming&quot; } )&lt;br/&gt;db.categories.insert( { _id: &quot;Programming&quot;, parent: &quot;Books&quot; } )&lt;br/&gt;db.categories.insert( { _id: &quot;Books&quot;, parent: null } )&lt;/p&gt;

&lt;p&gt;查询节点的父节点（或称为查询上一级分类）的语句，例如查询MongoDB所属分类：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;nx&quot;&gt;db&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;categories&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;findOne&lt;span class=&quot;p&quot;&gt;( &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;nx&quot;&gt;_id&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;MongoDB&quot; &lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;p&quot;&gt;).&lt;span class=&quot;nx&quot;&gt;parent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;查询节点的子节点（或者为查询下一级分类），例如查询Database的直连的子节点（不是孙子节点）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;db.categories.find( { parent: &quot;Databases&quot; } )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面的文档可以查询出子文档，但是会显示出多个文档，例如上面的查询语句，会返回出MongoDB 文档和 dbm文档 ，我们还需要还特殊处理，那么可不可以在一个文档中显示出所以的子节点呢？&lt;/p&gt;
&lt;p&gt;可以的。文档模式设计如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;MongoDB&quot;, children: [] } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;dbm&quot;, children: [] } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Databases&quot;, children: [ &quot;MongoDB&quot;, &quot;dbm&quot; ] } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Languages&quot;, children: [] } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Programming&quot;, children: [ &quot;Databases&quot;, &quot;Languages&quot; ] } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Books&quot;, children: [ &quot;Programming&quot; ] } )&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果这时候查询Databases的子节点，就会是一个文档了。查询验证语句如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.findOne( { _id: &quot;Databases&quot; } ).children&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;此模式也支持查询节点的父节点。例如查询MongoDB这个节点的父节点：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.find( { children: &quot;MongoDB&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;情景2  查询祖先节点&lt;/h4&gt;
&lt;p&gt;其文档设计为：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;MongoDB&quot;, ancestors: [ &quot;Books&quot;, &quot;Programming&quot;, &quot;Databases&quot; ], parent: &quot;Databases&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;dbm&quot;, ancestors: [ &quot;Books&quot;, &quot;Programming&quot;, &quot;Databases&quot; ], parent: &quot;Databases&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Databases&quot;, ancestors: [ &quot;Books&quot;, &quot;Programming&quot; ], parent: &quot;Programming&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Languages&quot;, ancestors: [ &quot;Books&quot;, &quot;Programming&quot; ], parent: &quot;Programming&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Programming&quot;, ancestors: [ &quot;Books&quot; ], parent: &quot;Books&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.insert( { _id: &quot;Books&quot;, ancestors: [ ], parent: null } )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如查询MongoDB节点的祖先节点：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.findOne( { _id: &quot;MongoDB&quot; } ).ancestors&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当然也可以查询 后代节点：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.categories.find( { ancestors: &quot;Programming&quot; } )&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;四  后记&lt;/h2&gt;
&lt;p&gt;MongoDB的模式设计是一个比较大的课题，需要多看看情景案例，多品味一些优秀的文档设计，多问些问什么要这样做，是否有更优的设计，要慢慢去领悟MongoDB的哲学思想。&lt;/p&gt;
&lt;p&gt;总之，这是一个多看、多想、多思的蜕变羽化过程，可能时间很长、过程有些痛苦。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 18:58:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 挑战 设计从来就是个挑战。 当我们第一次接触数据库，学习数据库基础理论时，都需要学习范式，老师也一再强调范式是设计的基础。范式是这门课程中的重要部分，在期末考试中也一定是个重要考点。如果我们当年大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9637158.html</dc:identifier>
</item>
<item>
<title>从 nodejs -&gt; sequelize -&gt; postgres，你都得设置好时区 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9638367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9638367.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;最近在做报表统计，因为 sequelize 的时区配置没加导致了统计数字对不上的问题。&lt;/p&gt;

&lt;p&gt;答：&lt;code&gt;UTC&lt;/code&gt; 是我们&lt;strong&gt;现在用的&lt;/strong&gt;时间标准，&lt;code&gt;GMT&lt;/code&gt; 是老的时间计量标准。&lt;/p&gt;
&lt;p&gt;（1）&lt;code&gt;GMT&lt;/code&gt; 是根据地球的自转和公转来计算时间，也就是太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间就是中午12点&lt;/p&gt;
&lt;p&gt;缺点：地球的&lt;strong&gt;自转正在缓速变慢&lt;/strong&gt;。所以 GMT 会越来越有误差。&lt;/p&gt;
&lt;p&gt;国外科学家认为，地球自转变慢的原因有很多，其中包括来自月球的潮汐力以及地核降温等等。预计 100 年以后每天时间会增加 1.8ms，2 亿年之后，地球上一天的是将是 25 小时。&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;UTC&lt;/code&gt; 是根据原子钟来计算时间，50 亿年误差一秒，可以说非常&lt;strong&gt;精确&lt;/strong&gt;。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;nodejs -&amp;gt; sequelize -&amp;gt; postgres&lt;/p&gt;
&lt;h3 id=&quot;nodejs&quot;&gt;1、nodejs&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;（1）类 UNIX OS&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;process.env.TZ = 'Asia/Shanghai';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）mac / windows&lt;/p&gt;
&lt;p&gt;修改系统设置，如 mac 下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201809/896608-20180913023523059-1809490855.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;moment().format(&quot;YYYY-MM-DD HH:mm:ss Z&quot;)  
//2018-09-13 01:44:09 +08:00

// 修改时区

moment().format(&quot;YYYY-MM-DD HH:mm:ss Z&quot;)  
//2018-09-12 18:44:25 +01:00 &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;postgres&quot;&gt;2、postgres&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;（1）配置文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;postgresql.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;timezone = 'PRC'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）postgres CLI&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set timezone = 'xxx'&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：postgres 底层存的是 UTC 时间，set timezone 只是改变了数据库展示时间的方式（带时区）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;show timezone // postgres 默认为 PRC ( = Asia/Shanghai)
select &quot;activatedAt&quot; from &quot;Members&quot; where id = '373'
//2018-07-26 07:13:38.291+08
 
//修改时区
set timezone='UTC'
show timezone // UTC
select &quot;activatedAt&quot; from &quot;Members&quot; where id = '373'
//2018-07-25 23:13:38.291+00&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sequelize&quot;&gt;3、sequelize&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;timezone: '+08:00'&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let sequelize = new Sequelize(config.database, config.username, config.password, {
        &quot;username&quot;: &quot;username&quot;,
        &quot;password&quot;: &quot;password&quot;,
        &quot;database&quot;: &quot;database&quot;,
        &quot;host&quot;: &quot;127.0.0.1&quot;,
        &quot;port&quot;: 5432,
        &quot;dialect&quot;: &quot;postgres&quot;, 
        timezone: '+08:00',  // 等同于 postgres 的 `set timezone = 'xxx'` 
});
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://sequelize.readthedocs.io/en/latest/api/sequelize/&quot; class=&quot;uri&quot;&gt;https://sequelize.readthedocs.io/en/latest/api/sequelize/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201809/896608-20180913023535399-1590899732.png&quot; alt=&quot;原文&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201809/896608-20180913023546964-1522307855.png&quot; alt=&quot;翻译&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 18:37:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<og:description>背景 最近在做报表统计，因为 sequelize 的时区配置没加导致了统计数字对不上的问题。 问：大家都知道时区，但是你清楚 UTC 和 GMT 的区别吗？ 答： 是我们 现在用的 时间标准， 是老的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9638367.html</dc:identifier>
</item>
<item>
<title>2018校招面试随笔 - 疯狂阿贾克斯</title>
<link>http://www.cnblogs.com/caizhiqin/p/9638346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caizhiqin/p/9638346.html</guid>
<description>&lt;p&gt;　　今年4月底入职当前互联网公司，有幸参加了公司2018校招，负责某java岗初试的一面或者二面（初试一轮或者两轮看情况的）。第一次参与校招，持续两天，今天刚忙完，晚上躺在床上竟有点睡不着，想反思下这两天的操作，文笔不佳，想到啥写点啥。&lt;/p&gt;
&lt;p&gt;　　连续的面试下来，感觉被考验的既是校招生，也是自己。来面试的不乏名校高材生，更有竞赛高手，年级排名靠前的学霸，感觉多数是完胜当年刚毕业时的自己。&lt;/p&gt;
&lt;p&gt;　　由于很多学生并不会java，自己给面试者准备的内容一是操作系统、计算机网络、算法与数据结构、http相关随机发问；二是简历上的项目深挖（但是感觉对于学生的python和c++项目大多数最终还是面试效果不太理想，需要提升自己的技能覆盖面）；三就是最后的编程题；&lt;/p&gt;
&lt;p&gt;　　在最后的编程题上，主要准备了三道不同的题目，看心情随机问。其一是回文算法，比较简单，但答上来后会升级，升级后寻找当前字符串的最长回文子串，不要求实现给出思路就行；其二是寻找两个字符串的最大公共子串；其三是自创的兔子问题改编版：初始有一对成年兔子，成年兔子每3个月会生一对兔子（一开始说成年当月不生，后来干脆统一成年当月也生），小兔子需要4个月成年，成年兔子1年后死亡，求n个月后兔子对数。&lt;/p&gt;
&lt;p&gt;　　总的来说在内容一、二上的面试感觉自己做的还可以，但在编程题的面试过程中，还是有很多需要改进的敌方（睡不着的主要原因，觉得是不是有点对某些好学生不公平？）。&lt;/p&gt;
&lt;p&gt;　　其一是对于回文算法的升级版，前两个编程题都是反复挑选的网上的题，因此也是有看过网上能找到的各种实现。答案其实多重多样，但在第一天上午的面试中，有一个同学在升级难度后最终没找到思路，最后请求我给出见解，略微遗憾的是，当时我一下子也忘了怎么弄了，遂把前一个学生的解答思路回复给他（把字符串反转，然后就变成了题2，可以有新的思路了），但其实也并没有为该同学解答困惑。&lt;/p&gt;
&lt;p&gt;　　其二是对于求最大公共子串问题，没有适当准备给面试者的提示，陷入当面试同学请求提示时感觉提示了就毫无难度了，不提示又不太好的尴尬境地（最坏的结果是换题，换题非常不好，印象很深的一妹子被我换题后问懵了，感觉跟自己没准备好这题的提示有一定的关系）&lt;/p&gt;
&lt;p&gt;　　第三题自创的题，自己准备了一套面向对象的解法，但由于多数同学不会java，最终也没有同学按照我的思路来。不过也得到了各种千奇百怪的答案，各有特色，现场无法逐一验证， 很多答案在现场沟通中暂时没发现漏洞。(ps：所有的同学都忽略了兔子会死亡的设定，选择性忽略？)&lt;/p&gt;
&lt;p&gt;　　下面是自创兔子问题的答案，不是最优解但感觉思路明朗。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44.5&quot;&gt;
&lt;pre readability=&quot;18&quot;&gt;
/**&lt;br/&gt;* 根据设定，4岁成年，age=4，在4，7，10，13岁时会产生新的兔子，age=16时会死亡&lt;br/&gt;*/&lt;br/&gt;@Data&lt;br/&gt;class Rabbit {&lt;br/&gt;public static List&amp;lt;Rabbit&amp;gt; rabbits = new ArrayList&amp;lt;&amp;gt;(); //兔子池&lt;br/&gt;public static int month = 12; //目标月&lt;p&gt;private int age = 0;&lt;/p&gt;&lt;p&gt;public Rabbit(int age) {&lt;br/&gt;this.age = age;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void grow() {&lt;br/&gt;this.age++;&lt;br/&gt;if (age &amp;gt;= 4 &amp;amp;&amp;amp; age &amp;lt; 16) {&lt;br/&gt;breed();&lt;br/&gt;}&lt;br/&gt;if (age == 16) {&lt;br/&gt;die();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private void breed() {&lt;br/&gt;if (this.age % 3 == 1) {&lt;br/&gt;rabbits.add(new Rabbit(0));&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;private void die() {&lt;br/&gt;rabbits.remove(this);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void main(String args[]) {&lt;br/&gt;Rabbit rab = new Rabbit(4);&lt;br/&gt;rabbits.add(rab);&lt;br/&gt;for (int i = 1; i &amp;lt;= month; i++) {&lt;br/&gt;new ArrayList&amp;lt;&amp;gt;(rabbits).forEach(j -&amp;gt; j.grow());&lt;br/&gt;System.out.println(&quot;第&quot; + i + &quot;月 ，当前兔子年龄：&quot; + rabbits.stream().map(k -&amp;gt; Integer.toString(k.getAge())).reduce((u, v) -&amp;gt; u + &quot;,&quot; + v).get());&lt;br/&gt;}&lt;br/&gt;System.out.print(rabbits.size());&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 12 Sep 2018 17:46:00 +0000</pubDate>
<dc:creator>疯狂阿贾克斯</dc:creator>
<og:description>今年4月底入职当前互联网公司，有幸参加了公司2018校招，负责某java岗初试的一面或者二面（初试一轮或者两轮看情况的）。第一次参与校招，持续两天，今天刚忙完，晚上躺在床上竟有点睡不着，想反思下这两天</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caizhiqin/p/9638346.html</dc:identifier>
</item>
<item>
<title>【坐标系杂谈】投影后的数据如何去除投影？ - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/9638333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/9638333.html</guid>
<description>&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;网友有时候的问题很奇葩，但是这也给了我一个思考的余地：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然GCS能投影到PCS，那么为什么PCS不能恢复到GCS呢？我们知道，ArcGIS的矢量要素一旦投影完毕，就不能再恢复到其本身的GCS（虽然PCS有GCS的定义，但是投影法则不能去除），只能进行投影转换了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人说当然可以，反解不就行了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想说，你累吗？反解公式就能累死人，而且还不一定好找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天就给大家两种解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;第一种，即经纬度坐标值备份法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第二种，ArcGIS动态投影法。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果对PCS、GCS等坐标系不太熟悉的同学建议阅读我的坐标系统博客。B站/CSDN/博客园/知乎 均为同ID：秋意正寒。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;优点：不会丢失属性信息&lt;/p&gt;
&lt;p&gt;缺点：必须在投影之前操作，如果只有投影后的文件，请参考方法二&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即在进行投影之前，进行“添加XY信息”这一操作，该工具位于【数据管理工具箱】-【要素工具集】-【添加XY信息】。这样就能把经纬度提前写入属性表。&lt;/p&gt;
&lt;p&gt;或者添加两个字段，进行计算几何操作，单位选择十进制度，同样也能添加经纬度到属性表（与【添加XY信息】工具同样的效果）。&lt;/p&gt;
&lt;p&gt;ps：我们都知道，一个shp/一个矢量要素由空间数据和非空间数据组成，空间数据即其几何信息和坐标信息，非空间数据即其字段与属性值。&lt;/p&gt;
&lt;p&gt;在方法一中，我们就是把空间数据做了备份。&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;优点：投影后也可以操作，用于临时恢复地理坐标系统表示的数据&lt;/p&gt;
&lt;p&gt;缺点：属性信息需要重新导入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此法借助ArcGIS的动态投影功能，将数据框的单位改为十进制度，然后在计算几何时，将单位也改为十进制度即可。&lt;/p&gt;
&lt;p&gt;这样，就能把已经投影的数据的经纬度，以十进制度的形式写入属性表，此时再导出dbf表，再将其导入ArcGIS并设置坐标系为原数据的GCS就能恢复了，但是属性表需要重新组织。&lt;/p&gt;


&lt;p&gt;有人说这只能是点啊——有点你自己不会生成线和面吗？&lt;/p&gt;
&lt;p&gt;当然还有一种十分暴力的做法，那就是，如果知道某几个点的经纬度，不妨用空间校正...（逃&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 17:21:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>GCS到PCS只需投影，但是PCS如何脱去对应的投影法则呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onsummer/p/9638333.html</dc:identifier>
</item>
<item>
<title>/usr/bin/python: can't decompress data; zlib not available 的异常处理 - Bo_hemian</title>
<link>http://www.cnblogs.com/wkang/p/9638305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wkang/p/9638305.html</guid>
<description>&lt;h2&gt;1. 问题背景&lt;/h2&gt;
&lt;p&gt;使用Pycharm连接远程服务器端pipenv虚拟环境的python解释器，运行python spark脚本时报错如下错误：&lt;/p&gt;
&lt;p&gt;2018-09-12 23:56:00 ERROR Executor:91 - Exception in task 0.0 in stage 0.0 (TID 0)&lt;br/&gt;org.apache.spark.SparkException:&lt;br/&gt;Error from python worker:&lt;br/&gt;/usr/bin/python: can't decompress data; zlib not available&lt;br/&gt;PYTHONPATH was:&lt;br/&gt;/home/kangwang/.local/share/virtualenvs/pyspark-C8JL9jUk/lib/python3.5/site-packages/pyspark/python/lib/pyspark.zip:/home/kangwang/.local/share/virtualenvs/pyspark-C8JL9jUk/lib/python3.5/site-packages/pyspark/python/lib/py4j-0.10.7-src.zip:/home/kangwang/.local/share/virtualenvs/pyspark-C8JL9jUk/lib/python3.5/site-packages/pyspark/jars/spark-core_2.11-2.3.1.jar:/home/kangwang/.pycharm_helpers/pycharm_matplotlib_backend:/home/kangwang/myproject/pyspark&lt;br/&gt;java.io.EOFException&lt;br/&gt;at java.io.DataInputStream.readInt(DataInputStream.java:392)&lt;/p&gt;
&lt;p&gt;百度这个方法 &lt;a title=&quot;解决方法&quot; href=&quot;https://blog.csdn.net/iejtyq/article/details/64438398&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/iejtyq/article/details/64438398&lt;/a&gt;，发现无效，所以需要继续分析。&lt;/p&gt;
&lt;h2&gt;2. 问题分析&lt;/h2&gt;
&lt;p&gt;我是用pipenv在个人目录 myproject/pyspark下创建的虚拟环境，用来存放pyspark工程，其中python3.5解释器的安装路径为下面所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913000934570-1388283868.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据报错信息，可能是缺少相关依赖包，根据这篇博客https://blog.csdn.net/iejtyq/article/details/64438398 的做法，发现问题并没有得到解决，继续观察报错信息，发现其中的python解释器路径与我虚拟环境里的路径不一致，所以会不会是解释器的问题了呢？&lt;/p&gt;
&lt;p&gt;在服务器的虚拟环境下按以下方式执行test.py文件，发现并无报错。由此，结合上面报错信息，可知报错原因是Pycharm在Run test.py 时并没有成功使用虚拟环境下的python解释器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913002124366-2063167838.png&quot; alt=&quot;&quot; width=&quot;900&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. 解决办法&lt;/h2&gt;
&lt;p&gt;把虚拟环境下的python解释器加到pycharm中.py脚本的环境变量中，即 PATH=/home/kangwang/.local/share/virtualenvs/pyspark-C8JL9jUk/bin:$PATH&lt;/p&gt;
&lt;p&gt;具体步骤为1~7步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913005247413-916402921.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913005605037-1036249918.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913003307495-645586605.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上，就是这个脚本的环境变量配置过程。&lt;/p&gt;

&lt;p&gt;如果工程下的脚本都在服务器同一个虚拟环境下运行，采用上面那样一个一个脚本配置环境变量的方法会很繁琐，因此，可对整个工程下的环境变量进行设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913003727908-677011886.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1473228/201809/1473228-20180913004322549-408183606.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;工程下的环境变量的设置后，在该工程下创建新的.py文件时会自动添加已有的环境变量配置。然而，当重启Pycharm并再次进去该工程下创建新的.py文件时，之前设置的工程下的环境变量将失效，即不会保存。所以，在重启pycharm后，还需要再次重复上面8~15步。&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 17:00:00 +0000</pubDate>
<dc:creator>Bo_hemian</dc:creator>
<og:description>1. 问题背景 使用Pycharm连接远程服务器端pipenv虚拟环境的python解释器，运行python spark脚本时报错如下错误： 2018-09-12 23:56:00 ERROR Exe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wkang/p/9638305.html</dc:identifier>
</item>
<item>
<title>Web安全系列（二）：XSS 攻击进阶（初探 XSS Payload） - 梁音</title>
<link>http://www.cnblogs.com/liangyin/p/9638235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangyin/p/9638235.html</guid>
<description>&lt;p&gt;上一章我谈到了 XSS 攻击的几种分类以及形成的攻击的原理，并举了一些浅显的例子，接下来，我就阐述什么叫做 &lt;code&gt;XSS Payload&lt;/code&gt; 以及从攻击者的角度来初探 XSS 攻击的威力。&lt;/p&gt;
&lt;p&gt;在黑客 XSS 攻击成功之后，攻击者能够对用户当前浏览的页面植入各种恶意脚本，通过恶意脚本来控制浏览器，这些脚本实质上就是 &lt;code&gt;JavaScript&lt;/code&gt; 脚本（或者是其他浏览器可以运行的脚本），这种恶意植入且具有完成各种具体功能的恶意脚本就被称为 &lt;strong&gt;&lt;code&gt;XSS Payload&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个最常见的 &lt;code&gt;XSS Payload&lt;/code&gt; ，就是通过浏览器读取 Cookie 对象，进而发起 &lt;code&gt;Cookie 劫持&lt;/code&gt; 攻击。&lt;/p&gt;
&lt;p&gt;一般一个网站为了防止用户无意间关闭页面，重新打开需要重新输入账号密码繁杂的情况下，一般都会把登录信息（登录凭证）加密存储在 CooKie 中，并且设置一个超时时间，在此时间段内，用户利用自己账号信息随意进出该网站。如果该网站遭到 &lt;code&gt;XSS Payload&lt;/code&gt; ，黑客盗取了该用户的 Cookie 信息，往往意味着该用户的登录凭证丢失了，换句话说，攻击者不需要知道该用户的账号密码，直接利用盗取的 Cookie 模拟凭证，直接登录到该用户的账户。&lt;/p&gt;
&lt;p&gt;如下所示，攻击者先在一个社区发表一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/3d7076c5fa3dd695fe9d4d45043d73dc128e7a10.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你有意无意点了一下 &lt;code&gt;点我得大奖&lt;/code&gt; 这个时候，&lt;code&gt;XSS Payload&lt;/code&gt; 就生效了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/684f6e039d0a781320d2d85b62cd78cf8eed3d36.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/deb844b0af0ee7ae88075d162d424c20b266e492.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;XSS Payload&lt;/code&gt;会请求一个 img 图片，图片请求地址即为黑客的服务器地址， url 参数带上 Cookie ，我们在后台服务器接收到了这个请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/8376012029f460570f8dcfde463bff81ae59b526.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候，黑客就可以获取到此 Cookie，然后模拟 CooKie 登陆。&lt;/p&gt;
&lt;p&gt;当然传输的内容可以是任何内容，只要能获取到的，全都可以传输给后台服务器。&lt;/p&gt;
&lt;p&gt;如何利用窃取的 Cookie 登陆目标用户的账户呢？这和&lt;code&gt;利用自定义Cookie访问网站&lt;/code&gt;的过程是一样的，参考如下：&lt;/p&gt;
&lt;p&gt;当没有登陆的时候，Cookie 内容是空的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/03c8717701599c51d4cf1fbe4660864d97411683.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们手动添加 Cookie 后，登陆的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/58de73b844c8906607898b3170b16a42894723f9.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们就已经登陆上了该用户的账户。&lt;/p&gt;
&lt;p&gt;所以，通过 XSS 攻击，可以完成 &lt;code&gt;Cookie 劫持&lt;/code&gt; 攻击，直接登陆进用户的账户。&lt;/p&gt;
&lt;p&gt;其实都不需要带上参数，黑客就能获取到所有数据，这是因为当前 Web 中，Cookie 一般是用户凭证，浏览器发起的所有请求都会自动带上 Cookie 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/ed8d2d644f9c22eb7dd8c18f233fd39a899bcafd.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/74163d68249c925fa92541ab354fa84ef3c277bc.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么该如何预防 &lt;code&gt;Cookie 劫持&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;Cookie 的 &lt;code&gt;HttpOnly&lt;/code&gt; 标识可以有效防止 &lt;code&gt;Cookie 劫持&lt;/code&gt;，我们会在稍后章节具体介绍。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 16:10:00 +0000</pubDate>
<dc:creator>梁音</dc:creator>
<og:description>什么是 XSS Payload 上一章我谈到了 XSS 攻击的几种分类以及形成的攻击的原理，并举了一些浅显的例子，接下来，我就阐述什么叫做 以及从攻击者的角度来初探 XSS 攻击的威力。 在黑客 XS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangyin/p/9638235.html</dc:identifier>
</item>
<item>
<title>【CSS】纯css实现立体摆放图片效果 - 卡迪斯上小学</title>
<link>http://www.cnblogs.com/xiabaoying/p/9638233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiabaoying/p/9638233.html</guid>
<description>&lt;p&gt;1.  &lt;strong&gt;元素的 width/height/padding/margin 的百分比基准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置 一个元素 width/height/padding/margin 的百分比的时候，大家可知道基准是什么？&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
.parent {
  width: 200px;
  height: 100px;
}
.child {
  width: 80%;
  height: 80%;
}
.childchild {
  width: 50%;
  height: 50%;&lt;br/&gt;　padding: 2%;&lt;br/&gt;margin: 5%;&lt;br/&gt;} 
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
    &amp;lt;div class=&quot;parent&quot;&amp;gt;
        &amp;lt;div class=&quot;child&quot;&amp;gt;
            &amp;lt;div class=&quot;childchild&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上段代码中，childchild 元素的 width 是多少？ height 是多少？padding 是多少？ margin是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元素的 height 百分比基准是父级元素的 height， 元素的 width， padding， margin 百分比基准是父级元素的 width。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由此，相信大家都已经有数了，大家可以试一下呢～～&lt;/p&gt;
&lt;p&gt;面试经常会遇到一个简单的css样式问题 ， 实现一个自适应的正方形，原理就是基于上面的那些知识了。只需要&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
#box {
            width: 50%;
            padding-top: 50%;
            background: #000;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为元素的 width 和 padding 的基准值都是父级元素的 width， 而 body 的 width 就是浏览器窗口啦～～，so 这样设置就可以随着浏览器窗口大小变化，正方形自适应了呢～～&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 纯css实现立体摆放图片效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;言归正传，想要实现如下图中图片的立体摆放效果，就需要应用一下 padding ，width， height 的知识了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120335/201809/1120335-20180912232242784-1738360565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有点眼熟，是不是跟小说软件里推荐图书的样式有些相似呢？&lt;/p&gt;
&lt;p&gt;这里，首先我们看下其位置摆放，一张图片水平居中并且靠前，其他两边图片分别左右对齐，并且靠后一些，呈现一种立体摆放的样子。这里我学到了一种完全依赖css，简单的写法即可实现这种立体的效果。&lt;/p&gt;
&lt;p&gt; · &lt;strong&gt;不同的高度是 padding-top 有大有小撑起来的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; · 前后效果是 z-index 折叠顺序控制的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; · 排列上使用了 nth-of-type 伪元素控制 + positon 定位结合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120335/201809/1120335-20180912235750450-355149670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是有点思路了呢？不绕弯子了，直接上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;style&amp;gt;
            * {
                margin: 0;
                padding: 0;
            }
            .box {
                width: 300px;
                height: 200px;
                position: relative;
            }
            .img {
                width: auto;
                height: 0;
            }
            .box img {
                width: 100%;
                display: inline-block;
            }
            .box .img:nth-of-type(1) {
                display: inline-block;
                position: absolute;
                left: 50%;
                top: 50%;
                padding-bottom: 50%;
                transform: translate(-50%, -50%);
                z-index:  6;
            }
            .box .img:nth-of-type(2), .box .img:nth-of-type(3) {
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                padding-bottom: 63%;
                z-index: 3;
            }
            .box .img:nth-of-type(2) {
                right: 0;
            }
            .box .img:nth-of-type(3) {
                left: 0;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;box&quot;&amp;gt;
            &amp;lt;div class=&quot;img&quot;&amp;gt;
                &amp;lt;img src=&quot;https://febaidu.com/list/img/3ns.png&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;img&quot;&amp;gt;
                &amp;lt;img src=&quot;https://febaidu.com/list/img/3ns.png&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;img&quot;&amp;gt;
                &amp;lt;img src=&quot;https://febaidu.com/list/img/3ns.png&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　快去试试吧 ～&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 16:10:00 +0000</pubDate>
<dc:creator>卡迪斯上小学</dc:creator>
<og:description>1. 元素的 width/height/padding/margin 的百分比基准 设置 一个元素 width/height/padding/margin 的百分比的时候，大家可知道基准是什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiabaoying/p/9638233.html</dc:identifier>
</item>
<item>
<title>决策树（三）分类算法小结 - Jin_liang</title>
<link>http://www.cnblogs.com/jin-liang/p/9629084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-liang/p/9629084.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　本文主要是对分类型决策树的一个总结。在分类问题中，决策树可以被看做是if-then规则的结合，也可以认为是在特定特征空间与类空间上的条件概率分布。决策树学习主要分为三个步骤：特征选择、决策树的生成与剪枝操作。本文简单总结ID3和C4.5算法，之后是决策树的修剪。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　ID3算法和核心是：在决策树各级节点上选择属性时，用信息增益（information gain）作为属性的选择标准，具体做法是：检测所有的属性，选择信息增益最大的属性产生决策树节点，由该属性的不同取值建立分支，再对各分支循环调用该方法建立决策树节点的分支，直到所有子集仅包含同一类别为止。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;信息增益&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　了解信息增益，首先介绍熵与条件熵的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　熵表示随机变量不确定性的度量。设$X$是一个取有限值的离散随机变量，其概率分布为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$p(X=x_i)=p_i$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则随机变量 $X$ 的熵定义为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$H(X)=-\sum_{i=1}^np_ilogp_i  ， i=1,2,n$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由定义可知，熵只依赖于$X$的分布，而与$X$的取值无关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;熵越大，随机变量的不确定性越高，并且：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$0\leqslant{H(p)}\leqslant{logn}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当随机变量只有两个取值时，例如0，1，则$X$的分布为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; $$p(X=1)=p，p(X=0)=1-p，  0\leqslant{p}\leqslant1$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;熵为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$H(p)=-plog_2p-(1-p)log_2(1-p)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345004/201809/1345004-20180912220827649-1152958444.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当$p=0$或$p=1$时，$H(p)=0$，随机变量完全没有不确定性，当$p=0.5$时，$H(p)=1$，熵取最大值，随机变量的不确定性最大。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 条件熵&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 　　设随即变量$(X,Y)$，其联合概率分布为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$P(X=x_i,Y=y_i)=p_{ij},i=1,2,\dots,n;j=1,2,\dots,n$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性，随机变量$X$给定的条件下随机变量$Y$的条件熵$H(Y|X)$，定义为$X$给定的条件下$Y$的条件概率分布的熵对$X$的数学期望：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，$p_i=P(X=x_i)$&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;信息增益&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　特征$A$对训练数据集$D$的信息增益，定义为集合$A$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$g(D,A)=H(D)-H(D|A)$$&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　ID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其核心是：决策树各级结点上选择属性时，用信息增益（information gain）作为属性的选择标准，以使得在每一个非叶结点进行测试时，能获得关于被测试记录最大的类别信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其方法是：检测所有的属性，选择信息增益最大的属性产生决策树结点，由该属性的不同取值建立分支，再对各分支的子集递归调用该方法建立决策树结点的分支，直到所有子集仅包含同一类别的数据为止。最后得到一棵决策树。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　C4.5算法首先定义了“分裂信息”，即信息增益比：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$g_R(D,A)=\frac{g(D,A)}{H(D)}\qquad$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进： &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1：用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2：能够完成对连续属性的离散化处理； &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3：能够对不完整数据进行处理。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;　　决策树构造时，由于训练数据中的噪音或孤立点，许多分枝反映的是训练数据中的异常，使用这样的判定树对类别未知的数据进行分类，分类的准确性不高。因此试图检测和减去这样的分支，检测和减去这些分支的过程被称为树剪枝。树剪枝方法用于处理过分适应数据问题。通常，这种方法使用统计度量，减去最不可靠的分支，这将导致较快的分类，提高树独立于训练数据正确分类的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　树枝修剪包括事先修剪和事后修剪两种方法：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　（1）事前修剪方法：在决策树生成分支的过程，除了要进行基础规则的判断外，还需要利用统计学的方法对即将分支的节点进行判断，比如$\chi^2$或统计信息增益，如果分支后使得子集的样本统计特性不满足规定的阈值，则停止分支；但是阈值如何选取才合理是比较困难的。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　（2）事后修剪方法：在决策树充分生长后，修剪掉多余的分支。根据每个分支的分类错误率及每个分支的权重，计算该节点不修剪时预期分类错误率；对于每个非叶节点，计算该节点被修剪后的分类错误率，如果修剪后分类错误率变大，即放弃修剪；否则将该节点强制为叶节点，并标记类别。产生一系列修剪过的决策树候选之后，利用测试数据（未参与建模的数据）对各候选决策树的分类准确性进行评价，保留分类错误率最小的决策树。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　除了利用分类错误率进行树枝修剪，也可以利用决策树的编码长度进行修剪。所谓最佳决策树是编码长度最短的决策树，这种修剪方法利用最短描述长度（MDL）原则来进行决策树的修剪。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 15:31:00 +0000</pubDate>
<dc:creator>Jin_liang</dc:creator>
<og:description>引言 本文主要是对分类型决策树的一个总结。在分类问题中，决策树可以被看做是if-then规则的结合，也可以认为是在特定特征空间与类空间上的条件概率分布。决策树学习主要分为三个步骤：特征选择、决策树的生</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-liang/p/9629084.html</dc:identifier>
</item>
<item>
<title>机器学习100天——数据预处理(第一天) - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9638093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9638093.html</guid>
<description>&lt;p&gt;有个叫Avik Jain的老外在github上发起了一个100天学习机器学习的项目，每天花一个小时学习机器学习，学习内容由浅入深。今天是第一天，内容是如何进行数据预处理。该教程的编程语言是Python。&lt;/p&gt;

&lt;p&gt;数据预处理分为6步：&lt;/p&gt;

&lt;p&gt;第一步：导入NumPy和Pandas库。NumPy和Pandas是每次都要导入的库，其中Numpy包含了数学计算函数，Pnadas是一个用于导入和管理数据集(Data Sets)的类库。&lt;/p&gt;

&lt;p&gt;第二步：导入数据集。数据集一般都是.csv格式，csv文件以文本形式存储数据。每一行数据是一条记录。我们使用pandas类库的read_csv方法读取本地的csv文件作为一个dataframe。然后从datafram中分别创建自变量和因变量的矩阵和向量。&lt;/p&gt;

&lt;p&gt;第三步：处理缺失的数据。我们得到的数据很少是完整的。数据可能因为各种原因丢失，为了不降低机器学习模型的性能，需要处理数据。我们可以用整列的平均值或者中间值替换丢失的数据。我们用sklearn.preprocessing库中的Inputer类完成这项任务。&lt;/p&gt;

&lt;p&gt;第四步：对分类数据进行编码。分类数据指的是含有标签值而不是数字值得变量。取值范围通常是固定的。例如“YES”和“NO”不能用于模型的数学计算，所以需要编码成数字。为数显这一功能，我们从sklearn.preprocessing库中导入LabelEncoder类。&lt;/p&gt;

&lt;p&gt;第五步：拆分数据集为测试集合和训练集合。把数据集拆分成两个，一个是用来训练模型的训练集合，另一个是用来验证模型的测试集合。两种比例一般是80:20。我们导入sklearn.crossvalidation库中的train_test_split()方法。&lt;/p&gt;

&lt;p&gt;第六步：特征缩放。大部分模型算法使用两点间的欧式近距离表示，但此特征在幅度、单位和范围姿态问题上变化很大。在距离计算中，高幅度的特征比低幅度特征权重大。可用特征标准化或Z值归一化解决。导入sklearn.preprocessing库的StandardScalar类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180912231928545-1206032466.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 1&lt;span&gt;: 导入类库
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 2&lt;span&gt;: 导入数据集
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; dataset = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; X = dataset.iloc[ : , :-1&lt;span&gt;].values
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; Y = dataset.iloc[ : , 3&lt;span&gt;].values
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 3&lt;span&gt;: 处理缺失的数据
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Imputer
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; imputer = Imputer(missing_values = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strategy = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, axis =&lt;span&gt; 0)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; imputer = imputer.fit(X[ : , 1:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; X[ : , 1:3] = imputer.transform(X[ : , 1:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; Step 4&lt;span&gt;:编码分类数据
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LabelEncoder, OneHotEncoder
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; labelencoder_X =&lt;span&gt; LabelEncoder()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; X[ : , 0] =&lt;span&gt; labelencoder_X.fit_transform(X[ : , 0])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;Creating a dummy variable
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; onehotencoder = OneHotEncoder(categorical_features =&lt;span&gt; [0])
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; X =&lt;span&gt; onehotencoder.fit_transform(X).toarray()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; labelencoder_Y =&lt;span&gt; LabelEncoder()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; Y =&lt;span&gt;  labelencoder_Y.fit_transform(Y)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; Step 5&lt;span&gt;: 切分数据集成训练数据和测试数据
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; X_train, X_test, Y_train, Y_test = train_test_split( X , Y , test_size = 0.2, random_state =&lt;span&gt; 0)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; Step 6&lt;span&gt;: 特征缩放
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; StandardScaler
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; sc_X =&lt;span&gt; StandardScaler()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; X_train =&lt;span&gt; sc_X.fit_transform(X_train)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; X_test = sc_X.fit_transform(X_test)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本教程的测试数据请关注本人的公众号获取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180912232212869-1354932756.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Sep 2018 15:23:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>有个叫Avik Jain的老外在github上发起了一个100天学习机器学习的项目，每天花一个小时学习机器学习，学习内容由浅入深。今天是第一天，内容是如何进行数据预处理。该教程的编程语言是Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9638093.html</dc:identifier>
</item>
<item>
<title>struts2.5+框架使用通配符与动态方法 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9638045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9638045.html</guid>
<description>&lt;ol&gt;&lt;li&gt;
&lt;h2&gt;通配符：&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在学习struts框架时经常会使用到通配符调用方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;usercrud&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test-*&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.gitee.dgwcode.action.UserCrudAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;{1}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/view/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;allowed-methods&amp;gt;query,delete,update,insert&amp;lt;/allowed-methods&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的action name=&quot;user_*&quot;中*这个符号代表的值会传入method=“{1}”中，并对应action类的一个方法名，这样就能很大程度地减少配置文档中action的数目。&lt;/p&gt;

&lt;p&gt;但是在使用这种通配符方法的时候，经常会看到这样的映射错误提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Struts Problem Report
Struts has detected an unhandled exception:

Messages:    
There is no Action mapped for namespace [/] and action name [test-update] associated with context path [/Struts2_01].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果看到提示的是映射问题，你可以按照映射路线排除一遍，&lt;/p&gt;
&lt;p&gt;第一步：先排查访问的链接有没有问题（细节问题）&lt;/p&gt;
&lt;p&gt;第二步：&lt;span&gt;查看struts.xml的配置（仔细排查，出现问题几率很大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：查看相关的action类及方法（比如return的值是不是跟配置文件中的result对应得上等）&lt;/p&gt;
&lt;p&gt;第四步：查看结果响应页面是否存在问题（出现问题的几率比较小）&lt;/p&gt;

&lt;h2&gt;2.动态方法&lt;/h2&gt;
&lt;p&gt;当使用动态调用方法时（action名 + 感叹号 + 方法名进行方法调用），需要将其属性改为true，&lt;/p&gt;
&lt;p&gt;如：query为类中的方法名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;${pageContext.request.contextPath }/test!query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DynamicMethodInvocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当使用通配符调用语法时，建议将其属性改为false（struts2.5.2中默认是false）&lt;/p&gt;
&lt;p&gt;当我们需要将其属性改成false时，&lt;/p&gt;
&lt;p&gt;只在struts.xml配置文件中加入此句即可修改属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 动态方法调用 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;
            class&lt;/span&gt;&lt;span&gt;=&quot;com.gitee.dgwcode.action.UserCrudAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/view/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;allowed-methods&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;query,delete,update,insert&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;allowed-methods&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&amp;lt;allowed-methods&amp;gt;方法名1，方法名2…&amp;lt;/allowed-methods&amp;gt;代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>概述：struts2.5以后加强了安全性，下面就是安全配置引发的问题 通配符： 在学习struts框架时经常会使用到通配符调用方法，如下： 其中的action name=&quot;user_*&amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9638045.html</dc:identifier>
</item>
</channel>
</rss>