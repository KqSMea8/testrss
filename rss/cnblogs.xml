<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Hadoop（二）搭建伪分布式集群 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7647686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7647686.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面只是大概介绍了一下Hadoop，现在就开始搭建集群了。我们下尝试一下搭建一个最简单的集群。之后为什么要这样搭建会慢慢的分享，先要看一下效果吧！&lt;/p&gt;

&lt;h2&gt;1.1、单机模式（独立模式）（Local或Standalone  Mode）&lt;/h2&gt;
&lt;p&gt;　　-默认情况下，Hadoop即处于该模式，用于开发和调式。&lt;/p&gt;
&lt;p&gt;　　-不对配置文件进行修改。&lt;br/&gt;　　-使用&lt;span&gt;本地文件系统，而不是分布式文件系统&lt;/span&gt;。&lt;br/&gt;　　-Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，&lt;span&gt;Map()和Reduce()任务作为同一个进程的不同部分来执行的&lt;/span&gt;。&lt;br/&gt;　　-用于&lt;span&gt;对MapReduce程序的逻辑进行调试，确保程序的正确&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;1.2、伪分布式模式（Pseudo-Distrubuted Mode）&lt;/h2&gt;
&lt;p&gt;　　-Hadoop的守护进程运行在本机机器，模拟一个小规模的集群　&lt;/p&gt;
&lt;p&gt;　　-在&lt;span&gt;一台主机模拟多主机&lt;/span&gt;。&lt;br/&gt;　　-Hadoop&lt;span&gt;启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程&lt;/span&gt;。&lt;br/&gt;　　-在这种模式下，Hadoop使用的是&lt;span&gt;分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程&lt;/span&gt;。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，&lt;/p&gt;
&lt;p&gt;　　　　以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。&lt;br/&gt;　　-修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性）&lt;br/&gt;　　-格式化文件系统&lt;/p&gt;
&lt;h2&gt;1.3、全分布式集群模式（Full-Distributed Mode）&lt;/h2&gt;
&lt;p&gt;　　-Hadoop的守护进程运行在一个集群上　&lt;/p&gt;
&lt;p&gt;　　-Hadoop的&lt;span&gt;守护进程运行在由多台主机搭建的集群上，是真正的生产环境&lt;/span&gt;。&lt;br/&gt;　　-在所有的主机上&lt;span&gt;安装JDK和Hadoop，组成相互连通的网络&lt;/span&gt;。&lt;br/&gt;　　-在主机间&lt;span&gt;设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表&lt;/span&gt;。&lt;br/&gt;　　-修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数&lt;br/&gt;　　-格式化文件系统&lt;/p&gt;

&lt;p&gt;环境：在ubuntu17.04&lt;/p&gt;
&lt;p&gt;　　　　jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;　　　　hadoop 2.8.1&lt;/p&gt;
&lt;h2&gt;2.1、能够正常运行的Ubuntu操作系统&lt;/h2&gt;
&lt;p&gt;　　在Ubuntu下，软件安装到/opt下，当前正在使用的用户，对于opt目录需要有读写权限：　&lt;/p&gt;
&lt;p&gt;　　1）将opt的权限给为777（漏洞文件），不推荐在生产环境中使用。但是可以在学习和调试环境中使用。　　　　　&lt;/p&gt;
&lt;p&gt;　　2）sudo&lt;/p&gt;
&lt;p&gt;　　　　在启动Hadoop的各个守护进程的时候，需要使用sudo。&lt;br/&gt;　　　　在管理Hadoop的时候，实际上由不同的用户启动不同集群的守护进程。&lt;br/&gt;　　　　统一使用当前的用户管理所有集群。&lt;/p&gt;
&lt;p&gt;　　3）该目录的所有者设置为当前用户&lt;/p&gt;
&lt;h2&gt;2.2、安装JDK，并配置环境变量&lt;/h2&gt;
&lt;p&gt;　　1）将jdk安装包放在家目录下&lt;/p&gt;
&lt;p&gt;　　2）解压到opt目录下&lt;/p&gt;
&lt;p&gt;　　　　sudo tar zxvf jdk-8u131-linux-x64.tar.gz -C /opt&lt;/p&gt;
&lt;p&gt;　　　　此时在/opt目录下：会有一个jdk1.8.0_131&lt;/p&gt;
&lt;p&gt;　　3）创建软链接&lt;/p&gt;
&lt;p&gt;　　　　sudo ln -snf /opt/jdk1.8.0_131 /opt/jdk&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010210840355-2051409448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：创建软连接的目的是为了，我们在做项目的时候，可能会用到不同的jdk版本，这是要换软件的话，只需要修改软链接就可以了。而不用修改配置文件。&lt;/p&gt;
&lt;p&gt;　　4）配置环境变量　　　&lt;/p&gt;
&lt;p&gt;　　　　局部环境变量：~/.bashrc&lt;br/&gt;　　　　全局环境变量：/etc/profile&lt;br/&gt;　　　　export JAVA_HOME=/opt/jdk&lt;br/&gt;　　　　export JRE_HOME=$JAVA_HOME/jre&lt;br/&gt;　　　　export CLASSPATH=.:$JAVA_HOME/lib&lt;br/&gt;　　　　export PATH=$PATH:$JAVA_HOME/bin&lt;/p&gt;
&lt;p&gt;　　　　source 相关文件（更新配置文件）&lt;/p&gt;
&lt;p&gt;　　5）查看是否安装成功&lt;/p&gt;
&lt;p&gt;　　　java、javac、java -version&lt;/p&gt;

&lt;h2&gt;3.1、安装hadoop&lt;/h2&gt;
&lt;p&gt;　　1）解压hadoop安装包到opt目录下&lt;/p&gt;
&lt;p&gt;　　　　sudo  tar zxvf hadoop-2.8.1.tar.gz -C /opt&lt;/p&gt;
&lt;p&gt;　　2）创建软链接&lt;/p&gt;
&lt;p&gt;　　　　ln -snf /opt/hadoop-2.8.1   /opt/hadoop　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211309324-431154157.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）配置环境变量　　&lt;/p&gt;
&lt;p&gt;　　　　在/etc/profile文件中加入以下内容：&lt;br/&gt;　　　　export HADOOP_HOME=/opt/hadoop&lt;br/&gt;　　　　export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin&lt;br/&gt;　　　　source /etc/profile&lt;/p&gt;
&lt;p&gt;　　4）使用hadoop version命令测试是否配置成功&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211424777-870467980.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2、配置hadoop&lt;/h2&gt;
&lt;p&gt;　　配置文件存放在/opt/hadoop/etc/hadoop中有n多个文件，暂时我们只需要修改的只有5个&lt;/p&gt;
&lt;p&gt;　　1）hadoop-env.sh&lt;/p&gt;
&lt;p&gt;　　　　大约在25行左右　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　export JAVA_HOME=${JAVA_HOME}改成export JAVA_HOME=/opt/jdk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010211938887-441968715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：在配置文件中有提示我们怎么设置，我们一般不删除，二回选择注释它的提示。&lt;/p&gt;
&lt;p&gt;　　2）core-site.xml　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　　　&amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.0.0.5:9000&amp;lt;/value&amp;gt;   &lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212345871-1121339163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：1.0.0.5是你主节点所在主机的ip，而9000为端口&lt;/p&gt;
&lt;p&gt;　　3）hdfs-site.xml　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;hadoop-cluster&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/nn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;&lt;span&gt;dfs.namenode.ch
                    eckpoint.dir&lt;/span&gt;&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.namenode.checkpoint.edits.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/snn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/hdfs/dn&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212523715-657867265.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）mapred-site.xml&lt;/p&gt;
&lt;p&gt;　　　　在hadoop的相关目录中没有此文件，但是有一个mapred-site.xml.template文件，将该文件复制一份为mapred-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　cp mapred-site.xml.template mapred-site.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212728262-586427381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）yarn-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;!-- 指定ResourceManager的地址--&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;0.5&lt;/span&gt;&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;!-- 指定reducer获取数据的方式--&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property&amp;gt;
                    &amp;lt;name&amp;gt;yarn.nodemanager.local-dirs&amp;lt;/name&amp;gt;
                    &amp;lt;value&amp;gt;file:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;data/hadoop/yarn/nm&lt;/span&gt;&lt;span&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010212905699-2115750669.png&quot; alt=&quot;&quot; width=&quot;432&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7）创建相关目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        sudo mkdir -p /data/hadoop/hdfs/&lt;span&gt;nn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;dn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/hdfs/&lt;span&gt;snn
        sudo mkdir &lt;/span&gt;-p /data/hadoop/yarn/nm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　注意：　　&lt;/p&gt;
&lt;p&gt;　　　　如果&lt;span&gt;使用sudo启动hadoop的相关进程，这几目录的权限可以不用管&lt;/span&gt;。&lt;br/&gt;　　　　如果是&lt;span&gt;使用当前的用户启动相关进程，对于opt目录，当前用户得有读写权限，对于/data目录也需要读写权限&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　遇到问题：&lt;/p&gt;
&lt;p&gt;　　　　　　笔者就是在这个目录权限的问题吃el很大得亏。首先为了不使用sudo我将/data目录的权限修改为777，然后进行&lt;/p&gt;
&lt;p&gt;　　　　　　HDFS集群格式化的时候，出现：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010213351309-1503138602.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　这时我在想为什么呢？原来我只是给data目录设置了读写权限，但是没有给它的子目录设置读写权限。所以：　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　　　　　chmod -R &lt;span&gt;777&lt;/span&gt; /data    递归设置权限
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8）对HDFS集群进行格式化，HDFS集群是用来存储数据的。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　hdfs namenode -format
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.3、启动集群&lt;/h2&gt;
&lt;p&gt;　　1）启动HDFS集群　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　hadoop-daemon.sh start namenode 启动主节点&lt;br/&gt;　　　　hadoop-daemon.sh start datanode 启动从节点&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214239918-1067025019.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）启动YARN集群&lt;/p&gt;
&lt;p&gt;　　　　yarn-daemon.sh start resourcemanager&lt;br/&gt;　　　　yarn-daemon.sh start nodemanager&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214358668-7481029.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）启动作业历史服务器&lt;/p&gt;
&lt;p&gt;　　　　mr-jobhistory-daemon.sh start historyserver&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214508637-1286314807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）jps命令查看是否启动成功&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214544090-1756410260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）HDFS和YARN集群都有相对应的WEB监控页面&lt;/p&gt;
&lt;p&gt;　　　　HDFS：http://ip:50070&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214721105-1362648307.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　YARN：http://ip:8088&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010214857324-806088798.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6）HDFS集群的简单操作命令&lt;/p&gt;
&lt;p&gt;　　　　hdfs dfs -ls /&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010215935293-1929086326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　hdfs dfs -mkdir -p /user/zyh&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010220056621-281989886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7） YARN集群的操作----提交任务/作业&lt;/p&gt;
&lt;p&gt;　　　　计算PI值的作业：&lt;br/&gt;　　　　yarn jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.1.jar pi 4 100&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010220350934-750510351.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我之前没有注意发现我的yarn的从节点没有启动起来，在执行计算PI值的时候没有成功才看到：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225330934-888154571.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看日志发现是配置文件：&lt;/p&gt;
&lt;p&gt;　　在hdfs-site-web.xml中：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225646043-2033598849.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看http://1.0.0.5:50070可以查看从节点是否启动：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010225929902-90790098.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在执行上面使用yarn集群来计算pi值得命令：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010230147246-1473267315.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看http://1.0.0.5:8088可以看出计算pi值得任务正在执行：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010230032137-1249088310.png&quot; alt=&quot;&quot; width=&quot;993&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后成功：&lt;/p&gt;
&lt;p&gt;　　　　　这里就截图了，电脑卡住了，上图中在web页面可以查看到任务执行成功，终端中会显示执行结果！　　　　　&lt;/p&gt;

&lt;p&gt;喜欢就点“推荐”哦！&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 15:07:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7647686.html</dc:identifier>
</item>
<item>
<title>设计模式 5/23 原型模式 - Lionel Andrés Messi</title>
<link>http://www.cnblogs.com/LionelMessi/p/7597803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LionelMessi/p/7597803.html</guid>
<description>&lt;p&gt;原型模式，一个深入浅出，检验你对基础知识了解的是否透彻的一个设计模式。&lt;/p&gt;
&lt;p&gt;之所以这样定义，因为我栽了个跟头&lt;/p&gt;
&lt;p&gt;想要吃透原型模式，就得深入理解 浅拷贝，深拷贝&lt;/p&gt;
&lt;p&gt;想要深入吃透 浅拷贝，深拷贝&lt;/p&gt;
&lt;p&gt;我们就要对 值类型 和 引用类型 有较深的认识&lt;/p&gt;
&lt;p&gt;如果对 值类型 和 引用类型 有了较深的认识，在GC也至少有一定的修为了&lt;/p&gt;
&lt;p&gt;..........我还能继续这样写下去很多，所以有开头的那句话，原型模式，一个深入浅出，检验你对基础知识了解的是否透彻的一个设计模式。&lt;/p&gt;

&lt;p&gt;对值类型 和 引用类型 的浅薄的 入门，可以参考 几年前写的 &lt;a href=&quot;http://www.cnblogs.com/LionelMessi/p/4314370.html&quot; target=&quot;_blank&quot;&gt;面试前的准备---C#知识点回顾----02&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有一些基础知识的介绍,可以作为了解 浅拷贝 和 深拷贝的铺垫&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了，看黑板!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：指的是拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，你有一张光盘，你进行了多次刻录，产生了第二张，第三者光盘，那这三种光盘是相互独立的，第一张损坏或第二张损坏，都不会影响到第三张【光盘，会不会暴露年龄啊】。在.NET领域，值对象就是典型的例子，如int, Double以及结构体和枚举等。具体例子如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ece5c375-fedd-43c7-b296-667860a7cc35')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ece5c375-fedd-43c7-b296-667860a7cc35',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ece5c375-fedd-43c7-b296-667860a7cc35&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;int&lt;/span&gt; source = &lt;span&gt;11&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值类型赋值内部执行深拷贝&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; copy =&lt;span&gt; source;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对拷贝对象进行赋值不会改变源对象的值&lt;/span&gt;
            copy = &lt;span&gt;22&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时source仍然为11
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样对源对象赋值也不会改变拷贝对象的值&lt;/span&gt;
            source = &lt;span&gt;33&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时copy 仍然为22            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 怎么实现深拷贝，可以最原始的一个一个赋值，但也可以用反射或反序列化方式来实现，因人而异，具体根据具体需求定，寻找代码最合适的方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：指的是拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。此时，其中一个对象的改变都会影响到另一个对象。其实我们自己经常浅拷贝，在家，你是个宝宝的身份，在学校，你是学生的身份，在公司面前，你是职员，但如果你生病了，那么你所有身份都会生病，全都反应在你这个实体身上。在.NET中引用类型就是一个例子。如类类型。具体例子如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ca861ab6-86fd-4121-a253-0db8ae9d2710')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ca861ab6-86fd-4121-a253-0db8ae9d2710',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca861ab6-86fd-4121-a253-0db8ae9d2710&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
 Person you = &lt;span&gt;new&lt;/span&gt; Person() { Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            Person schoolP &lt;/span&gt;= you; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 浅拷贝&lt;/span&gt;
            schoolP.Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝对象改变Info值&lt;/span&gt;
            Person familyP =&lt;span&gt; you;
            familyP.Info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宝宝&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Person emp &lt;/span&gt;=&lt;span&gt; you;
            emp.Info &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;职员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 突然你生病了&lt;/span&gt;
            you.Info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生病了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;schoolP.Info: {0}；familyP.Info: {1}；emp.Info:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, schoolP.Info, familyP.Info, emp.Info);
            Console.Read();


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Info { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;重点！！！在C#中，浅拷贝的实现方式很简单，.NET自身也提供了实现，只需要实现接口 : ICloneable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET中值类型默认是深拷贝的，而对于引用类型，默认实现的是浅拷贝。&lt;strong&gt;所以对于类中引用类型的属性改变时，其另一个对象也会发生改变。当某个类的实例有个字段是值类型，那么实际该字段会和类的实例保持在同一个地方，即堆上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此次载的跟头就是在，让我痛定思痛的记住了，类都是引用类型&lt;/p&gt;

&lt;p&gt;有了前面的铺垫，我们来看看原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点再次来临，2点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.前半句告诉你原型还得自己建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.后半句指点你，剩下的对象可以通过拷贝实现。具体是深拷贝还是浅拷贝，根据你的需求来定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，来品味下原型模式&lt;/p&gt;
&lt;p&gt;在 War3 ，魔兽争霸[再次暴露年龄], 大海龟地图中有4个点位有野怪，这些野怪组成由 1个大海龟，2个小海龟组成，都是海龟，他们的差别是伤害输出的不同。&lt;/p&gt;
&lt;p&gt;我们来看看怎么画这个图&lt;/p&gt;
&lt;p&gt;先定义野怪，因为在地图中，除了海归，还有其他野怪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('48140130-99f5-49c8-aa20-9e360af3ef17')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('48140130-99f5-49c8-aa20-9e360af3ef17',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_48140130-99f5-49c8-aa20-9e360af3ef17&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 敌人，野怪
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Enemy : ICloneable
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Enemy(Location location, &lt;span&gt;int&lt;/span&gt; power, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; speed)
        {
            Location &lt;/span&gt;=&lt;span&gt; location;
            Power &lt;/span&gt;=&lt;span&gt; power;
            Speed &lt;/span&gt;=&lt;span&gt; speed;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出生点位
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Location Location { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 攻击力[1~10 越来越强]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Power { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 行动速度[1~10 越来越快]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Speed { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 深拷贝
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Enemy DeepClone();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 浅拷贝
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Clone()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.MemberwiseClone();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这是出生点位类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fce33373-9bc8-4703-82b2-b0c0736b3435')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fce33373-9bc8-4703-82b2-b0c0736b3435',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fce33373-9bc8-4703-82b2-b0c0736b3435&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 出生点位
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Location
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 横坐标
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; X;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 纵坐标
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Y;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Location(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
        {
            X &lt;/span&gt;=&lt;span&gt; x;
            Y &lt;/span&gt;=&lt;span&gt; y;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;再定义海归野怪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e0e27e0b-925e-49e4-9fce-0a90374ccfe7')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e0e27e0b-925e-49e4-9fce-0a90374ccfe7',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0e27e0b-925e-49e4-9fce-0a90374ccfe7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 海龟
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;    [Serializable]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeaTurtle : Enemy
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SeaTurtle(Location location, &lt;span&gt;int&lt;/span&gt; power, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; speed)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(location, power, speed)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Enemy DeepClone()
        {
            MemoryStream memoryStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
            BinaryFormatter formatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryFormatter();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 序列化成流&lt;/span&gt;
            formatter.Serialize(memoryStream, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            memoryStream.Position &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化成对象&lt;/span&gt;
            SeaTurtle seaTurtle =&lt;span&gt; (SeaTurtle)formatter.Deserialize(memoryStream);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seaTurtle;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是海龟，攻击力:{0},速度:{1},出生点位:{2},{3}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Power, Speed, Location.X, Location.Y);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;比如我们现在要生成一组野怪，我们看看怎么用原型模式实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4b8e8a6b-bc8b-4198-9e43-2d65324e07b6')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4b8e8a6b-bc8b-4198-9e43-2d65324e07b6',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4b8e8a6b-bc8b-4198-9e43-2d65324e07b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            Location seaTurtleLocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Location(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大海龟出生&lt;/span&gt;
            SeaTurtle bigSeaTurtle = &lt;span&gt;new&lt;/span&gt; SeaTurtle(seaTurtleLocation, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;照着大海龟 拷贝一个小海龟  A &lt;/span&gt;
            Enemy smallSeaTurtleA =&lt;span&gt; (SeaTurtle)bigSeaTurtle.DeepClone();
            smallSeaTurtleA.Location.X &lt;/span&gt;= seaTurtleLocation.X + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            smallSeaTurtleA.Power &lt;/span&gt;= bigSeaTurtle.Power / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再直接copy小海龟A 拷贝一个小海龟  B   &lt;/span&gt;
            Enemy smallSeaTurtleB =&lt;span&gt; (SeaTurtle)smallSeaTurtleA.DeepClone();
            smallSeaTurtleB.Location.X &lt;/span&gt;= seaTurtleLocation.X - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            bigSeaTurtle.Show();
            smallSeaTurtleA.Show();
            smallSeaTurtleB.Show();
            Console.ReadLine();

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最终的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
我是海龟，攻击力:&lt;span&gt;10&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
我是海龟，攻击力:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
我是海龟，攻击力:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,速度:&lt;span&gt;10&lt;/span&gt;,出生点位:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在Enemy类中实现了接口ICloneable，大家可以试试用Clone方法会得到什么效果 &lt;/p&gt;

&lt;p&gt;总结下&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;用于创建重复的对象，同时又能保证性能，同时，我们还可以不用构造方法&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;p&gt;1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。&lt;/p&gt;
&lt;p&gt;2、逃避了构造函数的约束，如果我们的构造方法有约定，那因为可以不用到构造方法，所以我们逃避了约定&lt;/p&gt;

&lt;p&gt;以上就是关于 原型模式 的分享&lt;/p&gt;
&lt;p&gt;你们的支持是我写作的动力源泉，请不要吝啬你的点赞，谢谢&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 15:04:00 +0000</pubDate>
<dc:creator>Lionel Andr&amp;#233;s Messi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LionelMessi/p/7597803.html</dc:identifier>
</item>
<item>
<title>Spring读书笔记——bean加载 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</guid>
<description>&lt;p&gt;我们的日常开发几乎离不开Spring，他为我们的开发带来了很大的便捷，那么Spring框架是如何做到方便他人的呢。今天就来说说bean如何被加载加载。&lt;/p&gt;
&lt;p&gt;我们在xml文件中写过太多类似这样的bean声明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;jsonParser&quot; class=&quot;com.jackie.json.FastjsonJsonParser&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这样的声明是如果被Spring读取并加载的呢？&lt;/p&gt;
&lt;h3 id=&quot;defaultlistablebeanfactory&quot;&gt;DefaultListableBeanFactory&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory
      implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是DefaultListableBeanFactory类源码的声明，集成了父类AbstractAutowireCapableBeanFactory以及实现了接口&lt;br/&gt;ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable（且不管这些又长有难懂的父类和父接口都是干什么的）&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/619240/201710/619240-20171010225719480-1219586878.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是DefaultListableBeanFactory的所有依赖父类，可以看到最顶层使我们熟悉的Object类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地位&lt;/strong&gt;&lt;br/&gt;DefaultListableBeanFactory类是整个bean加载的核心部分。后面我们要说到的XmlBeanFactory就是DefaultListableBeanFactory的子类。&lt;/p&gt;
&lt;h3 id=&quot;xmlbeanfactory&quot;&gt;XmlBeanFactory&lt;/h3&gt;
&lt;p&gt;XmlBeanFactory是DefaultListableBeanFactory的子类。其与DefaultListableBeanFactory类的不同之处通过看源码就会发现，XmlBeanFactory使用了自定义的XmlBeanDefinitionReader用于读取xml文件内容。&lt;/p&gt;
&lt;p&gt;XmlBeanFactory的源码并不复杂&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class XmlBeanFactory extends DefaultListableBeanFactory {

   private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


   /**
    * Create a new XmlBeanFactory with the given resource,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource) throws BeansException {
      this(resource, null);
   }

   /**
    * Create a new XmlBeanFactory with the given input stream,
    * which must be parsable using DOM.
    * @param resource XML resource to load bean definitions from
    * @param parentBeanFactory parent bean factory
    * @throws BeansException in case of loading or parsing errors
    */
   public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
      super(parentBeanFactory);
      this.reader.loadBeanDefinitions(resource);
   }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;有两个构造函数&lt;/li&gt;
&lt;li&gt;两个构造函数都有参数Resource，我们在调用前可以通过各种实现比如&lt;code&gt;new ClassPathResource(&quot;application-context.xml&quot;)&lt;/code&gt;的方式传值&lt;/li&gt;
&lt;li&gt;Resource有很多实现比如 文件（FileSystemResource）、URL资源（UrlResource）、InputStream资源（InputStreamResource）、Byte数组（ByteArrayResource）等&lt;/li&gt;
&lt;li&gt;使用Resource是因为该接口抽象出了Spring用到的各种底层资源比如File、Url、Classpath等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bean加载过程&quot;&gt;bean加载过程&lt;/h3&gt;
&lt;p&gt;说到这里的bean加载就离不开我们上面提到的XmlBeanFactory类。&lt;br/&gt;一切的加载XML以及解析bean的操作都要从XmlBeanFactory的&lt;br/&gt;XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory)&lt;br/&gt;说起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;理所当然，我们首先点击进入XmlBeanDefinitionReader类的loadBeanDefinitions方法。整个过程简单说就是：&lt;br/&gt;1.首先对传入的Resouce进行封装，成为EncodeResource对象（之所以这么做，是考虑可以对于资源文件进行编码）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;得到Resource的输入流&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream inputStream = encodedResource.getResource().getInputStream();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;3.调用doLoadBeanDefinitions方法&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;进入doLoadBeanDefinitions方法，我们可以看到方法实现也很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
    try {
        int validationMode = getValidationModeForResource(resource);
        Document doc = this.documentLoader.loadDocument(
                inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;IOException parsing XML document from &quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要做了三件事&lt;br/&gt;得到XML文件的验证模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int validationMode = getValidationModeForResource(resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.加载XML文件，得到对应的Document对象(这里可以发现是调用了this.documentLoader即DefaultDocmentLoader类)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Document doc = this.documentLoader.loadDocument(
      inputSource, getEntityResolver(), this.errorHandler, validationMode, isNamespaceAware());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的解析成Document其实就是常规的SAX解析XML的操作。&lt;/p&gt;
&lt;p&gt;3.根据得到的Document对象注册Bean&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;registerBeanDefinitions(doc, resource)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析注册beandefinitions&quot;&gt;解析注册BeanDefinitions&lt;/h3&gt;
&lt;p&gt;上面的在得到Docment对象后，就是需要解析注册BeanDefinitions了。&lt;br/&gt;进入registerBeanDefinitions方法我们可以看到其实现为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        documentReader.setEnvironment(this.getEnvironment());
        int countBefore = getRegistry().getBeanDefinitionCount();
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续深入，则进入到类DefaultBeanDefinitionDocumentReaderregisterBeanDefinitions方法的doRegisterBeanDefinitions实现。&lt;br/&gt;在这个方法里实现了对于XML中的bean真正的解析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void doRegisterBeanDefinitions(Element root) {
   String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
   if (StringUtils.hasText(profileSpec)) {
      Assert.state(this.environment != null, &quot;Environment must be set for evaluating profiles&quot;);
      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
            profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
      if (!this.environment.acceptsProfiles(specifiedProfiles)) {
         return;
      }
   }

   // Any nested &amp;lt;beans&amp;gt; elements will cause recursion in this method. In
   // order to propagate and preserve &amp;lt;beans&amp;gt; default-* attributes correctly,
   // keep track of the current (parent) delegate, which may be null. Create
   // the new (child) delegate with a reference to the parent for fallback purposes,
   // then ultimately reset this.delegate back to its original (parent) reference.
   // this behavior emulates a stack of delegates without actually necessitating one.
   BeanDefinitionParserDelegate parent = this.delegate;
   this.delegate = createHelper(this.readerContext, root, parent);

   preProcessXml(root);
   parseBeanDefinitions(root, this.delegate);
   postProcessXml(root);

   this.delegate = parent;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;追踪该方法中的每一个方法就是具体执行解析xml并加载bean的过程，有兴趣可以打断点调试一遍。&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 14:56:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/SpringSource1.html</dc:identifier>
</item>
<item>
<title>RobotFramework自动化测试框架-移动手机自动化测试Click A Point关键字的使用 - 老清</title>
<link>http://www.cnblogs.com/laoqing/p/7648185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoqing/p/7648185.html</guid>
<description>&lt;p&gt;Click A Point关键字用来模拟点击APP界面上的一个点，该关键字接收两个三个参数[ x=0 | y=0 | duration=100 ]，x和y代表的是点的坐标位置，duration代表的是点击持续的时长。这三个参数如果没有传入的话，会分表默认x=0，y=0，duration=100。&lt;/p&gt;
&lt;p&gt;示例1：这里依旧采用上面使用的APP界面来做操作示例，使用Click A Point关键字来模拟点击一个button按钮，输入button按钮所在的坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200756/201710/1200756-20171010222734309-1290535433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Open Application   http://localhost:4723/wd/hub  platformName=Android platformVersion=22       deviceName=98YFBP522VSU       app=C:/Users/yongqing/Desktop/app-debug.apk   appPackage=com.example.calculator    appActivity=MainActivity&lt;/p&gt;
&lt;p&gt;Input Text       accessibility_id=输入框 23                               &lt;/p&gt;
&lt;p&gt;Input Text       id=com.example.calculator:id/factortwo       12                               &lt;/p&gt;
&lt;p&gt;Click A Point  370  339  1000             &lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;Starting test: RobotFrameworkTest1.TestSuite5.TestCase008&lt;/p&gt;
&lt;p&gt;20170510 15:32:25.243 :  INFO : Typing text '23' into text field 'accessibility_id=输入框'&lt;/p&gt;
&lt;p&gt;20170510 15:32:25.243 :  INFO : msg:find accessibility_id=输入框&lt;/p&gt;
&lt;p&gt;20170510 15:32:32.005 :  INFO : Typing text '12' into text field 'id=com.example.calculator:id/factortwo'&lt;/p&gt;
&lt;p&gt;20170510 15:32:32.006 :  INFO : msg:find id=com.example.calculator:id/factortwo&lt;/p&gt;
&lt;p&gt;20170510 15:32:37.282 :  INFO : Clicking on a point (370,339).&lt;/p&gt;
&lt;p&gt;Ending test:   RobotFrameworkTest1.TestSuite5.TestCase008         &lt;/p&gt;
&lt;p&gt;从执行结果可以看到，还可以通过Click A Point关键字模拟点击一个button按钮。&lt;/p&gt;
&lt;p&gt; 【原文归作者所有，欢迎转载，但是保留版权】&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 14:28:00 +0000</pubDate>
<dc:creator>老清</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoqing/p/7648185.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(三)加入一个新驱动：西门子S7 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/7647775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/7647775.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        首先感谢博客园：第一篇文章、第一个开源项目，算是旗开得胜。可以看到，项目大部分流量来自于博客园，码农乐园，名不虚传^^。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;园友给了我很多支持，并提出了很好的改进意见。现加入屏幕分辨率自适应和OPC Server可CLSID和ProgID自适应加载功能。屏幕自适应本是普遍问题，因为之前都是标配硬件，举手之劳，一懒就忽略了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205248340-732885456.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅仅十天前，我还是上github只会点击&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205235168-872764741.png&quot; alt=&quot;&quot;/&gt;的菜鸟。Readme文件如何编辑都是现学现卖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一次向github上传仓库，下载了发现居然没有任何exe,dll,bak文件！度之，更改忽略文件。总之是赶鸭子上架，各种囧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然则有园友捧场，我也就不揣浅陋，以见教于大方了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;如何加入一个新驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我更新了dll文件夹：增加了libnodave.dll、libnodave.net.dll、SiemensPLCDriver.dll。这个SiemensPLCDriver.dll，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是西门子S7系列PLC的驱动程序(包括源代码，在Program里面）。&lt;strong&gt;请先同步或者重新下载最新版本&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;libnodave开源库(&lt;a href=&quot;https://github.com/netdata/libnodave&quot; target=&quot;_blank&quot;&gt;https://github.com/netdata/libnodave&lt;/a&gt;)据说是来自西门子的德国大神所作。某前辈当年一句话：能搞定驱动就是大牛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我找到了libnodave,封装后成功的实现了与西门子200PLC通讯，很受鼓舞，也成为了项目的起点。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注册驱动&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;打开变量管理器TagConfig，点注册，双击【路径】框，在dll文件夹里找到SiemensPLCDriver.dll。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205141543-1846769824.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205131449-1949480711.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果出现在下方列表，打钩，点注册，一般会提示成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205117652-902099210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这时候，右键点树节点S1-&amp;gt;参数设置，就会看到S7以太网协议已经成为可选项。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;驱动的加载&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171010205055824-1570444533.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上述一系列动作，就是驱动dll的信息，已经写入了数据库的RegisterModule表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这张表就是为系统服务&lt;strong&gt;反射&lt;/strong&gt;加载驱动程序提供基本信息：加载的位置、类名 、描述，以便实例化为具体的驱动类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;span&gt;DAServer&lt;/span&gt;内有一个AddDriver方法，就是&lt;span&gt;Activator&lt;/span&gt;.CreateInstance加载驱动并转换为&lt;span&gt;IDriver&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用反射加载，最大优点就是用户可以自己实现一个驱动，或者引用第三方驱动，并用TagConfig注册，而不需要改动源代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;如何实现一个新驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 驱动接口规范&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;[&lt;span&gt;Description&lt;/span&gt;(&quot;S7 以太网协议&quot;)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;public sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SiemensTCPReader : &lt;span&gt;IPLCDriver&lt;/span&gt;, &lt;span&gt;IMultiReadWrite&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在前一篇文章里提到，&lt;span&gt;IPLCDriver&lt;/span&gt; 是所有PLC都实现的接口。&lt;span&gt;IMultiReadWrite&lt;/span&gt; 是支持批量读写的下位机必须实现的接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为PLC都具有可连接性、可读写性，同时西门子的协议还支持批量读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SiemensTCPReader&lt;/span&gt; 里的Connect方法，就是对libnodave中connectPLC方法的封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dispose方法，就是释放libnodave的非托管资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReadBytes、ReadInt32、ReadBit、ReadFloat、WriteFloat等方法，就是对&lt;span&gt;IReaderWriter&lt;/span&gt;接口的实现。也就是单独读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReadMultiple、WriteMultiple方法是对&lt;span&gt;IMultiReadWrite&lt;/span&gt; 接口的实现，也是对libnodave中批量读写方法的封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个&lt;span&gt;Description&lt;/span&gt; 属性描述符，在注册之后会被反射为驱动的描述字符，存入数据库。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 为什么要实现批量读写，如何实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;批量读写的目的，就是为了提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人总是拿C#、.NET的所谓性能说事。首先我认为.NET性能优良。关键是你怎么写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对性能影响最大的往往不是语言、框架，而是IO。IO的性能成本往往是语言本身的十倍、百倍、甚至千倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在PLC通讯过程中，请求往返就是性能瓶颈。因为大部分下位机不支持订阅-发布（推送）模式，只能采用定期轮询方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是轮询，如果变量很多，如果一个个去读写，读1000个变量要轮询1000次，一次往返起码几十毫秒，效率差的惊人，还占用PLC大量资源。这是行不通的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但如果你想一次就能读入1000个变量，要考虑到变量可能是不连续的，散乱的。而每次读取的大小受PDU所限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，就一定要对变量的分布分析整理，类似送快递，客户虽然分布在各个小区，但并不能像醉汉一样漫无目的的投递，而是根据客户的分布，执行最优化的路线选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整理的结果，就是将所有要读写的变量分割为块，每块大小不能超过PLC 的PDU。力求往返次数最少、一次读入的区块最大、包含的变量最多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分割整理变量区块的功能，就是&lt;span&gt;PLCGroup&lt;/span&gt; 的UpdatePDUArea函数实现的。不过我在这里只是进行简单的地址归纳，并没有做最优解。最优算法肯定是存在的，但可能与现行方法出入不会太大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网关层接口概述&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下位机通讯原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何实现一个设备驱动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何设计图元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VS插件模块及原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归档模块及文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何进行功能扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组态变量表达式实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。欢迎大家提出宝贵意见和建议！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 13:02:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/7647775.html</dc:identifier>
</item>
<item>
<title>Java Socket通信以及可能出现的问题解决 - 摇头耶稣</title>
<link>http://www.cnblogs.com/shakinghead/p/7647761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shakinghead/p/7647761.html</guid>
<description>&lt;p&gt;Java中基于TCP协议实现网络通信的两个类：客户端的Socket和服务器端的ServerSocket。&lt;/p&gt;
&lt;p&gt;Socket通信模型如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1218256/201710/1218256-20171010201225777-505754918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不管Socket通信的功能有多复杂，任何&lt;span lang=&quot;EN-US&quot;&gt;socket通信过程的基本结构都是一样的。其基本步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;①分别在客户端和服务器端创建&lt;span lang=&quot;EN-US&quot;&gt;Socket和&lt;span lang=&quot;EN-US&quot;&gt;ServerSocket实例；服务器端通过&lt;span lang=&quot;EN-US&quot;&gt;.accept()方法等待请求并阻塞。请求收到后，建立连接&lt;span lang=&quot;EN-US&quot;&gt;Socket对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;②通过&lt;span lang=&quot;EN-US&quot;&gt;getInputStream和&lt;span lang=&quot;EN-US&quot;&gt;getOutputStream方法分别在客户端和服务器端打开输入输出流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;③利用&lt;span lang=&quot;EN-US&quot;&gt;IO流进行读写操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;④关闭所有的流资源和套接字资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;其中，编程工作主要集中在第三步，其他的部分代码基本相同。所有步骤都可能抛出&lt;span lang=&quot;EN-US&quot;&gt;IO异常！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;我在编写一个简单的socket程序时，使用的Socket通信出现了一个问题：我在客户端写入的数据，在服务器端无法输出。当我从客户端断开连接时，之前写入的所有数据立刻在服务器端输出出来了。经过反复的验证和求解，以下是我的结论和解决方法。希望有同样问题的小伙伴看完可以解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;通过一端的Socket建立了PrintWriter类来写入数据，通过另一端的Socket建立了BufferedReader类来读取数据并输出。如果数据写入后没有被显示，可能的原因有两种：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;一、写入的数据存储在缓冲区中，没有被写入IO流中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;如果不主动的干涉，写入的数据会一直堆在缓冲区中，直到缓冲区满了引发JVM自动刷新缓冲区。显然这不符合我们的需求。对于这种情况，PrintWriter类提供了flush()方法来强制刷新缓冲区，将缓冲区数据写入IO流中。另外，PrintWriter类的构造器有一个参数”boolean autoflush“，这个参数默认为false，如果设置为true，则会开启自动刷新缓冲区功能。但是请注意，这里的自动刷新是有触发条件的，那就是：PrintWriter类写入数据的方法必须是println、printf或者format方法时，才会触发自动刷新。如果是调用write()这类方法写入数据，是不会触发自动刷新的！总结起来，就是三点：autoflush参数设置，write和println方法的选择，flush方法的使用。对这三个进行组合，就能保证在Socket通信的某一端写入数据时，数据一定能成功地写入到IO流中！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、读取数据使用了readLine()方法，该方法没有正常的结束：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;请注意，BufferedReader类的readLine()方法是一个阻塞函数！也就是说，这个方法本身是读取一行数据，但是它自己识别不了什么叫做“一行”!当调用该方法读取完一段数据后，它会阻塞，而不会return它的读取数据。这就是为什么有的时候明明已经刷新了缓冲区正确的写入数据了，还是通过输入流读取数据并显示出来的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;对于readLine()方法，它解除阻塞、正确结束并返回读取的值，只有以下几种情况：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;①读取的数据里含有回车符&quot;\r&quot;或者换行符&quot;\n&quot;或者回车换行符&quot;\r\n&quot;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;②读取的数据是在另一端通过println方法写入的，因为println方法自带换行符；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;③BufferedReader类的缓冲区满了，那么JVM会自动刷新缓冲区从而释放“积攒”的数据（但是鉴于默认缓冲区大小为8192个字符，对于小数据量的通信，显然触发不了）；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;④对于读取的数据，写入这些数据的流发生异常或者直接关闭，那么readLine()就会把它吃的数据全部吐出来。这就刚好解释了，为什么在我的程序中，断开客户端Socket连接，服务器端立刻输出所有客户端消息的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;综上，在Socket通信过程中，保证某一端输出流的缓冲被刷新，保证另一端的readLine方法能正常停止，即可解决写入的数据在另一端无法输出的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;以下是我修改后能成功运行的代码，分别是服务器端Socket和客户端Socket。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;over！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStreamWriter;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShakingServer{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建服务器套接字实例，设置监听端口为2000&lt;/span&gt;
        ServerSocket server=&lt;span&gt;new&lt;/span&gt; ServerSocket(2000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始监听客户端的请求，并阻塞&lt;/span&gt;
        Socket socket=&lt;span&gt;server.accept();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求收到后，自动建立连接。通过IO流进行数据传输&lt;/span&gt;
        System.out.println(&quot;连接建立成功&quot;&lt;span&gt;);

        OutputStream os&lt;/span&gt;=&lt;span&gt;socket.getOutputStream();
        PrintWriter pw&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PrintWriter(&lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(os)),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        pw.write(&lt;/span&gt;&quot;欢迎访问摇头耶稣的世界！&quot;&lt;span&gt;);
        pw.flush();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我关闭了输出流，所以另一端的readLine方法才正常结束了&lt;/span&gt;
&lt;span&gt;        socket.shutdownOutput();

        InputStream is&lt;/span&gt;=&lt;span&gt;socket.getInputStream();
        InputStreamReader isr&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(is);
        BufferedReader br&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            String str&lt;/span&gt;=&lt;span&gt;br.readLine();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(str.equals(&quot;quit&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            System.out.println(&lt;/span&gt;&quot;Client said: &quot;+&lt;span&gt;str);
        }
        socket.shutdownInput();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket.shutdownOutput();&lt;/span&gt;
&lt;span&gt;        socket.close();
        server.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStreamWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.PrintWriter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShakingClient{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建客户端的套接字，设置连接的服务器的IP地址和端口号&lt;/span&gt;
        Socket socket=&lt;span&gt;new&lt;/span&gt; Socket(&quot;169.254.132.203&quot;,2000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入流读取服务器发送的信息&lt;/span&gt;
        BufferedReader br=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(socket.getInputStream()));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启自动刷新缓冲区&lt;/span&gt;
        PrintWriter pw=&lt;span&gt;new&lt;/span&gt; PrintWriter(&lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(socket.getOutputStream())),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);            
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从键盘读取数据&lt;/span&gt;
        BufferedReader ii=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(System.in));
        System.out.println(br.readLine());
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为开启了自动刷新，且调用的是println方法，所以可以不调用flush方法&lt;/span&gt;
        pw.println(&quot;请求进入摇头耶稣的世界&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pw.flush();&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            String str&lt;/span&gt;=&lt;span&gt;ii.readLine();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用了回车符来保证另一端的readLine方法正常结束&lt;/span&gt;
            pw.write(str+&quot;\r&quot;&lt;span&gt;);
            pw.flush();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果输入quit则退出聊天室&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(str.equals(&quot;quit&quot;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        socket.shutdownInput();
        socket.shutdownOutput();
        socket.close();
    }
}
                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Oct 2017 12:52:00 +0000</pubDate>
<dc:creator>摇头耶稣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shakinghead/p/7647761.html</dc:identifier>
</item>
<item>
<title>JavaScript接口 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7646969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7646969.html</guid>
<description>&lt;p&gt;&lt;span&gt;JavaScript中实现接口的方法有三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种，使用注释的方法实现接口&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;特点：&lt;br/&gt;（1）最简单，但是功能最弱&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）利用 interface和 implement&quot;文字&quot;&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;2&quot;&gt;（3）把他们用注释的方式表现出来&lt;p&gt;具体实现如下：&lt;/p&gt;&lt;p&gt;1，用注释定义一个接口&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * interface PersonDao(){
    * function add(obj);
    * function remove(obj);
    * function find(id);
    * }
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）用注释来注明实现的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * PersonDaoImp  implement PersonDao （PersonDaoImp实现接口PersonDao） 
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PersonDaoImp=&lt;span&gt;function () {   };//定义实现类&lt;br/&gt;//实现
    PersonDaoImp.prototype.add&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;&lt;span&gt;    }
    PersonDaoImp.prototype.remove&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;&lt;span&gt;    }
    PersonDaoImp.prototype.find&lt;/span&gt;=&lt;span&gt;function(id){
       &lt;/span&gt;&lt;span&gt;//具体代码
&lt;/span&gt;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;（1）使用文字的形式告知是谁实现谁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）优点，这样是很有意义的，大型项目需要的就是规范和标准，可以在没有写实现之前充分考虑架构和设计&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3）缺点：需要人为的遵守注释中的说明&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;第二种，使用属性检验法实现接口 。 实质为通过一个属性判断实现了谁&lt;br/&gt;具体如下：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;1，用注释来定义一个接口&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * interface PersonDao(){
     * function add(obj);
     * function remove(obj);
     * function find(id);
     * }
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;2，&lt;/span&gt;&lt;/span&gt;用注释来说明实现接口类+实现类中增加属性&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * PersonDaoImp  implement PersonDao
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; PersonDaoImp=&lt;span&gt;function () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.implementInterface=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告知该类实现的接口是啥是一个数组，&lt;/span&gt;
&lt;span&gt;}
    PersonDaoImp.prototype.add&lt;/span&gt;=&lt;span&gt;function(obj){
             alert(obj);
    }
    PersonDaoImp.prototype.remove&lt;/span&gt;=&lt;span&gt;function(obj){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;    }
    PersonDaoImp.prototype.find&lt;/span&gt;=&lt;span&gt;function(id){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）检验属性的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收一个不定参数 可能有多个  使用Object&lt;/span&gt;
&lt;span&gt;        function imp1(Object) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历传入对象的所用属性  i=1：第一个是不定参数，从第二个参数开始遍历接口，故i=1&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arguments除Object外&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; interfaceName=&lt;span&gt;arguments[i];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; interfaceFind=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;Object.implementInterface.length;j++&lt;span&gt;){
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Object.implementInterface[j]==&lt;span&gt;interfaceName){
                         interfaceFind&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                         &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                     }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;interfaceFind){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）接口与实现类的配合实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  function addObj(obj) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; PersonDao=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonDaoImp();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始检查  实现类是否实现接口&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!imp1(PersonDao,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;某对象是否实现接口(对象，接口)   第一次参数是对象，第二个参数是不定参数&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PersonDaoImp没有实现接口PersonDao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;
&lt;span&gt;                PersonDao.add(obj);
            }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
addObj(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;第三种，鸭式变形法  一种形似的命名方式，从实现角度来理解为：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如果对象中具有的方法与接口中定义的方法同名  则认为是实现了本接口。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;具体如下：&lt;br/&gt;1，定义一个接口类   注意这里与上面两种不一样了，不用写注释说明了&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Interface=function (name,methods) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name：接口名字&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;必须是两个参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methods=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个空数组装载函数名&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;methods.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;  methods[i]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;){
                alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数名必须是字符串类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.methods.push( methods[i]);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;2，定义一个静态方法来实现接口与实现类的 直接检验&lt;br/&gt;注意，&lt;/span&gt;&lt;span&gt;静态方法不要写成Interface.prototype ,因为这是写到接口的原型链上的，我们要把静态的函数直接写到类层次上。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Interface.ensureImplement=function (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) {
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arguments.length&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数必须不少于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     }
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;arguments.length;i++&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inter=&lt;span&gt;arguments[i];
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是接口就必须是Interface类型&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(inter.constructor!=&lt;span&gt;Interface){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;如果是接口类的话，就必须是Interface类型&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接口中的方法是否全部实现
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历函数集合&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;inter.methods.length;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method=inter.methods[j];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口中所有函数

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;object[method]是传入的函数&lt;/span&gt;
             &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;object&lt;/span&gt;[method]||&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[method]!=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现类中必须有方法名字与接口中所用方法名相同&lt;/span&gt;
                     &lt;span&gt;throw&lt;/span&gt;  &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实现类中没有完全实现接口中的所有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        }
                    }
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，应用&lt;/p&gt;
&lt;p&gt;3.1定义自己的接口    &lt;/p&gt;
&lt;p&gt;         例如：此处定义两个接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; FirstInterface=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FirstInterface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);//第一个接口
&lt;/span&gt;&lt;span&gt; var&lt;/span&gt; SecondInterface=&lt;span&gt;new&lt;/span&gt; Interface(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SecondInterface&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;save&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]);//第二个接口&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2，定义实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 function commManager() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现两个类
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先实现方法&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.add=&lt;span&gt;function () {
            alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok--实现&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.remove=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.search=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.save=&lt;span&gt;function () {
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检验&lt;/span&gt;
        Interface.ensureImplement(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,GridManager,formManager);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3，实现类的实例化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; comm=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; commManager();
    comm.add();//调用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 总结：三种方式都有自己的优势与缺点，每种的选择需要根据自己的需要进行选择。但是在设计的时候实现类间低耦合的相当重要的。&lt;/p&gt;
&lt;p&gt;本人初学，若有不足之处，还希望大家能多多指出，大家相互学习，谢谢。&lt;/p&gt;




&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span/&gt;
&lt;/pre&gt;

</description>
<pubDate>Tue, 10 Oct 2017 12:51:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7646969.html</dc:identifier>
</item>
<item>
<title>浪潮之巅——IT产业的三大定律 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7641540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7641540.html</guid>
<description>&lt;p&gt;　　说实话除了小说以外，从来没有什么书能让我一口气看完，更不用说IT界的书了。但是吴军老师的《浪潮之巅》这本书除外，电子版的洋洋洒洒五百多页，我一下午就将其看完了。全书通过介绍AT&amp;amp;T、IBM、微软、苹果、google等IT公司的发展历史，分析了一些公司从辉煌走向衰落的过程和原因，还讲述了风投的相关知识以及几个重要的商业模式、国际金融机构和世界经济操盘手等等。&lt;/p&gt;
&lt;p&gt;　　这是LZ看完之后乱入的诗兴大发：滚滚长江东逝水，浪花淘尽英雄，数风流人物，还看今朝！！！&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171009183244184-783273318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　作者文笔风趣幽默，通俗易懂，大家有兴趣的也可以看看，那么回归本篇博客的正题，本篇博客不是谈这本书的读后感，而是先重点讲解这本书的第四章节——计算机工业的生态链，也就是IT产业的三大定律，而这三大定律也是指引着公司发展的秘诀。&lt;/p&gt;

&lt;h3&gt;1、摩尔定律&lt;/h3&gt;
&lt;p&gt;　　摩尔定律：&lt;strong&gt;集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这是由英特尔（Intel）创始人之一戈登·摩尔（Gordon Moore）于1965年提出来的，总结下来有如下三个版本：&lt;/p&gt;
&lt;p&gt;　　①、集成电路芯片上所集成的电路的数目，每隔18个月就翻一番。&lt;/p&gt;
&lt;p&gt;　　②、微处理器的性能每隔18个月提高一倍，而价格下降一倍。&lt;/p&gt;
&lt;p&gt;　　③、用一个美元所能买到的电脑性能，每隔18个月翻两番。&lt;/p&gt;
&lt;p&gt; 　　LZ找到如下的这张图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171009174012230-1707830543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　横轴为新CPU发明的年份，纵轴为可容纳晶体管的对数。所有的点近似成一条直线，这意味着晶体管数目随年份呈指数变化，大概每两年翻一番。&lt;/p&gt;
&lt;p&gt;　　这里我们需要说明的是，戈登·摩尔发现的摩尔定律不基于任何特定的科学或工程理论，只是真实情况的影射总结。而硅芯片行业注意到了这个定律，也没有简单把它当作一个描述的、预言性质的观察，而是作为一个说明性的，重要的规则，整个行业努力的目标。&lt;/p&gt;
&lt;p&gt;　　要么跟随摩尔定律，要么死！！！&lt;/p&gt;
&lt;p&gt;　　在摩尔定律发现长达40年间，它带领着硅谷以史诗般的速度前进，并成为全世界的先驱。忽视摩尔定律的公司纷纷被淘汰，紧随它的公司则越来越强大富有。&lt;/p&gt;
&lt;p&gt;　　摩尔定律也是整个信息时代的驱动力，多亏有了摩尔定律，我们今天才能把智能手机放在口袋或钱包里，今天智能手机的性能比 1965-1995 年里最大的电脑还要强劲。没有摩尔定律就没有超薄笔记本电脑，也不可能产生足以绘制整个基因组、或是设计复杂药物的高性能计算机。流媒体视频、社交媒体、搜索功能、云——没有摩尔定律，这些都不可能产生（或者说不可能这么快产生可能更加准确）。&lt;/p&gt;
&lt;p&gt;　　但是摩尔定律能一直持续下去吗？我们很容易就能想到：芯片上元件的几何尺寸总不可能无限制地缩小下去，这就意味着，总有一天，芯片单位面积上可集成的元件数量会达到极限。问题只是这一极限是多少，以及何时达到这一极限。业界已有专家预计，芯片性能的增长速度将在今后几年趋缓。&lt;/p&gt;
&lt;p&gt;　　而我们也完全不必担心摩尔定律何时会终结，我们要知道摩尔定律实际上是关于人类信念的定律，&lt;strong&gt;当人们相信某件事情一定能做到时，就会努力去实现它&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;2、安迪-比尔定律&lt;/h3&gt;
&lt;p&gt;　　根据前面讲摩尔定律，我们可以有这样一个消费信念：如果我今天嫌计算机太贵买不起，那么我等十八个月就可以用一半的价钱来买。&lt;/p&gt;
&lt;p&gt;　　大家想想，如果都是这种想法的话，那么计算机的销售量便上不去了，包括其他IT产品也是。但是实际上，世界上的个人微机销量在持续增长，比如在2004年到2009年，这五年间，世界上 PC（包括个人机和小型服务器）的销量会增长 60%，远远高于经济的增长。而促使人们不断更新自己硬件的原因便是安迪-比尔定律。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;安迪-比尔定理 （Andy and Bill’s Law）&lt;/strong&gt;是对IT产业中软件和硬件升级换代关系的一个概括。原话是 “Andy gives, Bill takes away.（安迪提供什么，比尔拿走什么。）” 安迪指英特尔前CEO安迪·格鲁夫，比尔指微软前任CEO比尔·盖茨，这句话的意思是，硬件提高的性能，很快被软件消耗掉了。&lt;/p&gt;
&lt;p&gt;　　怎么理解呢？最明显的例子是我们使用的手机，那时候单核，512兆内存，甚至更小的内存也能够让我们使用日常的手机软件。但是现在的手机动不动就双核，四核，内存达到了2G,4G，甚至6G，但是能使用的手机软件也并不比以前多很多。这是因为操作系统越来越大，应用软件也越来越大导致的，虽然新版的软件功能比以前强，但是增加的功能绝对不是和它的大小成正比。&lt;/p&gt;
&lt;p&gt;　　一台十年前的计算机能装多少应用程序，现在的也不过装这么多，虽然硬盘的容量增加了一千倍。更糟糕的是，用户发现，如果不更新计算机，现在很多新的软件就用不了，连上网也是个问题。而十年前买得起的车却照样可以跑。&lt;/p&gt;
&lt;p&gt;　　这种现象咋一看好像是操作系统商，或者应用软件商在故意和大家作对，实际上比如微软或者其他厂商也不想把操作系统或者应用软件做这么大，比如以前的软件用汇编语言编写，只有几K大小。但是汇编语言编写的我们知道可读性很差，而且工作效率特别低。特别是现在有了足够的硬件资源，软件工程师做事情更讲究自己的工作效率，程序的规范化和可读性等等。便产生了如今的高级编程语言，高级语言工作效率很高，但是运行效率却低的很。比如今天的 Java 就比 C++ 效率低得多，C++ 又比二十年前的 C 效率低。因此，即使是同样功能的软件，今天的比昨天的占用硬件资源多是一件在所难免的事。&lt;/p&gt;
&lt;p&gt;　　虽然用户很是烦恼新的软件把硬件提升所带来的好处几乎全部用光，但是在 IT 领域，各个硬件厂商恰恰是靠软件开发商用光自己提供的硬件资源得以生存。比如以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新机器让惠普和戴尔等公司收益，而这些整机生产厂再向英特尔这样的半导体厂订货购买新的芯片、同时向 Seagat e等外设厂购买新的外设。在这中间，各家的利润先后得到相应的提升，股票也随着增长。各个硬件半导体和外设公司再将利润投入研发，按照摩尔定理制定的速度，提升硬件性能，为微软下一步更新软件、吃掉硬件性能做准备。所以如果微软的开发速度比预期的慢，软件的业绩不好，那么英特尔等公司的业绩也会受到影响。&lt;/p&gt;
&lt;p&gt;　　也就是说安迪-比尔定理把原本属于耐用消费品的电脑、手机等商品变成了消耗性商品，刺激着整个 IT 领域的发展。&lt;/p&gt;

&lt;h3&gt;3、反摩尔定律&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。&lt;/strong&gt;这便是反摩尔定律，不是反对摩尔定律的看法，而是从相反的角度来看待摩尔定律。它是由是Google的前CEO埃里克·施密特提出的。&lt;/p&gt;
&lt;p&gt;　　反摩尔定律对于所有的IT公司来讲，都是非常可怕的，因为一个IT公司花了同样的劳动，却只得到以前一半的收入。反摩尔定律逼着所有的硬件设备公司必须赶上摩尔定律所规定的更新速度，而所有的硬件和设备生产厂活得都是非常辛苦的。但是从另一个方面来讲，反摩尔定律促成科技领域质的进步，并为新兴公司提供生存和发展的可能。和所有事物的发展一样，IT领域的技术进步也有量变和质变两种。为了赶上摩尔定律预测的发展速度，光靠量变是不够的。每一种技术，过不了多少年，量变的潜力就会被挖掘光，这时就必须要有革命性的创造发明诞生。&lt;/p&gt;

&lt;h3&gt;4、总结&lt;/h3&gt;
&lt;p&gt;　　IT行业总体来说是一个高速发展的行业，在这个行业中发展，摩尔定律推动着我们马不停蹄的前进。而由于安迪-比尔定律的存在，在IT工业的产业链中，处于上游的是看不见摸不着的软件和IT服务行业，而下游才是看得见摸得着的硬件和半导体。因此从事IT行业，想要获得高利润，无不是从上游入手。从微软，谷歌，到Facebook，无一不是如此。但是这里有个例外，苹果公司，它是通过硬件实现软件的价值，因为它的产品成为了一种时尚和潮流。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 12:22:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7641540.html</dc:identifier>
</item>
<item>
<title>MyBatis 配置的一些小知识点 - 坚持到底gl</title>
<link>http://www.cnblogs.com/zhouguanglin/p/7647524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouguanglin/p/7647524.html</guid>
<description>&lt;h2&gt;MyBatis别名配置——typeAliases&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;　　类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。说白了就是预先设置包名&lt;/p&gt;
&lt;p&gt;api是这样写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAlias &lt;/span&gt;&lt;span&gt;alias&lt;/span&gt;&lt;span&gt;=&quot;Author&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;domain.blog.Author&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAlias &lt;/span&gt;&lt;span&gt;alias&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;domain.blog.Blog&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;domain.blog&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个直接在xml中的&amp;lt;configuration&amp;gt;下设置就可以，再使用的时候就可以直接使用别名了，不过要注意的时候写在xml下的时候有顺序关系的 哦！碰到错误自己解决，调整位置就好&lt;/p&gt;
&lt;p&gt;已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。&lt;/p&gt;
&lt;table class=&quot;table table-striped&quot; border=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;a&quot;&gt;&lt;th&gt;别名&lt;/th&gt;
&lt;th&gt;映射的类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;_byte&lt;/td&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;_long&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;_short&lt;/td&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;_int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;_integer&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;_double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;_float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;_boolean&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;integer&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;BigDecimal&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;bigdecimal&lt;/td&gt;
&lt;td&gt;BigDecimal&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;Map&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;hashmap&lt;/td&gt;
&lt;td&gt;HashMap&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;list&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;arraylist&lt;/td&gt;
&lt;td&gt;ArrayList&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;a&quot;&gt;&lt;td&gt;collection&lt;/td&gt;
&lt;td&gt;Collection&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;b&quot;&gt;&lt;td&gt;iterator&lt;/td&gt;
&lt;td&gt;Iterator&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;映射器——mappers&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 &lt;tt&gt;file:///&lt;/tt&gt; 的 URL），或类名和包名等。&lt;/p&gt;
&lt;p&gt;这里有四种方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一种类路径的资源引用
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;com/entity/UserMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
第二种直接给出本地地址形式的，自己存放的地址，完全限定资源定位符
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;=&quot;file:///var/mappers/UserMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
第三种以类的形式去寻找
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.entity.AuthorMapper&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
第四种包名的形式
 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.entity.builder&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;映射配置细节&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;resultMap和resultType&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;resultType&lt;/strong&gt;是直接表示返回类型的，查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。当提供的返回类型属性是resultType的时候，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，只是当我们提供的返回类型属性是resultType的时候，MyBatis对自动的给我们把对应的值赋给resultType所指定对象的属性。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;resultMap&lt;/strong&gt;则是对外部ResultMap的引用，然后基于查找出来的属性名进行键值对封装，主要用在进行复杂联合查询上，结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。&lt;/p&gt;
&lt;p&gt;　　resultType跟resultMap不能同时存在。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;resultMap支持继承&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　extends=&quot;User&quot;说明继承了上一个resultMap，要是一个实体类很重的话，先给出一个框架大家都继承与他，是不错的选择&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;多对多关联查询 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.entity.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user_info&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;userInfos&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;com.entity.UserInfo&quot;&lt;/span&gt;&lt;span&gt;
            column&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUser&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;user_info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user u,userinfo i
        where u.id=i.uid and u.id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;动态SQL语句完成多条件查询&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;动态 SQL 通常要做的事情是有条件地包含 where 子句的一部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogWithTitleLike&quot;&lt;/span&gt;&lt;span&gt;
     resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG 
  WHERE state = ‘ACTIVE’ 
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND title like #{title}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条语句提供了一个可选的文本查找类型的功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回。&lt;/p&gt;
&lt;h3&gt;choose&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;queryEmp&quot;&lt;/span&gt;&lt;span&gt;  resultType&lt;/span&gt;&lt;span&gt;=&quot;cn.test.entity.Emp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          select * from emp where 1=1
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;choose&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;when &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;deptNo!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          and deptno=#{deptNo}
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;when &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;deptName!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          and deptname=#{deptName}
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;otherwise&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          and personnum&amp;gt;#{personNum}
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;otherwise&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;choose&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面也说了，choose相当于Java中的switch语句；当第一个when满足时；就只执行第一个when中的条件。当when中的条件都不满足时；就会执行默认的的；也就是otherwise中的语句。&lt;/p&gt;
&lt;h3&gt;Where&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getU&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.entity.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select*from user
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username!=null and username!=''&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                username like concat('%',#{username},'%')
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                and id=#{id}
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; where下面第一个if语句中以and开头，也可以省略第一个and ，如果第一个if语句中有and；mybatis会将第一个and忽略。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;set&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateEmp&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;cn.test.entity.Emp&quot;&lt;/span&gt;&lt;span&gt; flushCache&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          update emp 
          &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;empName!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;empname=#{empName},&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;job!=null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;job=#{job}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          where empno=#{empNo}
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  在mybatis中的SQL语句结尾不能加“；”，这样会导致mybatis无法识别字符；导致SQL语句的语法错误；&lt;/p&gt;
&lt;h3&gt;foreach&lt;/h3&gt;
&lt;p&gt;动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectPostIn&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;domain.blog.Post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT *
  FROM POST P
  WHERE ID in
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;foreach &lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;&lt;span&gt;=&quot;index&quot;&lt;/span&gt;&lt;span&gt; collection&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;
      open&lt;/span&gt;&lt;span&gt;=&quot;(&quot;&lt;/span&gt;&lt;span&gt; separator&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; close&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{item}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;   &lt;/span&gt;【版本声明】本文为博主原创文章，转载请注明出处&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 11:58:00 +0000</pubDate>
<dc:creator>坚持到底gl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouguanglin/p/7647524.html</dc:identifier>
</item>
<item>
<title>设计模式之组合模式 - snailteam</title>
<link>http://www.cnblogs.com/snaildev/p/7647190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snaildev/p/7647190.html</guid>
<description>&lt;h3&gt;什么是组合模式？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://owvsetuqu.bkt.clouddn.com/image/designpattern/Composite2.png&quot;&gt;&lt;img src=&quot;http://owvsetuqu.bkt.clouddn.com/image/designpattern/Composite2.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;组合模式允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合。&lt;br/&gt;组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组合部件（Component）：它是一个抽象角色，为要组合的对象提供统一的接口。&lt;/li&gt;
&lt;li&gt;叶子（Leaf）：在组合中表示子节点对象，叶子节点不能有子节点。&lt;/li&gt;
&lt;li&gt;合成部件（Composite）：定义有枝节点的行为，用来存储部件，实现在Component接口中的有关操作，如增加（Add）和删除（Remove）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;透明式的组合模式&lt;/strong&gt;&lt;br/&gt;在Component中声明所有来管理子对象的方法，其中包括Add，Remove等。这样实现Component接口的所有子类都具备了Add和Remove方法。这样做的好处是叶节点和枝节点对于外界没有区别，它们具备完全一致的接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/// &amp;lt;summary&amp;gt;
/// 一个抽象构件，声明一个接口用于访问和管理Component的子部件
/// &amp;lt;/summary&amp;gt;
public abstract class Component
{
    protected string name;

    public Component(string name)
    {
        this.name = name;
    }

    /// &amp;lt;summary&amp;gt;
    /// 增加一个节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public abstract void Add(Component component);

    /// &amp;lt;summary&amp;gt;
    /// 移除一个节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public abstract void Remove(Component component);

    /// &amp;lt;summary&amp;gt;
    /// 显示层级结构
    /// &amp;lt;/summary&amp;gt;
    public abstract void Display(int level);
}

/// &amp;lt;summary&amp;gt;
/// 叶子节点
/// &amp;lt;/summary&amp;gt;
public class Leaf : Component
{
    public Leaf(string name)
        : base(name)
    { }

    /// &amp;lt;summary&amp;gt;
    /// 由于叶子节点没有子节点，所以Add和Remove方法对它来说没有意义，但它继承自Component，这样做可以消除叶节点和枝节点对象在抽象层次的区别，它们具备完全一致的接口。
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Add(Component component)
    {
        Console.WriteLine(&quot;Can not add a component to a leaf.&quot;);
    }

    /// &amp;lt;summary&amp;gt;
    /// 实现它没有意义，只是提供了一个一致的调用接口
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Remove(Component component)
    {
        Console.WriteLine(&quot;Can not remove a component to a leaf.&quot;);
    }

    public override void Display(int level)
    {
        Console.WriteLine(new string('-', level) + name);
    }
}

/// &amp;lt;summary&amp;gt;
/// 定义有枝节点的行为，用来存储部件，实现在Component接口中对子部件有关的操作
/// &amp;lt;/summary&amp;gt;
public class Composite : Component
{
    public Composite(string name)
        : base(name)
    { }

    /// &amp;lt;summary&amp;gt;
    /// 一个子对象集合，用来存储其下属的枝节点和叶节点
    /// &amp;lt;/summary&amp;gt;
    private List&amp;lt;Component&amp;gt; children = new List&amp;lt;Component&amp;gt;();

    /// &amp;lt;summary&amp;gt;
    /// 增加子节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Add(Component component)
    {
        children.Add(component);
    }

    /// &amp;lt;summary&amp;gt;
    /// 移除子节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public override void Remove(Component component)
    {
        children.Remove(component);
    }

    public override void Display(int level)
    {
        Console.WriteLine(new string('-', level) + name);

        // 遍历其子节点并显示
        foreach (Component component in children)
        {
            component.Display(level + 2);
        }
    }
}

/// &amp;lt;summary&amp;gt;
/// 调用
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
static void Main(string[] args)
{
    // 生成树根，并为其增加两个叶子节点
    Component root = new Composite.Composite(&quot;Root&quot;);
    root.Add(new Leaf(&quot;Leaf A in Root&quot;));
    root.Add(new Leaf(&quot;Leaf B in Root&quot;));

    // 为根增加两个枝节点
    Component branchX = new Composite.Composite(&quot;Branch X in Root&quot;);
    Component branchY = new Composite.Composite(&quot;Branch Y in Root&quot;);
    root.Add(branchX);
    root.Add(branchY);

    // 为BranchX增加页节点
    branchX.Add(new Leaf(&quot;Leaf A in Branch X&quot;));

    // 为BranchX增加枝节点
    Component branchZ = new Composite.Composite(&quot;Branch Z in Branch X&quot;);
    branchX.Add(branchZ);

    // 为BranchY增加叶节点
    branchY.Add(new Leaf(&quot;Leaf in Branch Y&quot;));

    // 为BranchZ增加叶节点
    branchZ.Add(new Leaf(&quot;Leaf in Branch Z&quot;));

    // 显示树
    root.Display(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;弊端：客户端对叶节点和枝节点是一致的，但叶节点并不具备Add和Remove的功能，因而对它们的实现是没有意义的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全式组合模式&lt;/strong&gt;&lt;br/&gt;在Component中不去声明Add和Remove方法，那么子类的Leaf就不需要实现它，而是在Composit声明所有用来管理子类对象的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/// &amp;lt;summary&amp;gt;
/// 一个抽象构件，声明一个接口用于访问和管理Component的子部件
/// &amp;lt;/summary&amp;gt;
public abstract class Component
{
    protected string name;

    public Component(string name)
    {
        this.name = name;
    }

    /// &amp;lt;summary&amp;gt;
    /// 显示层级结构
    /// &amp;lt;/summary&amp;gt;
    public abstract void Display(int level);
}

/// &amp;lt;summary&amp;gt;
/// 叶子节点
/// &amp;lt;/summary&amp;gt;
public class Leaf : Component
{
    public Leaf(string name)
        : base(name)
    { }
   
    public override void Display(int level)
    {
        Console.WriteLine(new string('-', level) + name);
    }
}

/// &amp;lt;summary&amp;gt;
/// 定义有枝节点的行为，用来存储部件，实现在Component接口中对子部件有关的操作
/// &amp;lt;/summary&amp;gt;
public class Composite : Component
{
    public Composite(string name)
        : base(name)
    { }

    /// &amp;lt;summary&amp;gt;
    /// 一个子对象集合，用来存储其下属的枝节点和叶节点
    /// &amp;lt;/summary&amp;gt;
    private List&amp;lt;Component&amp;gt; children = new List&amp;lt;Component&amp;gt;();

    /// &amp;lt;summary&amp;gt;
    /// 增加子节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public void Add(Component component)
    {
        children.Add(component);
    }

    /// &amp;lt;summary&amp;gt;
    /// 移除子节点
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;component&quot;&amp;gt;&amp;lt;/param&amp;gt;
    public void Remove(Component component)
    {
        children.Remove(component);
    }

    public override void Display(int level)
    {
        Console.WriteLine(new string('-', level) + name);

        // 遍历其子节点并显示
        foreach (Component component in children)
        {
            component.Display(level + 2);
        }
    }
}

/// &amp;lt;summary&amp;gt;
/// 调用
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
static void Main(string[] args)
{
    // 生成树根，并为其增加两个叶子节点
    Composite.Composite root = new Composite.Composite(&quot;Root&quot;);
    root.Add(new Leaf(&quot;Leaf A in Root&quot;));
    root.Add(new Leaf(&quot;Leaf B in Root&quot;));

    // 为根增加两个枝节点
    Composite.Composite branchX = new Composite.Composite(&quot;Branch X in Root&quot;);
    Composite.Composite branchY = new Composite.Composite(&quot;Branch Y in Root&quot;);
    root.Add(branchX);
    root.Add(branchY);

    // 为BranchX增加页节点
    branchX.Add(new Leaf(&quot;Leaf A in Branch X&quot;));

    // 为BranchX增加枝节点
    Composite.Composite branchZ = new Composite.Composite(&quot;Branch Z in Branch X&quot;);
    branchX.Add(branchZ);

    // 为BranchY增加叶节点
    branchY.Add(new Leaf(&quot;Leaf in Branch Y&quot;));

    // 为BranchZ增加叶节点
    branchZ.Add(new Leaf(&quot;Leaf in Branch Z&quot;));

    // 显示树
    root.Display(1);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;弊端：叶节点无需在实现Add与Remove这样的方法，但是对于客户端来说，必须对叶节点和枝节点进行判定，为客户端的使用带来不便。&lt;/p&gt;
&lt;h3&gt;组合模式的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组合模式使得客户端代码可以一致地处理对象和对象容器，无需关系处理的单个对象，还是组合的对象容器。&lt;/li&gt;
&lt;li&gt;将”客户代码与复杂的对象容器结构“解耦。&lt;/li&gt;
&lt;li&gt;可以更容易地往组合对象中加入新的构件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。&lt;br/&gt;&lt;strong&gt;注意的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有时候系统需要遍历一个树枝结构的子构件很多次，这时候可以考虑把遍历子构件的结构存储在父构件里面作为缓存。&lt;/li&gt;
&lt;li&gt;客户端尽量不要直接调用树叶类中的方法（在我上面实现就是这样的，创建的是一个树枝的具体对象;），而是借用其父类（Graphics）的多态性完成调用，这样可以增加代码的复用性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;组合模式的使用场景&lt;/h3&gt;
&lt;p&gt;在以下情况下应该考虑使用组合模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当想表达对象的部分-整体的层次结构时。&lt;/li&gt;
&lt;li&gt;希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象时。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;.NET 中Winform 中的空间类型大多用到了该种设计模式。另， 《设计模式》一书中提倡：相对于安全性，我们比较强调透明性。对于第一种方式中叶子节点内不需要的方法可以使用空处理或者异常报告的方式来解决。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SnailDev/SnailDev.DesignPattern&quot; target=&quot;_blank&quot;&gt;代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 10:37:00 +0000</pubDate>
<dc:creator>snailteam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snaildev/p/7647190.html</dc:identifier>
</item>
</channel>
</rss>