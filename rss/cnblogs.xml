<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>poj~2528 Mayor's posters - 弃疗大表哥</title>
<link>http://www.cnblogs.com/qldabiaoge/p/9058416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qldabiaoge/p/9058416.html</guid>
<description>&lt;p&gt;Mayor's posters&lt;/p&gt;
&lt;div class=&quot;plm&quot;&gt;
&lt;table align=&quot;center&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Time Limit:&lt;/strong&gt; 1000MS&lt;/td&gt;
&lt;td width=&quot;10px&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Memory Limit:&lt;/strong&gt; 65536K&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;Total Submissions:&lt;/strong&gt; 73869&lt;/td&gt;
&lt;td width=&quot;10px&quot;&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Accepted:&lt;/strong&gt; 21303&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Description&lt;/p&gt;
&lt;div class=&quot;ptx&quot; lang=&quot;en-US&quot; readability=&quot;22&quot;&gt;The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules: &lt;br/&gt;&lt;ul&gt;&lt;li&gt;Every candidate can place exactly one poster on the wall. &lt;/li&gt;
&lt;li&gt;All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown). &lt;/li&gt;
&lt;li&gt;The wall is divided into segments and the width of each segment is one byte. &lt;/li&gt;
&lt;li&gt;Each poster must completely cover a contiguous number of wall segments.&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections. &lt;br/&gt;Your task is to find the number of visible posters when all the posters are placed given the information about posters' size, their place and order of placement on the electoral wall. &lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Input&lt;/p&gt;
&lt;p&gt;The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &amp;lt;= n &amp;lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers l&lt;sub&gt;i&lt;/sub&gt; and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &amp;lt;= i &amp;lt;= n, 1 &amp;lt;= l&lt;sub&gt;i&lt;/sub&gt; &amp;lt;= ri &amp;lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered l&lt;sub&gt;i&lt;/sub&gt;, l&lt;sub&gt;i&lt;/sub&gt;+1 ,... , ri.&lt;/p&gt;
&lt;p class=&quot;pst&quot;&gt;Output&lt;/p&gt;
&lt;div class=&quot;ptx&quot; lang=&quot;en-US&quot; readability=&quot;9&quot;&gt;For each input data set print the number of visible posters after all the posters are placed. &lt;p&gt;The picture below illustrates the case of the sample input. &lt;br/&gt;&lt;img src=&quot;http://poj.org/images/2528_1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p class=&quot;pst&quot;&gt;Sample Input&lt;/p&gt;
&lt;pre class=&quot;sio&quot;&gt;
1
5
1 4
2 6
8 10
3 4
7 10
&lt;/pre&gt;
&lt;p class=&quot;pst&quot;&gt;Sample Output&lt;/p&gt;
&lt;pre class=&quot;sio&quot; readability=&quot;6&quot;&gt;
4&lt;p&gt;这题注意要离散化就OK了 ，线段树离散化  ，&lt;br/&gt;但是要注意一个坑点 &lt;br/&gt;if (sum[i] - sum[i - 1] &amp;gt; 1) sum[m++] = sum[i - 1] + 1;&lt;br/&gt;要加一个点，避免区间不正确覆盖。&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = 2e4 + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tree[maxn &amp;lt;&amp;lt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;], a[maxn], b[maxn];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum[&lt;span&gt;3&lt;/span&gt; * maxn], vis[&lt;span&gt;3&lt;/span&gt; *&lt;span&gt; maxn], ans;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     memset(tree, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tree));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     memset(vis, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pushdown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rt) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     tree[rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;] = tree[rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; tree[rt];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     tree[rt] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; rt, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;=&lt;span&gt; y ) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         tree[rt] =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tree[rt] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) pushdown(rt);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; m = (l + r) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x &amp;lt;= m) updata(l, m, x, y, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, v);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (y &amp;gt; m ) updata(m + &lt;span&gt;1&lt;/span&gt;, r, x, y, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, v);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rt) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tree[rt] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;vis[tree[rt]]) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             vis[tree[rt]] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             ans++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (l == r) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; m = (l + r) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     query(l, m, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     query(m + &lt;span&gt;1&lt;/span&gt;, r, rt &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t, n;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        init();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tot = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;a[i], &amp;amp;&lt;span&gt;b[i]);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             sum[tot++] =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             sum[tot++] =&lt;span&gt; b[i];
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         sort(sum, sum +&lt;span&gt; tot);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = unique(sum, sum + tot) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt; ; i &amp;lt; t ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (sum[i] - sum[i - &lt;span&gt;1&lt;/span&gt;] &amp;gt; &lt;span&gt;1&lt;/span&gt;) sum[m++] = sum[i - &lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         sort(sum, sum +&lt;span&gt; m);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x = lower_bound(sum, sum + m, a[i]) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; y = lower_bound(sum, sum + m, b[i]) -&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             updata(&lt;span&gt;0&lt;/span&gt;, m - &lt;span&gt;1&lt;/span&gt;, x, y, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, i);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         query(&lt;span&gt;0&lt;/span&gt;, m - &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 18 May 2018 15:20:00 +0000</pubDate>
<dc:creator>弃疗大表哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qldabiaoge/p/9058416.html</dc:identifier>
</item>
<item>
<title>Scrapy爬虫框架第七讲【ITEM PIPELINE用法】 - 疾风_lu</title>
<link>http://www.cnblogs.com/518894-lu/p/9053939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/518894-lu/p/9053939.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;ITEM PIPELINE用法详解&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180514145258553-377347092.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ITEM PIPELINE作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;清理HTML数据&lt;/li&gt;
&lt;li&gt;验证爬取的数据(检查item包含某些字段)&lt;/li&gt;
&lt;li&gt;去重(并丢弃)【预防数据去重，真正去重是在url,即请求阶段做】&lt;/li&gt;
&lt;li&gt;将爬取结果保存到数据库中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518085704285-1301830639.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; ITEM PIPELINE核心方法（4个）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）、open_spider(spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）、close_spider(spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）、from_crawler(cls,crawler)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）、process_item(item,spider)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面小伙伴们我们依次来分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、open_spider(spider) 【参数spider 即被开启的Spider对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该方法非必需，在Spider开启时被调用，主要做一些初始化操作，如连接数据库等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、close_spider(spider)【参数spider 即被关闭的Spider对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该方法非必需，在Spider关闭时被调用，主要做一些如关闭数据库连接等收尾性质的工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、from_crawler(cls,crawler)【参数一：Class类 参数二：crawler对象】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;该方法非必需，Spider启用时调用，早于open_spider（）方法，是一个类方法，用@classmethod标识，它与__init__函有关，这里我们不详解（一般我们不对它进行修改）&lt;/p&gt;
&lt;p&gt;4、process_item(item,spider)【参数一：被处理的Item对象 参数二：生成该Item的Spider对象】&lt;/p&gt;
&lt;p&gt;该方法必需实现，定义的Item pipeline会默认调用该方法对Item进行处理，它返回Item类型的值或者抛出DropItem异常&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;实例分析（以下实例来自官网：https://doc.scrapy.org/en/latest/topics/item-pipeline.html）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scrapy.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DropItem
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PricePipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     vat_factor = 1.15
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price_excludes_vat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] *&lt;span&gt; self.vat_factor
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; DropItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Missing price in %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % item)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先定义了一个PricePipeline类&lt;/p&gt;
&lt;p&gt;定义了增值税税率因子为1.15&lt;/p&gt;
&lt;p&gt;主函数process_item方法实现了如下功能：判断Item中的price字段，如没计算增值税，则乘以1.15，并返回Item，否则直接抛弃&lt;/p&gt;
&lt;p&gt;总结：该方法要么return item给后边的管道处理，要么抛出异常&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 数据去重&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scrapy.exceptions &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DropItem
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DuplicatesPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.ids_seen =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.ids_seen:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; DropItem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Duplicate item found: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; item)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             self.ids_seen.add(item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先定义了一个DuplicatesPipeline类&lt;/p&gt;
&lt;p&gt;这里比上面多了一个初始化函数__init__，set()---去重函数&lt;/p&gt;
&lt;p&gt;主函数process_item方法首先判断item数据中的id是否重复，重复的就将其抛弃，否则就增加到id，然后传给下个管道&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 将数据写入文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JsonWriterPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.file = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;items.jl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        self.file.close()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         line = json.dumps(dict(item)) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        self.file.write(line)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先我们定义了一个JsonWritePipeline类&lt;/p&gt;
&lt;p&gt;定义了三个函数：&lt;/p&gt;
&lt;p&gt;first：open_spider（）在Spider开启时启用作用很简单即打开文件，准备写入数据&lt;/p&gt;
&lt;p&gt;second：close_spider()在Spider关闭时启用作用也很简单即关闭文件&lt;/p&gt;
&lt;p&gt;third(主要）：process_items()作用如下首先将item转换为字典类型，在用json.dumps()序列化为json字符串格式，再写入文件，最后返回修改的item给下一个管道&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;综合实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymongo
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MongoPipeline(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     collection_name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;scrapy_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, mongo_uri, mongo_db):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.mongo_uri =&lt;span&gt; mongo_uri
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.mongo_db =&lt;span&gt; mongo_db
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @classmethod
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; from_crawler(cls, crawler):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cls(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             mongo_uri=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_URI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             mongo_db=crawler.settings.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MONGO_DATABASE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self, spider):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.client =&lt;span&gt; pymongo.MongoClient(self.mongo_uri)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         self.db =&lt;span&gt; self.client[self.mongo_db]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self, spider):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        self.client.close()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        self.db[self.collection_name].insert(dict(item))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;首先我们定义了一个MongoPipeline类&lt;/p&gt;
&lt;p&gt;这里我们修改了初始化函数__init__，给出了存储到Mongodb的链接地址和数据库名称所以更改了from_crawler()工厂函数函数（生产它的对象），这里指定了链接地址和数据表名称&lt;/p&gt;
&lt;p&gt;最后我们定义了三个函数：&lt;/p&gt;
&lt;p&gt;first:open_spider（）在Spider开启时启用作用是打开mongodb数据库&lt;/p&gt;
&lt;p&gt;second:close_spider()在Spider关闭时启用作用是关闭数据库&lt;/p&gt;
&lt;p&gt;third：process_items()作用如下在数据库中插入item&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;项目实战：&lt;/span&gt;（我们以58同城镇江房屋出租为例）抓取出租信息的标题、价格、详情页的url&lt;/p&gt;
&lt;p&gt;我是在ubuntu16.04环境下跑的&lt;/p&gt;
&lt;p&gt;启动终端并激活虚拟环境：source course_python3.5/bin/activate&lt;/p&gt;
&lt;p&gt;创建一个新目录project：mkdir project&lt;/p&gt;
&lt;p&gt;创建项目：scrapy startproject city58-----cd city58----创建爬虫（这里小伙伴们注意项目名不能与爬虫名重名）scrapy genspider city58_test&lt;/p&gt;
&lt;p&gt;下面我们正式开始&lt;/p&gt;
&lt;p&gt;（1）、修改items.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225113747-1608841659.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）修改city58_test.py文件（这里我们使用pyquery选择器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225240919-730922761.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、重点来了，修改pipelines.py文件，小伙伴们可参考上面的案例分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225433628-1931444650.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）最后通过settings.py启动pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518225544110-1030751486.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里向小伙伴们科普一个小知识点：后面的数字是优先级，数字越小，越优先执行&lt;/p&gt;
&lt;p&gt;（5）项目运行结果(部分)----下次小伙伴们想了解出租信息可以找我，我帮你秒下。哈哈！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324415/201805/1324415-20180518230230137-574999808.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且我们可以在同级目录下找到我们写入的文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、首先了解了管道的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、掌握了核心的方法，其中特别是process_item()方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、最后我们通过实例和项目进行实战，后面我们会继续学习如何使用管道进行高级的操作，敬请期待，记得最后一定要在配置文件中开启Spider中间件&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 15:04:00 +0000</pubDate>
<dc:creator>疾风_lu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/518894-lu/p/9053939.html</dc:identifier>
</item>
<item>
<title>Python +selenium自动化环境的搭建 - 疯了的小蜗</title>
<link>http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</guid>
<description>&lt;p&gt;                        Python +selenium+googledriver&lt;/p&gt;
&lt;p&gt;小白的血泪安装使，不停的总结写心得是理解透彻的毕竟之路&lt;/p&gt;
&lt;p&gt;一，python的安装：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先去Python的官网下载安装包：https://www.python.org/&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224520851-1880938557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、下载完成后如下图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224531132-530004149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、双击exe文件进行安装，如下图，并按照圈中区域进行设置，切记要勾选打钩的框，然后再点击Customize installation进入到下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224545187-885410726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224600928-586789100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、对于上图中，可以通过Browse进行自定义安装路径，也可以直接点击Install进行安装，点击install后便可以完成安装了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224611156-775763655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.配置环境变量：在path中配置当前，你Python.exe程序的安装路径，注意：只要这个程序的安装路径，不要把这个文件的名字也填上，用半角分号隔开。&lt;/p&gt;
&lt;p&gt;如果后期要使用pip的话，也需要把pip.exe的安装路径配到path中也就是说你最少要配置两次，pip用着比较方便&lt;/p&gt;
&lt;p&gt;6、为了检查我们的python是否安装成功，可以在命令窗口中输入python进行查询，如显示下图一的信息则表示成功了，如显示第二张图的信息则表示出错了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224636323-1331028824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224649259-2032293135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;二，接下来安装pycharm&lt;/p&gt;
&lt;p&gt;1、首先从网站下载pycharm：&lt;a href=&quot;http://www.jetbrains.com/pycharm/download/#section=windows&quot; target=&quot;_blank&quot;&gt;点击打开链接&lt;/a&gt;（链接为：http://www.jetbrains.com/pycharm/download/#section=windows），进入之后如下图，根据自己电脑的操作系统进行选择，对于windows系统选择图中红色圈中的区域。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224700401-1327848736.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;485&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、下载完成之后如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224734960-787743548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、直接双击下载好的exe文件进行安装，安装截图如下：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224749327-1812838869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Next进入下一步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224756627-966383519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Next进入下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224803747-650371214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击Install进行安装：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224811572-73233130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;安装完成后出现下图界面，点级Finish结束安装：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224818603-113563685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我们来创建自己的第一个程序：&lt;/p&gt;
&lt;p&gt;1、单击桌面上的pycharm图标，进入到pycharm中，如下图所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224826571-1069486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、我们选择第二个，然后点击Ok：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224833688-2058219732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、点击上图中的Accept进入下一步：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224846367-2120970046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、点击上图中的ok进入下一步：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224852583-803981762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、点击Create New Project，进入如下图的界面，图中的Location是选择你安装的python的位置，选择好后，点击create。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224905000-1804123428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、在进入的界面如下图，鼠标右击图中箭头指向的地方，然后最后选择python file，在弹出的框中填写文件名（任意填写）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224922974-1488923341.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、文件创建成功后便进入如下的界面，便可以编写自己的程序了，当然如果你对这个界面不满意的话，可以自己设置背景，这里我就不详细说明了（自行百度即可）。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518224939433-2091864403.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意：要有破解版的：&lt;/p&gt;
&lt;p&gt;由于最新jetbrains发布了IntelliJ IDEA 15. PyCharm 5.PhpStorm10.WebStorm 11等各个版本，但是改变了注册方法。原先的注册码包括注册机都已经不能使用了。&lt;/p&gt;
&lt;p&gt;现在有个比较简单的注册方法.注册时选择“License server”输入“http://15.idea.lanyus.com/”点击“OK”即可快速激活JetBrains系列产品&lt;/p&gt;
&lt;p&gt;使用最新的更新路径：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://idea.lanyus.com/&quot;&gt;http://idea.lanyus.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;二，        安装request模块，和webdriver&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看Python的安装路径下面 F:\Python\Scripts 有没有pip.exe&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225047568-1790081807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225102343-812742884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;注：pip是安装管理工具，如果pip版本太低，可使用上面的命令对pip升级，如果没有pip则需要安装pip，或者直接用外部下载包安装。&lt;/p&gt;
&lt;p&gt;可以使用：F:\Python\Scripts&amp;gt;&lt;strong&gt;easy_install.exe pip（更新pip）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装selenium：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（1）   使用cmd命令窗口，切换到你Python的安装路径下面，F:\Python\Scripts的pip程序路径下。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（2）   输入：pip install -U selenium&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（3）   检查selenium是否安装好，在IDE中import selenium，没报错就是导好了&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;三，        安装谷歌的驱动：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载与你当前版本匹配的谷歌驱动:一定要与当前版本匹配的&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;如果不匹配的可能出现这个错：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225424473-709858702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;放到你谷歌的安装路径下面：C:\Program Files (x86)\Google\Chrome\Application&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这样基本上就可以了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在环境变量中配置这个驱动程序的路径。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;（环境变量时系统其自动调用启动一些程序的寻找路径。）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;四：会出现这样的提示：去掉这个提示&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225434584-487954405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装这个：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225451184-17672110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          2．或者配置一下&lt;/p&gt;
&lt;p&gt;还有可能报这个错：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401386/201805/1401386-20180518225502260-620273196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;是谷歌驱动和浏览器不匹配&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 14:56:00 +0000</pubDate>
<dc:creator>疯了的小蜗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/insane-Mr-Li/p/9058348.html</dc:identifier>
</item>
<item>
<title>加密与安全传输 - 疯狂船长</title>
<link>http://www.cnblogs.com/L-dongf/p/9047846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9047846.html</guid>
<description>&lt;h3&gt;1、对称加密&lt;/h3&gt;
&lt;p&gt;概念：加密和解密使用同一个秘钥&lt;/p&gt;
&lt;p&gt;算法：DES、3DES、AES、Blowfish、Twofish、IDEA、RC6、CAST5等&lt;/p&gt;
&lt;p&gt;优点：效率高；将数据分割成固定大小的块，逐个进行加密&lt;/p&gt;
&lt;p&gt;缺点：每一个通信就需要一个秘钥；秘钥传递不安全；无法确定数据来源&lt;/p&gt;
&lt;h3&gt;2、非对称加密&lt;/h3&gt;
&lt;p&gt;公钥与私钥：公钥是公开给所有人的；私钥是只有自己知道；通过私钥可以推算出公钥，但是通过私钥无法退出公钥；使用公钥加密必须使用私钥解密，或者使用私钥加密必须使用公钥解密；公私钥必须成对出现&lt;/p&gt;
&lt;p&gt;算法：RSA、DSA、ELGamal&lt;/p&gt;
&lt;p&gt;优缺点：可以实现数字签名来验证数据来源；可以安全的交换对称秘钥；可以实现时间加密，但是对应大的数据解密时效率太低，适合加密少量数据&lt;/p&gt;
&lt;h3&gt;3、单向散列（hash）&lt;/h3&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;p&gt;1）雪崩效应：数据不同，摘要一定大不同&lt;/p&gt;
&lt;p&gt;2）单向：不可反推数据&lt;/p&gt;
&lt;p&gt;3）摘要长度固定大小&lt;/p&gt;
&lt;p&gt;算法：md5:128、sha1:160、sha224、sha256、sha384、sha512&lt;/p&gt;
&lt;p&gt;功能：用来验证数据的完整性&lt;/p&gt;
&lt;h3&gt;4、秘钥交换算法（DH）&lt;/h3&gt;
&lt;p&gt;1）A和B协商生成公开的整数a,大素数p&lt;/p&gt;
&lt;p&gt;2）A:生成隐私数据 :x(x&amp;lt;p),计算得出 a^x%p，发送给B；B:生成隐私数据 :y(y&amp;lt;p),计算得出 a^y%p，发送给A&lt;/p&gt;
&lt;p&gt;3）A:计算得出 [(a^y%p)^x] %p = a^xy%p，生成为密钥；B:计算得出 [(a^x%p)^y] %p = a^xy%p，生成为密钥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180516203001017-1135631294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、在安全通信过程中：&lt;/h3&gt;
&lt;p&gt;爱丽丝：&lt;/p&gt;
&lt;p&gt;1）原数据通过hash算法得出一个摘要；&lt;/p&gt;
&lt;p&gt;2）用爱丽丝的私钥加密摘要；&lt;/p&gt;
&lt;p&gt;3）将加密的摘要和原数据一块使用对称秘钥加密；&lt;/p&gt;
&lt;p&gt;4）再用鲍勃的公钥将对称秘钥加密；&lt;/p&gt;
&lt;p&gt;5）密文数据发送————&amp;gt;&lt;/p&gt;
&lt;p&gt;鲍勃：&lt;/p&gt;
&lt;p&gt;1）&amp;lt;————接受密文数据；&lt;/p&gt;
&lt;p&gt;2）使用鲍勃的私钥解密对称秘钥；&lt;/p&gt;
&lt;p&gt;3）使用对称秘钥解密原数据和加密后的摘要；&lt;/p&gt;
&lt;p&gt;4）使用爱丽丝的公钥解密摘要；&lt;/p&gt;
&lt;p&gt;5）计算原数据的hash摘要并和解密后的摘要进行比较，从而确定原始数据的完整性。&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en&quot;&gt;&lt;strong&gt;TLS&lt;/strong&gt;：&lt;/span&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;Transport Layer Security及其前身安全套接层&lt;span lang=&quot;en&quot;&gt;&lt;span lang=&quot;en&quot;&gt;SSL&lt;/span&gt;是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;特性：可以保证数据传输的机密性、完整性，可实现认证，重放保护（重放：由中间人捕获到加密的数据再次传输到目的服务器，有可能会影响账户的安全）等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS协议&lt;/strong&gt;分俩个阶段：&lt;strong&gt;握手阶段(协商阶段)&lt;/strong&gt;：客户端和服务器端认证对方身份（依赖于PKI体系，利用数字证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。后续通信使用的所有密钥都是通过MasterSecret生成。&lt;strong&gt;应用阶段&lt;/strong&gt;：在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180518203034747-2090943804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身份认证可选）、密钥交换&lt;/li&gt;
&lt;li&gt;ChangeCipherSpec 协议：一条消息表明握手协议已经完成&lt;/li&gt;
&lt;li&gt;Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，&lt;/li&gt;
&lt;li&gt;atal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告&lt;/li&gt;
&lt;li&gt;Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等&lt;/li&gt;
&lt;li&gt;HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合。HTTP over SSL”或“HTTP over TLS”，对http协议的文本数据进行加密处理后，成为二进制形式传输&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数字证书认证机构（Certificate Authority，缩写为CA）&lt;/strong&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;，也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PKI&lt;/strong&gt;：公开密钥基础建设，包括签证机构（CA）、注册机构（RA）、证书吊销列表（CRL）以及证书存取库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X.509&lt;/strong&gt;：定义了证书的结构以及认证协议标准，包括版本号、序列号、签名算法、颁发者、有效期限、主体名称、主体公钥、CRL分发点、扩展信息、发行者签名等信息&lt;/p&gt;
&lt;p&gt;ca证书颁发机构分根ca和子ca，根ca的证书为自签证书，然后再为子ca颁发证书；用户只要信任了根ca的证书则就是信任了子ca颁发的证书。&lt;/p&gt;
&lt;p&gt;相关配置文件：&lt;strong&gt;/etc/pki/tls/openssl.cnf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
####################################################################
[ ca ]
default_ca      = CA_default            #默认CA，在一台服务器可以搭建多个CA
[ CA_default ]　　　　　　　　　　　　　　　 #默认CA的配置
dir             = /etc/pki/CA           #工作目录
certs           = $dir/certs            #存放证书
crl_dir         = $dir/crl              #存放证书吊销列表
database        = $dir/index.txt        #数据库索引文件，需要手动创建
new_certs_dir   = $dir/newcerts         #新证书的路径
certificate     = $dir/cacert.pem       #CA的证书文件
serial          = $dir/serial           #下一个要颁发的证书序列号，16进制
crlnumber       = $dir/crlnumber        #下一个要吊销的证书序列号
crl             = $dir/crl.pem          #证书吊销列表
private_key     = $dir/private/cakey.pem#CA的私钥文件
RANDFILE        = $dir/private/.rand    #生成私钥需要用到的随机数文件&lt;br/&gt;default_days    = 365                   #默认颁发证书的有效期
default_crl_days= 30                    #30天发布一次证书吊销列表
default_md      = sha256                #
preserve        = no                    #
policy          = policy_match　　　　　　#策略匹配，定义客户端和服务端申请证书时的信息匹配策略

[ policy_match ]
countryName             = match　　　　　 #必须匹配
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional   　　#不要求必须匹配
commonName              = supplied  　　 #必须提供
emailAddress            = optional
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;示例：搭建一个私有CA&lt;/h2&gt;
&lt;p&gt;服务端搭建：&lt;/p&gt;
&lt;p&gt;1、生成CA的私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 066; openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、生成自签证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
# openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -out /etc/pki/CA/cacert.pem -days 3650
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:beijing
Locality Name (eg, city) [Default City]:beijing
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:it
Common Name (eg, your name or your server's hostname) []:ca.test.com 
Email Address []:
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-new: 生成新证书签署请求&lt;/li&gt;
&lt;li&gt;-x509: 专用于CA生成自签证书&lt;/li&gt;
&lt;li&gt;-key: 生成请求时用到的私钥文件&lt;/li&gt;
&lt;li&gt;-days n：证书的有效期限&lt;/li&gt;
&lt;li&gt;-out /PATH/TO/SOMECERTFILE: 证书的保存路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、创建必要的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# touch /etc/pki/CA/index.txt
# echo 01 &amp;gt;/etc/pki/CA/serial
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl x509 -in /etc/pki/CA/cacert.pem -noout -text [-subject | -issuer | -dates]  查看证书信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端生成注册申请请求：&lt;/p&gt;
&lt;p&gt;1、生成私钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 077; openssl genrsa -out app.key 1024)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、生成签署请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
# openssl req -new -key app.key -out app.csr
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:beijing
Locality Name (eg, city) [Default City]:beijing
Organization Name (eg, company) [Default Company Ltd]:test
Organizational Unit Name (eg, section) []:it
Common Name (eg, your name or your server's hostname) []:app.test.com
Email Address []:
A challenge password []:
An optional company name []:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、将签署请求发送给CA&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# scp app.csr 192.168.0.7:/etc/pki/CA/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端签署：&lt;/p&gt;
&lt;p&gt;1、签署请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# openssl ca -in /etc/pki/CA/app.csr -out /etc/pki/CA/certs/app.crt -days 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、将签署后的证书发回客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# scp /etc/pki/CA/certs/app.crt 192.168.0.6:/root
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CA吊销证书的管理&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
生成吊销列表
[root@centos7 CA]# &lt;strong&gt;echo 01 &amp;gt;/etc/pki/CA/crlnumber&lt;/strong&gt;
[root@centos7 CA]# &lt;strong&gt;openssl ca -gencrl -out crl.pem&lt;/strong&gt;

查看吊销列表
[root@centos7 CA]# openssl &lt;strong&gt;crl&lt;/strong&gt; -in crl.pem -noout -text

查看证书状态
[root@centos7 CA]# cat index.txt
V（正常证书）       180826054533Z           01      unknown /C=CN/ST=BJ/O=test/OU=it/CN=www.test.com
[root@centos7 CA]# openssl &lt;strong&gt;ca&lt;/strong&gt; -status 01
Using configuration from /etc/pki/tls/openssl.cnf
01=Valid (V)（正常证书）

吊销证书
[root@centos7 CA]# openssl &lt;strong&gt;ca&lt;/strong&gt; -revoke newcerts/01.pem 
[root@centos7 CA]# cat index.txt
R  （已被吊销）     180826054533Z   180518060712Z   01      unknown /C=CN/ST=BJ/O=test/OU=it/CN=www.test.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;md5sum&lt;/strong&gt;、sha1sum、sha224sum、sha256sum 、sha384sum 、sha512sum：计算散列值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--check：检查md5值是否正确&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;gpg：&lt;/strong&gt;GunPG&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c file：加密文件&lt;/li&gt;
&lt;li&gt;-o file -d file.gpg：解密文件&lt;/li&gt;
&lt;li&gt;--gen-key：生成非对称秘钥&lt;/li&gt;
&lt;li&gt;--list-keys：查看已有公钥&lt;/li&gt;
&lt;li&gt;-e -r keyname file：使用指定公钥加密文件&lt;/li&gt;
&lt;li&gt;--import filename.pubkey：导入公钥&lt;/li&gt;
&lt;li&gt;-a --export -o filename.pubkey：导出公钥&lt;/li&gt;
&lt;li&gt;--delete-secret-keys keyname：删除私钥&lt;/li&gt;
&lt;li&gt;--delete-keys keyname：删除公钥&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# rngd -r /dev/urandom  #提供随机数来生成秘钥
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;openssl&lt;/span&gt;：&lt;/strong&gt;多用途的工具集&lt;/p&gt;
&lt;p&gt;组件：&lt;/p&gt;
&lt;p&gt;openssl: 多用途的命令行工具，包openssl&lt;/p&gt;
&lt;p&gt;libcrypto: 加密算法库，包openssl-libs&lt;/p&gt;
&lt;p&gt;libssl：加密模块应用库，实现了ssl及tls，包nss&lt;/p&gt;
&lt;p&gt;子命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;enc&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl enc -e -des3 -a -salt -in testfile -out testfile.cipher  使用-des3加密算法对称加密testfile文件&lt;br/&gt;# openssl enc -d -des3 -a -salt -in testfile.cipher -out testfile  解密
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-e 加密&lt;/li&gt;
&lt;li&gt;-d 解密&lt;/li&gt;
&lt;li&gt;-des3 | -des | -des 加密算法&lt;/li&gt;
&lt;li&gt;-a 表示使用base64编码&lt;/li&gt;
&lt;li&gt;编码：base64 === a-z A-Z 0-9 / + 64个字符&lt;/li&gt;
&lt;li&gt;-salt 加盐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;dgst &lt;/strong&gt; -md5 | -hex  单向加密&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;passwd&lt;/strong&gt; -1 -salt  生成MD5加密密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rand&lt;/strong&gt; -base64 | -hex # 生成随机数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;genrsa：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# (umask 066; openssl genrsa -out test.key -des 2048)  生成私钥并且使用des加密
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;rsa：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# openssl rsa -in test.key -out test2.key  将加密的私钥解密
# openssl rsa -in test2.key -pubout -out test2.key.pub  从私钥中提取对应的公钥
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;个人学习笔记  记录于22:16&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 14:19:00 +0000</pubDate>
<dc:creator>疯狂船长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9047846.html</dc:identifier>
</item>
<item>
<title>论文阅读 | CrystalBall: A Visual Analytic System for Future Event Discovery and Analysis from Social Media Data - basasuya</title>
<link>http://www.cnblogs.com/Basasuya/p/9058033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Basasuya/p/9058033.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://wesslen.github.io/assets/documents/papers/crystalball.pdf&quot;&gt;论文地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;abstract&quot;&gt;1 Abstract&lt;/h3&gt;
&lt;p&gt;这是一个可以预测未来一段时间内所发生事情的可视化系统，使用的是twitter数据进行分析。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210239589-570290288.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;introduction&quot;&gt;2 Introduction&lt;/h3&gt;
&lt;p&gt;识别一个未来的事件并不可以依靠消息量的突增来判断(一般一个很大的事件的到来会引发交际圈的热烈讨论)，一个未来时间的发生并不一定可以激发消息量的增加。&lt;strong&gt;识别未来事件的挑战在于筛选大量社交媒体数据，并识别埋在关于过去和正在进行的事件，个人状态更新等的压倒性信息中的小信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者看来，未来事件的定义是&quot;与将来的位置和日期/时间(跨度)相关联的事件。 这种情况的特点是地点和时间，通常与特定主题和社交网络相关联。&quot; &lt;strong&gt;位置和时间&lt;/strong&gt;是定义未来事件的主要属性&lt;/p&gt;
&lt;p&gt;通过这个系统。我们既可以发现各种未来事件，也可以对特定的时间地点进行重点调查。&lt;/p&gt;
&lt;h3 id=&quot;related-work&quot;&gt;3 Related Work&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;未来事件提取&lt;/strong&gt;和&lt;strong&gt;可视化交互&lt;/strong&gt;是两个主要的方面&lt;/p&gt;
&lt;h3 id=&quot;system-overview-and-pipeline&quot;&gt;4 System overview and pipeline&lt;/h3&gt;
&lt;p&gt;CrystalBall集成了多个组件，包括来自Twitter Streaming API ，实体提取，未来事件标识 和排名以及交互式可视化界面。 所有的数据收集和分析都是在线进行的。接口每天刷新以显示未来几天或几周内可能发生的事件的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210355869-2123267321.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;crystalball-future-event-identifiction-and-characterization&quot;&gt;5 CrystalBall: future event identifiction and characterization&lt;/h3&gt;
&lt;h3 id=&quot;如何处理数据&quot;&gt;(如何处理数据)&lt;/h3&gt;
&lt;p&gt;因为未来数据在所有的数据占比小，怎么提取是个问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NPMI&lt;/strong&gt;得到了位置和时间之间的相关性，相比PMI，将其正则化到1和-1之间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210745961-1759979717.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面所说到的NPMI，还有一些其他特征，这些其他属性包括&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接和比例&lt;/strong&gt;，我们衡量包含链接的推文与所有与可能的未来事件相关的推文的比例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题标签比例&lt;/strong&gt;。同样，我们测量与一个可能的未来事件相关的推文的标签比率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户可信&lt;/strong&gt;度，我们选择一个简单的度量，即Twitter追随者朋友（TFF）比率来表示用户的可信度。TFF是追随者与朋友的比率。 1.0到2.0之间的比率表示用户具有平衡的跟随/跟随者关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户多样性&lt;/strong&gt;，如果关于一个潜在的未来事件的所有推文都来自一个账户，那么这些推文很可能来自被编程为定期发送某些推文的机器人。&lt;/p&gt;
&lt;p&gt;除此之外有些信息并不包括完整的信息，比方说纽约在4.3会有一场音乐会，但是推文里只会提到“我将在4月3日访问我在纽约的朋友”，其实可能是和朋友一起看音乐会。所以我们可以设计一些关于相似推文的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心性&lt;/strong&gt;。高度连接的推特网络将具有接近1的程度中心性，而分散的推特网络产生接近于0的中心性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推特相似性&lt;/strong&gt;。&lt;a href=&quot;mailto:但是并不是所有推文都有@和转发相关联&quot;&gt;但是并不是所有推文都有@和转发相关联&lt;/a&gt;。所以我们还计算了每篇推文的相似性&lt;/p&gt;
&lt;p&gt;我们已经提出了确定可能的未来事件（NPMI）的措施，以及六个额外措施来描述事件的特征。下一步是结合这些措施来评估已确定的未来事件的质量。我们希望对事件进行排名，以便CrystalBall首先直观地表示高质量的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们使用RankSVM进行排序&lt;/strong&gt;。为了训练RankSVM，我们开发了一个标签数据集，其中包含三天内提取的未来事件（约1000个事件）。我们为表2列出的事件定义了5个类别。标注决定表明我们重视地缘政治和基层性质的事件。&lt;br/&gt;五位编码者独立完成了1000次提取的未来事件，并使用上述分类对事件进行了排名。然后，我们使用标记的数据集来训练RankSVM，并开发了一个可应用于无标签事件排序的模型。在CrystalBall可视化界面中，事件列表视图中每天显示的事件顺序（如图3所示）反映了RankSVM的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210813615-2053857173.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;crystalball-visual-interface可视化分析&quot;&gt;5 CrystalBall: Visual Interface（可视化分析）&lt;/h3&gt;
&lt;h4 id=&quot;按时间检索&quot;&gt;按时间检索&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;日期纵览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们从整个时间轴进行查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518210948650-1796043157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是未来事件的总揽，首先每行该日期所发生的事件，实线连接的是有相同的地点的事件。虚线连接的是具有同样的关键词的事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211003472-1896412935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个事件都有自己的颜色，颜色代表整个事件的感情属性，而颜色的深浅表达了置信度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单个日期查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211018189-2069819953.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以查看一天的信息&lt;/p&gt;
&lt;p&gt;A图，花瓣的红色占比代表了这个指标的大小，中间的数字是该日共有几个未来事件。&lt;/p&gt;
&lt;p&gt;B图中，1表是每个时刻的时间数，2表是近30天内将会发生的相似事件，3表是按照感情属性分类的结果。&lt;/p&gt;
&lt;p&gt;C图中，未来事件中的关键词。&lt;/p&gt;
&lt;p&gt;D按钮可以用来收藏&lt;/p&gt;
&lt;h4 id=&quot;按地点检索&quot;&gt;按地点检索&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211037367-849716895.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A图中可以放缩不同尺寸的地点，中间的数字表示的是事件数，不同深浅表达了在不同时间点内的事件。&lt;/p&gt;
&lt;p&gt;B图中当我们点击华盛顿图表，就会跳出所有事件的映像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211052861-1582459437.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图词云显示的是当前区域当中过的关键词&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211109679-1560156204.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图这种模式下，每个节点代表一个事件，节点之间的链接表示两个事件共享相同的位置和时间。节点中的数字表示事件的推文数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211126255-1334777293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图每个点是一个用户，颜色代表了TTF比例，越深代表跟随者越多。聚集在一起表示同样的时间地点。点击这个区域，所有这块有的词语都会被标红&lt;/p&gt;
&lt;p&gt;可视化系统的互动方式有 按照 &lt;strong&gt;时间，地点，关键词，类型&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;case-study&quot;&gt;7 Case Study&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211147887-492845910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211206532-1574055028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面介绍了一件北卡罗来纳州夏洛特市2016年9月抗议活动有关的一周活动。图1中的实现代表了三个有同样的地点的事物，分析这个时间线，可以发现这个时间线中有很多关于抗议的关键词。关注9.24一天，可以发现很多人的情绪都转变为恐慌，愤怒。与此同时一个有趣的现象就是大家的视线都转向了trump的一篇推文(最右边的一张图)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211218017-531694867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该系统还可以搜索潜在的用户。用户通过关键词(爱国的欧洲人反对西方的伊斯兰化)搜索，可以非常详细的认识一个活动的开始，组织，和最后收到大家的报道。&lt;/p&gt;
&lt;h3 id=&quot;validation-studies&quot;&gt;8 Validation studies&lt;/h3&gt;
&lt;p&gt;我们希望通过我们的系统预测于&lt;strong&gt;2011年9月17日在纽约市开始的占领运动&lt;/strong&gt;。CrystalBall分析了大约123,000条推文，其中根据我们的初步数据分析，只有120条推文包含标签“占据”。但是CrystalBall可以找到这些蛛丝马迹。下图显示了这个寻找的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211238003-372164027.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着事件的组织，CrystalBall可以识别早期信号。用户从事件日历视图开始，发现了一系列的选举后事件。在确定了多个大型全球地点（例如印度，英国，加拿大，伦敦，以色列）后，她发现跨越多个日期的“华盛顿”。选择那个地点后，她在就职典礼日（1月20日）之前发现了多个未成年人事件。描述未来事件的关键词包括“million womenmarch”，“washton”，“1月”等。查看与这些事件有关的推文显示3月份的&lt;strong&gt;妇女组织活动&lt;/strong&gt;在选举后不久发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201805/1324872-20180518211250045-1316185010.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;limitation&quot;&gt;9 Limitation&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用 时间-地点 组合进行编码，比较局限。&lt;/li&gt;
&lt;li&gt;识别未来事件错误，关于过去事件的新闻头条的推文可能会被错误地视为未来事件，而且很多转发是在很多天之后才收到转发。&lt;/li&gt;
&lt;li&gt;时间位置的提取算法还是不准确&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;future-work&quot;&gt;10 Future Work&lt;/h3&gt;
&lt;p&gt;处理多个数据源的流量(fb, ins, wiki, google)，新的nlp算法&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 13:06:00 +0000</pubDate>
<dc:creator>basasuya</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Basasuya/p/9058033.html</dc:identifier>
</item>
<item>
<title>jenkins+gitlab自动化编译部署方案探索及服务端编译webpack实战 - 冒雨ing</title>
<link>http://www.cnblogs.com/saysmy/p/8806975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saysmy/p/8806975.html</guid>
<description>&lt;p&gt;之前我们的开发流程为在本地进行webpack打包编译，然后svn提交源代码和编译后的代码。同时每次提交前也会从svn更新源代码和编译后的代码。这样做有几个缺点：&lt;/p&gt;
&lt;p&gt;1. svn 更新和提交编译后的代码造成大量冲突文件&lt;/p&gt;
&lt;p&gt;2. 由于我们使用非覆盖式发布的命名方式，在经过小组多人多次优化提交测试之后，在整理需要发布的文件列表时，很容易遗漏一些文件&lt;/p&gt;
&lt;p&gt;3. 在涉及到多人开发同一功能时容易产生代码被覆盖、人工安排发布优先级、手动注释他人未上线代码等情况&lt;/p&gt;
&lt;p&gt;4. svn的分支开发繁琐不友好，加重工作量&lt;/p&gt;

&lt;p&gt;最不能容忍的是第一第二点，于是我们改成服务端打包编码，本地只提交和更新源代码，这样就会大大减少冲突。同时，利用jenkins自动把服务端打包编译后的代码部署到测试和线上环境，省去了手动整理待发布文件列表的麻烦，也避免了发布文件遗漏的情况。为了提高开发流程质量，科学友好的规范开发流程，我们选择gitlab作为新的代码仓库，通过分支管理和代码review来提高开发效率，减少发布错误。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;完成功能：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 代码仓库用gitlab托管，使用&lt;a href=&quot;https://mp.weixin.qq.com/s/0N3isbSZL4fM5HjZo1aafA?&quot; target=&quot;_blank&quot;&gt;AoneFlow&lt;/a&gt;分支管理模式（阿里命名的一种分支管理模式，借鉴于gitflow, githubflow和gitlabflow）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518145225490-1010569428.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 源代码合并到测试分支后，jenkins自动打包编译并将编译后的代码部署到测试环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 源代码合并到发布分支后，jenkins自动打包编译并将编译后的代码部署到线上环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 给Master稳定分支打版本tag，同时增加tag版本说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; 脚手架和代码分离，保留一个脚手架仓库，提供给各个环境编译。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518113725442-2079142424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;部署方案探索&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A. jenkins合并代码并编译，ssh发送编译后代码到测试环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点：发送代码量大，耗时严重&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B. jenkins合并代码并编译，编译结果提交到gitlab，ssh连接测试环境从gitlab更新代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点：编译后代码合并到gitlab冲突多，麻烦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C. jenkins合并代码，ssh连接测试环境更新gitlab代码，然后运行编译命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：速度快，冲突少&lt;/p&gt;

&lt;p&gt;综上，我们选择方案C进行部署代码。&lt;/p&gt;

&lt;p&gt;发布到线上，不能通过merge到release/prop发布分支后自动触发jenkins构建，因为我可能同时有多个feature分支需要一次性发布到线上，这个时候需要多个feature分支挨个合并到发布分支，然后才能执行构建操作。所以合并到发布分支和构建部署到线上应该分为两个独立部分，分别执行。 &lt;/p&gt;
&lt;p&gt;一图胜千言，结合我司的实际开发环境，目前整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518193357830-1357490349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 关于jenkins安装的方案网上有很多，可以另行查询。&lt;/p&gt;
&lt;h2&gt;1. 首先安装插件：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Gitlab Hook Plugin &lt;/li&gt;
&lt;li&gt;GitLab Plugin &lt;/li&gt;
&lt;li&gt;Publish Over SSH&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;系统管理--管理插件--可选插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518171027262-395950604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412121502769-1847214559.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 2. 新建job&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412120751881-835757453.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;649&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;3. 配置git源码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;点击新建的job，点击配置--源码管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518182315480-1659141267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt; Repository URL&lt;/span&gt; ： 填写git仓库地址&lt;/p&gt;

&lt;p&gt;点击add--jenkins &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192520009-1613972823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;选择 ssh username with private key (需要提前在jenkins服务器生成ssh keys)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;username:  root&lt;/li&gt;
&lt;li&gt;enter directly:  &lt;strong&gt;私钥&lt;/strong&gt;内容   或者 From a file on Jenkins master ： 私钥的存放路径比如/home/role/.ssh/id_rsa&lt;/li&gt;
&lt;li&gt;passphrase:  生成ssh keys时填的密码，如果当时没设置则不填&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果选择私钥内容，那就需要在gitlab上把你的公钥填到gitlab ssh keys:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192552473-830942288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;点击Credentials选择刚添加的证书，如果此时没有红字报错，证明设置成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412160327080-1599687083.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 4. 设置webhook&lt;/h2&gt;
&lt;p&gt;webhook按我的理解就是可以触发的一个接口，可以用它来在一定条件下触发某个任务。&lt;/p&gt;

&lt;p&gt;在job配置中找到如下选项：如果没有，则先安装&lt;a class=&quot;display-name&quot; href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin&quot; target=&quot;_blank&quot;&gt;Gitlab Hook Plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518154459425-214910359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;复制红框中的webhook url， 打开gitlab如下图在URL处填写webhook地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192721515-879718609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;add后点击test，如果提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412183115769-1109546162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则设置成功，jenkins成功触发！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;！！！注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gitlab的webhooks url 是根据jenkins构建权限连接设置的，如果必须登录才能构建就必须获取jenkins的用户名及token，可以在jenkins用户-设置里面查看到 ，url格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;lt;username&amp;gt;:&amp;lt;api-token&amp;gt;@&amp;lt;jenkins-server&amp;gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 如果不须登录就能构建就直接设置为 &lt;span class=&quot;cnblogs_code&quot;&gt;http&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jenkins-server/job/security_Usm/build?delay=0sec&lt;/span&gt;&lt;/span&gt;  ，security_Usm是job名称&lt;/p&gt;
&lt;p&gt;所以，如果你出现如下错误提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180412160803910-1141701927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Hook executed successfully but returned HTTP 403 &amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HTTP Status 403 – Forbidden&amp;lt;/title&amp;gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;h1 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:22px;} h2 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:16px;} h3 {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;font-size:14px;} body {font-family:Tahoma,Arial,sans-serif;color:black;background-color:white;} b {font-family:Tahoma,Arial,sans-serif;color:white;background-color:#525D76;} p {font-family:Tahoma,Arial,sans-serif;background:white;color:black;font-size:12px;} a {color:black;} a.name {color:black;} .line {height:1px;background-color:#525D76;border:none;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;HTTP Status 403 – Forbidden&amp;lt;/h1&amp;gt;&amp;lt;hr class=&quot;line&quot; /&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Type&amp;lt;/b&amp;gt; Status Report&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Message&amp;lt;/b&amp;gt; anonymous is missing the Job&amp;amp;#47;Build permission&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Description&amp;lt;/b&amp;gt; The server understood the request but refuses to authorize it.&amp;lt;/p&amp;gt;&amp;lt;hr class=&quot;line&quot; /&amp;gt;&amp;lt;h3&amp;gt;Apache Tomcat/8.5.24&amp;lt;/h3&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要更改你的gitlab中webhook地址为如下形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maoyu:89w3fseydf96934hy@10.95.10.10:8080/jenkins/project/front-end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5. ssh部署到服务器&lt;/h2&gt;
&lt;p&gt;全局配置ssh服务器：系统管理--系统设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180424143041909-756430802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180424143102331-501928417.png&quot; alt=&quot;&quot;/&gt;、&lt;/p&gt;
&lt;p&gt;配置好后点击Test，出现success即表示成功。&lt;/p&gt;

&lt;p&gt;然后配置具体的发布内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180425192742893-302455813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192812308-71319058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;source files: jenkins中工作空间下的路径&lt;/li&gt;
&lt;li&gt;remote directory: 是相对全局配置中Publish over SSH -- SSH server -- Remote Directory的路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; source files亦可不填，直接连接服务器后执行exec command.&lt;/p&gt;

&lt;h2&gt;6. 显示构建日志的时间&lt;/h2&gt;
&lt;p&gt;如果想在console output中显示如下的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518155542703-1415226265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置如下即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518155610548-234850233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 7. 自动合并Gitlab Merge Request&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你想在Merge request后使用jenkins自动合并代码，可以使用下面的方法，如果不需要这样，比如push到某个分支直接触发webhook则可以跳过此步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的目前构建方案中，在发布到测试环境时，两种都有，即既可以通过Merge Request触发自动合并然后构建，也可以手动合并后产生push事件触发webhook。但很可能之后会改成提交到对应分支后，自动触发webhook，jenkins合并到相应分支然后编译部署。看具体公司的使用习惯和一些规范吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用插件：Gitlab Merge Request Builder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此插件是通过设定分支，定时检查分支有没有收到Merge Request请求来决定是否进行构建。gitlab是个审核管理 ，当jenkins构建完成之后，gitlab便会合并分支。&lt;/p&gt;
&lt;p&gt; 配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518161435895-1849085408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想在gitlab pipeline成功之后自动执行merge操作，需要勾上下面的配置，可以说这是必须的，不然你就完不成自动合并：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518192958871-1303074149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;gitlab对应的合并界面有如下变化：&lt;/p&gt;

&lt;p&gt;初始界面如下，可以在右上角close 合并请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518162201032-1208559847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　在建立合并请求到合并成功，可能会出现如下的红叉提示Could not connect to the CI server. 不用管它，可以忽略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518161920407-1446019063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如果合并失败，界面提示如下，则需要去jenkins查看日志具体为什么合并失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180417113308368-1423955251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;或者你可能会看到如下的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180417115041425-309523046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;合并成功如下，在discussion中会有jenkins自动添加的一些comment：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518162532707-1271395282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Gitlab Merge Request Builder会触发gitlab的pipeline, 无需配置gitlab的CI/CD。&lt;/p&gt;
&lt;p&gt;如果在gitlab 的merge requests部分，Discussion没有Build Started，Build triggered, Build finished Test Passed.这些提示，说明Gitlab Merge Request Builder插件没有起作用，仔细检查配置Gitlab Project Path等是否正确，如果都正确可以尝试重启jenkins，重新发起merge request。&lt;/p&gt;
&lt;p&gt;如果在配置构建触发器下的 Gitlab Merge Request Builder，点击apply时报如下错误，则在系统管理--系统配置中检查Gitlab Merge Request Builder配置Jenkins Username和Jenkins API Token是否正确。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420114540153-1774064448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitlab merge冲突：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420170135222-132473544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击 &lt;strong&gt;解决冲突 &lt;/strong&gt;手动编辑解决冲突，保存即可重新触发merge request，然后自动合并&lt;/p&gt;

&lt;h2&gt;8. 参数化构建 &lt;/h2&gt;
&lt;p&gt;参数化构建即第一你需要手动点击构建按钮，第二你可以设置一些参数变量在构建中使用，比如开发环境，分支参数等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518163031244-1098192392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为什么需要参数化构建？我们目前项目比较简单，其实无需参数化构建，但在部署到线上后给master打tag时，遇到点麻烦，即不能给tag设置一些个性化的说明文案，这样找起tag单纯看版本号可能很难知道某个版本里面完成什么功能。所以我们在发布到线上时，增加了deploymsg即要发布功能的描述，用来作为tag的描述信息。&lt;/p&gt;
&lt;p&gt;参数化构建可以使用jenkins自带的参数化构建过程，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518163340618-365767472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参加参数中选择string parameter， 第一项名字即你要添加的变量名。&lt;/p&gt;
&lt;p&gt;设置好后保存，即完成了参数化构建的设置。&lt;/p&gt;
&lt;p&gt;第二种方法可以使用jenkins插件，jenkins有着几千款各种功能插件，非常丰富，基本我们想要的功能都会有插件支持。&lt;/p&gt;
&lt;p&gt;这里我们使用的插件是：Generic Webhook Trigger &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180416191252779-35098821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180416191337457-368435164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 按照以上配置即配置了一个ref变量。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180413111122867-71004681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;更简便的方法是&lt;a href=&quot;https://github.com/jenkinsci/gitlab-plugin&quot; target=&quot;_blank&quot;&gt;gitlab plugin&lt;/a&gt;提供的变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180413123205334-2120801064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以再shell中打印如下查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &quot;gitlabBranch: ${gitlabBranch}&quot;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;只需要对文件名命名不同的名字即可，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201805/979473-20180518170500683-1916966995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;p&gt;如以下表示每2分钟执行一次任务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180420154524134-930174934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;cron语法有五位，分别的意义是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MINUTES Minutes in one hour (0-59)&lt;/li&gt;
&lt;li&gt;HOURS Hours in one day (0-23)&lt;/li&gt;
&lt;li&gt;DAYMONTH Day in a month (1-31)&lt;/li&gt;
&lt;li&gt;MONTH Month in a year (1-12)&lt;/li&gt;
&lt;li&gt;DAYWEEK Day of the week (0-7) where 0 and 7 are sunday&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中每个字段除了可以使用取值范围内的值外，还能使用一些特殊的字符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*     匹配范围内所有值&lt;/li&gt;
&lt;li&gt;M-N   匹配M~N范围内所有值&lt;/li&gt;
&lt;li&gt;M-N/X 或者 */X   在指定M~N范围内或整个有效区间内每隔X构建一次 &lt;/li&gt;
&lt;li&gt;A,B,...,Z        匹配多个值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了在系统中生成定时任务，符号H（代表“Hash”，后面用“散列”代替）应该用在可能用到的地方，例如：为十几个日常任务配置0 0 * * *将会在午夜产生较大峰值。相比之下，配置H H * * * 仍将每天一次执行每个任务，不是都在同一时刻，可以更好的使用有限资源。&lt;/p&gt;
&lt;p&gt;符号H可用于范围，例如，H H(0-7) * * * 代表凌晨0:00到 上午7:59一段时间。你还可以用H代表有或无范围的区间。&lt;/p&gt;
&lt;p&gt;符号H 在一定范围内可被认为是一个随机值，但实际上它是任务名称的一个散列而不是随机函数。&lt;/p&gt;
&lt;p&gt;需要注意的是，月份中的某天-DOM字段，类似于*/3 或者 H/3 的短周期由于月份的天数不固定，在大多数月尾总不会工作。例如，*/3 将会在一个月里面的第一天、第四天。。。第31天执行，下个月的那天继续重复执行。散列一般被选择在1-28天内，所以H/3将会在跑到月底的3-6天内导致空白。（长时间循环将会导致长度不一，但是这种影响也是不明显的。）&lt;/p&gt;
&lt;p&gt;空行和以#开头的行将会被认为是注释。&lt;/p&gt;
&lt;p&gt;另外，@yearly, @annually, @monthly, @weekly, @daily, @midnight, 和 @hourly也支持别名。这些使用散列系统自动匹配，例如：@hourly 和 H * * * * 一样代表一个小时内的任何时刻。@midnight实际上代表凌晨0:00到凌晨2:59之间的一段时间。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每隔15分钟。(或许:07, :22, :37, :52)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H/15 * * * *&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每前半小时中每隔10分钟。 (3次, 或许:04, :14, :24)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H(0-29)/10 * * * *&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;# 每个工作日从早上9点45分开始到下午3点45分结束这段时间内每间隔2小时的45分钟那一刻。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;45 9-16/2 * * 1-5&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#每个工作日从早上9点到下午5点这段时间内每间隔2小时之间的某刻。(或许在上午10:38, 下午12:38, 下午2:38 , 下午4:38)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H H(9-16)/2 * * 1-5&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#每月（除了12月）从1号到15号这段时间内某刻。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;H H 1,15 1-11 *&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt;1、关闭Jenkins&lt;/h2&gt;
&lt;p&gt;     只需要在访问jenkins服务器的网址url地址后加上exit。例如我jenkins的地址http://localhost:8080/，那么我只需要在浏览器地址栏上敲下&lt;strong&gt;http://localhost:8080/exit&lt;/strong&gt; 网址就能关闭jenkins服务.&lt;/p&gt;
&lt;h2&gt;2、重启Jenkies&lt;/h2&gt;
&lt;p&gt;    http://localhost:8080/restart&lt;/p&gt;
&lt;h2&gt;3、重新加载配置信息&lt;/h2&gt;
&lt;p&gt;  &lt;strong&gt; &lt;/strong&gt; http://localhost:8080/reload&lt;/p&gt;
&lt;hr/&gt;

&lt;h3&gt;1. GitLab: The project you were looking for could not be found.&lt;/h3&gt;
&lt;p&gt;fatal: Could not read from remote repository.&lt;/p&gt;
&lt;p&gt;Please make sure you have the correct access rights&lt;br/&gt;and the repository exists.&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;查看git用户是否具有提交到gitlab仓库的权限&lt;/p&gt;

&lt;h3&gt; 2. &lt;code class=&quot;hljs livecodeserver has-numbering&quot;&gt;Could &lt;span class=&quot;hljs-operator&quot;&gt;not &lt;span class=&quot;hljs-built_in&quot;&gt;open &lt;span class=&quot;hljs-operator&quot;&gt;a connection &lt;span class=&quot;hljs-built_in&quot;&gt;to your authentication agent.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;需手动开启ssh，如下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 eval `ssh-agent -s`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行ssh-add 即可&lt;/p&gt;

&lt;h3&gt;3.  Exception when publishing, exception message [Exec timed out or was interrupted after 120,001 ms&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979473/201804/979473-20180427103632748-755462850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适当调大超时时间，比如调成300000&lt;/p&gt;

&lt;h3&gt;4. ssh_exchange_identification: Connection closed by remote host &lt;/h3&gt;
&lt;h4&gt;解决方法一. 把SSH连接数改大 &lt;/h4&gt;
&lt;p&gt;修改服务器上的这个文件：/etc/ssh/sshd_config 找到这行 &lt;span class=&quot;cnblogs_code&quot;&gt;# MaxSessions 10&lt;/span&gt;  ：&lt;/p&gt;
&lt;p&gt;去掉前面的&quot;#&quot; 并把数字改大，最后重启sshd service sshd restart 然后重新连接即可. &lt;/p&gt;
&lt;h4&gt;解决方法二.  每次正常退出SSH连接&lt;/h4&gt;
&lt;p&gt;每次执行完命令后用输入&quot;exit&quot; 退出, 防止连接数过多.&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;见github: &lt;a href=&quot;https://github.com/saysmy/svnsh&quot; target=&quot;_blank&quot;&gt;https://github.com/saysmy/svnsh&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 13:03:00 +0000</pubDate>
<dc:creator>冒雨ing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saysmy/p/8806975.html</dc:identifier>
</item>
<item>
<title>.Net中集合排序的一种高级玩法 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9058024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9058024.html</guid>
<description>&lt;p&gt;学生有名称、学号，&lt;/p&gt;
&lt;p&gt;班级有班级名称、班级序号&lt;/p&gt;
&lt;p&gt;学校有学校名称、学校编号（序号）&lt;/p&gt;



&lt;p&gt;现在需要对学生进行排序&lt;/p&gt;

&lt;p&gt;第一排序逻辑&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按学校编号（序号）排列&lt;/li&gt;
&lt;li&gt;再按班级序号排列&lt;/li&gt;
&lt;li&gt;再按学生学号排列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，在我们录入数据库信息的时候，有的人可能比较懒，没有录入 学校的序号， 班级的序号，学生的学号 ，怎么办？  那么就Plan B  !&lt;/p&gt;

&lt;p&gt;第二排序逻辑&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;按学校名称排列&lt;/li&gt;
&lt;li&gt;再按班级的名称排列&lt;/li&gt;
&lt;li&gt;再按学生名称排列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我编写了学校、班级、学生的实体关系代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Sort
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; School
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Class
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; School School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class Class { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以前写的简单排序，还可以用OrderBy解决，如果之前写过的一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;《.Net中集合排序还可以这么玩》&quot; href=&quot;http://www.cnblogs.com/CoderAyu/p/8858447.html&quot; target=&quot;_blank&quot;&gt;《.Net中集合排序还可以这么玩》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是这里的排序就比较复杂了，用简单的OrderBy恐怕是解决不了了。&lt;/p&gt;

&lt;p&gt;.Net中，对List集合，有一个Sort字方法，让我们选中Sort方法，F12,看看Sort方法长哪样？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201805/1293736-20180518201932927-1158364915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Sort方法一共有四个重载，我们挑最基础的一个，Sort()  0参数的这个，懂了这个，其他几个应该也会懂了，我们看看该方法的描述：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201805/1293736-20180518201944837-1346833979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然我英语不太好，但是这基础的英语还是能看懂，大致是说：&lt;/p&gt;

&lt;p&gt;用默认的比较器对该List进行排序。&lt;/p&gt;

&lt;p&gt;那么，这个Comparer(比较器)是什么呢？&lt;/p&gt;

&lt;p&gt;其实，它是接口IComparable下的一个方法，也就是说只有实现了ICoparable接口下的这个叫比较器的方法才能使用Sort进行排序，我们F12进入到IComparable来看看这个接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201805/1293736-20180518202023126-1484542523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该接口只有一个CompareTo方法，我用我蹩脚的英语大致看懂了这句话的意思是：&lt;/p&gt;

&lt;p&gt;定义一个比较方法来对制定类型进行排序。&lt;/p&gt;

&lt;p&gt;该方法返回类型为Int类型。通过查找查找相关资料，了解到其返回值与其含义如下：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;
&lt;p align=&quot;center&quot;&gt;值&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;412&quot;&gt;
&lt;p align=&quot;center&quot;&gt;含义&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;
&lt;p align=&quot;center&quot;&gt;复数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;412&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;该实例比传入的Other实例小。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;412&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;该实例与传入的Other实例相等。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;
&lt;p align=&quot;center&quot;&gt;正数&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;412&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;该实例比传入的Other实例大。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;知道了这个原则，我们就可以给Student类继承并实现该方法了。&lt;/p&gt;

&lt;p&gt;对文章开头的排序需求，我们重温一下：&lt;/p&gt;

&lt;p&gt;第一排序逻辑（Int?）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按学校编号（序号）排列&lt;/li&gt;
&lt;li&gt;再按班级序号排列&lt;/li&gt;
&lt;li&gt;再按学生学号排列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当序号为空时，用第二种排序逻辑，&lt;/p&gt;

&lt;p&gt;第二排序逻辑(String)&lt;/p&gt;

&lt;div&gt;
&lt;ol&gt;&lt;li&gt;按学校名称排列&lt;/li&gt;
&lt;li&gt;再按班级的名称排列&lt;/li&gt;
&lt;li&gt;再按学生名称排列&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;其实无非就是对Student中涉及到的Int?和string两种数据类型进行比较。&lt;/p&gt;

&lt;p&gt;Int?类型(Nullable)和string已经实现了Compare方法，其中Nullable的如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201805/1293736-20180518205927134-1933193569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是为了能更深入地理解该方法的使用，我自己来写一个Int?类型数据比较的方法，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareInit(&lt;span&gt;int&lt;/span&gt;? x, &lt;span&gt;int&lt;/span&gt;?&lt;span&gt; y)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; y == &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果都是空 那么返回0相等&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.HasValue &amp;amp;&amp;amp; y == &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入X有值，但是Y是空的，那么X比Y小 返回-1。&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; y.HasValue) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传入X为空，但是Y有值，那么X比Y大 返回1。&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.Value &amp;gt;&lt;span&gt; y.Value)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.Value &amp;lt;&lt;span&gt; y.Value)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则两个数相等&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;其中，为什么我认为有值的比Null的还小返回-1呢？ 因为我想把Null的往后排，把有值的往前排，其他流行的做法是认为有值的是比Null大的，即返回1，大家可以结合自己的业务需求选择。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;写好了Int?类型数据比较的方法，还有String类型数据的比较，我就不自己造轮子去写了，用现成的String.CompareOrdinal()方法。&lt;/p&gt;

&lt;p&gt;然后，我们开始给Student实现ICompare接口的CompareTo方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student : IComparable&amp;lt;Student&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class Class { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; CompareTo(Student other)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ReferenceEquals(&lt;span&gt;this&lt;/span&gt;, other)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果两个值的引用相同，那么直接返回相等。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ReferenceEquals(&lt;span&gt;null&lt;/span&gt;, other)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该实例是空的，但是传入的实例不是空的，那么返回1

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较学校的序号&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; compareResult = CompareInit(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Class.School.Order, other.Class.School.Order);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareResult != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; compareResult;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较班级的序号&lt;/span&gt;
            compareResult = CompareInit(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Class.Order, other.Class.Order);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareResult != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; compareResult;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较学生的学号&lt;/span&gt;
            compareResult = CompareInit(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Order, other.Order);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareResult != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; compareResult;
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果以上还未区分出大小，比较学校的名称&lt;/span&gt;
            compareResult = String.CompareOrdinal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Class.School.Name, other.Class.School.Name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareResult != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; compareResult;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较班级的名称&lt;/span&gt;
            compareResult = String.CompareOrdinal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Class.Name, other.Class.Name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareResult != &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; compareResult;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较学生的名称&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; String.CompareOrdinal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name, other.Name);

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现该方法后，就可以对List&amp;lt;Student&amp;gt; 使用Sort方法了，我们来试试看。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Sort
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; students =&lt;span&gt; InitData();

        &lt;strong&gt;&lt;span&gt;    students.Sort();  //此处执行了Sort方法&lt;/span&gt;&lt;/strong&gt;


            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name-Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; student &lt;span&gt;in&lt;/span&gt;&lt;span&gt; students)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学校:{student.Class.School.Name}-{student.Class.School.Order}&amp;gt;&amp;gt;班级:{student.Class.Name}-{student.Class.Order}&amp;gt;&amp;gt;学生:{student.Name}-{student.Order}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            Console.ReadLine();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; InitData() //创建数据
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; school1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; School()
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; school2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; School
            {
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Order &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; class1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                School &lt;/span&gt;=&lt;span&gt; school1,
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; class2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class
            {
                Order &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                School &lt;/span&gt;=&lt;span&gt; school1,
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; class3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                School &lt;/span&gt;=&lt;span&gt; school2,
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; student1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Class &lt;/span&gt;=&lt;span&gt; class1,
            };


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; student2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student
            {
                Order &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Class &lt;/span&gt;=&lt;span&gt; class1,
            };


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; student3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student
            {
                Order &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Class &lt;/span&gt;=&lt;span&gt; class1,
            };


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; student4 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Class &lt;/span&gt;=&lt;span&gt; class2,
            };


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; student5 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student
            {
                Order &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Class &lt;/span&gt;=&lt;span&gt; class3,
            };

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; { student5, student3, student4, student2, student1 };

        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201805/1293736-20180518204658393-44145722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，学校B虽然是以B开头，但是因为期Order为0比1更靠前，所以以Order为准，学校B排到了最前面。&lt;/p&gt;

&lt;p&gt;好几天没写了，写博客对我我而言，意义无非在于加深印象同时把我所掌握的东西分享给大家，这个方法是今天同事教我的，可能对园子里大神来说这比较基础，但是相信如果掌握这个方法，对以后也许中复杂排序会有比较有用，希望对大家也能有所帮助。&lt;/p&gt;
&lt;p&gt;项目的GitHub地址：&lt;/p&gt;
&lt;p&gt;https://github.com/liuzhenyulive/Sort&lt;/p&gt;

&lt;p&gt;如果大家有更好的办法，欢迎下下方留言与我交流。&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 13:03:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9058024.html</dc:identifier>
</item>
<item>
<title>多线程二（线程通信） - yumiaoxa</title>
<link>http://www.cnblogs.com/yumiaoxia/p/9057973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yumiaoxia/p/9057973.html</guid>
<description>&lt;h2&gt;一. 传统的线程通信&lt;/h2&gt;
&lt;p&gt;Object类提供了三个方法由同步监视器调用。分为两种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于使用synchronized修饰的同步方法，因为该类的默认实例（this)就是同步监视器，所以可以在同步方法中直接调用这三个方法。&lt;/li&gt;
&lt;li&gt;对于使用synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，所以必须使用该对象调用这三个方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于这三个方法的解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;wait()：导致当前线程等待，知道其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程，该wait()方法有两种形式：无时间参数的wait(一直等待，直到其他线程通知）；带时间参数的wait(等待指定时间后自动唤醒）。调用wait()方法的当前线程会释放对该同步监视器的锁定。&lt;/li&gt;
&lt;li&gt;notify()：唤醒此同步监视器上等待的单个线程。如果所有线程都在此同步监视器等待，则会任意唤醒其中一个线程。只有当前线程放弃对该同步监视器的锁定后（使用wait()方法），才可以执行被唤醒的线程。&lt;/li&gt;
&lt;li&gt;notifyAll()：唤醒此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后（使用wait()方法），才可以执行被唤醒的线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面程序示范了存钱，取钱的两个线程。存款者和取款者不断重复存款、取钱的操作，要求存款者将钱存入指定账户后，取钱者立即取出这笔钱。不允许存款者连续两次存款，不允许取钱者两次取钱。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.renentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识账户中是否有存款的旗标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Account(String accountNo, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为账户余额不允许修改，所以只提供getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag) {
                wait();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;取钱&quot;+&lt;span&gt;drawAmount);
                balance &lt;/span&gt;-=&lt;span&gt; drawAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot;+&lt;span&gt;balance);
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                notifyAll();
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException ie){
            ie.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; desposit(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果flag为真，表明账户中已有人存钱进去，存钱方法阻塞&lt;/span&gt;
&lt;span&gt;                wait();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;存款&quot; +&lt;span&gt; depositAmount);
                balance &lt;/span&gt;+=&lt;span&gt; depositAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                notifyAll();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.renentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DrawThread(String name,Account acount,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; acount;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.drawAmount =&lt;span&gt; drawAmount;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
            account.draw(drawAmount);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.renentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DepositThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DepositThread(String name,Account acount,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount){
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; acount;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.depositAmount =&lt;span&gt; depositAmount;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100; i++&lt;span&gt;) {
                account.desposit(depositAmount);
            }
        }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.renentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DrawTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Account account &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Account(&quot;1234567&quot;,0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DrawThread(&quot;取钱者&quot;,account,800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者甲&quot;,account,800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者乙&quot;,account,800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者丙&quot;,account,800&lt;span&gt;).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157286/201805/1157286-20180518182047180-2040578416.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果可以看出，程序最后被阻塞无法继续向下执行，这是因为3个取款者线程共有300次操作，而一个取款者只有100次取钱操作，所以程序最后被阻塞。&lt;/p&gt;
&lt;h2&gt;二. 使用Condition通信&lt;/h2&gt;
&lt;p&gt;当使用Lock对象来保证来保证同步时，Java提供了一个Condition类来保持协调，&lt;span&gt;使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象&lt;/span&gt;，Condition对象也可以唤醒其他处于等待的线程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Condition将同步监视器方法（wait()，notify()和notifyAll()）分解成截然不同的对象，以便通过将这些对象与Lock对象结合使用，为每个对象提供多个等待值（wait-set)。在这种情况下，Lock代替了同步方法或同步代码块，Condition替代了同步监视器的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Condition实例被绑定在一个Lock对象上。要获得特定Lock实例的Condition实例，调用Lock对象的newCondition()方法即可，Condition对象提供了如下三个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;await()：类似于隐式同步监视器的wait()方法，导致当前线程等待，直到其他线程调用该Condition的signal()方法或signalAll()方法来唤醒该线程。该await()方法有更多变体，如long awaitNanos(long nanosTimeout)、void awaitUninterruptibly()、awaitUntil(Date deadline)等，可以完成更丰富的等待操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;signal()：唤醒此Lock对象等待的单个线程。如果所有线程都在此Lock对象上等待，则会任意唤醒其中一个线程。只有当前线程放弃对该Lock对象的锁定后（使用await()方法），才可以执行被唤醒的线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;signalAll()：唤醒此Lock对象等待的单个线程。只有当前线程放弃对该Lock对象的锁定后（使用await()方法），才可以执行被唤醒的线程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面程序Account使用Lock对象来控制同步，并使用Condition对象来控制线程的协调运行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.Condition;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显式定义Lock对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得指定Lock对象的对应的Condition&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition cond=&lt;span&gt; lock.newCondition();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识账户中是否有存款的旗标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Account(String accountNo, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为账户余额不允许修改，所以只提供getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag) {
                cond.wait();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;取钱&quot;+&lt;span&gt;drawAmount);
                balance &lt;/span&gt;-=&lt;span&gt; drawAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot;+&lt;span&gt;balance);
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                cond.signalAll();
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException ie){
            ie.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; desposit(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果flag为真，表明账户中已有人存钱进去，存钱方法阻塞&lt;/span&gt;
&lt;span&gt;                cond.await();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;存款&quot; +&lt;span&gt; depositAmount);
                balance &lt;/span&gt;+=&lt;span&gt; depositAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                cond.signalAll();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e)
        {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
            lock.unlock();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该程序的其他类和执行效果完全跟上面一样。&lt;/p&gt;
&lt;p&gt;三. 使用阻塞队列（BlockingQueue)控制线程通信&lt;/p&gt;
&lt;p&gt;Java 5提供一个BlockingQueue接口，它是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程同步的工具。BlockingQueue有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已满，则该线程被阻塞。&lt;/p&gt;
&lt;p&gt;程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，则可很好的控制线程的通信。&lt;/p&gt;
&lt;p&gt;BlockingQueue提供如下两个支持阻塞的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;put(E e)：尝试把e元素放入BlockingQueue中，如果该队列的元素已满，则阻塞该线程。&lt;/li&gt;
&lt;li&gt;take()：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BlockingQueue继承了Queue接口，也可以使用Queue的方法，归纳为三类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在队列尾部插入元素。包括add(E e)、offer(E e)和put(E e)方法，当该队列以满时，这三个方法分别会抛出异常、返回法false、阻塞队列。&lt;/li&gt;
&lt;li&gt;在队列头部删除并返回删除的元素。包括remove()、poll()、和take()方法当该队已空时，这三个方法分别会抛出异常、返回法false、阻塞队列。&lt;/li&gt;
&lt;li&gt;在队列头部取出但不删除元素。包括element()和peek()方法，当队列已空时，这两个方法分别抛出异常、返回false。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应关系如下：&lt;/p&gt;
&lt;table border=&quot;1.5&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot;&gt;&lt;caption&gt;BlockingQueue包含的方法之间的对应关系&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;抛出异常&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不同返回值&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;阻塞线程&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;指定头时时长&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;队尾插入元素&lt;/td&gt;
&lt;td&gt;add(E e)&lt;/td&gt;
&lt;td&gt;offer(E e)&lt;/td&gt;
&lt;td&gt;put(E e)&lt;/td&gt;
&lt;td&gt;offer(e,time,unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;队头删除元素&lt;/td&gt;
&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;poll(time,unit)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;获取、不删除元素&lt;/td&gt;
&lt;td&gt;element()&lt;/td&gt;
&lt;td&gt;peek()&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;BlockingQueue有5个实现类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayBlockingQueue：基于数组实现的BlockingQueue队列&lt;/li&gt;
&lt;li&gt;LinkkedBlockingQueue：基于链表实现的BlockingQueue队列&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：并不是标准的阻塞队列，该队列调用方法取出元素时，是取出队列中最小的元素，可使用Comparator定制排序。&lt;/li&gt;
&lt;li&gt;SynchronousQueue：同步队列。对该队列的存取操作必须交替执行。&lt;/li&gt;
&lt;li&gt;DelayQueue：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现。不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long getDelay()方法），DelayQueue根据集合元素的getDelay()方法的返回值进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面以ArrayBlockingQueue为例介绍阻塞队列的功能和用法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.thread.blockingqueue;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ArrayBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.BlockingQueue;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Producer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Producer(BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bq =&lt;span&gt; bq;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        String[] strArr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;java&quot;,&quot;Struts&quot;,&quot;Spring&quot;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 99 i++&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;生产者准备生产集合元素！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试放入元素，如果队列已满，则线程被阻塞&lt;/span&gt;
                bq.put(strArr[i%3&lt;span&gt;]);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName()&lt;/span&gt;+&quot;生产完成：&quot;+&lt;span&gt;bq);
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Consummer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Consummer(BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bq =&lt;span&gt; bq;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;消费者准备消费集合元素！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
                bq.take();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName()&lt;/span&gt;+&quot;消费完成：&quot;+&lt;span&gt;bq);
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlockingqueueTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        BlockingQueue&lt;/span&gt;&amp;lt;String&amp;gt; bq = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动三个生产者线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动一个消费者线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consummer(bq).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157286/201805/1157286-20180518204330271-1008233119.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，只要一个线程向该队列放入元素，其他生产者线程就必须等待，等待消费者线程取出队列里的元素&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 12:48:00 +0000</pubDate>
<dc:creator>yumiaoxa</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yumiaoxia/p/9057973.html</dc:identifier>
</item>
<item>
<title>基于Emit实现的C#版本的BeanCopier - 华然</title>
<link>http://www.cnblogs.com/Huaran1chendu/p/9057925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Huaran1chendu/p/9057925.html</guid>
<description>&lt;p&gt;在java的技术栈当中，著名的Cglib库里面有一个BeanCopier,这个类的功能就是可以完成两个对象的属性复制工作（哪怕属于两个不同的类）.&lt;/p&gt;
&lt;p&gt;今天本人通过.net内置的System.Reflection.Emit命名空间写了一个.net版本的BeanCopier，实现原理是基于Emit来直接操作中间代码，从而动态生成实现，类似于一个动态代理。&lt;/p&gt;
&lt;p&gt;Nuget安装依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Install-Package BeanCopier -Version 2.1.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BeanCopier.Core;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; BeanCopier.Emit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleApp1
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过工程方法得到一个BeanCopier&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; beanCopier = EmitBeanCopierFactory.Instance.Create&amp;lt;User, UserInfo&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 源属性对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()
            {
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                Age &lt;/span&gt;= &lt;span&gt;12&lt;/span&gt;&lt;span&gt;,
                Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;****&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标属性对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; userInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用动态生成的copy方法&lt;/span&gt;
&lt;span&gt;            beanCopier.Copy(user, userInfo);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用一个自定义的转换器，将自动被回调&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; selfConverter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SelfConverter();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用自定义转换&lt;/span&gt;
&lt;span&gt;            beanCopier.Copy(user,userInfo, selfConverter);

            Console.ReadLine();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SelfConverter : BeanConverter&amp;lt;User, UserInfo&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserInfo Convert(User souce, UserInfo target)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Int32 Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Byte Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Int32 Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Byte Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该工具的限制条件是：&lt;br/&gt;1.源类和目标类均必须为public类型&lt;/p&gt;
&lt;p&gt;2.源类的属性需要具备public类型的get访问器&lt;/p&gt;
&lt;p&gt;3.目标类的属性需要具备public类型的set访问器&lt;/p&gt;
&lt;p&gt;4.自定义的转换器需要为public类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;源码地址：https://github.com/FanHuaRan/dotnetbeancopier&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;欢迎大家一起来完善这个工具，有问题可以发邮件与我联系：834171100@qq.com&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 12:33:00 +0000</pubDate>
<dc:creator>华然</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Huaran1chendu/p/9057925.html</dc:identifier>
</item>
<item>
<title>Java  学习路线之四个阶段 - 听~雨</title>
<link>http://www.cnblogs.com/hanwen1014/p/9057881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanwen1014/p/9057881.html</guid>
<description>&lt;p&gt;写这篇总结，主要是记录下自己的学习经历，算是自己对知识的一个回顾。也给想要学习 Java 的提供一些参考，对于一些想要学习Java，又不知道从哪里下手，以及现在有哪些主流的 Java 技术。想必大家学习一门技术，前期都很想看到一些结果或成就，这样就比较容易激励自己学习下去，最好的办法就是实践，实践，实践！先说明一下我的情况，我是从大二才开始接触 Java，然后自己摸索，期间真是摸打滚爬过来的。选的是计算机专业，大一的时候还没有自己的笔记本，所以都是听课过来的，了解了一些概念性的东西，课上老师也有演示过一些程序，懂得思考之后，发现计算机有很多有趣的地方，比如想知道这个东西是如何实现的，为什么会出现这些东西。真不是知道当初天天打游戏的时候，为什么没有发现，要是发现的话，现在说不定早就那啥那啥了。到了大二的时候自己有了笔记本之后，就开始自己摸索，很好奇自己当初拿到笔记本竟然没有去打游戏，而是用来学习。下面开始说正事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开始学习的时候，经过自己搜索之后，发现有很多种语言，自己完全处于懵逼状态，不知道选哪个，也不知道每种语言都可以用来干什么，后来经过学长的指点还有身边的人都说 Java 好，自己慢慢的就入坑了。在选择要学习一门语言的时候，一定要选自己感兴趣的，而且要有自己的目标，不然的话，后期很难坚持下来，除非你有很强的自律性。每个人前进都是有自己的驱动力，所以找到属于自己的驱动力，才能保证你不断的进步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java第一阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚接触 Java 的时候，想必大家都是从环境配置开始的，这个里面的坑想必大家都踩过。对于还没有开始的同学，也有可能会经历这个阶段，说可能是因为现在的 Java1.6 之后安装默认是加到环境变量里面的，但是在安装过程中有可能会出现一些意外情况，导致不能加入成功，这是就需要我们手动加入了。在这里特说明下，在大学期间一定要把一些基础的课程学好，比如：计算机系统、算法、编译原理等，这个对后期的学习会有很大的影响，最简单的就是你在添加环境变量的时候，为什么要把路径添加到 Path 下面，而不是添加到其它下面，计算机是如何去识别访问这些东西。&lt;/p&gt;

&lt;p&gt;我一开始学习 Java 的时候，是学长分享的视频，这个视频的好处就是在学习 Java 基础的时候，完全脱离一些集成的工具，就是用编辑器（notepad++）写好程序，手动通过命令行去编译，再执行，让你能够了解其中的原理，以及锻炼自己的动手能力。如果一上来就上你用 Eclipse 或者其它工具，把一些底层的东西屏蔽掉，开始学习的时候大家可能连 class 文件都没有见过，只是知道写了这行代码，运行之后它会出来什么结果。&lt;/p&gt;

&lt;p&gt;这里给出我当初学习的视频，有点老但是基础知识都是一样的。学习 Java 基础知识的时候，应该多动手，多思考，很多时候，你想当然的事情，等你写出来运行一下，你就会发现不是这么一回事，不信你就试试。在学习视频的时候，有两种学习方法建议：方法一先把视频过一篇，在看视频的时候，记下知识点，看完视频之后，自己对着知识点，自己敲代码实现，实在想不出来的，回过头来在看视频。方法二边看视频边跟着敲代码，这样会比第一种方法相对容易一些，但是如果是这种方法学习的话，要记得回头多复习，不然很容易忘记。两种方法各有好处，第一种方法一开始学习比较慢，但是后面基础有了之后，就会上手很快，而且记得很牢固。第二种方法比第一种方法花的时间要相对的少一些，所以需要我们反复的去回顾。学习完以上内容之后，你应该对 Java 有了一定的了解，你可以使用 Java 语言写出来一些简单的程序，并且是使用最简单的编辑器。这个时候，可以不用着急进入下个阶段，给自己一两天的时间，对学习过的知识进行下总结。&lt;/p&gt;

&lt;p&gt;在学习的过程中，你应该注重下面这些知识点，由于是自己总结的，有可能会有不对的地方，若有不对之处，还请指出。&lt;/p&gt;

&lt;p&gt;知识点梳理：&lt;/p&gt;
&lt;p&gt;概念：面向对象的三大基本特征五大基本原则（当初让学长考我的时候第一个问的就是这个）、面向对象、面向过程、什么是多态、什么是继承、什么是封装。&lt;/p&gt;
&lt;p&gt;集合：Collection 集合、List 集合、Set 集合、Map 集合&lt;/p&gt;
&lt;p&gt;异常：Java 中异常处理机制和应用，自定义异常&lt;/p&gt;
&lt;p&gt;IO：File 类，字符流、字节流、转换流、缓冲流、递归&lt;/p&gt;
&lt;p&gt;网络编程：Socket&lt;/p&gt;
&lt;p&gt;线程：线程的生命周期，Java 线程池，线程同步问题，线程死锁问题&lt;/p&gt;
&lt;p&gt;继承和接口：Class，Interface&lt;/p&gt;
&lt;p&gt;反射：动态代理&lt;/p&gt;
&lt;p&gt;Mysql 和 JDBC 开发：Mysql 数据库，JDBC，DBUtils，DBCP连接池&lt;/p&gt;
&lt;p&gt;书籍推荐：Head First Java, Java核心技术&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;视频获取：后台回复「javaweb学习资料」包含后面三个阶段。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 第二阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 基础学习完之后，我是开始学习 Javaweb，在一开始的几天比较迷茫，因为感觉自己写的东西没有用处，比如写个计算器什么的，生活中没有什么用，可能是太过于看结果导致的。这个时候应该去做一些有趣的事情，学习新的知识，开发新的大陆，这就是我们的 Web 开发了，主要包括前端页面（HTML/CSS/JS），Servlet/JSP，以及 Mysql 相关的知识。这些视频在上面分享的视频里面已经包括了。&lt;/p&gt;

&lt;p&gt;关于页面，这些内容对于 Java 后端来说，不是特别重要，但是你应该尽自己的最大能力让它漂亮，最起码可以入眼，这样的话，页面就不是什么问题了。接下来，就是学习的重头戏了，学习 Servlet/JSP 部分，这也是 Java 后端开发必须非常精通的部分，在学习 Web 这三部分的时候，这个部分是最花时间的。这个阶段学习的时候，要学会使用开发工具，比如 Eclipse 或者 IDEA 来学习。最后一部分，你就要学会使用数据库，Mysql 数据库是不错的入门选择，而且 Java 领域主流的关系型数据就是 Mysql，这部分其实你在学习 JDBC 的时候，就会接触到，因为 JDBC 也是属于数据库的一部分。不仅要学会使用 JDBC 操纵数据库，而且还要学会使用数据库客户端工具，比如 sqlyog，navicat 等。&lt;/p&gt;

&lt;p&gt;知识点梳理：&lt;/p&gt;
&lt;p&gt;前端技术：HTML、CSS、JS、JQuery、Bootstrap&lt;/p&gt;
&lt;p&gt;JavaWeb 核心内容：Servlet、JSP、XML、HTTP、Ajax、过滤器、拦截器等&lt;/p&gt;
&lt;p&gt;Mysql 和 JDBC：复习&lt;/p&gt;
&lt;p&gt;推荐书籍：相关的 Web 书籍都可以，可以顺带着看 Java 编程思想&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 第三阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个阶段是在你掌握第二阶段之后开始，如果学习了第二个阶段之后想找工作的话，还需要在学习一些主流的框架知识。目前比较主流的框架是 SSM 框架，既 Spring，SpringMVC，Mybatis。要学会这些框架的搭建，以及用它们作出一个简单的 WEB 项目，包括增删改查的功能。在这里一开始，你可以不用太去关心那些配置文件，以及为什么会这样配置，这个可以留到后面慢慢了解，开始的时候先让自己有个体验，激励自己学习的动力。&lt;/p&gt;

&lt;p&gt;搭建这三个框架的时候，一定要记录自己搭建的过程，这个在你工作之后肯定会用到的。在搭建的过程，我们通过网上查找资料或是跟着视频学习，都会接触到 Maven 这个工具，这个工具在你工作之后，也一定会用到的，可以顺带着了解，你不一定要去完全掌握，只要学会使用，知道基本原理就可以。学会使用之后，自己要跟着老师或者从网上去理解更多的东西，比如那些配置文件等。&lt;/p&gt;

&lt;p&gt;知识点梳理：&lt;/p&gt;
&lt;p&gt;Spring 框架：配置文件、IoC 思想、DI 依赖注入、面向切面编程、事务等。&lt;/p&gt;
&lt;p&gt;SpringMVC：框架原理、交互、拦截器等。&lt;/p&gt;
&lt;p&gt;Maven：安装使用、基本操作。&lt;/p&gt;
&lt;p&gt;Mybatis：框架原理、Mybatis 开发 DAO 方式、与其它框架的整合。&lt;/p&gt;

&lt;p&gt;推荐书籍：Spring 实战，Effective Java，Java 编程思想&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java 第四阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个时候相信你已经能够完成独立开发，并且也工作了，对付工作上面的时候，你的技术一定是可以的。但是这个时候不要对自己进行松懈，你要继续学习，而不是工作只是为了应对工作，你应该提升自己的价值。这个时候可以去看一些比较底层的书籍，比如《深入理解Java虚拟机》，这本书就是全面帮助你了解 Java 虚拟机，这个时候想必你一定知道 Java 是运行在 JVM 上的，你没有任何理由不去了解 JVM。另外，关于并发这方面，推荐《Java并发编程实战》，这本书啃完之后，对并发的理解应该有一定的体会了。&lt;/p&gt;

&lt;p&gt;这个阶段要做的远不止这些，我们要去思考我们之前使用的那些框架是怎么回事，以及阅读 Java 经典的一些源码，看懂源码的前提，就是你已经有了一定的基础，当然有基础也不一定一下子就能看懂，看不懂就要去思考，在看源码的过程中，你可能有各种各样的疑问，有疑问就是对的，问自己最多的应该是这里问什么会这样写，而不是那样写吧。这个阶段需要自己对自己有很强的自律去学习，不要看了一半就放弃了。学会看源码之后，自己可以尝试着模仿别人写的比较好的开源项目，造属于自己的轮子，虽说不一定有用，但是对提升自己有一定的好处。&lt;/p&gt;

&lt;p&gt;如果你想成为优秀的人，你就要「能别人不能」，也就是说你要找到属于自己的一个领域研究下去，以期在将来，你能够成为这个领域的专家，建立起你的差异性。&lt;/p&gt;

&lt;p&gt;最后，请记住，从你入行那一刻起，你就要比别人努力，就要不停的学习。每个人在学习的过程中都有自己的一种方式，在学习的过程中，要学会自己去判断。其实生活中也是一样的，你身边的人形形色色，有的人你喜欢，有的人你讨厌，但是你喜欢的人身上也有缺点，你讨厌的人身上也有其优点，这个时候你要学会从他们身上学习他们的优点，让自己变的更优秀。&lt;/p&gt;


&lt;p&gt;PS：如果觉得文章不错的话，还请大家点赞分享下，算是对我的最大支持。&lt;/p&gt;







&lt;p&gt;一条迷途的咸鱼，&lt;/p&gt;
&lt;p&gt;总有一天会游向属于它的天地！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806341/201805/806341-20180518201510883-396225159.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 May 2018 12:17:00 +0000</pubDate>
<dc:creator>听~雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hanwen1014/p/9057881.html</dc:identifier>
</item>
</channel>
</rss>