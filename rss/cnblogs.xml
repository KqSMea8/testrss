<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程之ThreadLocal内存泄漏探究 - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9311308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9311308.html</guid>
<description>&lt;p&gt;&lt;strong&gt;使用 ThreadLocal 不当可能会导致内存泄露，是什么原因导致的内存泄漏呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先看一个例子，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/14.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalOutOfMemoryTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LocalVariable {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Long[] a = &lt;span&gt;new&lt;/span&gt; Long[&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (1)&lt;/span&gt;
    final &lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor poolExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(6, 6, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, TimeUnit.MINUTES,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2)&lt;/span&gt;
    final &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (3)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; ++&lt;span&gt;i) {
            poolExecutor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (4)&lt;/span&gt;
                    localVariable.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LocalVariable());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (5)&lt;/span&gt;
                    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;use local varaible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    localVariable.remove();&lt;/span&gt;
&lt;span&gt;
                }
            });

            Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (6)&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pool execute over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（1）创建了一个核心线程数和最大线程数为 6 的线程池，这个保证了线程池里面随时都有 6 个线程在运行。&lt;/p&gt;
&lt;p&gt;代码（2）创建了一个 ThreadLocal 的变量，泛型参数为 LocalVariable，LocalVariable 内部是一个 Long 数组。&lt;/p&gt;
&lt;p&gt;代码（3）向线程池里面放入 50 个任务。&lt;/p&gt;
&lt;p&gt;代码（4）设置当前线程的 localVariable 变量，也就是把 new 的 LocalVariable 变量放入当前线程的 threadLocals 变量。&lt;/p&gt;
&lt;p&gt;由于没有调用线程池的 shutdown 或者 shutdownNow 方法所以线程池里面的用户线程不会退出，进而 JVM 进程也不会退出。&lt;/p&gt;

&lt;p&gt;运行后，我们立即打开jconsole 监控堆内存变化，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714222827452-1022712833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，让我们打开 localVariable.remove() 注释，然后在运行，观察堆内存变化如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714223105351-233334858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从第一次运行结果可知，当主线程处于休眠时候进程占用了大概 75M 内存，打开 localVariable.remove() 注释后第二次运行则占用了大概 25M 内存，可知 没有写 localVariable.remove() 时候内存发生了泄露，下面分析下泄露的原因，如下：&lt;/p&gt;
&lt;p&gt;第一次运行的代码，在设置线程的 localVariable 变量后没有调用&lt;code&gt;localVariable.remove()&lt;/code&gt; 方法，导致线程池里面的 5 个线程的 threadLocals 变量里面的&lt;code&gt;new LocalVariable()&lt;/code&gt;实例没有被释放，虽然线程池里面的任务执行完毕了，但是线程池里面的 5 个线程会一直存在直到 JVM 退出。这里需要注意的是由于 localVariable 被声明了 static，虽然线程的 ThreadLocalMap 里面是对 localVariable 的弱引用，localVariable 也不会被回收。运行结果二的代码由于线程在设置 localVariable 变量后即使调用了&lt;code&gt;localVariable.remove()&lt;/code&gt;方法进行了清理，所以不会存在内存泄露。&lt;/p&gt;

&lt;p&gt;接下来我们要想清楚的知道内存泄漏的根本原因，那么我们就要进入源码去看了。&lt;/p&gt;
&lt;p&gt;我们知道ThreadLocal 只是一个工具类，具体存放变量的是在线程的 threadLocals 变量里面，threadLocals 是一个 ThreadLocalMap 类型的，我们首先一览ThreadLocalMap的类图结构，类图结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714224007079-1026057888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图 ThreadLocalMap 内部是一个 Entry 数组, Entry 继承自 WeakReference，Entry 内部的 value 用来存放通过 ThreadLocal 的 set 方法传递的值，那么 ThreadLocal 对象本身存放到哪里了吗?&lt;/p&gt;
&lt;p&gt;下面看看 Entry 的构造函数，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Entry(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; k, Object v) {
    super(k);
    value &lt;/span&gt;=&lt;span&gt; v;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再接着看Entry的父类WeakReference的构造函数super（k），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeakReference(T referent) {
   super(referent);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再看WeakReference的父类Reference的构造函数super（referent），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Reference(T referent) {
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(referent, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再看WeakReference的父类Reference的另外一个构造函数this（referent , null），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Reference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt;&lt;span&gt; queue) {
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.referent =&lt;span&gt; referent;
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.queue = (queue == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; ReferenceQueue.NULL : queue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知 k 被传递到了 WeakReference 的构造函数里面，也就是说 ThreadLocalMap 里面的 key 为 ThreadLocal 对象的弱引用，具体是 referent 变量引用了 ThreadLocal 对象，value 为具体调用 ThreadLocal 的 set 方法传递的值。&lt;/p&gt;
&lt;p&gt;当一个线程调用 ThreadLocal 的 set 方法设置变量时候，当前线程的 ThreadLocalMap 里面就会存放一个记录，这个记录的 key 为 ThreadLocal 的引用，value 则为设置的值。&lt;/p&gt;
&lt;p&gt;但是考虑如果这个 ThreadLocal 变量没有了其他强依赖，而当前线程还存在的情况下，由于线程的 ThreadLocalMap 里面的 key 是弱依赖，则当前线程的 ThreadLocalMap 里面的 ThreadLocal 变量的弱引用会被在 gc 的时候回收，但是对应 value 还是会造成内存泄露，这时候 ThreadLocalMap 里面就会存在 key 为 null 但是 value 不为 null 的 entry 项。&lt;/p&gt;
&lt;p&gt;其实在 ThreadLocal 的 set 和 get 和 remove 方法里面有一些时机是会对这些 key 为 null 的 entry 进行清理的，但是这些清理不是必须发生的，下面简单讲解ThreadLocalMap 的 remove 方法的清理过程，remove 的源码，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; key) {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)计算当前ThreadLocal变量所在table数组位置，尝试使用快速定位方法&lt;/span&gt;
  Entry[] tab =&lt;span&gt; table;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)这里使用循环是防止快速定位失效后，变量table数组&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i]; e != &lt;span&gt;null&lt;/span&gt;; e = tab[i =&lt;span&gt; nextIndex(i, len)]) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(3)找到&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (e.&lt;span&gt;get&lt;/span&gt;() ==&lt;span&gt; key) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(4)找到则调用WeakReference的clear方法清除对ThreadLocal的弱引用&lt;/span&gt;
&lt;span&gt;          e.clear();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(5)清理key为null的元素&lt;/span&gt;
&lt;span&gt;          expungeStaleEntry(i);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
   }
}
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expungeStaleEntry(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; staleSlot) {
            Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6）去掉去value的引用&lt;/span&gt;
            tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            tab[staleSlot] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            size&lt;/span&gt;--&lt;span&gt;;&lt;br/&gt;Entry e;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = nextIndex(staleSlot, len); (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;; i =&lt;span&gt; nextIndex(i, len)) {
                ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k = e.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(7)如果key为null,则去掉对value的引用。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    e.value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    size&lt;/span&gt;--&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h !=&lt;span&gt; i) {
                        tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            h &lt;/span&gt;=&lt;span&gt; nextIndex(h, len);
                        tab[h] &lt;/span&gt;=&lt;span&gt; e;
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（4）调用了 Entry 的 clear 方法，实际调用的是父类 WeakReference 的 clear 方法，作用是去掉对 ThreadLocal 的弱引用。&lt;/p&gt;
&lt;p&gt;代码（6）是去掉对 value 的引用，到这里当前线程里面的当前 ThreadLocal 对象的信息被清理完毕了。&lt;/p&gt;
&lt;p&gt;代码（7）从当前元素的下标开始看 table 数组里面的其他元素是否有 key 为 null 的，有则清理。循环退出的条件是遇到 table 里面有 null 的元素。所以这里知道 null 元素后面的 Entry 里面 key 为 null 的元素不会被清理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.ThreadLocalMap 内部 Entry 中 key 使用的是对 ThreadLocal 对象的弱引用，这为避免内存泄露是一个进步，因为如果是强引用，那么即使其他地方没有对 ThreadLocal 对象的引用，ThreadLocalMap 中的 ThreadLocal 对象还是不会被回收，而如果是弱引用则这时候 ThreadLocal 引用是会被回收掉的。&lt;/p&gt;
&lt;p&gt;　　2.但是对于的 value 还是不能被回收，这时候 ThreadLocalMap 里面就会存在 key 为 null 但是 value 不为 null 的 entry 项，虽然 ThreadLocalMap 提供了 set,get,remove 方法在一些时机下会对这些 Entry 项进行清理，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露，所以在使用完毕后即使调用 remove 方法才是解决内存泄露的最好办法。&lt;/p&gt;
&lt;p&gt;　　3.线程池里面设置了 ThreadLocal 变量一定要记得及时清理，因为线程池里面的核心线程是一直存在的，如果不清理，那么线程池的核心线程的 threadLocals 变量一直会持有 ThreadLocal 变量。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 15:21:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9311308.html</dc:identifier>
</item>
<item>
<title>javaScript设计模式之面向对象编程（object-oriented programming，OOP）(一) - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9297286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9297286.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
面试的时候，总会被问到，你对javascript面向对象的理解？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程（object-oriented programming，OOP）是一种程序设计范型。它讲&lt;span&gt;对象&lt;/span&gt;作为程序的设计&lt;span&gt;基本单元&lt;span&gt;，讲程序和数据封装其中，以提高程序的重用性、灵活性和扩展性。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、举个例子&lt;/p&gt;
&lt;p&gt;有这么一个需求：做一个验证表单功能，仅需要验证用户名，邮箱，密码等&lt;/p&gt;
&lt;p&gt;觉得在项目产品开发中，自己是这么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkName(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkEmail(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkPassword(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;声明了3个全局变量，&lt;/p&gt;
&lt;p&gt;下面是创建3个函数保存在变量里来实现你的功能，而你写的是将你的变量名放在function后边，也代表了你的变量，所以声明了3个全局变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建了3个函数保存在变量里&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; checkName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码邮箱&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; checkPassword = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从功能上讲没有任何问题，但是如果别人也定义了同样的方法就会覆盖原有的功能，这种相互覆盖的问题不易觉察到。&lt;/p&gt;
&lt;p&gt;我们可以将这些检查函数放在一个变量里保存，这样减少覆盖和被覆盖的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）用对象收编变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象，他有属性和方法，我们访问属性或者方法，可以通过&lt;span&gt;&lt;strong&gt;点语法&lt;/strong&gt;&lt;/span&gt;向下遍历查询得到，我们可以&lt;strong&gt;创建一个检测对象，我们把方法放在里面。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们将所有的函数作为CheckObject对象的方法，这样我们就只有一个对象，比如检测姓名CheckObject.checkName().&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)对象的另一种形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先声明一个对象，然后给他添加方法&lt;/strong&gt;，在JavaScript中函数也是对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
CheckObject.checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
CheckObject.checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是当别人想用你写的对象方法就比较麻烦，因为这个对象不能复制一份（这个&lt;strong&gt;对象类&lt;/strong&gt;在用new关键字创建新的对象时，新创建的对象时不能继承这些方法）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）真假对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想简单的复制一下，你可以将这些方法放在一个函数对象中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验姓名&lt;/span&gt;
&lt;span&gt;        }，
        checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验邮箱&lt;/span&gt;
&lt;span&gt;        }
        checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验密码&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当每次调用这个函数的时候，把我们之前的对象返回出来，当别人每次调用这个函数时都会&lt;strong&gt;返回新对象&lt;/strong&gt;。这样我们每个人使用的时候就不会相互影响，比如检测邮箱可以这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; CheckObject();
a.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（4）类也可以&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然通过创建新对象完成需求，但是他不是一个真正的意义上的类的创建方式，并且创建对象a和对象CheckObject没有任何关系，返回的对象与CheckObject对象无关，稍微优化一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkPassword = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这样的对象，就可以看成是类，我们就可以不需要使用&lt;strong&gt;创建对象方法&lt;/strong&gt;创建，既然是一个类，就用关键词new来创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以用CheckObject类创建出来对象，我们其他人就可以对&lt;strong&gt;类实例化（用类创建对象）&lt;/strong&gt;，这样每一个人都有一套自己的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）一个检测类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过this的定义，每一次通过new关键字创建新对象时候，新创建的对象都会对类的this上的属性进行复制，所以新创建的对象都会有自己的一套方法，然而有时候造成消耗很奢侈，我们需要处理一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype.checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
CheckObject.prototype.checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
CheckObject.prototype.checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样创建对象实例时候，创建出来的对象所拥有的方法都是一个，因为他们需要依赖prototype原型依次寻找，而找到方法是同一个，但是prototype写很多遍，可以这么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
checkObject.prototype &lt;/span&gt;=&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    }，
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上两种方法不能混着用。&lt;/p&gt;
&lt;p&gt;如在后边为对象的原型对象赋值新对象，那么会覆盖之前对prototype对象赋值的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;  a  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkName();
a.checkEmail();
a.checkPassword();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(6)方法还可以这样用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、this对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;；
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CheckObject.checkName().checkEmail().checkPassword();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、类的原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype &lt;/span&gt;=&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;；
    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是使用的时候需要创建一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkName().checkEmail().checkPassword();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(7)函数祖先&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如你想给每一个函数都添加一个检测邮箱的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Function.prototype.checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测邮箱&lt;/span&gt;
｝
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样使用这个方法就比较简单，&lt;/p&gt;
&lt;p&gt;1、函数形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
f.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、类的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function();
f.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你这种方式，原则上没有问题，但是污染了全局原生对象Function，这样别人创建的函数也会被你创建的函数污染，造成不必要的开销，但是你可以&lt;strong&gt;抽象出一个统一添加方法&lt;/strong&gt;的功能方法。方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，如果你想添加邮箱验证的方法和姓名验证的方法，可以这样使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;(){};&lt;br/&gt;//或者&lt;br/&gt;var methods = new Function();&lt;br/&gt;methods.addMethod('checkName',function(){&lt;br/&gt;　　//验证姓名&lt;br/&gt;})&lt;br/&gt;methods.addMethod('checkEmail',function(){&lt;br/&gt;　　//验证邮箱&lt;br/&gt;})&lt;br/&gt;methods.checkName();&lt;br/&gt;methods.checkEmail();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(8)链式添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想&lt;span&gt;&lt;strong&gt;链式添加&lt;/strong&gt;&lt;/span&gt;，在addMethods中将this返回，就可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你还想&lt;strong&gt;添加方法&lt;/strong&gt;，可以这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
methods.addMethod(&lt;/span&gt;'checkName',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名 &lt;/span&gt;
}).addMethod('checkEmail',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱 &lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我想&lt;span&gt;&lt;strong&gt;链式使用&lt;/strong&gt;&lt;span&gt;，应该如何实现？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;既然添加方法可以将this返回实现，那么添加的每一个方法都将this返回是不是也就实现了呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
methods.addMethod(&lt;/span&gt;'checkName',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;  
}).addMethod(&lt;/span&gt;'checkEmail',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
methods.checkName().checkEmail();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(9)换一种使用方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、函数式调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、类式调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用类式调用，不能直接使用，需要通过new关键字来创建新对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Methods();
m.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JavaScript中函数时一等公民。&lt;/p&gt;

&lt;p&gt;1、如何实现方法的链式调用？&lt;/p&gt;
&lt;p&gt;只需在类中的每个方法中通过this关键字返回对象实例的引用。每次函数调用都会返回一个新对象，表面上是CheckObject对象，实际是返回的新对象，这样每次调用就不会相互影响了。&lt;/p&gt;
&lt;p&gt;2、为函数添加多个方法的addMethod方法？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）this对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
     checkName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;      
    } ,   &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;   checkEmail: function&lt;span&gt;(){
      //验证邮箱
      return this&lt;span&gt;;      
    } ,  &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 　　checkPassword: function(){
      //验证密码
      return this;      
    } ,  
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）类的原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype &lt;/span&gt;=&lt;span&gt; {
     checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    } ,
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
     },
     checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 14 Jul 2018 15:17:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9297286.html</dc:identifier>
</item>
<item>
<title>相机IMU融合四部曲（二）：误差状态四元数详细解读 - 极品巧克力</title>
<link>http://www.cnblogs.com/ilekoaiq/p/9266036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilekoaiq/p/9266036.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;相机IMU融合四部曲（二）：误差状态四元数详细解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;极品巧克力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上一篇文章，《D-LG-EKF详细解读》中，讲了理论上的SE3上相机和IMU融合的思想。但是，还没有涉及到实际的操作，以及实际操作中会遇到的一些问题。所以，本文开始讲实际操作，包括，在相机和IMU融合的过程中，IMU速度的计算，加速度计和陀螺仪的使用，偏移的处理，重力的滤波等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文的主要参考文献为John sola的《Quaternion kinematics for the error state Kalman》，简称为误差状态四元数。它的基本思想和D-LG-EKF是一样的，都是对均值状态和扰动状态的进行处理。但是，不同的是，在误差状态四元数里，是把偏移也放到状态里滤波的，而Google Cardboard里的偏移是通过低通滤波滤出来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且John sola的相机和IMU融合的程序是开源的，项目名称为RT-SLAM，源代码地址为&lt;a href=&quot;https://www.openrobots.org/wiki/rtslam/&quot;&gt;https://www.openrobots.org/wiki/rtslam/&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其运行效果如视频（https://vimeo.com/114879173）所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文目标读者：传感器融合算法工程师。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.预测&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先，列出运动方程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231030690-712220475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，下标t表示的是true的意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又因为实际测量值与真实值的关系为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231030950-180858096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把实际测量值代入到上式中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231031323-2075510684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，用D-LG-EKF里面的均值+扰动的思想，表示两个时刻的均值以及扰动状态之间要满足的关系，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231031575-74669990.png&quot; alt=&quot;&quot;/&gt;，所以，代入上式，得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231031871-163828229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231032161-1889302878.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;里面，其实是&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231032364-441660680.png&quot; alt=&quot;&quot;/&gt;，而不是&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231032577-553604633.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231032816-615240431.png&quot; alt=&quot;&quot;/&gt;是中间的一个转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，上式左边的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231033035-24792859.png&quot; alt=&quot;&quot;/&gt;等都为均值，就是由&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231033324-2068739173.png&quot; alt=&quot;&quot;/&gt;时刻的均值变换过来的，新的均值的计算过程如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231033578-1651457064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再代回到之前的公式中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231033880-112528535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从而得到，新的扰动与旧的扰动的关系，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231034116-1330615375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231034325-653068703.png&quot; alt=&quot;&quot;/&gt;的平方项都忽略掉，忽略二阶的极小值，进一步推导。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231034566-235221507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考《从角轴到四元数微分方程》，角轴扰动与四元数扰动的关系为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231034896-103491430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原先的表达式可以转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231035174-1856768404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的推导中，因为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231035432-449169455.png&quot; alt=&quot;&quot;/&gt;是二阶极小值，所以忽略掉。因为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231035707-1602810691.png&quot; alt=&quot;&quot;/&gt;是各向相同的噪声，所以&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231035962-880801570.png&quot; alt=&quot;&quot;/&gt;，参考论文里面的推导，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231036161-1858674522.png&quot; alt=&quot;&quot;/&gt;并不会影响协方差的计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对下一个表达式进行转换，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231036440-404924014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把上面的四元数乘法，全部都解开，应该就能算出来。但是太麻烦了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231036888-2083578545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上式转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231037175-112161903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上式中，因为，认为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231037399-850188765.png&quot; alt=&quot;&quot;/&gt;是一个微小值，所以直接&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231037660-1011688864.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者，另外一种方法，参考论文上的方法，对表达式两边求导，导数也应该是相同的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231037887-1753983210.png&quot; alt=&quot;&quot;/&gt;，所以，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231038169-1112927907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面，进行了两处简化，首先，忽略掉了&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231038446-1215021658.png&quot; alt=&quot;&quot;/&gt;项，然后，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231038924-859047526.png&quot; alt=&quot;&quot;/&gt;。积分之后，就得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231039402-1067686500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与前面那种方法的结果相同。但是，论文上的这种方法难想到，为了思考上的方便，以后仍然还是用前面的那种方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启发：这里用旋转矩阵，而不是叉乘，这么操作的目的应该是，叉乘只是对旋转矩阵的近似，而角轴转旋转矩阵，用罗德里格斯变换，得到的结果最准确。所以，最终结果里，还是尽量少用叉乘，能组合成旋转矩阵就组合成旋转矩阵，而角轴到旋转矩阵的方法用罗德里格斯变换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，算后面的扰动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231039635-551695768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的扰动与旧的扰动的关系，总结起来就是，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231039880-1838441699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，都转换成了线性的关系，可以表示为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231040146-1083613244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231040386-1268816072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231040636-1325979147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231040903-2003664985.png&quot; alt=&quot;&quot;/&gt;，所以，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231041156-141067553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231041411-910365056.png&quot; alt=&quot;&quot;/&gt;的计算，参考论文上的公式（270）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231041644-1594418732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.更新&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;然后，使用贝叶斯公式，用&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231041917-1445862478.png&quot; alt=&quot;&quot;/&gt;表示，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231042343-1515428707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231042901-1171718681.png&quot; alt=&quot;&quot;/&gt;表示的是一种特殊的运算，意思是距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了能像《D-LG-EKF》里面那样转换成卡尔曼滤波的形式，上式的右边内容，需要进行线性化。在扰动的均值处进行线性化，在这里，即为&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231043116-560220737.png&quot; alt=&quot;&quot;/&gt;处进行线性化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231043391-777747842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231043643-435737452.png&quot; alt=&quot;&quot;/&gt;，也可以进一步变换，比如，MSF里，把四元数残差转换成角轴残差。但这些残差都要有相对应的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231043970-1457400140.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在误差状态四元数论文里，是通过级联求导的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231044223-610772993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231044501-390762586.png&quot; alt=&quot;&quot;/&gt;要根据具体的残差方程来计算，而&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231044728-114056369.png&quot; alt=&quot;&quot;/&gt;则是固定的。无论是四元数残差还是角轴残差，还是其它的残差，不同的仅仅只是&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231045022-1948322811.png&quot; alt=&quot;&quot;/&gt;，而&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231045239-3340710.png&quot; alt=&quot;&quot;/&gt;和&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231045452-577286633.png&quot; alt=&quot;&quot;/&gt;都是一样的。所以，上面的表达式，是一个通用模型，适用于所有的残差，也可以说是，适用于所有的观测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231045667-1911261537.png&quot; alt=&quot;&quot;/&gt;可以提前计算好，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231046005-152683374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，其它项都是单位阵，除了&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231046234-570085342.png&quot; alt=&quot;&quot;/&gt;，则计算如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231046494-1236314854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231046778-1092282044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是可以提前计算好的，在实际计算时，只需要把&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231047061-1378481319.png&quot; alt=&quot;&quot;/&gt;代进来就行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231047257-1825655278.png&quot; alt=&quot;&quot;/&gt;，则原式可以转换为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231047536-342855100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，就可以转换为卡尔曼滤波公式，这些对应的是扰动的均值和协方差，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231047817-987208874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，就是把卡尔曼滤波算出来的最大后验值，加入到原先的状态中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231048088-2127326379.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是论文里面的reset部分，就是让旧的状态吸收进卡尔曼滤波出来的扰动的均值，让新扰动的均值变为0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则新的扰动，与旧的扰动的关系为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231048335-74749985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231048580-358587808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代回到之前的公式，得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231048909-609496073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从而得到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231049242-473899960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，新的扰动的均值为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231049593-637891555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的扰动的协方差为，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231050144-693753812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，也就得到的新的协方差，&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231050383-746771087.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231050605-1715134650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者，也没必要这么麻烦，直接根据前面新旧扰动的关系，算&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231050857-1667039101.png&quot; alt=&quot;&quot;/&gt;，然后&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231051092-43592627.png&quot; alt=&quot;&quot;/&gt;。其实根据协方差计算公式，本质上是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.全局扰动&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前的扰动都是加在右边的，全局扰动就是加在左边的扰动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局扰动与本地扰动的区别，如论文中的表格4所示。差别不大，主要是角度上的扰动的雅克比。这里也计算一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231051376-1641574638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.微分方程的积分&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;论文的附录部分，就是讨论用龙格库塔的方法，或者泰勒多阶展开的方法，对状态转移矩阵进行积分。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;虽然论文中有说这么一句话，全局扰动的方法比局部扰动的方法要好，比如李名杨的MSCKF中的方法，但是没有具体举例说明好在哪里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用四元数来表示状态，四元数扰动与角轴扰动的转换太麻烦了，可以改成用李代数来表示旋转，但是李代数里面的BCH近似的&lt;img src=&quot;https://images2018.cnblogs.com/blog/699318/201807/699318-20180714231051632-526597356.png&quot; alt=&quot;&quot;/&gt;又不好算。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.参考文献&lt;/h2&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Solà J. Quaternion kinematics for the error-state Kalman filter[J]. 2017.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 14 Jul 2018 15:14:00 +0000</pubDate>
<dc:creator>极品巧克力</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ilekoaiq/p/9266036.html</dc:identifier>
</item>
<item>
<title>Spring MVC五大核心组件和配置 - 零晨三点半</title>
<link>http://www.cnblogs.com/resultset/p/9311255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/resultset/p/9311255.html</guid>
<description>&lt;p&gt;一,五大核心组件&lt;/p&gt;
&lt;p&gt;　　1.DispatcherServlet　　请求入口&lt;/p&gt;
&lt;p&gt;　　2.HandlerMapping　　  请求派发,负责请求和控制器建立一一对应的关系&lt;/p&gt;
&lt;p&gt;　　3.Controller　　　　　  处理器&lt;/p&gt;
&lt;p&gt;　　4.ModelAndView　　　  封装模型信息和视图信息&lt;/p&gt;
&lt;p&gt;　　5.ViewResolver　　　　视图处理器,定位页面&lt;/p&gt;
&lt;p&gt;二,Spring MVC的编写步骤(访问WEB-INF下的.jsp)&lt;/p&gt;
&lt;p&gt;　　1.建立项目,导入jar包(ioc mvc)并且拷贝Spring容器中对应的配置文件到src下,并且在WEB-INF下创建一个hello.jsp&lt;/p&gt;
&lt;p&gt;　　2.在web.xml中配置DispatcherServlet并通过初始化参数contextConfigLocation指定Spring容器对应的配置文件&lt;/p&gt;
&lt;p&gt;　　3.在Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping&lt;/p&gt;
&lt;p&gt;　　4.写一个控制器类实现Controller接口,控制器方法中返回ModelAndView,在Spring容器中配置控制器&lt;/p&gt;
&lt;p&gt;　　5.配置ViewResolver的实现类internalResourceViewResolver&lt;/p&gt;
&lt;p&gt;如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1432185/201807/1432185-20180714215448407-615524279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置DispatcherServlet&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_96d28e8a-1319-44d1-aa0c-a2da7d67faa8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_96d28e8a-1319-44d1-aa0c-a2da7d67faa8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_96d28e8a-1319-44d1-aa0c-a2da7d67faa8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;   &amp;lt;display-name&amp;gt;spring-mvc&amp;lt;/display-name&amp;gt;
&lt;span&gt; 4&lt;/span&gt;   &amp;lt;welcome-file-list&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;index.html&amp;lt;/welcome-file&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;index.htm&amp;lt;/welcome-file&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;&lt;span&gt;default&lt;/span&gt;.html&amp;lt;/welcome-file&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;&lt;span&gt;default&lt;/span&gt;.htm&amp;lt;/welcome-file&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;&lt;span&gt;default&lt;/span&gt;.jsp&amp;lt;/welcome-file&amp;gt;
&lt;span&gt;11&lt;/span&gt;   &amp;lt;/welcome-file-list&amp;gt;
&lt;span&gt;12&lt;/span&gt;   &amp;lt;!-- 配置请求入口 --&amp;gt;
&lt;span&gt;13&lt;/span&gt;   &amp;lt;servlet&amp;gt;
&lt;span&gt;14&lt;/span&gt;       &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt;15&lt;/span&gt;       &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
&lt;span&gt;16&lt;/span&gt;       &amp;lt;!-- 配置初始化参数 --&amp;gt;
&lt;span&gt;17&lt;/span&gt;       &amp;lt;init-param&amp;gt;
&lt;span&gt;18&lt;/span&gt;           &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
&lt;span&gt;19&lt;/span&gt;           &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&lt;span&gt;20&lt;/span&gt;       &amp;lt;/init-param&amp;gt;
&lt;span&gt;21&lt;/span&gt;   &amp;lt;/servlet&amp;gt;
&lt;span&gt;22&lt;/span&gt;   &amp;lt;servlet-mapping&amp;gt;
&lt;span&gt;23&lt;/span&gt;       &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt;24&lt;/span&gt;       &amp;lt;url-pattern&amp;gt;*.&lt;span&gt;do&lt;/span&gt;&amp;lt;/url-pattern&amp;gt;
&lt;span&gt;25&lt;/span&gt;   &amp;lt;/servlet-mapping&amp;gt;
&lt;span&gt;26&lt;/span&gt; &amp;lt;/web-app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;HandlerMapping&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0c82aac7-bc74-4bd2-ad3f-22a15cb35789&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c82aac7-bc74-4bd2-ad3f-22a15cb35789&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c82aac7-bc74-4bd2-ad3f-22a15cb35789&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
&lt;span&gt; 3&lt;/span&gt;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
&lt;span&gt; 5&lt;/span&gt;     xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;  
&lt;span&gt; 6&lt;/span&gt;     xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; 
&lt;span&gt; 7&lt;/span&gt;     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt; 8&lt;/span&gt;     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
&lt;span&gt; 9&lt;/span&gt;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;span&gt;10&lt;/span&gt;     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
&lt;span&gt;11&lt;/span&gt;     xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
&lt;span&gt;12&lt;/span&gt;     xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans-4.1.xsd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context-4.1.xsd&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jdbc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jee &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jee/spring-jee-4.1.xsd&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx/spring-tx-4.1.xsd&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/data/jpa &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/util/spring-util-4.1.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &amp;lt;!-- 配置请求分发器,让请求和控制器之间建立一一对应关系 --&amp;gt;
&lt;span&gt;23&lt;/span&gt;     &amp;lt;bean id=&quot;handlerMapping&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;property name=&quot;mappings&quot;&amp;gt;
&lt;span&gt;25&lt;/span&gt;             &amp;lt;props&amp;gt;
&lt;span&gt;26&lt;/span&gt;                 &amp;lt;prop key=&quot;/toHello.do&quot;&amp;gt;helloController&amp;lt;/prop&amp;gt;
&lt;span&gt;27&lt;/span&gt;             &amp;lt;/props&amp;gt;
&lt;span&gt;28&lt;/span&gt;         &amp;lt;/property&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt;30&lt;/span&gt;     &amp;lt;!-- 配置控制器 --&amp;gt;
&lt;span&gt;31&lt;/span&gt;     &amp;lt;bean id=&quot;helloController&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.xcz.controller.ToHelloController&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;32&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;ViewResolver&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_80762a7f-b929-4c12-b185-bc08e85ac1f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_80762a7f-b929-4c12-b185-bc08e85ac1f0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_80762a7f-b929-4c12-b185-bc08e85ac1f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
&lt;span&gt; 3&lt;/span&gt;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
&lt;span&gt; 5&lt;/span&gt;     xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;  
&lt;span&gt; 6&lt;/span&gt;     xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; 
&lt;span&gt; 7&lt;/span&gt;     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt; 8&lt;/span&gt;     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
&lt;span&gt; 9&lt;/span&gt;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;span&gt;10&lt;/span&gt;     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
&lt;span&gt;11&lt;/span&gt;     xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
&lt;span&gt;12&lt;/span&gt;     xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans-4.1.xsd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context-4.1.xsd&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jdbc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jee &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jee/spring-jee-4.1.xsd&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx/spring-tx-4.1.xsd&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/data/jpa &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/util/spring-util-4.1.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &amp;lt;!-- 配置视图处理器 --&amp;gt;
&lt;span&gt;23&lt;/span&gt;     &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt;26&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt;27&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最终配置结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_91e5631d-1dfa-4714-b780-8b047029a514&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_91e5631d-1dfa-4714-b780-8b047029a514&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91e5631d-1dfa-4714-b780-8b047029a514&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
&lt;span&gt; 3&lt;/span&gt;     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt;     xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
&lt;span&gt; 5&lt;/span&gt;     xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;  
&lt;span&gt; 6&lt;/span&gt;     xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; 
&lt;span&gt; 7&lt;/span&gt;     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt; 8&lt;/span&gt;     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
&lt;span&gt; 9&lt;/span&gt;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;span&gt;10&lt;/span&gt;     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
&lt;span&gt;11&lt;/span&gt;     xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
&lt;span&gt;12&lt;/span&gt;     xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans-4.1.xsd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context-4.1.xsd&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jdbc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/jee &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/jee/spring-jee-4.1.xsd&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/tx/spring-tx-4.1.xsd&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/data/jpa &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/util/spring-util-4.1.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &amp;lt;!-- 配置请求分发器,让请求和控制器之间建立一一对应关系 --&amp;gt;
&lt;span&gt;23&lt;/span&gt;     &amp;lt;bean id=&quot;handlerMapping&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;property name=&quot;mappings&quot;&amp;gt;
&lt;span&gt;25&lt;/span&gt;             &amp;lt;props&amp;gt;
&lt;span&gt;26&lt;/span&gt;                 &amp;lt;prop key=&quot;/toHello.do&quot;&amp;gt;helloController&amp;lt;/prop&amp;gt;
&lt;span&gt;27&lt;/span&gt;             &amp;lt;/props&amp;gt;
&lt;span&gt;28&lt;/span&gt;         &amp;lt;/property&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt;30&lt;/span&gt;     &amp;lt;!-- 配置控制器 --&amp;gt;
&lt;span&gt;31&lt;/span&gt;     &amp;lt;bean id=&quot;helloController&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.xcz.controller.ToHelloController&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;32&lt;/span&gt;     &amp;lt;!-- 配置视图处理器 --&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
&lt;span&gt;34&lt;/span&gt;         &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt;35&lt;/span&gt;         &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt;36&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt;37&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后开启服务,在浏览器上输入localhost:端口号/项目名/toHello.do,看到如下界面,说明配置成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1432185/201807/1432185-20180714230143654-6987310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Jul 2018 15:04:00 +0000</pubDate>
<dc:creator>零晨三点半</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/resultset/p/9311255.html</dc:identifier>
</item>
<item>
<title>组件化开发-002-Cocoapods远程私有库使用(Private Repo) - 胡锦涛_Steven</title>
<link>http://www.cnblogs.com/StevenHuSir/p/ComponentBased_PrivateRepo.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StevenHuSir/p/ComponentBased_PrivateRepo.html</guid>
<description>&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;创建一个私有的podspec包括如下那么几个步骤&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol1&quot;&gt;&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;创建并设置一个私有的Spec Repo。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;创建Pod所对应的podspec文件。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;本地测试配置好的podspec文件是否可用。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;向私有的Spec Repo中提交podspec。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;更新维护podspec。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;本地私有仓库&lt;/strong&gt;：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;什么是Spec Repo？他是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库，remote端在GitHub上，当我们使用Cocoapods后它会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180714224919249-1330387751.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;1.&lt;strong&gt;在码云上创建一个私有库&lt;/strong&gt;：&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://gitee.com/Steven_Hu/HKCommonTools.git&quot;&gt;https://gitee.com/Steven_Hu/HKCommonTools.git&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;2.&lt;strong&gt;将私有库添加到本地&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;pod repo add  &lt;span&gt;REPO_NAME &lt;/span&gt; &lt;span&gt;SOURCE_URL&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$pod repo add CommomToolSpec https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/Steven_Hu/HKCommonTools.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Cloning spec repo `CommomToolSpec` from `&lt;a href=&quot;https://gitee.com/Steven_Hu/HKCommonTools.git%60&quot;&gt;https://gitee.com/Steven_Hu/HKCommonTools.git`&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;3.&lt;strong&gt;cd 到桌面开始组件化抽取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;cd ./Desktop&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;pod lib create HKCommonTool&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Cloning `https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/CocoaPods/pod-template.git` into `HKCommonTool`.&lt;/span&gt;
&lt;span&gt;Configuring HKCommonTool template.
&lt;/span&gt;! Before you can create a &lt;span&gt;new&lt;/span&gt;&lt;span&gt; library we need to setup your git credentials.
 What &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; your email?
 &amp;gt; &lt;span&gt;916109796&lt;/span&gt;&lt;span&gt;@qq.com
&lt;/span&gt;! Setting your email &lt;span&gt;in&lt;/span&gt; git to &lt;span&gt;916109796&lt;/span&gt;&lt;span&gt;@qq.com
  git config user.email &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;916109796@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
------------------------------&lt;span&gt;
To &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; you started we need to ask a few questions, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; should only take a minute.
If &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; your first time we recommend running through with the guide: 
 &lt;/span&gt;- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;guides.cocoapods.org/making/using-pod-lib-create.html&lt;/span&gt;
 ( hold cmd and &lt;span&gt;double&lt;/span&gt; click links to open &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a browser. )

What platform &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; you want to use?? [ iOS /&lt;span&gt; macOS ]
 &lt;/span&gt;&amp;gt;&lt;span&gt; iOS
What language &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; you want to use?? [ Swift /&lt;span&gt; ObjC ]
 &lt;/span&gt;&amp;gt;&lt;span&gt; ObjC
Would you like to include a demo application with your library&lt;/span&gt;? [ Yes /&lt;span&gt; No ]
 &lt;/span&gt;&amp;gt;&lt;span&gt; Yes
Which testing frameworks will you use&lt;/span&gt;? [ Specta / Kiwi /&lt;span&gt; None ]
 &lt;/span&gt;&amp;gt;&lt;span&gt; None
Would you like to &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; view based testing? [ Yes /&lt;span&gt; No ]
 &lt;/span&gt;&amp;gt;&lt;span&gt; Yes
What &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; your &lt;span&gt;class&lt;/span&gt; prefix?
 &amp;gt;&lt;span&gt; HK
Running pod install on your &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; library.
Pod installation complete&lt;/span&gt;! There are &lt;span&gt;2&lt;/span&gt; dependencies from the Podfile and &lt;span&gt;1&lt;/span&gt; total pods installed.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把要抽取的工具类拖到 Pods -&amp;gt;Development Pods 下的Replace.m 中并替换掉它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;cd 到工程目录下 执行 pod install&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;4.&lt;strong&gt;推送到远程私有库(git远程仓库地址，或者码云等)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;//关联远程仓库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;在 &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;HKCommonTool &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;工程目录下 执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$git remote add origin https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/Steven_Hu/HKCommonTools.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;//提交到git仓库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git add .
git commit &lt;/span&gt;-m &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool初始化&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
git push origin master
git push origin master &lt;/span&gt;-f &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局提交&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;5.&lt;strong&gt;修改 .podspec 文件并提交&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Pod::Spec.&lt;span&gt;new&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; |s|&lt;span&gt;
  #名称
  s.name             &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #版本号
  s.version          &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #摘要
  s.summary          &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool 常用工具类归类&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #描述
  s.description      &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iOS开发常用的常用宏定义和工具类，网络框架等~&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #远程仓库首页链接
  s.homepage         &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://gitee.com/Steven_Hu/HKCommonTools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #截图
  # s.screenshots     &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.example.com/screenshots_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.example.com/screenshots_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #许可证
  s.license          &lt;/span&gt;= { :type =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MIT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, :file =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LICENSE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
  #作者
  s.author           &lt;/span&gt;= { &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HJT916109796&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;916109796@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
  #source来源
  s.source           &lt;/span&gt;= { :git =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://gitee.com/Steven_Hu/HKCommonTools.git&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, :tag =&amp;gt;&lt;span&gt; s.version.to_s }
  #社交链接
  # s.social_media_url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://twitter.com/&amp;lt;TWITTER_USERNAME&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #开发版本
  s.ios.deployment_target &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #资源文件路径
  s.source_files &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool/Classes/**/*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  #资源包
  # s.resource_bundles &lt;/span&gt;=&lt;span&gt; {
  #   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; =&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool/Assets/*.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  # }
  # s.public_header_files &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pod/Classes/**/*.h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  # s.frameworks &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UIKit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MapKit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  # s.dependency &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AFNetworking&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;~&amp;gt; 2.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;校验文件的正确性&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$pod lib lint HKCommonTool.podspec
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;重新提交&lt;/strong&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git add .
git commit &lt;/span&gt;-m &lt;span&gt;'&lt;/span&gt;&lt;span&gt;修改podspec文件~&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
git push origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;设置tag&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git tag
git tag &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
git push &lt;/span&gt;--tags
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6.&lt;span class=&quot;s1&quot;&gt;推送本地Spec到远程仓库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git fetch origin master&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git checkout master&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;git branch --set-upstream-to=origin/master master&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Branch 'master' set up to track remote branch 'master' from 'origin'.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git pull&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;pod repo update&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;pod repo push CommomToolSpec HKCommonTool.podspec&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git push&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git pull&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;git push origin master&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;7.&lt;span class=&quot;s1&quot;&gt;如何使用:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;编辑Podfile文件如下&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;编辑Podfile 必须加&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;span&gt;&lt;strong&gt;git =&amp;gt; 'https://gitee.com/Steven_Hu/HKCommonTools.git'&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
platform :ios, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
use_frameworks&lt;/span&gt;!&lt;span&gt;

target &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKTools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;
  
  pod &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XCDemo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  ,:git =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://gitee.com/Steven_Hu/XCTool.git&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  pod &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKCommonTool&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  ,:git =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://gitee.com/Steven_Hu/HKCommonTools.git&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
#  pod &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKTools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, :path =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./Lib/HKTools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
#  pod &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HKTools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, :podspec =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;~/.cocoapods/repos/HKTools/HKTools.podspec&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180714224523616-1953343301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.&lt;span class=&quot;s1&quot;&gt;其他常用命令:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除本地私有库&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ pod repo remove hktools
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s2&quot;&gt;Removing spec repo `gitee-steven_hu-hktools`&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Jul 2018 14:54:00 +0000</pubDate>
<dc:creator>胡锦涛_Steven</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StevenHuSir/p/ComponentBased_PrivateRepo.html</dc:identifier>
</item>
<item>
<title>每天学点SpringCloud（六）：Hystrix使用 - 智享</title>
<link>http://www.cnblogs.com/zhixiang-org-cn/p/9311183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixiang-org-cn/p/9311183.html</guid>
<description>
&lt;p&gt;Hystrix是一个实现断路器模式的库。什么是断路器模式呢？就像我们家庭中的电闸一样，如果有那一处出现意外，那么电闸就会立刻跳闸来防止因为这一处意外而引起更大的事故，直到我们确认处理完那一处意外后才可以再打开电闸。而Hystrix的存在就是为了预防程序中出现这种问题而导致程序不可用的情况。&lt;/p&gt;

&lt;p&gt;比如说我们有三个微服务 A、B、C，其中A依赖于B，B依赖于C，如果这时候C出现了问题，那么就导致B不可用，紧接着A也不可用，更有可能导致整个系统不可用。我们接下来就来看看如何利用Hystrix预防这种情况&lt;/p&gt;



&lt;p&gt;首先我们复制一份cloud-demo-consumer项目，改名为cloud-demo-consumer-hystrix&lt;/p&gt;
&lt;p&gt;引入Hystrix的依赖&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs xml&quot;&gt;
       &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&amp;gt;org.springframework.cloud&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&amp;gt;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;application.xml不用变&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs yaml&quot;&gt;
&lt;span class=&quot;hljs-attr&quot;&gt;spring:
&lt;span class=&quot;hljs-attr&quot;&gt;  application:
&lt;span class=&quot;hljs-attr&quot;&gt;    name: &lt;span class=&quot;hljs-string&quot;&gt;consumer-demo-hystrix
&lt;span class=&quot;hljs-attr&quot;&gt;server:
&lt;span class=&quot;hljs-attr&quot;&gt;  port: &lt;span class=&quot;hljs-number&quot;&gt;8090
&lt;span class=&quot;hljs-attr&quot;&gt;eureka:
&lt;span class=&quot;hljs-attr&quot;&gt;  client:
&lt;span class=&quot;hljs-attr&quot;&gt;    healthcheck:
&lt;span class=&quot;hljs-attr&quot;&gt;      enabled: &lt;span class=&quot;hljs-literal&quot;&gt;true
&lt;span class=&quot;hljs-attr&quot;&gt;    serviceUrl:
&lt;span class=&quot;hljs-attr&quot;&gt;      defaultZone: &lt;span class=&quot;hljs-attr&quot;&gt;http://root:root@localhost:8761/eureka
&lt;span class=&quot;hljs-attr&quot;&gt;  instance:
&lt;span class=&quot;hljs-attr&quot;&gt;    prefer-ip-address: &lt;span class=&quot;hljs-literal&quot;&gt;true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;CloudDemoConsumerApplication改名为CloudDemoConsumerHystrixApplication，并且它的注解应该是&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs less&quot;&gt;
&lt;span class=&quot;hljs-variable&quot;&gt;@SpringBootApplication
&lt;span class=&quot;hljs-variable&quot;&gt;@EnableEurekaClient
&lt;span class=&quot;hljs-variable&quot;&gt;@EnableCircuitBreake
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;上方我们不认识的这个@EnableCircuitBreake注解就是表示开启断路器模式的注解&lt;/p&gt;

&lt;p&gt;然后我们看一下controller&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs kotlin&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@RestController
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;/user&quot;)
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;UserController {

    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired
    &lt;span class=&quot;hljs-keyword&quot;&gt;private RestTemplate restTemplate;

    &lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(&lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;/getUser/{id}&quot;)
    &lt;span class=&quot;hljs-meta&quot;&gt;@HystrixCommand(fallbackMethod = &lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;getUserFallback&quot;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;public User getUser(&lt;span class=&quot;hljs-meta&quot;&gt;@PathVariable &lt;span class=&quot;hljs-built_in&quot;&gt;Long id){
         &lt;span class=&quot;hljs-keyword&quot;&gt;return restTemplate.getForObject(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://provider-demo/user/getUser/&quot;+id,User.&lt;span class=&quot;hljs-keyword&quot;&gt;class);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public User getUserFallback(&lt;span class=&quot;hljs-built_in&quot;&gt;Long id) {
        User user = new User();
        user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;王五&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return user;
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;它相比较于原先的controller仅仅是多了一个@HystrixCommand(fallbackMethod = &quot;getUserFallback&quot;)注解和一个方法，这个注解呢就是指定Hystrix在此方法超时时调用的方法。&lt;/p&gt;


&lt;p&gt;首先启动我们代表Eureka服务的项目，然后启动cloud-demo-provider项目，紧接着启动我们现在的项目。&lt;/p&gt;

&lt;p&gt;项目启动以后我们打开浏览器访问localhost:8088/user/getUser/2的时候发现一切正常，网页上返回了张三这个用户。如果我们没有引入Hystrix的时候如果这时候把服务提供者停掉的话在访问会出现什么情况呢，是不是会报错，或者超时呀。&lt;/p&gt;
&lt;p&gt;但是现在不一样了，我们引入了Hystrix，所以我们现在停掉提供者访问的时候会发现程序走了注解指定的fallbackMethod，也就是方法getUserFallBack，这个时候我们浏览器得到的结果是王五。&lt;/p&gt;

&lt;p&gt;Hystrix默认的超时时间是1秒，也就是说它在等待服务提供者1秒后如果得不到结果的话就会认为提供者挂了，紧接着调用fallbackMethod。&lt;/p&gt;
&lt;p&gt;这个时间其实我们可以控制，只需要在yml文件中配置一个属性就可以自定义这个时间&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs stylus&quot;&gt;
hystrix&lt;span class=&quot;hljs-selector-class&quot;&gt;.command&lt;span class=&quot;hljs-selector-class&quot;&gt;.default&lt;span class=&quot;hljs-selector-class&quot;&gt;.execution&lt;span class=&quot;hljs-selector-class&quot;&gt;.isolation&lt;span class=&quot;hljs-selector-class&quot;&gt;.thread&lt;span class=&quot;hljs-selector-class&quot;&gt;.timeoutInMilliseconds: &lt;span class=&quot;hljs-number&quot;&gt;1000 &lt;span class=&quot;hljs-number&quot;&gt;#1000毫秒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;



&lt;p&gt;接下来我们看一下Feign是怎么使用Hystrix,&lt;/p&gt;
&lt;p&gt;这次我们改造cloud-demo-consumer-feign项目，项目名称改为cloud-demo-consumer-feign-hystrix，同样向上述 方式一样引入Hystrix的依赖，&lt;/p&gt;
&lt;p&gt;接着 CloudDemoConsumerFeignApplication类名改为 CloudDemoConsumerFeignHystrixApplication，同样的加入@EnableCircuitBreaker注解&lt;/p&gt;
&lt;p&gt;有一点不一样的地方是我们需要在yml文件中配置一下来开启Hystrix&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs stylus&quot;&gt;
feign&lt;span class=&quot;hljs-selector-class&quot;&gt;.hystrix&lt;span class=&quot;hljs-selector-class&quot;&gt;.enabled: true
&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;这里controller中需要改造的不再是指定单个方法，而是指定接口的实现类&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs applescript&quot;&gt;
@FeignClient(&lt;span class=&quot;hljs-built_in&quot;&gt;name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;provider-demo&quot;, fallback = HystrixClientFallback.&lt;span class=&quot;hljs-built_in&quot;&gt;class)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下这个实现类&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@Component
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HystrixClientFallback &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;UserFeignClient {
    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;getUser&lt;span class=&quot;hljs-params&quot;&gt;(Long id) {
        User user = &lt;span class=&quot;hljs-keyword&quot;&gt;new User();
        user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;王五&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return user;
    }
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;这样的话如果接口中有多个方法的话我们就不必为每一个方法取指定了。&lt;/p&gt;

&lt;p&gt;现在我们已经解决了服务提供者挂掉的事情了，但是有点不好的是，我们现在还不能知道服务提供者到底是咋挂的，要是能捕获到服务提供者&lt;/p&gt;
&lt;p&gt;抛的异常就好了，其实Hystrix对这个是支持的，我们接下来看一下&lt;/p&gt;



&lt;p&gt;UserFeignClient上方的注解需要变一下&lt;/p&gt;
&lt;pre class=&quot;ql-syntax hljs applescript&quot;&gt;
@FeignClient(&lt;span class=&quot;hljs-built_in&quot;&gt;name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;provider-demo&quot;, fallbackFactory = HystrixClientFactory.&lt;span class=&quot;hljs-built_in&quot;&gt;class)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这次使用的是fallbackFactory这个属性，我们看一下它指定的这个类又是怎么实现的呢&lt;/p&gt;

&lt;pre class=&quot;ql-syntax hljs java&quot;&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@Component
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HystrixClientFactory &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;FallbackFactory&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;UserFeignClient&amp;gt; {

    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final Logger LOGGER = LoggerFactory.getLogger(HystrixClientFactory.class);

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public UserFeignClient &lt;span class=&quot;hljs-title&quot;&gt;create&lt;span class=&quot;hljs-params&quot;&gt;(Throwable cause) {
        HystrixClientFactory.LOGGER.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;the provider error is: {}&quot;, cause.getMessage());
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;new UserFeignClient() {
            &lt;span class=&quot;hljs-meta&quot;&gt;@Override
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;getUser&lt;span class=&quot;hljs-params&quot;&gt;(Long id) {
                User user = &lt;span class=&quot;hljs-keyword&quot;&gt;new User();
                user.setName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;王五&quot;);
                &lt;span class=&quot;hljs-keyword&quot;&gt;return user;
            }
        };
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;我们可以看到，在这个create的工厂方法中，它的入参就是服务提供者的异常，得到了这个异常以后才会去做实现。这样是不是更加灵活了呢？&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/2388386839/spring-cloud-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/2388386839/spring-cloud-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;码云：&lt;a href=&quot;https://gitee.com/zhixiang_blog/spring-cloud-demo&quot; target=&quot;_blank&quot;&gt;https://gitee.com/zhixiang_blog/spring-cloud-demo&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;如果对您有所帮助，请记得帮忙点一个star哦&lt;/h5&gt;



&lt;p&gt;本文出自&lt;a href=&quot;https://zhixiang.org.cn/#/blog/read/4f908c52-4ab9-4261-8189-e76a9fdbcc14&quot; target=&quot;_blank&quot;&gt;https://zhixiang.org.cn/#/blog/read/4f908c52-4ab9-4261-8189-e76a9fdbcc14&lt;/a&gt;,转载请保留。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 14:34:00 +0000</pubDate>
<dc:creator>智享</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhixiang-org-cn/p/9311183.html</dc:identifier>
</item>
<item>
<title>springboot添加邮件发送及压缩功能 - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/9190233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/9190233.html</guid>
<description>&lt;h6&gt;&lt;span&gt;springboot添加邮件发送及文件压缩功能&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;转载请注明出处&lt;/span&gt;：&lt;span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: springboot添加邮件发送功能&quot; href=&quot;https://www.cnblogs.com/funnyzpc/p/9190233.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/funnyzpc/p/9190233.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先来一段诗&lt;/p&gt;
&lt;p&gt;&lt;span&gt;```&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　就这样吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　忍受折磨&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　然后，躺进医院&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　然后，死去&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　化作一抔土&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　从此，这世界没有烦恼&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　没有病痛&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　没有我&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　也没有这个世界&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;```&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;以上是在半睡半醒中想到的，写的不好，读者可直接略过。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这次本来只讲讲邮件发送功能的，惮于内容比较贫乏，故加了点儿文件压缩的功能讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先邮件发送，邮件功能在springboot里面是有对应的依赖组件，这个：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-mail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;邮件功能开发在springboot里面相当简单，这里我大致总结下开发内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　A&amp;gt;添加依赖包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　B&amp;gt;配置Mail基本参数(ymal或propertie里面)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　C&amp;gt;Service中注入JavaMailSender，调用相关方法即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这里面可能会有个问题，就是在具体服务器部署的时候服务器会封堵&lt;span&gt;邮件服务端口&lt;/span&gt;，以及普通邮件&lt;span&gt;安全&lt;/span&gt;问题，这里讲解的时候我会顺道给出解决之道。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，需要在工程的pom.xml中&lt;span&gt;引入邮件组件&lt;/span&gt;，组件的版本需对应springboot的版本(可不写，这里我略去)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-mail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;接下来就是在配置文件中配置邮件的基本参数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    mail:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      host: smtp.exmail.qq.com
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      username: username@hostname.com
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      password: 密码
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      default-encoding: UTF-8
&lt;/span&gt;&lt;span&gt; 7       ssl:
 8         trust: smtp.exmail.qq.com
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      properties:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        mail:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;          smtp:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            auth: true  #是否需要认证
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            socketFactory:
14               class: javax.net.ssl.SSLSocketFactory #SSL证书Socket工厂
15               port: 465 #使用SMTP465端口&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置参数的时候一定要注意缩进，因为我给的是yaml的配置格式，&lt;span&gt;若是properties配置，大致是这样子(例子)：spring.mail.host:smtp.exmail.qq.com&lt;/span&gt;,每一个子项都是完整的格式，一开始我是省略了properties项以下的配置(是否认真，SSL，端口)，后来发现服务器将邮件的25端口封了，所以在本地可以但是在服务器就行不通了，所以需要&lt;span&gt;指定邮件服务端口&lt;/span&gt;为465，我这里使用的是qq邮箱，如果使用163或其他邮箱需自行查阅服务商支持的端口，至于邮件安全问题，在这里需要声明两个，&lt;span&gt;一个是ssl信任，以及mail的socket工厂&lt;/span&gt;，具体请见以上红色部分，以上配置仅对qq邮箱有效，不保证其他邮箱也适用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ok，配置完成，这里就开始写具体的实现类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; XXX.common.util.DateUtil;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.SimpleMailMessage;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.javamail.JavaMailSender;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.javamail.MimeMessageHelper;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.MimeMessage;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailService {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(MailService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     @Value(&quot;${spring.mail.username}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String SEND_USER_ADDR;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JavaMailSender mailSender;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;     *      发送简单邮件
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; sendSimpleMail&lt;/span&gt;(String receive,String obj,String content) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!StringUtils.isNotBlank(content) || !&lt;span&gt;StringUtils.isNotBlank(receive))
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不发送空邮件&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         SimpleMailMessage message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMailMessage();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        message.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             message.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            message.setTo(receive);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        message.setSubject(obj);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        message.setText(content);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            mailSender.send(message);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             LOG.info(&quot;Simple mail send success!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             LOG.error(&quot;sendSimpleMail ERROR!&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringBuilder strBuilder;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;     *  发送html邮件 多列表单的形式
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题(题目)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendHtmlMailByList&lt;/span&gt;(String receive,String obj,List&amp;lt;Map&amp;gt;&lt;span&gt; content){
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(content.isEmpty() || !StringUtils.isNotBlank(receive) || &lt;span&gt;null&lt;/span&gt;==&lt;span&gt;obj)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             MimeMessage msg =&lt;span&gt; mailSender.createMimeMessage();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(msg, &lt;span&gt;true&lt;/span&gt;, &quot;UTF-8&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决乱码问题&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                helper.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     helper.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                    helper.setTo(receive);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                helper.setSubject(obj);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 strBuilder=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body style=\&quot;padding:3% 2%;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;This message is automatically sent to the system.&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;Send Date by &quot;+DateUtil.getDateFormat(&lt;span&gt;new&lt;/span&gt; Date(),DateUtil.DATETIME_DEFAULT_FORMAT) +&quot;&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;The following is the details:&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;table border=\&quot;2px solid red\&quot; width=\&quot;100%\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;thead style=\&quot;background-color: #aea2e2;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 Object[] st=content.get(0&lt;span&gt;).keySet().toArray();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;st.length;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;th&amp;gt;&quot;+st[i]+&quot;&amp;lt;/th&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/thead&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;体&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map item:content){
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object str:st)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         strBuilder.append(&quot;&amp;lt;td&amp;gt;&quot;+item.get(str)+&quot;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/table&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h3 style=\&quot;text-align:right\&quot;&amp;gt;Best wishes&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LOG.info(strBuilder.toString());&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                 helper.setText(strBuilder.toString(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 LOG.error(&quot;sendHtmlMail ERROR:&quot;&lt;span&gt;,e);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            mailSender.send(msg);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;     *  发送html邮件 单列记录形式
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题(题目)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendHtmlMailByItem&lt;/span&gt;(String receive,String obj,List&amp;lt;String&amp;gt;&lt;span&gt; content){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(content.isEmpty() || !StringUtils.isNotBlank(receive) || &lt;span&gt;null&lt;/span&gt;==&lt;span&gt;obj)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         MimeMessage msg =&lt;span&gt; mailSender.createMimeMessage();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(msg, &lt;span&gt;true&lt;/span&gt;, &quot;UTF-8&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决乱码问题&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            helper.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 helper.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                helper.setTo(receive);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            helper.setSubject(obj);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             strBuilder=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body style=\&quot;padding:3% 2%;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;This message is automatically sent to the system.&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;Send Date by &quot;+DateUtil.getDateFormat(&lt;span&gt;new&lt;/span&gt; Date(),DateUtil.DATETIME_DEFAULT_FORMAT) +&quot;&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;The following is the details:&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;table border=\&quot;2px solid red\&quot; width=\&quot;100%\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;thead style=\&quot;background-color: #aea2e2;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;th&amp;gt;&quot;+obj.toUpperCase()+&quot; DETAIL&amp;lt;/th&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/thead&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;体&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String item:content){
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot;+item+&quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/table&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3 style=\&quot;text-align:right;font-weight:normal;\&quot;&amp;gt;Best wishes&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            LOG.info(strBuilder.toString());
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             helper.setText(strBuilder.toString(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;             LOG.error(&quot;sendHtmlMail ERROR:&quot;&lt;span&gt;,e);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        mailSender.send(msg);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上我是将邮件功能封装成一个服务类，&lt;span&gt;使用的时候只需要将当前类注入 然后直接调用即可&lt;/span&gt;，以上封装了两个方法：一个是简单邮件发送，一个是带html table的邮件，如果需要&lt;span&gt;发送附件，需将附件放入到&lt;/span&gt;&lt;span&gt;MimeMessageHelper里面(调用addAttachment(&quot;文件名&quot;, 文件))&lt;/span&gt;方法即可，这里因为无实际需求，遂就略去了，好了，邮件发送功能已经完成，这里看下实际效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180714214436361-1229539825.png&quot; alt=&quot;&quot; width=&quot;1069&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;邮件功能实现完毕，现在我讲讲文件压缩功能，压缩功能的实现大致有四种，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;A&amp;gt;利用java.util.zip提供的api压缩&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B&amp;gt;利用apache的ant包提供的api压缩(org.apache.tools.ant.taskdefs.Zip)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C&amp;gt;使用zip4j提供的api压缩(net.lingala.zip4j)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　D&amp;gt;调用宿主机的shell命令压缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要特别提到三个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;A&amp;gt;普通邮件压缩中文乱码(不支持中文)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B&amp;gt;压缩后无法解压(解压错误)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C&amp;gt;文件压缩添加压缩密码问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际开发过压缩功能，以上三点儿对于新手来说尤其的头痛，这里我分享下以前在开发压缩功能中碰到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用原生java.util包提供的压缩，如果被压缩文件使用到中文，则会&lt;span&gt;乱码&lt;/span&gt;(据说是jdk的一个bug)，而且压缩实现的代码较为复杂(尤其是设置密码)，尤其是对于跨目录压缩和多文件压缩尤其麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用apache提供的zip工具虽避免了以上会出现的问题，但是需要提醒一点儿的是这个&lt;span&gt;ant包与webLogic冲突(&lt;/span&gt;部署的时候会报错)且无法实现压缩设置密码，如果使用的是webLogic而不是tomocat的情况下，一定要注意到这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用java调用宿主机的shell命令也是个不错的选择，但是，需要编写shell命令，同时对于部署在&lt;span&gt;windows平台就不太友好了，移植比较麻烦&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，对于以上问题，我这里推荐&lt;strong&gt;&lt;span&gt;zip4j&lt;/span&gt;&lt;/strong&gt;，以下也是针对zip4j的压缩实现做讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先，需要引入依赖包&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;       &amp;lt;!--压缩：支持加密压缩--&amp;gt;
&lt;span&gt;2&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;3&lt;/span&gt;             &amp;lt;groupId&amp;gt;net.lingala.zip4j&amp;lt;/groupId&amp;gt;
&lt;span&gt;4&lt;/span&gt;             &amp;lt;artifactId&amp;gt;zip4j&amp;lt;/artifactId&amp;gt;
&lt;span&gt;5&lt;/span&gt;             &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&lt;span&gt;6&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;再，封装一个压缩/解压缩工具类以方便使用&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.core.ZipFile;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.exception.ZipException;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.model.ZipParameters;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.util.Zip4jConstants;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 本工具类使用Zip4j来进行压缩以及解压缩
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZipUtil {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明压缩对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ZipParameters parameters;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解压文件对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ZipFile zipFile;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sourceFilePath    被压缩的文件的路径(单文件,文件夹)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; zipFilePath       压缩文件路径
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password          压缩密码
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;                  压缩成功：true ，压缩失败：false
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean &lt;strong&gt;&lt;span&gt;singleFileCompress&lt;/span&gt;&lt;/strong&gt;(String sourceFilePath,String zipFilePath,String password){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         parameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipParameters();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 压缩方式(默认方式)&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 压缩级别(默认级别)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩加密设置&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(password)) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             parameters.setEncryptFiles(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否设置文件加密(默认为否)&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加密方式(此处是标准压缩)&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            parameters.setPassword(password.toCharArray());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             ZipFile zipFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(zipFilePath);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是文件则直接压缩，若是文件夹，遍历文件全部压缩&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath).isFile()) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 zipFile.setFileNameCharset(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 zipFile.addFile(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath), parameters);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;File ff=new File(sourceFilePath);&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             File[] flst=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath).listFiles();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             System.out.println(&quot;文件个数=&amp;gt;&quot;+&lt;span&gt;flst.length);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(File f:flst){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 zipFile.setFileNameCharset(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                zipFile.addFile(f, parameters);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ZipException e) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception id){
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            id.printStackTrace();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean &lt;span&gt;&lt;strong&gt;unZip&lt;/strong&gt;&lt;/span&gt;(String zipFile,String unZipDir){
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             ZipUtil.zipFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(zipFile);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             ZipUtil.zipFile.setFileNameCharset(&quot;GBK&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置编码格式
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用自带的方法检测一下zip文件是否合法，包括文件是否存在、是否为zip文件、是否被损坏等&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ZipUtil.zipFile.isValidZipFile()) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZipException(&quot;文件不合法或不存在&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跟java自带相比，这里文件路径会自动生成，不用判断&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            ZipUtil.zipFile.extractAll(unZipDir);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(ZipException e){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;以上压缩方法自带密码压缩功能，可以压缩单文件也可以压缩目录文件，相对于原生的实现，一下子清爽了许多，这里唯一需要说明的是，压缩的目标文件在压缩前一定不能穿件，否则会报错！另外对于解压缩一定要注意文件编码和判断文件是否存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　OK，本章的功能已尽数分享，希望各位在开发功能的时候能避免这其中的&lt;strong&gt;&lt;span&gt;坑&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在是2018-07-14 22:16:12 ,各位晚安&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180714221708537-1189105993.png&quot; alt=&quot;&quot; width=&quot;45&quot; height=&quot;42&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 14:30:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/9190233.html</dc:identifier>
</item>
<item>
<title>SSH 学习笔记 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9311160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9311160.html</guid>
<description>&lt;h2 id=&quot;零背景&quot;&gt;零、背景&lt;/h2&gt;
&lt;p&gt;在看 pm2 的 deploy 功能的时候，对 ssh 的不熟悉导致错误频出，包括之前对 github 的配置也用到了 SSH，所以找个机会整理一下。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt; 是每一台 Linux 电脑的标准配置。&lt;/p&gt;
&lt;p&gt;需要指出的是，SSH 只是一种&lt;strong&gt;协议&lt;/strong&gt;，存在多种&lt;strong&gt;实现&lt;/strong&gt;，既有商业实现，也有开源实现。本文针对的实现是 &lt;code&gt;OpenSSH&lt;/code&gt;，它是自由软件，应用非常广泛。&lt;/p&gt;
&lt;p&gt;[拓展]&lt;/p&gt;
&lt;p&gt;（1）SSL、SSH、OpenSSL、OpenSSH 的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222302800-1954833915.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;（2）SSL 版本之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222312806-457353542.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以 SSL 的规范叫法是 &lt;code&gt;SSL/TLS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前，应用最广泛的是 TLS 1.0。不过比如微信的小程序接口开发需要支持 TLS 大于等于 1.2。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;（3）scp（secure copy）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scp&lt;/code&gt; 是 linux 系统下基于 ssh 登陆进行的安全远程文件拷贝命令。&lt;/p&gt;
&lt;h4 id=&quot;从本地复制到远程&quot;&gt;1、从本地复制到远程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//复制文件
scp /Users/xjnotxj/Downloads/a.jpg root@1.2.3.4:/data/wwwroot 
scp /Users/xjnotxj/Downloads/a.jpg root@1.2.3.4:/data/wwwroot/b.jpg

//复制目录
scp -r /Users/xjnotxj/Downloads/folder/ root@1.2.3.4:/data/wwwroot/&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;从远程复制到本地&quot;&gt;2、从远程复制到本地&lt;/h4&gt;
&lt;p&gt;前后顺序颠倒即可&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二用处&quot;&gt;二、用处&lt;/h2&gt;
&lt;h4 id=&quot;远程登录&quot;&gt;1、远程登录&lt;/h4&gt;
&lt;p&gt;SSH 登录机制：由上文可知，SSH 基于 SSL/TLS 协议，而它的&lt;strong&gt;机制有两种&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;①&lt;strong&gt;口令认证&lt;/strong&gt;（需要密码（即口令））&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222322067-1270974907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们访问 host 远程服务器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次访问的时候，会弹出提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host

　　The authenticity of host 'host (xx.xxx.xx.xxx)' can't be established.

　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.

　　Are you sure you want to continue connecting (yes/no)?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段话的意思时：&lt;strong&gt;无法确认远程 host 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗&lt;/strong&gt;？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;之所以是公钥指纹而不是公钥，即用 fingerprint 代替 key，主要是 key 过于长（RSA算法生成的公钥最少也得 1024 位），很难直接比较。所以，对公钥进行 hash 生成一个 128 位的指纹，这样就方便比较了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会有提示？&lt;/p&gt;
&lt;p&gt;因为要防止&lt;code&gt;中间人攻击&lt;/code&gt;，因为 hacker 的服务器也可以冒充身份把它自己的公钥发给你。&lt;/p&gt;
&lt;p&gt;什么是中间人攻击？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222331471-817492110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;yes 后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Warning: Permanently added 'host (xx.xxx.xx.xxx)' (RSA) to the list of known hosts. 
Password: (enter password) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该 host 被追加到文件 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 中，然后就可以正常输入密码了，且以后再连接这个 host 就不会有提示了。&lt;/p&gt;
&lt;p&gt;那如果在&lt;strong&gt;连接前&lt;/strong&gt;就避免这种恼人的提示？&lt;/p&gt;
&lt;p&gt;① ssh-keyscan / known_hosts&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;事先使用 &lt;code&gt;ssh-keyscan&lt;/code&gt; 命令（ gather ssh public keys ）获取到远程主机的公钥，然后添加到信任列表 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 里 ，避免弹出这个警告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keyscan -t rsa gitlab.xxx.com &amp;gt;&amp;gt; ~/.ssh/known_hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个 SSH 用户都有 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 文件，此外系统也有一个这样的文件，通常是 &lt;code&gt;/etc/ssh/ssh_known_hosts&lt;/code&gt;，保存一些对所有用户都可信赖的远程主机的公钥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② StrictHostKeyChecking=no&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh user@host -o StrictHostKeyChecking=no &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=no&lt;br/&gt;最不安全的级别。相对安全的内网建议使用。如果连接和 key 不存在或不匹配，那么就自动添加到 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=ask &lt;br/&gt;默认的级别。如果连接和 key 不存在或不匹配，给出提示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=yes &lt;br/&gt;最安全的级别。如果连接与 key 不存在或不匹配，就直接拒绝连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;②&lt;strong&gt;密钥认证&lt;/strong&gt;（不需要密码，但事先得把本机的公钥放在服务器上）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222341018-748752603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步、生成本机公钥&lt;/p&gt;
&lt;p&gt;先判断本机有没有之前生成过公钥？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat ~/.ssh/id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有，执行下面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa 

ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096
// github/gitlab 官方推荐这种写法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;~/.ssh&lt;/code&gt; 下会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt;。前者是你的&lt;strong&gt;公钥&lt;/strong&gt;，后者是你的&lt;strong&gt;私钥&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;-t 是选择 key 的类型，支持 dsa | ecdsa | ed25519 | rsa | rsa1，下面是最常用的 rsa 和 dsa 的比较：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;rsa&lt;/td&gt;
&lt;td&gt;非对称加密算法&lt;/td&gt;
&lt;td&gt;大整数的分解（两个素数的乘积）&lt;/td&gt;
&lt;td&gt;几乎一样&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;广泛&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dsa&lt;/td&gt;
&lt;td&gt;非对称加密算法&lt;/td&gt;
&lt;td&gt;整数有限域离散对数&lt;/td&gt;
&lt;td&gt;几乎一样&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;一般&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;结论：&lt;strong&gt;&lt;code&gt;RSA&lt;/code&gt; 是目前最好也是使用最广泛的非对称加密算法&lt;/strong&gt;。如 github/gitlab 和 pm2 官方文档都推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二步、拷贝本机公钥到远程服务器上&lt;/p&gt;
&lt;p&gt;这里有两种方法：&lt;/p&gt;
&lt;p&gt;1.ssh-copy-id&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-copy-id remote@myserver.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是远程主机将用户的公钥，保存在 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;2.类 github 方法&lt;/p&gt;
&lt;p&gt;github/gitlab 需要手工粘贴到 web 的设置页面里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222403816-1486358611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步、直接登录，不需要输入密码了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：如果还不行的解决方法：&lt;/p&gt;
&lt;p&gt;打开远程主机的 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，检查下面几行前面&quot;#&quot;注释是否去掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　RSAAuthentication yes
　　PubkeyAuthentication yes
　　AuthorizedKeysFile .ssh/authorized_keys&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重启 ssh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // ubuntu系统
  service ssh restart

  // debian系统
  /etc/init.d/ssh restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;密钥认证虽然前期麻烦，需要手动将公钥放置在远程主机上，但是更加安全，可以有效&lt;strong&gt;杜绝中间人攻击&lt;/strong&gt;，推荐使用。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;https 是如何避免中间人攻击的?&lt;/p&gt;
&lt;p&gt;通过 CA 证书中心来进行公证，这些证书都是事先内置在浏览器里的，其实跟 SSH 的密钥认证法很像，是事先把公钥放在远程服务器的&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;[拓展]&lt;/p&gt;
&lt;p&gt;（1）github/gitlab 使用 SSH、HTTPS 哪个好？&lt;/p&gt;
&lt;p&gt;①是否输入密码&lt;/p&gt;
&lt;p&gt;当你&lt;strong&gt;git clone、git fetch、git pull、git push&lt;/strong&gt;使用 HTTPS URL，你会被要求输入 GitHub 的&lt;strong&gt;用户名和密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当你&lt;strong&gt;git clone、git fetch、git pull、git push&lt;/strong&gt;使用 SSH URL，你会被要求输入你的 &lt;strong&gt;SSH密钥密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但一般我们在生成 SSH 密钥的时候没有设置密码的习惯。所以等于 SSH 的方式不需要输入密码。&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;windows&lt;/strong&gt; 下也可以有存储密码的方法，用 git-credential-winstore 和 git-credential-manager-for-windows 存储 credential，安全性和便捷性同样可以保证。具体没用过，windows i refuse。&lt;/p&gt;
&lt;p&gt;②部署难度&lt;/p&gt;
&lt;p&gt;对&lt;strong&gt;类 linux&lt;/strong&gt; 来说配置 ssh 是最简单的方式。毕竟 git 是 linus 写的软件。linus 又是 linux 的作者。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;总结：对于我这个 mac 用户，还是用 SSH 更方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;（3）使用别名登录主机&lt;/p&gt;
&lt;p&gt;新建文件 &lt;code&gt;~/.ssh/config&lt;/code&gt;，并写入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Host myWebsite
    HostName 1.2.3.4
    User root
    IdentityFile ~\.ssh\id_rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Host : 别名&lt;br/&gt;HostName：目标主机名或 IP 地址&lt;br/&gt;User：登陆的用户&lt;br/&gt;IdentityFile：登陆的私钥&lt;/p&gt;
&lt;p&gt;于是可以这样登录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//原来
$ ssh root@1.2.3.4
//现在
$ ssh myWebsite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实践看我另一篇《 &lt;a href=&quot;https://www.cnblogs.com/xjnotxj/p/5845574.html&quot;&gt;一台电脑上的git同时使用两个github账户&lt;/a&gt; 》&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;（4）其他参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//指定端口
$ ssh root@1.2.3.4 -p 8080

//调试模式
$ ssh -v root@1.2.3.4 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）远程服务器管理 SSH 登录用户&lt;/p&gt;
&lt;p&gt;①查看所有在线用户 / 查看自己&lt;/p&gt;
&lt;p&gt;简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]#  who
root     tty1         2018-01-05 15:11
root     pts/0        2018-07-14 19:07 (xxx.81.48.19)
root     pts/1        2018-07-14 19:00 (xxx.81.48.19)

//查看自己
[root@AY140506122759852282Z ~]#  who am i
root     pts/1        2018-07-14 19:00 (xxx.81.48.19)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# w
 19:07:26 up 190 days,  3:56,  3 users,  load average: 1.24, 1.07, 1.06
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1      05Jan18 190days  1.66s  1.66s -bash
root     pts/0     19:07   26.00s  0.04s  0.04s -bash
root     pts/1     19:00    6.00s  0.13s  0.00s w

//指定特定用户
[root@AY140506122759852282Z ~]# w root&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;USER：登陆帐号&lt;br/&gt;TTY：用户终端&lt;br/&gt;LOGIN@：登陆时间&lt;br/&gt;IDLE：登陆时长&lt;br/&gt;JCPU：指所有与该终端相关的进程任务所耗费的 CPU 时间&lt;br/&gt;PCPU：指 WHAT 域的任务执行耗费的 CPU 时间&lt;br/&gt;WHAT：表示当前执行的任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间、登录时长&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;②踢掉某个在线用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# pkill -kill -t pts/0

//强制
[root@AY140506122759852282Z ~]# pkill -9 -t pts/0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后对方就会自动断开连接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# Connection to xxx.124.109.112 closed.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;③查看用户登录历史（包括在线）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# last -10
root     pts/0        xxx.81.48.19     Sat Jul 14 19:07   still logged in
root     pts/1        xxx.81.48.19     Sat Jul 14 19:00   still logged in
root     pts/1        xxx.81.48.19     Sat Jul 14 18:59 - 18:59  (00:00)
root     pts/1        xxx.81.48.19     Sat Jul 14 18:58 - 18:59  (00:00)
root     pts/1        xxx.81.48.19     Sat Jul 14 18:57 - 18:58  (00:00)
root     pts/0        xxx.81.48.19     Sat Jul 14 18:57 - 19:04  (00:07)
root     pts/0        xxx.81.48.19     Sat Jul 14 17:18 - 17:23  (00:05)
root     pts/1        xxx.81.48.19     Sat Jul 14 14:14 - 14:14  (00:00)
root     pts/0        xxx.81.48.19     Sat Jul 14 14:13 - 14:14  (00:01)
root     pts/0        xxx.81.48.19     Fri Jul 13 14:41 - 16:41  (02:00)

//指定特定用户
[root@AY140506122759852282Z ~]# last -10 root&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间、注销时间、登录时长&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;（6）退出SSH&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exit&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;远程执行命令&quot;&gt;2、远程执行命令&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ssh user@host 'ls /data'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列出远程主机 /data 下的目录&lt;/p&gt;
&lt;h4 id=&quot;端口转发&quot;&gt;3、端口转发&lt;/h4&gt;
&lt;p&gt;待写，具体可先参考：&lt;/p&gt;
&lt;p&gt;《SSH原理与运用（二）：远程操作与端口转发》http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&lt;br/&gt;《玩转SSH端口转发》&lt;br/&gt;https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/&lt;/p&gt;
&lt;h4 id=&quot;实现-vpn虚拟专用网络&quot;&gt;4、实现 VPN（虚拟专用网络）&lt;/h4&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;1、【SSH原理与运用（一）：远程登录】http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&lt;br/&gt;2、【Linux系统下如何查看已经登录用户】&lt;br/&gt;https://www.jb51.net/LINUXjishu/10876.html&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 14:24:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9311160.html</dc:identifier>
</item>
<item>
<title>Spring核心——Bean的定义与控制 - AI乔治</title>
<link>http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</guid>
<description>&lt;p&gt;在Sring核心与设计模式的文章中，分别介绍了Ioc容器和Bean的依赖关系。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。&lt;/p&gt;
&lt;p&gt;除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的生命周期功能以及状态定义功能。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;前置依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用&lt;em&gt;depends-on&lt;/em&gt;声明前置依赖即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215113590-2033206306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;延迟加载&lt;/h2&gt;
&lt;p&gt;通常情况下，所有的 singleton 类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。&lt;/p&gt;
&lt;p&gt;IoC支持所有的 singleton Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。但是如果你的应用对启动时间的长短并不敏感，建议让所有的 singleton 都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。&lt;/p&gt;
&lt;p&gt;可以设置全局延迟加载，也可以设置某个Bean延迟加载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215132579-1019762338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215146871-1983160172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。&lt;/p&gt;
&lt;p&gt;延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在Effective &lt;em&gt;Java&lt;/em&gt;一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;生命周期方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个Bean的创建、使用再到最后销毁称为&quot;Bean的生命周期&quot;。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;初始化方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215222123-1710140570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215235519-1614027468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2种方法都等效，实际使用是我们应该使用哪一种方法呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和JSR-330规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;销毁方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：&lt;/p&gt;
&lt;p&gt;继承实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215256457-1163101040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215309978-1037696572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;全局配置初始化与销毁方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IoC容器还提供了全局配置初始化与销毁方法的配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215338532-544696104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;通过在&amp;lt;beans&amp;gt;标签上使用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通过在&amp;lt;beans&amp;gt;标签上使用&lt;em&gt;default-init-method&lt;/em&gt;和&lt;em&gt;default-destroy-method&lt;/em&gt; 属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。&lt;/p&gt;
&lt;p&gt;如果在&amp;lt;beans&amp;gt;上设定2个默认的生命周期方法，同时在&amp;lt;bean&amp;gt;上也指定了&lt;em&gt;init-method&lt;/em&gt;或&lt;em&gt;destroy-method，&lt;/em&gt;回调方法会以&amp;lt;bean&amp;gt;上的配置为准。这样就保证全局配置与单独配置可以共存。&lt;/p&gt;
&lt;p&gt;使用初始化或销毁2个生命周期方法注意的要点：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&amp;lt;beans&amp;gt;的属性统一名称使用全局配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 14 Jul 2018 13:50:00 +0000</pubDate>
<dc:creator>AI乔治</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</dc:identifier>
</item>
<item>
<title>JAVAEE——Lucene基础：什么是全文检索、Lucene实现全文检索的流程、配置开发环境、索引库创建与管理 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9311066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9311066.html</guid>
<description>&lt;p&gt;&lt;span&gt;第一天：&lt;/span&gt;Lucene&lt;span&gt;的基础知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、案例分析：什么是全文检索，如何实现全文检索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Lucene&lt;span&gt;实现全文检索的流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 创建索引&lt;/p&gt;
&lt;p&gt;b) 查询索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、配置开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、创建索引库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、查询索引库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、分析器的分析过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 测试分析器的分词效果&lt;/p&gt;
&lt;p&gt;b) 第三方中文分析器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、索引库的维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 添加文档&lt;/p&gt;
&lt;p&gt;b) 删除文档&lt;/p&gt;
&lt;p&gt;c) 修改文档&lt;/p&gt;
&lt;p&gt;8&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的高级查询&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;使用&lt;/span&gt;Query&lt;span&gt;的子类查询&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MatchAllDocsQuery&lt;/li&gt;
&lt;li&gt;TermQuery&lt;/li&gt;
&lt;li&gt;NumericRangeQuery&lt;/li&gt;
&lt;li&gt;BooleanQuery&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;b) &lt;span&gt;使用&lt;/span&gt;QueryParser&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;QueryParser&lt;/li&gt;
&lt;li&gt;MulitFieldQueryParser&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;span&gt;实现一个文件的搜索功能，通过关键字搜索文件，&lt;/span&gt;&lt;span&gt;凡是文件名或文件内容包括关键字的文件&lt;/span&gt;&lt;span&gt;都需要找出来。还可以根据中文词语进行查询，并且需要支持多个条件查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本案例中的原始内容就是磁盘上的文件，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213109981-1226552600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;3.1. &lt;strong&gt;数据库搜索&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;数据库中的搜索很容易实现，通常都是使用&lt;/span&gt;sql&lt;span&gt;语句进行查询，而且能很快的得到查询结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为什么数据库搜索很容易？&lt;/p&gt;
&lt;p&gt;因为数据库中的数据存储是有规律的，有行有列而且数据格式、数据长度都是固定的。&lt;/p&gt;

&lt;h2&gt;3.2. &lt;strong&gt;数据分类&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们生活中的数据总体分为两种：结构化数据和非结构化数据。&lt;/p&gt;
&lt;p&gt;结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非结构化数据：指不定长或无固定格式的数据，如邮件，&lt;/span&gt;word&lt;span&gt;文档等磁盘上的文件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.3. &lt;strong&gt;非结构化数据查询方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;&lt;span&gt;顺序扫描法&lt;/span&gt;(Serial Scanning)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用&lt;/span&gt;windows&lt;span&gt;的搜索也可以搜索文件内容，只是相当的慢。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（2）&lt;strong&gt;&lt;span&gt;全文检索&lt;/span&gt;(Full-text Search)&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span&gt;字典&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据&lt;/span&gt;——&lt;span&gt;也即对字的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;这种先建立索引，再对索引进行搜索的过程就叫全文检索&lt;/span&gt;(Full-text Search)&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。&lt;/p&gt;
&lt;h2&gt;3.4. &lt;strong&gt;如何实现全文检索&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;Lucene&lt;span&gt;实现全文检索。&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.5. &lt;strong&gt;全文检索的应用场景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、&lt;/span&gt;Google&lt;span&gt;等搜索引擎、论坛站内搜索、电商网站站内搜索等。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;4.1. &lt;strong&gt;索引和搜索流程图&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213228919-731064707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1&lt;span&gt;、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档&lt;/p&gt;

&lt;p&gt;2&lt;span&gt;、红色表示搜索&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;，从索引库中搜索内容，搜索过程包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果&lt;/p&gt;

&lt;h2&gt;4.2. &lt;strong&gt;创建索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（&lt;/span&gt;index&lt;span&gt;）中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。&lt;/p&gt;

&lt;h3&gt;4.2.1. &lt;strong&gt;获得原始文档&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原始文档&lt;/strong&gt;&lt;span&gt;是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本案例中的原始内容就是磁盘上的文件，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213629237-897660206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Internet&lt;span&gt;上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Lucene&lt;span&gt;不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nutch&lt;span&gt;（&lt;/span&gt;&lt;a href=&quot;http://lucene.apache.org/nutch&quot;&gt;&lt;span&gt;http://lucene.apache.org/nutch&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）&lt;/span&gt;, Nutch&lt;span&gt;是&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;的一个子项目，包括大规模爬虫工具，能够抓取和分辨&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;网站数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jsoup（&lt;span&gt;http://jsoup.org/&lt;/span&gt;&lt;span&gt; &lt;/span&gt;），jsoup &lt;span&gt;是一款&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt; &lt;span&gt;的&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;解析器，可直接解析某个&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址、&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;文本内容。它提供了一套非常省力的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，可通过&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;span&gt;以及类似于&lt;/span&gt;&lt;span&gt;jQuery&lt;/span&gt;&lt;span&gt;的操作方法来取出和操作数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;heritrix&lt;span&gt;（&lt;/span&gt;&lt;span&gt;http://sourceforge.net/projects/archive-crawler/files&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;Heritrix &lt;span&gt;是一个由&lt;/span&gt; &lt;span&gt;java&lt;/span&gt; &lt;span&gt;开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于&lt;/span&gt;pdf&lt;span&gt;、&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;xls&lt;/span&gt;&lt;span&gt;等文件可通过第三方提供的解析工具读取文件内容，比如&lt;/span&gt;&lt;span&gt;Apache POI&lt;/span&gt;&lt;span&gt;读取&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;xls&lt;/span&gt;&lt;span&gt;的文件内容。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.2.2. &lt;strong&gt;创建文档对象&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（&lt;/span&gt;Document&lt;span&gt;），文档中包括一个一个的域（&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;），域中存储内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们可以将磁盘上的一个文件当成一个&lt;/span&gt;document&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;中包括一些&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;文件名称、&lt;/span&gt;&lt;span&gt;file_path&lt;/span&gt;&lt;span&gt;文件路径、&lt;/span&gt;&lt;span&gt;file_size&lt;/span&gt;&lt;span&gt;文件大小、&lt;/span&gt;&lt;span&gt;file_content&lt;/span&gt;&lt;span&gt;文件内容），如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213736863-1494691952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：每个&lt;/span&gt;Document&lt;span&gt;可以有多个&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，不同的&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;可以有不同的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，同一个&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;可以有相同的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;（域名和域值都相同）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个文档都有一个唯一的编号，就是文档&lt;/span&gt;id&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.2.3. &lt;strong&gt;分析文档&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将原始内容创建为包含域（&lt;/span&gt;Field&lt;span&gt;）的文档（&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;比如下边的文档经过分析如下：&lt;/p&gt;
&lt;p&gt;原文档内容：&lt;/p&gt;
&lt;p&gt;Lucene is a Java full-text search engine.  Lucene is not a complete&lt;/p&gt;
&lt;p&gt;application, but rather a code library and API that can easily be used&lt;/p&gt;
&lt;p&gt;to add search capabilities to applications.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分析后得到的&lt;/span&gt;&lt;span&gt;语汇单元&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lucene&lt;span&gt;、&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;full&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;search&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;engine&lt;/span&gt;&lt;span&gt;。。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个单词叫做一个&lt;/span&gt;Term&lt;span&gt;，不同的域中拆分出来的相同的单词是不同的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;中包含两部分一部分是文档的域名，另一部分是单词的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：文件名中包含&lt;/span&gt;apache&lt;span&gt;和文件内容中包含的&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;是不同的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2.4. &lt;strong&gt;创建索引&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到&lt;/span&gt;Document&lt;span&gt;（文档）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213801221-1541944283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫&lt;strong&gt;倒排索引结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;倒排索引结构&lt;/strong&gt;&lt;span&gt;是根据内容（词语）找文档，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213813023-1028085089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;4.3. &lt;strong&gt;查询索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（&lt;/span&gt;index&lt;span&gt;）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3.1. &lt;strong&gt;用户查询接口&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213829062-392980554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Lucene&lt;span&gt;不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.3.2. &lt;strong&gt;创建查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的&lt;/span&gt;Field&lt;span&gt;文档域、查询关键字等，查询对象会生成具体的查询语法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法&lt;/span&gt; “&lt;span&gt;fileName:lucene&lt;/span&gt;&lt;span&gt;”表示要搜索&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域的内容为“&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;”的文档&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3.3. &lt;strong&gt;执行查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;搜索索引过程：&lt;/p&gt;
&lt;p&gt;根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如搜索语法为&lt;/span&gt;“&lt;span&gt;fileName:lucene&lt;/span&gt;&lt;span&gt;”表示搜索出&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;域中包含&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;搜索过程就是在索引上查找域为&lt;/span&gt;fileName&lt;span&gt;，并且关键字为&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;，并根据&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;找到文档&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213840644-1164666734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.3.4. &lt;strong&gt;渲染结果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213849374-321446141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h2&gt;5.1. &lt;strong&gt;Lucene&lt;span&gt;下载&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Lucene&lt;span&gt;是开发全文检索功能的工具包，从官方网站下载&lt;/span&gt;&lt;span&gt;Lucene4.10.3&lt;/span&gt;&lt;span&gt;，并解压。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;http://lucene.apache.org/&quot;&gt;&lt;span&gt;http://lucene.apache.org/&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本：&lt;/span&gt;lucene4.10.3&lt;/p&gt;
&lt;p&gt;Jdk&lt;span&gt;要求：&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;以上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IDE&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Eclipse&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5.2. &lt;strong&gt;&lt;span&gt;使用的&lt;/span&gt;jar&lt;span&gt;包&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213900041-401003656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213910414-952187178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Lucene&lt;span&gt;包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lucene-core-4.10.3.jar&lt;/p&gt;
&lt;p&gt;lucene-analyzers-common-4.10.3.jar&lt;/p&gt;
&lt;p&gt;lucene-queryparser-4.10.3.jar&lt;/p&gt;

&lt;p&gt;其它：&lt;/p&gt;
&lt;p&gt;commons-io-2.4.jar&lt;/p&gt;
&lt;p&gt;junit-4.9.jar&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;indexwriter&lt;span&gt;对象创建索引&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.1. &lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;java&lt;span&gt;工程，并导入&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;indexwriter&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）&lt;span&gt;指定索引库的存放位置&lt;/span&gt;Directory&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2）指定一个分析器，对文档内容进行分析。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建&lt;/span&gt;document&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：创建&lt;/span&gt;field&lt;span&gt;对象，将&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;添加到&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;indexwriter&lt;span&gt;对象将&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象写入索引库，此过程进行索引创建。并将索引和&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象写入索引库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：关闭&lt;/span&gt;IndexWriter&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.2. &lt;strong&gt;Field&lt;span&gt;域的属性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是否分析&lt;/strong&gt;：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否索引&lt;/strong&gt;&lt;span&gt;：将&lt;/span&gt;Field&lt;span&gt;分析后的词或整个&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;值进行索引，只有索引方可搜索到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否存储&lt;/strong&gt;&lt;span&gt;：将&lt;/span&gt;Field&lt;span&gt;值存储在文档中，存储在文档中的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;才可以从&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;中获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：商品名称、订单号，凡是将来要从&lt;/span&gt;Document&lt;span&gt;中获取的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;都要存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;是否存储的标准：是否要将内容展示给用户&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Field&lt;span&gt;类&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数据类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Analyzed&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否分析&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Indexed&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否索引&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Stored&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;StringField(FieldName, FieldValue,Store.YES))&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;字符串&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建一个字符串&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，但是不会进行分析，会将整个串存储在索引中，&lt;/span&gt;比如&lt;span&gt;(&lt;/span&gt;订单号,&lt;span&gt;姓名等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储在文档中用Store.YES&lt;span&gt;或&lt;/span&gt;Store.NO&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;LongField(FieldName, FieldValue,Store.YES)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Long&lt;span&gt;型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建一个&lt;span&gt;Long&lt;/span&gt;&lt;span&gt;数字型&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，进行分析和索引，&lt;/span&gt;比如&lt;span&gt;(&lt;/span&gt;价格)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储在文档中用Store.YES&lt;span&gt;或&lt;/span&gt;Store.NO&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;center&quot;&gt;StoredField(FieldName, FieldValue) &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;重载方法，支持多种类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建不同类型&lt;span&gt;Field&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;不分析，不索引，但要&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;存储在文档中&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;10&quot;&gt;
&lt;p align=&quot;center&quot;&gt;TextField(FieldName, FieldValue, Store.NO)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;或&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;TextField(FieldName, reader)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;字符串&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;或&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;流&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;如果是一个&lt;span&gt;Reader, lucene&lt;/span&gt;&lt;span&gt;猜测内容比较多&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会采用&lt;/span&gt;&lt;span&gt;Unstored&lt;/span&gt;&lt;span&gt;的策略&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;6.3. &lt;strong&gt;代码实现&lt;/strong&gt; &lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; createIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定索引库存放的路径
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;D:\temp\0108\index&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引库还可以存放到内存中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Directory directory = new RAMDirectory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个标准分析器&lt;/span&gt;
        Analyzer analyzer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardAnalyzer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexwriterCofig对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二根参数：分析器对象&lt;/span&gt;
        IndexWriterConfig config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriterConfig(Version.LATEST, analyzer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexwriter对象&lt;/span&gt;
        IndexWriter indexWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriter(directory, config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始文档的路径D:\传智播客\01.课程\04.lucene\01.参考资料\searchsource&lt;/span&gt;
        File dir = &lt;span&gt;new&lt;/span&gt; File(&quot;D:\\传智播客\\01.课程\\04.lucene\\01.参考资料\\searchsource&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File f : dir.listFiles()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件名&lt;/span&gt;
            String fileName =&lt;span&gt; f.getName();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;
            String fileContent =&lt;span&gt; FileUtils.readFileToString(f);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;
            String filePath =&lt;span&gt; f.getPath();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件的大小&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; fileSize  =&lt;span&gt; FileUtils.sizeOf(f);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件名域
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数：域的名称
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数：域的内容
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三个参数：是否存储&lt;/span&gt;
            Field fileNameField = &lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;&lt;span&gt;, fileName, Store.YES);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件内容域&lt;/span&gt;
            Field fileContentField = &lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;&lt;span&gt;, fileContent, Store.YES);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径域（不分析、不索引、只存储）&lt;/span&gt;
            Field filePathField = &lt;span&gt;new&lt;/span&gt; StoredField(&quot;path&quot;&lt;span&gt;, filePath);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件大小域&lt;/span&gt;
            Field fileSizeField = &lt;span&gt;new&lt;/span&gt; LongField(&quot;size&quot;&lt;span&gt;, fileSize, Store.YES);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建document对象&lt;/span&gt;
            Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            document.add(fileNameField);
            document.add(fileContentField);
            document.add(filePathField);
            document.add(fileSizeField);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建索引，并写入索引库&lt;/span&gt;
&lt;span&gt;            indexWriter.addDocument(document);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;br/&gt;6.4. &lt;/span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;Luke&lt;span&gt;工具查看索引文件&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214024901-335546746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;7.1. &lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;Directory&lt;span&gt;对象，也就是索引库存放的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;indexReader&lt;span&gt;对象，需要指定&lt;/span&gt;&lt;span&gt;Directory&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：创建一个&lt;/span&gt;indexsearcher&lt;span&gt;对象，需要指定&lt;/span&gt;&lt;span&gt;IndexReader&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：创建一个&lt;/span&gt;TermQuery&lt;span&gt;对象，指定查询的域和查询的关键词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第五步：执行查询。&lt;/p&gt;
&lt;p&gt;第六步：返回查询结果。遍历查询结果并输出。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：关闭&lt;/span&gt;IndexReader&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;7.2. &lt;strong&gt;IndexSearcher&lt;span&gt;搜索方法&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot;&gt;
&lt;p align=&quot;center&quot;&gt;方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;indexSearcher.search(query, n)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;indexSearcher.search(query, filter, n)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加过滤策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;indexSearcher.search(query, n, sort)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加排序策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;indexSearcher.search(booleanQuery, filter, n, sort)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加过滤策略，添加排序策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;7.3. &lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询索引库&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; searchIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定索引库存放的路径
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;D:\temp\0108\index&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexReader对象&lt;/span&gt;
        IndexReader indexReader =&lt;span&gt; DirectoryReader.open(directory);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexsearcher对象&lt;/span&gt;
        IndexSearcher indexSearcher = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexSearcher(indexReader);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是查询对象，第二个参数是查询结果返回的最大值&lt;/span&gt;
        TopDocs topDocs = indexSearcher.search(query, 10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询结果的总条数&lt;/span&gt;
        System.out.println(&quot;查询结果的总条数：&quot;+&lt;span&gt; topDocs.totalHits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历查询结果
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;topDocs.scoreDocs存储了document对象的id&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ScoreDoc scoreDoc : topDocs.scoreDocs) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;scoreDoc.doc属性就是document对象的id
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据document的id找到document对象&lt;/span&gt;
            Document document =&lt;span&gt; indexSearcher.doc(scoreDoc.doc);
            System.out.println(document.get(&lt;/span&gt;&quot;filename&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(document.get(&quot;content&quot;));&lt;/span&gt;
            System.out.println(document.get(&quot;path&quot;&lt;span&gt;));
            System.out.println(document.get(&lt;/span&gt;&quot;size&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexreader对象&lt;/span&gt;
&lt;span&gt;        indexReader.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;7.4. &lt;strong&gt;TopDocs&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Lucene&lt;span&gt;搜索结果可通过&lt;/span&gt;&lt;span&gt;TopDocs&lt;/span&gt;&lt;span&gt;遍历，&lt;/span&gt;&lt;span&gt;TopDocs&lt;/span&gt;&lt;span&gt;类提供了少量的属性，如下：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p align=&quot;center&quot;&gt;方法或属性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p&gt;totalHits&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配搜索条件的总记录数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p&gt;scoreDocs&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot;&gt;
&lt;p&gt;顶部匹配记录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;Search&lt;span&gt;方法需要指定匹配记录数量&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;indexSearcher.search(query, n)&lt;/p&gt;
&lt;p&gt;TopDocs.totalHits：是匹配索引库中所有记录的数量&lt;/p&gt;
&lt;p&gt;TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search&lt;span&gt;方法指定的参数&lt;/span&gt;n&lt;/p&gt;


&lt;h2&gt;8.1. &lt;strong&gt;&lt;span&gt;分析器（&lt;/span&gt;Analyzer&lt;span&gt;）的执行过程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如下图是语汇单元的生成过程：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214103187-1369029134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;从一个&lt;/span&gt;Reader&lt;span&gt;字符流开始，创建一个基于&lt;/span&gt;&lt;span&gt;Reader&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Tokenizer&lt;/span&gt;&lt;span&gt;分词器，经过三个&lt;/span&gt;&lt;span&gt;TokenFilter&lt;/span&gt;&lt;span&gt;生成语汇单元&lt;/span&gt;&lt;span&gt;Tokens&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要看分析器的分析效果，只需要看&lt;/span&gt;Tokenstream&lt;span&gt;中的内容就可以了。每个分析器都有一个方法&lt;/span&gt;&lt;span&gt;tokenStream&lt;/span&gt;&lt;span&gt;，返回一个&lt;/span&gt;&lt;span&gt;tokenStream&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;8.2. &lt;strong&gt;分析器的分词效果&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看标准分析器的分词效果&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTokenStream() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个标准分析器对象&lt;/span&gt;
        Analyzer analyzer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardAnalyzer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得tokenStream对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数：域名，可以随便给一个
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数：要分析的文本内容&lt;/span&gt;
        TokenStream tokenStream = analyzer.tokenStream(&quot;test&quot;, &quot;The Spring Framework provides a comprehensive programming and configuration model.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个引用，可以获得每个关键词&lt;/span&gt;
        CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个偏移量的引用，记录了关键词的开始位置以及结束位置&lt;/span&gt;
        OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将指针调整到列表的头部&lt;/span&gt;
&lt;span&gt;        tokenStream.reset();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历关键词列表，通过incrementToken方法判断列表是否结束&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(tokenStream.incrementToken()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键词的起始位置&lt;/span&gt;
            System.out.println(&quot;start-&amp;gt;&quot; +&lt;span&gt; offsetAttribute.startOffset());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取关键词&lt;/span&gt;
&lt;span&gt;            System.out.println(charTermAttribute);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束位置&lt;/span&gt;
            System.out.println(&quot;end-&amp;gt;&quot; +&lt;span&gt; offsetAttribute.endOffset());
        }
        tokenStream.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;8.3. &lt;/span&gt;&lt;strong&gt;中文分析器&lt;/strong&gt; &lt;/p&gt;
&lt;h3&gt;8.3.1. &lt;strong&gt;Lucene&lt;span&gt;自带中文分词器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;18&quot;&gt;l StandardAnalyzer：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单字分词：就是按照中文一个字一个字地进行分词。如：&lt;/span&gt;“我爱中国”&lt;span&gt;，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;效果：&lt;/span&gt;“&lt;span&gt;我&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;爱”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;国&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;l CJKAnalyzer&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二分法分词：按两个字进行切分。如：&lt;/span&gt;“&lt;span&gt;我&lt;/span&gt;是&lt;span&gt;中国人&lt;/span&gt;”&lt;span&gt;，效果：&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;我&lt;/span&gt;是”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;是&lt;span&gt;中&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;“国人”&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上边两个分词器无法满足需求。&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;l SmartChineseAnalyzer&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理&lt;/p&gt;
&lt;h3&gt;8.3.2. &lt;strong&gt;第三方中文分析器&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;paoding： 庖丁解牛最新版在 &lt;a href=&quot;https://code.google.com/p/paoding/&quot;&gt;&lt;span&gt;https://code.google.com/p/paoding/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;中最多支持&lt;/span&gt;Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。&lt;/li&gt;
&lt;li&gt;mmseg4j：最新版已从 &lt;a href=&quot;https://code.google.com/p/mmseg4j/&quot;&gt;&lt;span&gt;https://code.google.com/p/mmseg4j/&lt;/span&gt;&lt;/a&gt; 移至 &lt;a href=&quot;https://github.com/chenlb/mmseg4j-solr&quot;&gt;&lt;span&gt;https://github.com/chenlb/mmseg4j-solr&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，支持&lt;/span&gt;Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了mmseg算法。&lt;/li&gt;
&lt;li&gt;IK-analyzer： 最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。&lt;/li&gt;
&lt;li&gt;ansj_seg：最新版本在 &lt;a href=&quot;https://github.com/NLPchina/ansj_seg&quot;&gt;&lt;span&gt;https://github.com/NLPchina/ansj_seg&lt;/span&gt;&lt;/a&gt; tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。&lt;/li&gt;
&lt;li&gt;imdict-chinese-analyzer：最新版在 &lt;a href=&quot;https://code.google.com/p/imdict-chinese-analyzer/&quot;&gt;&lt;span&gt;https://code.google.com/p/imdict-chinese-analyzer/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;，&lt;/span&gt; &lt;span&gt;最新更新也在&lt;/span&gt;2009年5月，下载源码，不支持Lucene 4.10 。是利用HMM（隐马尔科夫链）算法。&lt;/li&gt;
&lt;li&gt;Jcseg：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用mmseg算法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;8.3.3. &lt;strong&gt;IKAnalyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214236624-1982051588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：把&lt;/span&gt;jar&lt;span&gt;包添加到工程中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：把配置文件和扩展词典和停用词词典添加到&lt;/span&gt;classpath&lt;span&gt;下&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注&lt;span&gt;意：&lt;/span&gt;mydict.dic&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ext_stopword.dic&lt;/span&gt;&lt;span&gt;文件的格式为&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;，注意是&lt;/span&gt;&lt;span&gt;无&lt;/span&gt;BOM &lt;span&gt;的&lt;/span&gt;UTF-8 &lt;span&gt;编码&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;使用EditPlus.exe&lt;span&gt;保存为&lt;/span&gt;&lt;span&gt;无&lt;/span&gt;BOM &lt;span&gt;的&lt;/span&gt;&lt;span&gt;UTF-8 &lt;/span&gt;&lt;span&gt;编码&lt;/span&gt;格式，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214242907-2011219071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;8.4. &lt;strong&gt;Analyzer&lt;span&gt;使用时机&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;8.4.1. &lt;strong&gt;&lt;span&gt;索引时使用&lt;/span&gt;Analyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入关键字进行搜索，当需要让该关键字与文档域内容所包含的词进行匹配时需要对文档域内容进行分析，需要经过Analyzer&lt;span&gt;分析器处理生成语汇单元（&lt;/span&gt;Token&lt;span&gt;）。分析器分析的对象是文档中的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域。当&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的属性&lt;/span&gt;tokenized&lt;span&gt;（是否分词）为&lt;/span&gt;true&lt;span&gt;时会对&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;值进行分析，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214249779-1867569561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一些&lt;/span&gt;Field&lt;span&gt;可以不用分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、不作为查询条件的内容，比如文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、不是匹配内容中的词而匹配&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的整体内容，比如订单号、身份证号等。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.4.2. &lt;strong&gt;&lt;span&gt;搜索时使用&lt;/span&gt;Analyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对搜索关键字进行分析和索引分析一样，使用&lt;/span&gt;Analyzer&lt;span&gt;对搜索关键字进行分析、分词处理，使用分析后每个词语进行搜索。比如：搜索关键字：&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;pring web &lt;span&gt;，经过分析器进行分词，得出：&lt;/span&gt;spring  web&lt;span&gt;拿词去索引词典表查找&lt;/span&gt; &lt;span&gt;，找到索引链接到&lt;/span&gt;Document&lt;span&gt;，解析&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于匹配整体&lt;/span&gt;Field&lt;span&gt;域的查询可以在搜索时不分析，比如根据订单号、身份证号查询等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：搜索使用的分析器要和索引使用的分析器一致。&lt;/strong&gt;&lt;/p&gt;


&lt;h2&gt;9.1. &lt;strong&gt;索引库的添加&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;9.1.1. &lt;strong&gt;步骤&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;向索引库中添加&lt;/span&gt;document&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：先创建一个&lt;/span&gt;indexwriter&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;document&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：把&lt;/span&gt;document&lt;span&gt;对象写入索引库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：关闭&lt;/span&gt;indexwriter&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.1.2. &lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addDocument() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引库存放路径&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        
        IndexWriterConfig config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IndexWriterConfig(Version.LATEST, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个indexwriter对象&lt;/span&gt;
        IndexWriter indexWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriter(directory, config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Document对象&lt;/span&gt;
        Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向document对象中添加域。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不同的document可以有不同的域，同一个document可以有相同的域。&lt;/span&gt;
        document.add(&lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;, &quot;新添加的文档&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;新添加的文档的内容&quot;&lt;span&gt;, Store.NO));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;新添加的文档的内容第二个content&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content1&quot;, &quot;新添加的文档的内容要能看到&quot;&lt;span&gt;, Store.YES));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加文档到索引库&lt;/span&gt;
&lt;span&gt;        indexWriter.addDocument(document);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;9.2. &lt;/span&gt;&lt;strong&gt;索引库删除&lt;/strong&gt; &lt;/p&gt;
&lt;h3&gt;9.2.1. &lt;strong&gt;删除全部&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除全部索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAllIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除全部索引&lt;/span&gt;
&lt;span&gt;        indexWriter.deleteAll();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。 &lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;此方法慎用！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;9.2.2. &lt;strong&gt;指定查询条件删除&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据查询条件删除索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteIndexByQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个查询条件&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据查询条件删除&lt;/span&gt;
&lt;span&gt;        indexWriter.deleteDocuments(query);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;9.3. &lt;/span&gt;&lt;strong&gt;索引库的修改&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;原理就是先删除后添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改索引库&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Document对象&lt;/span&gt;
        Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向document对象中添加域。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不同的document可以有不同的域，同一个document可以有相同的域。&lt;/span&gt;
        document.add(&lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;, &quot;要更新的文档&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。&quot;&lt;span&gt;, Store.YES));
        indexWriter.updateDocument(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;java&quot;&lt;span&gt;), document);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexWriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10. &lt;/span&gt;&lt;strong&gt;Lucene&lt;span&gt;索引库查询（重点）&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;对要搜索的信息创建Query&lt;span&gt;查询对象，&lt;/span&gt;Lucene&lt;span&gt;会根据&lt;/span&gt;Query&lt;span&gt;查询对象生成最终的查询语法，类似关系数据库&lt;/span&gt;Sql&lt;span&gt;语法一样&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;也有自己的查询语法，比如：“&lt;/span&gt;&lt;span&gt;name:lucene&lt;/span&gt;&lt;span&gt;”表示查询&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;为“&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;”的文档信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可通过两种方法创建查询对象：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;提供&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Query&lt;span&gt;是一个抽象类，&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;提供了很多查询对象，比如&lt;/span&gt;&lt;span&gt;TermQuery&lt;/span&gt;&lt;span&gt;项精确查询，&lt;/span&gt;&lt;span&gt;NumericRangeQuery&lt;/span&gt;&lt;span&gt;数字范围查询等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;name&quot;, &quot;lucene&quot;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;QueryParse&lt;/span&gt;&lt;span&gt;解析查询表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;QueryParse&lt;span&gt;会将用户输入的查询表达式解析成&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    QueryParser queryParser = &lt;span&gt;new&lt;/span&gt; QueryParser(&quot;name&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;name:lucene&quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;10.1. &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;query&lt;span&gt;的子类查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;10.1.1. &lt;strong&gt;MatchAllDocsQuery&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用MatchAllDocsQuery查询索引目录中的所有文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMatchAllDocsQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询条件&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MatchAllDocsQuery();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.2. &lt;/span&gt;&lt;strong&gt;TermQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;TermQuery&lt;span&gt;，通过项查询，&lt;/span&gt;&lt;span&gt;TermQuery&lt;/span&gt;&lt;span&gt;不使用分析器所以建议匹配不分词的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域查询，比如订单号、分类&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;号等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;指定要查询的域和要查询的关键词。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Termquery查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTermQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询对象&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;lucene&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
        TopDocs topDocs = indexSearcher.search(query, 10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共查询到的document个数&lt;/span&gt;
        System.out.println(&quot;查询结果总数量：&quot; +&lt;span&gt; topDocs.totalHits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历查询结果&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ScoreDoc scoreDoc : topDocs.scoreDocs) {
            Document document &lt;/span&gt;=&lt;span&gt; indexSearcher.doc(scoreDoc.doc);
            System.out.println(document.get(&lt;/span&gt;&quot;filename&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(document.get(&quot;content&quot;));&lt;/span&gt;
            System.out.println(document.get(&quot;path&quot;&lt;span&gt;));
            System.out.println(document.get(&lt;/span&gt;&quot;size&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexreader&lt;/span&gt;
&lt;span&gt;        indexSearcher.getIndexReader().close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.3. &lt;/span&gt;&lt;strong&gt;NumericRangeQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可以根据数值范围查询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数值范围查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testNumericRangeQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数：
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.域名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.最小值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最大值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.是否包含最小值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.是否包含最大值&lt;/span&gt;
        Query query = NumericRangeQuery.newLongRange(&quot;size&quot;, 1l, 1000l, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.4. &lt;/span&gt;&lt;strong&gt;BooleanQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可以组合查询条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合条件查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testBooleanQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个布尔查询对象&lt;/span&gt;
        BooleanQuery query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BooleanQuery();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个查询条件&lt;/span&gt;
        Query query1 = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        Query query2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合查询条件&lt;/span&gt;
&lt;span&gt;        query.add(query1, Occur.MUST);
        query.add(query2, Occur.MUST);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Occur.MUST&lt;span&gt;：必须满足此条件，相当于&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Occur.SHOULD&lt;span&gt;：应该满足，但是不满足也可以，相当于&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Occur.MUST_NOT&lt;span&gt;：必须不满足。相当于&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;10.2. &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;queryparser&lt;span&gt;查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;QueryParser&lt;span&gt;也可以创建&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;QueryParser&lt;/span&gt;&lt;span&gt;提供一个&lt;/span&gt;&lt;span&gt;Parse&lt;/span&gt;&lt;span&gt;方法，此方法可以直接根据查询语法来查询。&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;对象执行的查询语法可通过&lt;/span&gt;System.out.println(query);&lt;span&gt;查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。&lt;/p&gt;

&lt;h3&gt;10.2.1. &lt;strong&gt;QueryParser&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;需要加入&lt;/span&gt;queryParser&lt;span&gt;依赖的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214519545-293585767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;1.1.1.1 &lt;strong&gt;程序实现&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueryParser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建queryparser对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数默认搜索的域
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数就是分析器对象&lt;/span&gt;
        QueryParser queryParser = &lt;span&gt;new&lt;/span&gt; QueryParser(&quot;content&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;Lucene是java开发的&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;1.1.1.2 &lt;/span&gt;&lt;strong&gt;查询语法&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、基础的查询语法，关键词查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;域名&lt;/span&gt;+&lt;span&gt;“：”&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;搜索的关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;content:java&lt;/p&gt;
&lt;p&gt;2、范围查询&lt;/p&gt;
&lt;p&gt;&lt;span&gt;域名&lt;/span&gt;+&lt;span&gt;“&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;+[&lt;/span&gt;&lt;span&gt;最小值&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;最大值&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;size:[1 TO 1000]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围查询在&lt;/span&gt;lucene&lt;span&gt;中支持数值类型，不支持字符串类型。在&lt;/span&gt;&lt;span&gt;solr&lt;/span&gt;&lt;span&gt;中支持字符串类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、组合条件查询&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1 +&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：两个条件之间是并且的关系&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;+filename:apache +content:apache&lt;/p&gt;
&lt;p&gt;2）+&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：必须满足第一个条件，应该满足第二个条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;+filename:apache content:apache&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;条件&lt;/span&gt;1 &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：两个条件满足其一即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;filename:apache content:apache&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：必须不满足条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，要满足条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;-filename:apache content:apache&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.MUST 查询条件必须满足，相当于and&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;+&lt;span&gt;（加号）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.SHOULD 查询条件可选，相当于or&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;空（不用符号）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.MUST_NOT 查询条件不能满足，相当于not非&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;-&lt;span&gt;（减号）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;第二种写法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 AND &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 OR &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 NOT &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.2. &lt;strong&gt;MultiFieldQueryParser&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可以指定多个默认搜索域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMultiFiledQueryParser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以指定默认搜索的域是多个&lt;/span&gt;
        String[] fields = {&quot;filename&quot;, &quot;content&quot;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个MulitFiledQueryParser对象&lt;/span&gt;
        MultiFieldQueryParser queryParser = &lt;span&gt;new&lt;/span&gt; MultiFieldQueryParser(fields, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;java AND apache&quot;&lt;span&gt;);
        System.out.println(query);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  &lt;/p&gt;

</description>
<pubDate>Sat, 14 Jul 2018 13:47:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9311066.html</dc:identifier>
</item>
</channel>
</rss>