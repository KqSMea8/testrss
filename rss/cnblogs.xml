<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一起学Hive——使用MSCK命令修复Hive分区 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9776023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9776023.html</guid>
<description>&lt;p&gt;最近在使用Hive的过程中，在备份数据时，经常会使用cp或mv命令来拷贝数据，将数据拷贝到我们新建备份表的目录下面，如果不是分区表，则上面的操作之后，新建的备份表可以正常使用，但是如果是分区表的，一般都是使用alter table add partition命令将分区信息添加到新建的表中，每添加一条分区信息就执行一个alter table add partition命令，如果分区数量少还好办，但是遇到分区数量多的情况，特别是分区数量大于50的情况，如果还是使用alter命令添加分区，那是一件耗时耗力的事情，还容易出错。&lt;/p&gt;
&lt;p&gt;幸运的是Hive提供了MSCK命令，用于修复表的分区，我们先看Hive官方是如果介绍MCSK命令的：&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;Hive stores a list of partitions for each table in its metastore. If, however, new partitions are directly added to HDFS (say by using hadoop fs -put command), the metastore (and hence Hive) will not be aware of these partitions unless the user runs ALTER TABLE table_name ADD PARTITION commands on each of the newly added partitions.&lt;br/&gt;However, users can run a metastore check command with the repair table option:&lt;br/&gt;MSCK REPAIR TABLE table_name;&lt;br/&gt;which will add metadata about partitions to the Hive metastore for partitions for which such metadata doesn't already exist. In other words, it will add any partitions that exist on HDFS but not in metastore to the metastore. See HIVE-874 for more details. When there is a large number of untracked partitions, there is a provision to run MSCK REPAIR TABLE batch wise to avoid OOME. By giving the configured batch size for the property hive.msck.repair.batch.size it can run in the batches internally. The default value of the property is zero, it means it will execute all the partitions at once.&lt;br/&gt;The equivalent command on Amazon Elastic MapReduce (EMR)'s version of Hive is:&lt;br/&gt;ALTER TABLE table_name RECOVER PARTITIONS;&lt;br/&gt;Starting with Hive 1.3, MSCK will throw exceptions if directories with disallowed characters in partition values are found on HDFS. Use hive.msck.path.validation setting on the client to alter this behavior; &quot;skip&quot; will simply skip the directories. &quot;ignore&quot; will try to create partitions anyway (old behavior). This may or may not work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译成中文的大概意思就是：Hive将每个表的分区信息保存在metastore中，如果通过hadoop fs -put命令直接将分区信息添加到HDFS，metastore是不会感知到这些新增的分区，除非执行了ALTER TABLE table_name ADD PARTITION命令。但是用户可以运行metastore检查命令&lt;code&gt;MSCK REPAIR TABLE table_name;&lt;/code&gt;该命令将关于分区的元信息添加到Hive metastore中，这是对于那些没有元信息的分区来说的。换句话说，就是将任何存在于HDFS上但不在metastore上的分区添加到metastore。&lt;/p&gt;
&lt;p&gt;下面介绍如果使用MSCK命令，创建了一个bigdata17_partition表，然后通过cp命令将几个目录的文件拷贝到bigdata17_partition目录下面，然后执行show partitions bigdata17_partition命令，将不会显示分区的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hive&amp;gt; show partitions bigdata17_partition;
OK
Time taken: 1.121 seconds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行MSCK REPAIR TABLE bigdata17_partition;命令添加分区：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hive&amp;gt; MSCK REPAIR TABLE bigdata17_partition;
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 10124
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 21234
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 346783
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 2532162
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 2901198
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 3129087
18/10/11 17:27:15 WARN log: Updating partition stats fast for: bigdata17_partition;
18/10/11 17:27:15 WARN log: Updated size to 23190876
OK
Partitions not in metastore:    bigdata17_partition;:dt=2018-09-15    bigdata17_partition;:dt=2018-09-16    bigdata17_partition;:dt=2018-09-17    bigdata17_partition;:dt=2018-09-18    bigdata17_partition;:dt=2018-09-19     bigdata17_partition;:dt=2018-09-20    bigdata17_partition;:dt=2018-09-21
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-15
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-16
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-17
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-18
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-19
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-20
Repair: Added partition to metastore bigdata17_partition;:dt=2018-09-21
Time taken: 0.613 seconds, Fetched 8 row(s)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述的结果可以看到已经将bigdata17_partition表的分区信息添加到Hive metastore中，和add partition命令比起来既方便又高效。&lt;/p&gt;
&lt;p&gt;有点需要注意的是，分区的目录结构必遵循&lt;br/&gt;/partition_name=partition_value/结构，否则msck无法自动添加分区，只能使用add partition命令。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 22:08:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>最近在使用Hive的过程中，在备份数据时，经常会使用cp或mv命令来拷贝数据，将数据拷贝到我们新建备份表的目录下面，如果不是分区表，则上面的操作之后，新建的备份表可以正常使用，但是如果是分区表的，一般</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9776023.html</dc:identifier>
</item>
<item>
<title>相信机遇只能改变环境，努力是用来改变自己的。 - 买辣椒也用券</title>
<link>http://www.cnblogs.com/Juaoie/p/9764137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Juaoie/p/9764137.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这段时间没事的时候都在看园子里的博客或者微信订阅号里的文章，不是看什么技术文档，而是看看这些计算机前辈们的心灵鸡汤。最近有些焦虑，可能是因为大三即将毕业，考虑升本还是工作问题，考虑自己所学是否能所用的问题，考虑个人能力问题以及私人的问题。写这篇博客只是为了记录一下即将毕业的我的想法，以免以后对现在做出的选择后悔。先来点鸡汤，哈哈。&lt;/p&gt;
&lt;p&gt;因为我是一名高职生，所以我身边难免会有些自甘堕落的人，每当这些人和我谈心论志的时候，都会和我谈什么“天才论”、“机遇论”。所谓的“天才论”就是相信有比自己优秀的人都是有天赋，相信那些考985、211的人都是天才，都是智力超群的人。所谓“机遇论”就是说那些本来因该和自己一样平庸的人，或者说和自己一样文凭的人混的比自己好，就说别人是因为机遇好。不要只看得到别人的成功，还得看的到别人的努力。而我以前一直想给别人灌输思想是“只要努力就没有不能做到的”，但现在不这样了，因为比事实更难改变的是人的思想（哪怕你用事实证明一些错误的思想，他也不愿意承认。），不得不承认，这世上确实有一些极少数天才，但确不是那些比你强的人都是天才，也有些人机遇确实比你好，但是机遇从来都只是改变了他的环境，努力却是用来改变自己的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;假期在公司实习和产里上班的一些心得：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在出学校之前总是幻想自己以后可能在某某公司上班，拿着多少多少工资，然后通过自己的努力一点点的往上面爬，在二十八九的时候成为公司的项目经理或者什么什么职位。第一、你要确认你能承受得住这七八年的社会底层上班族的生活。拿着低薪工资过着拮据生活独自漂泊在无依无靠的大城市并没有你想象中的那么容易度过。想想自己的朋友，想想自己的那些同辈的兄弟姐妹，才会发现自己的脆弱，自己的平庸。第二、程序员这个工资确实消磨人的意志，编程人员做久了都少了年少的几分轻狂，不再喜欢谈心论志了，什么都显的理所应当了，自己的懦弱就显得更加理所应当了。第三、像我们这种技术不怎么样的程序员，只能作为一种编码的工具，何时才能成为像架构师或项目经理那样有独立思维的人呢，为什么说只是一种编码的工具，因为编程其实便不是很复杂的过程，只不过是有些枯燥，编码的过程是很机械化的，你可以想象编码的过程就像产里的技术工人在流水线上工作一样。在不同的公司就是在不同的厂里工作，不同的项目就是不同的流水线，不同的程序语言和框架就是不同的工具和技术。项目不同使用的语言和框架都有所不同，但是语言和框架都好学，就像不同的流水线上的工具和技术都好学，而项目经理就是像厂长去分配谁在什么线上使用什么技术或者工具的人。所以说都说30岁之前是一个程序员最有价值的时候，30岁之后就要转到管理层了，就像一个在厂里接触过各个流水线的工人等到30岁成为厂长是一样的道理。第四、并不是所有的程序员都能混到管理层，就像并不是每个产里的油腻的大叔都是产长，我在厂里见到过很多忙碌的油腻大叔，我在公司也见过很多迷茫的程序员，我害怕成为这样的人。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了不做流水线：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;公司都是这样的，什么样的学历在什么阶段做什么样的事，如果你的学位高又或者认识很多有本事的人，才有机会跳过这样消磨意志的工作。要么出去拼一拼，成与败、累与苦都要自己独自承受，要么踏踏实实留下来提升学历。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;要么什么都懂要么就精通一门：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不要太纠结学什么语言，只要方向是正确的就可以了，因为你所学的语言只是工具，这些都会忘记的，新的工具还在等着你，等你使用过很多工具，那么你离厂长就不远了。如果你精通一样工具，那么你就是专家，想想厂里那些负责技术指导的专家都是怎么样的吧，但是，专家也不是那么好当的，因为工具是会被淘汰的，技术也是要更新的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;随时保持职业微笑：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;保持微信，这是每个职业人应该要学会的。不得不说社会还是现实的，不会保持“微笑”确实会处处碰壁，哪怕已伤痕累累也要强颜微笑、也要苦中作乐，时刻都要告诉自己眼泪是留给自己的，微笑是送给别人的。这也是我在我能接触到的很多成功人士身上总结出来的，那些成功的人总是有一副悦颜的嘴脸，他们的微笑表现的像他们的礼节一样绅士，就像一副被刻意雕刻的小丑面具。他们把职业微笑带到公司，也带回家。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 18:50:00 +0000</pubDate>
<dc:creator>买辣椒也用券</dc:creator>
<og:description>前言： 这段时间没事的时候都在看园子里的博客或者微信订阅号里的文章，不是看什么技术文档，而是看看这些计算机前辈们的心灵鸡汤。最近有些焦虑，可能是因为大三即将毕业，考虑升本还是工作问题，考虑自己所学是否</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Juaoie/p/9764137.html</dc:identifier>
</item>
<item>
<title>JDBC（1）简单介绍/数据库的连接 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9775988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9775988.html</guid>
<description>
&lt;p&gt;&lt;span&gt;初始JDBC：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC是java连接数据库的一个工具，没有这个工具，java将无法和数据库进行连接。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;JDBC API：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC是个“低级”接口，也就是说，他直接用于调用SQL命令。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;JDBC驱动类型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC是应用程序编程接口，描述了在访问关系数据库的标准 java类库。并且还为数据库厂商提供了个标准的体系结构，让厂商&lt;/p&gt;
&lt;p&gt;可以为自己的数据库产品提供IDBC驱动程序，这政驱动程序可以直接访向商的数据产品，从而提高了Java 程序访问数据库&lt;/p&gt;
&lt;p&gt;的效率，在lana程序设计中，JDBC可以分为以下4种驱动。                                                                                                                                                                                     &lt;/p&gt;
&lt;p&gt;1.JBDBC-ODBC&lt;/p&gt;
&lt;p&gt;2.本地API驱动&lt;/p&gt;
&lt;p&gt;3.网络协议驱动&lt;/p&gt;
&lt;p&gt;4.本地协议驱动                                                                                                                                                                                                                                                             &lt;/p&gt;

&lt;p&gt;&lt;span&gt;JDBC&lt;/span&gt;&lt;span&gt;常用接口和类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.DriverManager&lt;/p&gt;
&lt;p&gt;用于管理JDBC驱动的服务类。程序中使用该类主要功能是获取Connection对象。&lt;/p&gt;
&lt;p&gt;2.Connection&lt;/p&gt;
&lt;p&gt;他代表数据库连接对象，每个Connection代表一次物理会话。&lt;/p&gt;
&lt;p&gt;要想访问数据库，必须先获得数据库的连接&lt;/p&gt;
&lt;p&gt;3.Statement&lt;/p&gt;
&lt;p&gt;用于执行SQL的语句的工具接口。&lt;/p&gt;
&lt;p&gt;4.PreparedStatement&lt;/p&gt;
&lt;p&gt;这是一个预编译的Statement对象。&lt;/p&gt;
&lt;p&gt;5.ResultSet&lt;/p&gt;
&lt;p&gt;这是一个得到返回结果的对象，包括查询结果的方法。                       &lt;/p&gt;

&lt;p&gt;&lt;span&gt;JDBC编程的步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.注册数据库驱动&lt;/p&gt;
&lt;p&gt;2.建立连接&lt;/p&gt;
&lt;p&gt;3.获得Statement/PreparedStatement对象&lt;/p&gt;
&lt;p&gt;4.执行sql语句&lt;/p&gt;
&lt;p&gt;5.处理结果集（增删该查）&lt;/p&gt;
&lt;p&gt;6.关闭&lt;/p&gt;
&lt;p&gt;图形过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181012010912320-1735363162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;基本的理论一点的知识介绍的差不多了，剩下的看代码进行解释。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在代码要跑起来了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.使用Driver连接数据库&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;Diver 是一个接口，数据库厂商必须提供的能实现的接口，能从其中获取数据库的连接
&lt;span&gt;建立lib文件
&lt;span&gt;添加jar包
右键--》build path--》add to build path加入到类目录下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; void testjdbc() throws SQLException{&lt;/span&gt;
        
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.创建Driver实现类的对象
        &lt;span&gt;Driver&lt;/span&gt; driver  &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; new com.mysql.jdbc.Driver();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.准备数据库连接到基本信息
        String url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &quot;jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;shijian&quot;;
        Properties info &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; new Properties();
        info.put(&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;, &quot;root&quot;);
        info.put(&quot;password&quot;, &quot;&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;&quot;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.调用Driver的jiekou  Connect(url,info)获取数据库的连接
        Connection connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; driver.connect&lt;/span&gt;(url, info);
        System.out.println(connection);
        connection.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 此时可以成功连接到数据库。&lt;/p&gt;
&lt;p&gt;2.编写一个通用的方法，在不修改源程序情况下，连接数据库&lt;/p&gt;
&lt;p&gt;那么此时我们可以想到的是把连接数据库需要的代码写道配置文件中&lt;/p&gt;
&lt;p&gt;创建db.properties，并且放在类路径下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection() throws Exception{
        String driverClass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String jdbcUrl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String &lt;/span&gt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取jdbc.Properties文件
        InputStream &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; getClass().getClassLoader().getResourceAsStream(&quot;db.properties&quot;);
        
        Properties properties &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; new Properties();
        properties.&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);
        driverClass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;driver&quot;);
        jdbcUrl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;jdbcUrl&quot;);
        &lt;/span&gt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; properties.getProperty(&quot;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;);
        password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;password&quot;);
        
        
        Driver driver &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; (Driver) Class.forName(driverClass).newInstance();
        Properties info &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; new Properties();
        info.put(&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&quot;, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;);
        info.put(&quot;password&quot;, password);
        
        Connection connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; driver.connect(jdbcUrl, info);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connection;        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; db.properties&lt;/p&gt;
&lt;p&gt;这里不仅可以写mysql的还可以写其他的数据连接所需要的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver&lt;span&gt;=&lt;/span&gt;&lt;span&gt;com.mysql.jdbc.Driver
jdbcUrl&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;jdbc:mysql:&lt;span&gt;//&lt;/span&gt;localhost:&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;shijian
&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;root
password&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 3.使用DriverManager&lt;/p&gt;
&lt;p&gt;DriverManager是驱动的管理类&lt;/p&gt;
&lt;pre&gt;
重载的getConnection()方法获取数据库的连接，较为方便
可以同时管理多个驱动，若注册了多个数据库连接，则调用getConnection()方法是传入的值不同，则显示的不同
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; void DriverManager() throws Exception{
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;驱动的全类名
        String driverClass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String jdbcUrl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String &lt;/span&gt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
    &lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取jdbc.Properties文件
        
        InputStream &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; getClass().getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);
        Properties properties &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; new Properties();
        properties.&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;(&lt;span&gt;in&lt;/span&gt;&lt;span&gt;);
        driverClass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;driver&quot;);
        jdbcUrl &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;jdbcUrl&quot;);
        &lt;/span&gt;&lt;span&gt;user&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; properties.getProperty(&quot;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;);
        password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; properties.getProperty(&quot;password&quot;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;DriverManager.getConnection(jdbcUrl, &lt;span&gt;user&lt;/span&gt;&lt;span&gt;, password);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载驱动程序
        Class.forName(driverClass);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过DriverManager的getConnection接口获取数据库的连接
        Connection connection &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; 
                DriverManager&lt;/span&gt;.getConnection(jdbcUrl, &lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;, password);
        System.out.println(connection);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 现在直接使用jdbc的方式连接数据的项目已经很少了，都是框架，但是这里的一些知识在学习中还是很重要的。&lt;/p&gt;

</description>
<pubDate>Thu, 11 Oct 2018 17:24:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>初始JDBC： JDBC是java连接数据库的一个工具，没有这个工具，java将无法和数据库进行连接。 JDBC API： JDBC是个“低级”接口，也就是说，他直接用于调用SQL命令。 JDBC驱动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9775988.html</dc:identifier>
</item>
<item>
<title>Linux常见目录说明 - 吾名墨嗔</title>
<link>http://www.cnblogs.com/myworld5218/p/9775931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld5218/p/9775931.html</guid>
<description>&lt;p&gt;Linux中没有Windows系统中常见的盘符(C盘、D盘等等)，它的目录结构类似树形如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1086987/201810/1086987-20181011225506756-277814797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处于目录最顶层的是系统的根目录，任何目录，文件和设备都在“/”之下，其他的再一级一级分类归属；&lt;/p&gt;
&lt;p&gt;                                                                      &lt;span&gt; Linux 常见目录说明&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;29&quot;&gt;&lt;tr&gt;&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;根目录，文件的最顶端，/etc,/bin,/dev,/lib,/sbin应该和根目录放置在一个分区中，而&lt;/p&gt;
&lt;p&gt;类似/usr/local可以单独位于另一个分区中&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;/bin&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;存放系统所需要的重要命令，比如文件或目录操作的命令ls、cp、mkdir等。另外/usr/bin也&lt;/p&gt;
&lt;p&gt;存放了一些系统命令，这些命令对应的文件都是可执行的，普通用户可以使用其中大部分的命令&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;/boot&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;这是存放Linux启动时内核及引导系统程序所需要的核心文件，内核文件和grub系统引导管理器&lt;/p&gt;
&lt;p&gt;都位于这个目录中&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;/dev&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;存放Linux系统下的设备文件，如光驱、磁盘等，访问该目录下某个文件相当于访问某个硬件设备，&lt;/p&gt;
&lt;p&gt;常用的是挂载光驱&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;/etc&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;一般存放系统的配置文件，作为一些软件启动时默认配置文件读取的目录，如/etc/fstab存放&lt;/p&gt;
&lt;p&gt;系统分区信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;/home&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;系统默认的用户主目录，如果添加用户时不指定用户的主目录，默认在/home下创建与用户名同名 &lt;/p&gt;
&lt;p&gt;的文件夹，代码中可以HOME环境变量表示当前用户的主目录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;64位系统有/lib64文件夹,主要存放动态链接库。类似的目录有/usr/lib、/usr/local/lib等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;存放一些当系统意外崩溃或机器意外关机时产生的文件碎片&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;用于存放挂载存储设备的挂载目录，如光驱等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;/proc&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;存放操作系统运行时的运行目录，如进程信息、内核信息、网络信息等。此目录的内容存在&lt;/p&gt;
&lt;p&gt;于内存中，实际不占用磁盘空间。如/etc/cpuinfo存放CPU的相关信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;Linux超级权限用户root的主目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;/sbin&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;存放一些系统管理的命令，一般只能由超级权限用户root执行，大多数命令普通用户一般无权限执&lt;/p&gt;
&lt;p&gt;行，类似/sbin/ifconfig,普通用户使用绝对路径也可执行，用于查看当前系统的网络配置，类似的&lt;/p&gt;
&lt;p&gt;目录有/usr/sbin;/usr/local/sbin&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;/tmp&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;临时文件目录，任何人都可以访问，系统软件或用户运行程序(如MySQL)时产生的临时文件存放到&lt;/p&gt;
&lt;p&gt;到这里。此目录数据需要定期清除，重要数据不可放置在此目录下，此目录空间不宜过小&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;/usr&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;应用程序存放目录，如命令，帮助文件等。安装Linux软件包时默认安装到/usr/local目录下。&lt;/p&gt;
&lt;p&gt;比如/usr/share/fonts存放系统字体，/usr/share/man存放帮助文档，/usr/include存放软件的&lt;/p&gt;
&lt;p&gt;文件等。/usr/local目录建议单独分区并设置较大的磁盘空间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;/var&lt;/td&gt;
&lt;td&gt;这个目录的内容是经常变动的，/var/log用于存放系统日志，/var/lib存放系统库文件等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;/sys&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;目录与/proc类似，是一个虚拟的文件系统，主要记录与系统核心相关的信息，如系统当前已经转入&lt;/p&gt;
&lt;p&gt;的模块信息等，这个目录实际不占硬盘容量&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;备注:在Linux中一切皆文件 ，包括硬盘、光驱、及其他硬件等都是以文件的形式存在于系统中&lt;/p&gt;
</description>
<pubDate>Thu, 11 Oct 2018 16:33:00 +0000</pubDate>
<dc:creator>吾名墨嗔</dc:creator>
<og:description>Linux中没有Windows系统中常见的盘符(C盘、D盘等等)，它的目录结构类似树形如下图所示: 处于目录最顶层的是系统的根目录，任何目录，文件和设备都在“/”之下，其他的再一级一级分类归属； Li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld5218/p/9775931.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 入门教程 4、ASP.NET Core MVC控制器入门 - ken-io</title>
<link>http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-controller-action.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-controller-action.html</guid>
<description>&lt;h2 id=&quot;H2-0&quot;&gt;一、前言&lt;/h2&gt;
&lt;h3 id=&quot;H3-1&quot;/&gt;
&lt;ul&gt;&lt;li&gt;ASP.NET Core MVC控制器简介&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC控制器操作简介&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC控制器操作简介返回类型简介&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC控制器操作简介返回类型示例&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC控制器参数映射逻辑说明&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC控制器参数映射/获取示例&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;H3-2&quot;/&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;软件/环境&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;Windows 10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SDK&lt;/td&gt;
&lt;td&gt;2.1.401&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ASP.NET Core&lt;/td&gt;
&lt;td&gt;2.1.3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IDE&lt;/td&gt;
&lt;td&gt;Visual Studio Code 1.27&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;浏览器&lt;/td&gt;
&lt;td&gt;Chrome 69&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;本篇代码以下代码进行调整：&lt;a href=&quot;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-02&quot; target=&quot;_blank&quot;&gt;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-02&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;H3-3&quot;/&gt;
&lt;p&gt;你可能需要的前置知识&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MVC框架/模式介绍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/mvc&quot; target=&quot;_blank&quot;&gt;https://baike.baidu.com/item/mvc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;H2-4&quot;/&gt;
&lt;h3 id=&quot;H3-5&quot;/&gt;
&lt;p&gt;在MVC Web框架中，路由模块会对接收到的请求进行匹配并转交由对应的控制器（Controller）进行处理。&lt;br/&gt;控制器的作用就是处理接收到的请求，解析用户输入并执行对应程序理逻辑，然后返回对应的输出。&lt;/p&gt;
&lt;p&gt;用户的输入可以是QueryString、FormData、也可以是HTTP Header、HTTP Body。&lt;br/&gt;控制器的输出格式通常是：HTML、JSON、XML、普通文本&lt;/p&gt;
&lt;h3 id=&quot;H3-6&quot;/&gt;
&lt;p&gt;所有Controller类都必须直接或间接继承于&lt;code&gt;Microsoft.AspNetCore.Mvc.ControllerBase&lt;/code&gt;。为了搭配视图引擎使用，ASP.NET Core MVC 框架内置了 &lt;code&gt;Microsoft.AspNetCore.Mvc.Controller&lt;/code&gt;类，提供了一些视图引擎需要的特性。所以，默认我们继承该类即可。&lt;/p&gt;
&lt;h3 id=&quot;H3-7&quot;/&gt;
&lt;p&gt;Controller类的类名（ClassName）推荐以&lt;code&gt;Controller&lt;/code&gt;为结尾（不区分大小写）。&lt;br/&gt;例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HomeController&lt;/li&gt;
&lt;li&gt;TestController&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;路由模块去掉结尾的Controller作为ControllerName。&lt;br/&gt;那么对应的&lt;code&gt;ControllerName&lt;/code&gt;则分别是&lt;code&gt;Home&lt;/code&gt;、&lt;code&gt;Test&lt;/code&gt;。这也是路由映射到Controller的主要标识。&lt;/p&gt;
&lt;p&gt;当然，你也可以不以Controller作为控制器类名（ClassName）的固定后缀，那么路由模块会以完整的类名（ClassName）作为&lt;code&gt;ControllerName&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 ASP.NET MVC框架中，控制器（Controller）类名必须以Controller作为后缀，但是在 ASP.NET Core MVC框架中去掉了这个限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下Controller的定义都是可以的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;H2-8&quot;/&gt;
&lt;h3 id=&quot;H3-9&quot;/&gt;
&lt;p&gt;控制器（Controller）操作（Action）就是控制器接收到请求后实际用与处理请求的程序方法/函数。&lt;/p&gt;
&lt;p&gt;Controller接收到请求后根据路由的ActionName找到对应的Action，然后将用户的输入映射到该Action的参数，最终Action实际执行完成后再返回对应的输出。&lt;/p&gt;
&lt;h3 id=&quot;H3-10&quot;/&gt;
&lt;p&gt;Action必须是控制器中定义的公有非静态方法，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HomeController : &lt;span class=&quot;hljs-title&quot;&gt;Controller
{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;Index(&lt;span class=&quot;hljs-params&quot;&gt;)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return Content(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World ！ -ken.io&quot;);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;string &lt;span class=&quot;hljs-title&quot;&gt;Test(&lt;span class=&quot;hljs-params&quot;&gt;)
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;DoSomething(&lt;span class=&quot;hljs-params&quot;&gt;)
    {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照默认的路由配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Action：Index() 将响应/home/index的请求&lt;/li&gt;
&lt;li&gt;Action: Test() 将响应/home/test的请求&lt;/li&gt;
&lt;li&gt;Action: DoSomething() 将响应/home/dosomething的请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你在Controller定义了一个公有的非静态方法，但不想让这个方法处理请求，那么可以标记为NonAction&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HomeController : &lt;span class=&quot;hljs-title&quot;&gt;Controller
{
    [&lt;span class=&quot;hljs-meta&quot;&gt;NonAction]
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;LogicMethod(&lt;span class=&quot;hljs-params&quot;&gt;){

    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-11&quot;/&gt;
&lt;p&gt;ASP.NET Core MVC 限定 Action返回类型必须是实现了&lt;code&gt;Microsoft.AspNetCore.Mvc.IActionResult&lt;/code&gt;接口的类型，框架本身提供了该接口的默认实现&lt;code&gt;Microsoft.AspNetCore.Mvc.ActionResult&lt;/code&gt;，并提供了&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;ActionResult类&lt;/a&gt;的子类，用于输出不同内容格式的需求。&lt;/p&gt;
&lt;p&gt;不过在定义Action方法的时候，返回值类型也可以定义成string、int等，这些自定义的返回类型会在返回到响应流之前被框架自动包装到合适的ActionResult子类型中。&lt;/p&gt;
&lt;p&gt;常用的ActionResult子类说明&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Action返回类型&lt;/th&gt;
&lt;th&gt;Controller内置方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ViewResult&lt;/td&gt;
&lt;td&gt;View()&lt;/td&gt;
&lt;td&gt;将视图数据交由Razor视图引擎渲染&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PartialViewResult&lt;/td&gt;
&lt;td&gt;PartialView()&lt;/td&gt;
&lt;td&gt;将视图数据交由Razor视图引擎部分视图（PartialView）渲染&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ContentResult&lt;/td&gt;
&lt;td&gt;Content()&lt;/td&gt;
&lt;td&gt;返回自定义文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;JsonResult&lt;/td&gt;
&lt;td&gt;Json()&lt;/td&gt;
&lt;td&gt;返回对象的JSON序列化结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FileResult&lt;/td&gt;
&lt;td&gt;File()&lt;/td&gt;
&lt;td&gt;返回要写入响应中的二进制输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RedirectResult&lt;/td&gt;
&lt;td&gt;Redirect()&lt;/td&gt;
&lt;td&gt;重定向到指定的Url&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;RedirectToRouteResult&lt;/td&gt;
&lt;td&gt;RedirectToAction(),RedirectToRoute()&lt;/td&gt;
&lt;td&gt;重定向到指定的Action或者路由&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EmptyResult&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;在Action返回null或者Action定义返回关键字是void时会被包装为EmptyResult&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;H2-12&quot;/&gt;
&lt;h3 id=&quot;H3-13&quot;/&gt;
&lt;p&gt;在Controllers文件夹中新建&lt;code&gt;ActionResultTestController.cs&lt;/code&gt;并继承于Controller类用于测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using System;
&lt;span class=&quot;hljs-keyword&quot;&gt;using Microsoft.AspNetCore.Mvc;

&lt;span class=&quot;hljs-keyword&quot;&gt;namespace &lt;span class=&quot;hljs-title&quot;&gt;Ken.Tutorial.Web.Controllers
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;ActionResultTestController : &lt;span class=&quot;hljs-title&quot;&gt;Controller
    {

    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup.cs配置该测试控制器专用路由&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-14&quot;/&gt;
&lt;p&gt;定义返回ContentResult的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;ContentTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
   &lt;span class=&quot;hljs-keyword&quot;&gt;return Content(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content Result Test --ken.io&quot;);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目，浏览器访问 {host:port}/art/contenttest，将看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;ContentResult Test &lt;span class=&quot;hljs-keyword&quot;&gt;by ken.io
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-15&quot;/&gt;
&lt;p&gt;定义返回JsonResult的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;JsonTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Json(&lt;span class=&quot;hljs-keyword&quot;&gt;new { Message = &lt;span class=&quot;hljs-string&quot;&gt;&quot;JsonResult Test&quot;, Author = &lt;span class=&quot;hljs-string&quot;&gt;&quot;ken.io&quot; });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目，浏览器访问 {host:port}/art/jsontest，将看到以下输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-json hljs&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;message&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;JsonResult Test&quot;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;author&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;ken.io&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-16&quot;/&gt;
&lt;p&gt;定义返回FileResult的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;FileTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;var bytes = Encoding.Default.GetBytes(&lt;span class=&quot;hljs-string&quot;&gt;&quot;FileResult Test by ken.io&quot;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;return File(bytes, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/text&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;filetest.txt&quot;);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目，浏览器访问 {host:port}/art/jsontest，将会下载文件filetest.txt。&lt;br/&gt;文件内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;FileResult Test &lt;span class=&quot;hljs-keyword&quot;&gt;by ken.io
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-17&quot;/&gt;
&lt;p&gt;定义返回Redirect相关的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;RedirectTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Redirect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://ken.io&quot;);
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;RedirectToActionTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return RedirectToAction(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jsontest&quot;);
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;RedirectToRouteTest(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return RedirectToRoute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Default&quot;, &lt;span class=&quot;hljs-keyword&quot;&gt;new { Controller = &lt;span class=&quot;hljs-string&quot;&gt;&quot;home&quot;, Action = &lt;span class=&quot;hljs-string&quot;&gt;&quot;index&quot; });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目，浏览器访问测试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问 /art/redirecttest，将跳转到 &lt;a href=&quot;https://ken.io/&quot; target=&quot;_blank&quot;&gt;https://ken.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;访问 /art/redirecttoactiontest，将跳转到 /art/jsontest&lt;/li&gt;
&lt;li&gt;访问 /art/redirecttoroutetest，将跳转到 /&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;H2-18&quot;/&gt;
&lt;h3 id=&quot;H3-19&quot;/&gt;
&lt;p&gt;路由将请求交由对应的Controller处理时，Controller会找到对应的Action方法，并从&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.routing.routedata?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;RouteData&lt;/a&gt;或HTTP请求数据（QueryString、FormData、Header等）找到执行该方法所需要的参数的值。&lt;/p&gt;
&lt;p&gt;如果未找到参数对应的数据，且该参数类型是可以为null的类型，则null将作为参数值传递递，否则将会引发一场。&lt;/p&gt;
&lt;p&gt;另外，Action方法也可以不定义参数，手动从&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.routing.routedata?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;RouteData&lt;/a&gt;或HTTP请求数据（QueryString、FormData、Header等）获取对应的参数值。&lt;/p&gt;
&lt;h3 id=&quot;H3-20&quot;/&gt;
&lt;p&gt;在Controllers文件夹中新建&lt;code&gt;ParamsMappingTestController.cs&lt;/code&gt;并继承于Controller类用于测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using System;
&lt;span class=&quot;hljs-keyword&quot;&gt;using Microsoft.AspNetCore.Mvc;

&lt;span class=&quot;hljs-keyword&quot;&gt;namespace &lt;span class=&quot;hljs-title&quot;&gt;Ken.Tutorial.Web.Controllers
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;ParamsMappingTestController:&lt;span class=&quot;hljs-title&quot;&gt;Controller
    {

    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup.cs配置该测试控制器专用路由&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;H3-21&quot;/&gt;
&lt;p&gt;定义接收路由参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetId(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int id)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Content(&lt;span class=&quot;hljs-string&quot;&gt;$&quot;Action params mapping test by ken.io, id:&lt;span class=&quot;hljs-subst&quot;&gt;{id}&quot;);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动应用，浏览器访问 /pmt/getid/1024 或者 /pmt/getid?id=1024，将会看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;Action &lt;span class=&quot;hljs-keyword&quot;&gt;params mapping test &lt;span class=&quot;hljs-keyword&quot;&gt;by ken.io, id:&lt;span class=&quot;hljs-number&quot;&gt;1024
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过PostMan等工具post访问 /pmt/getid 在HTTP Header参数增加id=1024并发送请求，也会看到同样输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-basic-kbrbm.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;H3-22&quot;/&gt;
&lt;p&gt;定义接收数组参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetArray(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;string[] idArray)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;var message = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io,id:&quot;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (idArray != &lt;span class=&quot;hljs-literal&quot;&gt;null)
    {
        message += &lt;span class=&quot;hljs-keyword&quot;&gt;string.Join(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;, idArray);
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Content(message);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用启动，浏览器访问 /pmt/getarray/1,2 或者 /pmt/getarray?id=1,2，将会看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;Action &lt;span class=&quot;hljs-keyword&quot;&gt;params mapping test &lt;span class=&quot;hljs-keyword&quot;&gt;by ken.io,id:&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过PostMan等工具post访问 /pmt/getarray 并设置表单参数并发送请求，也会看到同样输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-basic-array-kbrbm.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;h4-5-&quot;/&gt;
&lt;p&gt;在项目根目录创建Models文件夹，并创建Person.cs类文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Person
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;string Name { &lt;span class=&quot;hljs-keyword&quot;&gt;get; &lt;span class=&quot;hljs-keyword&quot;&gt;set; }

    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int Age { &lt;span class=&quot;hljs-keyword&quot;&gt;get; &lt;span class=&quot;hljs-keyword&quot;&gt;set; }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义接收自定义参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetPerson(&lt;span class=&quot;hljs-params&quot;&gt;Person person)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Json(&lt;span class=&quot;hljs-keyword&quot;&gt;new { Message = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io&quot;, Data = person });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用启动，浏览器访问 /pmt/getperson?name=ken&amp;amp;age=18，将会看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;message&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io&quot;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;data&quot;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;ken&quot;,
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;age&quot;: &lt;span class=&quot;hljs-number&quot;&gt;18
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过PostMan等工具post访问 /pmt/getperson 并设置表单参数并发送请求，也会看到同样输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-custom-kbrb.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;H3-23&quot;/&gt;
&lt;p&gt;定义接收自定义类型数组参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetPersonList&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;Person&amp;gt; person)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Json(&lt;span class=&quot;hljs-keyword&quot;&gt;new { Message = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io&quot;, Data = person });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动应用，浏览器访问 /pmt/getpersonlist?person[0].name=ken&amp;amp;person[0].age=18&amp;amp;person[1].name=tom&amp;amp;person[1].age=20&lt;br/&gt;将会看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;message&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io&quot;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;data&quot;: [
    {
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;ken&quot;,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;age&quot;: &lt;span class=&quot;hljs-number&quot;&gt;18
    },
    {
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;name&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;tom&quot;,
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;age&quot;: &lt;span class=&quot;hljs-number&quot;&gt;20
    }
  ]
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者通过PostMan等工具post访问 /pmt/getpersonlist 并设置表单参数并发送请求，也会看到同样输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-custom-array-kbrb.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;H3-24&quot;/&gt;
&lt;p&gt;定义接收JSON类型参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetPersonJson(&lt;span class=&quot;hljs-params&quot;&gt;[FromBody]Person person)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Json(&lt;span class=&quot;hljs-keyword&quot;&gt;new { Message = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Action params mapping test by ken.io&quot;, Data = person });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动应用，这时候我们就只能通过PostMan工具进行测试了&lt;/p&gt;
&lt;p&gt;首先设置 Content-Type=application/json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-custom-json-contenttype-kbrbm.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后设置JSON表单参数并发送请求，就会看到对应输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.ken.io/blog/aspdotnet-core/tutorial-2.1/04/aspnet-core-mvc-action-params-mapping-httpdata-custom-json-body-kbrb.png?v=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;H3-25&quot;/&gt;
&lt;p&gt;定义手动获取参数的Action&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-csharp hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;GetByHand(&lt;span class=&quot;hljs-params&quot;&gt;)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return Json(&lt;span class=&quot;hljs-keyword&quot;&gt;new
    {
        Id = RouteData.Values[&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;],
        Name = Request.Query[&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;]
    });
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用启动后，浏览器访问 /pmt/getbyhand/1024?name=ken&amp;amp;name=tom&amp;amp;age=18&lt;br/&gt;将看到以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;id&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1024&quot;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;name&quot;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;ken&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;tom&quot;
  ]
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RouteData.Values[“id”]：从路由数据中获取数据&lt;br/&gt;Request.Query[“name”]：从Url参数中获取数据&lt;br/&gt;Request.Form[“name”]：从表单参数中获取数据&lt;/p&gt;
&lt;h2 id=&quot;H2-26&quot;/&gt;
&lt;h3 id=&quot;H3-27&quot;/&gt;
&lt;ul&gt;&lt;li&gt;本文代码示例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-04&quot; target=&quot;_blank&quot;&gt;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-04&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文首发于我的独立博客：&lt;a href=&quot;https://ken.io/note/asp.net-core-tutorial-mvc-controller-action&quot; target=&quot;_blank&quot;&gt;https://ken.io/note/asp.net-core-tutorial-mvc-controller-action&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 11 Oct 2018 16:03:00 +0000</pubDate>
<dc:creator>ken-io</dc:creator>
<og:description>一、前言 1、本教程主要内容 ASP.NET Core MVC控制器简介 ASP.NET Core MVC控制器操作简介 ASP.NET Core MVC控制器操作简介返回类型简介 ASP.NET C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-controller-action.html</dc:identifier>
</item>
<item>
<title>Optaplanner终于支持多线程并行运行 - Multithreaded incremental solving - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/9775876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/9775876.html</guid>
<description>&lt;p&gt;　&lt;a href=&quot;http://www.optaplanner.org/&quot; target=&quot;_blank&quot;&gt;　Optaplanner&lt;/a&gt; 7.9.0.Final之前，启动引擎开始对一个Problem进行规划的时候，只能是单线程进行的。也就是说，当引擎对每一个possible solution进行分数计算的过程中，细化到每个步骤(Caculation)，都只能排队在同一个线程中依次计算，不管你的问题是否存在并行计算的可能。很显示这种运算方式应用于一些可并行计划的场景下，是相当不利的。就算是一些在业务逻辑上无法实现并行运算的情况，若在引擎自行调用指定的算法进行寻优时，若可以将每个Step,甚至每个Move的运行操作，适当地分配到不同的线程中执行，那么在多核CPU的环境下，无疑能大大提升planning的性能，从而在规定的时间内行到更优的效果。毕竟对于NP-Hard/NP-Complete问题，除了比较算法优劣外，另一个维度对比的就是运算量。&lt;/p&gt;
&lt;p&gt;　　 而在7.9.0.Final版本中，发布了并行计算功能 - &lt;a href=&quot;http://www.optaplanner.org/download/releaseNotes/releaseNotes7.html&quot; target=&quot;_blank&quot;&gt;Multithreaded incremental solving&lt;/a&gt;. 此功能只需要在配置文档中指定对应的并行线程数（可指定数量，也可由系统自行决定线程数）,在启动Planning后，每一个Step中的各个Move即有可能被分配于不同的线程进行计算。我在我的项目中启用了此功能，试用过各种类型的项目，其性能的提升基本上在30% - 150%之间。对于运算量巨大的情况（约束多且复杂、问题规划大），确实能有不少的提升。&lt;/p&gt;
&lt;p&gt;　　此功能在7.12.0. Final版本中，也有所优化，主要是针对Chained Throudth Time模式下的优化。&lt;/p&gt;

&lt;p&gt;关于并行计算功能的更新信息如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;New and noteworthy: Engine 7.9.0.Final&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot; readability=&quot;13.953142857143&quot;&gt;
&lt;h3 id=&quot;_multithreaded_incremental_solving&quot;&gt;Multithreaded incremental solving&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;OptaPlanner can now solve one dataset (without partitioning) with multiple threads to take advantage of multiple CPU cores.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Even with just a few CPU cores, it triples the score calculation speed:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;span class=&quot;image&quot;&gt;&lt;img src=&quot;http://www.optaplanner.org/download/releaseNotes/7.9/multithreadedSolvingVrpTabuSearch.png&quot; alt=&quot;searchTableOfContents&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Multithreaded incremental solving is easy to activate. Just add a &lt;code&gt;&amp;lt;moveThreadCount&amp;gt;&lt;/code&gt; line in your solver config:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;highlight nowrap&quot;&gt;
&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;lt;solver&amp;gt;
  &amp;lt;moveThreadCount&amp;gt;&lt;span class=&quot;number&quot;&gt;4&amp;lt;/moveThreadCount&amp;gt;
  ...
&amp;lt;/solver&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;13.949044585987&quot;&gt;
&lt;p&gt;This basically donates 4 extra CPU cores to the solver. Use &lt;code&gt;AUTO&lt;/code&gt; to have OptaPlanner deduce it automatically. Optionally, specify a &lt;code&gt;&amp;lt;threadFactoryClass&amp;gt;&lt;/code&gt; for environments that don’t like arbitrary thread creation.&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于Optaplanner有任何疑问，可以通过邮件将问题发到我邮件，我将及时处理。通过即时通讯工具，我确实没办法即时处理，导致无意忽略了不少信息。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/kentzhang/p/12977379@qq.com&quot; target=&quot;_blank&quot;&gt;12977379@qq.com&lt;/a&gt; 或 &lt;a href=&quot;mailto:kentbill@gmail.com&quot; target=&quot;_blank&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 11 Oct 2018 16:02:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>Optaplanner 7.9.0.Final之前，启动引擎开始对一个Problem进行规划的时候，只能是单线程进行的。也就是说，当引擎对每一个possible solution进行分数计算的过程中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/9775876.html</dc:identifier>
</item>
<item>
<title>在php文件中xml格式 - Receiver</title>
<link>http://www.cnblogs.com/zz-1021/p/9775866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zz-1021/p/9775866.html</guid>
<description>&lt;h2&gt;&lt;span&gt;本人是小白，有错误的地方请指正，勿喷！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在写一个调查问卷的过程中用到了xml文件，如想要了解，可以通过以下链接简单学习：http://www.w3school.com.cn/xml/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所用工具：phpstudy+notepad++（使用utf-8编码无BOM）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;出现的问题如下:最开始的代码如下：我想要 求出去长沙游玩的人数是多少人，&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;lt;?php&lt;br/&gt;header('Content-Type: text/xml');&lt;br/&gt;$xmlstr=&quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&amp;gt; &lt;br/&gt;&amp;lt;movies&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;350&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;长沙&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;47&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;张家界&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;3&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;118&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;上海&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;4&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;80&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;南京&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;/movies&amp;gt;&lt;br/&gt;&quot;;&lt;br/&gt;$xml = simplexml_load_string($xmlstr);&lt;br/&gt;$count0 = $xml-&amp;gt;movie[0]-&amp;gt;count;&lt;br/&gt;echo $count0;&lt;br/&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;火狐浏览器上：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;XML 解析错误：语法错误&lt;br/&gt;位置：http://localhost:8080/diaocha/2.php&lt;br/&gt;行 1，列 1：350&lt;/p&gt;
&lt;p&gt;360浏览器上的错误：&lt;/p&gt;
&lt;h3&gt;This page contains the following errors:&lt;/h3&gt;
&lt;p&gt;error on line 1 at column 1: Document is empty&lt;/p&gt;
&lt;h3&gt;Below is a rendering of the page up to the first error.&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;需要改正的地方是：&lt;/p&gt;
&lt;p&gt;去掉第一句：header('Content-Type: text/xml');即可。得到350&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、如果你是需要查看xml格式的时候&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;?php&lt;br/&gt;header('Content-Type: text/xml');&lt;br/&gt;$xmlstr=&quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&amp;gt; &lt;br/&gt;&amp;lt;movies&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;350&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;长沙&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;47&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;张家界&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;3&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;118&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;上海&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;4&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;80&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;南京&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;/movies&amp;gt;&lt;br/&gt;&quot;;&lt;/p&gt;
&lt;p&gt;就可以得出结果:&lt;/p&gt;
&lt;p&gt;This XML file does not appear to have any style information associated with it. The document tree is shown below.&lt;/p&gt;

&lt;div class=&quot;pretty-print&quot;&gt;
&lt;div id=&quot;collapsible0&quot; class=&quot;collapsible&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;expanded&quot; readability=&quot;13&quot;&gt;

&lt;p&gt;&amp;lt;movies&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;350&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;长沙&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;47&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;张家界&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;3&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;118&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;上海&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;movie&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;旅游的人数&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;4&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;count&amp;gt;80&amp;lt;/count&amp;gt;&lt;br/&gt;&amp;lt;content&amp;gt;南京&amp;lt;/content&amp;gt;&lt;br/&gt;&amp;lt;/movie&amp;gt;&lt;br/&gt;&amp;lt;/movies&amp;gt;&lt;br/&gt;&quot;;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;html-tag&quot;&gt;上方的那句话可以不用管：在IE浏览器上没有那句话 所以只是因为其他浏览器的兼容性而已。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 11 Oct 2018 15:59:00 +0000</pubDate>
<dc:creator>Receiver</dc:creator>
<og:description>本人是小白，有错误的地方请指正，勿喷！ 在写一个调查问卷的过程中用到了xml文件，如想要了解，可以通过以下链接简单学习：http://www.w3school.com.cn/xml/ 所用工具：php</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zz-1021/p/9775866.html</dc:identifier>
</item>
<item>
<title>144_二叉树的前序遍历 - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/9775788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/9775788.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;描述&quot;&gt;描述&lt;/h2&gt;
&lt;p&gt;给定一个二叉树，返回它的&lt;strong&gt;前序&lt;/strong&gt;遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt; 递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
&lt;h2 id=&quot;方法一递归&quot;&gt;方法一：递归&lt;/h2&gt;
&lt;h3 id=&quot;java-代码&quot;&gt;Java 代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        preorderTraversal(root, res);
        return res;
    }
    
    private void preorderTraversal(TreeNode root, List&amp;lt;Integer&amp;gt; res) {
        if (root == null) {
            return;
        }
        
        res.add(root.val);
        preorderTraversal(root.left, res);
        preorderTraversal(root.right, res);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，其中，&lt;span class=&quot;math inline&quot;&gt;\(n​\)&lt;/span&gt; 为二叉树节点的数目&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;方法二非递归使用栈&quot;&gt;方法二：非递归（使用栈）&lt;/h2&gt;
&lt;h3 id=&quot;java-代码-1&quot;&gt;Java 代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if (root == null) {
            return res;
        }
        
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            res.add(cur.val);
            
            if (cur.right != null) {
                stack.push(cur.right);
            }
            if (cur.left != null) {
                stack.push(cur.left);
            }
        }
        return res;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，其中，&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 为二叉树节点的数目&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(h)\)&lt;/span&gt;，其中，&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt; 为二叉树的高度&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 11 Oct 2018 15:36:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>144_二叉树的前序遍历 [TOC] 描述 给定一个二叉树，返回它的 前序 遍历。 示例: 进阶： 递归算法很简单，你可以通过迭代算法完成吗？ 方法一：递归 Java 代码 复杂度分析： 时间复杂度：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/9775788.html</dc:identifier>
</item>
<item>
<title>Hive 官方手册翻译 -- Hive Transactions (Hive 事务) - 范振勇</title>
<link>http://www.cnblogs.com/fanzhenyong/p/9775713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanzhenyong/p/9775713.html</guid>
<description>&lt;p align=&quot;right&quot;&gt;由 Alan Gates创建, 最终由 Andrew Sherman修改于2018年8月7日&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;原文链接：&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions&quot;&gt;https://cwiki.apache.org/confluence/display/Hive/Hive+Transactions&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;翻译：Google Google翻译，金山软件 金山词霸&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;校对：南大通用 范振勇 (如有翻译问题，请多指教)&lt;/p&gt;

&lt;p&gt;　　升级到Hive 3.0时，由之前版本创建的任何事务性表都需要在每个分区上运行Major(主要/深度)级紧缩操作。更确切地说，自上一次Major级紧缩操作之后，在其上执行任何Update/Delete/Merge语句的分区，都必须再进行一次Major级紧缩操作。就是说，在Hive升级到Hive 3之前，此分区上不会发生任何Update/Delete/Merge操作。&lt;/p&gt;

&lt;p&gt;　　ACID代表了数据库事务的四个特征：原子性(一个操作要么完全成功，要么失败，绝不会留下部分数据) 、一致性(一旦应用程序执行了一个操作，该操作的结果在它以后的每个操作中都是可见的)、隔离性(一个用户未完成的操作不会对其他用户造成意外影响)，以及持久性(一旦一个操作完成，它将保持下来，即便面对机器故障或系统故障)。一直以来，这些特性被认为是数据库系统事务功能的一部分。&lt;/p&gt;
&lt;p&gt;　　截止到 0.13，Hive都只提供分区级别的原子性、一致性和持久性。可以通过打开一种可用的锁机制(Zookeeper或内存)来提供隔离性。随着在Hive 0.13中添加事务，现在可以在行级别提供完整的ACID语义，这样一个应用程序就可以在另一个应用程序读取同一个分区时添加行，而不会相互干扰。&lt;/p&gt;
&lt;p&gt;Hive中添加ACID语义事务的特性，可以解决以下用例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 流数据的采集。许多用户使用如Apache Flume，Apache Storm，或Apache Kafka等工具，将数据流到自己的Hadoop集群。尽管这些工具可以每秒数百行或更多行的速度写入数据，但Hive只能每十五分钟到一小时的添加分区。更短间隔的添加分区会导致表中出现大量的分区。这些工具可以将数据流到现有的分区中，但这将导致读操作产生脏读(也就是说，能看到在启动查询后会写入的数据)，并在目录中留下许多小文件，这将给NameNode带来压力。使用此事务功能，将支持此场景，同时保证读操作获得一致的数据视图，并避免过多的文件。&lt;/li&gt;
&lt;li&gt; 缓慢变化的维度（表）。在典型的星型模型的数据仓库中，维度表随着时间的推移变化很缓慢。例如，零售商开设新的商店，这些商店需要添加到商店表中，或者现有的商店可能会改变面积或其他可跟踪的特性。这些更改会导致插入单个记录或更新记录(取决于所选择的策略)。从0.14开始，Hive能够支持这一点。&lt;/li&gt;
&lt;li&gt; 数据重述（译注：财务术语，类似“调帐”）。有时，收集的数据被认为是不正确的，需要修正。或数据的第一个实例可能是近似值（90％的服务报告），随后提供了完整数据。或业务规则可能要求因为随后的交易进行重述某些交易（例如，在购物之后，客户可以购买成员资格，因此有权享受折扣价格，包括在先前的购买记录）。或者用户可以根据合同约定在他们关系的结束时消除其客户的数据。从Hive0.14开始，这些用例可以通过INSERT，UPDATE和DELETE来支持。&lt;/li&gt;
&lt;li&gt; 使用SQL MERGE语句实现批量更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;所有DML操作都是自动提交，尚不支持BEGIN，COMMIT，和ROLLBACK，计划在将来的版本中支持这些特性。&lt;/li&gt;
&lt;li&gt;在第一个版本中只支持ORC文件格式。构建事务特性的初衷是可以使用任何存储格式，只要这些存储格式可以确定如何更新或删除基本记录(基本上，具有显式或隐式的行id即可)，但到目前为止，仅完成针对ORC的集成工作。&lt;/li&gt;
&lt;li&gt;默认情况下，事务被配置为OFF。有关配置值的讨论，请参见下面的配置部分。&lt;/li&gt;
&lt;li&gt;要使用事务特性，表必须分桶。在同一系统中的不使用事务和ACID的表则无需分桶。外部表不能成为ACID表，因为外部表上的更改超出了紧缩器的控制范围(hive-13175)。&lt;/li&gt;
&lt;li&gt;不允许从非ACID的会话中读取/写入ACID表。换句话说，要操作ACID表，必须将Hive事务管理器设置为org.apache.hadoop.hive.ql.lockmgr.DbTxnManager。&lt;/li&gt;
&lt;li&gt;现在只支持快照隔离级别。当一个给定的查询启动时，它会提供该数据的一致快照。不支持脏读（READ UNCIMMITTED）、提交读（READ COMMITTED）、可重复读（REPEATABLE READ）或可序列化（SERIALIZABLE）。引入BEGIN的目的是在事务持续时间内支持快照隔离，而不仅仅是一个查询。根据用户请求，还可以添加其他隔离级别。&lt;/li&gt;
&lt;li&gt;现有的ZooKeeper和内存锁管理器与事务不兼容。我们无意处理这个问题。有关如何为事务存储锁的讨论，请参阅下面的基本设计。&lt;/li&gt;
&lt;li&gt;原来ACID表不支持使用ALTER TABLE更改Schema，参见Hive-11421。此缺陷于Hive 1.3.0/ Hive 2.0.0修复成功。&lt;/li&gt;
&lt;li&gt;使用Oracle作为Metastore DB和“datanucleus.connectionPoolingType = BONECP”时，可能偶发性产生 “No such lock ...”和“No such transaction...”的错误。在这种情况下，建议设置“datanucleus.connectionPoolingType = DBCP”。&lt;/li&gt;
&lt;li&gt;LOAD DATA ...语句不支持事务性表，直到Hive-16732才能正确执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hive提供了流数据采集和流式转换的API：&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Streaming+Data+Ingest&quot;&gt;Hive HCatalog流API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Streaming+Data+Ingest+V2&quot;&gt;Hive流API&lt;/a&gt;（从Hive 3开始）&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/HCatalog+Streaming+Mutation+API&quot;&gt;HCatalog流式转换API&lt;/a&gt;（在Hive2.0.0及更高版本）&lt;/p&gt;
&lt;p&gt;API的比较可参考流式转换文档的背景部分。&lt;/p&gt;

&lt;p&gt;1.从Hive0.14开始,INSERT … VALUES，UPDATE和DELETE已被添加到SQL语法。详见 &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML&quot;&gt;Language Manual DML&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.一些新的命令已经添加到Hive的DDL中，以支持ACID和事务，另外一些修改了现有的DDL语句。&lt;/p&gt;
&lt;p&gt;2.1加入一个新命令SHOW TRANSACTIONS，详见&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ShowTransactions&quot;&gt;Show Transactions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.2加入一个新命令SHOW COMPACTIONS，详见 &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ShowCompactions&quot;&gt;Show Compactions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.3改变了SHOW LOCKS命令，以便提供锁与事务相关的信息。如果您使用的是Zookeeper或内存锁管理器，你会发现这个命令的输出并无差别。详见&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ShowLocks&quot;&gt;Show Locks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.4 ALTER TABLE添加了一个新的选项，用于表或分区的紧缩。在一般情况下，用户不需要请求紧缩，因为系统会检测紧缩的需求并开始执行紧缩。但是，如果关闭了表的紧缩功能，或者用户希望在系统没选择的情况下紧缩表，则可以使用ALTER TABLE启动紧缩。详见  &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-AlterTable/PartitionCompact&quot;&gt;Alter Table/Partition紧缩&lt;/a&gt;，这将任务放到紧缩排队等待后返回。用户可以使用SHOW COMPACTIONS查看紧缩的进度。&lt;/p&gt;
&lt;p&gt;3.添加一个新命令终止事务：ABORT TRANSACTIONS，详见&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-AbortTransactions&quot;&gt;Abort Transactions&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　HDFS不支持文件的就地更改.对于追加写的文件，它也不为用户不提供读取的一致性。为了在HDFS之上提供这些特性，我们遵循了在其他数据仓库工具中使用的标准方法。表或分区的数据存储在一组基本文件中。新记录、更新和删除的记录存储在增量文件中。每个事务(或者是流代理(如Flume或Storm)的每个批事务)都创建了一组新的增量文件，以更改表或分区。在读取时，合并基础文件和增量文件并应用更新和删除的变化。&lt;/p&gt;
&lt;h2&gt;6.1、 基础目录和增量目录&lt;/h2&gt;
&lt;p&gt;　　以前，分区(或者表，如果该表未分区的话)的所有文件都存放在一个目录中。现在更改后，任何使用ACID更改的分区(或表)都将有一个用于基本文件的目录和一个用于每个增量文件集的目录。对于未分区的表“t”，其目录布局如下所示：&lt;/p&gt;
&lt;p&gt;表“T”在文件系统的布局&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
hive&amp;gt; dfs -&lt;span&gt;ls&lt;/span&gt; -R /user/hive/warehouse/&lt;span&gt;t;
drwxr&lt;/span&gt;-xr-x   - ekoifman staff          &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; /user/hive/warehouse/t/&lt;span&gt;base_0000022
&lt;/span&gt;-rw-r--r--   &lt;span&gt;1&lt;/span&gt; ekoifman staff        &lt;span&gt;602&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; /user/hive/warehouse/t/base_0000022/&lt;span&gt;bucket_00000
drwxr&lt;/span&gt;-xr-x   - ekoifman staff          &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; /user/hive/warehouse/t/&lt;span&gt;delta_0000023_0000023_0000
&lt;/span&gt;-rw-r--r--   &lt;span&gt;1&lt;/span&gt; ekoifman staff        &lt;span&gt;611&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; /user/hive/warehouse/t/delta_0000023_0000023_0000/&lt;span&gt;bucket_00000
drwxr&lt;/span&gt;-xr-x   - ekoifman staff          &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;07&lt;/span&gt; /user/hive/warehouse/t/&lt;span&gt;delta_0000024_0000024_0000
&lt;/span&gt;-rw-r--r--   &lt;span&gt;1&lt;/span&gt; ekoifman staff        &lt;span&gt;610&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;07&lt;/span&gt; /user/hive/warehouse/t/delta_0000024_0000024_0000/bucket_00000
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.2、 紧缩器&lt;/h2&gt;
&lt;p&gt;　　紧缩器是一套Metastore内运行，支持ACID系统的后台进程。它由Initiator（发起者），Worker，Cleaner，AcidHouseKeeperService和其他几部分组成。&lt;/p&gt;
&lt;h3&gt;6.2.1、  增量文件紧缩&lt;/h3&gt;
&lt;p&gt;　　随着表的修改操作，创建了越来越多的增量文件，就需要紧缩以保持足够的性能。有两种类型的紧缩，次要和主要：&lt;/p&gt;
&lt;p&gt;　　次要/轻度/minor紧缩处理一组现有的增量文件，针对每个桶，将它们重写为单个的增量文件。&lt;/p&gt;
&lt;p&gt;　　主要/深度/major紧缩处理一个或多个桶的增量文件和基本文件，并将它们重写为每个桶新的基本文件。主要紧缩成本更高，但更有效。&lt;/p&gt;
&lt;p&gt;　　所有紧缩都是在后台完成的，不会阻止数据的并发读、写。紧缩后，系统将等待所有旧文件的读操作完成后，删除旧文件。&lt;/p&gt;
&lt;h4&gt;6.2.1.1、    Initiator（发起者）&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;　　这个模块负责发现哪些表或分区需要紧缩。需要在Metastore中配置参数hive.compactor.initiator.on启用该模块，在“事务的新配置参数”中有几个形式为*.threshold的属性，控制何时创建紧缩任务以及执行哪种类型的紧缩。每个紧缩任务处理一个分区(如果表未分区，则处理整个表)。如果给定分区的连续紧缩失败次数超过hive.compactor.initiator.failed.compacts.threshold，则该分区的自动紧缩调度将停止。有关更多信息，请参见配置参数表。&lt;/p&gt;
&lt;h4&gt;6.2.1.2、    Worker&lt;/h4&gt;
&lt;p align=&quot;left&quot;&gt;　　每个Worker处理单个紧缩任务。紧缩任务是一个MapReduce的作业，其名称形式如下：&amp;lt;hostname&amp;gt;-compactor-&amp;lt;db&amp;gt;.&amp;lt;table&amp;gt;.&amp;lt;partition&amp;gt;。每个Worker向集群提交作业(如果定义了hive.compactor.jobs.queue)到Yarn队列，并等待作业完成。hive.compactor.worker.threads确定每个Metastore中的Worker数量。Hive数据仓库中的Worker总数决定了紧缩的最大并发数量。&lt;/p&gt;
&lt;h4&gt;6.2.1.3、    Cleaner&lt;/h4&gt;
&lt;p&gt;　　就是在紧缩后，确定不再需要增量文件之后删除增量文件的进程。&lt;/p&gt;
&lt;h4&gt;6.2.1.4、    AcidHouseKeeperService&lt;/h4&gt;
&lt;p&gt;　　此进程查找在hive.txn.timeout时间内没有心跳的事务，并中止它们。系统假设此时启动事务的客户端停止心跳、崩溃，而它锁定的资源应该被释放。&lt;/p&gt;
&lt;h4&gt;6.2.1.5、    SHOW COMPACTIONS&lt;/h4&gt;
&lt;p&gt;　　此命令显示有关当前正在运行的紧缩和紧缩的近期历史记录(可配置保留期限)信息。从hive-12353开始，可显示紧缩的历史记录信息。&lt;/p&gt;
&lt;p&gt;　　关于此命令和输出的更多信息，可参阅  &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ShowCompactions&quot;&gt;LanguageManual DDL#Show Compactions&lt;/a&gt;。影响该命令的输出的参数见“事务新的配置参数/紧缩历史记录”配置属性。系统保留每种类型的最后N个条目：失败、成功、尝试(其中N对每种类型都是可配置的)。&lt;/p&gt;
&lt;h2&gt;6.3、 事务/锁管理器&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　Hive添加了一个名为“事务管理器”的新逻辑概念，它包含了以前的“数据库/表/分区锁管理器”的概念(hive.lock.Manager，缺省值为org.apache.hadoop.hive.ql.lockmgr.zookeeper.ZooKeeperHiveLockManager)。事务管理器现在还负责管理事务锁。默认的DummyTxnManager模仿老Hive版本的行为：没有事务，并使用hive.lock.Manager属性为表、分区和数据库创建锁管理器。新添加的DbTxnManager使用DbLockManager管理Hive Metastore中的所有锁/事务(事务和锁在服务器故障时是持久的)。这意味着在启用事务时，不再存在以前锁定Zookeeper中的行为了。为了避免客户端死掉并使事务或锁悬而未决，定期从锁持有者和事务发起者向Metastore发送心跳。如果在配置的时间内未接收到心跳，则锁或事务将被中止。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　从Hive 1.3.0开始，DbLockManger可以通过控制hive.lock.numretires和hive.lock.sleep.between.retries来设定尝试获取锁的时间。当DbLockManager无法获得锁(由于存在竞争锁)时，它将退出，并在某个时间段后再试。为了支持短时间运行的即席查询，而又不对Metastore压力太大，每次重试之后，DbLockManager将等待时间加倍。初始回退时间为100 ms，并以hive.lock.sleep.between.retries为上限。hive.lock.numretries是它将重试请求锁的总次数。因此，调用获取锁将阻塞的总时间(给定100次重试和60次睡眠时间)是(100 ms 200 ms 400 ms.51200 ms 60s ..60s)=91分钟：42秒：300毫秒。&lt;/p&gt;
&lt;p&gt;　　锁管理器中使用的锁的详细信息见&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ShowLocks&quot;&gt;Show locks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　请注意，使用DbTxnManager的锁管理器将获取所有表上的锁，即使是那些没有设置“transactional=true”属性的表。默认情况下，对非事务性表的INSERT操作将获得独占锁，从而阻止其他插入和读取。虽然在技术上是正确的，但这与传统Hive的工作方式(例如，w/o 锁管理器)是不同的, 为了向后兼容，提供了hive.txn.strict.locking.mode(见下表)模式，这将使该锁管理器在非事务性表的插入操作上获取共享锁。这恢复了以前的语义，同时仍然提供了锁管理器的好处，例如在读取表时防止表被删除。&lt;/p&gt;
&lt;p&gt;　　请注意，对于事务表，插入总是获取共享锁，因为这些表在存储层实现了MVCC架构，并且即使存在并发修改操作，也能提供读的强一致性（快照隔离）。&lt;/p&gt;

&lt;p&gt;　　必须设置这些配置参数的适当值，才能最低限度的打开Hive中的事务支持：&lt;/p&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;p&gt;    hive.support.concurrency  - true&lt;/p&gt;
&lt;p&gt;    hive.enforce.bucketing  - true（从Hive2.0不再需要）&lt;/p&gt;
&lt;p&gt;    hive.exec.dynamic.partition.mode  - nonstrict&lt;/p&gt;
&lt;p&gt;    hive.txn.manager  -  org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/p&gt;
&lt;p&gt;服务器端（Metastore）&lt;/p&gt;
&lt;p&gt;    hive.compactor.initiator.on  -  true（参见下面表格有详细介绍）&lt;/p&gt;
&lt;p&gt;    hive.compactor.worker.threads  -至少在一个metastore Thrift服务的实例设置为正数&lt;/p&gt;
&lt;p&gt;以下部分列出了所有影响Hive事务和紧缩的配置参数。另见上方的“限制”和下面的“表属性”。&lt;/p&gt;
&lt;h2&gt;7.1、 事务的新配置参数&lt;/h2&gt;
&lt;p&gt;　　许多新的配置参数已经被添加到系统，用以支持事务。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;48.415379864114&quot;&gt;&lt;tr&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;strong&gt;配置关键&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;strong&gt;默认值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;&lt;strong&gt;位置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;strong&gt;注解&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5789473684211&quot;&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.manager&quot;&gt;hive.txn.manager&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;见注解&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;客户端/&lt;br/&gt;HiveServer2&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;默认值： org.apache.hadoop.hive.ql.lockmgr.DummyTxnManager&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;支持事务所需的值： org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;而DummyTxnManager实现Hive 0.13前的行为，并且不提供事务支持。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.2820512820513&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.strict.locking.mode&quot;&gt;hive.txn.strict.locking.mode&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;客户端/ HiveServer2&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;在严格模式非ACID资源使用标准的R / W锁语义，例如INSERT将获得排他锁；在非严格模式，对于非ACID资源，INSERT将只获取共享锁，它允许两个并发写入到相同的分区，但仍让锁管理器在表被写入时阻止DROP TABLE等（从Hive 2.2.0）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.9827586206897&quot;&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.timeout&quot;&gt;hive.txn.timeout&lt;/a&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;300&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;客户端/&lt;br/&gt;HiveServer2 /Metastore &lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;如果客户没有发送心跳，多长时间（单位秒）之后宣布事务中止。对于所有组件/服务，至关重要的是此属性要有相同的值。（注5）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.4426229508197&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.heartbeat.threadpool.size&quot;&gt;hive.txn.heartbeat.threadpool.size&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt; 5&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;客户端/ HiveServer2&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;3.5&quot;&gt;
&lt;p&gt;用于心跳的线程数（从&lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-12366&quot;&gt;Hive 1.3.0和2.0.0&lt;/a&gt;开始）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.4285714285714&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.timedout.txn.reaper.start&quot;&gt;hive.timedout.txn.reaper.start&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;100秒&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Metastore启动后，启动第一个收割器(中止超时事务的进程)的延迟时间（从Hive 0.13开始）。用于控制上述的AcidHouseKeeperServcie。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.2686567164179&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.timedout.txn.reaper.interval&quot;&gt;hive.timedout.txn.reaper.interval&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;180秒&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;描述收割程序(中止超时事务的进程)运行频率的时间间隔。（从Hive 0.13开始）。用于控制上述的AcidHouseKeeperServcie。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4&quot;&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.max.open.batch&quot;&gt;hive.txn.max.open.batch&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;客户&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;可以在调用一次open_txns（）获取到事务的最大数量。（注1）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.1493506493506&quot;&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.max.open.txns&quot;&gt;hive.max.open.txns&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;100000&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;HiveServer2 /Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;打开的事务的最大数量。如果当前打开的事务达到此限制，则将来打开的事务请求将被拒绝，直到该数目低于限制为止。(从Hive 1.3.0和2.1.0)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.7916666666667&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.count.open.txns.interval&quot;&gt;hive.count.open.txns.interval&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;1秒&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;HiveServer2 /Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;检查打开事务计数的时间间隔（单位秒）(从Hive 1.3.0和2.1.0开始)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.759385665529&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.retryable.sqlex.regex&quot;&gt;hive.txn.retryable.sqlex.regex&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p&gt;“”（空字符串）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;HiveServer2 /Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5.1588785046729&quot;&gt;
&lt;p&gt;由逗号分隔的一组用于描述SQL状态，错误代码，可重试的SQLExceptions错误信息的正则表达式，这是适合于Hive Metastore数据库（从&lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-12637&quot;&gt;Hive 1.3.0和2.1.0&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;例子见&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.txn.retryable.sqlex.regex&quot;&gt;配置属性&lt;/a&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.24427480916&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.initiator.on&quot;&gt;hive.compactor.initiator.on&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;缺省值为false，支持事务的话需要为true。&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;是否在此Metastore实例上运行启动器（initiator）和清理（cleaner）的线程。在Hive1.3.0之前，关键是要正好在一个独立的Metastore服务实例上启用它(尚未强制执行)。从Hive1.3.0开始，可以在任意数量的独立Metastore实例上启用此属性。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.7789473684211&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.worker.threads&quot;&gt;hive.compactor.worker.threads&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;在这个metastore实例上运行多少个紧缩工作线程。（注2）&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;默认值为0，支持事务时至少在一个Metastore实例上大于0。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.6299212598425&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.worker.timeout&quot;&gt;hive.compactor.worker.timeout&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;86400&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;紧缩作业运行多长时间（秒）后会被宣告失败，并重新排队。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.84375&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.cleaner.run.interval&quot;&gt;hive.compactor.cleaner.run.interval&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5000&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;4.2857142857143&quot;&gt;
&lt;p&gt;运行清理线程的间隔（毫秒）。（&lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-8258&quot;&gt;Hive 0.14.0&lt;/a&gt;和更高版本）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5853658536585&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.check.interval&quot;&gt;hive.compactor.check.interval&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;300&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;检查表或分区是否需要紧缩的时间间隔（单位秒）。（注3）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.271186440678&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.delta.num.threshold&quot;&gt;hive.compactor.delta.num.threshold&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;在表或分区引发次要/轻度/minor紧缩的差量目录数目。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.0754189944134&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.delta.pct.threshold&quot;&gt;hive.compactor.delta.pct.threshold&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;0.1&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;触发一个主要/深度/major紧缩任务的增量文件相对基础文件大小的百分比。1 = 100％，默认0.1 = 10％。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5211267605634&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.abortedtxn.threshold&quot;&gt;hive.compactor.abortedtxn.threshold&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;p6&quot; align=&quot;center&quot;&gt;1000&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;p6&quot;&gt;触发一个主要/深度/major紧缩任务的涉及给定表或分区的中止事务数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.7913669064748&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.max.num.delta&quot;&gt;hive.compactor.max.num.delta&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;500&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;在单个紧缩作业中试图处理增量文件的最大数量(从Hive1.3.0开始)。（注4）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.934554973822&quot;&gt;&lt;td width=&quot;356&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.compactor.job.queue&quot;&gt;hive.compactor.job.queue&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;“”（空字符串）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;用于指定将提交紧缩作业到Hadoop队列的名称。设置为空字符串，则由Hadoop选择队列(从Hive1.3.0开始)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;4&quot; width=&quot;842&quot;&gt;
&lt;p&gt;&lt;span&gt;紧缩的历史记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hive.compactor.history.retention.succeeded&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;em&gt;3&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;要在历史记录中保留的成功紧缩条目的数量(每个分区)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hive.compactor.history.retention.failed&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;em&gt;3&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;要在历史记录中保留的紧缩失败条目的数量(每个分区)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hive.compactor.history.retention.attempted&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;em&gt;2&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;要在历史记录中保留的尝试紧缩条目的数量(每个分区)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hive.compactor.initiator.failed.compacts.threshold&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;em&gt;2&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;对给定分区紧缩连续失败的数目，在此之后，启动器（Initiator）将停止自动调度紧缩。此时，仍然可以使用ALTER TABLE来启动紧缩。一旦手动启动的紧缩成功，就恢复自动启动的紧缩。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;请注意，这个值必须小于hive.compactor.history.retention.failed。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;356&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hive.compactor.history.reaper.interval&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;em&gt;2M&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;89&quot;&gt;
&lt;p&gt;Metastore&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;349&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;控制清除compactions历史记录的进程多久运行一次。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　注1： hive.txn.max.open.batch控制流代理(如Flume或Storm)同时打开的事务。然后，流代理将该数量的条目写入单个文件(每个Flume代理或Storm bolt)。因此，增加此值会减少流代理创建的增量文件的数量。但它也会增加Hive在任何给定时间必须跟踪的已打开事务的数量，这可能会对读取性能产生负面影响。&lt;/p&gt;
&lt;p&gt;　　注2：工作线程生成MapReduce作业以执行紧缩。它们自己不执行紧缩。增加工作者线程的数量将减少需要紧缩的表或分区的时间。它也将增加Hadoop集群上的后台负载，因为更多MapReduce作业要在后台运行。每次紧缩都可以处理一个分区(如果没有分区，则是整个表)。&lt;/p&gt;
&lt;p&gt;　　注3： 减小该值将减少需要紧缩的表或分区启动紧缩所需的时间。然而，检查是否需要紧缩需要对每个表或分区调用NameNode，以确认每个表或分区自上一次主要/深度/major紧缩以来是否进行了事务处理。因此，降低此值将增加NameNode的负载。&lt;/p&gt;
&lt;p&gt;　　注4： 如果紧缩程序检测到有非常多的增量文件，它就首先运行几个小的部分紧缩(在当前顺序中)，然后执行实际请求的紧缩。&lt;/p&gt;
&lt;p&gt;　　注5： 如果该值不是相同的，则活动事务可能被确定为“timed out（超时）”并因此中止。这还将导致诸如“没有这样的事务（No such transaction）...”、“没有这样的锁（No such lock）...”之类的错误。&lt;/p&gt;
&lt;h2&gt;7.2、 为INSERT，UPDATE，DELETE设置的参数&lt;/h2&gt;
&lt;p&gt;　　除了上面列出的新参数，现有的一些为支持INSERT ... VALUES，UPDATE 和  DELETE需要而设置的参数。&lt;/p&gt;
&lt;p&gt;hive.support.concurrency    true（默认为false）&lt;/p&gt;
&lt;p&gt;hive.enforce.bucketing      true（默认为false）（从Hive2.0不再需要）&lt;/p&gt;
&lt;p&gt;hive.exec.dynamic.partition.mode    nonstrict不严格的（默认为strict严格的）&lt;/p&gt;
&lt;h2&gt;7.3、 为紧缩设置的参数&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　如果您的系统中的数据不属于Hive用户(即运行Hive Metastore的用户)，那么Hive需要以数据拥有者的身份运行才能执行紧缩操作。如果您已经设置了HiveServer 2模拟用户，那么唯一要做的额外工作就是确保Hive在运行Hive Metastore的主机上有模拟用户的权利。这是通过将主机名添加到Hadoop的core-site.xml文件中的hadoop.proxyuser.hive.host实现的，如果您还没有这样做，那么需要配置Hive作为代理用户，这要求您为运行Hive Metastore的用户设置keytab，并将hadoop.proxyuser.hive.host和hadoop.proxyuser.hive.group添加到Hadoop的core-site.xml文件中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　请参阅您的Hadoop版本中关于安全模式的Hadoop文档(例如，对于Hadoop2.5.1，请参阅&lt;a href=&quot;http://hadoop.apache.org/docs/r2.5.1/hadoop-project-dist/hadoop-common/SecureMode.html&quot;&gt;Hadoop的安全模式&lt;/a&gt;)。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　从Hive 0.14.0开始，如果一个表用于ACID写入（INSERT、UPDATE、DELETE），那么必须在该表中设置表属性“transactional=true”。注意，一旦表已被经由TBLPROPERTIES（“transactional=true”）定义为ACID表，它不能被转换回非ACID表，即不允许改变为TBLPROPERTIES（“transactional=false”）。此外，在运行任何查询之前，必须在hive-site.xml或会话开始时将hive.txn.Manager设置为org.apache.hadoop.hive.ql.lockmgr.DbTxnManager。如果不这样的话，插入将以旧的样式进行；更新和删除将在hive-11716之前被禁止。因为不允许在没有DbTxnManager的ACID表上进行Hive-11716操作。无论如何，这也不适用于Hive 0.13.0。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　如果表所有者不希望系统自动确定何时紧缩，则可以设置表属性“NO_AUTO_COMPACTION”。这将阻止所有自动紧缩。仍然可以使用ALTER Table /Partition Compact语句进行手动紧缩。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在创建或更改表时，使用TBLPROPERTIES子句设置表属性，如Hive数据定义语言的CREATE Table和&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-AlterTableProperties&quot;&gt;ALTER Table PROPERTIES&lt;/a&gt;部分所述。在Hive版本0.x和1.0中，表属性“transactional”和“NO_AUTO_COMPACTION”区分大小写，但从版本1.1.0(hive-8308)开始，它们是不区分大小写的。&lt;/p&gt;
&lt;p&gt;　　更多的与紧缩相关的选项可以通过与Hive 1.3.0和2.1.0的TBLPROPERTIES来设置。它们可以通过CREATE TABLE设置在表级别属性，也可以通过ALTER TABLE/Partition COMPACT在请求级别上设置。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　这些用于覆盖仓库/表范围的设置。例如，要覆盖MR属性以影响紧缩作业，可以在CREATE TABLE语句中或通过ALTER TABLE显式启动紧缩时，添加&quot;compactor.&amp;lt;mr property name&amp;gt;=&amp;lt;value&amp;gt;&quot;。这里所述的&quot; &amp;lt;mr property name&amp;gt;=&amp;lt;value&amp;gt;&quot;将设置在紧缩MR作业的Jobconf上。类似地,&quot; tblprops.&amp;lt;prop name&amp;gt;=&amp;lt;value&amp;gt;&quot;可用于设置/覆盖集群上所能解释的任何表属性代码。最后,&quot; compactorthreshold.&amp;lt;prop name&amp;gt;=&amp;lt;value&amp;gt;&quot;可用于替代来自&quot;新的事务配置参数&quot;中以&quot;.threshold&quot;结尾的属性，在由系统触发compact时进行控制。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;示例：&lt;/p&gt;
&lt;p&gt;例如：在TBLPROPERTIES中设置表级别的紧缩选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; table_name (
  id                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
  name              string
)
&lt;/span&gt;&lt;span&gt;CLUSTERED&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; (id) &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; BUCKETS STORED &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; ORC
TBLPROPERTIES (&quot;transactional&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;true&quot;,
  &quot;compactor.mapreduce.map.memory.mb&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;2048&lt;/span&gt;&quot;,                   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 指定紧缩map作业的属性&lt;/span&gt;
  &lt;span&gt;&quot;compactorthreshold.hive.compactor.delta.num.threshold&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;4&lt;/span&gt;&quot;,  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 如果有超过4个增量目录，则触发轻度紧缩&lt;/span&gt;
  &lt;span&gt;&quot;compactorthreshold.hive.compactor.delta.pct.threshold&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;0.5&lt;/span&gt;&quot; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 如果增量文件的大小与基础文件的大小的比率大于50%，则触发深度紧缩&lt;/span&gt;&lt;span&gt;
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 例如：在TBLPROPERTIES中设置请求级别的紧缩选项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; table_name COMPACT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;minor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
   &lt;span&gt;WITH&lt;/span&gt; OVERWRITE TBLPROPERTIES (&quot;compactor.mapreduce.map.memory.mb&quot;&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;3072&lt;/span&gt;&quot;);  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 指定紧缩map作业的属性&lt;/span&gt;

&lt;span&gt;ALTER&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; table_name COMPACT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;major&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
   &lt;span&gt;WITH&lt;/span&gt; OVERWRITE TBLPROPERTIES (&quot;tblprops.orc.compress.size&quot;&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;8192&lt;/span&gt;&quot;);         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 更改任何其他Hive表属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 11 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>范振勇</dc:creator>
<og:description>由 Alan Gates创建, 最终由 Andrew Sherman修改于2018年8月7日 原文链接：https://cwiki.apache.org/confluence/display/Hive</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanzhenyong/p/9775713.html</dc:identifier>
</item>
<item>
<title>【Maven】---坐标与依赖 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9775712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9775712.html</guid>
<description>&lt;p&gt;      最近想深度学习下maven，找到一本书叫《Maven实战》,这本书讲的确实很好，唯一遗憾的是当时maven教学版本是3.0.0的，而目前已经到了3.5.4了，版本存在差距,&lt;/p&gt;
&lt;p&gt;没关系，如果有时间和精力我也会阅读官方文档，看看到底有哪些变换。&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;     1、何为Maven坐标&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      maven定义了这样一组规则：世界上任何一个构件都可以使用maven坐标唯一标识，坐标元素包括：&lt;span&gt;groupId、artifactId、version、packaging、classifier&lt;/span&gt;。只要提供正确&lt;/p&gt;
&lt;p&gt;的坐标就能从仓库中找到相应的构件供我们使用。maven从哪里下载构件呢？答：maven内置了一个中央仓库的地址，该中央仓库包含了世界上大部分流行的开源构件。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、坐标详解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;任何构件都必须明确定义自己的坐标，而一组maven坐标是通过一些元素定义的，他们是：groupId、artifactId、version、packaging、classifier。先看一组坐标定义如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.sonatype.nexus&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nexus-indexer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是nexus-indexer项目的坐标，nexus-indexer是一个对maven仓库编纂索引并提供搜索功能的类库，它是Nexus项目的一个子模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;goupId&lt;/span&gt;&lt;/strong&gt;: 定义了当前maven项目隶属的实际项目，一般是域名+项目名。比如：com.alibaba.taotao&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;/strong&gt;：该元素定义实际项目中的一个maven项目（模块，一般推荐项目名+子模块名。比如：taobao-web&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;version&lt;/span&gt;&lt;/strong&gt;： 定义maven项目当前所处版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;/strong&gt;：定义maven项目的打包方式，默认使用jar。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;classifier&lt;/span&gt;&lt;/strong&gt;：该元素用来帮助定义构件输出的一些附属构件。&lt;/p&gt;
&lt;p&gt;上述5元素&lt;span&gt;groupId、artifactId、version是必须的&lt;/span&gt;，packaging可选，默认jar，classifier不能直接定义。同时，项目构件的文件名是与坐标对应的，&lt;/p&gt;
&lt;p&gt;一般的规则为artificatId-version[-classifier].packaging。packing并非一定与构件扩展名对应，比如packing为maven-plugin的构件扩展名为jar。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、依赖详解&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、依赖的配置&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;一般的依赖只有基本的 groupId，artifactId，version。我们来看下详细的依赖配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            ...
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;gourpId、artifactId、version：&lt;/span&gt;&lt;/strong&gt;依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，maven根据坐标才能找到需要的依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;         type：&lt;/span&gt;&lt;/strong&gt;依赖的类型，对于项目坐标定义的packing，大部分情况是不必声明，默认是jar。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      scope&lt;/strong&gt;&lt;/span&gt; ：依赖的范围 下面具体讲解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    optional&lt;/span&gt;&lt;/strong&gt;: 标记依赖是否可选，值为true或false，默认为false, 如果为可选依赖，则依赖不具有传递性。即B-&amp;gt;X(可选依赖)，A-&amp;gt;B。此时A的依赖中不包含X。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;exclusions：&lt;/span&gt;&lt;/strong&gt;用来排除传递性依赖。&lt;/p&gt;
&lt;p&gt;大部分依赖声明只包含基本坐标，然而在一些特殊情况下，其他元素至关重要。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、依赖范围scope&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;classpath：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;用于指定.class文件存放的位置，类加载器会从该路径中加载所需的.class文件到内存中。maven在编译、执行测试、实际运行有着三套不同的classpath。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;编译classpath&lt;/span&gt;&lt;/strong&gt;：编译主代码有效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试classpath：&lt;/span&gt;&lt;/strong&gt;编译、运行测试代码有效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运行classpath：&lt;/span&gt;&lt;/strong&gt;项目运行时有效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maven的依赖范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; compile：&lt;/span&gt;&lt;/strong&gt;编译依赖范围。（默认方式），有效范围：编译classpath+测试classpath+运行classpath。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;      test：&lt;/span&gt;&lt;/strong&gt;测试依赖范围。有效范围：测试classpath  比如：JUnit，只在测试时使用，在编译主代码和运行时不需要此依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;provided：&lt;/span&gt;&lt;/strong&gt;已提供依赖范围。有效范围：编译classpath+测试classpath。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; runtime：&lt;/span&gt;&lt;/strong&gt;运行时依赖范围。有效范围：测试classpath+运行classpath。比如：JDBC驱动实现（mysql-connector-java）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  system：&lt;/span&gt;&lt;/strong&gt;系统依赖范围。有效范围：编译classpath+测试classpath。使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径，&lt;/p&gt;
&lt;p&gt;因为此类依赖不是通过maven仓库解析的，而且往往与本地及其系统绑定，可能造成构建的不可移植，慎用。systemPath元素可以引用环境变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181011225217555-1106163690.png&quot; alt=&quot;&quot; width=&quot;828&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;你引用本地的jar包，当然只能本地使用了&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;javax.sql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc-stdext&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;system&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;systemPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${JAVA_HOME}/lib/rt.jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;systemPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;你会发现这里这里是test，那么里面有个@Test 注解 只能在test目录下有效，在main目录下该注解是无效的&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;    3、传递依赖性 &lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;假设&lt;span&gt;A依赖B，B依赖C，则A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖&lt;/span&gt;。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。&lt;/p&gt;
&lt;p&gt;如下表，最左边是第一直接依赖范围，上面是第二直接依赖范围，中间交叉单元格表示传递性依赖范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181011225615587-851208649.png&quot; alt=&quot;&quot; width=&quot;890&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;规律：&lt;/p&gt;
&lt;p&gt;第二直接依赖范围是compile时，传递依赖的范围与第一直接依赖范围一致。&lt;/p&gt;
&lt;p&gt;第二直接依赖范围是test时，依赖不会传递。&lt;/p&gt;
&lt;p&gt;第二直接依赖范围是provided时,只传递第一直接依赖为provided的依赖。&lt;/p&gt;
&lt;p&gt;第二直接依赖范围是runtime时,传递依赖的范围与第一直接依赖范围一致，但是compile例外，此时传递依赖范围为runtime。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    4、依赖调节&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部 分情况下我们只需要关心项0的直接依赖是什么，而不用考虑这些直接依赖会引人什么传 递性依赖。&lt;/p&gt;
&lt;p&gt;但有时候，当传递性依赖造成问题的时候，我们就需要清楚地知道该传递性依 赖是从哪条依赖路径引入的。&lt;/p&gt;
&lt;p&gt;例如，项目A有这样的依赖关系：A-&amp;gt;B-&amp;gt;C-&amp;gt;X(1.0)、A-&amp;gt;D-&amp;gt;X(2.0)，X是A的 传递性依赖，但是两条依赖路径上有两个版本的X,那么哪个X会被Maven解析使用呢?&lt;/p&gt;
&lt;p&gt;两个版本都被解析显然是不对的，因为那会造成依赖重复，因此必须选择一个。Maven依 赖调解（Dependency Mediation)的第一原则是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;路径最近者优先。&lt;/span&gt;该例中X( 1.0)的路径氏 度为3,而X(2.0)的路径长度为2,因此X(2.0)会被解折使用。&lt;/p&gt;
&lt;p&gt;依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A-&amp;gt;B-&amp;gt;Y(1.0)、A-&amp;gt; C-&amp;gt;Y(2.0)，Y(1.0)和Y(2.0)的依赖路径长度是一样的，都为2。Maven定义了依赖调解的第二原则：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一声明者优先&lt;/span&gt;。在依 赖路径长度相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用，顺序最前的那个依赖优胜。该例中，如果B的依赖声明在C之前，那么Y (1.0)就会被解析使用.&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;   5、排除依赖&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;传递性依赖会给项目引入很多依赖，简化项目依赖管理，但是也会带来问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求&lt;/span&gt;：比如当前项目有一个第三方依赖，而第三方依赖依赖了另一个类库的SNAPSHOT版本，那么这个SNAPSHOT就会成为当前项目的传递性依赖，而SNAPSHOT的不稳定性会直接影响到当前项目。&lt;/p&gt;
&lt;p&gt;这时候就应该排除掉SNAPSHOT。并且声明该类库的正式发布版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.hibernate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hibernate-validator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.6.10.Final&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     上述代码中hibernate-validator依赖slf4j-api，但是当前项目不想使用传递过来的slf4j-api，所以通过&lt;span&gt;exclusions&lt;/span&gt;声明排除依赖。当前项目声明了自己需要的1.7.12版本的slf4j-api。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;exclusions可以包含一个或者多fexdWon子元素，因此可以排除一个或者多 个传递性依赖&lt;/span&gt;。需要注意的是，声明exclusion的时候只需要groupld和artifactld,而不 笛要version元素，&lt;/p&gt;
&lt;p&gt;这是因为只需要gmupkl和arlifactid就能唯一定位依赖图中的某个依 赖。换句话说，Maven解析后的依赖中，不可能出现groupW和artifactld相同，但是 version不同的两个依赖。&lt;/p&gt;
&lt;p&gt;注意：&lt;span&gt;排除依赖的时候也要注意，比如A依赖1.1版本的B, ,而你不想要1.1版本的B,而是要2.1的B,这个时候也需要考虑A跟2.1的B是否能兼容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201810/1090617-20181011230932388-553707554.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;6、归类依赖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求&lt;/span&gt;：关于springframework的依赖有好多，org.springframework:spirng-core:2.5.6、org.springframework:sprng-beans:2.5.6、org.springframework:spring-context:2.5.6，&lt;/p&gt;
&lt;p&gt;他们来自同一个项目不同模块，因此版本都是相同的，可以预见在升级spring时这些依赖都会一起升级，为了方便统一所以使用properties元素定义maven属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
....
 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;springframework.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.3.2.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;springframework.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过使用${springframework.version}替换掉实际值，将所有spring依赖的版本值都使用这一引用值表示。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${springframework.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-beans&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${springframework.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${springframework.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;《Maven实战》. 许晓斌 &lt;/p&gt;
&lt;p&gt;同时很高兴，找到看过这本书的人的总结。&lt;/p&gt;
&lt;p&gt;坐标详解：&lt;a href=&quot;https://www.jianshu.com/p/30ece967dccd&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/30ece967dccd&lt;/a&gt;&lt;br/&gt;依赖配置：&lt;a href=&quot;https://www.jianshu.com/p/79cf4423281a%20%20%20&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/79cf4423281a&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天一亮，又是崭新的起点，又是未知的征程（上校20）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 11 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Maven坐标与依赖 最近想深度学习下maven，找到一本书叫《Maven实战》,这本书讲的确实很好，唯一遗憾的是当时maven教学版本是3.0.0的，而目前已经到了3.5.4了，版本存在差距, 没关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9775712.html</dc:identifier>
</item>
</channel>
</rss>