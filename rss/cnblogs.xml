<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第0次作业 - 李孟男</title>
<link>http://www.cnblogs.com/lmn1234/p/8590265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lmn1234/p/8590265.html</guid>
<description>&lt;p&gt;（1）最理想的师生关系是健身教练与学员之间的关系 古往今来，对于师生关系都有很多说法，褒贬不一。如父子关系，师徒关系等等。那么师生关系有是怎样的关系呢？ 我认为理想的师生关系有以下特征：首先是民主平等。师生之间民主平等的关系是社会主义民主平等的人际关系的反映，是教育活动取得良好效果的重要条件。其次是尊师爱生。尊师爱生是指学生应当尊重教师，教师应当热爱学生，师生之间彼此尊重、相互友爱，这是建立良好师生关系的感情基础。接下来就是教学相长。教学相长是指在教育教学中教师和学生是相互制约、相互促进、共同提高的。最后就是心理相容。心理相容是指教师与学生在心理上彼此协调一致、相互接纳。所以我同意邹欣老师的说法，最理想的师生关系是健身教练与学员之间的关系。教练可以像朋友一样和你相处，陪你锻炼。可以像老师一样教你。也可以互相督促，最后健身教练一般都很年轻，没有什么代沟，符合最后一条。而且每个学员来到健身会所都是为了锻炼学习而来的，所以我希望我们的老师可以像健身教练一样，根据我们的自身情况而调节教学方法，不要教死书，死教书，因为健身教练和学员关系的本质在于学员有意愿，健身教练做的便是督导。学员想要达成某种目的而去找教练监督自己来帮助自己达成自己的目的。这样一来学生也就不会出现叛逆，不认真去学习，不学习，不听课，不完成作业等情况，老师也不会因为去监管学生而烦心了。 （2）我对博客中的评分规则有什么意见和建议？ 我对博客中提到的评分规则是抱有肯定态度的，因为没有规矩不成方圆，任何事都需要有规矩，而这个评分规则是相对公平的，没有人能够取巧，取巧的人被惩罚也是理所当然的，没有在规定时间内完成任务的也是不合格的，所以不给予分数是有道理的，而超过一个星期才完成的比不按时的更为严重，所以应该倒扣这次的分数，而写出来的作业也不是为了完成作业而完成作业，作业的质量的也是有要求的，满篇文章如果都是流水账，那么这个文章将没有任何存在的意义和价值。但是这只是第一次作业，我个人认为分数不应该存在负分，因为那样我认为会严重打消本来就不积极的人的积极性，导致那些人破罐子破摔，直接放弃治疗，因而对这个学科失去的兴趣。ABCD四个评分的档次也是必须要有的，因为在任何时候都需要有一个大概的排名而不是普度众生，给所有完成的人一个相同的分数，因为那样对那些认真完成的人是很不公平的，他们可能耗费比别人多出一倍的时间去完成作业，而得到的分数却是和那些糊弄的人分数一样，久而久之，认真完成作业的人的数量也会逐渐的减少。而且作业的要求也都有明确的表示，不存在不会做或者做错的问题，在有绝对正确的解释面前，任何的借口都是软弱无力的，所以我认为这个评分的方案是正确的无疑，只是有一些略微的严格，毕竟慈母无孝子，严师出高徒，就我个人认为这是可行的。 （3）你读了该博客中哪些超链接？有何感想？ 由于时间关系我读了几篇博文是我感触比较深的就是我读的这一篇 《病梅馆记》 它讲的是封建统治阶级以暴力解决问题，压迫，剥削，百姓，从而使百姓陷入了苦不堪言的境界，这篇博文的写作背景就是在清朝封建统治者为了加强思想统治，奴役人民，政权当道，一方面以八股文作为科举考试选用人才的法定文体，以束缚人们的思想，镇压知识分子.在长期严酷的思想统治下，人才遭受严重的压抑和摧残，激起了反抗的勇气。作者托梅议政，在这个文章中，文人墨客说梅什么样什么样是好的，卖梅的人就以这些形象作为卖点，故意把梅做成这个样子来时自己收益大增，作者痛恨这种做法，高呼自己怎么不能有更多的空间和时间来治疗杭苏的病梅，这个文章形象地揭露和抨击了清朝封建统治者束缚人们思想，压抑，摧残人才的罪行，表达了作者要求改革政治，打破严酷的思想统治，追求个性解放的强烈愿望。在文章中生动的体现出如果把老师比作园丁是好的，也与不好的反方向的例子 关于编辑方式markdown的教程只是教会了我怎么去设置我并不知道怎么去使用它。还有许多超链接中的超链接，内容很丰富，尤其是在师生关系这个超链接中，其中举例了多种师生间的矛盾的情况，这说明师生矛盾在我们的生活中还是非常显著的，我们之间都需要相互体谅去避免发生。我们整个博客作业，不仅仅只有我们同学在完成它还有许多老师的心血，为我们共同的进步。以上就是我阅读的超链接和阅读感想。 （4）我的大学目标 1）学习目标要明确，做好切实可行的计划。 2）合理安排时间，按时完成学习任务。 3）养成做笔记的习惯。 4）认真地完成布置的作业，养成自主的学习习惯。 5）不断加强专业学习，确定补修专业。 6）利用课余时间兼职与自己专业相关的工作。 总之，虽然客观制定了个人初步学习计划，但还存在许多不完善与不足之处，还需要今后根据自己的切实情况，在学习中不断地补充，加以改进、及时地总结经验，以合格的成辑来完成自己三年的学业。 本学期的规划 由于我计算机不精通，相当于从头学起，所以我决定跟紧老师的步伐，学习一些简单的代码编程，并且我会认真记笔记把老师的内容记录，然后利用课余时间自主学习，每天空出一到两个小时学习这门课程。&lt;/p&gt;



</description>
<pubDate>Sat, 17 Mar 2018 07:35:00 +0000</pubDate>
<dc:creator>李孟男</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lmn1234/p/8590265.html</dc:identifier>
</item>
<item>
<title>systemd的作用 - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/8577504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/8577504.html</guid>
<description>&lt;p&gt;早上群上讨论了一下systemd的作用，还导致了一个人的直接退群，出于求知心理，搜索了一些systemd，对此也作出了一些相应的整理；&lt;/p&gt;
&lt;h2&gt;一、systemd的诞生：&lt;/h2&gt;
&lt;p&gt;学习嵌入式bootloader与kernel衔接的时候，就入门了init进程；init进程也就是系统的第一个进程，PID号为1；&lt;/p&gt;

&lt;p&gt;init进程总所周知的问题是从它开始启动，并从下一个程序开始，都是以一个进程启动另一个进程的方式来进行；这样做的显而易见的缺点就是执行速度慢，没有一整套的系统来管理，并且/ect/目录下的随便一个脚本简直长的发指；关机过程差不多是相反的过程，首先init停止所有服务，最后阶段会卸载文件系统。&lt;/p&gt;

&lt;p&gt;所以伟大的程序员开始了自己的创作，systemd也就诞生啦。systemd 几乎完全兼容传统的 SysV init 系统： SysV init 脚本可以作为另一种配置文件格式被识别； 提供与 SysV 兼容的 &lt;code class=&quot;filename&quot;&gt;/dev/initctl&lt;/code&gt; 接口； 提供各种 SysV 工具的兼容实现； 依然兼容例如 &lt;code class=&quot;filename&quot;&gt;/etc/fstab&lt;/code&gt; 或者 &lt;span&gt;utmp&lt;/span&gt;之类传统的 Unix 特性。&lt;/p&gt;

&lt;p&gt;systemd现在广泛用于Fedora 21、Ubuntu（Ubuntu 15.04以上）、Centos等linux操作系统上；&lt;/p&gt;

&lt;h2&gt;二、systemd是什么？&lt;/h2&gt;
&lt;p&gt;开发Systemd的主要目的就是减少系统引导时间和计算开销。&lt;/p&gt;
&lt;p&gt;Systemd（系统管理守护进程），最开始以GNU GPL协议授权开发，现在已转为使用&lt;a href=&quot;https://baike.baidu.com/item/LGPL/10583469?fr=aladdin&quot; target=&quot;_blank&quot;&gt;GNU LGPL&lt;/a&gt;协议，它是如今讨论最热烈的引导和服务管理程序。如果你的Linux系统配置为使用Systemd引导程序，它取替传统的init进程，启动过程将交给systemd处理。Systemd的一个核心功能是它同时支持init进程的后开机启动脚本。&lt;/p&gt;

&lt;p&gt; Systemd引入了并行启动的概念，它会为每个需要启动的守护进程建立一个套接字，这些套接字对于使用它们的进程来说是抽象的，这样它们可以允许不同守护进程之间进行交互。Systemd会创建新进程并为每个进程分配一个控制组（&lt;a href=&quot;https://www.cnblogs.com/caoxiaojian/p/5633430.html&quot; target=&quot;_blank&quot;&gt;cgroup&lt;/a&gt;）。处于不同控制组的进程之间可以通过内核来互相通信。 cgroups 信息由内核负责维护， 并且可以通过 &lt;code class=&quot;filename&quot;&gt;/sys/fs/cgroup/systemd/&lt;/code&gt; 接口进行访问。&lt;/p&gt;

&lt;p&gt;当作为系统实例运行时， systemd 将会按照 &lt;code class=&quot;filename&quot;&gt;system.conf&lt;/code&gt; 配置文件 以及 &lt;code class=&quot;filename&quot;&gt;system.conf.d&lt;/code&gt; 配置目录中的指令工作； 当作为用户实例运行时，systemd 将会按照 &lt;code class=&quot;filename&quot;&gt;user.conf&lt;/code&gt; 配置文件 以及 &lt;code class=&quot;filename&quot;&gt;user.conf.d&lt;/code&gt; 配置目录中的指令工作。&lt;/p&gt;
&lt;h3&gt;2.1 单位：&lt;/h3&gt;
&lt;p&gt;systemd 将各种系统启动和运行相关的对象， 表示为各种不同类型的单元(unit)， 并提供了处理不同单元之间依赖关系的能力。 &lt;/p&gt;
&lt;p&gt;Systemd 的其中一个目标就是简化这些事物之间的相互作用，因此如果你有程序需要在某个挂载点被创建或某个设备被接入后开始运行，Systemd 可以让这一切正常运作起来变得相当容易。&lt;/p&gt;
&lt;p&gt;各种不同的单元类型如下：&lt;/p&gt;
&lt;ol class=&quot;orderedlist&quot; type=&quot;1&quot; readability=&quot;13&quot;&gt;&lt;li class=&quot;listitem&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;service 单元。用于封装一个后台服务进程。 &lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;socket 单元。 用于封装一个系统套接字(UNIX)或互联网套接字(INET/INET6)或FIFO管道。 相应的服务在第一个&quot;连接&quot;进入套接字时才会被启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;target 单元。 用于将多个单元在逻辑上组合在一起。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;device 单元。用于封装一个设备文件，可用于基于设备的启动。 并非每一个设备文件都需要一个 device 单元， 但是每一个被 udev 规则标记的设备都必须作为一个 device 单元出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;mount 单元。 用于封装一个文件系统挂载点(也向后兼容传统的 /etc/fstab 文件)。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;automount 单元。 用于封装一个文件系统自动挂载点，也就是仅在挂载点确实被访问的情况下才进行挂载。 它取代了传统的 autofs 服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;timer 单元。 用于封装一个基于时间触发的动作。它取代了传统的 atd, crond 等任务计划服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;swap 单元。 用于封装一个交换分区或者交换文件。 它与 mount 单元非常类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;path 单元。 用于根据文件系统上特定对象的变化来启动其他服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;slice 单元。 用于控制特定 CGroup 内(例如一组 service 与 scope 单元)所有进程的总体资源占用。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;scope 单元。它与 service 单元类似，但是由 systemd 根据 D-bus 接口接收到的信息自动创建， 可用于管理外部创建的进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;systemd 能够处理各种类型的依赖关系， 包括依赖与冲突(也就是 &lt;code class=&quot;varname&quot;&gt;Requires=&lt;/code&gt; 与 &lt;code class=&quot;varname&quot;&gt;Conflicts=&lt;/code&gt; 指令)， 以及先后顺序(也就是 &lt;code class=&quot;varname&quot;&gt;After=&lt;/code&gt; 与 &lt;code class=&quot;varname&quot;&gt;Before=&lt;/code&gt; 指令)。 注意， 上述两种类型的依赖关系(依赖与冲突、先后顺序)之间是相互独立的(无关的)。 举例来说，假定 &lt;code class=&quot;filename&quot;&gt;foo.service&lt;/code&gt; 依赖于(Requires) &lt;code class=&quot;filename&quot;&gt;bar.service&lt;/code&gt; 但并未指定先后顺序， 那么这两个服务将被同时并行启动。 不过在两个单元之间既存在依赖关系也存在先后顺序的情形也很常见。 另外需要注意的是， 大多数依赖关系都是由 systemd 隐式创建和维护的， 因此没有必要额外手动创建它们。&lt;/p&gt;


&lt;h3&gt;2.2 systemctl：&lt;/h3&gt;
&lt;p&gt;systemctrl是systemd的系统管理的指令，相应指令如下：&lt;a href=&quot;http://man.linuxde.net/systemctl&quot; target=&quot;_blank&quot;&gt;http://man.linuxde.net/systemctl&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 重启系统
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl reboot
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 关闭系统，切断电源
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl poweroff
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;# CPU停止工作
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl halt
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;# 暂停系统
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl suspend
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 让系统进入冬眠状态
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; systemctl hibernate
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;# 让系统进入交互式休眠状态
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; systemctl hybrid-&lt;span&gt;sleep&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;# 启动进入救援状态（单用户状态）
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; systemctl rescue
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2.3 target文件：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Systemd使用“target”来处理引导和服务管理过程。这些systemd里的“target”文件被用于分组不同的引导单元以及启动同步进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。&lt;/p&gt;

&lt;p&gt;传统的&lt;code&gt;init&lt;/code&gt;启动模式里面，有&lt;a href=&quot;http://www.cnblogs.com/linhaostudy/p/Linux运行级别（runlevel）&quot; target=&quot;_blank&quot;&gt;运行级别&lt;/a&gt;的概念，跟 Target 的作用很类似。不同的是，运行级别是互斥的，不可能多个运行级别同时启动，但是多个 Target 可以同时启动。&lt;/p&gt;

&lt;p&gt;它与&lt;code&gt;init&lt;/code&gt;进程的主要差别如下。&lt;/p&gt;
&lt;p&gt;（1）默认的 RunLevel（在&lt;code&gt;/etc/inittab&lt;/code&gt;文件设置）现在被默认的 Target 取代，位置是&lt;code&gt;/etc/systemd/system/default.target&lt;/code&gt;，通常符号链接到&lt;code&gt;graphical.target&lt;/code&gt;（图形界面）或者&lt;code&gt;multi-user.target&lt;/code&gt;（多用户命令行）。&lt;/p&gt;

&lt;p&gt;（2）启动脚本的位置，以前是&lt;code&gt;/etc/init.d&lt;/code&gt;目录，符号链接到不同的 RunLevel 目录 （比如&lt;code&gt;/etc/rc3.d&lt;/code&gt;、&lt;code&gt;/etc/rc5.d&lt;/code&gt;等），现在则存放在&lt;code&gt;/lib/systemd/system&lt;/code&gt;和&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录。&lt;/p&gt;

&lt;p&gt;（3）配置文件的位置，以前&lt;code&gt;init&lt;/code&gt;进程的配置文件是&lt;code&gt;/etc/inittab&lt;/code&gt;，各种服务的配置文件存放在&lt;code&gt;/etc/sysconfig&lt;/code&gt;目录。现在的配置文件主要存放在&lt;code&gt;/lib/systemd&lt;/code&gt;目录，在&lt;code&gt;/etc/systemd&lt;/code&gt;目录里面的修改可以覆盖原始设置；&lt;/p&gt;

&lt;h3&gt;2.4 日志文件：&lt;/h3&gt;
&lt;p&gt;systemd使用journalctl来管理相应的日志文件；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 查看所有日志（默认情况下 ，只保存本次启动的日志）
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; journalctl
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 查看内核日志（不显示应用日志）
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -&lt;span&gt;k
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;# 查看系统本次启动的日志
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -&lt;span&gt;b
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -b -&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;# 查看上一次启动的日志（需更改设置）
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -b -&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;# 查看指定时间的日志
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --since=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-10-30 18:17:16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --since &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20 min ago&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --&lt;span&gt;since yesterday
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --since &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2015-01-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --&lt;span&gt;until&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2015-01-11 03:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --since &lt;span&gt;09&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; --&lt;span&gt;until&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1 hour ago&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# 显示尾部的最新10行日志
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -&lt;span&gt;n
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 显示尾部指定行数的日志
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -n &lt;span&gt;20&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;# 实时滚动显示最新日志
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -&lt;span&gt;f
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;# 查看指定服务的日志
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl /usr/lib/systemd/&lt;span&gt;systemd
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;# 查看指定进程的日志
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl _PID=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;# 查看某个路径的脚本的日志
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl /usr/bin/&lt;span&gt;bash
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;# 查看指定用户的日志
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl _UID=&lt;span&gt;33&lt;/span&gt; --&lt;span&gt;since today
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;# 查看某个 Unit 的日志
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -&lt;span&gt;u nginx.service
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -u nginx.service --&lt;span&gt;since today
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;# 实时滚动显示某个 Unit 的最新日志
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -u nginx.service -&lt;span&gt;f
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;# 合并显示多个 Unit 的日志
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; $ journalctl -u nginx.service -u php-fpm.service --&lt;span&gt;since today
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;# 查看指定优先级（及其以上级别）的日志，共有8级
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; # &lt;span&gt;0&lt;/span&gt;&lt;span&gt;: emerg
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;&lt;span&gt;: alert
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;: crit
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;: err
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; # &lt;span&gt;4&lt;/span&gt;&lt;span&gt;: warning
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; # &lt;span&gt;5&lt;/span&gt;&lt;span&gt;: notice
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; # &lt;span&gt;6&lt;/span&gt;: &lt;span&gt;info&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; # &lt;span&gt;7&lt;/span&gt;&lt;span&gt;: debug
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -p err -&lt;span&gt;b
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; # 日志默认分页输出，--no-&lt;span&gt;pager 改为正常的标准输出
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --no-&lt;span&gt;pager
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;# 以 JSON 格式（单行）输出
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -b -u nginx.service -&lt;span&gt;o json
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;# 以 JSON 格式（多行）输出，可读性更好
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl -b -&lt;span&gt;u nginx.serviceqq
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;  -o json-&lt;span&gt;pretty
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;# 显示日志占据的硬盘空间
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --disk-&lt;span&gt;usage
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;# 指定日志文件占据的最大空间
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --vacuum-size=&lt;span&gt;1G
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt; &lt;span&gt;# 指定日志文件保存多久
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; $ &lt;span&gt;sudo&lt;/span&gt; journalctl --vacuum-&lt;span&gt;time&lt;/span&gt;=1years
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;三、systemd的争议：&lt;/h2&gt;
&lt;p&gt;直接看知乎问题吧：&lt;a href=&quot;https://www.zhihu.com/question/25873473&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/25873473&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 07:29:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/8577504.html</dc:identifier>
</item>
<item>
<title>项目微管理9 - 质量 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/8589375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/8589375.html</guid>
<description>&lt;p&gt;说起质量，程序员都是一把辛酸泪啊。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;渐行渐远的质量体系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;对于质量，不光每个公司非常重视，很多的国际化组织也非常重视，于是他们纷纷搞出了种种质量体系，于是，大批热衷于考试的同学们又有活干了，于是，大批的培训机构也从心里乐开了花。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317140423384-512274067.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;渐行渐远的混账质量体系，四代就不愿意多想了，四代还是把目光集中在了实际的项目质量上。如何来衡量软件的质量？这个倒是大家都懂，根据Bug数量嘛！&lt;/p&gt;

&lt;p&gt;提起Bug，四代想起一个段子：“问：程序猿最讨厌康熙的哪个儿子。答：胤禩。因为他是八阿哥（bug）”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317140833510-2005911191.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;确实，Bug的数量客观的反映了软件的质量，所以大量的公司把Bug的数目列入开发人员的考核指标中的做法就不足为奇了。既然这样，为了提高软件质量，我们就减少Bug数目嘛，听起来无比正确，无比英明！甚至还有的兄弟直接提出：应该 0 Bug嘛！可是实际情况是这样的吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bug是怎么炼成的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;要真正的了解Bug的意义，需要首先来了解一下Bug的组成。通常来说，实际的项目运作中，开Bug会出现在如下场景中：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317140948665-2132422808.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;1. 软件实际功能与预期的表现不同&lt;/p&gt;

&lt;p&gt;这个不需要多说了，实现的功能和设计的不一样，这个是狭义上Bug的全部含义，这也是传统意义上软件质量的全部含义。这帮小子，看我怎么收拾他们，哼！这是大多数项目经理看到这些Bug的第一感觉。&lt;/p&gt;

&lt;p&gt;2. 软件缺少一些功能&lt;/p&gt;

&lt;p&gt;少一些功能，严格来说，不是软件的缺陷，很多的公司也是采用各种文档和工具来管理这些需求，行不行？非常行！只不过作为一个以敏捷为核心理念的“互联网+”时代的团队，四代觉得不用这么麻烦。&lt;/p&gt;

&lt;p&gt;敏捷精神大幅削弱文档的重要性，需求文档可以作为收集需求时的重要方式保存下来。不过对于团队来说，把它们理解后记入Bug也是一个非常灵活的方式，虽然有时候往往也会需要一份详细的设计文档来描述设计细节。&lt;/p&gt;

&lt;p&gt;3. 用户对软件功能不满意&lt;/p&gt;

&lt;p&gt;这货不是说功能没有，也不是说开发错了，而是开发出的功能与客户的习惯不匹配，不习惯自然就不满意了，于是电话来了，客服MM必须要安慰一下，然后开个Bug提交给研发部门，谁让客户是上帝呢！&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317141204846-1810929236.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;不过很明显很多人对上帝的理解有误，认为他钱花了，就是大爷，态度非常强横，更过分的是很多人还没花钱也这么强横。&lt;/p&gt;

&lt;p&gt;4. 团队对功能的改进计划&lt;/p&gt;

&lt;p&gt;这一部分主要来自团队内部对软件的改进意见，大部分可能是从技术角度来说的，比如重构，架构等。&lt;/p&gt;

&lt;p&gt;从长远的来看，代码的质量也严重影响着软件的质量，这里代码的质量可不仅仅包括正确性，更多指的是代码的可读性，传承性，也就是：简单，简洁，简短，灵活。&lt;/p&gt;

&lt;p&gt;在四代的经历中，这几乎就是开Bug的几个最主要的动因了。除此以外，还有许多无法纳入正常分类的各种稀奇古怪的问题，大家通常的做法也是开Bug。&lt;/p&gt;

&lt;p&gt;纵观上面所有的类型，简单的用一句话来总结就是：&lt;span&gt;&lt;strong&gt;Bug是多样的，不仅仅是质量的指标，更为贴切的说，Bug是协同工作的工具&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bug是合作的工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;这么一说，你还觉的使用Bug数量来衡量开发人员的绩效还有道理吗？&lt;/p&gt;

&lt;p&gt;其实在四代的经历中，只要是尝试这么做的团队，几乎都会把开发团队逼急，以致于时常看到开发和测试大撕逼的情形。&lt;/p&gt;

&lt;p&gt;四代至今还清晰记得在某年的年会上，某测试团队自编的一个小品。这个小品的场景模仿的就是植物大战僵尸，只不过植物换成了开发团队，僵尸换成了高举着Bug的测试团队。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317141744141-128956098.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;在一波波Bug的来袭中，开发和测试之间不断斗智斗勇，最终在一大波Bug来袭中，无力回天的开发们终于祭出了最强的技能-Postpond，就是延期处理，于是世界清净了。&lt;/p&gt;

&lt;p&gt;四代用大拇指都可以想象得到，演这场戏的时候，测试团队是多么的无奈，而开发对于Bug是多么的抵制。因为Bug代表着绩效不好，代表着实际利益的损失，这就是很多开发团队一听到开Bug就急眼的原因。在这种情形下，Bug代表否定，这就是开发团队的后顾之忧，安全隐患。&lt;/p&gt;

&lt;p&gt;而对于斗争的另一方-测试团队来说，一旦Bug数量也成为衡量团队的绩效的指标的话，那么效果立竿见影，开发团队和测试团队立即水火不容，这对于团队来说真的是最为糟糕的事情了。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317141955370-960297064.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;于是，四代在确立考评精神的那个时刻开始，就立即将Bug排除在外了。这样，开发没有了后顾之忧，测试没有了利益驱动。&lt;/p&gt;

&lt;p&gt;而且四代还会不断的强化Bug合作的功效，鼓励大家有什么问题就多开Bug，于是大家可以平心静气的对待Bug了，大家不再害怕Bug了，&lt;span&gt;&lt;strong&gt;Bug终于恢复了其本来的面目：合作的工具，质量的表现！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;论项目经理技术必须过关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;这样一来，很多人一定觉得天可能会塌下来，对于那些滥竽充数的开发来说，没有质量的概念了，那还不就随便搞了，继而，劣币驱逐良币，整个团队就不好了。是吗？很多人一定是这么想的，四代如是说！&lt;/p&gt;

&lt;p&gt;在四代的周围存在大量这样的人，事事追求完美的结果，如果不可以就不会去做了。这样的同学总是期待通过考评一件事把所有的绩效问题都解决，也希望通过Bug把所有的质量问题都解决。这样考虑问题往往缺乏系统性，四代以前也是这么思考问题的。&lt;/p&gt;

&lt;p&gt;不过，四代现在的思路就是，既然单点发挥了最大的优点，但是有缺点怎么办？那就通过系统的其他点来补充，这就是&lt;span&gt;&lt;strong&gt;四代的团队建设理念：以系统代替单点，系统内通过互补来达到平衡！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317142140277-1641609068.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;如果你足够细心的话，你会发现，上述Bug类型中有两类是与代码质量息息相关的，就是第一个和最后一个：功能的缺陷和代码改进计划。对于这两类Bug，代码质量起着至关重要的作用。&lt;/p&gt;

&lt;p&gt;于是，对于四代来说，非常大的一部分时间就应该花在代码质量上，而这不仅要求四代本身的代码质量水平要比较高，因为他要判别代码的质量的好坏，而且要求四代拿出一些规范来约束团队的开发流程和测试流程。&lt;/p&gt;

&lt;p&gt;从这两个角度来说，做好一个项目的质量管理，至少需要两个方面的准备：技术上的准备和管理上的准备，对于很多的传统的公司来说，需要两个人来完成，一个是技术经理，一个是项目经理。&lt;/p&gt;

&lt;p&gt;不过在“互联网+”时代，团队小微化。四代觉得，完全可以由“项目经理一个人来主导，团队配合”来达到这个效果。由于要主导这件事，所以，四代一直坚定的认为：软件项目经理必须首先是一个优秀的程序员，否则他不会深刻的认识到代码对软件质量的巨大影响。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201803/109061-20180317142855442-1080944180.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代见识过太多的这样的半吊子项目经理了，本身技术根本不过关，但是机缘巧合走上了管理的路子，虽然他们也知道质量很重要，但是也就仅仅知道而已了。&lt;/p&gt;

&lt;p&gt;他们根本不知道项目的代码可能已经乱的一塌糊涂，他们意识上根本没注意到这个，他们还在满天找些不太靠谱的原因来解释这种现象。稍微好点的项目经理也许还会制定些合作规范来改善外部的条件，殊不知根本原因就藏在项目内部-代码质量，它根本没有被重视！&lt;/p&gt;

&lt;p&gt;历史上无数团队或国家的灭亡都归结于一件事：祸起萧墙，软件也是一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目质量保证二重奏&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;为了保证项目的质量，四代做了两件事：第一件事是制定代码规范和审查机制，这个已经运行，这是从代码上保证，也就是代码质量；另外一件事就是建立团队唯一正式，也是最重要的文档-测试文档，这是从测试和文档上保证，也就是软件质量！&lt;/p&gt;

&lt;p&gt;俗话说的好“冰冻三尺，非一日之寒”！代码质量也不是一步达到的，而是经过多次精心的修改而来的，这个过程就是重构！那么重构到底是在干些什么呢？&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 06:42:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/8589375.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET MVC界面美化及使用Bundle完成静态资源管理 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/8589175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/8589175.html</guid>
<description>&lt;p&gt;　　对于一个应用来说界面的重要性无言而喻，而Web应用的界面是使用Html+Css以及Javascript实现的，ASP.NET MVC是一个用来构建Web应用的框架，它的界面也是Html实现的，对于一些开发团队来说，一般Web项目会存在专业的UI前端工程师和后端工程师，前端工程师可能只懂设计和Html，但是对于如何将设计好的Html应用到ASP.NET可能就需要ASP.NET工程师的帮助。&lt;br/&gt;　　本文将介绍如何将已经设计好的Web界面应用到ASP.NET MVC中以及如何对这些资源文件进行管理，先看一下修改后的效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317123858607-1711843622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317124118313-1408153960.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　本章的主要内容有：&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#resouceSelect&quot;&gt;素材选择&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#viewImplement&quot;&gt;ASP.NET MVC的界面布局及界面实现&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#resouceManagement&quot;&gt;使用BundleConfig进行素材资源管理&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#resouceType&quot;&gt;使用bundle对素材分类&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#resouceOptimization&quot;&gt;使用Bundle对资源文件进行优化&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#resouceVersionSelect&quot;&gt;在Bundle中使用通配符及文件版本(min版)的选择&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#usingCDN&quot;&gt;使用CDN&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#bundleCache&quot;&gt;Bundle中的缓存&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#rewriteUrl&quot;&gt;Bundle重写样式表中资源引用路径&lt;/a&gt;&lt;br/&gt;　　　　○ &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#custemResouce&quot;&gt;自定义资源转变(Transform)&lt;/a&gt;&lt;br/&gt;　　● &lt;a href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html#summary&quot;&gt;小结&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;素材选择&lt;/h2&gt;
&lt;p&gt;　　本文选取开源主题&lt;a href=&quot;https://startbootstrap.com/template-overviews/clean-blog/&quot; target=&quot;_blank&quot;&gt;Start Bootstrap - Clean Blog&lt;/a&gt;为例进行介绍。&lt;br/&gt;　　Clean Blog是一个现代风格的响应式主题，基于bootstrap 4.0，下图为Clean Blog的运行效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317124321262-1560214702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将Clean Blog下载到本地并导入《My Blog》项目中，该主题中包含了相应的样式表、图片、Js、示例页面等文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317124402407-873296523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：Clean Bolg的GitHub地址：&lt;a href=&quot;https://github.com/BlackrockDigital/startbootstrap-clean-blog&quot; target=&quot;_blank&quot;&gt;https://github.com/BlackrockDigital/startbootstrap-clean-blog&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC的界面布局及界面实现&lt;/h2&gt;
&lt;p&gt;　　Clean Blog是由Html、Css、Javascript文件组成的一个静态Web界面，要将其应用到ASP.NET MVC中，只需要对其结构进行分析后一一替换到ASP.NET MVC的View中即可。&lt;br/&gt;所以首先要分析的是Clean Blog以及My Blog应用的页面布局，对于Clean Blog来说它分为三块，分别是导航、内容以及页脚：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317125149647-161179591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同样的My Blog之前使用的ASP.NET MVC默认模板也是分为了导航、内容和页脚：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317125234543-1774157333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于上面的布局来说，导航和页脚部分是不变的，只有中间的内容是变化的，在ASP.NET MVC中提供了布局页的机制，专门用来定义页面布局，将不变的内容放置在该布局页面上，所以要更换界面首先需要的就是定义布局页面：&lt;br/&gt;　　在Views/Shared目录下添加一个新的布局页面，将Clean Blog的Index页面中的导航以及页脚代码复制到新的布局页面中，包括css以及js的引用（注：需要修改路径），页面内容部分使用@RenderBody()方法代替：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317130130977-1247903070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时将_ViewStart.cshtml中指定的布局文件改为新创建的CleanBlog布局文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317130206042-421551699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后参照Clean Blog内容页样式完成相应内容页面修改即可，下面以“联系我们”页面为例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317130231160-571348891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行效果(注：没有实现原主题中的信息提交功能)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317130549626-766262304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;使用BundleConfig进行素材资源管理&lt;/h2&gt;
&lt;p&gt;　　通过上面的介绍知道了如何通过布局页面来搭建页面内容，Web页面除了本身的Html代码外还少不了css、JavaScript等文件的支持，但这些文件都是相对零散的，在ASP.NET中有一个Bundle机制专门用于管理这些资源文件。&lt;br/&gt;　　Bundle有捆和包的意思，而在ASP.NET MVC中它实际就是可以将一组css或JavaScript捆绑起来，捆绑可以根据资源的一些特性进行归类，与此同时还添加了一些有用的附加功能，如：文件最小化、资源文件的版本管理、使用CDN加速、资源文件的缓存等等，下面就介绍如何使用bundle来管理新添加到项目中的素材资源。&lt;/p&gt;
&lt;h3&gt;使用bundle对素材分类&lt;/h3&gt;
&lt;p&gt;　　为了保证页面样式一致，所以在创建布局文件时添加了全站共用的样式和脚本，Clean Blog是基于Bootstrap4.0建立的，除此之外还有一些特殊的内容，如下图所示，它的实例代码中已经进行过分类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317130959801-899839134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　样式主要包括Bootstrap的核心样式、模板中使用的字体以及模板中的自定义样式，同样JavaScript除了bootstrap必要的JavaScript外还有自定义的JavaScript。根据这个分类规则，在App_Start/BundleConfig的BundleConfig类型中注册分类：&lt;/p&gt;
&lt;p&gt;　　样式分类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317131228610-789961936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脚本分类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317131256144-777416053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：建议bundle的地址以bundles作为前缀，避免与路由冲突。&lt;/span&gt;&lt;br/&gt;　　完成后在布局文件中改用Bundle渲染样式和脚本：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132110538-278365781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用Bundle对资源文件进行优化&lt;/h3&gt;
&lt;p&gt;　　前面通过Bundle对资源进行了分类，当同一类资源下存在多个文件时，页面只需要一句代码就可以全部引入使代码更清晰，当然Bundle机制在资源分类的同时，更重要的是可以对资源文件进行优。&lt;br/&gt;　　这里的优化有两个点分别是文件&lt;strong&gt;请求的优化&lt;/strong&gt;和文件&lt;strong&gt;大小的优化&lt;/strong&gt;，前者是将同一类的文件进行合并，合并成一个文件，在请求时只需请求一次即可，后者是将css及JavaScript中不需要的字符删除、变量名称简写以达到缩减文件尺寸的目的。&lt;br/&gt;　　使用Bundle管理资源时，在Release模式下将自动进行优化，另外也可以设置BundleTable.EnableOptimizations为true进行强制优化，如下图所示：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132250339-127771848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行时将可以看到如下结果：&lt;br/&gt;　　1. 请求数量减少：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132455477-1400185713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.非最小化的js文件被最小化，如clean-blog.js：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132522222-721556172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：上面请求中出现字体文件无法找到的错误将在后续内容解释。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;在Bundle中使用通配符及文件版本(min版)的选择&lt;/h3&gt;
&lt;p&gt;　　对于一些样式或脚本组件来说，它本身就可能由多个文件构成，如下图中的Jquery目录中就有jquery.js以及jquery.slim.js两个文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132607933-424755195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在一些复杂的应用中还可能会使用到jQuery的其它组件，这样资源文件会更多，为了简化Bundle对资源的归类，在使用Bundle注册分类时，可以使用通配符来一次匹配多个文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132634044-1985483429.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：Bundle中能识别的通配符有两种，常用的就是“*”，另外还可以通过“{version}”来匹配文件版本。更多通配符相关内容可参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification#using-the--wildcard-character-to-select-files&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification#using-the--wildcard-character-to-select-files&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;　　直接使用*通配符可以匹配相应目录下的所有文件，下图是运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132717265-229723596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从图中可以看到，比之前的请求中多了一些js文件，这些文件就是通过通配符匹配到的，但要注意的是这里&lt;span&gt;&lt;strong&gt;没有获取包含.min版本的js文件&lt;/strong&gt;&lt;/span&gt;，在相同目录下clean-blog.js以及jquery.js都有被最小化的min版本：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317132818577-1731117062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Bundle机制会根据debug/release模式或者BundleTable.EnableOptimizations属性来判断是否对资源文件优化，&lt;span&gt;在release模式(web.config中compilation的debug属性为true)下或者BundleTable.EnableOptimizations设为true时会启用资源优化&lt;/span&gt;，这里的资源优化除了上面提到的多个文件捆绑外，如果文件列表中有min版本文件，那么就会优先选择min版本文件。&lt;br/&gt;　　由于优化模式下无法看到具体请求的文件名称，所以在clean-blog.min.js中添加一条日志输出代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135217260-1243241084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后使用release模式运行程序，将会获得下面结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135239618-541013432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　除了看到请求减少以外，还看到日志中输出了min版本文件中添加的内容，证明使用release模式运行时Bundle会自动选择文件最小化的版本。&lt;/p&gt;
&lt;h3&gt;使用CDN&lt;/h3&gt;
&lt;p&gt;　　CDN(内容分发网络)，为了提高web的响应速度，其中一项主要的优化手段就是将静态资源放到CDN上，这样用户就可以在离他最近的网络节点获取到这些资源，这样既提高了资源获取的速度同时也降低了应用服务器的压力，ASP.NET中的Bundle可以为相应的资源配置CDN，并且该配置也是release模式下生效：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135344273-1113400056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用CDN主要有以下几个步骤：&lt;br/&gt;　　● 将bundles的UseCdn属性设为true。&lt;br/&gt;　　● 创建Bundle对象时构造方法中传入CDN的路径。&lt;br/&gt;　　● 设置Bundle对象的CdnFallbackExpression属性，该属性用于判断通过CDN加载的内容是否正确加载，如果没有那么会加载Include中的内容。&lt;/p&gt;
&lt;p&gt;　　运行效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135519712-1653329727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将bundles.CdnFallbackExpression的属性设置为window.jQuery会生成一个判断window.jQuery对象是否存在，如果不存在则获取服务器资源的代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135548404-228654320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过修改CDN资源路径，模拟CDN无法访问情况，它会自动加载可用的资源：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135629507-1074149318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CDN可用资源参考：&lt;a href=&quot;http://www.bootcdn.cn/&quot; target=&quot;_blank&quot;&gt;http://www.bootcdn.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Bundle中的缓存&lt;/h3&gt;
&lt;p&gt;　　在Release或资源优化模式下，Bundle为其管理的资源提供了缓存机制，在第一次访问Bundle管理的资源时，Bundle会为每一组资源生成一个唯一标识，然后将该资源默认缓存一年：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135857142-692730982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当资源发生改变时唯一标识会发生变化，那么原来缓存的内容就自动失效了。&lt;/p&gt;
&lt;h3&gt;Bundle重写样式表中资源引用路径&lt;/h3&gt;
&lt;p&gt;　　在前面的介绍的过程中release模式下一直有一个错误，就是无法找到字体文件，这是因为在编写样式时会引入一些字体或者图片等外部资源，而这些资源一般是用相对路径进行引用的，但是当ASP.NET中使用Bundle来对样式资源进行捆绑时，该资源的url地址就发生改变了，导致使用该地址组合的引用资源的地址不正确，从而导致了资源无法加载：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317135942527-436960759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了解决这一问题，Bundle提供了一个重写样式引用相对路径的解决方案，在将样式表注册到Bundle中时，可以为相应的样式文件添加一个CssRewriteUrlTransform对象，它用于Css文件优化时对其引用的Url进行重写：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140005732-581997681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加以上代码后，运行程序将解决字体无法找到的问题：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140034097-1081397976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;自定义资源转变(Transform)&lt;/h3&gt;
&lt;p&gt;　　资源转变是Bundle机制在优化资源时提供的一个可拓展接口，如上面介绍的css Url重写就是资源转变的拓展，Bundle中实现资源转变需要实现以下接口：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140109783-208594713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接口中的参数分别代表获取到文件的虚拟路径和文件的内容。&lt;br/&gt;　　下面创建一个在css中插入自定义内容的资源转换器，来介绍如何实现资源转变的自定义拓展：&lt;br/&gt;　　实现IItemTransform接口，在样式文件中追加&quot;.test {color: red;}&quot;样式：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140155571-662148553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将该转换器通过Include方法应用到对应文件上：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140248519-1262862545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行结果显示相应内容已经被添加到最终的样式文件中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140336577-752261337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：IItemTransform接口是在资源优化前调用的，所以本例添加内容包含的空格和分号最终都被优化删除了，所以在使用IItemTransform进行拓展时需要注意资源优化问题。&lt;/span&gt;&lt;br/&gt;　　另外在Bundle中还有另外一个拓展接口IBundleTransform，它定义了一个用于转换Bundle相应文件的方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140422496-1355015294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实现Process接口，在响应的内容上添加注释“hello selim”：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140458094-788324677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　BundleTransform需要在Bundle的Transforms属性上添加：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140635039-1883763387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201803/640251-20180317140649839-240039433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相对与ItemTransform来说BundleTransform处理后的内容不会再进行优化，在文档&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification#less-coffeescript-scss-sass-bundling&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification#less-coffeescript-scss-sass-bundling&lt;/a&gt;中还通过BundleTransform实现了less等文件动态编译的功能，有兴趣可参考该文档。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本章主要介绍了如何将现有的Web样式应用到ASP.NET MVC中，并着重介绍了ASP.NET MVC中对静态资源管理的Bundle机制。Bundle机制除了可以对资源文件进行归类外还提供了资源文件优化、CDN、缓存等高级功能。合理的利用Bundle可以让项目代码更清晰，同时也可以提高应用的性能。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;　　&lt;a href=&quot;https://github.com/BlackrockDigital/startbootstrap-clean-blog&quot; target=&quot;_blank&quot;&gt;https://github.com/BlackrockDigital/startbootstrap-clean-blog&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://html.com/attributes/&quot; target=&quot;_blank&quot;&gt;https://html.com/attributes/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/mvc/overview/performance/bundling-and-minification&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/articles/842961/introducing-dynamic-bundles-for-asp-net-mvc&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/articles/842961/introducing-dynamic-bundles-for-asp-net-mvc&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/11355935/mvc4-stylebundle-not-resolving-images#&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11355935/mvc4-stylebundle-not-resolving-images#&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://www.bootcdn.cn/&quot; target=&quot;_blank&quot;&gt;http://www.bootcdn.cn/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://www.tutorialsteacher.com/mvc/scriptbundle-mvc&quot; target=&quot;_blank&quot;&gt;http://www.tutorialsteacher.com/mvc/scriptbundle-mvc&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/728146/ASP-NET-MVC-bundles-internals&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/728146/ASP-NET-MVC-bundles-internals&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://blogs.msdn.microsoft.com/rickandy/2011/05/21/using-cdns-and-expires-to-improve-web-site-performance/&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/rickandy/2011/05/21/using-cdns-and-expires-to-improve-web-site-performance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET MVC界面美化及使用Bundle完成静态资源管理&quot; href=&quot;http://www.cnblogs.com/selimsong/p/8589175.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/8589175.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 06:34:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/8589175.html</dc:identifier>
</item>
<item>
<title>与JavaWeb有关的故事（web请求与Java I／O） - 少年天团</title>
<link>http://www.cnblogs.com/1024Community/p/8589403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1024Community/p/8589403.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作为一名后端屌丝程序员，对算法、并发、性能乐此不疲。但是，随着年龄和阅历的增加，显然叶落而不知秋的心态是不太能混了。尤其是，某T面试官在明知我是后端，且明确表示对HTTP协议不太熟的情况下，强行让我解释HTTP状态码200至600的含义。这，便是本篇的初衷，讲一讲后端眼里的前端故事。内容基于《深入分析JavaWeb技术内幕》，加入了自己的理解，思维会比较跳跃，需要后端基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;0&quot;&gt;&lt;span&gt;web请求过程&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;作为一名从CS架构转入BS架构的后端，不得不说，BS是趋势也是方向，两个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端使用统一的浏览器，使用配置简单&lt;/li&gt;
&lt;li&gt;服务端基于统一的HTTP，简化开发模式，并且开源服务器众多，开发成本低&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;1&quot;&gt;&lt;span&gt;B/S网络架构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;CS架构通常是长链接交互数据，而BS架构是通过基于HTTP协议的无状态的短链接通讯。当在浏览器输入&lt;code&gt;http://www.cnblogs.com/1024Community/&lt;/code&gt;时，会发生一系列动作，最终将需要的信息返回到浏览器。其中涉及很多概念，如DNS解析、CDN、负载均衡等（后续会详解），但是基本架构还是差不多，基本流程是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浏览器输入URL---DNS解析成对应IP---负载均衡服务器---CDN---服务端系统---分布式缓存---文件系统/DB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包含CDN的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111501643-1488003983.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2&quot;&gt;&lt;span&gt;发起一个HTTP请求&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;概括为，通过URL解析到服务器IP，建立socket链接，发送符合HTTP规范的输入流，等待服务器返回数据，然后断开链接。linux中curl+URL命令，可以简单发起一个HTTP请求。&lt;/p&gt;
&lt;h4 id=&quot;3&quot;&gt;&lt;span&gt;HTTP解析&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;HTTP是BS网络架构的核心，程序员&lt;em&gt;杀人放火&lt;/em&gt;之必备。&lt;br/&gt;首先，要了解的是HTTP header部分，它控制着数据传输、浏览器渲染、服务器执行逻辑。&lt;br/&gt;常见HTTP请求头：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111434980-1806341129.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常见响应头：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111426083-1184258996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常见错误码：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111407909-1744181084.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HTTP请求头，charset、encoding、language、host、User-Agent、Connection&lt;br/&gt;HTTP响应头，Server、type、encoding、language、length、Keep-Alive&lt;br/&gt;HTTP常见状态码，200成功，302临时跳转，400请求语法错误，403服务器收到请求，拒绝服务，404请求资源不存在，500服务端异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;4&quot;&gt;&lt;span&gt;浏览器缓存机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;复杂而又重要，常用ctrl+F5组合键刷新界面，来获得最新数据。其原理是，在header中添加了两项，Pragma:no-cache和Cache-Control:no-cache。对于缓存相关的header参数，主要如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Pragma／Cache-Control&lt;br/&gt;缓存控制，Cache-Control优先级较高，和其他请求字段同时存在时（如Expires），会覆盖其他字段。Pragma类似，常用就是Pragma:no-cache,可选值如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111355058-1532922708.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Expires&lt;br/&gt;指定一个日期，超过这个日期，缓存超时，重新请求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Last-Modified／Etag&lt;br/&gt;服务端响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间。当浏览器再次请求时，在header中添加&lt;code&gt;If-Modified-Since&lt;/code&gt;字段，来询问页面是否最新，最新则返回304，服务器也不会传送数据。&lt;br/&gt;Etag类似功能，为每一个页面分配一个唯一编号，后端比较难处理，需要记住网站所有资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;5&quot;&gt;&lt;span&gt;DNS域名解析&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;将域名解析成地址，非常重要。整个HTTP通信都是基于TCP／IP协议簇的，没有IP地址就没法通信，但是IP地址是一串数字，难记，所以有了IP和域名的对应关系。有了对应关系，就要有解析，知道域名通过对应关系，就能得到IP，从而建立起通信。&lt;/p&gt;
&lt;h4 id=&quot;6&quot;&gt;&lt;span&gt;DNS域名解析过程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;看书说话，我们来捋一捋，当你在浏览器输入一串URL时，怎么找到的对应服务器IP&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314111257087-1744734247.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器检查本地缓存，缓存有实效，通过TTL（DNS记录在DNS服务器上缓存时间）设置&lt;/li&gt;
&lt;li&gt;检查操作系统缓存，linux下在/etc/hosts&lt;/li&gt;
&lt;li&gt;本地区域名服务器，LDNS&lt;/li&gt;
&lt;li&gt;Root Server域名服务器&lt;/li&gt;
&lt;li&gt;根域名服务器返回给本地域名服务器一个所查询域的主域名服务器gTLD Server地址（全球13台左右）&lt;/li&gt;
&lt;li&gt;LDNS在向上一步gTLD发送请求&lt;/li&gt;
&lt;li&gt;接收请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器地址（通常是注册的域名（提供商）服务器）&lt;/li&gt;
&lt;li&gt;Name Server查询存储的域名和IP映射关系，连同一个TTL值返回给DNS Server&lt;/li&gt;
&lt;li&gt;返回该域名对应的IP和TTL值，LDS会缓存这个对应关系&lt;/li&gt;
&lt;li&gt;把解析结果返回给用户，用户根据TTL值缓存在本地&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Tips：&lt;br/&gt;&lt;code&gt;win下使用nslookup，linux使用dig查询解析过程。 两个缓存地方LDS和本地机器，可用命令刷新，JVM也会缓存DNS结果，使用InetAddress时，注意使用单例模式，避免性能问题。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;7&quot;&gt;&lt;span&gt;CDN工作机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Content Delivery Network（内容分布网络）类似镜像+缓存+整体LB，通常缓存静态资源，用户主站取动态数据，CDN下载静态数据。目标：可扩展，安全性，可靠性。&lt;/p&gt;
&lt;h4 id=&quot;8&quot;&gt;&lt;span&gt;CDN架构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314152020487-2124083464.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看图说话，通过域名解析，通常会CNAME到CDN全局中的DNS负载均衡服务器，在通过这个GTM（广域网流量管理）分配到离用户最近的CDN节点。用户就可以到这个节点访问静态文件了。&lt;/p&gt;
&lt;h4 id=&quot;9&quot;&gt;&lt;span&gt;负载均衡&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;负载均衡，分为链路LB（DNS解析成不同IP）、集群LB（分为硬件和软件，硬件贵，性能好，但不能动态扩容，如F5；软件LB，如LVS）、操作系统LB（软中断和硬件中断，如多队列网卡）。&lt;/p&gt;
&lt;h4 id=&quot;10&quot;&gt;&lt;span&gt;CDN动态加速&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;总结为，通过CDN的DNS解析中通过动态的链路探测寻找回源最佳路径，然后通过DNS调度将所有请求调度到选定的路径上回源，加速用户访问效率&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180314152038427-667693959.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;11&quot;&gt;&lt;span&gt;Java I／O的工作机制&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;12&quot;&gt;&lt;span&gt;Java I／O类库的基本架构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;IO问题是人机交互的核心问题，是获取和交换信息的渠道，向来是应用系统的瓶颈，Java也在持续优化，如1.4版本引入了NIO。整个java.io包几十个类，有些概念不再详细介绍了（如字节流、字符流、io包继承结构），总体上看IO大体分为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于字节操作的io接口：InputStream和OutputStream&lt;/li&gt;
&lt;li&gt;基于字符操作的io接口：Writer和Reader&lt;/li&gt;
&lt;li&gt;基于磁盘操作的io接口：File&lt;/li&gt;
&lt;li&gt;基于网络操作的io接口：Socket（也算是IO）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;13&quot;&gt;&lt;span&gt;字节和字符的转化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;首先，数据持久化或网络传输都是以字节进行的，这就涉及一个字符和字节转化的问题，其中最重要的就是字符集编码问题，否则很容易出现常见的乱码问题，字符解码类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180317132316031-1851056647.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中InputStreamReader类是从字节到字符转化桥梁，过程中要指定字符集，否则使用操作系统默认。&lt;br/&gt;补充个UML知识，上图中使用的是组合，是整体与部分的关系，代码实现就是成员变量，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180317133242541-1174515903.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/firstcsharp/p/5327659.html&quot;&gt;UML参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;读的时候，字节流转化为字符，要解码（StreamDecoder），同样道理，写入是从字符到字节，需要编码（StreamEncoder）&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;14&quot;&gt;&lt;span&gt;磁盘IO工作机制&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;15&quot;&gt;&lt;span&gt;几种访问文件方式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;访问文件，读取和写入是调用操作系统的IO接口，因为磁盘是由操作系统管理。而只要是系统调用就会存在内核空间和用户空间切换问题，这本身是操作系统保护本身运行安全的机制，这就会出现一个问题，&lt;code&gt;内核空间和用户空间的数据复制&lt;/code&gt;，由于内核空间访问快，用户空间访问慢，所以，出现了缓存。这是基本原理，几种访问文件方式如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标准访问文件方式（实际上读写都是和内核空间缓存打交道，什么时候刷新到磁盘由操作系统决定）&lt;/li&gt;
&lt;li&gt;直接IO方式（内核不缓存，直接和磁盘IO打交道，慢，通常结合异步IO提升性能）&lt;/li&gt;
&lt;li&gt;同步访问文件（和标准访问类似，但是等缓存数据刷新到磁盘，才返回给应用）&lt;/li&gt;
&lt;li&gt;异步访问方式（访问发出后，不阻塞，异步返回）&lt;/li&gt;
&lt;li&gt;内存映射方式（把内核空间和磁盘文件关联，共享数据，减少&lt;code&gt;数据复制&lt;/code&gt;操作）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;16&quot;&gt;&lt;span&gt;Java访问磁盘文件&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;File对象是个虚拟的描述，解码类StreamDecoder、真正的文件描述类FileDescriptor，一图胜万言，如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180317132336058-2094902982.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;17&quot;&gt;&lt;span&gt;Java序列化技术&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;序列化就是将一个对象转为为一串二进制的字节数组，通过保存或转移这些字节数据来达到持久化的目的。接口，java.io.Serializable。&lt;br/&gt;对象序列化之后，查看二进制数组，会包含序列化协议、版本、是否新对象、class完整类名、UID、标记、所含域的个数、域类型、域名城、父类信息、类各属性的实际值。&lt;br/&gt;几个Java序列化要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;父类继承Serializable接口时，所有子类可序列化&lt;/li&gt;
&lt;li&gt;子类实现Serializable接口时，父类没有，则只有字类的属性可序列化（不报错）&lt;/li&gt;
&lt;li&gt;如果序列化的属性是对象，则这个对象也必须实现Serializable接口，否则报错&lt;/li&gt;
&lt;li&gt;反序列化时，如果对象属性有修改或删减，修改的属性部分会丢失，不报错&lt;/li&gt;
&lt;li&gt;反序列化时，UID被修改，会失败&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;纯Java环境，序列化可以很好的工作。多语言环境见还是推荐使用通用的数据结构如XML、JSON。&lt;/p&gt;
&lt;h4 id=&quot;18&quot;&gt;&lt;span&gt;网络IO机制&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;19&quot;&gt;&lt;span&gt;TCP三次握手和四次挥手&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;TCP建立过程，三次握手和四次挥手，过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180317132345108-1360302733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575312/201803/575312-20180317132349394-483698860.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个问题：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么A还要发送一次确认呢？可以二次握手吗？&lt;br/&gt;&lt;code&gt;为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为什么连接的时候是三次握手，关闭的时候却是四次握手？&lt;br/&gt;&lt;code&gt;因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Andya/p/7272462.html&quot;&gt;TCP三次握手和四次挥手过程&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;20&quot;&gt;&lt;span&gt;Java Socket工作机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;底层TCP／IP协议，Socket和ServerSocket（accept之前是阻塞的）建立连接，通过字节流传输，传输过程中，操作系统会为InputStream和OutputStream分配一定大小缓冲区，数据读写通过缓冲区完成。&lt;/p&gt;
&lt;h4 id=&quot;21&quot;&gt;&lt;span&gt;NIO概述&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;BIO方式，不管是网络还是磁盘，一旦有阻塞，线程都会失去CPU使用权。当需要大量HTTP长链接的情况，或者提升个别IO请求优先级，或者竞态资源同步，BIO处理起来会非常复杂，此时，NIO闪亮登场。显然，这个话题需要一个崭新的大篇幅来介绍，此处省略一万字=。=&lt;/p&gt;
&lt;h4 id=&quot;22&quot;&gt;&lt;span&gt;IO调优&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;磁盘IO优化&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  -  增加缓存，减少磁盘访问次数
  -  优化磁盘管理系统，设计最优的磁盘寻址策略（太底层）
  -  设计合理的磁盘存储数据块
  -  应用合理的RAID策略提升磁盘IO&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;TCP网络参数调优&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; -  32位系统通常只有65535个端口，0～1024受保护，查看可用端口数量，较少时可以通过更改tcp_fin_timeout位更小的值来快速释放。常用信息：
    cat ／proc／net／netstat ：查看TCP统计信息
    cat ／proc／net／snmp ：查看当前系统连接情况
    netstat -s ：查看网络统计信息 &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;网络IO优化&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  - 减少网络交互次数
  - 减少网络传输数据量大小
  - 减少编码（重要，网络流是字节形式，字符转字节比较耗时，尽量以字节形式传输或提前转码） 
  - 同步和异步的选择（同步就是一个任务的完成需要依赖另外一个任务的完成）
  - 阻塞与非阻塞的选择（阻塞就是CPU停下来等待一个慢的操作完成才接着完成其他的工作）
  - 同步、异步、阻塞、非阻塞混搭组合（根据场景来选择）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23&quot;&gt;&lt;span&gt;IO涉及的设计模式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;以下高能，需要功底：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;适配器模式，关键点：Adapter完成源到目标的适配，一般是继承源或持有源（构造器注入、方法注入等），实现目标接口。&lt;br/&gt;装饰器模式，关键点：在不改变源的接口的情况下，进行功能扩展。io包InputStream各种装饰器（FilterInputStream、BufferedInputStream等）通过持有源（构造器注入）来完成功能扩展。&lt;/p&gt;
&lt;p&gt;两者都对类进行了包装，两者的本质区别在于&lt;code&gt;是否改变了源的接口&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上来自天团运营总监：&lt;a href=&quot;http://www.cnblogs.com/lknny/&quot;&gt;坤少&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 05:53:00 +0000</pubDate>
<dc:creator>少年天团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1024Community/p/8589403.html</dc:identifier>
</item>
<item>
<title>JavaScript之优化DOM - _wind</title>
<link>http://www.cnblogs.com/wind-lanyan/p/8588544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-lanyan/p/8588544.html</guid>
<description>&lt;p&gt;&lt;span&gt;优化DOM得从重绘和重排讲起，long long ago...&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、重绘和重排&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.1 重绘和重排是什么&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;重绘是指一些样式的修改，元素的位置和大小都没有改变；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重排是指元素的位置或尺寸发生了变化，浏览器需要重新计算渲染树，而新的渲染树建立后，浏览器会重新绘制受影响的元素。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.2 浏览器渲染页面&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;去参加面试总会被问到一个问题，那就是“向浏览器输入一行url会发生什么？”，这个问题的答案除了要回答网络方面的知识还牵扯到浏览器渲染页面问题。当我们的浏览器接收到从服务器响应的页面之后便开始逐行渲染，遇到css的时候会异步的去计算属性值，再继续向下解析dom解析完毕之后形成一颗DOM树，将异步&lt;/span&gt;&lt;span&gt;计算好的样式（样式盒子）与DOM树相结合便成为了一个Render树，再由浏览器绘制在页面上。&lt;/span&gt;&lt;span&gt;DOM树与Render树的区别在于：样式为display:none;的节点会在DOM树中而不在渲染树中。&lt;/span&gt;&lt;span&gt;浏览器绘制了之后便开始解析js文件，根据js来确定是否重绘和重排。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.3 引起重绘和重排的原因&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;产生重绘的因素：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;改变visibility、outline、背景色等样式属性，并没有改变元素大小、位置等。浏览器会根据元素的新属性重新绘制。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;产生重排的因素：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;内容改变&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;文本改变或图片尺寸改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DOM元素的几何属性的变化&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;例如改变DOM元素的宽高值时，原渲染树中的相关节点会失效，浏览器会根据变化后的DOM重新排建渲染树中的相关节点。如果父节点的几何属性变化时，还会使其子节点及后续兄弟节点重新计算位置等，造成一系列的重排。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DOM树的结构变化&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;添加DOM节点、修改DOM节点位置及删除某个节点都是对DOM树的更改，会造成页面的重排。浏览器布局是从上到下的过程，修改当前元素不会对其前边已经遍历过的元素造成影响，但是如果在所有的节点前添加一个新的元素，则后续的所有元素都要进行重排。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取某些属性&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;除了渲染树的直接变化，当获取一些属性值时，浏览器为取得正确的值也会发生重排，这些属性包括：&lt;code&gt;offsetTop&lt;/code&gt;、&lt;code&gt;offsetLeft&lt;/code&gt;、 &lt;code&gt;offsetWidth&lt;/code&gt;、&lt;code&gt;offsetHeight&lt;/code&gt;、&lt;code&gt;scrollTop&lt;/code&gt;、&lt;code&gt;scrollLeft&lt;/code&gt;、&lt;code&gt;scrollWidth&lt;/code&gt;、&lt;code&gt;scrollHeight&lt;/code&gt;、 &lt;code&gt;clientTop&lt;/code&gt;、&lt;code&gt;clientLeft&lt;/code&gt;、&lt;code&gt;clientWidth&lt;/code&gt;、&lt;code&gt;clientHeight&lt;/code&gt;、&lt;code&gt;getComputedStyle()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;浏览器窗口尺寸改变&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;窗口尺寸的改变会影响整个网页内元素的尺寸的改变，即DOM元素的集合属性变化，因此会造成重排。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;滚动条的出现（会触发整个页面的重排）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之你要知道，js是单线程的，重绘和重排会阻塞用户的操作以及影响网页的性能，当一个页面发生了多次重绘和重排比如写一个定时器每500ms改变页面元素的宽高，那么这个页面可能会变得越来越卡顿，我们要尽可能的减少重绘和重排。那么我们对于DOM的优化也是基于这个开始。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;2、优化  &lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.1 减少访问&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;减少访问次数自然是想到缓存元素，但是要注意&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ele = document.getElementById('ele');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样并不是对ele进行缓存，每一次调用ele还是相当于访问了一次id为ele的节点。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2.1.1 缓存NodeList&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; foods = document.getElementsByClassName('food');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以用foods[i]来访问第i个class为food的元素，不过这里的foods并不是一个数组，而是一个NodeList。NodeList是一个类数组，保存了一些有序的节点并可以通过位置来访问这些节点。NodeList对象是动态的，每一次访问都会运行一次基于文档的查询。所以我们要尽量减少访问NodeList的次数，可以考虑将NodeList的值缓存起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优化前&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis = document.getElementsByTagName('li'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something...  &lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优化后，将length的值缓存起来就不会每次都去查询length的值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis = document.getElementsByTagName('li'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0, len = lis.length; i &amp;lt; len; i++&lt;span&gt;) {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something...  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且由于NodeList是动态变化的，所以如果不缓存可能会引起死循环，比如一边添加元素，一边获取NodeList的length。&lt;/p&gt;
&lt;h4&gt;2.1.2 改变选择器&lt;/h4&gt;
&lt;p&gt;获取元素最常见的有两种方法，getElementsByXXX()和queryselectorAll()，这两种选择器区别是很大的，前者是获取动态集合，后者是获取静态集合，举个例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设一开始有2个li&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis = document.getElementsByTagName('li');  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态集合&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ul = document.getElementsByTagName('ul')[0&lt;span&gt;];
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    console.log(lis.length);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newLi = document.createElement('li'&lt;span&gt;); 
    ul.appendChild(newLi);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出结果：2， 3， 4&lt;/span&gt;


&lt;span&gt;var&lt;/span&gt; lis = document.querySelector('li');  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态集合 &lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ul = document.getElementsByTagName('ul')[0&lt;span&gt;];
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
    console.log(lis.length);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newLi = document.createElement('li'&lt;span&gt;); 
    ul.appendChild(newLi);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出结果：2， 2， 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对静态集合的操作不会引起对文档的重新查询，相比于动态集合更加优化。&lt;/p&gt;
&lt;h4&gt;2.1.3 避免不必要的循环&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
// 优化前
for(var i = 0; i &amp;lt; 10; i++&lt;span&gt;) {&lt;br/&gt;document.getElementById('ele').innerHTML += 'a'&lt;span&gt;; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span readability=&quot;3&quot;&gt;} &lt;p&gt;// 优化后 &lt;br/&gt;var str = ''&lt;span&gt;; &lt;br/&gt;for(var i = 0; i &amp;lt; 10; i++&lt;span&gt;) {&lt;br/&gt;str += 'a'&lt;span&gt;; &lt;br/&gt;}&lt;br/&gt;document.getElementById('ele').innerHTML = str;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优化前的代码访问了10次ele元素，而优化后的代码只访问了一次，大大的提高了效率。&lt;/p&gt;
&lt;h4&gt;2.1.4 事件委托&lt;/h4&gt;
&lt;p&gt;js中的事件函数都是对象，如果事件函数过多会占用大量内存，而且绑定事件的DOM元素越多会增加访问dom的次数，对页面的交互就绪时间也会有延迟。所以诞生了事件委托，事件委托是利用了事件冒泡，只指定一个事件处理程序就可以管理某一类型的所有事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件委托前&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis = document.getElementsByTagName('li'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
   lis[i].onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.innerHTML);
   };  
}    

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件委托后&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ul = document.getElementsByTagName('ul')[0&lt;span&gt;];
ul.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
   console.log(event.target.innerHTML);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事件委托前我们访问了lis.length次li，而采用事件委托之后我们只访问了一次ul。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2 减少重绘重排&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.2.1 改变一个dom节点的多个样式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们想改变一个div元素的宽度和高度，通常做法可以是这样&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; div = document.getElementById('div1'&lt;span&gt;);
div.style.width = '220px';&lt;br/&gt;div.style.height = '300px';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上操作改变了元素的两个属性，访问了三次dom，触发两次重排与两次重绘。我们说过优化是减少访问次数以及减少重绘重排次数，从这个出发点可不可以只访问一次元素以及重排次数降低到1呢？显然是可以的，我们可以在css里写一个class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; css
.change {
    width: 220px;
    height: 300px;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
document.getElementById(&lt;/span&gt;'div').className = 'change';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就达到了一次操作多个样式&lt;/p&gt;
&lt;h4&gt;2.2.2  批量修改dom节点样式&lt;/h4&gt;
&lt;p&gt;上面代码的情况是针对于一个dom节点的，如果我们要改变一个dom集合的样式呢？&lt;/p&gt;
&lt;p&gt;第一时间想到的方法是遍历集合，给每个节点加一个className。再想想这样岂不是访问了多次dom节点？想想文章开头说的dom树和渲染树的区别，如果一个节点的display属性为none那么这个节点不会存在于render树中，意味着对这个节点的操作也不会影响render树进而不会引起重绘和重排，基于这个思路我们可以实现优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将待修改的集合的父元素display: none;&lt;/li&gt;
&lt;li&gt;之后遍历修改集合节点&lt;/li&gt;
&lt;li&gt;将集合父元素display: block;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设增加的class为.change&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis = document.getElementsByTagName('li'&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ul = document.getElementsByTagName('ul')[0&lt;span&gt;];

ul.style.display &lt;/span&gt;= 'none'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
    lis[i].className &lt;/span&gt;= 'change'&lt;span&gt;;  
}

ul.style.display &lt;/span&gt;= 'block';
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;3、总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;减少访问dom的次数
&lt;ul&gt;&lt;li&gt;缓存节点属性值&lt;/li&gt;
&lt;li&gt;选择器的使用&lt;/li&gt;
&lt;li&gt;避免不必要的循环&lt;/li&gt;
&lt;li&gt;事件委托&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;减少重绘与重排
&lt;ul&gt;&lt;li&gt;使用className改变多个样式&lt;/li&gt;
&lt;li&gt;使父元素脱离文档流再恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果以后看到其他优化方案我会更新，欢迎大家与我交流。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
</description>
<pubDate>Sat, 17 Mar 2018 05:12:00 +0000</pubDate>
<dc:creator>_wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-lanyan/p/8588544.html</dc:identifier>
</item>
<item>
<title>项目角度谈矢量切片运用以及Geoserver处理自定义规格矢量切片方案 - 李晓晖</title>
<link>http://www.cnblogs.com/naaoveGIS/p/8589204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/naaoveGIS/p/8589204.html</guid>
<description>&lt;p&gt;&lt;span&gt;文章版权由作者李晓晖和博客园共有，若转载请于明显处标明出处：&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/&quot;&gt;http://www.cnblogs.com/naaoveGIS/&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;矢量切图方案目前已经是很常见的一个方案，在2016年时团队基于Sharpmap开发了支持不同坐标系、不同切图参数、任意矢量数据（点、线、面）的工具。也着手开发了支持矢量切图浏览器前端配图的工具。在当时研究之前，也写过一篇初步研究的文章：&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/4982549.html&quot;&gt;WebGIS中矢量切图的初步研究&lt;/a&gt;（http://www.cnblogs.com/naaoveGIS/p/4982549.html）。&lt;/p&gt;

&lt;p&gt;但是回过头看这两年的运用场景，着实很少。究其原因大致几个方面：&lt;/p&gt;
&lt;p&gt;a.大数据量情况下，基于要素绘制的矢量切片虽然在前端可以实现更好的交互效果，但是项目中由于矢量数据量级往往达不到，完全可以直接处理为一个文本一次性加载于前端展示。&lt;/p&gt;
&lt;p&gt;b.即使大数据量情况下，基于WMS或者WMTS以图片形式展示要素也是基本方案。对于交互，虽然会多一次后台查询，但是项目产品往往没有互联网产品的极致交互要求。&lt;/p&gt;
&lt;p&gt;c.矢量切图的实施比较耗时，需要对图层要素分别切图、分别设置样式，实施成本太大。而基于arcmap等工具统一配图再一次性切图，实施效率会大大提高。虽然各图层样式我们可以设置默认样式，但是难免遇到各种新增或修改。而且由于工具需要提前分别切好各矢量图层，非常耗时。&lt;/p&gt;
&lt;p&gt;d.矢量切片的更新问题。同样由于我们对数据需要提前切片缓存，导致数据更新后，又得重新切片，没法做到实时。&lt;/p&gt;

&lt;p&gt;在项目的实际运用中，我们最需要解决的是瓦片预处理导致的切图耗时和无法实时更新问题。只有实施问题解决了，才能更好的推动在大数据量情况下使用矢量切片。&lt;/p&gt;
&lt;p&gt;回到2016年，当时已经预研到Geoserver和一些开源工具可以支持矢量切片，但是为什么最后还是选择自己开发工具了呢？&lt;br/&gt;a.当时Geoserver最新的版本是2.8，矢量切片支持的不是很好，面的切片上边界会不重合。&lt;/p&gt;
&lt;p&gt;b.开源工具TileStache，不仅仅是安装不方便，而且只支持了WGS84坐标系（包含墨卡托投影）。&lt;/p&gt;
&lt;p&gt;所以只好让团队专人着手开发了矢量切片工具。&lt;/p&gt;
&lt;p&gt;再回到现在2018年，Geoserver已经出到了2.12版本，矢量切片的面处理问题已经解决。所以目前采用Geoserver方案是更为便捷的方案，它可以很好的解决上面提到的实施问题和更新问题。&lt;/p&gt;
&lt;p&gt;a.可以通过udig等提前配置好图层的样式，形成模板，方便部署配置样式。&lt;/p&gt;
&lt;p&gt;b.Geoserver可以在Geowebcache中配置好对矢量切片格式的支持，并且可以分别设置是否预处理，或者实时切片。这样，减少工程实施时需要预处理的耗时。&lt;/p&gt;
&lt;p&gt;c.数据的更新问题，可以通过设置缓存的时效性进行控制，避免之前重新切图。&lt;/p&gt;

&lt;p&gt;同样，在很早之前的一篇文章中，我对GeoWebCache做了一个预研：&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/4195008.html&quot;&gt;利用GeoWebCache实现WebGIS地形图展示的缓存优化&lt;/a&gt;（&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/p/4195008.html&quot;&gt;http://www.cnblogs.com/naaoveGIS/p/4195008.html&lt;/a&gt;）。这里，我做进一步补充。&lt;/p&gt;
&lt;p&gt;a.下载对应插件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130054274-444889590.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意安装时，tomcat得是8系列。如果本地已经装有jdk1.7，则需要再装一个jdk1.8，然后在tomcat8的bin目录下的setclasspath.bat文件中，直接写定jdk的指向路径：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130112168-8112277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b.官网地址：&lt;a href=&quot;http://geowebcache.org/docs/current/concepts/index.html&quot;&gt;http://geowebcache.org/docs/current/concepts/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;c.GeoWebCache的导航页包含功能：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130121743-102406356.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130135462-1297590051.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击TMS（Tile Map Server），可以查看服务列表：&lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130146822-375611144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d.预览功能&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130239492-545190916.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;e.切图功能&lt;/p&gt;
&lt;p&gt;点击seed this layer。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130431558-157799807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;f.查看正在切图的进程&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130453361-1549073250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5.1增加自定义GridSets&lt;/h2&gt;
&lt;h3&gt;5.1.1创建GridSets&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130503598-1686981229.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认的GridSet中只包含了4326和900913坐标系。点击，create gridsets,我们以2379坐标系来示例。&lt;/p&gt;
&lt;h3&gt;5.1.2各参数配置&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130516936-223931564.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;467&quot;/&gt;&lt;/p&gt;
&lt;p&gt;a.通过查找选定坐标系。&lt;/p&gt;
&lt;p&gt;b.填写瓦片大小。&lt;/p&gt;
&lt;p&gt;c.切图比例尺。这里提供两种填写方式，以分辨率填写，或以比例尺填写。&lt;/p&gt;
&lt;h3&gt;5.1.3切图范围配置&lt;/h3&gt;
&lt;p&gt;这个配置十分重要，在我们切图中，有原点这个概念，而gridsets中我们没有发现与切图原点有关的配置项。而其实，这个切图范围，我们便可以将其视作原点配置。&lt;/p&gt;
&lt;p&gt;假设此时原点为：-5123200，10002100。&lt;/p&gt;
&lt;p&gt;我们便将切图范围设置为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130530963-82162960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.1.4Geoserver中产生的配置文件&lt;/h3&gt;
&lt;p&gt;在Geoserver的GWC文件夹中，我们可以看见保存gridsets后生成的对应配置文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130538293-878145882.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;518&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.2图层关联上gridsets&lt;/h2&gt;
&lt;p&gt;最后，我们点击图层栏，选择tilecaching&lt;/p&gt;
&lt;h3&gt;5.2.1选择切图格式&lt;/h3&gt;
&lt;p&gt;当安装了矢量切图插件后，在切图格式上便可以选择矢量切片相关格式。目前插件提供的矢量切片有三种格式：geojson、topojson、pbf。Geojson可读性高，topojson比前者小一些，但是不可读。而pbf格式压缩性更好，同样也不可读。Pbf在插件中为type=mapbox-vector，格式为x-protobuf。意思是，其数据组织采用的mapbox提供的mvt格式，该格式对地图不同级别下的要素会采用道格拉斯-普克算法进行抽稀，然后再以谷歌提供的pbf格式进行存储。所以，pbf压缩性更好，但是同样是不可读的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130551148-248368990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.2.2添加切图参数&lt;/h3&gt;
&lt;p&gt;把我们设置好的gridsets加入，并选定好需要切图的级别。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130602161-678615100.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.2.3其他参数&lt;/h3&gt;
&lt;h4&gt;5.2.3.1Metatiling factors&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130612024-518860519.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们向GWC发布的范围请求，会被以该设置切割成多个小瓦片。这个方案可以提高瓦片的命中率，但是也会导致瓦片过多等问题。&lt;/p&gt;
&lt;h4&gt;5.2.3.2缓存时效&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130726004-882038348.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.2.3.3瓦片间隙&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130734213-1392154186.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.1代码编写&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130757337-2022411468.png&quot; alt=&quot;&quot; width=&quot;925&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，TILEMATRIXSET对应我们设置的GRIDSETS名称，而TILEMATRIX对应各个级别时的切片级别名称。&lt;/p&gt;
&lt;h2&gt;6.2效果展示&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130812269-1693714098.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;432&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然目前已经展示出矢量切片，但是其切片又明显位移：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130823723-1558036536.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们是基于已有的4326或者900913坐标系，则不会有这个问题。但是基于自定义坐标系和切图参数时便发生了偏移。&lt;/p&gt;
&lt;p&gt;如果只谈解决思路：因为是线性偏移，我们可以代码中对不同级别设置不同的切图原点。但是这是非常不科学的。&lt;/p&gt;
&lt;p&gt;个人推测，这可能与DPI有关系，及每英寸的像素数有关系。我们的地图是ArcGIS发布，其切图参数使用的DPI是96，换算出来的屏幕一像素所代表的实际地理位置为：&lt;/p&gt;
&lt;p&gt;1英寸=2.54厘米&lt;/p&gt;
&lt;p&gt;1英寸=96像素&lt;/p&gt;
&lt;p&gt;那么屏幕的一像素具有（2.54/96=2.6458E-4）厘米/像素。&lt;/p&gt;
&lt;p&gt;但是，我们Geoserver中默认的是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130832983-728810649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将该配置修改后，重启Geoserver，偏移问题依然存在。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;不知道各位读者遇到过该问题否，是否有其他解决思路。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　-----欢迎转载，但保留版权，请于明显处标明出处：&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/&quot;&gt;http://www.cnblogs.com/naaoveGIS/&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                                                                        　　   如果您觉得本文确实帮助了您，可以微信扫一扫，进行小额的打赏和鼓励，谢谢 ^_^&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180317130940034-784126071.png&quot; alt=&quot;&quot; width=&quot;121&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 05:10:00 +0000</pubDate>
<dc:creator>李晓晖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/naaoveGIS/p/8589204.html</dc:identifier>
</item>
<item>
<title>记一次线上Curator使用过程JVM栈溢出解决 - 黄青石</title>
<link>http://www.cnblogs.com/huangqingshi/p/8576948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangqingshi/p/8576948.html</guid>
<description>&lt;p&gt;　   为了同学们看起来一目了，特按如下思路进行讲解。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;1.出现的场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   2.分析及解决的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   3.总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最近公司要使用zookeeper做配置管理（后面简称ZK)，然后自己就提前用虚拟机进行了ZK三台集群的搭建。之后开始选择使用zookeeper的java client工具，google了半天，发现了一个很名强大的Apache的Curator工具，很多底层的东西都已经给你封装好了，所以用起来很方便，因为我使用的场景是做配置管理，所以使用Curator的Framework就够了。Curator相对于zookeeper，就相当于Guava之于Java.&lt;/p&gt;
&lt;p&gt;　　因为每天的QPS上亿，所以考虑的因素还是很多，因此从网上找了一些demo，然后自己就开始写一些测试的类，下边的这个方法是用于获取客户端，并且加入了一些监听和输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CuratorFramework getClient(String namespace) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{

        ACLProvider aclProvider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ACLProvider() {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ACL&amp;gt;&lt;span&gt; acl ;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;ACL&amp;gt;&lt;span&gt; getDefaultAcl() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(acl ==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    ArrayList&lt;/span&gt;&amp;lt;ACL&amp;gt; acl =&lt;span&gt; ZooDefs.Ids.CREATOR_ALL_ACL;
                    acl.clear();
                    acl.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ACL(Perms.ALL, &lt;span&gt;new&lt;/span&gt; Id(&quot;auth&quot;, &quot;admin:admin&quot;&lt;span&gt;) ));
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.acl =&lt;span&gt; acl;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; acl;
            }
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;ACL&amp;gt;&lt;span&gt; getAclForPath(String path) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; acl;
            }
        };
        String scheme &lt;/span&gt;= &quot;digest&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] auth = &quot;admin:admin&quot;&lt;span&gt;.getBytes();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; connectionTimeoutMs = 1000&lt;span&gt;;
        String connectString &lt;/span&gt;= &quot;127.0.0.1:2181&quot;&lt;span&gt;;        &lt;/span&gt;&lt;span&gt;
        CuratorFramework client &lt;/span&gt;=&lt;span&gt; CuratorFrameworkFactory.builder().
                aclProvider(aclProvider).
                authorization(scheme, auth).
                connectionTimeoutMs(&lt;/span&gt;1&lt;span&gt;).
                connectString(connectString).sessionTimeoutMs(&lt;/span&gt;50&lt;span&gt;).
                namespace(namespace).
                retryPolicy(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RetryOneTime(1&lt;span&gt;)).build();
        client.getConnectionStateListenable().addListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionStateListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stateChanged(CuratorFramework client, ConnectionState newState) {
                System.out.println(&lt;/span&gt;&quot;** STATE CHANGED TO : &quot; +&lt;span&gt; newState);
            }
        });
        client.start();
        client.getZookeeperClient().internalBlockUntilConnectedOrTimedOut();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        client.getZookeeperClient().blockUntilConnectedOrTimedOut();&lt;/span&gt;
&lt;span&gt;        System.out.println(client.getZookeeperClient().isConnected());
        System.out.println(client.getState());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取客户端之后就可以启动（client.start())客户端并且创建相当的Node以及它的payload. 感觉写的已经可以了,而且经过简单的测试，觉得可以了，然后就上到测试环境上了，测试环境的访问量并不是很大，所以也没有什么特别异常，之后就放到线上了。&lt;/p&gt;
&lt;p&gt;　　当把程序放到线上去之后，系统的JVM监控系统就开始报警，线程数由几百迅速增加到了3、4千个，直接超过了我们设置的报警阈值，所以感觉使用jstack命令 jstack -l pid &amp;gt; threadDump,找一个 stack analyzer online的一个网站 fastthread.io, upload做好的threadDump文件，上边有很多汇总，然后基本上一目了然：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317121552257-1699490071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1700多个TIMED_WATING,还有1700多个TIMED_WATING,这里边肯定有问题，然后继续往下拉，会按线程分组进行展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317121740535-1561444895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　会发现有大概有77%的线程和Curator有关系，这个应该就是它的问题了，那么点开里边的内容，就能看到线程的明细了，继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317122052669-1209608416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　里边有Curator Framework的代码了，找到相当的行907，发现只要Client一启动的话就会使得BlockingQueue会有一个take()的动作，这个take的含义是将head取到，如果没有的话就等待，这就是线程WAITING的状态，然后继续看是在什么地方调用的它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317122403004-1471159162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    找到了，原来是客户端启动（client.start())的时候进行的调用，因为我在网上看到很多地方说build模式拿到的Client是线程安全的，所以我就每次拿一次client，然后调用其start()。这样每个不同的线程就会都等待在那个位置上。我没有在Finally调用 CloseableUtils.closeQuietly(client); 因为请求量太大，如果频繁的调用关闭客户端会造成性能下降，必须保持一个长连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317122823864-14690253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开Curator的官网上，里边也进行了说明，创建采用build的方式是线程安全的，但是要保持单例。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1236784/201803/1236784-20180317123720169-1413213223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样问题找到了，下边开始想着如果修复和优化，首先让它实现单例，同时还不能用完之后就直接关闭。同时要保持长连接，在特定情况下进行连接关闭，那就如果出现异常为&lt;/p&gt;
&lt;pre&gt;
KeeperException.ConnectionLossException时需要捕获并且进行计数和关闭。同时也为了效率考虑，再获取Node的payload时将payload进行缓存，这样再次减少了对zk的大量访问。同时可以根据自己的实际情况去考虑缓存的时间。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(client == &lt;span&gt;null&lt;/span&gt; || client.getState().equals(CuratorFrameworkState.STOPPED) || !&lt;span&gt;client.getNamespace().equals(namespace)) {
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (ZookeeperUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(client == &lt;span&gt;null&lt;/span&gt; || client.getState().equals(CuratorFrameworkState.STOPPED) || !&lt;span&gt;client.getNamespace().equals(namespace)) {
                        client &lt;/span&gt;=&lt;span&gt; getClient(namespace);
                    }
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同时在网上找到zookeeper集群上从3.4开始，从客户端连接数&lt;strong&gt;maxClientCnxns&lt;/strong&gt;（配置在zoo.cfg)默认连接数为60，改为0时不限制。&lt;/p&gt;
&lt;p&gt;　　总结：&lt;/p&gt;
&lt;p&gt;　　1. 当遇到线程数增加或CPU过高时需要使用jstack将JVM的线程数据导出到文件，然后通过在线工具或自己下载的工具进行分析，我还是比较喜欢这个在线的分析工具，它能分析出总的线程数中按状态进行分析，还可以按线程类型进行分组，很强大。&lt;/p&gt;
&lt;p&gt;　　2. 遇到问题要冷静思考，然后多写几个小的demo进行测试。我其实在写这个问题的过程中我是写了测试类进行模拟的，然后通过本机的jvisualvm查看栈的情况，根我推断的一致的，所以就会找到解决的方法。&lt;/p&gt;
&lt;p&gt;　　3.有些技术知识还是从官方网站学习，而且如果看书的话，需要从头看到尾，这样的话基本上能了解事务的全部内容，否则只看到部分内容。&lt;/p&gt;
&lt;p&gt;　　如果有写的不对的地方，欢迎同学们来拍砖~&lt;/p&gt;

</description>
<pubDate>Sat, 17 Mar 2018 05:03:00 +0000</pubDate>
<dc:creator>黄青石</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangqingshi/p/8576948.html</dc:identifier>
</item>
<item>
<title>JVM垃圾收集器&amp;对象的引用回收 - mosterRan</title>
<link>http://www.cnblogs.com/moster/p/8589061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moster/p/8589061.html</guid>
<description>&lt;div id=&quot;rightArrow&quot;&gt;&lt;a href=&quot;https://github.com/a947000098&quot;&gt;&lt;img src=&quot;https://github-camo.global.ssl.fastly.net/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;1.介绍垃圾收集器&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;  　垃圾收集器（Garbage Collection，GC）就是用于回收方法区和堆区，其他程序计数器、虚拟机栈、本地方法栈这3个区域都是随线程而生，随线程而灭，栈中的栈帧会随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都是具备确定性，所以这3个区域不需要考虑回收，因为方法结束或线程结束时，内存自然就跟着回收了。而Java堆和方法区就不同，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序出于运行期间才能知道会创建那些对象，这部分内存分配和回收都是动态的，所以这是垃圾收集器关注的内存。　 &lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;1.1如何判定对象是否存活？&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;引用计数算法&lt;/p&gt;
&lt;p&gt;　　给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0 的对象就是不能在被使用的。这种算法的优点在于判定效率高，实现简单，但Java 虚拟机没有选用引用计数算法来管理内存，原因是它很难解决相互循环引用的问题。&lt;/p&gt;
&lt;p&gt;下面的代码可以看出两个对象互相引用对方的属性所以不会被GC&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReferenceCountingGc {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object instance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024*1024&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] bigSize = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2 *&lt;span&gt; _1MB];
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGC() {
        ReferenceCountingGc objA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReferenceCountingGc();
        ReferenceCountingGc objB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReferenceCountingGc();
        objA.instance &lt;/span&gt;=&lt;span&gt; objB;
        objB.instance &lt;/span&gt;=&lt;span&gt; objA;
        
        objA &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        objB &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        System.gc();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ReferenceCountingGc.testGC();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可达性分析算法&lt;/p&gt;
&lt;p&gt;主流商用程序语言（JAVA 、C#）的主流实现都是通过可达性分析来判定对象是否存活。基本思路就是通过一些列的成为“GC Roots”的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明对象是不可用的。&lt;/p&gt;
&lt;p&gt;在 Java 语言中，可作为GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
&lt;li&gt;方法区中静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈中 JNI（Native方法） 引用的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;
&lt;h2&gt;2.对象的引用&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;　　无论是引用计数器判断对象的引用数量，还是可达性分析算法判断引用链是否可达，判定对象是否存活都与“引用”有关。JDK1.2 以前，Java 中引用的定义为 如果 reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表这一个引用。一个对象只有引用或者未被引用两种状态，总感觉缺少点什么，我们希望能描述这样一类对象：当内存还足够时，则能保留内存之中；如果内存空间在进行GC后还非常紧张，则可以抛弃这些对象。&lt;/p&gt;
&lt;p&gt;所以在JDK1.2 之后，Java 对引用概念进行扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强引用：类似“Object obj = new Object()”只要强引用还存在，垃圾收集器永远不会回收掉被应用的对象&lt;/li&gt;
&lt;li&gt;软引用：用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才回抛出内存溢出异常-&amp;gt;JDK1.2后，提供了SoftReference类来实现软引用&lt;/li&gt;
&lt;li&gt;弱引用：用来描述非必须对象的，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集器发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象-&amp;gt;JDK1.2后，提供了WeakReference类来实现弱引用&lt;/li&gt;
&lt;li&gt;虚引用：称为幽灵引用或幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。一个对象关联虚拟引用唯一目地就是能在这个对象被收集器回收时收到一个通知-&amp;gt;PhantomReference来实现虚引用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    User u &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
    SoftReference s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SoftReference(u);
    WeakReference w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakReference(u);
    PhantomReference p &lt;/span&gt;=  &lt;span&gt;new&lt;/span&gt; PhantomReference(u, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;2.1对象的缓刑&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 　　并不是在可达性分析算法中被标记一次就会马上被回收，而是至少要经历两次标记过程：如果对象在进行可达性分析后没有与GC Roots 相连接的引用链，则会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行的 finalize()方法。当对象没有覆盖 finalize()方法，或 finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。&lt;/p&gt;
&lt;p&gt;如果这个对象被判定没必要执行 finalize()方法，这个对象将会放置在F-Queue的队列中，并稍后由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里“执行”是虚拟机会触发这个方法，并不承诺会等待它运行结束，如果在对象的finalize()方法中执行缓慢，或者发生死循环，会导致F-Queue 队列其他对象永久处于等待，会导致内存回收系统崩溃。finalize()方法是对象逃脱回收的最后一次机会，稍后GC 将对 F-Queue中的对象进行第二次小规模标记，如果对象在finalize()中重新与引用链上任何一个对象建立关联即可，如把自己（this）赋值给某个类变量或者对象的成员变量，第二次标记时就会将它移除“即将回收”的集合；如果对象此时还没逃脱基本就被回收了。&lt;/p&gt;
&lt;p&gt;注意：finalize()方法只会被系统自动调用一次&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.1回收方法区&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;　　垃圾收集器主要回收两部分内容：废弃常量和无用的类废弃常量如字符串“abc”已经进入常量池中，但没有任何一个String对象引用它，也没有其他地方引用这个字面量，如果发生内存回收，而且有必要的话，这个“abc”常量就会被系统清理出常量池&lt;/p&gt;
&lt;p&gt;无用的类需要同时满足已下3个条件才算。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例&lt;/li&gt;
&lt;li&gt;加载该类的ClassLoader已经被回收&lt;/li&gt;
&lt;li&gt;该类java.lang.Class 对象没有任何地被引用，无法在任何地方通过反射访问该类的方法&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 17 Mar 2018 04:52:00 +0000</pubDate>
<dc:creator>mosterRan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moster/p/8589061.html</dc:identifier>
</item>
<item>
<title>一个多年互联网从业者，对刚入职场人最真诚的忠告 - metoy</title>
<link>http://www.cnblogs.com/qingquanzi/p/8589004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingquanzi/p/8589004.html</guid>
<description>&lt;p&gt;&lt;span&gt;我跟大多数初入职场的技术小白起点差不多，在开发的这条路上，没有天生的聪明天资，也没有一个耀眼的学历。在北京这样一个，随便一个同事，不是清华的本硕，就是北邮北航的硕士下，自己也常常因此感到惭愧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自己从事开发多年，经历过不少的公司。先是在普通的小互联网公司，后又在阿里这样的大公司工作，最近又到了美团这样的二线互联网公司。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反思自己的职业生涯，其实挺失败的，我清楚地看到，刚毕业那时的我，那些想法是错误的，那些习惯是应该是养成的。只可惜，刚毕业那时的我，无缘遇到一个能教导我这些的leader。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为一个过来人，今天我把自己的这些反思分享给大家，希望那些刚毕业刚入职场的小白，能够不要走我走错的路。(如果你觉着我说的有道理，不妨转发一下朋友圈，让更多的人看到)&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1287675/201803/1287675-20180317123536419-567268316.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1、不要认为业务不重要&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;刚毕业那会的我，常常这么想：我是做技术的，只要技术掌握好，做啥业务没关系。于是呢，每次换工作，都是在不同的行业切换。&lt;/p&gt;

&lt;p&gt;或许换工作会因为自己对技术的越来越娴熟，而有一定的工资涨幅。但是，企业更倾向于要相同业务背景的开发人员，他们更愿意为他们付高一些的工资，因为这类既有技术又有相关业务背景的人，往往比较稀缺。这类人不仅可以帮助公司用技术实现业务。也会知道在这个业务背景下，如何做更合理，效率更高，坑更少。而这些技巧、规范性的东西，往往是你经历过这个业务而收获的，很难通过自己查查资料就能学会掌握的。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;2、刚入职场，工资高低真不重要&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多刚工作的人都这么选择：A公司比B公司的薪资高三四千，果断选择A公司。&lt;/p&gt;

&lt;p&gt;通过工资高低来选择公司，是错误的认知。其实你想想啊，每个月少三千块钱你也不会饿着，每个月多三千块钱，你也不会变富。你应该把眼光放到这里：&lt;strong&gt;这家公司带给你的成长，能否让你未来更值钱，更具井竞争力。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可能你会说，我怎么知道这家公司是否能让我未来更值钱啊。&lt;/p&gt;

&lt;p&gt;其一，你先看看这家公司所从事的业务，然后反问自己，这个业务是否有前景有价值？自己是否愿意在相当长的一段时间里，在这个业务领域进行沉淀耕耘？&lt;/p&gt;

&lt;p&gt;其二，公司里的leader或者领导，是否有想法有格局，做事有条理不混乱。直白点就是公司里得有个像样的大牛供你学习吧。刚入职场的你，大概率是除了会些技术，其他都不懂的。你的成长最好是有一个优秀的人作为参考。&lt;/p&gt;

&lt;p&gt;我特别想强调下，一定要把握自己的试用期。试用期是公司考核你是否合格的时间，也是你考核公司是否适合自己的时间。试用期离职不算跳槽，觉着不合适就要在试用期抓紧撤，不要勉强自己满一年后再撤。一来时间很重要，不要荒废自己一年的时间；二来满一年跳槽就是频繁跳槽的标记。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3、不要频繁跳槽&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个都知道，公司不喜欢频繁跳槽的人，更喜欢安定踏实的人，这是从公司的角度来看。从个人发展的角度来看，频繁跳槽也是对自己的不负责任。&lt;/p&gt;

&lt;p&gt;对于技术来说，一个人花点时间、花点精力，都可以把技术学的不错。但是业务沉淀则不同。作为开发，开始往往只能接触业务上的很小一段，要掌握整个业务背景下的技术架构体系、以及规范技巧，离不开长时间的沉淀。&lt;/p&gt;

&lt;p&gt;如果你不想多年后，只是一个代码熟练地码农。那你一定要选好行业，选好公司，然后长时间沉淀，厚积薄发。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;4、刚入职场，能进大公司就去大公司&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于我们大部分的普通人，刚毕业进入职场，除了技术，其他基本上是一页白纸。对于技术学习，自己找资料，花精力，学好学会肯定是没问题的。但是对于如何做事，如何思考，采用什么样的流程规范，什么是行得通什么是行不通的，等等，你很难通过自学学会。&lt;/p&gt;

&lt;p&gt;大公司很多的流程、规范、技巧，都是很多聪明人经过长时间的实践积累沉淀而来的，如果你能进大公司去接触学习，自然对你以后的发展格局大有裨益。&lt;/p&gt;

&lt;p&gt;当然，大公司也有大公司的弊端。大公司的有些部门，经过长时间的发展，已经比较成熟稳定，很难再有开创性的突破。在这种环境下，尽管你也学到不少的东西，但给你实践性的发展空间比较小。这也是我觉着最好的发展经历就是：先在大公司沉淀学习，然后去成长型公司(或者部门)实践发展。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;5、养成思考的习惯&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最后这一条，也是大家最耳详能熟的。或许你也懂得这个道理，但是你是否打心里认可，是否实践于自己的工作日常，还需你自己评估下。&lt;/p&gt;

&lt;p&gt;从大道理上讲，国家的发展靠什么？肯定是“创新”俩字。&lt;/p&gt;

&lt;p&gt;如果没有人创新发明了汽车，那运输的效率是不是很低下。&lt;/p&gt;
&lt;p&gt;如果没有人创新发明了电话，那通讯的效率是不是很低下。&lt;/p&gt;
&lt;p&gt;等等等。。。。。&lt;/p&gt;

&lt;p&gt;其实对于个人的发展也是这样，个人要想发展起来，也是通过开创性的做一些事情。不管成功与否，它总能带给你成长的经历。即使失败了你也能学到：这样做是行不通的；成了则自然少不了升职加薪。&lt;/p&gt;

&lt;p&gt;而做一些开创性、创新性事情的起源，就是你对日常工作的思考，用土话说就是琢磨。&lt;/p&gt;

&lt;p&gt;一旦你养成了思考的习惯，你就将从一个被动接受任务完成工作的人，变成一个主动做事开创自己事业的人。&lt;/p&gt;

&lt;p&gt;最后我想说：&lt;strong&gt;工作仅仅可以让你糊口，但是事业可以让你有成就感，且容易财务自由。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;----------------------------------------------------------------&lt;/p&gt;
&lt;p&gt; 如果有兴趣，可以加入我的圈子，一起成长进步&lt;/p&gt;




</description>
<pubDate>Sat, 17 Mar 2018 04:39:00 +0000</pubDate>
<dc:creator>metoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingquanzi/p/8589004.html</dc:identifier>
</item>
</channel>
</rss>