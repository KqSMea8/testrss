<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程之ThreadLocal内存泄漏探究 - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9311308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9311308.html</guid>
<description>&lt;p&gt;&lt;strong&gt;使用 ThreadLocal 不当可能会导致内存泄露，是什么原因导致的内存泄漏呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先看一个例子，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/14.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalOutOfMemoryTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LocalVariable {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Long[] a = &lt;span&gt;new&lt;/span&gt; Long[&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (1)&lt;/span&gt;
    final &lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor poolExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(6, 6, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, TimeUnit.MINUTES,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2)&lt;/span&gt;
    final &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (3)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;50&lt;/span&gt;; ++&lt;span&gt;i) {
            poolExecutor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (4)&lt;/span&gt;
                    localVariable.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LocalVariable());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (5)&lt;/span&gt;
                    System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;use local varaible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    localVariable.remove();&lt;/span&gt;
&lt;span&gt;
                }
            });

            Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (6)&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pool execute over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（1）创建了一个核心线程数和最大线程数为 6 的线程池，这个保证了线程池里面随时都有 6 个线程在运行。&lt;/p&gt;
&lt;p&gt;代码（2）创建了一个 ThreadLocal 的变量，泛型参数为 LocalVariable，LocalVariable 内部是一个 Long 数组。&lt;/p&gt;
&lt;p&gt;代码（3）向线程池里面放入 50 个任务。&lt;/p&gt;
&lt;p&gt;代码（4）设置当前线程的 localVariable 变量，也就是把 new 的 LocalVariable 变量放入当前线程的 threadLocals 变量。&lt;/p&gt;
&lt;p&gt;由于没有调用线程池的 shutdown 或者 shutdownNow 方法所以线程池里面的用户线程不会退出，进而 JVM 进程也不会退出。&lt;/p&gt;

&lt;p&gt;运行后，我们立即打开jconsole 监控堆内存变化，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714222827452-1022712833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，让我们打开 localVariable.remove() 注释，然后在运行，观察堆内存变化如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714223105351-233334858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从第一次运行结果可知，当主线程处于休眠时候进程占用了大概 75M 内存，打开 localVariable.remove() 注释后第二次运行则占用了大概 25M 内存，可知 没有写 localVariable.remove() 时候内存发生了泄露，下面分析下泄露的原因，如下：&lt;/p&gt;
&lt;p&gt;第一次运行的代码，在设置线程的 localVariable 变量后没有调用&lt;code&gt;localVariable.remove()&lt;/code&gt; 方法，导致线程池里面的 5 个线程的 threadLocals 变量里面的&lt;code&gt;new LocalVariable()&lt;/code&gt;实例没有被释放，虽然线程池里面的任务执行完毕了，但是线程池里面的 5 个线程会一直存在直到 JVM 退出。这里需要注意的是由于 localVariable 被声明了 static，虽然线程的 ThreadLocalMap 里面是对 localVariable 的弱引用，localVariable 也不会被回收。运行结果二的代码由于线程在设置 localVariable 变量后即使调用了&lt;code&gt;localVariable.remove()&lt;/code&gt;方法进行了清理，所以不会存在内存泄露。&lt;/p&gt;

&lt;p&gt;接下来我们要想清楚的知道内存泄漏的根本原因，那么我们就要进入源码去看了。&lt;/p&gt;
&lt;p&gt;我们知道ThreadLocal 只是一个工具类，具体存放变量的是在线程的 threadLocals 变量里面，threadLocals 是一个 ThreadLocalMap 类型的，我们首先一览ThreadLocalMap的类图结构，类图结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180714224007079-1026057888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图 ThreadLocalMap 内部是一个 Entry 数组, Entry 继承自 WeakReference，Entry 内部的 value 用来存放通过 ThreadLocal 的 set 方法传递的值，那么 ThreadLocal 对象本身存放到哪里了吗?&lt;/p&gt;
&lt;p&gt;下面看看 Entry 的构造函数，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Entry(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; k, Object v) {
    super(k);
    value &lt;/span&gt;=&lt;span&gt; v;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再接着看Entry的父类WeakReference的构造函数super（k），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WeakReference(T referent) {
   super(referent);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再看WeakReference的父类Reference的构造函数super（referent），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Reference(T referent) {
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(referent, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们再看WeakReference的父类Reference的另外一个构造函数this（referent , null），如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Reference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt;&lt;span&gt; queue) {
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.referent =&lt;span&gt; referent;
   &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.queue = (queue == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; ReferenceQueue.NULL : queue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知 k 被传递到了 WeakReference 的构造函数里面，也就是说 ThreadLocalMap 里面的 key 为 ThreadLocal 对象的弱引用，具体是 referent 变量引用了 ThreadLocal 对象，value 为具体调用 ThreadLocal 的 set 方法传递的值。&lt;/p&gt;
&lt;p&gt;当一个线程调用 ThreadLocal 的 set 方法设置变量时候，当前线程的 ThreadLocalMap 里面就会存放一个记录，这个记录的 key 为 ThreadLocal 的引用，value 则为设置的值。&lt;/p&gt;
&lt;p&gt;但是考虑如果这个 ThreadLocal 变量没有了其他强依赖，而当前线程还存在的情况下，由于线程的 ThreadLocalMap 里面的 key 是弱依赖，则当前线程的 ThreadLocalMap 里面的 ThreadLocal 变量的弱引用会被在 gc 的时候回收，但是对应 value 还是会造成内存泄露，这时候 ThreadLocalMap 里面就会存在 key 为 null 但是 value 不为 null 的 entry 项。&lt;/p&gt;
&lt;p&gt;其实在 ThreadLocal 的 set 和 get 和 remove 方法里面有一些时机是会对这些 key 为 null 的 entry 进行清理的，但是这些清理不是必须发生的，下面简单讲解ThreadLocalMap 的 remove 方法的清理过程，remove 的源码，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(ThreadLocal&amp;lt;?&amp;gt;&lt;span&gt; key) {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)计算当前ThreadLocal变量所在table数组位置，尝试使用快速定位方法&lt;/span&gt;
  Entry[] tab =&lt;span&gt; table;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)这里使用循环是防止快速定位失效后，变量table数组&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i]; e != &lt;span&gt;null&lt;/span&gt;; e = tab[i =&lt;span&gt; nextIndex(i, len)]) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(3)找到&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (e.&lt;span&gt;get&lt;/span&gt;() ==&lt;span&gt; key) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(4)找到则调用WeakReference的clear方法清除对ThreadLocal的弱引用&lt;/span&gt;
&lt;span&gt;          e.clear();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(5)清理key为null的元素&lt;/span&gt;
&lt;span&gt;          expungeStaleEntry(i);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
   }
}
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expungeStaleEntry(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; staleSlot) {
            Entry[] tab &lt;/span&gt;=&lt;span&gt; table;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; tab.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6）去掉去value的引用&lt;/span&gt;
            tab[staleSlot].value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            tab[staleSlot] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            size&lt;/span&gt;--&lt;span&gt;;&lt;br/&gt;Entry e;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = nextIndex(staleSlot, len); (e = tab[i]) != &lt;span&gt;null&lt;/span&gt;; i =&lt;span&gt; nextIndex(i, len)) {
                ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt; k = e.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(7)如果key为null,则去掉对value的引用。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    e.value &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    size&lt;/span&gt;--&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (len - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h !=&lt;span&gt; i) {
                        tab[i] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tab[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            h &lt;/span&gt;=&lt;span&gt; nextIndex(h, len);
                        tab[h] &lt;/span&gt;=&lt;span&gt; e;
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（4）调用了 Entry 的 clear 方法，实际调用的是父类 WeakReference 的 clear 方法，作用是去掉对 ThreadLocal 的弱引用。&lt;/p&gt;
&lt;p&gt;代码（6）是去掉对 value 的引用，到这里当前线程里面的当前 ThreadLocal 对象的信息被清理完毕了。&lt;/p&gt;
&lt;p&gt;代码（7）从当前元素的下标开始看 table 数组里面的其他元素是否有 key 为 null 的，有则清理。循环退出的条件是遇到 table 里面有 null 的元素。所以这里知道 null 元素后面的 Entry 里面 key 为 null 的元素不会被清理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.ThreadLocalMap 内部 Entry 中 key 使用的是对 ThreadLocal 对象的弱引用，这为避免内存泄露是一个进步，因为如果是强引用，那么即使其他地方没有对 ThreadLocal 对象的引用，ThreadLocalMap 中的 ThreadLocal 对象还是不会被回收，而如果是弱引用则这时候 ThreadLocal 引用是会被回收掉的。&lt;/p&gt;
&lt;p&gt;　　2.但是对于的 value 还是不能被回收，这时候 ThreadLocalMap 里面就会存在 key 为 null 但是 value 不为 null 的 entry 项，虽然 ThreadLocalMap 提供了 set,get,remove 方法在一些时机下会对这些 Entry 项进行清理，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露，所以在使用完毕后即使调用 remove 方法才是解决内存泄露的最好办法。&lt;/p&gt;
&lt;p&gt;　　3.线程池里面设置了 ThreadLocal 变量一定要记得及时清理，因为线程池里面的核心线程是一直存在的，如果不清理，那么线程池的核心线程的 threadLocals 变量一直会持有 ThreadLocal 变量。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 15:21:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9311308.html</dc:identifier>
</item>
<item>
<title>javaScript设计模式之面向对象编程（object-oriented programming，OOP）(一) - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9297286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9297286.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
面试的时候，总会被问到，你对javascript面向对象的理解？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程（object-oriented programming，OOP）是一种程序设计范型。它讲&lt;span&gt;对象&lt;/span&gt;作为程序的设计&lt;span&gt;基本单元&lt;span&gt;，讲程序和数据封装其中，以提高程序的重用性、灵活性和扩展性。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、举个例子&lt;/p&gt;
&lt;p&gt;有这么一个需求：做一个验证表单功能，仅需要验证用户名，邮箱，密码等&lt;/p&gt;
&lt;p&gt;觉得在项目产品开发中，自己是这么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkName(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkEmail(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkPassword(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;声明了3个全局变量，&lt;/p&gt;
&lt;p&gt;下面是创建3个函数保存在变量里来实现你的功能，而你写的是将你的变量名放在function后边，也代表了你的变量，所以声明了3个全局变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建了3个函数保存在变量里&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; checkName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证码邮箱&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; checkPassword = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从功能上讲没有任何问题，但是如果别人也定义了同样的方法就会覆盖原有的功能，这种相互覆盖的问题不易觉察到。&lt;/p&gt;
&lt;p&gt;我们可以将这些检查函数放在一个变量里保存，这样减少覆盖和被覆盖的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）用对象收编变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象，他有属性和方法，我们访问属性或者方法，可以通过&lt;span&gt;&lt;strong&gt;点语法&lt;/strong&gt;&lt;/span&gt;向下遍历查询得到，我们可以&lt;strong&gt;创建一个检测对象，我们把方法放在里面。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们将所有的函数作为CheckObject对象的方法，这样我们就只有一个对象，比如检测姓名CheckObject.checkName().&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2)对象的另一种形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先声明一个对象，然后给他添加方法&lt;/strong&gt;，在JavaScript中函数也是对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
CheckObject.checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
CheckObject.checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是当别人想用你写的对象方法就比较麻烦，因为这个对象不能复制一份（这个&lt;strong&gt;对象类&lt;/strong&gt;在用new关键字创建新的对象时，新创建的对象时不能继承这些方法）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）真假对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想简单的复制一下，你可以将这些方法放在一个函数对象中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验姓名&lt;/span&gt;
&lt;span&gt;        }，
        checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验邮箱&lt;/span&gt;
&lt;span&gt;        }
        checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验密码&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当每次调用这个函数的时候，把我们之前的对象返回出来，当别人每次调用这个函数时都会&lt;strong&gt;返回新对象&lt;/strong&gt;。这样我们每个人使用的时候就不会相互影响，比如检测邮箱可以这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; CheckObject();
a.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（4）类也可以&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然通过创建新对象完成需求，但是他不是一个真正的意义上的类的创建方式，并且创建对象a和对象CheckObject没有任何关系，返回的对象与CheckObject对象无关，稍微优化一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.checkPassword = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这样的对象，就可以看成是类，我们就可以不需要使用&lt;strong&gt;创建对象方法&lt;/strong&gt;创建，既然是一个类，就用关键词new来创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以用CheckObject类创建出来对象，我们其他人就可以对&lt;strong&gt;类实例化（用类创建对象）&lt;/strong&gt;，这样每一个人都有一套自己的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）一个检测类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过this的定义，每一次通过new关键字创建新对象时候，新创建的对象都会对类的this上的属性进行复制，所以新创建的对象都会有自己的一套方法，然而有时候造成消耗很奢侈，我们需要处理一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype.checkName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;}
CheckObject.prototype.checkEmail &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;}
CheckObject.prototype.checkPassword &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样创建对象实例时候，创建出来的对象所拥有的方法都是一个，因为他们需要依赖prototype原型依次寻找，而找到方法是同一个，但是prototype写很多遍，可以这么写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
checkObject.prototype &lt;/span&gt;=&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
&lt;span&gt;    }，
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
&lt;span&gt;    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上两种方法不能混着用。&lt;/p&gt;
&lt;p&gt;如在后边为对象的原型对象赋值新对象，那么会覆盖之前对prototype对象赋值的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;  a  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkName();
a.checkEmail();
a.checkPassword();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(6)方法还可以这样用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、this对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;；
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CheckObject.checkName().checkEmail().checkPassword();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、类的原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype &lt;/span&gt;=&lt;span&gt; {
    checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;；
    }，
    checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是使用的时候需要创建一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckObject();
a.checkName().checkEmail().checkPassword();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(7)函数祖先&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如你想给每一个函数都添加一个检测邮箱的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Function.prototype.checkEmail = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测邮箱&lt;/span&gt;
｝
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样使用这个方法就比较简单，&lt;/p&gt;
&lt;p&gt;1、函数形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
f.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、类的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function();
f.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你这种方式，原则上没有问题，但是污染了全局原生对象Function，这样别人创建的函数也会被你创建的函数污染，造成不必要的开销，但是你可以&lt;strong&gt;抽象出一个统一添加方法&lt;/strong&gt;的功能方法。方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，如果你想添加邮箱验证的方法和姓名验证的方法，可以这样使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;(){};&lt;br/&gt;//或者&lt;br/&gt;var methods = new Function();&lt;br/&gt;methods.addMethod('checkName',function(){&lt;br/&gt;　　//验证姓名&lt;br/&gt;})&lt;br/&gt;methods.addMethod('checkEmail',function(){&lt;br/&gt;　　//验证邮箱&lt;br/&gt;})&lt;br/&gt;methods.checkName();&lt;br/&gt;methods.checkEmail();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(8)链式添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果想&lt;span&gt;&lt;strong&gt;链式添加&lt;/strong&gt;&lt;/span&gt;，在addMethods中将this返回，就可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你还想&lt;strong&gt;添加方法&lt;/strong&gt;，可以这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
methods.addMethod(&lt;/span&gt;'checkName',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名 &lt;/span&gt;
}).addMethod('checkEmail',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱 &lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我想&lt;span&gt;&lt;strong&gt;链式使用&lt;/strong&gt;&lt;span&gt;，应该如何实现？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;既然添加方法可以将this返回实现，那么添加的每一个方法都将this返回是不是也就实现了呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; methods = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
methods.addMethod(&lt;/span&gt;'checkName',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;  
}).addMethod(&lt;/span&gt;'checkEmail',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
methods.checkName().checkEmail();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;(9)换一种使用方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、函数式调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、类式调用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Function.prototype.addMethod = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name,fn){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype[name] =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用类式调用，不能直接使用，需要通过new关键字来创建新对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Methods();
m.checkEmail();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JavaScript中函数时一等公民。&lt;/p&gt;

&lt;p&gt;1、如何实现方法的链式调用？&lt;/p&gt;
&lt;p&gt;只需在类中的每个方法中通过this关键字返回对象实例的引用。每次函数调用都会返回一个新对象，表面上是CheckObject对象，实际是返回的新对象，这样每次调用就不会相互影响了。&lt;/p&gt;
&lt;p&gt;2、为函数添加多个方法的addMethod方法？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）this对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject =&lt;span&gt; {
     checkName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;      
    } ,   &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;   checkEmail: function&lt;span&gt;(){
      //验证邮箱
      return this&lt;span&gt;;      
    } ,  &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 　　checkPassword: function(){
      //验证密码
      return this;      
    } ,  
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（2）类的原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CheckObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
CheckObject.prototype &lt;/span&gt;=&lt;span&gt; {
     checkName:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证姓名&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    } ,
    checkEmail:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证邮箱&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
     },
     checkPassword:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证密码&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 14 Jul 2018 15:17:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9297286.html</dc:identifier>
</item>
<item>
<title>springboot添加邮件发送及压缩功能 - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/9190233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/9190233.html</guid>
<description>&lt;h6&gt;&lt;span&gt;springboot添加邮件发送及文件压缩功能&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;转载请注明出处&lt;/span&gt;：&lt;span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: springboot添加邮件发送功能&quot; href=&quot;https://www.cnblogs.com/funnyzpc/p/9190233.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/funnyzpc/p/9190233.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先来一段诗&lt;/p&gt;
&lt;p&gt;&lt;span&gt;```&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　就这样吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　忍受折磨&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　然后，躺进医院&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　然后，死去&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　化作一抔土&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　从此，这世界没有烦恼&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　没有病痛&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　没有我&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　也没有这个世界&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;```&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;以上是在半睡半醒中想到的，写的不好，读者可直接略过。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这次本来只讲讲邮件发送功能的，惮于内容比较贫乏，故加了点儿文件压缩的功能讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先邮件发送，邮件功能在springboot里面是有对应的依赖组件，这个：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-mail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;邮件功能开发在springboot里面相当简单，这里我大致总结下开发内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　A&amp;gt;添加依赖包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　B&amp;gt;配置Mail基本参数(ymal或propertie里面)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　C&amp;gt;Service中注入JavaMailSender，调用相关方法即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这里面可能会有个问题，就是在具体服务器部署的时候服务器会封堵&lt;span&gt;邮件服务端口&lt;/span&gt;，以及普通邮件&lt;span&gt;安全&lt;/span&gt;问题，这里讲解的时候我会顺道给出解决之道。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，需要在工程的pom.xml中&lt;span&gt;引入邮件组件&lt;/span&gt;，组件的版本需对应springboot的版本(可不写，这里我略去)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-mail&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;接下来就是在配置文件中配置邮件的基本参数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    mail:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      host: smtp.exmail.qq.com
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      username: username@hostname.com
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      password: 密码
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      default-encoding: UTF-8
&lt;/span&gt;&lt;span&gt; 7       ssl:
 8         trust: smtp.exmail.qq.com
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      properties:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        mail:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;          smtp:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            auth: true  #是否需要认证
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            socketFactory:
14               class: javax.net.ssl.SSLSocketFactory #SSL证书Socket工厂
15               port: 465 #使用SMTP465端口&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;配置参数的时候一定要注意缩进，因为我给的是yaml的配置格式，&lt;span&gt;若是properties配置，大致是这样子(例子)：spring.mail.host:smtp.exmail.qq.com&lt;/span&gt;,每一个子项都是完整的格式，一开始我是省略了properties项以下的配置(是否认真，SSL，端口)，后来发现服务器将邮件的25端口封了，所以在本地可以但是在服务器就行不通了，所以需要&lt;span&gt;指定邮件服务端口&lt;/span&gt;为465，我这里使用的是qq邮箱，如果使用163或其他邮箱需自行查阅服务商支持的端口，至于邮件安全问题，在这里需要声明两个，&lt;span&gt;一个是ssl信任，以及mail的socket工厂&lt;/span&gt;，具体请见以上红色部分，以上配置仅对qq邮箱有效，不保证其他邮箱也适用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ok，配置完成，这里就开始写具体的实现类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; XXX.common.util.DateUtil;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.SimpleMailMessage;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.javamail.JavaMailSender;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.mail.javamail.MimeMessageHelper;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.mail.internet.MimeMessage;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MailService {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(MailService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     @Value(&quot;${spring.mail.username}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String SEND_USER_ADDR;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JavaMailSender mailSender;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;     *      发送简单邮件
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;&lt;span&gt; sendSimpleMail&lt;/span&gt;(String receive,String obj,String content) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!StringUtils.isNotBlank(content) || !&lt;span&gt;StringUtils.isNotBlank(receive))
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不发送空邮件&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         SimpleMailMessage message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMailMessage();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        message.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             message.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            message.setTo(receive);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        message.setSubject(obj);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        message.setText(content);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            mailSender.send(message);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             LOG.info(&quot;Simple mail send success!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             LOG.error(&quot;sendSimpleMail ERROR!&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringBuilder strBuilder;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;     *  发送html邮件 多列表单的形式
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题(题目)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendHtmlMailByList&lt;/span&gt;(String receive,String obj,List&amp;lt;Map&amp;gt;&lt;span&gt; content){
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(content.isEmpty() || !StringUtils.isNotBlank(receive) || &lt;span&gt;null&lt;/span&gt;==&lt;span&gt;obj)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             MimeMessage msg =&lt;span&gt; mailSender.createMimeMessage();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(msg, &lt;span&gt;true&lt;/span&gt;, &quot;UTF-8&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决乱码问题&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                helper.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     helper.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                    helper.setTo(receive);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                helper.setSubject(obj);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                 strBuilder=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body style=\&quot;padding:3% 2%;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;This message is automatically sent to the system.&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;Send Date by &quot;+DateUtil.getDateFormat(&lt;span&gt;new&lt;/span&gt; Date(),DateUtil.DATETIME_DEFAULT_FORMAT) +&quot;&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h2&amp;gt;The following is the details:&amp;lt;/h2&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;table border=\&quot;2px solid red\&quot; width=\&quot;100%\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;thead style=\&quot;background-color: #aea2e2;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 Object[] st=content.get(0&lt;span&gt;).keySet().toArray();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;st.length;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;th&amp;gt;&quot;+st[i]+&quot;&amp;lt;/th&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/thead&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;体&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map item:content){
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object str:st)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         strBuilder.append(&quot;&amp;lt;td&amp;gt;&quot;+item.get(str)+&quot;&amp;lt;/td&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                     strBuilder.append(&quot;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/table&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;h3 style=\&quot;text-align:right\&quot;&amp;gt;Best wishes&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LOG.info(strBuilder.toString());&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                 helper.setText(strBuilder.toString(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 LOG.error(&quot;sendHtmlMail ERROR:&quot;&lt;span&gt;,e);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            mailSender.send(msg);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;     *  发送html邮件 单列记录形式
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; receive   收件人
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; obj       发送主题(题目)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content   邮件内容
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendHtmlMailByItem&lt;/span&gt;(String receive,String obj,List&amp;lt;String&amp;gt;&lt;span&gt; content){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(content.isEmpty() || !StringUtils.isNotBlank(receive) || &lt;span&gt;null&lt;/span&gt;==&lt;span&gt;obj)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         MimeMessage msg =&lt;span&gt; mailSender.createMimeMessage();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(msg, &lt;span&gt;true&lt;/span&gt;, &quot;UTF-8&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解决乱码问题&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            helper.setFrom(SEND_USER_ADDR);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(receive.contains(&quot;;&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 helper.setTo(receive.split(&quot;;&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                helper.setTo(receive);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            helper.setSubject(obj);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             strBuilder=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body style=\&quot;padding:3% 2%;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;This message is automatically sent to the system.&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;Send Date by &quot;+DateUtil.getDateFormat(&lt;span&gt;new&lt;/span&gt; Date(),DateUtil.DATETIME_DEFAULT_FORMAT) +&quot;&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3&amp;gt;The following is the details:&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;table border=\&quot;2px solid red\&quot; width=\&quot;100%\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;thead style=\&quot;background-color: #aea2e2;\&quot;&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;th&amp;gt;&quot;+obj.toUpperCase()+&quot; DETAIL&amp;lt;/th&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/thead&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;体&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String item:content){
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 strBuilder.append(&quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot;+item+&quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/tbody&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/table&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;h3 style=\&quot;text-align:right;font-weight:normal;\&quot;&amp;gt;Best wishes&amp;lt;/h3&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             strBuilder.append(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;            LOG.info(strBuilder.toString());
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             helper.setText(strBuilder.toString(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;             LOG.error(&quot;sendHtmlMail ERROR:&quot;&lt;span&gt;,e);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        mailSender.send(msg);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上我是将邮件功能封装成一个服务类，&lt;span&gt;使用的时候只需要将当前类注入 然后直接调用即可&lt;/span&gt;，以上封装了两个方法：一个是简单邮件发送，一个是带html table的邮件，如果需要&lt;span&gt;发送附件，需将附件放入到&lt;/span&gt;&lt;span&gt;MimeMessageHelper里面(调用addAttachment(&quot;文件名&quot;, 文件))&lt;/span&gt;方法即可，这里因为无实际需求，遂就略去了，好了，邮件发送功能已经完成，这里看下实际效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180714214436361-1229539825.png&quot; alt=&quot;&quot; width=&quot;1069&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;邮件功能实现完毕，现在我讲讲文件压缩功能，压缩功能的实现大致有四种，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;A&amp;gt;利用java.util.zip提供的api压缩&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B&amp;gt;利用apache的ant包提供的api压缩(org.apache.tools.ant.taskdefs.Zip)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C&amp;gt;使用zip4j提供的api压缩(net.lingala.zip4j)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　D&amp;gt;调用宿主机的shell命令压缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要特别提到三个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;A&amp;gt;普通邮件压缩中文乱码(不支持中文)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B&amp;gt;压缩后无法解压(解压错误)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C&amp;gt;文件压缩添加压缩密码问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际开发过压缩功能，以上三点儿对于新手来说尤其的头痛，这里我分享下以前在开发压缩功能中碰到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用原生java.util包提供的压缩，如果被压缩文件使用到中文，则会&lt;span&gt;乱码&lt;/span&gt;(据说是jdk的一个bug)，而且压缩实现的代码较为复杂(尤其是设置密码)，尤其是对于跨目录压缩和多文件压缩尤其麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用apache提供的zip工具虽避免了以上会出现的问题，但是需要提醒一点儿的是这个&lt;span&gt;ant包与webLogic冲突(&lt;/span&gt;部署的时候会报错)且无法实现压缩设置密码，如果使用的是webLogic而不是tomocat的情况下，一定要注意到这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用java调用宿主机的shell命令也是个不错的选择，但是，需要编写shell命令，同时对于部署在&lt;span&gt;windows平台就不太友好了，移植比较麻烦&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，对于以上问题，我这里推荐&lt;strong&gt;&lt;span&gt;zip4j&lt;/span&gt;&lt;/strong&gt;，以下也是针对zip4j的压缩实现做讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先，需要引入依赖包&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;       &amp;lt;!--压缩：支持加密压缩--&amp;gt;
&lt;span&gt;2&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;3&lt;/span&gt;             &amp;lt;groupId&amp;gt;net.lingala.zip4j&amp;lt;/groupId&amp;gt;
&lt;span&gt;4&lt;/span&gt;             &amp;lt;artifactId&amp;gt;zip4j&amp;lt;/artifactId&amp;gt;
&lt;span&gt;5&lt;/span&gt;             &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&lt;span&gt;6&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;再，封装一个压缩/解压缩工具类以方便使用&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.core.ZipFile;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.exception.ZipException;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.model.ZipParameters;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.lingala.zip4j.util.Zip4jConstants;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StringUtils;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 本工具类使用Zip4j来进行压缩以及解压缩
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZipUtil {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明压缩对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ZipParameters parameters;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解压文件对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ZipFile zipFile;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sourceFilePath    被压缩的文件的路径(单文件,文件夹)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; zipFilePath       压缩文件路径
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password          压缩密码
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;                  压缩成功：true ，压缩失败：false
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean &lt;strong&gt;&lt;span&gt;singleFileCompress&lt;/span&gt;&lt;/strong&gt;(String sourceFilePath,String zipFilePath,String password){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         parameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipParameters();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 压缩方式(默认方式)&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 压缩级别(默认级别)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩加密设置&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.isEmpty(password)) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             parameters.setEncryptFiles(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否设置文件加密(默认为否)&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加密方式(此处是标准压缩)&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            parameters.setPassword(password.toCharArray());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             ZipFile zipFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(zipFilePath);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是文件则直接压缩，若是文件夹，遍历文件全部压缩&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath).isFile()) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 zipFile.setFileNameCharset(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 zipFile.addFile(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath), parameters);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;File ff=new File(sourceFilePath);&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             File[] flst=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(sourceFilePath).listFiles();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             System.out.println(&quot;文件个数=&amp;gt;&quot;+&lt;span&gt;flst.length);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(File f:flst){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 zipFile.setFileNameCharset(&quot;GBK&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                zipFile.addFile(f, parameters);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ZipException e) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception id){
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            id.printStackTrace();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean &lt;span&gt;&lt;strong&gt;unZip&lt;/strong&gt;&lt;/span&gt;(String zipFile,String unZipDir){
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             ZipUtil.zipFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(zipFile);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             ZipUtil.zipFile.setFileNameCharset(&quot;GBK&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置编码格式
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用自带的方法检测一下zip文件是否合法，包括文件是否存在、是否为zip文件、是否被损坏等&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ZipUtil.zipFile.isValidZipFile()) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZipException(&quot;文件不合法或不存在&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跟java自带相比，这里文件路径会自动生成，不用判断&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            ZipUtil.zipFile.extractAll(unZipDir);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(ZipException e){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;以上压缩方法自带密码压缩功能，可以压缩单文件也可以压缩目录文件，相对于原生的实现，一下子清爽了许多，这里唯一需要说明的是，压缩的目标文件在压缩前一定不能穿件，否则会报错！另外对于解压缩一定要注意文件编码和判断文件是否存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　OK，本章的功能已尽数分享，希望各位在开发功能的时候能避免这其中的&lt;strong&gt;&lt;span&gt;坑&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在是2018-07-14 22:16:12 ,各位晚安&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180714221708537-1189105993.png&quot; alt=&quot;&quot; width=&quot;45&quot; height=&quot;42&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 14:30:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/9190233.html</dc:identifier>
</item>
<item>
<title>SSH 学习笔记 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/9311160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/9311160.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;在看 pm2 的 deploy 功能的时候，对 ssh 的不熟悉导致错误频出，包括之前对 github 的配置也用到了 SSH，所以找个机会整理一下。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;code&gt;SSH&lt;/code&gt; 是每一台 Linux 电脑的标准配置。&lt;/p&gt;
&lt;p&gt;需要指出的是，SSH 只是一种&lt;strong&gt;协议&lt;/strong&gt;，存在多种&lt;strong&gt;实现&lt;/strong&gt;，既有商业实现，也有开源实现。本文针对的实现是 &lt;code&gt;OpenSSH&lt;/code&gt;，它是自由软件，应用非常广泛。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[拓展]&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;sslsshopensslopenssh-的关系&quot;&gt;1、SSL、SSH、OpenSSL、OpenSSH 的关系：&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222302800-1954833915.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ssl-版本之间的关系&quot;&gt;2、SSL 版本之间的关系：&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222312806-457353542.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以 SSL 的规范叫法是 &lt;code&gt;SSL/TLS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前，应用最广泛的是 TLS 1.0。不过比如微信的小程序接口开发需要支持 TLS 大于等于 1.2。&lt;/p&gt;
&lt;h3 id=&quot;scpsecure-copy&quot;&gt;3、scp（secure copy）&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;scp&lt;/code&gt; 是 linux 系统下基于 ssh 登陆进行的安全远程文件拷贝命令。&lt;/p&gt;
&lt;h5 id=&quot;从本地复制到远程&quot;&gt;（1）从本地复制到远程&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;//复制文件
scp /Users/xjnotxj/Downloads/a.jpg root@1.2.3.4:/data/wwwroot 
scp /Users/xjnotxj/Downloads/a.jpg root@1.2.3.4:/data/wwwroot/b.jpg

//复制目录
scp -r /Users/xjnotxj/Downloads/folder/ root@1.2.3.4:/data/wwwroot/&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;从远程复制到本地&quot;&gt;（2）从远程复制到本地&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;前后顺序颠倒即可&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;远程登录&quot;&gt;1、远程登录&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;SSH 登录机制：由上文可知，SSH 基于 SSL/TLS 协议，而它的&lt;strong&gt;机制有两种&lt;/strong&gt;：&lt;/p&gt;
&lt;h5 id=&quot;口令认证需要密码即口令&quot;&gt;（1）&lt;strong&gt;口令认证&lt;/strong&gt;（需要密码（即口令））&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222322067-1270974907.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们访问 host 远程服务器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次访问的时候，会弹出提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host

　　The authenticity of host 'host (xx.xxx.xx.xxx)' can't be established.

　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.

　　Are you sure you want to continue connecting (yes/no)?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段话的意思时：&lt;strong&gt;无法确认远程 host 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗&lt;/strong&gt;？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;之所以是公钥指纹而不是公钥，即用 fingerprint 代替 key，主要是 key 过于长（RSA算法生成的公钥最少也得 1024 位），很难直接比较。所以，对公钥进行 hash 生成一个 128 位的指纹，这样就方便比较了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会有提示？&lt;/p&gt;
&lt;p&gt;因为要防止&lt;code&gt;中间人攻击&lt;/code&gt;，因为 hacker 的服务器也可以冒充身份把它自己的公钥发给你。&lt;/p&gt;
&lt;p&gt;什么是中间人攻击？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222331471-817492110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;yes 后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Warning: Permanently added 'host (xx.xxx.xx.xxx)' (RSA) to the list of known hosts. 
Password: (enter password) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该 host 被追加到文件 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 中，然后就可以正常输入密码了，且以后再连接这个 host 就不会有提示了。&lt;/p&gt;
&lt;p&gt;那如果在&lt;strong&gt;连接前&lt;/strong&gt;就避免这种恼人的提示？&lt;/p&gt;
&lt;p&gt;① ssh-keyscan / known_hosts&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;事先使用 &lt;code&gt;ssh-keyscan&lt;/code&gt; 命令（ gather ssh public keys ）获取到远程主机的公钥，然后添加到信任列表 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 里 ，避免弹出这个警告。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keyscan -t rsa gitlab.xxx.com &amp;gt;&amp;gt; ~/.ssh/known_hosts&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个 SSH 用户都有 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt; 文件，此外系统也有一个这样的文件，通常是 &lt;code&gt;/etc/ssh/ssh_known_hosts&lt;/code&gt;，保存一些对所有用户都可信赖的远程主机的公钥。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② StrictHostKeyChecking=no&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh user@host -o StrictHostKeyChecking=no &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=no&lt;br/&gt;最不安全的级别。相对安全的内网建议使用。如果连接和 key 不存在或不匹配，那么就自动添加到 &lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=ask &lt;br/&gt;默认的级别。如果连接和 key 不存在或不匹配，给出提示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StrictHostKeyChecking=yes &lt;br/&gt;最安全的级别。如果连接与 key 不存在或不匹配，就直接拒绝连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;密钥认证不需要密码但事先得把本机的公钥放在服务器上&quot;&gt;（2）&lt;strong&gt;密钥认证&lt;/strong&gt;（不需要密码，但事先得把本机的公钥放在服务器上）&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222341018-748752603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 生成本机公钥&lt;/p&gt;
&lt;p&gt;先判断本机有没有之前生成过公钥？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat ~/.ssh/id_rsa.pub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有，执行下面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa 

ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096
// github/gitlab 官方推荐这种写法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;~/.ssh&lt;/code&gt; 下会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt;。前者是你的&lt;strong&gt;公钥&lt;/strong&gt;，后者是你的&lt;strong&gt;私钥&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;-t 是选择 key 的类型，支持 dsa | ecdsa | ed25519 | rsa | rsa1，下面是最常用的 rsa 和 dsa 的比较：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;rsa&lt;/td&gt;
&lt;td&gt;非对称加密算法&lt;/td&gt;
&lt;td&gt;大整数的分解（两个素数的乘积）&lt;/td&gt;
&lt;td&gt;几乎一样&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;广泛&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dsa&lt;/td&gt;
&lt;td&gt;非对称加密算法&lt;/td&gt;
&lt;td&gt;整数有限域离散对数&lt;/td&gt;
&lt;td&gt;几乎一样&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;一般&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;结论：&lt;strong&gt;&lt;code&gt;RSA&lt;/code&gt; 是目前最好也是使用最广泛的非对称加密算法&lt;/strong&gt;。如 github/gitlab 和 pm2 官方文档都推荐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② 拷贝本机公钥到远程服务器上&lt;/p&gt;
&lt;p&gt;这里有两种方法：&lt;/p&gt;
&lt;p&gt;a.ssh-copy-id&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-copy-id remote@myserver.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是远程主机将用户的公钥，保存在 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;b.类 github 方法&lt;/p&gt;
&lt;p&gt;github/gitlab 需要手工粘贴到 web 的设置页面里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896608/201807/896608-20180714222403816-1486358611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ 直接登录，不需要输入密码了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ssh user@host&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：如果还不行的解决方法：&lt;/p&gt;
&lt;p&gt;打开远程主机的 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，检查下面几行前面&quot;#&quot;注释是否去掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　RSAAuthentication yes
　　PubkeyAuthentication yes
　　AuthorizedKeysFile .ssh/authorized_keys&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重启 ssh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // ubuntu系统
  service ssh restart

  // debian系统
  /etc/init.d/ssh restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;密钥认证虽然前期麻烦，需要手动将公钥放置在远程主机上，但是更加安全，可以有效&lt;strong&gt;杜绝中间人攻击&lt;/strong&gt;，推荐使用。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;https 是如何避免中间人攻击的?&lt;/p&gt;
&lt;p&gt;通过 CA 证书中心来进行公证，这些证书都是事先内置在浏览器里的，其实跟 SSH 的密钥认证法很像，是事先把公钥放在远程服务器的&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;[拓展]&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&quot;githubgitlab-使用-sshhttps-哪个好&quot;&gt;github/gitlab 使用 SSH、HTTPS 哪个好？&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;① 是否输入密码&lt;/p&gt;
&lt;p&gt;当你&lt;strong&gt;git clone、git fetch、git pull、git push&lt;/strong&gt;使用 HTTPS URL，你会被要求输入 GitHub 的&lt;strong&gt;用户名和密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当你&lt;strong&gt;git clone、git fetch、git pull、git push&lt;/strong&gt;使用 SSH URL，你会被要求输入你的 &lt;strong&gt;SSH密钥密码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但一般我们在生成 SSH 密钥的时候没有设置密码的习惯。所以等于 SSH 的方式不需要输入密码。&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;windows&lt;/strong&gt; 下也可以有存储密码的方法，用 git-credential-winstore 和 git-credential-manager-for-windows 存储 credential，安全性和便捷性同样可以保证。具体没用过，windows i refuse。&lt;/p&gt;
&lt;p&gt;② 部署难度&lt;/p&gt;
&lt;p&gt;对&lt;strong&gt;类 linux&lt;/strong&gt; 来说配置 ssh 是最简单的方式。毕竟 git 是 linus 写的软件。linus 又是 linux 的作者。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;总结：对于我这个 mac 用户，还是用 SSH 更方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;使用别名登录主机&quot;&gt;（3）使用别名登录主机&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;新建文件 &lt;code&gt;~/.ssh/config&lt;/code&gt;，并写入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Host myWebsite
    HostName 1.2.3.4
    User root
    IdentityFile ~\.ssh\id_rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Host : 别名&lt;br/&gt;HostName：目标主机名或 IP 地址&lt;br/&gt;User：登陆的用户&lt;br/&gt;IdentityFile：登陆的私钥&lt;/p&gt;
&lt;p&gt;于是可以这样登录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//原来
$ ssh root@1.2.3.4
//现在
$ ssh myWebsite&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实践看我另一篇《 &lt;a href=&quot;https://www.cnblogs.com/xjnotxj/p/5845574.html&quot;&gt;一台电脑上的git同时使用两个github账户&lt;/a&gt; 》&lt;/p&gt;
&lt;h5 id=&quot;其他参数&quot;&gt;（4）其他参数&lt;/h5&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;//指定端口
$ ssh root@1.2.3.4 -p 8080

//调试模式
$ ssh -v root@1.2.3.4 &lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;远程服务器管理-ssh-登录用户&quot;&gt;（5）远程服务器管理 SSH 登录用户&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;① 查看所有在线用户 / 查看自己&lt;/p&gt;
&lt;p&gt;简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]#  who
root     tty1         2018-01-05 15:11
root     pts/0        2018-07-14 19:07 (xxx.81.48.19)
root     pts/1        2018-07-14 19:00 (xxx.81.48.19)

//查看自己
[root@AY140506122759852282Z ~]#  who am i
root     pts/1        2018-07-14 19:00 (xxx.81.48.19)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# w
 19:07:26 up 190 days,  3:56,  3 users,  load average: 1.24, 1.07, 1.06
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1      05Jan18 190days  1.66s  1.66s -bash
root     pts/0     19:07   26.00s  0.04s  0.04s -bash
root     pts/1     19:00    6.00s  0.13s  0.00s w

//指定特定用户
[root@AY140506122759852282Z ~]# w root&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;USER：登陆帐号&lt;br/&gt;TTY：用户终端&lt;br/&gt;LOGIN@：登陆时间&lt;br/&gt;IDLE：登陆时长&lt;br/&gt;JCPU：指所有与该终端相关的进程任务所耗费的 CPU 时间&lt;br/&gt;PCPU：指 WHAT 域的任务执行耗费的 CPU 时间&lt;br/&gt;WHAT：表示当前执行的任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间、登录时长&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② 踢掉某个在线用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# pkill -kill -t pts/0

//强制
[root@AY140506122759852282Z ~]# pkill -9 -t pts/0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后对方就会自动断开连接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# Connection to xxx.124.109.112 closed.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;③ 查看用户登录历史（包括在线）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@AY140506122759852282Z ~]# last -10
root     pts/0        xxx.81.48.19     Sat Jul 14 19:07   still logged in
root     pts/1        xxx.81.48.19     Sat Jul 14 19:00   still logged in
root     pts/1        xxx.81.48.19     Sat Jul 14 18:59 - 18:59  (00:00)
root     pts/1        xxx.81.48.19     Sat Jul 14 18:58 - 18:59  (00:00)
root     pts/1        xxx.81.48.19     Sat Jul 14 18:57 - 18:58  (00:00)
root     pts/0        xxx.81.48.19     Sat Jul 14 18:57 - 19:04  (00:07)
root     pts/0        xxx.81.48.19     Sat Jul 14 17:18 - 17:23  (00:05)
root     pts/1        xxx.81.48.19     Sat Jul 14 14:14 - 14:14  (00:00)
root     pts/0        xxx.81.48.19     Sat Jul 14 14:13 - 14:14  (00:01)
root     pts/0        xxx.81.48.19     Fri Jul 13 14:41 - 16:41  (02:00)

//指定特定用户
[root@AY140506122759852282Z ~]# last -10 root&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示时间为&lt;strong&gt;登录时间、注销时间、登录时长&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;退出ssh&quot;&gt;（6）退出SSH&lt;/h5&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;exit&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;远程执行命令&quot;&gt;2、远程执行命令&lt;/h3&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;ssh user@host 'ls /data'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列出远程主机 /data 下的目录&lt;/p&gt;
&lt;h3 id=&quot;端口转发&quot;&gt;3、端口转发&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;待写，具体可先参考：&lt;/p&gt;
&lt;p&gt;《SSH原理与运用（二）：远程操作与端口转发》http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&lt;br/&gt;《玩转SSH端口转发》&lt;br/&gt;https://blog.fundebug.com/2017/04/24/ssh-port-forwarding/&lt;/p&gt;
&lt;h3 id=&quot;实现-vpn虚拟专用网络&quot;&gt;4、实现 VPN（虚拟专用网络）&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;略&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;1.【SSH原理与运用（一）：远程登录】http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&lt;br/&gt;2.【Linux系统下如何查看已经登录用户】https://www.jb51.net/LINUXjishu/10876.html&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 14:24:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjnotxj/p/9311160.html</dc:identifier>
</item>
<item>
<title>Spring核心——Bean的定义与控制 - AI乔治</title>
<link>http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</guid>
<description>&lt;p&gt;在Sring核心与设计模式的文章中，分别介绍了Ioc容器和Bean的依赖关系。如果阅读过前2文就会知道，Spring的整个运转机制就是围绕着IoC容器以及Bean展开的。IoC就是一个篮子，所有的Bean都向里面扔。除了提供篮子功能创建并存放Bean之外，IoC还要负责管理Bean与Bean之间的关系——依赖注入。之前也提到Bean是Spring核心容器的最小工作单元，Spring一些更高级的功能（例如切面、代理）都是在Bean的基础上实现。&lt;/p&gt;
&lt;p&gt;除了管理Bean与Bean之间的关系，IoC还提供了对Bean自身进行控制的各项功能，本文将介绍Bean的生命周期功能以及状态定义功能。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;前置依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bean与Bean之间存在依赖关系，可以是强依赖（通过XML和注解直接声明依赖）、也可以是弱依赖（ApplicationContextAware等方式获取）。当一个Bean需要另外一个Bean完成初始化后自身才能工作时，例如一个Bean依赖DataSoruce，但是DataSource的初始化需要较长时间。这个时候用&lt;em&gt;depends-on&lt;/em&gt;声明前置依赖即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215113590-2033206306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;延迟加载&lt;/h2&gt;
&lt;p&gt;通常情况下，所有的 singleton 类型的Bean都会在容器创建后进行初始化，简单的说就是启动Jvm就开始创建（实际上是创建ApplicationContext的某个实现类实例之后）。&lt;/p&gt;
&lt;p&gt;IoC支持所有的 singleton Bean在使用时再加载，这样做的好处是可以大大节省初始化的时间。但是如果你的应用对启动时间的长短并不敏感，建议让所有的 singleton 都启动时加载。这样可以在启动时就发现一些问题，而不是在运行很久直到使用时才由用户去触发这个问题。或者可以根据场景来使用决定是否延迟，例如开发时使用延迟加载，而在集成测试或上生产时关闭。&lt;/p&gt;
&lt;p&gt;可以设置全局延迟加载，也可以设置某个Bean延迟加载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215132579-1019762338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215146871-1983160172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，在设置某个单独的Bean延迟加载时，如果有某个没有延迟加载的Bean要依赖他，那实际上也会在初始化的时候就加载。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;还要强调一下，这里的“加载”仅仅是为了表示一个类被Ioc创造并放置容器中，和classLoad方法将class文件中的字节码加载到方法区的加载是两个概念。&lt;/p&gt;
&lt;p&gt;延迟加载在设计模式上是单例模式一种延伸，通常也被称为懒汉模式。单例通常有双重锁+volatile、静态类和枚举三种方式实现。在Effective &lt;em&gt;Java&lt;/em&gt;一书中对三种模式都有深入的解析。而对于Spring容器而言，枚举的方式肯定不好用了，静态类由于属于自身代码级别应该也不会用，所以双重锁的实现方式较为可信。不过我没去看过源码，仅属于猜测。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;生命周期方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个Bean的创建、使用再到最后销毁称为&quot;Bean的生命周期&quot;。Spring框架为Bean的生命周期各个阶段提供了多种回掉方法来处理各种状态或者数据。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;初始化方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个Bean完成初始化并注入各项参数之后，初始化回掉方法会被调用，简单的说就是完成创建之后会被调用。实现初始化回调方法有2个路径：1.继承org.springframework.beans.factory.InitializingBean接口，然后实现afterPropertiesSet方法。2.在Bean的XML配置上使用init-method属性来制定要调用的初始化：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215222123-1710140570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215235519-1614027468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2种方法都等效，实际使用是我们应该使用哪一种方法呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InitializingBean是Spring早期实现的一个生命周期回调方法。但是在JCP推出JSR-250和JSR-330规范之后，Spring的大神们开始意识到基于元编程思想和配置手段来实现非侵入式框架（Not Coupled）才是正道。所以现在都是推荐使用配置文件和JSR-250的@PostConstruct（关于各种Annotation的使用请关注后续的文章）。现在依然保留InitializingBean应该是考虑到兼容问题。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;销毁方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与创建方法相对应的是销毁方法。当一个类将要被销毁之前，对应的销毁回调方法会被调用。销毁方法也有一个继承实现和配置+注解实现：&lt;/p&gt;
&lt;p&gt;继承实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215256457-1163101040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215309978-1037696572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;依然建议销毁手段也使用配置或@PreDestroy来设定销毁方法。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;全局配置初始化与销毁方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IoC容器还提供了全局配置初始化与销毁方法的配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1376692/201807/1376692-20180714215338532-544696104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;通过在&amp;lt;beans&amp;gt;标签上使用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通过在&amp;lt;beans&amp;gt;标签上使用&lt;em&gt;default-init-method&lt;/em&gt;和&lt;em&gt;default-destroy-method&lt;/em&gt; 属性参数，可以为容器中所有的Bean统一指定初始化和销毁的生命周期方法。&lt;/p&gt;
&lt;p&gt;如果在&amp;lt;beans&amp;gt;上设定2个默认的生命周期方法，同时在&amp;lt;bean&amp;gt;上也指定了&lt;em&gt;init-method&lt;/em&gt;或&lt;em&gt;destroy-method，&lt;/em&gt;回调方法会以&amp;lt;bean&amp;gt;上的配置为准。这样就保证全局配置与单独配置可以共存。&lt;/p&gt;
&lt;p&gt;使用初始化或销毁2个生命周期方法注意的要点：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;初始化和销毁都提供了3种手段：XML配置、注解、以及实现接口。系统的各个部分会交由不同的团队开发，不遵循统一的规范，建议使用满足JSR规范的注解——@PostConstruct、@PreDestroy。如果是统一的团队，准训一致的规范，建议使用&amp;lt;beans&amp;gt;的属性统一名称使用全局配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果Bean设计到代理模式时（例如使用了AOP），那么生命周期方法被调用时，有可能代理类还没有被创建出来。因为生命周期方法是实体类完成对应工作之后就会被调用，而与代理类无关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 14 Jul 2018 13:50:00 +0000</pubDate>
<dc:creator>AI乔治</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIPAOJIAO/p/9311078.html</dc:identifier>
</item>
<item>
<title>JAVAEE——Lucene基础：什么是全文检索、Lucene实现全文检索的流程、配置开发环境、索引库创建与管理 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9311066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9311066.html</guid>
<description>&lt;p&gt;&lt;span&gt;第一天：&lt;/span&gt;Lucene&lt;span&gt;的基础知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、案例分析：什么是全文检索，如何实现全文检索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Lucene&lt;span&gt;实现全文检索的流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 创建索引&lt;/p&gt;
&lt;p&gt;b) 查询索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、配置开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、创建索引库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、查询索引库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、分析器的分析过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 测试分析器的分词效果&lt;/p&gt;
&lt;p&gt;b) 第三方中文分析器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、索引库的维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a) 添加文档&lt;/p&gt;
&lt;p&gt;b) 删除文档&lt;/p&gt;
&lt;p&gt;c) 修改文档&lt;/p&gt;
&lt;p&gt;8&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的高级查询&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;使用&lt;/span&gt;Query&lt;span&gt;的子类查询&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MatchAllDocsQuery&lt;/li&gt;
&lt;li&gt;TermQuery&lt;/li&gt;
&lt;li&gt;NumericRangeQuery&lt;/li&gt;
&lt;li&gt;BooleanQuery&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;b) &lt;span&gt;使用&lt;/span&gt;QueryParser&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;QueryParser&lt;/li&gt;
&lt;li&gt;MulitFieldQueryParser&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;span&gt;实现一个文件的搜索功能，通过关键字搜索文件，&lt;/span&gt;&lt;span&gt;凡是文件名或文件内容包括关键字的文件&lt;/span&gt;&lt;span&gt;都需要找出来。还可以根据中文词语进行查询，并且需要支持多个条件查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本案例中的原始内容就是磁盘上的文件，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213109981-1226552600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;3.1. &lt;strong&gt;数据库搜索&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;数据库中的搜索很容易实现，通常都是使用&lt;/span&gt;sql&lt;span&gt;语句进行查询，而且能很快的得到查询结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为什么数据库搜索很容易？&lt;/p&gt;
&lt;p&gt;因为数据库中的数据存储是有规律的，有行有列而且数据格式、数据长度都是固定的。&lt;/p&gt;

&lt;h2&gt;3.2. &lt;strong&gt;数据分类&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们生活中的数据总体分为两种：结构化数据和非结构化数据。&lt;/p&gt;
&lt;p&gt;结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非结构化数据：指不定长或无固定格式的数据，如邮件，&lt;/span&gt;word&lt;span&gt;文档等磁盘上的文件&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.3. &lt;strong&gt;非结构化数据查询方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;&lt;span&gt;顺序扫描法&lt;/span&gt;(Serial Scanning)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用&lt;/span&gt;windows&lt;span&gt;的搜索也可以搜索文件内容，只是相当的慢。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;（2）&lt;strong&gt;&lt;span&gt;全文检索&lt;/span&gt;(Full-text Search)&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之&lt;/span&gt;&lt;strong&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;span&gt;字典&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据&lt;/span&gt;——&lt;span&gt;也即对字的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;这种先建立索引，再对索引进行搜索的过程就叫全文检索&lt;/span&gt;(Full-text Search)&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。&lt;/p&gt;
&lt;h2&gt;3.4. &lt;strong&gt;如何实现全文检索&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;Lucene&lt;span&gt;实现全文检索。&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.5. &lt;strong&gt;全文检索的应用场景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、&lt;/span&gt;Google&lt;span&gt;等搜索引擎、论坛站内搜索、电商网站站内搜索等。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;4.1. &lt;strong&gt;索引和搜索流程图&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213228919-731064707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1&lt;span&gt;、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档&lt;/p&gt;

&lt;p&gt;2&lt;span&gt;、红色表示搜索&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;，从索引库中搜索内容，搜索过程包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果&lt;/p&gt;

&lt;h2&gt;4.2. &lt;strong&gt;创建索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（&lt;/span&gt;index&lt;span&gt;）中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。&lt;/p&gt;

&lt;h3&gt;4.2.1. &lt;strong&gt;获得原始文档&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原始文档&lt;/strong&gt;&lt;span&gt;是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本案例中的原始内容就是磁盘上的文件，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213629237-897660206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Internet&lt;span&gt;上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Lucene&lt;span&gt;不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nutch&lt;span&gt;（&lt;/span&gt;&lt;a href=&quot;http://lucene.apache.org/nutch&quot;&gt;&lt;span&gt;http://lucene.apache.org/nutch&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）&lt;/span&gt;, Nutch&lt;span&gt;是&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;的一个子项目，包括大规模爬虫工具，能够抓取和分辨&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;网站数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jsoup（&lt;span&gt;http://jsoup.org/&lt;/span&gt;&lt;span&gt; &lt;/span&gt;），jsoup &lt;span&gt;是一款&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt; &lt;span&gt;的&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;解析器，可直接解析某个&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址、&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;文本内容。它提供了一套非常省力的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，可通过&lt;/span&gt;&lt;span&gt;DOM&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;span&gt;以及类似于&lt;/span&gt;&lt;span&gt;jQuery&lt;/span&gt;&lt;span&gt;的操作方法来取出和操作数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;heritrix&lt;span&gt;（&lt;/span&gt;&lt;span&gt;http://sourceforge.net/projects/archive-crawler/files&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;Heritrix &lt;span&gt;是一个由&lt;/span&gt; &lt;span&gt;java&lt;/span&gt; &lt;span&gt;开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于&lt;/span&gt;pdf&lt;span&gt;、&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;xls&lt;/span&gt;&lt;span&gt;等文件可通过第三方提供的解析工具读取文件内容，比如&lt;/span&gt;&lt;span&gt;Apache POI&lt;/span&gt;&lt;span&gt;读取&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;xls&lt;/span&gt;&lt;span&gt;的文件内容。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.2.2. &lt;strong&gt;创建文档对象&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（&lt;/span&gt;Document&lt;span&gt;），文档中包括一个一个的域（&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;），域中存储内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们可以将磁盘上的一个文件当成一个&lt;/span&gt;document&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;中包括一些&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;文件名称、&lt;/span&gt;&lt;span&gt;file_path&lt;/span&gt;&lt;span&gt;文件路径、&lt;/span&gt;&lt;span&gt;file_size&lt;/span&gt;&lt;span&gt;文件大小、&lt;/span&gt;&lt;span&gt;file_content&lt;/span&gt;&lt;span&gt;文件内容），如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213736863-1494691952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：每个&lt;/span&gt;Document&lt;span&gt;可以有多个&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，不同的&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;可以有不同的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，同一个&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;可以有相同的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;（域名和域值都相同）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个文档都有一个唯一的编号，就是文档&lt;/span&gt;id&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.2.3. &lt;strong&gt;分析文档&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将原始内容创建为包含域（&lt;/span&gt;Field&lt;span&gt;）的文档（&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;比如下边的文档经过分析如下：&lt;/p&gt;
&lt;p&gt;原文档内容：&lt;/p&gt;
&lt;p&gt;Lucene is a Java full-text search engine.  Lucene is not a complete&lt;/p&gt;
&lt;p&gt;application, but rather a code library and API that can easily be used&lt;/p&gt;
&lt;p&gt;to add search capabilities to applications.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分析后得到的&lt;/span&gt;&lt;span&gt;语汇单元&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lucene&lt;span&gt;、&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;full&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;search&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;engine&lt;/span&gt;&lt;span&gt;。。。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个单词叫做一个&lt;/span&gt;Term&lt;span&gt;，不同的域中拆分出来的相同的单词是不同的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;中包含两部分一部分是文档的域名，另一部分是单词的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：文件名中包含&lt;/span&gt;apache&lt;span&gt;和文件内容中包含的&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;是不同的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.2.4. &lt;strong&gt;创建索引&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到&lt;/span&gt;Document&lt;span&gt;（文档）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213801221-1541944283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫&lt;strong&gt;倒排索引结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;倒排索引结构&lt;/strong&gt;&lt;span&gt;是根据内容（词语）找文档，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213813023-1028085089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;4.3. &lt;strong&gt;查询索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（&lt;/span&gt;index&lt;span&gt;）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3.1. &lt;strong&gt;用户查询接口&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213829062-392980554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Lucene&lt;span&gt;不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.3.2. &lt;strong&gt;创建查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的&lt;/span&gt;Field&lt;span&gt;文档域、查询关键字等，查询对象会生成具体的查询语法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法&lt;/span&gt; “&lt;span&gt;fileName:lucene&lt;/span&gt;&lt;span&gt;”表示要搜索&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域的内容为“&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;”的文档&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.3.3. &lt;strong&gt;执行查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;搜索索引过程：&lt;/p&gt;
&lt;p&gt;根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如搜索语法为&lt;/span&gt;“&lt;span&gt;fileName:lucene&lt;/span&gt;&lt;span&gt;”表示搜索出&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;域中包含&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;搜索过程就是在索引上查找域为&lt;/span&gt;fileName&lt;span&gt;，并且关键字为&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;，并根据&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;找到文档&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213840644-1164666734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.3.4. &lt;strong&gt;渲染结果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213849374-321446141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h2&gt;5.1. &lt;strong&gt;Lucene&lt;span&gt;下载&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Lucene&lt;span&gt;是开发全文检索功能的工具包，从官方网站下载&lt;/span&gt;&lt;span&gt;Lucene4.10.3&lt;/span&gt;&lt;span&gt;，并解压。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;http://lucene.apache.org/&quot;&gt;&lt;span&gt;http://lucene.apache.org/&lt;/span&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本：&lt;/span&gt;lucene4.10.3&lt;/p&gt;
&lt;p&gt;Jdk&lt;span&gt;要求：&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;以上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IDE&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Eclipse&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5.2. &lt;strong&gt;&lt;span&gt;使用的&lt;/span&gt;jar&lt;span&gt;包&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213900041-401003656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714213910414-952187178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Lucene&lt;span&gt;包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lucene-core-4.10.3.jar&lt;/p&gt;
&lt;p&gt;lucene-analyzers-common-4.10.3.jar&lt;/p&gt;
&lt;p&gt;lucene-queryparser-4.10.3.jar&lt;/p&gt;

&lt;p&gt;其它：&lt;/p&gt;
&lt;p&gt;commons-io-2.4.jar&lt;/p&gt;
&lt;p&gt;junit-4.9.jar&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;indexwriter&lt;span&gt;对象创建索引&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.1. &lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;java&lt;span&gt;工程，并导入&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;indexwriter&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）&lt;span&gt;指定索引库的存放位置&lt;/span&gt;Directory&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2）指定一个分析器，对文档内容进行分析。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建&lt;/span&gt;document&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：创建&lt;/span&gt;field&lt;span&gt;对象，将&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;添加到&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：使用&lt;/span&gt;indexwriter&lt;span&gt;对象将&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象写入索引库，此过程进行索引创建。并将索引和&lt;/span&gt;&lt;span&gt;document&lt;/span&gt;&lt;span&gt;对象写入索引库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五步：关闭&lt;/span&gt;IndexWriter&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.2. &lt;strong&gt;Field&lt;span&gt;域的属性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;是否分析&lt;/strong&gt;：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否索引&lt;/strong&gt;&lt;span&gt;：将&lt;/span&gt;Field&lt;span&gt;分析后的词或整个&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;值进行索引，只有索引方可搜索到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否存储&lt;/strong&gt;&lt;span&gt;：将&lt;/span&gt;Field&lt;span&gt;值存储在文档中，存储在文档中的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;才可以从&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;中获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：商品名称、订单号，凡是将来要从&lt;/span&gt;Document&lt;span&gt;中获取的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;都要存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;是否存储的标准：是否要将内容展示给用户&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Field&lt;span&gt;类&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数据类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Analyzed&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否分析&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Indexed&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否索引&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Stored&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;StringField(FieldName, FieldValue,Store.YES))&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;字符串&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建一个字符串&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，但是不会进行分析，会将整个串存储在索引中，&lt;/span&gt;比如&lt;span&gt;(&lt;/span&gt;订单号,&lt;span&gt;姓名等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储在文档中用Store.YES&lt;span&gt;或&lt;/span&gt;Store.NO&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;LongField(FieldName, FieldValue,Store.YES)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Long&lt;span&gt;型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建一个&lt;span&gt;Long&lt;/span&gt;&lt;span&gt;数字型&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;，进行分析和索引，&lt;/span&gt;比如&lt;span&gt;(&lt;/span&gt;价格)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;是否存储在文档中用Store.YES&lt;span&gt;或&lt;/span&gt;Store.NO&lt;span&gt;决定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;center&quot;&gt;StoredField(FieldName, FieldValue) &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;重载方法，支持多种类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;N&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;这个&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;用来&lt;/span&gt;构建不同类型&lt;span&gt;Field&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;不分析，不索引，但要&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;存储在文档中&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;209&quot; readability=&quot;10&quot;&gt;
&lt;p align=&quot;center&quot;&gt;TextField(FieldName, FieldValue, Store.NO)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;或&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;TextField(FieldName, reader)&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;73&quot;&gt;
&lt;p align=&quot;center&quot;&gt;字符串&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;或&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;流&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;94&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;82&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Y或&lt;span&gt;N&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;center&quot;&gt;如果是一个&lt;span&gt;Reader, lucene&lt;/span&gt;&lt;span&gt;猜测内容比较多&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会采用&lt;/span&gt;&lt;span&gt;Unstored&lt;/span&gt;&lt;span&gt;的策略&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;6.3. &lt;strong&gt;代码实现&lt;/strong&gt; &lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; createIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定索引库存放的路径
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;D:\temp\0108\index&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引库还可以存放到内存中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Directory directory = new RAMDirectory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个标准分析器&lt;/span&gt;
        Analyzer analyzer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardAnalyzer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexwriterCofig对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二根参数：分析器对象&lt;/span&gt;
        IndexWriterConfig config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriterConfig(Version.LATEST, analyzer);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexwriter对象&lt;/span&gt;
        IndexWriter indexWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriter(directory, config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始文档的路径D:\传智播客\01.课程\04.lucene\01.参考资料\searchsource&lt;/span&gt;
        File dir = &lt;span&gt;new&lt;/span&gt; File(&quot;D:\\传智播客\\01.课程\\04.lucene\\01.参考资料\\searchsource&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File f : dir.listFiles()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件名&lt;/span&gt;
            String fileName =&lt;span&gt; f.getName();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件内容&lt;/span&gt;
            String fileContent =&lt;span&gt; FileUtils.readFileToString(f);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;
            String filePath =&lt;span&gt; f.getPath();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件的大小&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; fileSize  =&lt;span&gt; FileUtils.sizeOf(f);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文件名域
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数：域的名称
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数：域的内容
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三个参数：是否存储&lt;/span&gt;
            Field fileNameField = &lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;&lt;span&gt;, fileName, Store.YES);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件内容域&lt;/span&gt;
            Field fileContentField = &lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;&lt;span&gt;, fileContent, Store.YES);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径域（不分析、不索引、只存储）&lt;/span&gt;
            Field filePathField = &lt;span&gt;new&lt;/span&gt; StoredField(&quot;path&quot;&lt;span&gt;, filePath);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件大小域&lt;/span&gt;
            Field fileSizeField = &lt;span&gt;new&lt;/span&gt; LongField(&quot;size&quot;&lt;span&gt;, fileSize, Store.YES);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建document对象&lt;/span&gt;
            Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            document.add(fileNameField);
            document.add(fileContentField);
            document.add(filePathField);
            document.add(fileSizeField);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建索引，并写入索引库&lt;/span&gt;
&lt;span&gt;            indexWriter.addDocument(document);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;br/&gt;6.4. &lt;/span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;Luke&lt;span&gt;工具查看索引文件&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214024901-335546746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;7.1. &lt;strong&gt;实现步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：创建一个&lt;/span&gt;Directory&lt;span&gt;对象，也就是索引库存放的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;indexReader&lt;span&gt;对象，需要指定&lt;/span&gt;&lt;span&gt;Directory&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：创建一个&lt;/span&gt;indexsearcher&lt;span&gt;对象，需要指定&lt;/span&gt;&lt;span&gt;IndexReader&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：创建一个&lt;/span&gt;TermQuery&lt;span&gt;对象，指定查询的域和查询的关键词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第五步：执行查询。&lt;/p&gt;
&lt;p&gt;第六步：返回查询结果。遍历查询结果并输出。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七步：关闭&lt;/span&gt;IndexReader&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;7.2. &lt;strong&gt;IndexSearcher&lt;span&gt;搜索方法&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot;&gt;
&lt;p align=&quot;center&quot;&gt;方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;indexSearcher.search(query, n)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;indexSearcher.search(query, filter, n)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加过滤策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;indexSearcher.search(query, n, sort)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加排序策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;358&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;indexSearcher.search(booleanQuery, filter, n, sort)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;362&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;搜索，添加过滤策略，添加排序策略，返回评分最高的&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;条记录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;7.3. &lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询索引库&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; searchIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定索引库存放的路径
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;D:\temp\0108\index&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexReader对象&lt;/span&gt;
        IndexReader indexReader =&lt;span&gt; DirectoryReader.open(directory);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建indexsearcher对象&lt;/span&gt;
        IndexSearcher indexSearcher = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexSearcher(indexReader);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是查询对象，第二个参数是查询结果返回的最大值&lt;/span&gt;
        TopDocs topDocs = indexSearcher.search(query, 10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询结果的总条数&lt;/span&gt;
        System.out.println(&quot;查询结果的总条数：&quot;+&lt;span&gt; topDocs.totalHits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历查询结果
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;topDocs.scoreDocs存储了document对象的id&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ScoreDoc scoreDoc : topDocs.scoreDocs) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;scoreDoc.doc属性就是document对象的id
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据document的id找到document对象&lt;/span&gt;
            Document document =&lt;span&gt; indexSearcher.doc(scoreDoc.doc);
            System.out.println(document.get(&lt;/span&gt;&quot;filename&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(document.get(&quot;content&quot;));&lt;/span&gt;
            System.out.println(document.get(&quot;path&quot;&lt;span&gt;));
            System.out.println(document.get(&lt;/span&gt;&quot;size&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexreader对象&lt;/span&gt;
&lt;span&gt;        indexReader.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;7.4. &lt;strong&gt;TopDocs&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Lucene&lt;span&gt;搜索结果可通过&lt;/span&gt;&lt;span&gt;TopDocs&lt;/span&gt;&lt;span&gt;遍历，&lt;/span&gt;&lt;span&gt;TopDocs&lt;/span&gt;&lt;span&gt;类提供了少量的属性，如下：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p align=&quot;center&quot;&gt;方法或属性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot;&gt;
&lt;p align=&quot;center&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p&gt;totalHits&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;匹配搜索条件的总记录数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p&gt;scoreDocs&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;393&quot;&gt;
&lt;p&gt;顶部匹配记录&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;Search&lt;span&gt;方法需要指定匹配记录数量&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;indexSearcher.search(query, n)&lt;/p&gt;
&lt;p&gt;TopDocs.totalHits：是匹配索引库中所有记录的数量&lt;/p&gt;
&lt;p&gt;TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search&lt;span&gt;方法指定的参数&lt;/span&gt;n&lt;/p&gt;


&lt;h2&gt;8.1. &lt;strong&gt;&lt;span&gt;分析器（&lt;/span&gt;Analyzer&lt;span&gt;）的执行过程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如下图是语汇单元的生成过程：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214103187-1369029134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;从一个&lt;/span&gt;Reader&lt;span&gt;字符流开始，创建一个基于&lt;/span&gt;&lt;span&gt;Reader&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Tokenizer&lt;/span&gt;&lt;span&gt;分词器，经过三个&lt;/span&gt;&lt;span&gt;TokenFilter&lt;/span&gt;&lt;span&gt;生成语汇单元&lt;/span&gt;&lt;span&gt;Tokens&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要看分析器的分析效果，只需要看&lt;/span&gt;Tokenstream&lt;span&gt;中的内容就可以了。每个分析器都有一个方法&lt;/span&gt;&lt;span&gt;tokenStream&lt;/span&gt;&lt;span&gt;，返回一个&lt;/span&gt;&lt;span&gt;tokenStream&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;8.2. &lt;strong&gt;分析器的分词效果&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看标准分析器的分词效果&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTokenStream() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个标准分析器对象&lt;/span&gt;
        Analyzer analyzer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardAnalyzer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得tokenStream对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数：域名，可以随便给一个
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数：要分析的文本内容&lt;/span&gt;
        TokenStream tokenStream = analyzer.tokenStream(&quot;test&quot;, &quot;The Spring Framework provides a comprehensive programming and configuration model.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个引用，可以获得每个关键词&lt;/span&gt;
        CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个偏移量的引用，记录了关键词的开始位置以及结束位置&lt;/span&gt;
        OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将指针调整到列表的头部&lt;/span&gt;
&lt;span&gt;        tokenStream.reset();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历关键词列表，通过incrementToken方法判断列表是否结束&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(tokenStream.incrementToken()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键词的起始位置&lt;/span&gt;
            System.out.println(&quot;start-&amp;gt;&quot; +&lt;span&gt; offsetAttribute.startOffset());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取关键词&lt;/span&gt;
&lt;span&gt;            System.out.println(charTermAttribute);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束位置&lt;/span&gt;
            System.out.println(&quot;end-&amp;gt;&quot; +&lt;span&gt; offsetAttribute.endOffset());
        }
        tokenStream.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;8.3. &lt;/span&gt;&lt;strong&gt;中文分析器&lt;/strong&gt; &lt;/p&gt;
&lt;h3&gt;8.3.1. &lt;strong&gt;Lucene&lt;span&gt;自带中文分词器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;18&quot;&gt;l StandardAnalyzer：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单字分词：就是按照中文一个字一个字地进行分词。如：&lt;/span&gt;“我爱中国”&lt;span&gt;，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;效果：&lt;/span&gt;“&lt;span&gt;我&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;爱”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;国&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;l CJKAnalyzer&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二分法分词：按两个字进行切分。如：&lt;/span&gt;“&lt;span&gt;我&lt;/span&gt;是&lt;span&gt;中国人&lt;/span&gt;”&lt;span&gt;，效果：&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;我&lt;/span&gt;是”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;是&lt;span&gt;中&lt;/span&gt;”&lt;span&gt;、&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;“国人”&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上边两个分词器无法满足需求。&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;l SmartChineseAnalyzer&lt;/p&gt;
&lt;p class=&quot;18&quot;&gt;对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理&lt;/p&gt;
&lt;h3&gt;8.3.2. &lt;strong&gt;第三方中文分析器&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;paoding： 庖丁解牛最新版在 &lt;a href=&quot;https://code.google.com/p/paoding/&quot;&gt;&lt;span&gt;https://code.google.com/p/paoding/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;中最多支持&lt;/span&gt;Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。&lt;/li&gt;
&lt;li&gt;mmseg4j：最新版已从 &lt;a href=&quot;https://code.google.com/p/mmseg4j/&quot;&gt;&lt;span&gt;https://code.google.com/p/mmseg4j/&lt;/span&gt;&lt;/a&gt; 移至 &lt;a href=&quot;https://github.com/chenlb/mmseg4j-solr&quot;&gt;&lt;span&gt;https://github.com/chenlb/mmseg4j-solr&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，支持&lt;/span&gt;Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了mmseg算法。&lt;/li&gt;
&lt;li&gt;IK-analyzer： 最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。&lt;/li&gt;
&lt;li&gt;ansj_seg：最新版本在 &lt;a href=&quot;https://github.com/NLPchina/ansj_seg&quot;&gt;&lt;span&gt;https://github.com/NLPchina/ansj_seg&lt;/span&gt;&lt;/a&gt; tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。&lt;/li&gt;
&lt;li&gt;imdict-chinese-analyzer：最新版在 &lt;a href=&quot;https://code.google.com/p/imdict-chinese-analyzer/&quot;&gt;&lt;span&gt;https://code.google.com/p/imdict-chinese-analyzer/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;，&lt;/span&gt; &lt;span&gt;最新更新也在&lt;/span&gt;2009年5月，下载源码，不支持Lucene 4.10 。是利用HMM（隐马尔科夫链）算法。&lt;/li&gt;
&lt;li&gt;Jcseg：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用mmseg算法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;8.3.3. &lt;strong&gt;IKAnalyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214236624-1982051588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：把&lt;/span&gt;jar&lt;span&gt;包添加到工程中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：把配置文件和扩展词典和停用词词典添加到&lt;/span&gt;classpath&lt;span&gt;下&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注&lt;span&gt;意：&lt;/span&gt;mydict.dic&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ext_stopword.dic&lt;/span&gt;&lt;span&gt;文件的格式为&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;，注意是&lt;/span&gt;&lt;span&gt;无&lt;/span&gt;BOM &lt;span&gt;的&lt;/span&gt;UTF-8 &lt;span&gt;编码&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;使用EditPlus.exe&lt;span&gt;保存为&lt;/span&gt;&lt;span&gt;无&lt;/span&gt;BOM &lt;span&gt;的&lt;/span&gt;&lt;span&gt;UTF-8 &lt;/span&gt;&lt;span&gt;编码&lt;/span&gt;格式，如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214242907-2011219071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;8.4. &lt;strong&gt;Analyzer&lt;span&gt;使用时机&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;8.4.1. &lt;strong&gt;&lt;span&gt;索引时使用&lt;/span&gt;Analyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;输入关键字进行搜索，当需要让该关键字与文档域内容所包含的词进行匹配时需要对文档域内容进行分析，需要经过Analyzer&lt;span&gt;分析器处理生成语汇单元（&lt;/span&gt;Token&lt;span&gt;）。分析器分析的对象是文档中的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域。当&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的属性&lt;/span&gt;tokenized&lt;span&gt;（是否分词）为&lt;/span&gt;true&lt;span&gt;时会对&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;值进行分析，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214249779-1867569561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一些&lt;/span&gt;Field&lt;span&gt;可以不用分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、不作为查询条件的内容，比如文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、不是匹配内容中的词而匹配&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的整体内容，比如订单号、身份证号等。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.4.2. &lt;strong&gt;&lt;span&gt;搜索时使用&lt;/span&gt;Analyzer&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对搜索关键字进行分析和索引分析一样，使用&lt;/span&gt;Analyzer&lt;span&gt;对搜索关键字进行分析、分词处理，使用分析后每个词语进行搜索。比如：搜索关键字：&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;pring web &lt;span&gt;，经过分析器进行分词，得出：&lt;/span&gt;spring  web&lt;span&gt;拿词去索引词典表查找&lt;/span&gt; &lt;span&gt;，找到索引链接到&lt;/span&gt;Document&lt;span&gt;，解析&lt;/span&gt;&lt;span&gt;Document&lt;/span&gt;&lt;span&gt;内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于匹配整体&lt;/span&gt;Field&lt;span&gt;域的查询可以在搜索时不分析，比如根据订单号、身份证号查询等。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：搜索使用的分析器要和索引使用的分析器一致。&lt;/strong&gt;&lt;/p&gt;


&lt;h2&gt;9.1. &lt;strong&gt;索引库的添加&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;9.1.1. &lt;strong&gt;步骤&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;向索引库中添加&lt;/span&gt;document&lt;span&gt;对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：先创建一个&lt;/span&gt;indexwriter&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：创建一个&lt;/span&gt;document&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：把&lt;/span&gt;document&lt;span&gt;对象写入索引库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：关闭&lt;/span&gt;indexwriter&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;9.1.2. &lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addDocument() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引库存放路径&lt;/span&gt;
        Directory directory = FSDirectory.open(&lt;span&gt;new&lt;/span&gt; File(&quot;D:\\temp\\0108\\index&quot;&lt;span&gt;));
        
        IndexWriterConfig config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IndexWriterConfig(Version.LATEST, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个indexwriter对象&lt;/span&gt;
        IndexWriter indexWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexWriter(directory, config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Document对象&lt;/span&gt;
        Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向document对象中添加域。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不同的document可以有不同的域，同一个document可以有相同的域。&lt;/span&gt;
        document.add(&lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;, &quot;新添加的文档&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;新添加的文档的内容&quot;&lt;span&gt;, Store.NO));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;新添加的文档的内容第二个content&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content1&quot;, &quot;新添加的文档的内容要能看到&quot;&lt;span&gt;, Store.YES));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加文档到索引库&lt;/span&gt;
&lt;span&gt;        indexWriter.addDocument(document);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;9.2. &lt;/span&gt;&lt;strong&gt;索引库删除&lt;/strong&gt; &lt;/p&gt;
&lt;h3&gt;9.2.1. &lt;strong&gt;删除全部&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除全部索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAllIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除全部索引&lt;/span&gt;
&lt;span&gt;        indexWriter.deleteAll();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。 &lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;此方法慎用！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;9.2.2. &lt;strong&gt;指定查询条件删除&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据查询条件删除索引&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteIndexByQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个查询条件&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据查询条件删除&lt;/span&gt;
&lt;span&gt;        indexWriter.deleteDocuments(query);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexwriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;9.3. &lt;/span&gt;&lt;strong&gt;索引库的修改&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;原理就是先删除后添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改索引库&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateIndex() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexWriter indexWriter &lt;/span&gt;=&lt;span&gt; getIndexWriter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Document对象&lt;/span&gt;
        Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向document对象中添加域。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不同的document可以有不同的域，同一个document可以有相同的域。&lt;/span&gt;
        document.add(&lt;span&gt;new&lt;/span&gt; TextField(&quot;filename&quot;, &quot;要更新的文档&quot;&lt;span&gt;, Store.YES));
        document.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TextField(&quot;content&quot;, &quot;2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。&quot;&lt;span&gt;, Store.YES));
        indexWriter.updateDocument(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;java&quot;&lt;span&gt;), document);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexWriter&lt;/span&gt;
&lt;span&gt;        indexWriter.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10. &lt;/span&gt;&lt;strong&gt;Lucene&lt;span&gt;索引库查询（重点）&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;对要搜索的信息创建Query&lt;span&gt;查询对象，&lt;/span&gt;Lucene&lt;span&gt;会根据&lt;/span&gt;Query&lt;span&gt;查询对象生成最终的查询语法，类似关系数据库&lt;/span&gt;Sql&lt;span&gt;语法一样&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;也有自己的查询语法，比如：“&lt;/span&gt;&lt;span&gt;name:lucene&lt;/span&gt;&lt;span&gt;”表示查询&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;为“&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;”的文档信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可通过两种方法创建查询对象：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;Lucene&lt;/span&gt;&lt;span&gt;提供&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Query&lt;span&gt;是一个抽象类，&lt;/span&gt;&lt;span&gt;lucene&lt;/span&gt;&lt;span&gt;提供了很多查询对象，比如&lt;/span&gt;&lt;span&gt;TermQuery&lt;/span&gt;&lt;span&gt;项精确查询，&lt;/span&gt;&lt;span&gt;NumericRangeQuery&lt;/span&gt;&lt;span&gt;数字范围查询等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;name&quot;, &quot;lucene&quot;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;QueryParse&lt;/span&gt;&lt;span&gt;解析查询表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;QueryParse&lt;span&gt;会将用户输入的查询表达式解析成&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    QueryParser queryParser = &lt;span&gt;new&lt;/span&gt; QueryParser(&quot;name&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;name:lucene&quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;10.1. &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;query&lt;span&gt;的子类查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;10.1.1. &lt;strong&gt;MatchAllDocsQuery&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用MatchAllDocsQuery查询索引目录中的所有文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMatchAllDocsQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询条件&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MatchAllDocsQuery();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.2. &lt;/span&gt;&lt;strong&gt;TermQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;TermQuery&lt;span&gt;，通过项查询，&lt;/span&gt;&lt;span&gt;TermQuery&lt;/span&gt;&lt;span&gt;不使用分析器所以建议匹配不分词的&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt;域查询，比如订单号、分类&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;号等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;指定要查询的域和要查询的关键词。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Termquery查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testTermQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询对象&lt;/span&gt;
        Query query = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;lucene&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
        TopDocs topDocs = indexSearcher.search(query, 10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共查询到的document个数&lt;/span&gt;
        System.out.println(&quot;查询结果总数量：&quot; +&lt;span&gt; topDocs.totalHits);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历查询结果&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ScoreDoc scoreDoc : topDocs.scoreDocs) {
            Document document &lt;/span&gt;=&lt;span&gt; indexSearcher.doc(scoreDoc.doc);
            System.out.println(document.get(&lt;/span&gt;&quot;filename&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(document.get(&quot;content&quot;));&lt;/span&gt;
            System.out.println(document.get(&quot;path&quot;&lt;span&gt;));
            System.out.println(document.get(&lt;/span&gt;&quot;size&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭indexreader&lt;/span&gt;
&lt;span&gt;        indexSearcher.getIndexReader().close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.3. &lt;/span&gt;&lt;strong&gt;NumericRangeQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可以根据数值范围查询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数值范围查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testNumericRangeQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建查询
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数：
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.域名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.最小值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最大值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.是否包含最小值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.是否包含最大值&lt;/span&gt;
        Query query = NumericRangeQuery.newLongRange(&quot;size&quot;, 1l, 1000l, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;10.1.4. &lt;/span&gt;&lt;strong&gt;BooleanQuery&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可以组合查询条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合条件查询&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testBooleanQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个布尔查询对象&lt;/span&gt;
        BooleanQuery query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BooleanQuery();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个查询条件&lt;/span&gt;
        Query query1 = &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;filename&quot;, &quot;apache&quot;&lt;span&gt;));
        Query query2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TermQuery(&lt;span&gt;new&lt;/span&gt; Term(&quot;content&quot;, &quot;apache&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合查询条件&lt;/span&gt;
&lt;span&gt;        query.add(query1, Occur.MUST);
        query.add(query2, Occur.MUST);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Occur.MUST&lt;span&gt;：必须满足此条件，相当于&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Occur.SHOULD&lt;span&gt;：应该满足，但是不满足也可以，相当于&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Occur.MUST_NOT&lt;span&gt;：必须不满足。相当于&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;10.2. &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;queryparser&lt;span&gt;查询&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过&lt;/span&gt;QueryParser&lt;span&gt;也可以创建&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;QueryParser&lt;/span&gt;&lt;span&gt;提供一个&lt;/span&gt;&lt;span&gt;Parse&lt;/span&gt;&lt;span&gt;方法，此方法可以直接根据查询语法来查询。&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;对象执行的查询语法可通过&lt;/span&gt;System.out.println(query);&lt;span&gt;查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。&lt;/p&gt;

&lt;h3&gt;10.2.1. &lt;strong&gt;QueryParser&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;需要加入&lt;/span&gt;queryParser&lt;span&gt;依赖的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201807/1135185-20180714214519545-293585767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;1.1.1.1 &lt;strong&gt;程序实现&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testQueryParser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建queryparser对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数默认搜索的域
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数就是分析器对象&lt;/span&gt;
        QueryParser queryParser = &lt;span&gt;new&lt;/span&gt; QueryParser(&quot;content&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;Lucene是java开发的&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;1.1.1.2 &lt;/span&gt;&lt;strong&gt;查询语法&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、基础的查询语法，关键词查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;域名&lt;/span&gt;+&lt;span&gt;“：”&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;搜索的关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;content:java&lt;/p&gt;
&lt;p&gt;2、范围查询&lt;/p&gt;
&lt;p&gt;&lt;span&gt;域名&lt;/span&gt;+&lt;span&gt;“&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;+[&lt;/span&gt;&lt;span&gt;最小值&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;最大值&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;size:[1 TO 1000]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围查询在&lt;/span&gt;lucene&lt;span&gt;中支持数值类型，不支持字符串类型。在&lt;/span&gt;&lt;span&gt;solr&lt;/span&gt;&lt;span&gt;中支持字符串类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、组合条件查询&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1 +&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：两个条件之间是并且的关系&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;+filename:apache +content:apache&lt;/p&gt;
&lt;p&gt;2）+&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：必须满足第一个条件，应该满足第二个条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;+filename:apache content:apache&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;条件&lt;/span&gt;1 &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：两个条件满足其一即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;filename:apache content:apache&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：必须不满足条件&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，要满足条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;-filename:apache content:apache&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.MUST 查询条件必须满足，相当于and&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;+&lt;span&gt;（加号）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.SHOULD 查询条件可选，相当于or&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;空（不用符号）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;411&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Occur.MUST_NOT 查询条件不能满足，相当于not非&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;214&quot;&gt;
&lt;p&gt;-&lt;span&gt;（减号）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;第二种写法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 AND &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 OR &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;条件&lt;/span&gt;1 NOT &lt;span&gt;条件&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;10.2.2. &lt;strong&gt;MultiFieldQueryParser&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可以指定多个默认搜索域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMultiFiledQueryParser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        IndexSearcher indexSearcher &lt;/span&gt;=&lt;span&gt; getIndexSearcher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以指定默认搜索的域是多个&lt;/span&gt;
        String[] fields = {&quot;filename&quot;, &quot;content&quot;&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个MulitFiledQueryParser对象&lt;/span&gt;
        MultiFieldQueryParser queryParser = &lt;span&gt;new&lt;/span&gt; MultiFieldQueryParser(fields, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IKAnalyzer());
        Query query &lt;/span&gt;= queryParser.parse(&quot;java AND apache&quot;&lt;span&gt;);
        System.out.println(query);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行查询&lt;/span&gt;
&lt;span&gt;        printResult(query, indexSearcher);
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  &lt;/p&gt;

</description>
<pubDate>Sat, 14 Jul 2018 13:47:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9311066.html</dc:identifier>
</item>
<item>
<title>Python之Django基本命令 - baishuchao</title>
<link>http://www.cnblogs.com/baishuchao/p/9311042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baishuchao/p/9311042.html</guid>
<description>&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$django-admin.py  startproject  project_name 

# 特别是在 windows 上，如果报错，尝试用 django-admin 代替 django-admin.py 试试&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 project_name 是自己的项目名称，需要为合法的 Python 包名，如不能为 1a 或 a-b。&lt;/p&gt;

&lt;p&gt;要先进入项目目录下，cd project_name 然后执行下面的命令；&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$ python manage.py startapp app_name
或 django-admin.py startapp app_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般一个项目有多个app，当然通用的app也可以在多个项目中使用。&lt;br/&gt;与项目名类似app name也需要为合法的Python 包名，如blog,news,aboutus等都是合法的app名称；&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Django 1.7.1及以上 用以下命令
# 1. 创建更改的文件
$python manage.py makemigrations
# 2. 将生成的py文件应用到数据库
$python manage.py migrate
 
 
旧版本的Django 1.6及以下用
$python manage.py syncdb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可以在SQL等数据库中创建与models.py代码对应的表，不需要自己手动执行SQL&lt;/p&gt;

&lt;p&gt;开发服务器，即开发时使用，一般修改代码后会自动重启，方便调试和开发，但是由于性能问题，建议只用来测试，不要用在生产环境。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$python manage.py runserver
 
# 当提示端口被占用的时候，可以用其它端口：
$python manage.py runserver 8001
$python manage.py runserver 9999
（当然也可以kill掉占用端口的进程，具体后面有讲，此处想知道的同学可查下 lsof 命令用法）
 
# 监听机器所有可用 ip （电脑可能有多个内网ip或多个外网ip）
$python manage.py runserver 0.0.0.0:8000
# 如果是外网或者局域网电脑上可以用其它电脑查看开发服务器
# 访问对应的 ip加端口，比如 http://172.16.20.2:8000&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;$python manage.py flush&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此命令会询问是yes or no，选择yes会把数据全部清空掉，只留下空表&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$python manage.py createsuperuser

# 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名密码必填

# 修改 用户密码可以用：
$python manage.py changepassword username&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;$python manage.py dumpdata appname &amp;gt; appname.json
$python manage.py loaddata appname.json&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;$python manage.py shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你安装了 bpython 或 ipython 会自动用它们的界面，推荐安装 bpython。&lt;/p&gt;
&lt;p&gt;这个命令和 直接运行 python 或 bpython 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;$python manage.py dbshell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。&lt;/p&gt;
&lt;p&gt;在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;➜  mysite python3.6 manage.py

Type 'manage.py help &amp;lt;subcommand&amp;gt;' for help on a specific subcommand.

Available subcommands:

[auth]
    changepassword
    createsuperuser

[contenttypes]
    remove_stale_contenttypes

[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    dumpdata
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    sendtestemail
    shell
    showmigrations
    sqlflush
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    test
    testserver

[sessions]
    clearsessions

[staticfiles]
    collectstatic
    findstatic
    runserver&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 14 Jul 2018 13:39:00 +0000</pubDate>
<dc:creator>baishuchao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baishuchao/p/9311042.html</dc:identifier>
</item>
<item>
<title>Java异常实践事项 - BlueWolfThe</title>
<link>http://www.cnblogs.com/achievement-active/p/9310975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/achievement-active/p/9310975.html</guid>
<description>&lt;p&gt;     &lt;span&gt;在大学项目开发中, 你有没发现自己做的项目总是出现bug,不仅仅出现bug，而且很难根据异常信息找到异常源。我当时也是非常懊恼, 可怕的是不知道怎么维护... 软件Java异常需要理解基础的知识, 在实战中较好的处理异常。&lt;a title=&quot;Java异常基础知识&quot; href=&quot;https://www.cnblogs.com/achievement-active/p/9304293.html&quot; target=&quot;_blank&quot;&gt;Java异常基础知识&lt;/a&gt; 、&lt;a title=&quot;tryCatchFinally代码块细节&quot; href=&quot;https://www.cnblogs.com/achievement-active/p/9308522.html&quot; target=&quot;_blank&quot;&gt;tryCatchFinally语句块&lt;/a&gt;  本节总结Java异常在实践中的相关事项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、 在Finally中清理资源或者使用Try-With-Resource语句&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt; &lt;/span&gt; &lt;span&gt;  &lt;span&gt;不要在try中关闭资源、因为一旦发生异常, 将无法正常关闭资源。以下代码给出二种处理方案, Finally关闭资源、Try-With-Resource（JDK1.7出现）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 写数据
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeFile(File file) {
        OutputStream os&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
             os&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(file);
             String str&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;hello gay!&quot;&lt;span&gt;);
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     os.write(str); 不编码--错误&lt;/span&gt;
             os.write(str.getBytes());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照默认的GBK编码&lt;/span&gt;
             os.write(5&lt;span&gt;);
             os.flush();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            os.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 写数据
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeFile(File file) {

               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它将在try被执行后自动关闭，或者处理一个异常。&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;(OutputStream os=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(file)) {
             String str&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; String(&quot;hello gay!&quot;&lt;span&gt;);
                   os.write(str.getBytes());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照默认的GBK编码&lt;/span&gt;
             os.write(5&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            
        }
        
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、 给出准确的异常处理信息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;     &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;尽量能更好地描述你的异常处理信息，比如用 NumberFormatException 代替 IllegalArgumentException ，避免抛出一个不具体的异常。catch语句块中子类在前、父类在后。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doNotDoThis() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
   }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doThis() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NumberFormatException {
  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、记录自定义异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;   为了给调用人员和维护者更清晰的异常信息、请确保在Javadoc中添加一个@throws 声明，并描述可能导致的异常情况&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * This method does something extremely useful ...
 * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; MyBusinessException if ... happens
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doSome() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; MyBusinessException {
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、记录异常信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      用1-2个简短的句子解释异常的原因、使用日志文件记录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Long(&quot;abc&quot;&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e) {
    log.error(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Exception(&quot;xxx&quot;&lt;span&gt;,e));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、最先捕获特定的异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;       &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  把特点的、已知的异常先捕获。&lt;/span&gt;&lt;span&gt;&lt;span&gt;catch块中只有第一个匹配到异常的catch语句才会被执行，所以，如果你最先发现IllegalArgumentException，你将永远不会到达catch里处理更具体的NumberFormatException，因为它是IllegalArgumentException的一个子类。&lt;/span&gt;&lt;span&gt;所以要首先捕获特定的异常类，并在末尾添加一些处理不是很具体异常的catch语句。&lt;strong&gt;子类应该在前面、父类在后面。最后一个catch可以写Exception。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; catchMostSpecificExceptionFirst() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        doSomething(&lt;/span&gt;&quot;A message&quot;&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e) {
        log.error(e);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalArgumentException e) {
        log.error(e)
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Exception捕获不确定的、模糊的异常&lt;/span&gt;
&lt;span&gt;      log.error(e);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 不要在catch中使用Throwable&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;因为所有的Exception（包括Error）都是Throwtable的子类。Error是JVM异常,我们无法预计和修改。Throwable也不够仔细。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doNotCatchThrowable() {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something&lt;/span&gt;
    } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't do this!&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、不要捕获和抛出异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;或许这样看起来很nice，当它发生时记录一个异常，然后重新抛出它，以便调用者能够适当地处理它。但是这样会同时打印日志信息和异常信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果你需要添加额外的信息，应该捕获异常并将其包装在一个自定义的信息中。但要确保遵循下面的第8条异常链化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Long(&quot;xyz&quot;&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e) {
    log.error(e);
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: &quot;xyz&quot;&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;main&quot; java.lang.NumberFormatException: For input string: &quot;xyz&quot;&lt;span&gt;
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:&lt;/span&gt;65&lt;span&gt;)
at java.lang.Long.parseLong(Long.java:&lt;/span&gt;589&lt;span&gt;)
at java.lang.Long.(Long.java:&lt;/span&gt;965&lt;span&gt;)
at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:&lt;/span&gt;63&lt;span&gt;)
at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:&lt;/span&gt;58)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;可能这样说不太清楚,举个例子假如main调用B函数、在B中调用A函数、A中发生异常, 而我们把异常交给调用者处理（main中）;应该这样:A中抛出异常、B链化抛出、main中捕获并且处理、记录。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
{
    
    System.out.println(&lt;/span&gt;&quot;请输入2个加数&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        result &lt;/span&gt;=&lt;span&gt; add();
        System.out.println(&lt;/span&gt;&quot;结果:&quot;+&lt;span&gt;result);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、记录&lt;/span&gt;
&lt;span&gt;     log.error(e);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、处理，比如打印;&lt;/span&gt;
&lt;span&gt;        e.printStackTrace();
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输入的2个整数返回&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; getInputNumbers()
{
    List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    Scanner scan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num1 =&lt;span&gt; scan.nextInt();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num2 =&lt;span&gt; scan.nextInt();
        nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num1));
        nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num2));
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; immExp;
    }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        scan.close();
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nums;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行加法计算&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums =&lt;span&gt;getInputNumbers();
        result &lt;/span&gt;= nums.get(0)  + nums.get(1&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;计算失败&quot;,immExp);  &lt;span&gt;////////////////////////////&lt;/span&gt;&lt;span&gt;/链化:以一个异常对象为参数构造新的异常对象。&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;8 、链化--包装异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;   &lt;span&gt;异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
{
    
    System.out.println(&lt;/span&gt;&quot;请输入2个加数&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        result &lt;/span&gt;=&lt;span&gt; add();
        System.out.println(&lt;/span&gt;&quot;结果:&quot;+&lt;span&gt;result);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
        e.printStackTrace();
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输入的2个整数返回&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; getInputNumbers()
{
    List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    Scanner scan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num1 =&lt;span&gt; scan.nextInt();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num2 =&lt;span&gt; scan.nextInt();
        nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num1));
        nums.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(num2));
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; immExp;
    }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        scan.close();
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nums;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行加法计算&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums =&lt;span&gt;getInputNumbers();
        result &lt;/span&gt;= nums.get(0)  + nums.get(1&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InputMismatchException immExp){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;计算失败&quot;,immExp);  &lt;span&gt;////////////////////////////&lt;/span&gt;&lt;span&gt;/链化:以一个异常对象为参数构造新的异常对象。&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  result;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
请输入2个加数
r 1
java.lang.Exception: 计算失败
    at practise.ExceptionTest.add(ExceptionTest.java:53)
    at practise.ExceptionTest.main(ExceptionTest.java:18)
Caused by: java.util.InputMismatchException
    at java.util.Scanner.throwFor(Scanner.java:864)
    at java.util.Scanner.next(Scanner.java:1485)
    at java.util.Scanner.nextInt(Scanner.java:2117)
    at java.util.Scanner.nextInt(Scanner.java:2076)
    at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)
    at practise.ExceptionTest.add(ExceptionTest.java:48)
    ... 1 more

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;附加: finally块的细节&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不要在fianlly中使用return。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不要在finally中抛出异常。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将尽量将所有的return写在函数的最后面，而不是try ... catch ... finally中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 14 Jul 2018 13:04:00 +0000</pubDate>
<dc:creator>BlueWolfThe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/achievement-active/p/9310975.html</dc:identifier>
</item>
<item>
<title>Java迭代器升级版探究 - Phpythoner</title>
<link>http://www.cnblogs.com/binroad/p/9310917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binroad/p/9310917.html</guid>
<description>&lt;p&gt;Alei最近和迭代器较上了劲，之前自以为深究过迭代器，不成想原来是坐井观天，以蠡测海。上文中写的东西哪里算什么深入探究？！但亡羊补牢，犹未迟也，经我多次试验，终于弄懂其中某些精巧机制，闲话少说，我们进入正题。&lt;/p&gt;
&lt;p&gt;注意，之后所有的知识点都以 ArrayList 这个容器类为例来进行详细说明&lt;/p&gt;
&lt;p&gt;在讨论这个问题之前我们得首先在意两个成员变量：&lt;/p&gt;
&lt;p&gt;1、ArrayList 类里继承于 AbstractList 类的成员变量 modCount：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、ArrayList 类的私有内部类 Itr 里的成员变量 expectedModCount：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; expectedModCount = modCount;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看下Itr类源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cursor;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of next element to return&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; lastRet = -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index of last element returned; -1 if no such&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
    }

    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
        checkForComodification();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        cursor &lt;/span&gt;= i + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
        checkForComodification();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ArrayList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
            cursor &lt;/span&gt;=&lt;span&gt; lastRet;
            lastRet &lt;/span&gt;= -1&lt;span&gt;;
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; consumer) {
        Objects.requireNonNull(consumer);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object[] elementData = ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i != size &amp;amp;&amp;amp; modCount ==&lt;span&gt; expectedModCount) {
            consumer.accept((E) elementData[i&lt;/span&gt;++&lt;span&gt;]);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; update once at end of iteration to reduce heap write traffic&lt;/span&gt;
        cursor =&lt;span&gt; i;
        lastRet &lt;/span&gt;= i - 1&lt;span&gt;;
        checkForComodification();
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们使用 ArrayList 容器的 iterator() 方法后，在栈空间里创建了一个此类特定的迭代器对象，同时将成员变量 modCount 的值赋予成员变量 expectedModCount。知道这个有趣的事情后可以先打住，让我们再来看看 ArrayList 类 remove() 方法的源码：&lt;/p&gt;
&lt;p&gt;参数为 int 类型的 remove()：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    rangeCheck(index);

    modCount&lt;/span&gt;++&lt;span&gt;;
    E oldValue &lt;/span&gt;=&lt;span&gt; elementData(index);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numMoved = size - index - 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
        System.arraycopy(elementData, index&lt;/span&gt;+1&lt;span&gt;, elementData, index,
                         numMoved);
    elementData[&lt;/span&gt;--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear to let GC do its work&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数为 Object 类型的 remove()：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elementData[index] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                fastRemove(index);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(elementData[index])) {
                fastRemove(index);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Private remove method that skips bounds checking and does not
 * return the value removed.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fastRemove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    modCount&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numMoved = size - index - 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
        System.arraycopy(elementData, index&lt;/span&gt;+1&lt;span&gt;, elementData, index,
                         numMoved);
    elementData[&lt;/span&gt;--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear to let GC do its work&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以 ArrayList 类里 remove() 方法为例来看，只要我们调用此方法一次，那么 modCount 便自加一次 1。于是我们可以理解，modCount 是一个记录容器对象修改次数的变量，它是一个计数器。小伙伴门完全可以去查源码，不仅仅是 remove()，凡是涉及对 ArrayList 对象的增、删、改的任何一种方法，当我们调用一次这类方法，那 modCount 便会自加一次 1，即，记录一次容器对象的改变。例如，当我创建一个 ArrayList 对象 al 后，我调用 al.add() 一次，调用 al.remove() 一次，再调用 al.add() 一次后，那么 modCount = 3，由此说明 al 被修改了3次。&lt;/p&gt;
&lt;p&gt;在没有创建迭代器对象之前的任何对容器对象的增删改操作只会让 modCount 自加，当我们创建一个对应容器类的迭代器对象之后，int expectedModCount = modCount，迭代器对象里的 expectedModCount 成员变量被初始化为与 modCount 里的数值一样的值。&lt;/p&gt;
&lt;p&gt;有了迭代器，然后用迭代器进行迭代，就涉及到迭代器对象的 hasNext()；next()方法了，我们看下这两个方法的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cursor !=&lt;span&gt; size;
}

@SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
    checkForComodification();
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cursor;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; size)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
    Object[] elementData &lt;/span&gt;= ArrayList.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elementData;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; elementData.length)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    cursor &lt;/span&gt;= i + 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E) elementData[lastRet =&lt;span&gt; i];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由此可见，两个方法都不会改变 expectedModCount 的值，那怎么理解 expectedModCount 这个成员变量呢？再看迭代器里的 remove() 方法源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastRet &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
    checkForComodification();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        ArrayList.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.remove(lastRet);
        cursor &lt;/span&gt;=&lt;span&gt; lastRet;
        lastRet &lt;/span&gt;= -1&lt;span&gt;;
        expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IndexOutOfBoundsException ex) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 remove() 方法的方法体里，有“expectedModCount = modCount; “这样一行语句，那么不管我们调用多少次迭代器的 remove() 方法，始终会让 expectedModCount 的数值等于 modCount 的值，这里的 expectedModCount 可理解为使用迭代器对容器类对象进行修改的”期望修改次数“，就是说：迭代器里的这个”期望修改次数“一定要和已经记录下的容器的修改次数 modCount 一样，那么当你通过迭代器对容器类对象遍历并进行修改时，使用迭代器本身的 remove() 才有意义（即让 expectedModCount = modCount）！！而在 next() 方法体里首行的 checkForComodification() 方法是这样定义的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看了源码，我们应该知道： checkForComodification() 的作用是检查 expectedModCount 和 modCount 的值是否相等，如果不等，则抛出 ConcurrentModificationException 这个异常。这下显而易见了，在我们通过迭代器进行遍历时，若使用非迭代器对象提供的修改容器类对象的任何方法，则 modCount 的值增大，而 expectedModCount 地值不发生改变，那么在进入下一次循环时，next() 方法体里首行的 checkForComodification() 方法检查到 expectedModCount 与 modCount 不等后抛出了 ConcurrentModificationException。&lt;/p&gt;
&lt;p&gt;那么，在通过迭代器进行迭代时，容器对象里的任何元素都不能通过容器类所提供的方法进行增删改的操作么？非也非也，Alei留下这样一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    Collection c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;aaa&quot;&lt;span&gt;));
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;bbb&quot;&lt;span&gt;));
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;ccc&quot;&lt;span&gt;));
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;ddd&quot;&lt;span&gt;));
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;fff&quot;&lt;span&gt;));
    c.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;eee&quot;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : c) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      System.out.print(o + &quot; &quot;);&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (o.equals(&quot;fff&quot;&lt;span&gt;)) {
            c.remove(o);
        }
    }
    System.out.println(c);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们运行这段程序，你将会发现 ”fff“ 这个字符串对象怎么被成功删除了？！这也是我之前一直疑惑且略显白痴的地方。其实，我可以下定结论：在通过迭代器进行迭代时，容器对象里的倒数第二个元素一定可以过容器类所提供的 remove() 方法进行删除操作（不管这个容器的 size 有多大）。这又是为什么呢？哈哈，对于这个问题，留待小伙伴们自行解决吧^_^！&lt;/p&gt;

</description>
<pubDate>Sat, 14 Jul 2018 12:40:00 +0000</pubDate>
<dc:creator>Phpythoner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/binroad/p/9310917.html</dc:identifier>
</item>
<item>
<title>【文文殿下】Manache算法-学习笔记 - 文文殿下</title>
<link>http://www.cnblogs.com/Syameimaru/p/9310883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Syameimaru/p/9310883.html</guid>
<description>&lt;p&gt;&lt;span&gt;Manache算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;定义&lt;/span&gt;：&lt;span&gt;是一个判断回文子串的算法，我们结合例题解释：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　&lt;/span&gt;&lt;/span&gt;题目：给定一个长度为 n 的字符串 S，求其最长回文子串 一个字符串是回文的，当且仅当反转后的串与原串完全相等&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;分析：&lt;/span&gt;&lt;span&gt;对于这个题目，有三种主流思路: &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　一：Hash+二分 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　计算字符串的前缀hash值&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　枚举中点，二分回文字串的长度&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　时间复杂度：$O(nlogn)$&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;span&gt;二：回文自动机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　&lt;/span&gt;&lt;span&gt;复杂度是线性的,但是编程复杂度极高，思维难度极高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　&lt;span&gt;三：Manache算法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　&lt;span&gt;复杂度是线性的，思维难度低，编程难度低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; &lt;span&gt;讲解Manache方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　对于Manache算法，我们先考虑朴素做法：枚举回文串中心，然后向两边扩展，这样的复杂度是$O(N^2)$的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　但是类比KMP算法，我们在朴素算法中，没有考虑到已经计算的部分对于之后结果的贡献，朴素方法的突破口就在这里了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　考虑优化：由于回文串长度分奇偶，有点麻烦，所以，我们考虑在每个字符中间插入一个'#'字符，来保证字符串的奇性。特别的，在字符串前两个字符，插入\$和#,对于\$的作用是：防止数组越界，既下文代码中的whie()函数，来确保其遇到字符串开头立即停止（因为对于$字符，其为唯一的，不可能有字符与其匹配）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　我们引入辅助数组$len[i]$ 来表示以$i$为中心，最大回文串的半径，显然的，对于每一个$len[i]$，$len[i]-1$就是原来回文串的长度，我们结合一个样例来说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　原字符串：$   #   A   #   B   #   A   #   A   #    B    #&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　$len$数组　 1   1   2    1   4    1   2     2   2    1   2    1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　原来的最长回文串是$3$ 也就是$len[4]-1$ （从0开始标号）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　对吧？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　接下来的问题，就是如何计算$len$数组了 ， 这确实是个问题，不过我们可以通过下面的办法解决：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　考虑$len[i]$ 以及当前求出的回文右边界$mx$ ， $id$ 是对应的回文中心，如果$i&amp;lt;mx$ 则附上初值$min{mx-i,p[j]}$,其中，$j$是$i$关于$id$的对称坐标，通过中点坐标公式，我们可以得出：$j=id*2-i$ 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　否则($i&amp;gt;=mx$)附上初值$len[i]=1$. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　然后，向两边扩展就好了。可以结合下面的图像理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439264/201807/1439264-20180714203128093-1047809008.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;151&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span&gt;　&lt;span&gt;带有下划线的部分，是已经计算得出的回文串。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5c54bfd0-5040-4c69-826f-8ad0f3438b55')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5c54bfd0-5040-4c69-826f-8ad0f3438b55&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5c54bfd0-5040-4c69-826f-8ad0f3438b55&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5c54bfd0-5040-4c69-826f-8ad0f3438b55',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5c54bfd0-5040-4c69-826f-8ad0f3438b55&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Manache() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; pos=&lt;span&gt;0&lt;/span&gt;,mx=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(register &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         len[i]=i&amp;lt;mx?min(len[(pos&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)-i],mx-i):&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(b[i-len[i]]==b[i+len[i]]) len[i]++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i+len[i]&amp;gt;mx) mx=i+len[i],pos=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Jul 2018 12:26:00 +0000</pubDate>
<dc:creator>文文殿下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Syameimaru/p/9310883.html</dc:identifier>
</item>
</channel>
</rss>