<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JAVA里自定义注解来进行数据验证 - Decouple</title>
<link>http://www.cnblogs.com/xz816111/p/9484902.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xz816111/p/9484902.html</guid>
<description>&lt;p&gt;API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。&lt;/p&gt;
&lt;p&gt;Java提供了一些基本的验证注解，比如&lt;code&gt;@NotNull&lt;/code&gt;、&lt;code&gt;@Size&lt;/code&gt;，但是更多情况下需要自定义验证逻辑，这时候就可以自己实现一个验证注解，方法很简单，仅需要两个东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个自定义的注解，并且指定验证器&lt;/li&gt;
&lt;li&gt;一个验证器的实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;section&quot;&gt;自定义验证注解&lt;/h2&gt;
&lt;p&gt;考虑有一个API，接收一个&lt;code&gt;Student&lt;/code&gt;对象，并希望对象里的&lt;code&gt;age&lt;/code&gt;域的值是奇数，这时候就可以创建以下注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = AgeValidator.class)
public @interface Odd {
    String message() default &quot;Age Must Be Odd&quot;;
    Class&amp;lt;?&amp;gt;[] groups() default {};
    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Target&lt;/code&gt;指明这个注解要作用在什么地方，可以是对象、域、构造器等，因为要作用在&lt;code&gt;age&lt;/code&gt;域上，因此这里选择&lt;code&gt;FIELD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Retention&lt;/code&gt;指明了注解的生命周期，可以有&lt;code&gt;SOURCE&lt;/code&gt;（仅保存在源码中，会被编译器丢弃），&lt;code&gt;CLASS&lt;/code&gt;（在class文件中可用，会被VM丢弃）以及&lt;code&gt;RUNTIME&lt;/code&gt;（在运行期也被保留），这里选择了生命周期最长的&lt;code&gt;RUNTIME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Constraint&lt;/code&gt;是最关键的，它表示这个注解是一个验证注解，并且指定了一个实现验证逻辑的验证器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message()&lt;/code&gt;指明了验证失败后返回的消息，此方法为&lt;code&gt;@Constraint&lt;/code&gt;要求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;groups()&lt;/code&gt;和&lt;code&gt;payload()&lt;/code&gt;也为&lt;code&gt;@Constraint&lt;/code&gt;要求，可默认为空，详细用途可以查看&lt;code&gt;@Constraint&lt;/code&gt;文档&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;section-1&quot;&gt;创建验证器&lt;/h2&gt;
&lt;p&gt;有了注解之后，就需要一个验证器来实现验证逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AgeValidator implements ConstraintValidator&amp;lt;Odd,Integer&amp;gt; {
    @Override
    public void initialize(Odd constraintAnnotation) {
    }

    @Override
    public boolean isValid(Integer age, ConstraintValidatorContext constraintValidatorContext) {
        return age % 2 != 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;验证器有两个类型参数，第一个是所属的注解，第二个是注解作用地方的类型，这里因为作用在&lt;code&gt;age&lt;/code&gt;上，因此这里用了&lt;code&gt;Integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialize()&lt;/code&gt;可以在验证开始前调用注解里的方法，从而获取到一些注解里的参数，这里用不到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isValid()&lt;/code&gt;就是判断是否合法的地方&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;section-2&quot;&gt;应用注解&lt;/h2&gt;
&lt;p&gt;注解和验证器创建好之后，就可以使用注解了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Student {
    @Odd
    private int age;
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class StudentResource {
    @PostMapping(&quot;/student&quot;)
    public String addStudent(@Valid @RequestBody Student student) {
        return &quot;Student Created&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在需要启用验证的地方加上&lt;code&gt;@Valid&lt;/code&gt;注解，这时候如果请求里的&lt;code&gt;Student&lt;/code&gt;年龄不是奇数，就会得到一个&lt;code&gt;400&lt;/code&gt;响应：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;timestamp&quot;: &quot;2018-08-15T17:01:44.598+0000&quot;,
    &quot;status&quot;: 400,
    &quot;error&quot;: &quot;Bad Request&quot;,
    &quot;errors&quot;: [
        {
            &quot;codes&quot;: [
                &quot;Odd.student.age&quot;,
                &quot;Odd.age&quot;,
                &quot;Odd.int&quot;,
                &quot;Odd&quot;
            ],
            &quot;arguments&quot;: [
                {
                    &quot;codes&quot;: [
                        &quot;student.age&quot;,
                        &quot;age&quot;
                    ],
                    &quot;arguments&quot;: null,
                    &quot;defaultMessage&quot;: &quot;age&quot;,
                    &quot;code&quot;: &quot;age&quot;
                }
            ],
            &quot;defaultMessage&quot;: &quot;Age Must Be Odd&quot;,
            &quot;objectName&quot;: &quot;student&quot;,
            &quot;field&quot;: &quot;age&quot;,
            &quot;rejectedValue&quot;: 12,
            &quot;bindingFailure&quot;: false,
            &quot;code&quot;: &quot;Odd&quot;
        }
    ],
    &quot;message&quot;: &quot;Validation failed for object='student'. Error count: 1&quot;,
    &quot;path&quot;: &quot;/student&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以手动来处理错误，加上一个&lt;code&gt;BindingResult&lt;/code&gt;来接收验证结果即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class StudentResource {
    @PostMapping(&quot;/student&quot;)
    public String addStudent(@Valid @RequestBody Student student, BindingResult validateResult) {
        if (validateResult.hasErrors()) {
            return validateResult.getAllErrors().get(0).getDefaultMessage();
        }
        return &quot;Student Created&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候如果验证出错，便只会返回一个状态为&lt;code&gt;200&lt;/code&gt;，内容为Age Must Be Odd的响应。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 17:23:00 +0000</pubDate>
<dc:creator>Decouple</dc:creator>
<og:description>API开发中经常会遇到一些对请求数据进行验证的情况，这时候如果使用注解就有两个好处，一是验证逻辑和业务逻辑分离，代码清晰，二是验证逻辑可以轻松复用，只需要在要验证的地方加上注解就可以。 Java提供了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xz816111/p/9484902.html</dc:identifier>
</item>
<item>
<title>Java LinkedHashMap类源码解析 - GrayWind</title>
<link>http://www.cnblogs.com/graywind/p/9484577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/graywind/p/9484577.html</guid>
<description>&lt;p&gt;LinkedHashMap继承了HashMap，他在HashMap的基础上增加了一个双向链表的结构，链表默认维持key插入的顺序，重复的key值插入不会改变顺序，适用于使用者需要返回一个顺序相同的map对象的情况。还可以生成access-order顺序的版本，按照最近访问顺序来存储，刚被访问的结点处于链表的末尾，适合LRU，put get compute merge都算作一次访问，其中put key值相同的结点也算作一次访问，replace只有在换掉一个键值对的时候才算一次访问，putAll产生的访问顺序取决于原本map的迭代器实现。&lt;/p&gt;
&lt;p&gt;在插入键值对时，可以通过对removeEldestEntry重写来实现新键值对插入时自动删除最旧的键值对&lt;/p&gt;
&lt;p&gt;拥有HashMap提供的方法，迭代器因为是通过遍历双向链表，所以额外开销与size成正比与capacity无关，因此选择过大的初始大小对于遍历时间的增加没有HashMap严重，后者的遍历时间依赖与capacity。&lt;/p&gt;
&lt;p&gt;同样是非线程安全方法，对于LinkedHashMap来说，修改结构的操作除了增加和删除键值对外，还有对于access-order时进行了access导致迭代器顺序改变，主要是get操作，对于插入顺序的来说，仅仅修改一个已有key值的value值不是一个修改结构的操作，但对于访问顺序，put和get已有的key值会改变顺序。迭代器也是fail-fast设计，但是fail-fast只是一个调试功能，一个设计良好的程序不应该出现这个错误&lt;/p&gt;
&lt;p&gt;因为HashMap加入了TreeNode，所以现在LinkedHashMap也有这个功能&lt;/p&gt;
&lt;p&gt; 以下描述中的链表，若无特别说明都是指LinkedHashMap的双向链表&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;先来看一下基本结构，每个键值对加入了前后指针，集合加入了头尾指针来形成双向链表，accessOrder代表链表是以访问顺序还是插入顺序存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Node&amp;lt;K,V&amp;gt;&lt;span&gt; {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; before, after;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加了先后指针来形成双向链表&lt;/span&gt;
        Entry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The head (eldest) of the doubly linked list.头部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The tail (youngest) of the doubly linked list.尾部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; tail;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true访问顺序 false插入顺序&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; accessOrder;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是几个内部方法。linkNodeLast将p连接到链表尾部&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkNodeLast(LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; last =&lt;span&gt; tail;
        tail &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原本链表为空则p同时为头部&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            p.before &lt;/span&gt;=&lt;span&gt; last;
            last.after &lt;/span&gt;=&lt;span&gt; p;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;transferLinks用dst替换src&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; transferLinks(LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; src,
                               LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; dst) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; b = dst.before =&lt;span&gt; src.before;
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; a = dst.after =&lt;span&gt; src.after;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            b.after &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tail &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            a.before &lt;/span&gt;=&lt;span&gt; dst;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reinitialize在调用HashMap方法的基础上，将head和tail设为null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reinitialize() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.reinitialize();
        head &lt;/span&gt;= tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newNode生成一个LinkedHashMap结点，next指向e，插入到LinkedHashMap链表末端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    Node&amp;lt;K,V&amp;gt; newNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =
            &lt;span&gt;new&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个键值对，next指向e&lt;/span&gt;
        linkNodeLast(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p插入到LinkedHashMap链表末端&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;replacementNode根据原结点生成一个LinkedHashMap结点替换原结点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    Node&amp;lt;K,V&amp;gt; replacementNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; q = (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)p;
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; t =
            &lt;span&gt;new&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(q.hash, q.key, q.value, next);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个新的键值对next是给出的next参数&lt;/span&gt;
        transferLinks(q, t);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用t替换q&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newTreeNode生成一个TreeNode结点，next指向next，插入到LinkedHashMap链表末端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    TreeNode&amp;lt;K,V&amp;gt; newTreeNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;new&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;(hash, key, value, next);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个TreeNode，next指向参数next&lt;/span&gt;
        linkNodeLast(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p插入到LinkedHashMap链表末端&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;replacementTreeNode根据结点p生成一个新的TreeNode，next设为给定的next，替换原本的p&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    TreeNode&amp;lt;K,V&amp;gt; replacementTreeNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; q = (LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)p;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; t = &lt;span&gt;new&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;(q.hash, q.key, q.value, next);
        transferLinks(q, t);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据结点p生成一个新的TreeNode，next设为给定的next，替换原本的p&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;afterNodeRemoval从LinkedHashMap的链上移除结点e&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeRemoval(Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) { 
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt;
            (LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
        p.before &lt;/span&gt;= p.after = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            b.after &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tail &lt;/span&gt;=&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            a.before &lt;/span&gt;=&lt;span&gt; b;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;afterNodeInsertion可能移除最旧的结点，需要evict为true同时链表不为空同时removeEldestEntry需要重写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) { 
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evict &amp;amp;&amp;amp; (first = head) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; removeEldestEntry(first)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;removeEldestEntry需要重写才从发挥作用，否则一定返回false&lt;/span&gt;
            K key = first.key;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除链表头部的结点&lt;/span&gt;
            removeNode(hash(key), key, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;afterNodeAccess在访问过后将结点e移动到链表尾部，需要Map是access-order，若移动成功则增加modCount&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) { 
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (accessOrder &amp;amp;&amp;amp; (last = tail) != e) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Map是access-order同时e不是链表的尾部&lt;/span&gt;
            LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt;
                (LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
            p.after &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结点e从链表中剪下&lt;/span&gt;
                head =&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                b.after &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                a.before &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                last &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                p.before &lt;/span&gt;=&lt;span&gt; last;
                last.after &lt;/span&gt;=&lt;span&gt; p;
            }
            tail &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结点e移动到链表尾部&lt;/span&gt;
            ++modCount;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为有access-order下结点被移动，所以增加modCount&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数方面，accessOrder默认是false插入顺序，初始大小为16，负载因子为0.75，这里是同HashMap。复制构造也是调用了HashMap.putMapEntries方法&lt;/p&gt;
&lt;p&gt;containsValue遍历链表寻找相等的value值，这个操作一定不会造成结构改变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(Object value) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LinkedHashMap.Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e = e.after) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查同样是根据LinkedHashMap提供的链表顺序进行遍历&lt;/span&gt;
            V v =&lt;span&gt; e.value;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v == value || (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; value.equals(v)))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; get方法复用HashMap的getNode方法，若找到结点且Map是访问顺序时，要将访问的结点放到链表最后，若没找到则返回null。而getOrDefault仅有的区别是没找到时返回defaultValue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复用HashMap的getNode方法&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessOrder)
            afterNodeAccess(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;access-order时将e放到队尾&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getOrDefault(Object key, V defaultValue) {
       Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; defaultValue;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;复用HashMap的getNode方法，若没有找到对应的结点则返回defaultValue&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessOrder)
           afterNodeAccess(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;access-order时将e放到队尾&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;clear方法在HashMap的基础上要把head和tail设为null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clear();
        head &lt;/span&gt;= tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;removeEldestEntry在put和putAll插入键值对时调用，原本是一定返回false的，如果要自动删除最旧的键值对要返回true，需要进行重写。比如下面这个例子，控制size不能超过100&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ENTRIES = 100&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeEldestEntry(Map.Entry eldest) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size() &amp;amp;&lt;span&gt;gt; MAX_ENTRIES;
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面两个方法和HashMap相似，返回key的Set和value的Collection还有返回键值对的Set，这个是直接引用，所以对它们的remove之类的修改会直接反馈到LinkedHashMap上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt;&lt;span&gt; keySet() {
        Set&lt;/span&gt;&amp;lt;K&amp;gt; ks =&lt;span&gt; keySet;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ks == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ks &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedKeySet();
            keySet &lt;/span&gt;=&lt;span&gt; ks;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ks;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回key值的set&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Collection&amp;lt;V&amp;gt;&lt;span&gt; values() {
        Collection&lt;/span&gt;&amp;lt;V&amp;gt; vs =&lt;span&gt; values;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            vs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedValues();
            values &lt;/span&gt;=&lt;span&gt; vs;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vs;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个包含所有value值的Collection&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet() {
        Set&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; es;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (es = entrySet) == &lt;span&gt;null&lt;/span&gt; ? (entrySet = &lt;span&gt;new&lt;/span&gt; LinkedEntrySet()) : es;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个含有所有键值对的Set&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查HashMap的putVal方法，我们可以看到在找到了相同key值并修改value值时会调用afterNodeAccess，对于access-order会改变结点顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到了相同的key则修改value值并返回旧的value&lt;/span&gt;
                V oldValue =&lt;span&gt; e.value;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    e.value &lt;/span&gt;=&lt;span&gt; value;
                afterNodeAccess(e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 15 Aug 2018 16:06:00 +0000</pubDate>
<dc:creator>GrayWind</dc:creator>
<og:description>LinkedHashMap继承了HashMap，他在HashMap的基础上增加了一个双向链表的结构，链表默认维持key插入的顺序，重复的key值插入不会改变顺序，适用于使用者需要返回一个顺序相同的ma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/graywind/p/9484577.html</dc:identifier>
</item>
<item>
<title>【java算法】---余弦相似度计算字符串相似率 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9484274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9484274.html</guid>
<description>&lt;p&gt;&lt;strong&gt;功能需求&lt;/strong&gt;：最近在做通过爬虫技术去爬取各大相关网站的新闻，储存到公司数据中。这里面就有一个技术点，就是如何保证你已爬取的新闻，再有相似的新闻&lt;/p&gt;
&lt;p&gt;               或者一样的新闻，那就不存储到数据库中。（因为有网站会去引用其它网站新闻，或者把其它网站新闻拿过来稍微改下内容就发布到自己网站中）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析方案&lt;/strong&gt;：最终就是采用余弦相似度算法，来计算两个新闻正文的相似度。现在自己写一篇博客总结下。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、理论知识&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先推荐一篇博客，对于余弦相似度算法的理论讲的比较清晰，我们也是按照这个方式来计算相似度的。网址：&lt;a href=&quot;https://blog.csdn.net/zz_dd_yy/article/details/51926305&quot; target=&quot;_blank&quot;&gt;相似度算法之余弦相似度&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、说重点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  我这边先把计算两个字符串的相似度理论知识再梳理一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;span&gt;首先是要明白通过向量来计算相识度公式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815214058330-1312704165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）明白：&lt;span&gt;余弦值越接近1，也就是两个向量越相似，这就叫&quot;余弦相似性&quot;，&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;余弦值越接近0，也就是两个向量越不相似，也就是这两个字符串越不相似&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;br/&gt;&lt;span&gt;2、案例理论知识&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;举一个例子来说明，用上述理论计算文本的相似性。为了简单起见，先从句子着手。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;句子A&lt;/strong&gt;&lt;/span&gt;：这只皮靴号码大了。那只号码合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;句子B&lt;/span&gt;&lt;/strong&gt;：这只皮靴号码不小，那只更合适。&lt;/p&gt;
&lt;p&gt;怎样计算上面两句话的相似程度？&lt;/p&gt;
&lt;p&gt;基本思路是：如果这两句话的用词越相似，它们的内容就应该越相似。因此，可以从词频入手，计算它们的相似程度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，分词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;句子A：这只/皮靴/号码/大了。那只/号码/合适。&lt;/p&gt;
&lt;p&gt;句子B：这只/皮靴/号码/不/小，那只/更/合适。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，计算词频。&lt;/span&gt;（也就是每个词语出现的频率）&lt;/p&gt;
&lt;p&gt;句子A：这只1，皮靴1，号码2，大了1。那只1，合适1，不0，小0，更0&lt;/p&gt;
&lt;p&gt;句子B：这只1，皮靴1，号码1，大了0。那只1，合适1，不1，小1，更1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，写出词频向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　句子A：(1，1，2，1，1，1，0，0，0)&lt;/p&gt;
&lt;p&gt;　　句子B：(1，1，1，0，1，1，1，1，1)&lt;/p&gt;
&lt;p&gt;第四步：运用上面的公式：计算如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815214345288-1095555724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算结果中夹角的余弦值为0.81非常接近于1，所以，上面的句子A和句子B是基本相似的&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、实际开发案例 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    我把我们实际开发过程中字符串相似率计算代码分享出来。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;  1、pom.xml&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  展示一些主要jar包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;结合操作工具包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.commons&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-lang3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;bean实体注解工具包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;汉语言包，主要用于分词&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.hankcs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hanlp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;portable-1.6.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;2、main方法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 计算两个字符串的相识度
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Similarity {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String content1=&quot;今天小小和爸爸一起去摘草莓，小小说今天的草莓特别的酸，而且特别的小，关键价格还贵&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;  String content2=&quot;今天小小和妈妈一起去草原里采草莓，今天的草莓味道特别好，而且价格还挺实惠的&quot;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;  score=&lt;span&gt;CosineSimilarity.getSimilarity(content1,content2);
        System.out.println(&lt;/span&gt;&quot;相似度：&quot;+&lt;span&gt;score);

        score&lt;/span&gt;=&lt;span&gt;CosineSimilarity.getSimilarity(content1,content1);
        System.out.println(&lt;/span&gt;&quot;相似度：&quot;+&lt;span&gt;score);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180815215306072-1733815165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过运行结果得出：&lt;/p&gt;
&lt;p&gt;  （1）第一次比较相似率为：0.772853 （说明这两条句子还是挺相似的），第二次比较相似率为：1.0  （说明一模一样）。&lt;/p&gt;
&lt;p&gt;  （2）我们可以看到这个句子的分词效果，后面是词性。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、Tokenizer（分词工具类）&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.hankcs.hanlp.HanLP;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.hankcs.hanlp.seg.common.Term;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.stream.Collectors;


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 中文分词工具类&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tokenizer {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分词&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Word&amp;gt;&lt;span&gt; segment(String sentence) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、 采用HanLP中文自然语言处理中标准分词进行分词&lt;/span&gt;
        List&amp;lt;Term&amp;gt; termList =&lt;span&gt; HanLP.segment(sentence);
&lt;br/&gt;&lt;span&gt;//上面控制台打印信息就是这里输出的&lt;/span&gt;
        System.out.println(termList.toString());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、重新封装到Word对象中（term.word代表分词后的词语，term.nature代表改词的词性）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; termList.stream().map(term -&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Word(term.word, term.nature.toString())).collect(Collectors.toList());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;4、Word（封装分词结果）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里面真正用到的其实就&lt;span&gt;词名和权重。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Objects;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 封装分词结果&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Word &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Comparable {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 词名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 词性&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String pos;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 权重，用于词向量分析&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Float weight;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Word(String name, String pos) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pos =&lt;span&gt; pos;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.hashCode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getClass() !=&lt;span&gt; obj.getClass()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Word other =&lt;span&gt; (Word) obj;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name, other.name);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        StringBuilder str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            str.append(name);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pos != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            str.append(&lt;/span&gt;&quot;/&quot;&lt;span&gt;).append(pos);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.toString();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; o) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.name == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Word)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        String t &lt;/span&gt;=&lt;span&gt; ((Word) o).getName();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.compareTo(t);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;5、CosineSimilarity（相似率具体实现工具类）&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.algorithm.tokenizer.Tokenizer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.algorithm.tokenizer.Word;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.CollectionUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigDecimal;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判定方式：余弦相似度，通过计算两个向量的夹角余弦值来评估他们的相似度 余弦夹角原理： 向量a=(x1,y1),向量b=(x2,y2) similarity=a.b/|a|*|b| a.b=x1x2+y1y2
 * |a|=根号[(x1)^2+(y1)^2],|b|=根号[(x2)^2+(y2)^2]&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CosineSimilarity {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(CosineSimilarity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**
     * 1、计算两个字符串的相似度
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getSimilarity(String text1, String text2) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果wei空，或者字符长度为0，则代表完全相同&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (StringUtils.isBlank(text1) &amp;amp;&amp;amp;&lt;span&gt; StringUtils.isBlank(text2)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1.0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个为0或者空，一个不为，那说明完全不相似&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (StringUtils.isBlank(text1) ||&lt;span&gt; StringUtils.isBlank(text2)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0.0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个代表如果两个字符串相等那当然返回1了（这个我为了让它也分词计算一下，所以注释掉了）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if (text1.equalsIgnoreCase(text2)) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            return 1.0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//第一步：进行分词&lt;/span&gt;
        List&amp;lt;Word&amp;gt; words1 =&lt;span&gt; Tokenizer.segment(text1);
        List&lt;/span&gt;&amp;lt;Word&amp;gt; words2 =&lt;span&gt; Tokenizer.segment(text2);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getSimilarity(words1, words2);
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 2、对于计算出的相似度保留小数点后六位
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; getSimilarity(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; score =&lt;span&gt; getSimilarityImpl(words1, words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(int) (score * 1000000 + 0.5)其实代表保留小数点后六位 ,因为1034234.213强制转换不就是1034234。对于强制转换添加0.5就等于四舍五入&lt;/span&gt;
        score = (&lt;span&gt;int&lt;/span&gt;) (score * 1000000 + 0.5) / (&lt;span&gt;double&lt;/span&gt;) 1000000&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; score;
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 文本相似度计算 判定方式：余弦相似度，通过计算两个向量的夹角余弦值来评估他们的相似度 余弦夹角原理： 向量a=(x1,y1),向量b=(x2,y2) similarity=a.b/|a|*|b| a.b=x1x2+y1y2
     * |a|=根号[(x1)^2+(y1)^2],|b|=根号[(x2)^2+(y2)^2]
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; getSimilarityImpl(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向每一个Word对象的属性都注入weight（权重）属性值&lt;/span&gt;
&lt;span&gt;        taggingWeightByFrequency(words1, words2);

        &lt;/span&gt;&lt;span&gt;//第二步：计算词频
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过上一步让每个Word对象都有权重值，那么在封装到map中（key是词，value是该词出现的次数（即权重））&lt;/span&gt;
        Map&amp;lt;String, Float&amp;gt; weightMap1 =&lt;span&gt; getFastSearchMap(words1);
        Map&lt;/span&gt;&amp;lt;String, Float&amp;gt; weightMap2 =&lt;span&gt; getFastSearchMap(words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将所有词都装入set容器中&lt;/span&gt;
        Set&amp;lt;Word&amp;gt; words = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        words.addAll(words1);
        words.addAll(words2);

        AtomicFloat ab &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a.b&lt;/span&gt;
        AtomicFloat aa = &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |a|的平方&lt;/span&gt;
        AtomicFloat bb = &lt;span&gt;new&lt;/span&gt; AtomicFloat();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |b|的平方

        &lt;/span&gt;&lt;span&gt;// 第三步：写出词频向量，后进行计算&lt;/span&gt;
        words.parallelStream().forEach(word -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看同一词在a、b两个集合出现的此次&lt;/span&gt;
            Float x1 =&lt;span&gt; weightMap1.get(word.getName());
            Float x2 &lt;/span&gt;=&lt;span&gt; weightMap2.get(word.getName());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x1 != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x1x2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x1 *&lt;span&gt; x2;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                ab.addAndGet(oneOfTheDimension);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x1 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(x1)^2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x1 *&lt;span&gt; x1;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                aa.addAndGet(oneOfTheDimension);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(x2)^2&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; oneOfTheDimension = x2 *&lt;span&gt; x2;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
&lt;span&gt;                bb.addAndGet(oneOfTheDimension);
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;|a| 对aa开方&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; aaa =&lt;span&gt; Math.sqrt(aa.doubleValue());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;|b| 对bb开方&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; bbb =&lt;span&gt; Math.sqrt(bb.doubleValue());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用BigDecimal保证精确计算浮点数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;double aabb = aaa * bbb;&lt;/span&gt;
        BigDecimal aabb =&lt;span&gt; BigDecimal.valueOf(aaa).multiply(BigDecimal.valueOf(bbb));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;similarity=a.b/|a|*|b|
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;divide参数说明：aabb被除数,9表示小数点后保留9位，最后一个表示用标准的四舍五入法&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; cos = BigDecimal.valueOf(ab.get()).divide(aabb, 9&lt;span&gt;, BigDecimal.ROUND_HALF_UP).doubleValue();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cos;
    }


    &lt;/span&gt;&lt;span&gt;/**
     * 向每一个Word对象的属性都注入weight（权重）属性值
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; taggingWeightByFrequency(List&amp;lt;Word&amp;gt; words1, List&amp;lt;Word&amp;gt;&lt;span&gt; words2) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (words1.get(0).getWeight() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; words2.get(0).getWeight() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;词频统计（key是词，value是该词在这段句子中出现的次数）&lt;/span&gt;
        Map&amp;lt;String, AtomicInteger&amp;gt; frequency1 = getFrequency(words1);&lt;span&gt;
        Map&lt;/span&gt;&amp;lt;String, AtomicInteger&amp;gt; frequency2 =&lt;span&gt; getFrequency(words2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是DEBUG模式输出词频统计信息
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        if (LOGGER.isDebugEnabled()) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            LOGGER.debug(&quot;词频统计1：\n{}&quot;, getWordsFrequencyString(frequency1));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            LOGGER.debug(&quot;词频统计2：\n{}&quot;, getWordsFrequencyString(frequency2));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标注权重（该词出现的次数）&lt;/span&gt;
        words1.parallelStream().forEach(word -&amp;gt; word.setWeight(frequency1.get(word.getName()).floatValue()));&lt;span&gt;
        words2.parallelStream().forEach(word &lt;/span&gt;-&amp;gt;&lt;span&gt; word.setWeight(frequency2.get(word.getName()).floatValue()));
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 统计词频
     * @return 词频统计图
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, AtomicInteger&amp;gt; getFrequency(List&amp;lt;Word&amp;gt;&lt;span&gt; words) {

        Map&lt;/span&gt;&amp;lt;String, AtomicInteger&amp;gt; freq = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这步很帅哦&lt;/span&gt;
        words.forEach(i -&amp;gt; freq.computeIfAbsent(i.getName(), k -&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger()).incrementAndGet());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; freq;
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 输出：词频统计信息
     */&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getWordsFrequencyString(Map&amp;lt;String, AtomicInteger&amp;gt;&lt;span&gt; frequency) {
        StringBuilder str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frequency != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;frequency.isEmpty()) {
            AtomicInteger integer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
            frequency.entrySet().stream().sorted((a, b) &lt;/span&gt;-&amp;gt; b.getValue().get() -&lt;span&gt; a.getValue().get()).forEach(
                    i &lt;/span&gt;-&amp;gt; str.append(&quot;\t&quot;).append(integer.incrementAndGet()).append(&quot;、&quot;).append(i.getKey()).append(&quot;=&quot;&lt;span&gt;)
                            .append(i.getValue()).append(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;));
        }
        str.setLength(str.length() &lt;/span&gt;- 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**
     * 构造权重快速搜索容器
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Float&amp;gt; getFastSearchMap(List&amp;lt;Word&amp;gt;&lt;span&gt; words) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(words)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyMap();
        }
        Map&lt;/span&gt;&amp;lt;String, Float&amp;gt; weightMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;(words.size());

        words.parallelStream().forEach(i &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i.getWeight() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;weightMap.put(i.getName(), i.getWeight());&lt;span&gt;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                LOGGER.error(&lt;/span&gt;&quot;no word weight info:&quot; +&lt;span&gt; i.getName());
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weightMap;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个具体实现代码因为思维很紧密所以有些地方写的比较绕，同时为了性能提升还手写了AtomicFloat原子类。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、AtomicFloat原子类&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * jdk没有AtomicFloat，写一个
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AtomicFloat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Number {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AtomicInteger bits;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AtomicFloat() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(0f);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AtomicFloat(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; initialValue) {
        bits &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger(Float.floatToIntBits(initialValue));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;叠加&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; addAndGet(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; update;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
            update &lt;/span&gt;= expect +&lt;span&gt; delta;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, update));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; update;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; getAndAdd(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; delta) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; update;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
            update &lt;/span&gt;= expect +&lt;span&gt; delta;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, update));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; expect;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getAndDecrement() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getAndAdd(-1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; decrementAndGet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addAndGet(-1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getAndIncrement() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getAndAdd(1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; incrementAndGet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addAndGet(1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; getAndSet(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; newValue) {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; expect;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            expect &lt;/span&gt;=&lt;span&gt; get();
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.compareAndSet(expect, newValue));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; expect;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSet(&lt;span&gt;float&lt;/span&gt; expect, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; update) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bits.compareAndSet(Float.floatToIntBits(expect), Float.floatToIntBits(update));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; set(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; newValue) {
        bits.set(Float.floatToIntBits(newValue));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; get() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.intBitsToFloat(bits.get());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; floatValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; doubleValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;) floatValue();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; intValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; longValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) get();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Float.toString(get());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;7、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;把大致思路再捋一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （1）先分词： &lt;/strong&gt;分词当然要按一定规则，不然随便分那也没有意义，那这里通过&lt;span&gt;采用HanLP中文自然语言处理中标准分词进行分词。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （2）统计词频： &lt;/strong&gt;就统计上面词出现的次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （3）通过每一个词出现的次数，变成一个向量，通过向量公式计算相似率。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 天一亮，又是崭新的起点，又是未知的征程（上校3）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 14:44:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>余弦相似度计算字符串相似率 功能需求：最近在做通过爬虫技术去爬取各大相关网站的新闻，储存到公司数据中。这里面就有一个技术点，就是如何保证你已爬取的新闻，再有相似的新闻 或者一样的新闻，那就不存储到数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9484274.html</dc:identifier>
</item>
<item>
<title>Hibernate一级缓存测试分析 - 白超华</title>
<link>http://www.cnblogs.com/bc8web/p/java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bc8web/p/java.html</guid>
<description>&lt;h4 id=&quot;hibernate的一级缓存就是指session缓存此session非http的session会话技术可以理解为jdbc的connection连接会话session缓存就是一块内存空间用来存放相互管理的java对象在使用hibernate查询对象的时候首先使用对象的oidobject-id在hibernate-的一级缓存空间进行查找如果通过oid匹配到了对象就直接从一级缓存中取出使用如果没有找到匹配该oid值的对象这才会进行查询数据库当从数据库中查询数据的时候该数据就会被放入到session缓存中目的就是为了减少数据库的访问次数从而提高性能&quot;&gt;Hibernate的一级缓存就是指Session缓存，此Session非http的session会话技术，可以理解为JDBC的Connection，连接会话，Session缓存就是一块内存空间，用来存放相互管理的java对象，在使用Hibernate查询对象的时候，首先使用对象的OID（&lt;code&gt;Object ID&lt;/code&gt;）在Hibernate 的一级缓存空间进行查找，如果通过OID匹配到了对象，就直接从一级缓存中取出使用，如果没有找到匹配该OID值的对象，这才会进行查询数据库。当从数据库中查询数据的时候，该数据就会被放入到Session缓存中，目的就是为了减少数据库的访问次数，从而提高性能。&lt;/h4&gt;
&lt;h2 id=&quot;hibernate缓存特点&quot;&gt;Hibernate缓存特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;save(), update(), saveOrUpdate()&lt;/strong&gt; 时候，如果缓存中没 有相应的对象，Hb就会自动的把查询信息加入到缓存。&lt;/li&gt;
&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;load(), get(), list()&lt;/strong&gt; 等查询方法的时候，会进行判断缓存中是否有数据，同摘要。&lt;/li&gt;
&lt;li&gt;当应用程序调用Session接口的 &lt;strong&gt;close()&lt;/strong&gt; Session缓存会被清空&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;接下来进行测试一级缓存&quot;&gt;接下来进行测试一级缓存&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先测试一级缓存是否存在？对user表的主键为“1”的分别进行两次查询：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public void demo1 (){
        Session session = HibernateUtils.openSession();
        Transaction transaction = session.beginTransaction();
        
        User user1 = session.get(User.class, &quot;1&quot;);
        System.out.println(user1);
        System.out.println(&quot;-------------&quot;);
        User user2 = session.get(User.class, &quot;1&quot;);
        System.out.println(user2);
        System.out.println(user1 == user2);
        
        transaction.commit();
        session.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815204731169-1445605516.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们发现第一次执行Session的get()方法的时候，由于一级缓存中没有数据，所以会向数据库发送一条sql语句进行查询，第二次调用get()的时候，则不会发送sql语句，而是从一级缓存中取的，所以user和user2的内存地址相等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一级缓存的快照区&quot;&gt;### 一级缓存的快照区&lt;/h2&gt;
&lt;p&gt;Hibernate向一级缓存放入数据的时候，同时复制一份放到Hibernate快照中，当使用commot()提交事务的时候，同时会清理Session的一级缓存，这是会用&lt;code&gt;OID&lt;/code&gt;判断一级缓存中的对象和快照中的对象是否一致，如果一致则执行 update 语句，将缓存中的内容同步到数据库，并且更新快照，这也就实现了不使用 update 语句就可以自动更新数据库，Hibernate快照的作用也就是为了保持缓存中的数据和数据库中的数据的一致性。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;快照区代码测试&lt;br/&gt;我们在get的时候设置断点，看到右侧变量 session-&amp;gt;persitenceContext-&amp;gt;entitlxxx-&amp;gt;head，也就是缓存中是为空的&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815211553759-745894955.png&quot;/&gt;&lt;br/&gt;现在继续执行&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815211937967-377970790.png&quot;/&gt;&lt;br/&gt;我们发现在缓存区域已经有了数据了，同时Hibernate 也会在快照区域创建数据，在 Hibernate3 里面它使用的是Map进行存储的，map的key作为一级缓存去，value作为一级快照区，当进行查询的时候，会同时给缓存和快照去放入相同的数据，当orm对象属性发生变化的时候，会首先改变缓存区的值，当进行事务提交的时候，会比较缓存和快照的内容，如果一致则不操作，不一致则更新数据库。&lt;br/&gt;继续执行:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/901316/201808/901316-20180815213405380-732585390.png&quot;/&gt;&lt;br/&gt;commin()的时候，自动进行更新，clear().evict()的时候会清除缓存（删除表中数据的时候也会）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public void demo1 (){
        Session session = HibernateUtils.openSession();
        Transaction transaction = session.beginTransaction();
        
        User user1 = session.get(User.class, &quot;1&quot;);
        System.out.println(user1);
        System.out.println(&quot;-------------&quot;);
        session.clear();
        User user2 = session.get(User.class, &quot;1&quot;);
        System.out.println(user2);
        System.out.println(user1 == user2);
        
        transaction.commit();
        session.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;输入如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Hibernate: 
    select
        user0_.uid as uid1_1_0_,
        user0_.name as name2_1_0_,
        user0_.username as username3_1_0_,
        user0_.password as password4_1_0_,
        user0_.email as email5_1_0_,
        user0_.telephone as telephon6_1_0_,
        user0_.sex as sex7_1_0_ 
    from
        user user0_ 
    where
        user0_.uid=?
User{uid=1, username=baiChaoHua, password=null, name=null, email=null, telephone=null, birthady=null, sex=null, state=0, code=null}
-------------
Hibernate: 
    select
        user0_.uid as uid1_1_0_,
        user0_.name as name2_1_0_,
        user0_.username as username3_1_0_,
        user0_.password as password4_1_0_,
        user0_.email as email5_1_0_,
        user0_.telephone as telephon6_1_0_,
        user0_.sex as sex7_1_0_ 
    from
        user user0_ 
    where
        user0_.uid=?
User{uid=1, username=baiChaoHua, password=null, name=null, email=null, telephone=null, birthady=null, sex=null, state=0, code=null}
false&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以看出执行执行了两次sql，user对象的内存地址也就自然不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一级缓存常用的API：&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:46:00 +0000</pubDate>
<dc:creator>白超华</dc:creator>
<og:description>Hibernate 一级缓存测试分析 ===================== Hibernate的一级缓存就是指Session缓存，此Session非http的session会话技术，可以理解为J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bc8web/p/java.html</dc:identifier>
</item>
<item>
<title>如何创建一个基于Node的HTTP服务器 - 余大彬</title>
<link>http://www.cnblogs.com/yuliangbin/p/9429062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuliangbin/p/9429062.html</guid>
<description>&lt;p&gt;首先创建一个HTTP服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; http = require('http'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    console.log(request.method);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求的方法&lt;/span&gt;
    console.log(request.url);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求里的url,只含有路径名，并不是完整的url&lt;/span&gt;
    console.log(request.header) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求头&lt;/span&gt;
&lt;span&gt;
    response.statusCode &lt;/span&gt;= 200&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析。不指定的话可能会造成乱码&lt;/span&gt;
    response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
    response.setHeader(&lt;/span&gt;'name','zfpx'&lt;span&gt;);
    response.write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString());
    response.end();
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server =&lt;span&gt; http.createServer(serve);
server.listen(&lt;/span&gt;3000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们希望读取其他文件的内容，则需要先导入fs模块，该模块是&lt;span&gt;读取文件的模块&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var fs = require('fs');&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
    response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
    fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
        response.write(data);
        response.end();
    })
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样又有一个问题，就是：在对返回的HTML代码开始解析时，解析过程中如果遇到引用的服务器上的资源（额外的CSS，JS代码，图片等资源），需要再次向服务器发送请求，但是不管是发送什么请求，服务器返回的都是index.html文件。这时，我们就需要对不同的请求资源做一个判断，让其返回不同类型的资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url == '/'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
        response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (url == '/style.css'&lt;span&gt;) {
        response.setHeader(&lt;/span&gt;'Content-Type','text/css;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('style.css',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个页面里，我们可能会请求非常多的静态资源，如果每次都加一个else if 显然让页面更复杂，且不利于维护。所以我们希望将所有的静态资源请求都封装在一个函数里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseMime(pathname) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = /\.(HTML|JS|CSS|JSON|TXT|ICO|JPG)/&lt;span&gt;i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reg.test(pathname)) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取请求文件的后缀名&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; suffix = reg.exec(pathname)[1&lt;span&gt;].toUpperCase();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据请求文件的后缀名获取到当前文件的MIME类型&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; suffixMIME = &quot;text/plain&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(suffix) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;HTML&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/html&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;CSS&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/css&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JS&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;text/javascript&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JSON&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;application/json&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;ICO&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;application/octet-stream&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;JPG&quot;&lt;span&gt;:
                suffixMIME &lt;/span&gt;= &quot;image/jpg&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suffixMIME;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，Node中还提供了一个第三方的模块能够自动帮我们判断文件的&lt;span&gt;MIME类型&lt;/span&gt;，我们这里还需要用到一个第三方的模块&quot;mine&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mime = require('mime'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; serve(request,response) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; request.url;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url == '/'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应类型，编码为utf-8。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器返回资源给浏览器时，还应该告诉浏览器这是什么类型的文件，以什么方式解析&lt;/span&gt;
        response.setHeader('Content-Type','text/html;charset=utf-8'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
        fs.readFile('index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
            response.write(data);
            response.end();
        })
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        static(url,response)
    }    
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; static(url,response) {
    response.setHeader(&lt;/span&gt;'Content-Type',mime.lookup(url) + ';charset=utf-8'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们希望返回的是其他文件的内容，则需要先读取其他文件，这时需要fs模块来读取文件&lt;/span&gt;
    fs.readFile(url.slice(1),&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,data) {
        response.write(data);
        response.end();
    })
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在我们的url都是类似http://localhost:3000/index.html这样的，就是客户端只是单纯的获取数据，并不涉及向服务器端发送数据。&lt;/p&gt;
&lt;p&gt;前面我们说过，request.url获取的是'3000:'之后的内容，那么当我们需要向服务器传一些内容的时候，比如说http://localhost:3000/index.html/?name=&quot;xiaoyu&quot;。这时request.url获取的就是/index.html/?name=&quot;xiaoyu&quot;。&lt;/p&gt;
&lt;p&gt;这样的url显然不能再作为我们判断路径的依据，所以我们得进一步处理这个url。其实node提供了一个更加强大的url解析库给我们，这个库就是”url“。&lt;span&gt;这个库能够解析整个完整的url路径。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;传送地址：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yuliangbin/p/9483918.html&quot;&gt;url模块学习小结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>余大彬</dc:creator>
<og:description>首先创建一个HTTP服务器。 如果我们希望读取其他文件的内容，则需要先导入fs模块，该模块是读取文件的模块。 但是这样又有一个问题，就是：在对返回的HTML代码开始解析时，解析过程中如果遇到引用的服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuliangbin/p/9429062.html</dc:identifier>
</item>
<item>
<title>这些年，在数据挖掘项目中踩的“坑” - 小糖球ai大萝卜</title>
<link>http://www.cnblogs.com/xiaotangqiu/p/9484157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaotangqiu/p/9484157.html</guid>
<description>&lt;p&gt;数据挖掘项目是一个涉及的环节也比较多，而且高度依赖数据的项目。所以在其中一个过程中遇到点坑，简直太正常不过了。&lt;br/&gt;需求不明确是第一大坑。需求不明确会把后面的分析方向完全带沟沟里面去，也容易被迫接受一些不可能完成的挖掘目标和商业目标。不过这种一般只会发生在一个公司刚开始有这个岗位的时候，随着项目的增加，后面大家普遍就知道数据挖掘的极限了，也知道数据挖掘任务所存在的风险了，便不会提出不可能完成的目标了。说一个曾经被带沟沟里去的需求。有一次接到领导说做一个需求，要找出影响用户忠诚度的关键因子，然后我吭哧吭哧的提取数要求，等数据，写分析报告，确认了几个关键因子，然后去见客户才发现人家提的是影响高端用户粘性的因子。范围都不对，大受打击。此处避坑方式，可以去接触一线客户的时候，不要退缩，一定要了解他们的真实想法，不要被口口相传后带歪了，然后白干了。&lt;br/&gt;数据本身质量问题是第二大坑。大部分生产系统收集的数据都不是专门为做挖掘而做的，基本都是为直接盈利而存在的，所以也就只有直接影响到市场营销的指标最可靠。别的辅助指标，只能说质量实在一般。我们提出的上百个指标，真正能用的有20来个就不错了。除了数据在记录的时候可能发生的错误问题，还可能是数据精度/偏倚和准确率，数据不一致，数据遗漏，数据离群点，数据重复等问题。没别的避坑方式，只能是尽可能多的了解系统的基础数据，搜集各方信息，在想法设法的提高数据质量的基础上发散思维生成更多分析维度，然后尽人事知天命！&lt;br/&gt;取数过程中发生的数据问题是第三大坑。尤其记得刚毕业那年，还是个小透明的时候。有一次做一个甲方的挖掘项目，因为第二天要交付（取数周期长耽误了工期），一伙人拿着乱七八糟的数据分析到凌晨3点，结果发现一个关键ID都弄错了，导致全部数据都没法用。那种想死的心情，那种想杀人的心情。也给我们一个血的教训，千万不要因为信任某个人或者项目时间紧而放弃认真检查数据。数据有问题就只能打回去重整，就算是时间紧也没办法。不过话说回来，本来从各个数据仓库取数就是个又杂又累的苦活，好一点的取数人员只是犯的傻逼错误少一些。有些逻辑上考虑不全是正常的。而且他们对于数据的指标含义什么的，不像我们这么敏感，他们也是要在短时间内完成任务。所以此处的避坑方式其实也很简单，那就是检查数据！检查数据！检查数据！！！&lt;br/&gt;如果说前面的三大坑还算是可以填满的，那么接下来要说的超级大坑靠我们普通小辈基本填不满的。那就是能否得到实权人物的支持。说到底，数据挖掘到现在为止，还只是个锦上添花的事业。对于广大身处各种生产问题无法自拔的一线人员和实权领导，是不会有时间和精力来做这些锦上添花的事情的。因此项目经常因为这样或那样的问题延期或者拒绝上线。总的来说，数据挖掘的理论和技术都发展的比较成熟了。但是受现阶段采集数据和系统建设的影响，要真正达到高级应用阶段还有一段距离。现在更多的是停留在数据分析和数据可视化阶段。&lt;br/&gt;做项目就是这样，克服困难完成任务才是重点。处理问题才能体现我们的价值嘛。如果项目顺利什么问题都没有不就变成了搞科研了吗？&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:32:00 +0000</pubDate>
<dc:creator>小糖球ai大萝卜</dc:creator>
<og:description>数据挖掘项目是一个涉及的环节也比较多，而且高度依赖数据的项目。所以在其中一个过程中遇到点坑，简直太正常不过了。需求不明确是第一大坑。需求不明确会把后面的分析方向完全带沟沟里面去，也容易被迫接受一些不可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaotangqiu/p/9484157.html</dc:identifier>
</item>
<item>
<title>Android 9.0新特性 - 安卓笔记侠</title>
<link>http://www.cnblogs.com/ganchuanpu/p/9484120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ganchuanpu/p/9484120.html</guid>
<description>&lt;p&gt;1、全面屏支持，Android P加入了对刘海屏的支持，谷歌称之为凹口屏幕（display with a cutout）。借助最新的提供的DisplayCutout类，开发者可以找到非功能区域的位置和形状，而非功能区域是不应显示功能的；使用getDisplayCutout（）就可以获取这个区域的详细信息，未来刘海屏手机很有可能成为主流趋势，在前摄像头没有比较好的隐藏方案出现之前，这可能是提高屏占比的好方法。&lt;/p&gt;
&lt;p&gt;2、通知栏的多种通知，从牛轧糖开始，你就可以增加一个action以对消息或从通知直接进入文字的行为作出反应。而在Android P版本中，你还可以在消息中展示图像；新的Notification.Person类可以识别对话中的任务，包括他们的头像和URI；当用户关闭消息通知时，你的app可以获取由系统发出的EXTRAREMOTEINPUT_DRAFT。你可以使用这个extra值来在app中进行预填充……&lt;/p&gt;
&lt;p&gt;3、多摄像头的更多画面，可以即时获取到两个或者更多的相机数据流，可以想象将有更多有趣的设计和实现出来&lt;/p&gt;
&lt;p&gt;4、GPS定位之外的WiFi定位，Android P增加了平台级支持IEEE 802.11 mc Wi-Fi协议(即Wi-Fi Round-Trip-Time,RTT), 从而让开发者可在App中使用室内定位。使用有硬件支持的Android P设备上，你的应用可以使用最新的RTT API以测量附近具有RTT功能的Wi-Fi AP。当然，前提是你的设备必须有定位功能而且你的App已经获取了ACCESS_COARSE_LOCATION及其以上的权限，可以想象将来更加精准的定位所带来的丰富的应用场景。&lt;/p&gt;
&lt;p&gt;5、网络还有神经网络，在Android P上，任务可以声明它们估算的数据大小，信号预读取并且指定详细的网络需求--任务载体则可以报告网络是否拥挤或是否不计量。JobScheduler便可按照网络状态管理任务。另一方面，神经网络API在Android 8.1引入，目的是加速Android设备上的机器学习。Android P扩展并改进了这些API, 为9个操作增加了支持，分别是Pad, BatchToSpaceND, SpaceToBatchND, Transpose, Strided Slice, Mean, Div, Sub和Squeeze。在Android P之后，设备将会对网络有更精细的调整：根据任务需求的数据大小和当前的网络环境。在收费网络里延迟一些网络要求，而在不计费的网络里可以通过消息预获取来得到更好的用户体验。神经网络API的更多操作则是让设备变得更智能、更聪明。智能的一种体现，节省流量和网络速度优化体验的一种好的改进。&lt;/p&gt;
&lt;p&gt;6、Material Design迎来2.0时代，神经网络Android 9.0加入了大量的圆角设计，UI方面的优化，感觉有些鸡肋，在现在各种模仿的设计趋势和各种定制化UI下，许多功能只是看看而已，用不到多少。&lt;/p&gt;
&lt;p&gt;7、Android Dashboard：用户可以看清楚自己在受手机上都干了哪些事情，从而提醒自己是否过多的浪费了不必要的时间，比如后是否看电影看视频太多，是否玩游戏太多等等。并在必要的时候提醒你应当休息一下。对某一款应用进行时间限制，用户使用到一定时间之后就会提醒，甚至让图标变灰色，以提醒用户尽量少用这个APP&lt;/p&gt;
&lt;p&gt;8、Wind Down：夜间模式；&lt;/p&gt;
&lt;p&gt;9、Adaptive Battery：更智能的方式来适应电池和屏幕，从而整体改善续航能力。谷歌加入了Adaptive Battery功能，不过这个模式需要单独开启，在该模式下，程序不需要唤醒可以极大的降低资源占用，更关注用户最常用的服务和应用程序，也算是AI技术的应用之一。这样就可以最大限度的降低后台占用，从而提升电池续航能力。这是Android团队与Google DeepMiind团队合作开发的成果，不仅可以预测用户接下来几个小时内将使用的应用程序，而且还包括在当天用户何时会使用哪些应用程序。智能的一种应用。&lt;/p&gt;
&lt;p&gt;10、Shush：屏幕朝下时进入完全勿扰状态；除了能够阻挡电话和通知的打扰，还有视觉免打扰的功能，屏幕不会点亮，直到用户主动打开手机。有趣的是在这个模式下，如果用户将手机屏幕朝下放置，那么手机会自动调整为震动或者静音模式，只保留闹钟的声音。&lt;/p&gt;
&lt;p&gt;11、Actions和Slices：通过检测用户的行为，让系统作出对应的动作。如插入耳机孔自动播放音乐，搜索“打车”自动显示打车软件等。&lt;/p&gt;
&lt;p&gt;总结：对更大屏幕显示的追求和视觉等体验的优化，智能的开始体现（用户行为的学习及正确化引导，网络环境的智能适应，电池电量的优化），更加人性化。期待更好的android，期待更好的智能体验，加油！&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:26:00 +0000</pubDate>
<dc:creator>安卓笔记侠</dc:creator>
<og:description>1、全面屏支持，Android P加入了对刘海屏的支持，谷歌称之为凹口屏幕（display with a cutout）。借助最新的提供的DisplayCutout类，开发者可以找到非功能区域的位置和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ganchuanpu/p/9484120.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（29）——定制ORM（六） - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/9483706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/9483706.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在开发中，查询操作是使用最多的，而查询列表是其中之一，查询列表可分为分页查询和不分页查询（它们之间多了一次总记录数查询），还可以分为单表查询和多表关联查询，返回的结构体根据前端使用的表单框架不同而有所区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先看看，对于列表分页查询，在接口中是如何处理的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0e4794a2-ffbf-42ab-9024-49a39092c8b2')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0e4794a2-ffbf-42ab-9024-49a39092c8b2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0e4794a2-ffbf-42ab-9024-49a39092c8b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询条件&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     wheres = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产品分类id&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     product_class_id = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;产品分类id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; product_class_id &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where product_class_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(product_class_id)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         order_by = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类型&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     type = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否是前台提交获取数据&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; type != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backstage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否已经存在查询条件了，是的话在原查询条件后面拼接&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             wheres = wheres + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出格式（前端使用jqgrid列表，需要指定输出格式）&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from product %(wheres)s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存总记录数量&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 0)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置分页大小&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         page_size = 10
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总页数&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断提交的页码是否超出范围&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面索引值&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;     record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;     paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合sql查询语句&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;     sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from product %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;            {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: wheres, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: order_by, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储记录&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt;         data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(data, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　代码看起来很长，有点复杂，对于这种列表分页查询，如果不封装的话，开发时复制粘贴就很容易出错，所以我们需要重新处理才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从上面代码可以看到，具体功能分为几个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一部分（9到33行）是接收并组合查询条件，接收分页参数和排序参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二部分（37到42行）是初始化结果输出参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三部分（44到51行）是获取查询总记录数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第四部分（55到75行）是计算总页数，计算当前分页位置要显示的记录位置区间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第五部分（80到92行）是组合查询语句，查询并输出结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了产品列表这个接口，大家可以看看产品分类列表接口，会发现两个接口第二部分到第五部分都差不多，所以我们封装ORM时，可以将这些相似部分进行处理，将它们封装到ORM对应的方法里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　首先，我们对上面代码的分析，可以提炼出分页查询方法需要有下面参数：查询字段、查询条件、当前分页索引值、每页显示记录数量、排序。如果是多表查询时，我们的ORM是直接绑定当前表单的就不适用了，所以还需要有个设置表名的参数，好灵活处理各种需求，根据这些要求，我们可以创建好列表查询方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; get_list(self, column_name_list=&lt;span&gt;''&lt;/span&gt;, wheres=&lt;span&gt;''&lt;/span&gt;, page_number=None, page_size=None, orderby=None, table_name=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    获取指定条件的数据库记录集
    :param column_name_list:      查询字段
    :param wheres:      查询条件
    :param page_number:   分页索引值
    :param page_size:    分页大小， 存在值时才会执行分页
    :param orderby:     排序规则
    :param table_name:     查询数据表，多表查询时需要设置
    :return: 返回记录集总数量与分页记录集
        {'records': 0, 'total': 0, 'page': 0, 'rows': []}
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在接收到这些参数以后，我们需要对相关参数进行初始化操作，方便后续代码的执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出参数：总记录数量与列表集&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总记录数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总页数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前页面索引&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [],     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询结果（记录列表）&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询数据表名称&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; table_name:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         table_name = self.&lt;span&gt;__table_name&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询字段名&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; column_name_list:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         column_name_list = self.&lt;span&gt;__column_name_list&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询条件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是字符串，表示该查询条件已组装好了，直接可以使用&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(wheres, str):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; wheres
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是list，则表示查询条件有多个，可以使用join将它们用and方式组合起来使用&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt;&lt;span&gt; isinstance(wheres, list):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(wheres)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; orderby:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         orderby = self.&lt;span&gt;__pk_name&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化分页查询的记录区间&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     paging = &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里是对传入的参数和后续需要用到的参数进行初始化操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里需要初始化查询结果输出参数结构，在进行记录数查询时，如果没有记录存在，就可以直接将结果返回出去了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　默认数据表为当前类实体指定的表名称，如果进行多表联合查询时，就需要设置多表联合查询的组合表名称，比如：product left join product_class on product.product_class_id = product_class.id&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同时我们还需要设置查询字段内容，如果想查询出所有字段，直接使用*，如果只想要输出指定的几个字段值，则可以填写这几个字段值，比如：id,name,content&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在查询时，有时不需要查询条件，这时我们可以不填写条件，如果有指定条件时，我们可以将它们组合好，也可以放到list中。它们的区别在于，有多个查询条件时，我们有时很难判断当前条件前需不需要添加and，这时我们就可以使用' and '.join(列表) 来进行合成了，当然用list方式条件之间只能是and的关系。对于复杂的条件，我们可以组合好以后提交进来直接使用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在查询时，如果没有指定排序方式，我们默认使用主键倒序来进行排序&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在分页列表操作时，我们通常需要获取总记录数返回给前端，所以在执行查询前，我们需要获取当前查询条件的总记录数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     with db_helper.PgHelper(self.&lt;span&gt;__db&lt;/span&gt;, self.&lt;span&gt;__is_output_sql&lt;/span&gt;&lt;span&gt;) as db:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否需要进行分页&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from %(table_name)s %(wheres)s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                   {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: table_name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置记录总数量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　加上if not page_size is None判断，是因为有时候我们查询时，不需要分页操作，直接将所有记录输出了，这里加上判断可以减少不必要的记录总数量查询&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当我们获取到总记录数量以后，我们需要根据前端页面显示的记录数进行计算，计算出总页面数量，排除页面索引值超出限制可能会带来的异常，还有需要计算当前页面查询时对应的记录起始位置，组合分页查询条件pagin&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;########################################################&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 page_size = 10
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总分页数量：通过总记录数除于每页显示数量来计算总分页数量&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断页码是否超出限制，超出限制查询时会出现异常，所以将页面索引设置为最后一页&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面值&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置（limit指定的位置）&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　最后，我们组合最终查询条件，查询并输出结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 按条件查询数据库记录&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select %(column_name_list)s from %(table_name)s %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;               {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column_name_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: column_name_list,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: table_name,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: orderby,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不需要分页查询时，直接在这里设置总记录数&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; len(result)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; data
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　完整代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;def&lt;/span&gt; get_list(self, column_name_list=&lt;span&gt;''&lt;/span&gt;, wheres=&lt;span&gt;''&lt;/span&gt;, page_number=None, page_size=None, orderby=None, table_name=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        获取指定条件的数据库记录集
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        :param column_name_list:      查询字段
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        :param wheres:      查询条件
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        :param page_number:   分页索引值
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        :param page_size:    分页大小， 存在值时才会执行分页
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        :param orderby:     排序规则
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :param table_name:     查询数据表，多表查询时需要设置
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        :return: 返回记录集总数量与分页记录集
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {'records': 0, 'total': 0, 'page': 0, 'rows': []}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出参数：总记录数量与列表集&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总记录数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0,     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总页数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1,      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前页面索引&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [],     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询结果（记录列表）&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询数据表名称&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; table_name:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             table_name = self.&lt;span&gt;__table_name&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询字段名&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; column_name_list:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             column_name_list = self.&lt;span&gt;__column_name_list&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化查询条件&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是字符串，表示该查询条件已组装好了，直接可以使用&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(wheres, str):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; wheres
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是list，则表示查询条件有多个，可以使用join将它们用and方式组合起来使用&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt;&lt;span&gt; isinstance(wheres, list):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(wheres)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; orderby:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             orderby = self.&lt;span&gt;__pk_name&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化分页查询的记录区间&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         paging = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         with db_helper.PgHelper(self.&lt;span&gt;__db&lt;/span&gt;, self.&lt;span&gt;__is_output_sql&lt;/span&gt;&lt;span&gt;) as db:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否需要进行分页&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from %(table_name)s %(wheres)s &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                       {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: table_name, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置记录总数量&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;########################################################&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     page_size = 10
&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总分页数量：通过总记录数除于每页显示数量来计算总分页数量&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                     page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断页码是否超出限制，超出限制查询时会出现异常，所以将页面索引设置为最后一页&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                     page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面值&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置（limit指定的位置）&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;                 record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;                 paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 按条件查询数据库记录&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;             sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select %(column_name_list)s from %(table_name)s %(wheres)s order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                   {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column_name_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: column_name_list,
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;table_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: table_name,
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wheres&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: wheres,
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: orderby,
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             result =&lt;span&gt; db.execute(sql)
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                 data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不需要分页查询时，直接在这里设置总记录数&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; len(result)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; data
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　我们在单元测试中跑一跑，看看结果吧&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/evn python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; common.string_helper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; string
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; logic &lt;span&gt;import&lt;/span&gt;&lt;span&gt; product_logic
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DbHelperTest(unittest.TestCase):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;数据库操作包测试类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------ini------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;清理测试环境&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;------clear------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只需要看这里，其他代码是测试用例的模板代码 #&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化product表操作类ProductLogic&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         _product_logic =&lt;span&gt; product_logic.ProductLogic()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         result = _product_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, 1, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#############################################&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　输出结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; -- -- --ini-- -- --
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;place_of_origin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;front_cover_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201808031245678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality_guarantee_period&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: datetime.datetime(2018, 8, 3, 16, 51, 3&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 15&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }, {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;place_of_origin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;front_cover_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201807251234568&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quality_guarantee_period&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: datetime.datetime(2018, 8, 3, 0, 14, 14&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 14&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; -- -- --clear-- -- --
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　前面的接口我们也改造一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产品分类id&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     product_class_id = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;产品分类id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类型&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     type = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询条件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     wheres =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; product_class_id &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         wheres.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_class_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(product_class_id))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否是前台提交获取数据&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; type != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backstage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         wheres.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     orderby =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         orderby = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化product表操作类ProductLogic&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     _product_logic =&lt;span&gt; product_logic.ProductLogic()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     result = _product_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, wheres, page_number, page_size, orderby)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(result, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　这样处理以后，代码看起来舒服多了&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;博客园&lt;/span&gt;&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;AllEmpty&lt;/span&gt;&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:20:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<og:description>在开发中，查询操作是使用最多的，而查询列表是其中之一，查询列表可分为分页查询和不分页查询（它们之间多了一次总记录数查询），还可以分为单表查询和多表关联查询，返回的结构体根据前端使用的表单框架不同而有所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/9483706.html</dc:identifier>
</item>
<item>
<title>初识机器学习——吴恩达《Machine Learning》学习笔记（十三） - Ta来自江湖</title>
<link>http://www.cnblogs.com/haifengbolgs/p/9484027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifengbolgs/p/9484027.html</guid>
<description>&lt;h3&gt;&lt;span&gt;无监督学习介绍(Unsupervised learning introdution)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;无监督学习：数据并没有任何的标签，通过算法，找出隐含在这些数据中的结构。聚类算法是一种无监督学习算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚类(clustering)分析将数据划分成有意义或有用的簇。聚类分析是一种分类的多元统计分析方法。按照个体或样品的特征将它们分类，使同一类别内的个体具有尽可能高的同质性(homogeneity)，而类别之间则应具有尽可能高的异质性(heterogeneity)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;聚类的应用：市场划分(Market segmentation)、社交网络分析(Social network analysis)、组织计算机集群(Organize computing clusters)、天文学数据分析(astronomical data analysis)等&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;K-means算法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;K-means算法是目前最热门的、应用最广泛的一共聚类算法。K-means算法是一种迭代算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随机初始化K个聚类中心。&lt;br/&gt;重复：&lt;br/&gt;1、聚类样本分配。把各样本x分配到最近的聚类中心。&lt;br/&gt;2、移动族类中心。每个中心分配各x之后，对每个中心k分配的各x求平均，然后赋值给μ(k)，相当于更新了聚类中心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直到聚类中心不再改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果遇到没有点的聚类中心，怎么办？最直接的做法是，把那个聚类中心移除掉！实际上很少会出现这种情况。大写的K表示簇类中心的个数，而小写的k则表示簇类中心的下标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180814202957157-1739213333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;优化目标(Optimization objective)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;K-means代价函数也叫失真代价函数，K-means算法的失真。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先最小化训练集到聚类中心的距离，再最小化聚类中心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180815201059578-686669447.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;随机初始化(Random initialization)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先，要求聚类中心K值小于训练集m值，然后，随机选择K个训练集元素作为K个聚类中心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180815203454348-1317365379.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为了找到最优解，或者说，避免区部最优解，应该尝试进行多次初始化聚类中心，然后选择畸变最小的，即代价函数最小的，一般次数为50-1000次。&lt;/p&gt;
&lt;p&gt;当K比较小时（2-10），多次初始化效果可能比较明显，当K比较大时，多次初始化效果可能不是很明显。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180815204616433-1774429906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;选择聚类数量(Choosing the number of clusters)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;肘部方法（肘部法则），K数量选择在肘部，但J对K数量的下降曲线很平滑，就会遇到难以选择K的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180815210444082-195018120.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;另一种选择聚类中心的方法是根据接下来的用途目的来作选择，哪个表现更好，就选哪个。例如，T恤尺寸的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436188/201808/1436188-20180815210633367-147960942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 13:07:00 +0000</pubDate>
<dc:creator>Ta来自江湖</dc:creator>
<og:description>无监督学习（Unsupervised learning) 无监督学习介绍(Unsupervised learning introdution) 无监督学习：数据并没有任何的标签，通过算法，找出隐含在这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifengbolgs/p/9484027.html</dc:identifier>
</item>
<item>
<title>深度解析Java中的那把锁 - Nicky160330</title>
<link>http://www.cnblogs.com/nicky-160330/p/9483821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nicky-160330/p/9483821.html</guid>
<description>&lt;p&gt;我们先来讨论锁的出现是为了解决什么问题，锁要保证的事情其实很好理解，同一件事（一个代码块）在同一时刻只能由一个人（线程）操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里所说的锁为排他锁，暂不考虑读写锁的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在这里打个比方，假设有10个人要过独木桥（独木桥只能承载一个人的重量），他们可以排好队一个一个的过，后面一个人看到前面过去了之后他便跟着过去，直到所有的人都过去。&lt;/p&gt;
&lt;p&gt;那如果我们用计算机模拟这个过程呢，没错，我们的程序不会排好队，更不会有看到前面的人已经通过这种主观能动性。所以这有点类似于所有的人都是蒙着眼睛的，但他们的听力是良好的，如果有人过去了之后在桥的另一头大喊一声“我已经通过了”，其他人便开始争着喊“下一个我过”。如果两个人几乎同时喊，在现实中我们很难搞清楚谁先谁后，甚至两个暴躁的人会打起来。但在计算机中他们不会，他们都如此听话如此可靠，而且在时间上总会分清谁先谁后，不会出现同时喊的状况。&lt;/p&gt;
&lt;p&gt;我们先来总结一下这个过程正常工作的&lt;strong&gt;两个先决条件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一时刻，只能有一个人抢到锁（过桥的权利）&lt;/li&gt;
&lt;li&gt;当操作完成之后，必须释放锁（过去桥之后，要告诉其他人现在可以过桥了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很简单，对吧，但锁的真正意义就在于此，只是不同的场景对这两点有不同的实现方式罢了。&lt;/p&gt;

&lt;h2 id=&quot;可见性&quot;&gt;可见性&lt;/h2&gt;
&lt;p&gt;提到Java中的锁，就不得不提Java的内存模型，如下图（假设在多核CPU上），这里可以使CPU的一个核心类比一个线程（这是一个简化的模型，事实上比这个模型复杂的多）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1461336/201808/1461336-20180815202439979-392924756.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：这里只是类比，CPU的Cache与JMM中的工作内存并不严格一致，但两者有一定交集，在这里做这样的类比并不会误导我们想要的出来的结论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读到这里或许有的读者会有问题，为什么CPU要把数据抓到工作内存去，而不是直接从主内存里面拿呢。这要从计算机的组成原理上讲起，CPU和内存在物理上是分离的，CPU从主存抓取数据如同远房探亲。从主内存中抓取数据比对数据的操作上要快数十倍甚至上百倍。这有点像你想和小明打一个小时游戏，但是要花几天甚至数十天的时间把小明请过来。这样为了省时间，我们可以把小明请过来，多打几天游戏在让他回去。事实上也的确如此，我们的CPU之所以要在Cache 中操作之前Fetch过来的数据，就是为了节省这一段时间。但这就在两个Thread中产生两个副本，而他们互相不知道对方有没有更改过cache到的数据。但充满智慧的CPU架构师给出了这种通知的保证（MESI协议，这大概是相当早的分布式缓存一致性解决方案了），这个协议的原理比较复杂，在此不在赘述，但这并不影响我们对锁的理解。我们只要知道，操作系统提供了这样的支持，并留给了&lt;code&gt;system call&lt;/code&gt;的&lt;code&gt;native api&lt;/code&gt;就足够了。这个方案解决了CPU对变量的&lt;strong&gt;可见性&lt;/strong&gt;。在java中通过使用&lt;code&gt;volatile&lt;/code&gt;实现变量的可见性保证，而其保证的原理正是借助与CPU的缓存一致性协议实现的，操作系统将其抽象为&lt;code&gt;lock&lt;/code&gt;操作，&lt;/p&gt;
&lt;h2 id=&quot;原子性&quot;&gt;原子性&lt;/h2&gt;
&lt;p&gt;似乎有了可见性对元素的操作就完全可靠了，但事实并非如此，这取决于对变量进行操作的过程，我们i++为例说明这一点，但在此之前，我们先来看一下i++在Java中的执行过程&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    static int i=1;
    public static void main(String[] args) {
        i++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用&lt;code&gt;javap -verbose Test.class&lt;/code&gt;查看Java中main方法的虚指令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0: getstatic     #2                  // Field i:I
3: iconst_2
4: iadd
5: putstatic     #2                  // Field i:I
8: return&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个过程的语义与下图相同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1461336/201808/1461336-20180815202451063-1011940673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考虑以下情况，在第三步回写的过程中算出的结果已经保留了，假设线程A在此卡顿了一会儿，其他线程已经更改了i的值，然后线程A才回过神来，但结果还是刚才算出的结果3，这时它进行回写操作的时候，就会覆盖其他线程对i的赋值，就会导致值的不一致现象。&lt;/p&gt;
&lt;p&gt;可以看到，之所以会出现这种现象，就是因为i++这个操作没有像我们想象的那样，一下子就完成，而是分成了很多步。我们称这种操作为非原子性操作，就是i++操作的非原子性，导致在哪怕保证了变量的可见性的情况下仍然会导致数据操作相互覆盖（线程不安全）的情况。&lt;/p&gt;
&lt;h2 id=&quot;隔离区临界区&quot;&gt;隔离区（临界区）&lt;/h2&gt;
&lt;p&gt;终于讲到Java中的锁了，根据独木桥的例子，要想保证多个线程对变量的操作绝对安全，就要保证对变量操作的串行化。Java中使用&lt;code&gt;synchronized&lt;/code&gt;关键字提供了前文提到过的两个先决条件。下面我们来详讲一下java中的&lt;code&gt;synchronized&lt;/code&gt;关键字。我们先来看以下代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        synchronized (Test.class) {
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样使用&lt;code&gt;javap -verbose Test.class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0: ldc           #2                  // class Test
2: dup
3: astore_1
4: monitorenter
5: aload_1
6: monitorexit
7: goto          15
10: astore_2
11: aload_1
12: monitorexit
13: aload_2
14: athrow
15: return&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们重点看monitorenter和monitorexit两个指令，根据我们前面所讲的两个先决条件，我们至少可以推断monitorenter在背后所做的事情有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;告诉其他线程，我拿到了锁（下一个过独木桥的人）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而monitorexit在背后做的事情当有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;告诉其他线程，我释放了锁（你们可以过桥了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里其实还有个问题，它标示锁的方式是什么，这就要提到java对象在内存中的模型了，事实上Test.class对象在内存中有个头部，通过设置这个对象头获取该对象的锁，而对这个锁的设置操作是用指令&lt;code&gt;cmpxchg&lt;/code&gt;保证原子性的，由操作系统和硬件底层支持。&lt;/p&gt;
&lt;p&gt;事实上Java对锁进行了优化，包括偏向锁和轻量级锁。所以通不通知其他线程并不是那么绝对的，而且monitor背后所做的事情也绝对不是这么简单，在这个模型中，其他线程确认自己有没有获得锁是主动过来看Test.class的对象头有没有被设置为已获取锁状态。如果没有，自己就上锁。如果已经被锁住了，这个线程就需要发出&lt;code&gt;system call&lt;/code&gt;来阻塞自己，但Java自己做不了这件事情，它必须借助操作系统完成，借助操作系统发出&lt;code&gt;system call&lt;/code&gt;到自己被阻塞这个过程需要几万的个时钟周期。而这个代价是相当昂贵的，对于CPU的执行速度来说，几万个时钟周期可以做很多的事情，这时如果我们乐观的认为，这个锁马上就能释放，我就愿意花费几百个时钟周期不停的判断这个锁是否释放，总比调用&lt;code&gt;system call&lt;/code&gt;的开销要低一些，这就是&lt;strong&gt;乐观锁&lt;/strong&gt;的原理。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;synchronized&lt;/code&gt;释放锁之前，任何线程都不能进入&lt;code&gt;synchronized&lt;/code&gt;的方法体内，不管在中间有多少操作，其他线程都必须等待操作完成之后释放锁的通知，这就保证了数据在多线程的绝对安全。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;同时，在上面的字节码可以看出，当程序顺序执行时，在第6步monitorexit之后，会直接跳转到底15步返回，但若中间发生了异常，会在第12步先monitorexit然后，在抛出异常，这其实是编译器替我们完成了加锁和释放锁的过程，而且编译器替我们做了在发生异常的情况下也释放锁的保证。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 15 Aug 2018 12:28:00 +0000</pubDate>
<dc:creator>Nicky160330</dc:creator>
<og:description>探讨Java中的锁的实现方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nicky-160330/p/9483821.html</dc:identifier>
</item>
</channel>
</rss>