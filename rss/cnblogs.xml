<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 WebGL 的 3D 服务器与客户端的通信 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8124629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8124629.html</guid>
<description>&lt;p&gt;这个例子的初衷是模拟服务器与客户端的通信，我把整个需求简化变成了今天的这个例子。3D 机房方面的模拟一般都是需要鹰眼来辅助的，这样找产品以及整个空间的概括会比较明确，在这个例子中我也加了，这篇文章就算是我对这次项目的一个总结吧。对了，这个例子我是参考一个 DEMO 来完成的，和示例中的显示有些不同，大家莫惊奇。&lt;/p&gt;
&lt;p&gt;例子链接： &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/schedule/examples/example_network.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/guide/core/schedule/examples/example_network.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171227074422135-950653773.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子没有设计师的参与，样式上面大家将就将就，但是我觉得还不错啊，哈哈~&lt;/p&gt;
&lt;p&gt;进入正题，整个例子差不多用了 200 行的代码来实现的，这就是我喜欢用 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT&lt;/a&gt; 的原因，现在 Web3d 技术兴起，大体就是分为两派：插件派和 HTML5 派。HT 就是基于 HTML5 的，不需要安装任何插件，啊，跑题了。。。&lt;/p&gt;
&lt;p&gt;首先，还是从场景的搭建开始，这个界面是在 body 体上添加了三个部分：3d 组件，属性组件以及拓扑组件（2d 组件）。添加的方式是这样的：为了最外层组件加载填充满窗口的方便性，HT 的所有组件都有 addToDOM 函数，其实现逻辑如下，其中 iv 是 invalidate 的简写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){   
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
        view &lt;/span&gt;=&lt;span&gt; self.getView(),   
        style &lt;/span&gt;=&lt;span&gt; view.style;
    document.body.appendChild(view);            
    style.left &lt;/span&gt;= '0'&lt;span&gt;;
    style.right &lt;/span&gt;= '0'&lt;span&gt;;
    style.top &lt;/span&gt;= '0'&lt;span&gt;;
    style.bottom &lt;/span&gt;= '0'&lt;span&gt;;      
    window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt; () { self.iv(); }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这个函数是将 style 中的位置都固定了，所以不能将所有的组件都用这个函数，我们按照这个函数的方式将拓扑组件和属性组件添加进界面中，3d 组件直接利用 addToDOM 函数即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.DataModel();
g3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3d 组件&lt;/span&gt;
g3d.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将组件添加进 body 体中&lt;/span&gt;
g3d.setDashDisabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启虚线流动&lt;/span&gt;
g3d.setMovableFunc(&lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重载移动函数&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回false，所有的图元都不可移动&lt;/span&gt;
&lt;span&gt;});
g3d.setEye([&lt;/span&gt;-813, 718, 1530]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 eye &lt;/span&gt;
g3d.setCenter([140, -25, 217]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 center（target）&lt;/span&gt;
gv = &lt;span&gt;new&lt;/span&gt; ht.graph.GraphView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2d 组件&lt;/span&gt;
gv.getView().className = 'graphview';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HT 组件根层都是一个 div，通过 getView() 函数获取&lt;/span&gt;
document.body.appendChild(gv.getView());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拓扑组件添加进 body 体中&lt;/span&gt;
gv.fitContent(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩放平移整个拓扑以展示所有的图元&lt;/span&gt;
&lt;span&gt;
propertyView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.widget.PropertyView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性组件   &lt;/span&gt;
propertyView.getView().className = 'property'&lt;span&gt;;
propertyView.setWidth(&lt;/span&gt;240);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置组件宽度&lt;/span&gt;
propertyView.setHeight(150);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高度&lt;/span&gt;
document.body.appendChild(propertyView.getView());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拓扑组件和属性组件的样式我就不再赘述了，只是设置了一个背景颜色以及 left right top bottom 位置而已。这里要声明一下，HT 组件一般都以设置 position 为 absolute 的绝对定位方式。&lt;/p&gt;
&lt;p&gt;大家可能会好奇，这个鹰眼怎么生成的？在 HT 中，只要 2D 和 3D 共用同一个数据容器 dataModel 即可共同拥有所有在这个 dataModel 中的元素，并且位置都是对应的，只需要类似这种做法即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.DataModel();
g3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView(dm);
gv &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.graph.GraphView(dm);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171227104605838-396841174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;是不是非常简单。。。可以省去大把时间开发。。。&lt;/p&gt;
&lt;p&gt;这个例子中除了连线之外的所有元素都是 ht.Node 类型的节点，所以我们将这个节点的创建方法封装一下，好重复利用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createNode(p3, s3, name, shape){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建节点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; ht.Node();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建类型为 ht.Node 类的节点&lt;/span&gt;
    dm.add(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点添加进数据容器 dataModel 中&lt;/span&gt;
    node.s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的样式，s 为 setStyle 的简写&lt;/span&gt;
        'shape3d': shape,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定节点的形体，这边是传入 3d 模型的 json 文件&lt;/span&gt;
        'label.position': 23,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字显示位置&lt;/span&gt;
        'label.transparent': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字在3d下是否透明 可消除字体周围的锯齿&lt;/span&gt;
        'label.color': '#eee',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字颜色&lt;/span&gt;
        'label.t3': [0, 0, -151],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字在3d下的偏移&lt;/span&gt;
        'label.r3': [0, Math.PI, 0],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字在3d下的旋转&lt;/span&gt;
        'label.scale': 2&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字缩放&lt;/span&gt;
&lt;span&gt;    });
    node.r3(&lt;/span&gt;0, Math.PI, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点旋转&lt;/span&gt;
    node.p3(p3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点在 3d 下的位置&lt;/span&gt;
    node.s3(s3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点在 3d 下的大小&lt;/span&gt;
    node.setName(name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的显示名称&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; node;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回节点&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及连线的创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createEdge(exchange, service){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连线&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; edge = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Edge(exchange, service);
    dm.add(edge);
    edge.s({
        &lt;/span&gt;'edge.width': 4,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线宽度&lt;/span&gt;
        'edge.color': 'red',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线颜色&lt;/span&gt;
        'edge.dash': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否显示虚线&lt;/span&gt;
        'edge.dash.color': 'yellow',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚线颜色&lt;/span&gt;
        'edge.dash.pattern': [32, 32],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线虚线样式默认为[16, 16]&lt;/span&gt;
&lt;span&gt;    });
    edge.a({&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户自定义属性 为 setAttr 的缩写&lt;/span&gt;
        'flow.enable': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否启用流动&lt;/span&gt;
        'flow.direction': 1,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方向&lt;/span&gt;
        'flow.step': 4&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步进&lt;/span&gt;
&lt;span&gt;    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; edge;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们界面中的显示的连线都是虚线流动的，HT 默认是关闭虚线流动的功能的，通过下面这句来开启虚线流动的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
g3d.setDashDisabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启虚线流动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时我们还需要设置动画，控制时间间隔，使得连线虚线偏移，形成一种“流动”的状态，动画请参考 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/schedule/ht-schedule-guide.html&quot; target=&quot;_blank&quot;&gt;schedule 调度手册&lt;/a&gt;：&lt;code&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
flowTask =&lt;span&gt; {
    interval: &lt;/span&gt;40&lt;span&gt;,
    action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.a('flow.enable'&lt;span&gt;)){
            data.s(&lt;/span&gt;'edge.dash.offset', data.s('edge.dash.offset')+(data.a('flow.step')*data.a('flow.direction'&lt;span&gt;)));
        }
    }
};
dm.addScheduleTask(flowTask);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加flowTask动画&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是界面上出现的所有的服务器以及客户端的节点的声明，都是基于 createNode 和 createEdge 函数创建的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;161&quot;&gt;
&lt;pre&gt;
floor = createNode([0, 5, 0], [1000, 10, 500]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地板图元&lt;/span&gt;
floor.s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图元的样式 s 为 setStyle 的缩写&lt;/span&gt;
    'all.color': 'rgb(47, 79, 79)'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;六面体的整体颜色&lt;/span&gt;
&lt;span&gt;});

exchange &lt;/span&gt;= createNode([0, 300, -400], [200, 20, 150], 'H3C 核心交换机', 'models/机房/机柜相关/机柜设备6.json');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;五台不同作用的服务器&lt;/span&gt;
service1 = createNode([-400, 140, 0], [100, 260, 100], '备用', 'models/机房/机柜相关/机柜2.json'&lt;span&gt;);
service2 &lt;/span&gt;= createNode([-200, 140, 0], [100, 260, 100], '网站', 'models/机房/机柜相关/机柜2.json'&lt;span&gt;);
service3 &lt;/span&gt;= createNode([0, 140, 0], [100, 260, 100], 'OA', 'models/机房/机柜相关/机柜2.json'&lt;span&gt;);
service4 &lt;/span&gt;= createNode([200, 140, 0], [100, 260, 100], '广告', 'models/机房/机柜相关/机柜2.json'&lt;span&gt;);
service5 &lt;/span&gt;= createNode([400, 140, 0], [100, 260, 100], '受理', 'models/机房/机柜相关/机柜2.json'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建交换机与服务器之间的连线&lt;/span&gt;
&lt;span&gt;createEdge(exchange, service1);
createEdge(exchange, service2);
createEdge(exchange, service3);
createEdge(exchange, service4);
createEdge(exchange, service5);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二台交换机&lt;/span&gt;
exchange2 = createNode([-100, 60, 400], [200, 20, 150], 'Procurve Switch 2010-23 交换机', 'models/机房/机柜相关/机柜设备6.json').s('label.color', '#000'&lt;span&gt;);

createEdge(exchange2, service1);
createEdge(exchange2, service2);
createEdge(exchange2, service3);
createEdge(exchange2, service4);
createEdge(exchange2, service5);

floor2 &lt;/span&gt;= createNode([-100, 5, 800], [1000, 10, 500&lt;span&gt;]);
floor2.s({
    &lt;/span&gt;'all.color': 'rgb(47, 79, 79)'&lt;span&gt;
});

device1 &lt;/span&gt;= createNode([-400, 20, 650], [200, 20, 100], 'VLS 12000(上)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);
device2 &lt;/span&gt;= createNode([100, 20, 650], [200, 20, 100], 'VLS 12000(下)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);
device3 &lt;/span&gt;= createNode([-200, 20, 800], [200, 20, 100], 'HP Strage Works 8/8 SAN Switch(上)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);
device4 &lt;/span&gt;= createNode([200, 20, 800], [200, 20, 100], 'HP Strage Works 8/8 SAN Switch(下)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);
device5 &lt;/span&gt;= createNode([-300, 20, 950], [200, 20, 100], 'EVA 8400 HSV450(上)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);
device6 &lt;/span&gt;= createNode([100, 20, 950], [200, 20, 100], 'EVA 8400 HSV450(下)', 'models/机房/机柜相关/机柜设备6.json'&lt;span&gt;);

createEdge(exchange2, device1);
edge1 &lt;/span&gt;=&lt;span&gt; createEdge(exchange2, device2);
createEdge(device1, device3);
createEdge(device1, device4);
createEdge(device2, device3);
createEdge(device2, device4);
createEdge(device3, device5);
createEdge(device3, device6);
createEdge(device4, device5);
createEdge(device4, device6);
dm.sm().ss(edge1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置选中 edge1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，需要在属性栏中添加属性，这里我们只对“连线”进行了属性的显示及调整，总共 5 个属性，包括我通过 setAttr（简写为 a）自定义的属性 flow.enable、flow.direction、flow.step 和样式属性 edge.color 以及 edge.dash.color。我们通过 name 属性结合 accessType 属性实现对 Data 节点的存取：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171227104449323-865352197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线的属性&lt;/span&gt;
edgeProperties =&lt;span&gt; [
    {
        name: &lt;/span&gt;'flow.enable',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存取 name 属性&lt;/span&gt;
        accessType: 'attr',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作存取属性类型&lt;/span&gt;
        displayName: 'Enable Flow',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存取属性名的显示文本值，若为空则显示 name 属性值&lt;/span&gt;
        valueType: 'boolean',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于提示组件提供合适的 renderer 渲染，boolean 类型，显示为勾选框&lt;/span&gt;
        editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该属性是否可编辑&lt;/span&gt;
&lt;span&gt;    },
    {
        name: &lt;/span&gt;'flow.direction'&lt;span&gt;,
        accessType: &lt;/span&gt;'attr'&lt;span&gt;,
        displayName: &lt;/span&gt;'Flow Direction'&lt;span&gt;,
        enum: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;枚举类型属性 传递数值和文字数组&lt;/span&gt;
            values: [-1, 1&lt;span&gt;],
            labels: [&lt;/span&gt;'正向流动', '反向流动'&lt;span&gt;]
        },
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
    {
        name: &lt;/span&gt;'flow.step'&lt;span&gt;,
        displayName: &lt;/span&gt;'Flow Step'&lt;span&gt;,                        
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        accessType: &lt;/span&gt;'attr'&lt;span&gt;,
        slider: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单插件中的滑动条 所以要添加 ht-form.js &lt;/span&gt;
            min: 0,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小值&lt;/span&gt;
            max: 10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大值&lt;/span&gt;
            step: 0.1&lt;span&gt;//&lt;/span&gt;&lt;span&gt;步进&lt;/span&gt;
&lt;span&gt;        }
    },
    {
        name: &lt;/span&gt;'edge.color'&lt;span&gt;,
        accessType: &lt;/span&gt;'style'&lt;span&gt;,
        displayName: &lt;/span&gt;'Edge Color'&lt;span&gt;,
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        valueType: &lt;/span&gt;'color',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色类型，以填充背景色的方式显示&lt;/span&gt;
        colorPicker: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色选择框&lt;/span&gt;
            instant: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取和设置是否处于即时状态，默认为true，代表作为表格和属性页的编辑器时，将实时改变模型值&lt;/span&gt;
&lt;span&gt;        }
    },
    {
        name: &lt;/span&gt;'edge.dash.color'&lt;span&gt;,
        displayName: &lt;/span&gt;'Dash Color'&lt;span&gt;,
        accessType: &lt;/span&gt;'style'&lt;span&gt;,
        valueType: &lt;/span&gt;'color'&lt;span&gt;,
        editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        colorPicker: {
            instant: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    }
];
propertyView.setEditable(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置属性组件可编辑&lt;/span&gt;
propertyView.addProperties(edgeProperties);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加连线属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是非常简单~  快动手实践一下吧！&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 22:37:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8124629.html</dc:identifier>
</item>
<item>
<title>go基础之--函数和map - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8129424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8129424.html</guid>
<description>&lt;p&gt;在整理函数之前先整理一下关于指针&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;指针&lt;/h2&gt;
&lt;p&gt;普通类型变量存的就是值，也叫值类型。指针类型存的是地址，即指针的值是一个变量的地址。&lt;br/&gt;一个指针指示值所保存的位置，不是所有的值都有地址，但是所有的变量都有。使用指针可以在无序知道&lt;br/&gt;变量名字的情况下，间接读取或更新变量的值。&lt;/p&gt;
&lt;p&gt;获取变量的地址，用&amp;amp;,例如:var a int 获取a的地址:&amp;amp;a，&amp;amp;a(a的地址)这个表达式获取一个指向整形变量的指针，它的类型是整形指针(*int),如果值叫做p,我们说p指向x,或者p包含x的地址，p指向的变量写成&lt;br/&gt;*p ，而*p获取变量的值，这个时候*p就是一个变量，所以可以出现在赋值操作符的左边，用于更新变量的值&lt;/p&gt;
&lt;p&gt;指针类型的零值是nil&lt;br/&gt;两个指针当且仅当指向同一个变量或者两者都是nil的情况才相等&lt;/p&gt;
&lt;p&gt;通过下面小例子进行理解指针：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;func test() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     x := 1
&lt;span&gt; 9&lt;/span&gt;     // &amp;amp;&lt;span&gt;x 获取的是变量x的地址，并赋值给p,这个时候p就是一个指针
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     p := &amp;amp;&lt;span&gt;x
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     // p是指针，所以*p获取的就是变量的值，指针指向的是变量x的值，即*&lt;span&gt;p为1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     fmt.Println(*&lt;span&gt;p)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     // 这里*&lt;span&gt;p 进行赋值，也就是更改了变量x的值，即实现不知道变量的名字更改变量的值
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     *p = 2
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    fmt.Println(x)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    test()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看一个关于通过一个函数来修改变量值的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; func modify(num &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     num = 100
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     a := 10
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    modify(a)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    fmt.Println(a)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子是修改变量的值，但是最后打印变量a的值是还是10，所以这里就需要知道，当通过定义的函数modify来修改变量的值时，传入变量a其实会进行一次拷贝，传入的其实是a变量的一个副本，所以当通过&lt;br/&gt;modify修改的时候修改的是副本的值，并没有修改变量a的值。&lt;br/&gt;当我们理解指针的之后，就可以通过指针的的方法来解决上面的这个问题，将代码更改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; func modify(num *&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     *num = 100
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     a := 10
&lt;span&gt;13&lt;/span&gt;     modify(&amp;amp;&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    fmt.Println(a)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里定义modify函数的时候参数设置的是一个指针，所以我们传入参数时，传入的是&amp;amp;a即变量a的地址，而这个地址指向的值是10，虽然这次传入的参数也是进行了传入的指针进行了一次拷贝，但是即使是拷贝了副本指向的值还是10，所以当我们通过指针*num修改值的时候其实就是在修改变量a的值。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;内置函数&lt;/h2&gt;
&lt;p&gt;len: 用于求长度，比如string、array、slice、map、channel&lt;br/&gt;new: 来分配内存，主要来分配值类型，如int、struct。返回的是指针&lt;br/&gt;make: 来分配内存，主要 来分配引 类型， 如chan、map、slice&lt;br/&gt;append: 来追加元素到数组、slice中&lt;br/&gt;panic和recover: 来做错误(这个后续整理)&lt;/p&gt;
&lt;p&gt;下面重点整理new和make&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;new函数&lt;/h3&gt;
&lt;p&gt;func new(Type) *Type&lt;br/&gt;先看一下官网对这个内置函数的介绍：&lt;br/&gt;内置函数 new 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针。这里要特别注意new返回的是一个指针&lt;/p&gt;
&lt;p&gt;new函数也是创建变量的一种方式。表达式new(T)创建一个未命名的T类型变量，初始化T类型的零值，并返回其地址(地址类型为*T)&lt;/p&gt;
&lt;p&gt;通过下面例子进行理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; import &quot;fmt&quot;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;func newFunc() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     p := new(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     fmt.Println(p)  //&lt;span&gt;打印是地址
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     fmt.Println(*p) //&lt;span&gt;int类型的零值为0这里打印0
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     *p = 2
&lt;span&gt;10&lt;/span&gt;     fmt.Println(*p) /&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;p已经为其地址指向了一个变量2,所以这里打印为2
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    newFunc()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们要知道new创建的变量和取其地址的普通局部变量没有什么不同，只是语法上的便利&lt;br/&gt;下面是两种方式的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; func newInt() *&lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     return new(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; func newInt2() *&lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     var res &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     return &amp;amp;&lt;span&gt;res
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们定义一个指针是不能直接给这个指针赋值的，而是需要先给这个指针分配内存，然后才能赋值&lt;br/&gt;下面例子先不初始化分配内存，直接赋值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/997599/201712/997599-20171228010359175-93570944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的做法是我们需要先通过new初始化，正确代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;func test(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     var p *&lt;span&gt;int&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     p = new(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     *p = 10
&lt;span&gt;11&lt;/span&gt;     fmt.Println(*&lt;span&gt;p)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;func main(){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    test()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;make函数&lt;/h3&gt;
&lt;p&gt;func make(Type, size IntegerType) Type&lt;br/&gt;先看一下官网对这个内置函数的介绍：&lt;br/&gt;内置函数make用来为slice,map或chan类型分配内存或初始化一个对象(这里需要注意：只能是这三种类型)&lt;br/&gt;第一次参数也是一个类型而不是一个值&lt;br/&gt;返回的是类型的引用而不是指针，而且返回值也依赖具体传入的类型&lt;br/&gt;注意：make返回初始化后的（非零）值。&lt;/p&gt;
&lt;p&gt;其实在上一篇整理切片slice的时候就用到了make如：&lt;br/&gt;make([]type,len)&lt;br/&gt;当时通过make来初始化slice的时候，第二个参数指定了它的长度，如果吗，没有第三个参数，它的容量和长度相等，当然也可以传入第三个参数来指定不同的容量值，但是注意不能比长度值小&lt;/p&gt;
&lt;p&gt;这里提前说一下通过make初始化map的时候，根据size大小来初始化分配内存，不过分配后的map长度为0，如果size被忽略了，会在初始化分配内存的时候分配一个小的内存&lt;/p&gt;
&lt;p&gt;关于new和make的一个小结：&lt;br/&gt;new 的作用是初始化一个指向类型的指针 (*T)，make的作用是为slice,map或者channel初始化，并且返回引用 T&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;函数&lt;/h2&gt;
&lt;p&gt;函数的声明语法：func 函数名 (参数 表) [(返回值 表)] {}&lt;br/&gt;这了要注意第一个花括号必须和func在一行&lt;/p&gt;
&lt;p&gt;常见的几种声明函数的方法：&lt;br/&gt;func add(){&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func add(a int,b int){&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func add(a int,b int) int{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func add(a int, b int)(int,int){&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func add(a ,b int)(int,int){&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;golang函数的特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不支持重载，即一个包不能有两个名字一样的函数&lt;/li&gt;
&lt;li&gt;函数也是一种类型，一个函数可以赋值给变量&lt;/li&gt;
&lt;li&gt;匿名函数&lt;/li&gt;
&lt;li&gt;多返回值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;演示一些函数的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; func add(a, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     return a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     c := add //&lt;span&gt;这里把函数名赋值给变量c
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     fmt.Printf(&quot;%p %T&quot;&lt;span&gt;, c, add)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     sum := c(10, 20) //&lt;span&gt;调用c其实就是在调用add
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    fmt.Println(sum)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;golang函数还有一个用法例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; type addFunc func(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; func add(a, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     return a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; func operator(op addFunc, a &lt;span&gt;int&lt;/span&gt;, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    return op(a, b)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     c :=&lt;span&gt; add
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     sum := operator(c, 100, 200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    fmt.Println(sum)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;变量作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在函数外面的变量是全局变量&lt;br/&gt;函数内部的变量是局部变量&lt;br/&gt;go中变量的作用域有多种情况：&lt;br/&gt;函数级别的，代码块级别的&lt;br/&gt;通过下面例子理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/997599/201712/997599-20171228010512597-171083851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于函数的可变参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变长函数被调用的时候可以有可变的参数个数&lt;br/&gt;在参数列表最后的类型名称前使用省略号...可以声明一个变长的函数，&lt;br/&gt;例如：&lt;br/&gt;0个或多个参数&lt;br/&gt;func add(arg...int) int{&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;1个或多个参数&lt;br/&gt;func add(a int,arg...int) int{&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;2个或多个参数&lt;br/&gt;func add(a int,b int,arg...int)int{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于函数参数的传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是值类型还是引用传递，传递给函数的都是变量的副本&lt;br/&gt;注意：map,slice,chan,指针，interface默认以引用方式传递&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延迟函数defer的调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法上，一个defer语句就是一个普通的函数或者方法调用，在调用之前加上关键字defer。函数和参数表达式会在语句执行时求值，但是无论是正常情况还是执行return语句或者函数执行完毕，以及不正常情况下，如程序发生宕机，实际的调用推迟到包含defer语句的函数结束后才执行，defer语句没有限制使用次数。&lt;/p&gt;
&lt;p&gt;defer用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当函数返回时，执行defer语句，因此可以用来做资源清理&lt;/li&gt;
&lt;li&gt;多个defer语句，按先进后出的方式执行&lt;/li&gt;
&lt;li&gt;defer语句中的变量，在defer声明时就决定了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先通过一个小例子理解defer:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;func testDefer(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     a := 100
&lt;span&gt;10&lt;/span&gt;     fmt.Printf(&quot;before defer:a=%d\n&quot;&lt;span&gt;,a)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    defer fmt.Println(a)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     a = 200
&lt;span&gt;13&lt;/span&gt;     fmt.Printf(&quot;after defer:a=%d\n&quot;&lt;span&gt;,a)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;func main(){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    testDefer()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以这样理解当我们执行defer语句的时a=100,这个时候压入到栈中，等程序最后结束的时候才会调用defer语句，所以打印的顺序是最后才打印一个数字100&lt;/p&gt;
&lt;p&gt;defer语句经常使用成对的操作，比如打开和关闭，连接和断开，加锁和解锁&lt;/p&gt;
&lt;p&gt;下面拿关闭一个打开文件操作为例子，当我们通过os.Open()打开一个文件的时候可以在后面添加defer f.Close() 这样在函数结束时就可以帮我们自动关闭一个打开的文件&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;Map类型&lt;/h2&gt;
&lt;p&gt;key-value的数据结构，又叫字典&lt;/p&gt;
&lt;p&gt;声明&lt;br/&gt;var map1 map[keytype]valuetype&lt;/p&gt;
&lt;p&gt;例子：&lt;br/&gt;var a map[string]string&lt;br/&gt;var a map[string]int&lt;/p&gt;
&lt;p&gt;注意：声明是不会分配内存的需要make初始化&lt;/p&gt;
&lt;p&gt;初始化的两种方式：&lt;br/&gt;var map[string]string = map[string][string]{&quot;hello&quot;,&quot;world&quot;}&lt;br/&gt;或：&lt;br/&gt;var a = make(map[string]string,10)&lt;/p&gt;
&lt;p&gt;插入和更新&lt;br/&gt;a[&quot;hello&quot;] = &quot;world&quot;&lt;/p&gt;
&lt;p&gt;查找&lt;br/&gt;val,ok := a[&quot;hello&quot;]&lt;/p&gt;
&lt;p&gt;遍历&lt;br/&gt;for k,v := range a{&lt;br/&gt;fmt.println(k,v)&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;删除&lt;br/&gt;delete(a,&quot;hello&quot;)&lt;/p&gt;
&lt;p&gt;长度&lt;br/&gt;len(a)&lt;/p&gt;
&lt;p&gt;map是引用类型&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 17:06:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8129424.html</dc:identifier>
</item>
<item>
<title>助力中小企业级连云端，促进工业互联网平台蓬勃发展，全套解决方案。附：技术产品 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/8128333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/8128333.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;总体方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;3.Super Link N1&lt;/strong&gt; &lt;strong&gt;一体化智能网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;4.ServerSuperIO&lt;/strong&gt;&lt;strong&gt;物联网通讯框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.SuperRTDB&lt;/strong&gt;&lt;strong&gt;高性能实时数据库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;6.SuperView Web&lt;/strong&gt;&lt;strong&gt;组态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;strong&gt;行业领域应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;8.&lt;/strong&gt;&lt;strong&gt;接入云端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;9.&lt;/strong&gt;&lt;strong&gt;工业互联网平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;strong&gt;．结束语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;1．概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      经过两年多团体的努力，四个产品终于面世了，做产品不容易，做好产品更不容易，最终形成了体系化的解决方案。下面具体介绍。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      行业大数据平台以及工业互联网平台的发展是必然趋势，结合自己的工作经验，在以前的BLOG中分析过，在此不再赘述。国外的工业平台以GE的Predix、西门子的MindSphere、ABB的 Ability为代表。从基础工业做起，并且有很多工业标准是他们制定的，建设工业互联网平台是从底层逐步向高层发展的必然选择，套用中国的说法是“工业+互联网”。中国的情况不一样，一是工业基础比较差，二是PLC层面国外厂家占据明显优势，国外的工业互联网平台大军进入中国，相当于整个工业生态都被国外企业所垄断，如果真是这个局面，那么“智能制造2025”就是一句空话。对工业相关政府部门以及工业企业的迫切性是显而易见的，不管是“弯道超车”还是“变道超车”，要找到一个切入点从而带动整体工业提升，也就是现在国家层面大力提倡的“互联网+工业”，也在推动“工业互联网平台”的建设。最近中国完成部署四台根服务器，以及推广IPV6的建设，这一系列的动作是组合拳。可能有些人狭隘的理解“工业互联网平台”只是一个云端平台，如果对标国外相关企业的情况，而是从底层到云端的体系化、标准化改变与提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      如果在工业领域有所大作为，那么“工业互联联网平台”是大公司的标配。这取决于需求方思维方式的改变，纵向从底层到顶层的整体架构、横向和数据流向不同业务系统异构集成，作为生产企业他们没有独立能力完成革命性的升级、改造，犹如当年调制解调（猫）到网线和光纤传输数据一样，现在比当年更需要勇气和能力去整合资源。“工业互联网平台”是大公司综合素质的体现，但是并不能狭隘的理解为一定要让生产企业上云平台，而是用“工业互联网”的思维去为用户服务。“工业互联网平台”最直接面向的两大用户群体：生产企业和为生产企业服务的中小企业，其他用户是从这两类用户基础上衍生出来的，例如：研究机构、上下游企业等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      不管做什么系统和平台都涉及到技术与业务，能把技术和业务都做的很好的公司很少，但是要想走的远，要学会技术和业务两条腿走路。“工业互联网平台”时代面临着技术重构和业务重构，在技术方面，需要使用物联网、分布式、大数据、实时计算、级联数据传输与控制等技术重构；在业务方面，需要整合不同的业务系统，例如：煤炭行业的6大系统的整合、冶金行业的整个工艺生产过程中涉及到各系统的整合等，但是业务的整合需要不断的迭代、完善的长期过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总之，在变革时代，从底层到顶层链路上的任何节点都有突破的机会。小公司没有建设平台的能力，但是不妨碍他们使用“工业互联网平台”和“工业互联网思维”去整合资源。下面介绍&lt;strong&gt;Super Link&lt;/strong&gt;、&lt;strong&gt;ServerSuperIO&lt;/strong&gt;、&lt;strong&gt;SuperRTDB&lt;/strong&gt;和&lt;strong&gt;SuperView&lt;/strong&gt;四个产品以及方案，帮助中小企业级联云平台或是自己建设行业云平台。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;2．总体方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        “工业互联网平台”大体分为：边缘区域和云端区域。针对生产企业和为生产企业服务的中小企业建设平台需要付出高昂的成本，所以在此不讨论云端建设问题，从技术体系提供边缘区域的整体建设方案。总体方案，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171227235852488-1569189775.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 边缘区域总体建设方案（&lt;strong&gt;橙色部分为实际产品&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        橙色部分的Super Link、ServerSuperIO、SuperRTDB和SuperView四个产品组成了边缘区域的整体解决方案以及对接工业云平台，为可持续交付业务提供基础的技术支持；产品之间定义了标准的协议接口，根据生产企业的实际应用场景随意组合，像搭积木一样实现产品之间的对接；方案的总体思路是降低成本、提高项目的实施效率。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;  &lt;span&gt;&lt;strong&gt;3．Super Link N1 一体化智能网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       一体化智能网关向下直接采集设备或传感器的数据，向上与ServerSuperIO&lt;/strong&gt;&lt;strong&gt;或云端对接。&lt;/strong&gt;市场上网关产品很多，大致为分三类：纯小型主机，内嵌软件全部自主开发；纯硬件接口，实现数据透明转发；不仅仅是主机，内嵌插件化数据采集框架和管理系统等。Super Link N1型一体化智能网关集成了四大产品：（1）&lt;strong&gt;C/C++&lt;/strong&gt;&lt;strong&gt;开发插件化数据采集框架，高效采集和灵活配置；（2&lt;/strong&gt;&lt;strong&gt;）嵌入式实时数据库，提供高效持久化数据服务；（3&lt;/strong&gt;&lt;strong&gt;）嵌入式Web&lt;/strong&gt;&lt;strong&gt;组态服务，即采集即显示，支持触摸屏和远程访问；（4&lt;/strong&gt;&lt;strong&gt;）Web&lt;/strong&gt;&lt;strong&gt;管理系统，可以远程对网关进行管理和配置，以及在线升级服务&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1&lt;/strong&gt;&lt;strong&gt;）硬件配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;工业级X86和ARM9 32 位 400MHz 处理器，所有应用支持跨平台&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;128MB DDR2 SDRAM，256MB Flash&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2个10/100M自适应工业以太网接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 8个RS485串行接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;1个CAN2.0 B 接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WIFI无线局域网支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GPRS/3G/4G远程无线数据传输支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;USB2.0 主接口支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大容量SD存储卡接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2路DI、2路DO&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内置实时时钟（RTC）蜂鸣器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内置温度传感器及硬件加密&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;预装Linux3.6&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持 -40～80℃ 工业宽温应用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171227235909706-1286308211.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;     （2）&lt;strong&gt;插件化数据采集框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         已经支持的协议OPC、Modbus、DNP、IEC-101、IEC-103、IEC104、IEC61850。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         硬件接口支持以太网、Wifi、NB-IOT、RS232/RS485、CAN、LonWorks、Profibus。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         工程实施中搭配二次开发设备数据采集插件驱动，挂载到网关内运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     （3）&lt;strong&gt;嵌入式实时数据库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          嵌入式实时数据库是在SuperRTDB实时数据库的基础上进行裁剪开发的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          支持秒级别数据存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         支持2万点秒级存储。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         支持有损压缩和无损压缩，压缩效率达1/30～1/50，压缩效果可由参数设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         系统支持整型、浮点型、布尔型等数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     （4）&lt;strong&gt;嵌入式&lt;/strong&gt;&lt;strong&gt;Web&lt;/strong&gt;&lt;strong&gt;组态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        与SuperView是同一个产品，支持跨平台部署，在后面详细介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     （5）&lt;strong&gt;Web&lt;/strong&gt;&lt;strong&gt;管理系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        嵌入式管理系统可以通过浏览器远程对网关设备进行全面管理。支持7大功能模块：&lt;strong&gt;工程管理、综合监控、故障诊断、通道监视、系统工具和用户管理&lt;/strong&gt;。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171227235744597-2107968032.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 工程管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171227235953097-547346574.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 设备及协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000019691-140189093.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 设备详细情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000048738-438541261.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 通道监视&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000117738-1375947430.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 状态监测&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4．ServerSuperIO物联网通讯框架&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;strong&gt;   ServerSuperIO&lt;/strong&gt;&lt;strong&gt;向下可以采集传感器或设备的数据或接收Super Link&lt;/strong&gt;&lt;strong&gt;网关上传的数据，向上与云端对接，在方案中起到中断器的作用。&lt;/strong&gt;仅是一个IO通讯框架本身不太具备现实使用意义，必须考虑到多协议多通讯机制与设备交互、数据完整性校验、设备之间的交互、不同层级部署的级联交互等。ServerSuperIO不仅仅是通讯框架，首先是以设备（传感器）为核心构建的框架，设备（传感器）的协议无关性，可以随意挂载设备驱动在框架下运行。所以ServerSuperIO本质上协调设备驱动（协议）、IO通道（COM和NET）、运行机制（模式）之间的协调机制，使之无缝结合、运行。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000200597-1670470412.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 采集与级联结构&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;ServerSuperIO&lt;/strong&gt;&lt;strong&gt;特点如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;轻型高性能通信框架，适用多种应用场：轮询模式、自控模式、并发模式和单例模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持协议驱动器，可以按规范写标准协议和自定义协议。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持发送数据缓存器，支持命令缓存重发和按优先级别发送。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持协议过滤器，按规则筛选数据，并且可以承继接口，自定义过滤方式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持接收数据缓存器，可以缓存不符合过滤器的数据，和下次接收数据进行拼接。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持按设备命令优先级别进行调度设备，保证有高级别命令的驱动及时发送。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持一个设备驱动，同时适配串口和网络两种通讯方式，可以监视IO通道数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持一个设备驱动，在网络通讯时适配TCP Server和TCP Client两种工作模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持WebSocket，进行数据采集与转发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持多设备共享同一个IO通道进行通讯。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持定时清理超时的网络IO通道。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持显示视图接口，满足不同人机对话的需求。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持服务组件接口，例如：4-20mA输出、LED大屏显示、短信服务、以及多功能网关服务。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;设备驱动与设备驱动，设备驱动与服务器（云端）可以实时双向交互，上传数据和指令下发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持OPC Server和OPC Client。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持创建多服务实例，完成不同业务的拆分。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持跨平台部署，可以运行在Linux和Windows系统。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持SuperRTDB、eDna和CoreRT实时数据库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持mysql、oracle、sqlserver和sqlite数据库。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       Designer IDE是在ServerSuperIO基础开发的，支持挂载设备驱动和服务驱动、OPC Server/Client、数据转发客户端/服务端、支持标准的Modbus协议驱动等。以前专注于ServerSuperIO基础框架的开发，侧重于框架的性能、扩展性、功能等，Designer IDE使整个框架操作更简单、易用。基于ServerSuperIO开发的设备驱动或服务驱动，可以挂载到IDE下运行。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000235097-1033734663.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 主程序&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     通过ServerSuperIO OPC Client读取数据信息，并把数据信息存储到实时数据库或关系数据库。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000502519-427300513.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 OPC DA Client配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     把设备驱动或OPC Client读上来的数据，通过OPC Server为其他系统提供可访问的接口，可以选择输出数据的设备点表或OPC Client点表。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000536097-91071457.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 OPC DA Server输出数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     数据转发（客户端）可以增加转发任务，主动连接其他服务器端，并且根据设备点表和OPC Client点表配置要转发的数据，可以实现物联网建设的级联以及直接连接云端。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000627925-2135567273.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 数据转发（客户端）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     数据转发（服务端）支持远程客户端主动连接ServerSuperIO，并针对已经连接的终端设备（PC机、手机、Web业务系统等）转发设备点表和OPC Client点表的数据，实现数据向终端的分发。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000714113-1150633348.png&quot; alt=&quot;&quot; width=&quot;1000&quot; height=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 数据转发（服务端）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;5．SuperRTDB高性能实时数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      ServerSuperIO&lt;/strong&gt;&lt;strong&gt;与SuperRTDB&lt;/strong&gt;&lt;strong&gt;直接对接&lt;/strong&gt;，作为存储设备实时数据，是边缘区域存储利器，配置关系数据使用能够达到很好的效果，不断满足用户提出的业务需求。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000804363-362377819.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   其特点如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）具有超大的内存管理能力，可以管理&lt;strong&gt;TB&lt;/strong&gt;&lt;strong&gt;级&lt;/strong&gt;的内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）支持高并发&lt;strong&gt;秒级&lt;/strong&gt;数据存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）时间戳分辨率可以达到&lt;strong&gt;微秒级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）支持&lt;strong&gt;旋转门压缩算法和可行域压缩编码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）服务器（志强CPU2.4内存64g）支持&lt;strong&gt;300&lt;/strong&gt;&lt;strong&gt;万点&lt;/strong&gt;同时写入存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）强大的补写历史功能，同时支持随机补写历史&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）支持有损压缩和无损压缩，压缩效率达&lt;strong&gt;1/50&lt;/strong&gt;&lt;strong&gt;～1/100&lt;/strong&gt;，压缩效果可由参数设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）系统支持&lt;strong&gt;整型、浮点型、布尔型&lt;/strong&gt;等数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）支持&lt;strong&gt;128&lt;/strong&gt;&lt;strong&gt;位长点名&lt;/strong&gt;，支持中文点名及描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）支持数据&lt;strong&gt;备份和恢复&lt;/strong&gt;，已有历史数据移植&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11）完整的&lt;strong&gt;二次开发接口&lt;/strong&gt;：C/C++ API；JAVA SDK；.NET SDK；Python SDK; Web API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（12）跨平台运行，支持Windows和Linux平台，X86和ARM的CPU框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;strong&gt;SuperRTDB&lt;/strong&gt;&lt;strong&gt;将来的发展方向是分布式的实时数据库&lt;/strong&gt;，为边缘区域建设大数据平台提供强有力的保障。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;6．SuperView Web组态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt; SuperView主要用于HMI人机对话显示的数据监测，可以部署在Super Link嵌入式网关内与采集服务进行交互、部署在主控室PC机或服务器端与ServerSuperIO进行交互，用于完成不同层次的数据实时监测，支持数据秒级刷新。与传统组态对比，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000856581-1644575355.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 组态对比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       SuperView拥有丰富的图元，支持svg和canvas二次开发的图元导入，满足不同行业、领域、场景的快速组态显示的需求。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000923675-23635829.png&quot; alt=&quot;&quot; width=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 组态图元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/279374/201712/279374-20171228000952175-486084561.png&quot; alt=&quot;&quot; width=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 组态编辑界面&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;7．行业领域应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      针对行业领域应用要么以技术为切入点、要么以业务为切入点，业务需要长期积累的过程，很好的技术体系能够支撑业务的快速发展，以及在项目中很好的控制项目进度、项目成本和项目风险。以上产品体系组成的解决方案，可以帮助各行各业在边缘区域进行体系化建设以及进行业务开发，同时为将来连接“工业互联网平台”提供持续接入的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      为工业的冶金、电力、煤炭、加工制造等，以及为民用的智能家居、智能楼宇、智能社区、车联网、环保、农业等领域提供综合的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;8．接入云端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      接入云端有两种方式：Super Link网关直接连接云端、企业部署ServerSuperIO统一整合数据连接云端。如果云端也部署了ServerSuperIO，那么可以实现从底层到云端的无缝级联，从而实现一体化的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     接入云端涉及到传输协议，一般协议包括：HTTP、MQTT和OPC DA/UA，azure支持OPC UA服务。不管什么协议都会涉及到实时数据传输、数据的压缩与加密、数据补传，以及历史数据上云的问题，要求保证实时性、稳定性和安全性。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;9．工业互联网平台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       有人问：互联网与工业互联网有什么区别？这个问题太大，可能只有专家才能回答。通俗易懂的解释：“互联网”可以拿PPT把故事讲的很美，但是“工业互联网”必须做实并且不是中小企业能够建设的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       “工业互联网”刚刚起步，类似当年“互联网”起步阶段，将来发展成什么程度还无法预测。东方国信紧扣时代契机，成立“工业互联网研究院”，并且积极推动“工业互联网平台”的建设与发展。最近东方国信中标工信部重点项目《&lt;a href=&quot;https://www.toutiao.com/i6501512888585290253/?tt_from=weixin_moments&amp;amp;utm_campaign=client_share&amp;amp;from=timeline&amp;amp;share_type=original&amp;amp;article_category=stock&amp;amp;app=news_article&amp;amp;utm_source=weixin_moments&amp;amp;iid=20175004123&amp;amp;utm_medium=toutiao_android&amp;amp;wxshare_count=1&quot;&gt;信息物理系统关键技术测试验证能力提升和行业试验床建设&lt;/a&gt;》，是推动“工业互联网平台”建设过程中在具体行业的落地应用。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;&lt;span&gt;10．结束语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       任何技术方案最终都是为用户提供有价值的服务，对于企业来讲宗旨是提高效率和降低成本。以上的技术方案，是为新时代的发展提供基础支持。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;物联网&amp;amp;集成技术(.NET) QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;ServerSuperIO 3.0 开源地址：&lt;a href=&quot;https://github.com/wxzz/ServerSuperIO&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/ServerSuperIO&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 27 Dec 2017 16:16:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsjwq/p/8128333.html</dc:identifier>
</item>
<item>
<title>poj 1015 Jury Compromise - PowerofChoas</title>
<link>http://www.cnblogs.com/PowerofChoas/p/8128199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PowerofChoas/p/8128199.html</guid>
<description>&lt;p&gt;题目大意：每个人有两种值Di和Pi，从n个人中选m个人组成集合J，D(J)和P(J)为这m个人的Di与Pi和，使|D(J) - P(J)|最小。若有多个集合J最小，则使D(J) + P(J) 最大。&lt;sub&gt;&lt;br/&gt;&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;1&amp;lt;=n&amp;lt;=200, 1&amp;lt;=m&amp;lt;=20 ，Di和Pi最大为20.&lt;/p&gt;
&lt;p&gt;注意到Di和Pi的和很小，我们可以用类似背包的思想将所有可能生成的值记录下来。&lt;/p&gt;
&lt;p&gt;路径用数组记录，每次加入节点时加入本节点与之前的路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;cstdlib&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MAXM (20 + 5)
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MAXN (200 + 5)
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MAXDP (20 * 20 + 5)
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dp[MAXM][MAXDP], path[MAXM][MAXDP][MAXM];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, cas;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; d[MAXN], p[MAXN], plu[MAXN], subs[MAXN];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m) &amp;amp;&amp;amp; n &amp;amp;&amp;amp;&lt;span&gt; m){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jury #%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ++&lt;span&gt;cas);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;d[i], &amp;amp;&lt;span&gt;p[i]);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             plu[i] = d[i] +&lt;span&gt; p[i];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             subs[i] = d[i] -&lt;span&gt; p[i];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; fix = &lt;span&gt;20&lt;/span&gt; *&lt;span&gt; m;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         memset(dp, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(dp)); 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         memset(path, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(path));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         dp[&lt;span&gt;0&lt;/span&gt;][fix] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; n; k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(i = m - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) // attention
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt;= fix * &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(dp[i][j] &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){ 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(dp[i + &lt;span&gt;1&lt;/span&gt;][j + subs[k]] &amp;lt; dp[i][j] +&lt;span&gt; plu[k]){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             dp[i + &lt;span&gt;1&lt;/span&gt;][j + subs[k]] = dp[i][j] +&lt;span&gt; plu[k]; // 记录相同差值的最大和
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;0&lt;/span&gt;; t &amp;lt; i; t++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                                 path[i + &lt;span&gt;1&lt;/span&gt;][j + subs[k]][t] =&lt;span&gt; path[i][j][t]; // 枚举之前的路径
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                             path[i + &lt;span&gt;1&lt;/span&gt;][j + subs[k]][t]=&lt;span&gt;k; // 当前节点
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; dp[m][fix + i] == -&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; dp[m][fix - i] == -&lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;); // 枚举最小差的绝对值
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; temp = dp[m][fix + i] &amp;gt; dp[m][fix - i] ? i : -&lt;span&gt;i; 
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; sumd = (dp[m][fix + temp] + temp) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; sump = (dp[m][fix + temp] - temp) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Best jury has value %d for prosecution and value %d for defence:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sumd, sump);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,path[m][fix + temp][i] + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Wed, 27 Dec 2017 16:02:00 +0000</pubDate>
<dc:creator>PowerofChoas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PowerofChoas/p/8128199.html</dc:identifier>
</item>
<item>
<title>Javascript中的Microtask和Macrotask——从一道很少有人能答对的题目说起 - Horstxu</title>
<link>http://www.cnblogs.com/xuning/p/8117581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuning/p/8117581.html</guid>
<description>&lt;p&gt;首先我们来看一道题目，如下javascript代码，执行后会在控制台打印出什么内容？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; async1() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   console.log('async1 start'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  await async2();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   console.log('async1 end'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; async2() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   console.log('async2 start'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    resolve();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     console.log('async2 promise'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; console.log('script start'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   console.log('setTimeout'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }, 0&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;async1();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   console.log('promise1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  resolve();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   console.log('promise2'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   console.log('promise3'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; console.log('script end');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说实话，真正能在面试中把这道题目答对的前端工程师凤毛麟角。我们先来瞧一下答案吧。把以上代码存到test.js文件中，并用node执行一下，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/566097/201712/566097-20171226133129213-1397176826.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果把以上代码贴到一个网页中的script标签里面，然后打开这个网页，再打开控制台，可以看到如下输出（Chrome 64位 63.0.3239.84）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/566097/201712/566097-20171226133444135-951181923.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果和node打印的一模一样。那么为什么是这个顺序呢？&lt;/p&gt;

&lt;p&gt;我们都知道js的单线程特性（html5的web worker不算在内～）以及良好的异步支持。在单线程的前提下，异步任务到底什么时候开始执行，其实是有两个队列来进行管理，即Macrotask和Microtask（只有一个字母的差距，不要认错……）。在当前正在执行的线程中，如果碰到属于Macrotask的异步任务，则放入Macrotask队列；碰到Microtask的异步任务则放入Microtask队列。注意这里只是把任务放入队列，并不会执行它。等到当前主线程任务直线完毕之后，会依次从Microtask队列中取出任务执行，在执行期间当然还是遵循碰到异步任务放入相应队列的原则。等到Microtask任务全部执行过了，此时再从Macrotask队列中取出一个任务执行。&lt;/p&gt;

&lt;p&gt;属于Macrotask的任务有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
setTimeout，setInteveral，script标签，I/O，UI渲染
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;属于Microtask的任务有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Promise，async/await，process.nextTick，Object.observe，MutationObserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（事实上，即使同样是Microtask，内部也是有优先级的差别的，例如NodeJS的实现上，process.nextTick比Promise要先执行。相关问题可以瞧瞧这个连接：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ 。反正我瞧到一半就放弃了，好在async/await和Promise没有优先级差别）&lt;/p&gt;

&lt;p&gt;然后我们来分析一下本题中的执行顺序：&lt;/p&gt;
&lt;p&gt;【1】第15行执行，&lt;span&gt;&lt;strong&gt;打印出script start&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【2】第16至18行，把回调任务放入Macrotask （目前Macrotask：第16行setTimeout，Microtask：空）&lt;/p&gt;
&lt;p&gt;【3】第20行，执行async1函数，先打印出第2行的&lt;strong&gt;&lt;span&gt;async1 start&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【4】第3行的async2先执行，打印出第8行的&lt;strong&gt;&lt;span&gt;async2 start&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【5】第9行至第12行遇到Promise，先打印出第11行的&lt;strong&gt;&lt;span&gt;async2 promise&lt;/span&gt;&lt;/strong&gt;（注意不管你resolve写在new Promise的函数什么位置，都跟写到最后一句一样！）&lt;/p&gt;
&lt;p&gt;【6】第3行的async2返回了Promise，并且async2前面有await修饰，因此后面第4行的任务被放到Microtask（目前Macrotask：第16行setTimeout，Microtask：第4行）&lt;/p&gt;
&lt;p&gt;【7】第22至25行，&lt;strong&gt;&lt;span&gt;打印出promise1&lt;/span&gt;&lt;/strong&gt;，并把第26行放入Microtask，注意第28行还没执行到，所以这行什么都不做（目前Macrotask：第16行setTimeout，Microtask：第4行，第26行）&lt;/p&gt;
&lt;p&gt;【8】第30行&lt;strong&gt;&lt;span&gt;打印script end&lt;/span&gt;&lt;/strong&gt;（目前Macrotask：第16行setTimeout，Microtask：第4行，第26行）&lt;/p&gt;
&lt;p&gt;【9】脚本主线程执行结束，现在拿出来一个Microtask，即第4行，&lt;strong&gt;&lt;span&gt;打印async1 end&lt;/span&gt;&lt;/strong&gt;（目前Macrotask：第16行setTimeout，Microtask：第26行）&lt;/p&gt;
&lt;p&gt;【10】再拿出来一个Microtask，即第26行，&lt;strong&gt;&lt;span&gt;打印promise2&lt;/span&gt;&lt;/strong&gt;，此时由于第26行后面跟着then，所以把第28行插入Microtask（目前Macrotask：第16行setTimeout，Microtask：第28行）&lt;/p&gt;
&lt;p&gt;【11】再拿出来一个Microtask，即第28行，&lt;span&gt;&lt;strong&gt;打印promise3&lt;/strong&gt;&lt;/span&gt;（目前Macrotask：第16行的setTimeout，Microtask：空）&lt;/p&gt;
&lt;p&gt;【12】Microtask没有了，执行下一个Macrotask，即第16行的setTimeout，&lt;strong&gt;&lt;span&gt;打印setTimeout&lt;/span&gt;&lt;/strong&gt;，结束&lt;/p&gt;

&lt;p&gt;需要注意的是，以下两种写法，效果是一模一样的（resolve的位置无所谓）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
写法1:
new Promise((resolve, reject) =&amp;gt; {
  console.log('1111');
  resolve();
  console.log('2222');
});

写法2:
new Promise((resolve, reject) =&amp;gt; {
  console.log('1111');
  console.log('2222');
  resolve();
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另外，对于Promise的链式调用，如new Promise(....).then(...).then(...)....，一次只放第一个then的内容进入Microtask，等第一个then执行的时候，会把第二个then放入Microtask，而不是一次把两个then都放进去。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:36:00 +0000</pubDate>
<dc:creator>Horstxu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuning/p/8117581.html</dc:identifier>
</item>
<item>
<title>循环 - 里昂科科</title>
<link>http://www.cnblogs.com/leonsehun/p/8128136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leonsehun/p/8128136.html</guid>
<description>&lt;p&gt;循环&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1  &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;多项式求和&lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232414206-922067302.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;h4&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;先输入一个整数&lt;/span&gt;n,&lt;/p&gt;
&lt;p&gt;循环输入n&lt;span&gt;次，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个&lt;/span&gt;flag&lt;span&gt;，要求加法时定义&lt;/span&gt;&lt;span&gt;flag=-1&lt;/span&gt;&lt;span&gt;；减法时&lt;/span&gt;&lt;span&gt;flag=1&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;sum=0&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行&lt;/span&gt;sum=x+flag*1.00/j;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232424456-1860965897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232525675-833714141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2  &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;求&lt;/span&gt;1到100的和&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232542941-1937680790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用循环，定义&lt;/span&gt;i.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232615597-511381201.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232703800-1567380463.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232625285-2105013126.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原因&lt;/span&gt;  &lt;span&gt;未打空格&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.&lt;/strong&gt;&lt;strong&gt;求幂之和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232639410-2080861229.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此题很简单，调用&lt;/span&gt;pow函数，循环累加即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232649472-1606326583.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232714785-201426326.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同学互评：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232848956-1632545344.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涧薇同学的代码写的很明了，比较容易读懂，但我觉得，我自己用到了函数，所以，嗯。还是不分伯仲吧。一起学习一起进步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232922472-500135168.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;经过循环这个题组的练习，我学到了格式很重要，尤其是在&lt;/span&gt;PTA上，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遇见很复杂的多重循环，可以选择调用函数，以便美观，也更清楚。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之，需要理清思路，画好流程图很重要，一步一步跟着思路打代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:30:00 +0000</pubDate>
<dc:creator>里昂科科</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leonsehun/p/8128136.html</dc:identifier>
</item>
<item>
<title>Netty学习笔记（一）：接收nodejs模拟表单上传的文件 - stone-fly</title>
<link>http://www.cnblogs.com/stone-fly/p/8127960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stone-fly/p/8127960.html</guid>
<description>&lt;p&gt;&lt;span&gt;好久不写博客了，也好久不写代码了，这两天临时遇上一个事情，觉得不难，加上觉得手有些生，就动手做了一下，结果遇上了不少坑，有新坑，有老坑，痛苦无比，现在总算差不多了，赶紧记录下来，希望以后不再重复这种痛苦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事情很简单，用nodejs模拟表单提交，上传文件到netty服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、netty的参考资料很多，目前有netty3,netty4两个版本，netty5出到alpha 2版本，不知道怎么的，就不更新了，官网也注明不支持了，所以我采用的是netty4.1.19版，目前最新的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;参考的资料大致如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1）http://netty.io/wiki/index.html，官方的文档，都写的很经典，值得学习，里面的例子snoop对我帮助很大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2）https://www.programcreek.com/，一个示例代码的网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;netty的代码基本都是照抄第二个网站的内容，具体地址是https://www.programcreek.com/java-api-examples/index.php?source_dir=netty4.0.27Learn-master/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java。共有三个文件，HttpUploadServer.java，HttpUploadServerHandler.java，HttpUploadServerInitializer.java&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、nodejs本身比较简单，但也花了不少时间研究。上传文件可选的组件也很多，有form-data，request甚至官方的API，使用起来都不复杂，本来选择的是form-data，但是用起来也遇到了不少问题，最终使用的还是request，request使用起来非常简单，我主要参考了如下内容。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     1）http://www.open-open.com/lib/view/open1435301679966.html 中文的，介绍的比较详细。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     2）https://github.com/request/request 这是官方网站，内容最全，最权威。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、详细环境&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Windows 10专业版&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）Spring Tool Suite 3.9.1，其实用eclipse也可以&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   3）Netty 4.1.19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   4）Nodejs 8.9.3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、目标&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Netty程序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        a）同时支持post、get方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        b）将cookie、get参数和post参数保存到map里，如果是文件上传，则将其保存到临时目录，返回web地址，供客户访问。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）nodejs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        a）同时支持get、post方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        b）可以设置cookie，因为上传文件肯定是需要登录的，sessionID一般是保存在cookie里面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5、预期思路&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）先解决netty的服务端问题，客户端先用浏览器测试。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）再解决nodejs的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6、解决过程和踩的坑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Netty&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       a）Netty编程本身不难，但是相对来说要底层一些，如果经常做web开发的人，可能容易困惑，但熟悉一下就好了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            一般来说，netty服务端程序分为三个程序，如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Server：启动线程，保定端口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Initializer：初始化流处理器，即将接收到的字节流先进行编码，形成对象，供后续解码器处理，我们需要关注的东西不多，在这个程序里，我们拿到手的已经是解析好的http对象了，只要按照我们的思路处理就可以了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Handler：是我们自己的逻辑，在这个例子里就是解析对象，形成map，将文件保存到磁盘上而已。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      b）首先是pom文件，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

        &amp;lt;groupId&amp;gt;io-netty&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;io-netty-example&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

        &amp;lt;name&amp;gt;io-netty-example&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

        &amp;lt;properties&amp;gt;
                &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;/properties&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;!-- https://mvnrepository.com/artifact/io.netty/netty-codec-http --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;4.1.19.Final&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;1.2.44&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      c）Server非常简单，代码也不多，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload; 
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.bootstrap.ServerBootstrap; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.Channel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.EventLoopGroup; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoopGroup; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioServerSocketChannel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.logging.LogLevel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.logging.LoggingHandler; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.SslContext; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.util.SelfSignedCertificate; 
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * A HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpUploadServer { 
 
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; SSL = System.getProperty(&quot;ssl&quot;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, SSL? &quot;8443&quot; : &quot;8090&quot;&lt;span&gt;)); 
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception { 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure SSL. &lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SslContext sslCtx; 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (SSL) { 
            SelfSignedCertificate ssc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SelfSignedCertificate(); 
            sslCtx &lt;/span&gt;=&lt;span&gt; SslContext.newServerContext(ssc.certificate(), ssc.privateKey()); 
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
            sslCtx &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
        } 
 
        EventLoopGroup bossGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(1&lt;span&gt;); 
        EventLoopGroup workerGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup(); 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; { 
            ServerBootstrap b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap(); 
            b.group(bossGroup, workerGroup); 
            b.channel(NioServerSocketChannel.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;); 
            b.handler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggingHandler(LogLevel.INFO)); 
            b.childHandler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpUploadServerInitializer(sslCtx)); //调用Initializer
 
            Channel ch &lt;/span&gt;=&lt;span&gt; b.bind(PORT).sync().channel(); 
 
            System.err.println(&lt;/span&gt;&quot;Open your web browser and navigate to &quot; +&lt;span&gt; 
                    (SSL&lt;/span&gt;? &quot;https&quot; : &quot;http&quot;) + &quot;://127.0.0.1:&quot; + PORT + '/'&lt;span&gt;); 
 
            ch.closeFuture().sync(); 
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { 
            bossGroup.shutdownGracefully(); 
            workerGroup.shutdownGracefully(); 
        } 
    } 
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     d）Initializer代码，需要注意的是流处理器，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2012 The Netty Project 
 * 
 * The Netty Project licenses this file to you under the Apache License, 
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at: 
 * 
 *   &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt; 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelInitializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelPipeline;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpContentCompressor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpObjectAggregator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpRequestDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpResponseEncoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.SslContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HttpUploadServerInitializer &lt;span&gt;extends&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SslContext sslCtx;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpUploadServerInitializer(SslContext sslCtx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sslCtx =&lt;span&gt; sslCtx;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initChannel(SocketChannel ch) {
        ChannelPipeline pipeline &lt;/span&gt;=&lt;span&gt; ch.pipeline();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sslCtx != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
        }

        pipeline.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestDecoder()); //处理Request
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncomment the following line if you don't want to handle HttpChunks.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pipeline.addLast(new HttpObjectAggregator(1048576)); //将对象组装为FullHttpRequest&lt;/span&gt;
        pipeline.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseEncoder());  //处理Response

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the following line if you don't want automatic content compression.&lt;/span&gt;
        pipeline.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpContentCompressor());  //压缩

        pipeline.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpUploadServerHandler());
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       这里需要注意一点，采用HttpRequestDecoder处理器，会将一个Request对象解析成三个对象HttpRequest、HttpCotent、LastHttpContent，这三个对象大致是这样的，HttpRequest是地址信息和头部信息，其中包括get方式传送的参数和cookie信息；HttpContent是消息体，即Body部分，即post方式form提交的内容；LastHttpContent则是消息体的末尾，即提示消息体结束，也就是整个请求结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      但是需要注意的是，使用HttpObjectAggregator处理器，可以将Request对象处理为FullRequest，但我测试了一下，不知道为什么，竟然卡死了，所以只好用这种笨办法，以后研究一下，这次先这样吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      e）Handler的代码有些长，不过还是贴出来吧。       &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2012 The Netty Project 
 * 
 * The Netty Project licenses this file to you under the Apache License, 
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at: 
 * 
 *   &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt; 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.buffer.ByteBuf;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFuture;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFutureListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelHandlerContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.SimpleChannelInboundHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.Cookie;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.CookieDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.DefaultFullHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.FullHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpContent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpHeaders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpResponseStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpVersion;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.LastHttpContent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.QueryStringDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.ServerCookieEncoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.Attribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DiskAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DiskFileUpload;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.FileUpload;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpDataFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.InterfaceHttpData;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.util.CharsetUtil;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Files;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Paths;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map.Entry;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Level;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Logger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSON;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; io.netty.buffer.Unpooled.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; io.netty.handler.codec.http.HttpHeaders.Names.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HttpUploadServerHandler &lt;span&gt;extends&lt;/span&gt; SimpleChannelInboundHandler&amp;lt;HttpObject&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = Logger.getLogger(HttpUploadServerHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpRequest request;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; readingChunks;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; StringBuilder responseContent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HttpDataFactory factory = &lt;span&gt;new&lt;/span&gt; DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Disk
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; size
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exceed&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpPostRequestDecoder decoder;

    &lt;/span&gt;&lt;span&gt;//////
&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; String tempPath = &quot;d:/upload/&quot;&lt;span&gt;;  //文件保存目录

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String url_path = &quot;http://localhost/upload/&quot;&lt;span&gt;;   //文件临时web目录
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String errorJson;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; mparams = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();  //将参数保存到map里面

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        DiskFileUpload.deleteOnExitTemporaryFile &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; should delete file
                                                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; on exit (in normal
                                                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exit)&lt;/span&gt;
        DiskFileUpload.baseDirectory = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; system temp directory&lt;/span&gt;
        DiskAttribute.deleteOnExitTemporaryFile = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; should delete file on
                                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exit (in normal exit)&lt;/span&gt;
        DiskAttribute.baseDirectory = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; system temp directory&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelUnregistered(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (decoder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            decoder.cleanFiles();
        }
    }
&lt;br/&gt;//处理输入对象，会执行三次，分别是HttpRequest、HttpContent、LastHttpContent
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead0(ChannelHandlerContext ctx, HttpObject msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpRequest) {
            HttpRequest request &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.request =&lt;span&gt; (HttpRequest) msg;
            URI uri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URI(request.getUri());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!uri.getPath().equals(&quot;/formpostmultipart&quot;&lt;span&gt;)) {
                errorJson &lt;/span&gt;= &quot;{code:-1}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new getMethod
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (Entry&amp;lt;String, String&amp;gt; entry : request.headers()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;HEADER: &quot; + entry.getKey() + '=' + entry.getValue() +
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new getMethod&lt;/span&gt;
            Set&amp;lt;Cookie&amp;gt;&lt;span&gt; cookies;
            String value &lt;/span&gt;=&lt;span&gt; request.headers().get(COOKIE);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                cookies &lt;/span&gt;=&lt;span&gt; Collections.emptySet();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                cookies &lt;/span&gt;=&lt;span&gt; CookieDecoder.decode(value);
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie : cookies) {
                mparams.put(cookie.getName(), cookie.getValue());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
&lt;span&gt;            System.out.println(JSON.toJSONString(mparams));

            QueryStringDecoder decoderQuery &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryStringDecoder(request.getUri());
            Map&lt;/span&gt;&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; uriAttributes =&lt;span&gt; decoderQuery.parameters();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
&lt;span&gt;            mparams.putAll(uriAttributes);
            System.out.println(JSON.toJSONString(mparams));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; attr: uriAttributes.entrySet()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (String attrVal: attr.getValue()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;URI: &quot; + attr.getKey() + '=' + attrVal + &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\n&quot;);&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (request.getMethod().equals(HttpMethod.GET)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET Method: should not try to create a HttpPostRequestDecoder
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; So stop here
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\nEND OF GET CONTENT\r\n&quot;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not now: LastHttpContent will be sent writeResponse(ctx.channel());&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                decoder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpPostRequestDecoder(factory, request);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ErrorDataDecoderException e1) {
                e1.printStackTrace();
                responseContent.append(e1.getMessage());
                writeResponse(ctx.channel());
                ctx.channel().close();
                errorJson &lt;/span&gt;= &quot;{code:-2}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            readingChunks &lt;/span&gt;=&lt;span&gt; HttpHeaders.isTransferEncodingChunked(request);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;Is Chunked: &quot; + readingChunks + &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;IsMultipart: &quot; + decoder.isMultipart() + &quot;\r\n&quot;);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (readingChunks) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Chunk version
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;Chunks: &quot;);&lt;/span&gt;
                readingChunks = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check if the decoder was constructed before
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if not it handles the form get&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (decoder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpContent) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; New chunk is received&lt;/span&gt;
                HttpContent chunk =&lt;span&gt; (HttpContent) msg;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    decoder.offer(chunk);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ErrorDataDecoderException e1) {
                    e1.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(e1.getMessage());&lt;/span&gt;
&lt;span&gt;                    writeResponse(ctx.channel());
                    ctx.channel().close();
                    errorJson &lt;/span&gt;= &quot;{code:-3}&quot;&lt;span&gt;;
                    writeError(ctx, errorJson);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append('o');
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; example of reading chunk by chunk (minimize memory usage due to
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Factory)&lt;/span&gt;
&lt;span&gt;                readHttpDataChunkByChunk(ctx);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; example of reading only if at the end&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (chunk &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; LastHttpContent) {
                    writeResponse(ctx.channel());
                    readingChunks &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    reset();
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            writeResponse(ctx.channel());
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reset() {
        request &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; destroy the decoder to release all resources&lt;/span&gt;
&lt;span&gt;        decoder.destroy();
        decoder &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Example of reading request by chunk and getting values from chunk to chunk
     * 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     &lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;//处理post数据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readHttpDataChunkByChunk(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (decoder.hasNext()) {
                InterfaceHttpData data &lt;/span&gt;=&lt;span&gt; decoder.next();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new value&lt;/span&gt;
&lt;span&gt;                        writeHttpData(ctx, data);
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        data.release();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (EndOfDataDecoderException e1) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\nEND OF CONTENT CHUNK BY CHUNK\r\n\r\n&quot;);&lt;/span&gt;
            mparams.put(&quot;code&quot;, &quot;-2&quot;&lt;span&gt;);
        }
    }
    //解析post属性，保存文件，写入map
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeHttpData(ChannelHandlerContext ctx, InterfaceHttpData data) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.getHttpDataType() ==&lt;span&gt; HttpDataType.Attribute) {
            Attribute attribute &lt;/span&gt;=&lt;span&gt; (Attribute) data;
            String value;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                value &lt;/span&gt;=&lt;span&gt; attribute.getValue();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error while reading data from File, only print name and error&lt;/span&gt;
&lt;span&gt;                e1.printStackTrace();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\nBODY Attribute: &quot; +
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; attribute.getHttpDataType().name() + &quot;: &quot;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; + attribute.getName() + &quot; Error while reading value: &quot; + e1.getMessage() +
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;\r\n&quot;);&lt;/span&gt;
                errorJson = &quot;{code:-4}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            mparams.put(attribute.getName(), attribute.getValue());
            System.out.println(JSON.toJSONString(mparams));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.getHttpDataType() ==&lt;span&gt; HttpDataType.FileUpload) {
                FileUpload fileUpload &lt;/span&gt;=&lt;span&gt; (FileUpload) data;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileUpload.isCompleted()) {
                    System.out.println(fileUpload.length());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileUpload.length() &amp;gt; 0&lt;span&gt;) {
                        String orign_name &lt;/span&gt;=&lt;span&gt; fileUpload.getFilename();
                        String file_name &lt;/span&gt;= UUID.randomUUID() + &quot;.&quot;
                                + orign_name.substring(orign_name.lastIndexOf(&quot;.&quot;) + 1&lt;span&gt;);
                        fileUpload.renameTo(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(tempPath +&lt;span&gt; file_name));
                        mparams.put(data.getName(), url_path &lt;/span&gt;+&lt;span&gt; file_name);
                        System.out.println(JSON.toJSONString(mparams));
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    errorJson &lt;/span&gt;= &quot;{code:-5}&quot;&lt;span&gt;;
                    writeError(ctx, errorJson);

                }
            }
        }
    }
    //写入response，返回给客户
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeResponse(Channel channel) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Convert the response content to a ChannelBuffer.&lt;/span&gt;
        ByteBuf buf =&lt;span&gt; copiedBuffer(JSON.toJSONString(mparams), CharsetUtil.UTF_8);
        responseContent.setLength(&lt;/span&gt;0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decide whether to close the connection or not.&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; close =&lt;span&gt; HttpHeaders.Values.CLOSE.equalsIgnoreCase(request.headers().get(CONNECTION))
                &lt;/span&gt;||&lt;span&gt; request.getProtocolVersion().equals(HttpVersion.HTTP_1_0)
                        &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(request.headers().get(CONNECTION));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Build the response object.&lt;/span&gt;
        FullHttpResponse response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);
        response.headers().set(CONTENT_TYPE, &lt;/span&gt;&quot;text/plain; charset=UTF-8&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;close) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There's no need to add 'Content-Length' header
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if this is the last response.&lt;/span&gt;
&lt;span&gt;            response.headers().set(CONTENT_LENGTH, buf.readableBytes());
        }

        Set&lt;/span&gt;&amp;lt;Cookie&amp;gt;&lt;span&gt; cookies;
        String value &lt;/span&gt;=&lt;span&gt; request.headers().get(COOKIE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            cookies &lt;/span&gt;=&lt;span&gt; Collections.emptySet();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            cookies &lt;/span&gt;=&lt;span&gt; CookieDecoder.decode(value);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cookies.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset the cookies if necessary.&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie : cookies) {
                response.headers().add(SET_COOKIE, ServerCookieEncoder.encode(cookie));
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write the response.&lt;/span&gt;
        ChannelFuture future =&lt;span&gt; channel.writeAndFlush(response);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Close the connection after the write operation is done if necessary.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
            future.addListener(ChannelFutureListener.CLOSE);
        }
    }
    //返回错误信息，也是写入response
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeError(ChannelHandlerContext ctx, String errorJson) {

        ByteBuf buf &lt;/span&gt;=&lt;span&gt; copiedBuffer(errorJson, CharsetUtil.UTF_8);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Build the response object.&lt;/span&gt;
        FullHttpResponse response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);

        response.headers().set(CONTENT_TYPE, &lt;/span&gt;&quot;text/html; charset=UTF-8&quot;&lt;span&gt;);
        response.headers().set(CONTENT_LENGTH, buf.readableBytes());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write the response.&lt;/span&gt;
&lt;span&gt;        ctx.channel().writeAndFlush(response);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.log(Level.WARNING, responseContent.toString(), cause);
        ctx.channel().close();
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     虽然代码很多，但是最需要注意的只有四个方法：    &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;channelRead0(ChannelHandlerContext ctx, HttpObject msg)：处理输入内容，会执行三次，分别是HttpRequest、HttpContent、LastHttpContent，依次处理。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;readHttpDataChunkByChunk(ChannelHandlerContext ctx)：解析HttpContent时调用，即消息体时，具体执行过程在函数writeHttpData中   &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;writeResponse(Channel channel)：写入response，这里调用了fastjson将map转换为json字符串。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;      f）上传的html文件     &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HTML5的标题&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form  &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8090/formpostmultipart?a=张三&amp;amp;b=李四&quot;&lt;/span&gt;&lt;span&gt;  method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;  enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;shiyq&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;历史地理&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=file  &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;上传&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;      g）启动HttpUploadServer，然后在浏览器里访问upload.html，返回结果如下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;span&gt;{
    &quot;name&quot;: &quot;历史地理&quot;,
    &quot;a&quot;: [
        &quot;张三&quot;
    ],
    &quot;b&quot;: [
        &quot;李四&quot;
    ],
    &quot;file&quot;: &quot;http://localhost/upload/13d45df8-d6c7-4a7a-8f21-0251efeca240.png&quot;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      这里要注意的是，地址栏传递的参数是个数组，即参数名可以重复，form里面的值不可以，只能是一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2）NodeJS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       nodejs相对要简单一些，但是也更让人困惑，主要遇到了两个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       a）请求地址包含中文的情况，这个其实是个老问题，很容易解决，但是却卡住了半天，看来很久不写程序就是不行啊。最后的解决办法就是进行url编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       b）cookie设置的问题，form-data模块没有说明cookie设置的问题，官方API的request也言之不详，幸好request写的比较明白，但是默认还不开启，需要设置，还是老话，三天不写程序手就生了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      c）环境非常简单，只需要安装request模块就可以了，命令为npm install request，尽量不要装在全局，在我的Windows 10上出现找不到模块的现象，最后安装到当前目录才解决，最后的代码如下      &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; fs = require('fs'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = require('request').defaults({jar:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;});  //不要忘记npm install request,不要忘记设置jar:true,否则无法设置cookied

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file_path=&quot;D:/Documents/IMG_20170427_121431.jpg&quot;
&lt;span&gt;var&lt;/span&gt; formData =&lt;span&gt; {
    name:&lt;/span&gt;&quot;路送双&quot;&lt;span&gt;,
    code:&lt;/span&gt;&quot;tom&quot;&lt;span&gt;,
    my_file:fs.createReadStream(file_path)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = encodeURI(&quot;http://localhost:8090/formpostmultipart?a=王二&amp;amp;a=张三&amp;amp;b=李四&quot;&lt;span&gt;);//对中文编码
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j =&lt;span&gt; request.jar();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cookie = request.cookie('key1=value1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cookie1 = request.cookie('key2=value2'&lt;span&gt;);
j.setCookie(cookie, url);
j.setCookie(cookie1, url);

request.post({url:url, jar:j, formData: formData}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; optionalCallback(err, httpResponse, body) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; console.error('upload failed:'&lt;span&gt;, err);
  }
  console.log( body);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     需要注意cookie的设置，不仅需要设置jar属性为true，还需要调用多次setCookie，还需要在request.post中指定参数，挺麻烦的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      d）返回结果如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;{
    &lt;/span&gt;&quot;key1&quot;: &quot;value1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;key2&quot;: &quot;value2&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;a&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;王二&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;张三&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;b&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;李四&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;code&quot;: &quot;tom&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;my_file&quot;: &quot;http://localhost/upload/8d8e2f9f-7513-4844-9614-0d7fb7a33a6e.jpg&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;name&quot;: &quot;路送双&quot;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;7、结论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     其实是个很简单的问题，不过研究过程有些长，而且很笨拙，如果用FullHttpRequest，代码会少很多，以后再研究吧。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:28:00 +0000</pubDate>
<dc:creator>stone-fly</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stone-fly/p/8127960.html</dc:identifier>
</item>
<item>
<title>InfluxDB:cannot use field in group by clause - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/8128065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/8128065.html</guid>
<description>&lt;p&gt;  最近在使用InfluxDB时，发现一个很奇怪的问题，一个本来正常的功能，做了一次改动后，就不能正常显示了.&lt;/p&gt;
&lt;p&gt;一、查询语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SELECT MEMORY FROM &lt;span&gt;&quot;ACM_PROCESS_MONITOR&quot; GROUP BY USER_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 异常信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Server returned error: can not use &lt;span&gt;field&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; GROUP BY clause: &lt;span&gt;USER_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Group By语句后面，只能是Tag列，不能是Field列&lt;/p&gt;

&lt;p&gt;二、查看所有Tag列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227225512722-598871319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  说明&lt;span&gt;USER_NAME&lt;/span&gt;是Tag列&lt;/p&gt;
&lt;p&gt;三、查看所有Field列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227225618956-328987666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   说明USER_NAME是Field列&lt;/p&gt;
&lt;p&gt;   综上所述，USER_NAME既是FIELD列，又是TAG列！&lt;/p&gt;
&lt;p&gt; 四、问题产生原因&lt;/p&gt;
&lt;p&gt;  产生这个问题的原因，是因为UESER_NAME以前确实是FIELD列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227230508191-2078406843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因为不能在GROUP BY 中查询，于是把它设置为了TAG列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227230646378-619859701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    为了方便，删除了原来的表，数据都是新的，GROUP BY 没有问题。&lt;/p&gt;
&lt;p&gt;   今天一不小心，又启用了改之前的程序，导致又把USER_NAME作为了FIELD列，所以GROUP BY的时候出问题了。&lt;/p&gt;
&lt;p&gt;   老外的描述：https://github.com/influxdata/influxdb/issues/3783&lt;/p&gt;
&lt;p&gt;   解决方案：&lt;/p&gt;
&lt;p&gt;   1.把表删了重建，然后启用新程序&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;   2.重新为USER_NAME取一个作为TAG列的名字：TAG_USER_NAME，数据都写到这里，用它作为GROUP BY的Tag列&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:02:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/8128065.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏（View篇）--自定义 View 的基本流程 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8060101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8060101.html</guid>
<description>&lt;p&gt;View是Android很重要的一部分，常用的View有Button、TextView、EditView、ListView、GridView、各种layout等等，开发者通过对这些View的各种组合以形成丰富多彩的交互界面，一个应用中界面交互的体验往往在应用的受欢迎程度上起了很关键得作用，所以开发者们大多会想方设法的做出一个更加精美的界面，例如：通过自定义View、深入学习View的原理以便更好的对其优化使其在操作起来更加流畅等等，也正因为如此，在面试中View也常常作为面试官重点考察的对象之一。&lt;/p&gt;
&lt;p&gt;View是所有控件的基类，包括Button、TextView、EditView等等都直接或间接继承自view，View下面还有ViewGroup子类，即LinearLayout、RelativeLayout等都属于ViewGroup。&lt;/p&gt;
&lt;p&gt;我们需要知道的是在Android中，无论是View还是其他界面，右方向代表着x轴的正向，下方向代表着y轴的正向。&lt;/p&gt;
&lt;h3 id=&quot;view-的基本工作原理&quot;&gt;View 的基本工作原理&lt;/h3&gt;
&lt;p&gt;在 ActivityThread 中，当Activity被创建后会将 DecorView 添加到 Window 中，同时创建 ViewRootImpl 对象，并将 ViewRootImpl 和 DecorView 建立关联，而 DecorView 就是一个 Activity 的顶级 View，在一个默认的主题中，它分为标题栏，和内容区域，我们所添加的 View 均是添加到了 DecorView 的内容区域，这些被添加进去的 View 的工作流程正式通过 ViewRootImpl 完成的。&lt;/p&gt;
&lt;p&gt;ViewRoot、DecorView 及 View 的三大流程简介：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ViewRoot：对应于 ViewRootImpl，链接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过它完成的。（View 的绘制流程是从 ViewRoot 的 performTraversals() 方法开始的，它经过 measure、layout、draw 三个流程最终才能将一个 View 完整的绘制出来。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DecorView：新建一个 Android 应用时我们都知道，默认主题的情况下这个应用的界面会分为两部分：标题栏、内容区域。而这个界面的顶级 View 就是 DecorView。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;View的绘制经过了 measure、layout、draw 三个流程：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;measure：对应 onMeasure() 方法，测量View的宽、高。&lt;/li&gt;
&lt;li&gt;layout：对应 onLayout() 方法，确定view的四个顶点，即确定View在父容器中的位置。&lt;/li&gt;
&lt;li&gt;draw：对应 onDraw()，绘制View。在自定义 View 时我们也正是在 onDraw() 方法内可以在 Canvas 画布上随心所欲的画出我们想要的 View。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;自定义-view&quot;&gt;自定义 View&lt;/h3&gt;
&lt;p&gt;自定义 View 的方式不止一种，可以直接继承 View，重写 onDraw() 方法，也可以直接继承 ViewGroup，还可以继承现有的控件（如：TextView、LinearLayout）等，本篇主要介绍一下直接继承 View 的方式。&lt;/p&gt;
&lt;p&gt;直接继承 View 来实现自定义 View 的这种方式比较灵活，可以实现很多复杂的效果，这种方式最关键的步骤就是重写 onDraw() 方法，通过 Paint 画笔等工具在 Canvas 画布上进行各种图案的绘制以达到我们想要的效果。&lt;/p&gt;
&lt;p&gt;其实在自定义 View 过程中，难点往往不是怎么使用画笔本身，而是绘制出预期效果的思路，例如：你想通过自定义 View 来做一个折线图控件，传入一组数据怎么确定这些数据在画布上对应点的相对坐标，而确定点的坐标就需要通过相关的数学公式来计算了，推算出合适的公式往往就是解决问题的关键。&lt;/p&gt;
&lt;p&gt;接下来就用这种方式来写个圆形的小 demo 来说明一下自定义 View 的流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建一个继承 View 的类，添加构造方法，设置 Paint 画笔，重写 onDraw() 方法，先在画布上以最简单的方式话一个半径为100的圆。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 自定义 View 简单示例
 * Created by liuwei on 17/12/14.
 */
public class MyView extends View {

    private final static String TAG = MyView.class.getSimpleName();

    private Paint mPaint = new Paint();
    private int mColor = Color.parseColor(&quot;#ff0000&quot;);

    public MyView(Context context) {
        super(context);
        Log.i(TAG, &quot;MyView(Context context)：content=&quot; + context);
        init();
    }

    public MyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        Log.i(TAG, &quot;MyView(Context context, @Nullable AttributeSet attrs)：content=&quot; + context + &quot; | attrs=&quot; + attrs);
        init();
    }

    private void init() {
        mPaint.setAntiAlias(true); // 消除锯齿
        mPaint.setColor(mColor); // 为画笔设置颜色
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        // 重写此方法，对自定义控件在 wrap_content 情况下设置默认宽、高
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int heithtSpecSize = MeasureSpec.getSize(heightMeasureSpec);

        if (widthSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; heightSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(200, 200);
        } else if (widthSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(200, heithtSpecSize);
        } else if (heightSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(widthSpecSize, 200);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        Log.i(TAG, &quot;onDraw: &quot;);
        super.onDraw(canvas);
        canvas.drawCircle(100, 100, 100, mPaint);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果就是一个红色的实心圆，在这个示例中为了使得布局文件中的 wrap_content 正常生效，重写了 onMeasure() 方法，关于这个问题，在这篇博文&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8067167.html&quot;&gt;《Android查缺补漏--自定义 View 中 wrap_content 无效的解决方案》&lt;/a&gt;中也介绍过了，这里就不多说了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将上面的圆再扩展一下：做成以画布的可用区域的中心为圆点，画出最大的圆。同时为自定义 View 设置 padding&lt;br/&gt;对于一个控件，有 margin 和 padding，margin 是外间距，属于控件之外的范围，在自定义 View 时不需要对 margin 做特殊处理。但 padding 就不同了，是内间距，需要我们在控件的内部做处理才能让布局文件中对控件设置的 padding 生效。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private int mPaddingTop;
private int mPaddingBottom;
private int mPaddingLeft;
private int mPaddingRight;

private int mUsableWidth; // 可用宽度（减去padding后的宽度）
private int mUsableHeight;// 可用高度（减去padding后的高度）

private int mUsableStartX = 0; // 画笔起始点的x坐标
private int mUsableStartY = 0; // 画笔其实点的y坐标

private int mCircleX; // 圆心x坐标
private int mCircleY; // 圆心y坐标
private int mCircleRadius;// 圆的半径

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPaddingTop = getPaddingTop();
    mPaddingBottom = getPaddingBottom();
    mPaddingLeft = getPaddingLeft();
    mPaddingRight = getPaddingRight();

    // 可用宽度和宽度要考虑padding
    mUsableWidth = getWidth() - mPaddingRight - mPaddingLeft;
    mUsableHeight = getHeight() - mPaddingTop - mPaddingBottom;
    // 画笔起始点要考虑padding
    mUsableStartX = mPaddingLeft;
    mUsableStartY = mPaddingTop;

    // 确定可用区域的中心为圆心
    mCircleX = mUsableStartX + mUsableWidth / 2;
    mCircleY = mUsableStartY + mUsableHeight / 2;

    // 确定圆的半径，以可用宽度和高度两者较短的一半为圆的半径
    if (mUsableWidth &amp;lt;= mUsableHeight) {
        mCircleRadius = mUsableWidth / 2;
    } else {
        mCircleRadius = mUsableHeight / 2;
    }

    canvas.drawCircle(mCircleX, mCircleY, mCircleRadius, mPaint);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在布局文件中设置 paddingLeft 为15dp，paddingRight 为30dp，为了更好看出间距，将控件的背景颜色设为了黑色，查看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;cn.codingblock.view.reset_view.MyView
        android:id=&quot;@+id/myview&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:paddingLeft=&quot;15dp&quot;
        android:paddingRight=&quot;30dp&quot;
        android:background=&quot;#000&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218231256850-2026384580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，在 onDraw() 方法对padding处理之后，在布局文件中无论怎么设置padding，都能保证圆心在可用区域的中心。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为自定义 View 添加自定义属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先在 res/values 路径下创建一个xml文件，添加一个设置圆的颜色的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;declare-styleable name=&quot;MyView&quot;&amp;gt;
        &amp;lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&amp;gt;
    &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造方法中解析属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public MyView(Context context, @Nullable AttributeSet attrs) {
    super(context, attrs);
    TypedArray typeArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);
    mColor = typeArray.getColor(R.styleable.MyView_circle_color, mColor);
    typeArray.recycle();
    init();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在布局文件中这是属性就可以了，要注意的是，在使用自定义属性时要添加 xmlns:app=&quot;&lt;a href=&quot;http://schemas.android.com/apk/res-auto&quot; class=&quot;uri&quot;&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt;&quot; 才可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;cn.codingblock.view.activity.MyViewActivity&quot;&amp;gt;

    &amp;lt;cn.codingblock.view.reset_view.MyView
        android:id=&quot;@+id/myview&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:paddingLeft=&quot;15dp&quot;
        android:paddingRight=&quot;30dp&quot;
        app:circle_color=&quot;#ad42ce&quot;
        android:background=&quot;#000&quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改变颜色后的效果图如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218221850928-544517003.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为自定义view添加交互事件&quot;&gt;为自定义View添加交互事件&lt;/h3&gt;
&lt;h4 id=&quot;motionevent-触摸事件&quot;&gt;MotionEvent 触摸事件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            Log.i(TAG, &quot;onTouchEvent: ACTION_DOWN&quot;);
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }
    return super.onTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在自定义 View 中，重写 onTouchEvent() 方法，获取 MotionEvent，正如上面代码所写，MotionEvent 比较常用的事件有三种 ACTION_DOWN、ACTION_MOVE、ACTION_UP 分别对应手指按下-移动-离开。&lt;/p&gt;
&lt;p&gt;接下来对上面的圆形demo添加一个小事件，就是每当手指点击一下屏幕，圆形就随机换一种颜色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Random mRandom = new Random(100);
private int[] mColors = new int[] {
  Color.parseColor(&quot;#ff0000&quot;),
  Color.parseColor(&quot;#ffffff&quot;),
  Color.parseColor(&quot;#ff00ff&quot;),
  Color.parseColor(&quot;#ffff00&quot;),
  Color.parseColor(&quot;#ff00ff&quot;),
  Color.parseColor(&quot;#0000ff&quot;)
};

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mColor = mColors[mRandom.nextInt(6)];
            mPaint.setColor(mColor);
            invalidate(); // 通知控件重绘
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }
    return super.onTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218223436600-637929861.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家也可以在此基础上稍微再扩展一下，例如：通过 event.getX() 和 event.getY() 获取触摸点的坐标，判断出点是否落在了圆形区域内，从而使只有点手指点到圆形区域内才改变颜色，否则不改变。感兴趣的童鞋可自行动手试一试。&lt;/p&gt;
&lt;p&gt;在上面代码中通知 View 重绘时使用了 invalidate() 方法，其实 postInvalidate() 也可以通知 View 重绘，那么这两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;其实简单来说，invalidate() 只能在 UI 线程中使用，而 postInvalidate() 可以在子线程中使用。&lt;/p&gt;
&lt;h4 id=&quot;scalegesturedetector-缩放手指检测&quot;&gt;ScaleGestureDetector 缩放手指检测&lt;/h4&gt;
&lt;p&gt;除了上面最普通的 MotionEvent 事件之外，Android 还提供了很多有趣的事件，就想 GestureDetector（手势检测）、VelocityTracker（速度追踪）等等，用起来也都很方便，其实只要你愿意，这些事件也完全可以在 onTouchEvent() 方法中实现，接下来在为上述的圆形 Demo 添加一个缩放的功能，也就是使用 ScaleGestureDetector 实现，效果跟平时在手机查看照片时我们用两根手指来放大/缩小图片一样。&lt;/p&gt;
&lt;p&gt;ScaleGestureDetector 在使用起来也很简单，首先需要初始化并为其添加一个放缩手势监听器，并且需要在 onTouchEvent() 方法内，通过 ScaleGestureDetector.onTouchEvent(event) 来让 ScaleGestureDetector 接管触摸事件，其余的事项请注意看代码中的注释。&lt;/p&gt;
&lt;p&gt;在上述代码的基础上新增如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Context mContext;
private ScaleGestureDetector mScaleGestureDetector; // 缩放手势检测
private float mScaleRate = 1; // 缩放比率

private void init() {
    mPaint.setAntiAlias(true); // 消除锯齿
    mPaint.setColor(mColor); // 为画笔设置颜色
    // 初始化 ScaleGestureDetector 并添加缩放手势监听器
    mScaleGestureDetector = new ScaleGestureDetector(mContext, mOnScaleGestureListener);
}

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPaddingTop = getPaddingTop();
    mPaddingBottom = getPaddingBottom();
    mPaddingLeft = getPaddingLeft();
    mPaddingRight = getPaddingRight();

    // 可用宽度和宽度要考虑padding
    mUsableWidth = getWidth() - mPaddingRight - mPaddingLeft;
    mUsableHeight = getHeight() - mPaddingTop - mPaddingBottom;
    // 画笔起始点要考虑padding
    mUsableStartX = mPaddingLeft;
    mUsableStartY = mPaddingTop;

    // 确定可用区域的中心为圆心
    mCircleX = mUsableStartX + mUsableWidth / 2;
    mCircleY = mUsableStartY + mUsableHeight / 2;

    // 确定圆的半径，以可用宽度和高度两者较短的一半为圆的半径
    if (mUsableWidth &amp;lt;= mUsableHeight) {
        mCircleRadius = mUsableWidth / 2;
    } else {
        mCircleRadius = mUsableHeight / 2;
    }

    // 让半径乘以缩放倍率
    mCircleRadius *= mScaleRate;
    canvas.drawCircle(mCircleX, mCircleY, mCircleRadius, mPaint);
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mColor = mColors[mRandom.nextInt(6)];
            mPaint.setColor(mColor);
            invalidate(); // 通知控件重绘
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }

    // 让缩放手势检测器接管触摸事件
    if (mScaleGestureDetector.onTouchEvent(event)) {
        return true;
    }

    return super.onTouchEvent(event);
}

private ScaleGestureDetector.OnScaleGestureListener mOnScaleGestureListener = new ScaleGestureDetector.OnScaleGestureListener() {
    @Override
    public boolean onScale(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScale: &quot; + detector.getScaleFactor());
        // 获取缩放比例因子并累乘到缩放倍率上
        mScaleRate *= detector.getScaleFactor();
        postInvalidate();
        return true;
    }

    @Override
    public boolean onScaleBegin(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScaleBegin: &quot; + detector.getScaleFactor());
        return true;
    }

    @Override
    public void onScaleEnd(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScaleEnd: &quot; + detector.getScaleFactor());
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171219183841756-1136104681.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码需要注意的是，在 ScaleGestureDetector 捕获到事件后要正确的将事件消费掉（注意代码中返回 true 的地方），不然缩放手势无法正常工作。&lt;/p&gt;
&lt;p&gt;自定义 View 在 Android 中一直以来都是很重要的一部分，在平时的开发想要做出一个个性炫酷的交互界面是离不开自定义 View，自定义 View 说难不难，说简单也不简单，总之，千里之行，始于足下，只要我们掌握好自定义 View 的基础知识，再复杂的界面也可以一步步完成。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;最后想说的是，本系列文章为博主对Android知识进行再次梳理，查缺补漏的学习过程，一方面是对自己遗忘的东西加以复习重新掌握，另一方面相信在重新学习的过程中定会有巨大的新收获，如果你也有跟我同样的想法，不妨关注我一起学习，互相探讨，共同进步！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考文献：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;《Android开发艺术探索》&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;《Android开发进阶从小工到专家》&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 27 Dec 2017 14:56:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8060101.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】用PaddlePaddle和Tensorflow实现GoogLeNet InceptionV2/V3/V4 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8127780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8127780.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上一篇文章我们引出了GoogLeNet InceptionV1的网络结构，这篇文章中我们会详细讲到Inception V2/V3/V4的发展历程以及它们的网络结构和亮点。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GoogLeNet Inception V2在《&lt;a href=&quot;https://arxiv.org/abs/1502.03167&quot; target=&quot;_blank&quot;&gt;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&lt;/a&gt;》出现，最大亮点是提出了Batch Normalization方法，它起到以下作用：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;e6nx&quot;&gt;&lt;li&gt;&lt;span&gt;使用较大的学习率而不用特别关心诸如梯度爆炸或消失等优化问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;降低了模型效果对初始权重的依赖；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以加速收敛，一定程度上可以不使用Dropout这种降低收敛速度的方法，但却起到了正则化作用提高了模型泛化性；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;即使不使用ReLU也能缓解激活函数饱和问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;能够学习到从当前层到下一层的分布缩放( scaling (方差)，shift (期望))系数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　在机器学习中，我们通常会做一种假设：训练样本独立同分布(iid)且训练样本与测试样本分布一致，如果真实数据符合这个假设则模型效果可能会不错，反之亦然，这个在学术上叫Covariate Shift，所以从样本（外部）的角度说，对于神经网络也是一样的道理。从结构（内部）的角度说，由于神经网络由多层组成，样本在层与层之间边提特征边往前传播，如果每层的输入分布不&lt;span&gt;一致，那么势必造成要么模型效果不好，要么学习速度较慢，学术上这个叫InternalCovariate Shift。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设：&lt;/span&gt;$y$&lt;span&gt;为样本标注&lt;/span&gt;，$X=\{x_{1},x_{2},x_{3},......\}$&lt;span&gt;为样本&lt;/span&gt;$x$&lt;span&gt;通过神经网络若干层后每层的输入&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理论上：&lt;/span&gt;$p(x,y)$&lt;span&gt;的联合概率分布应该与集合$X$中任意一层输入的联合概率分布一致，如&lt;/span&gt;：$p(x,y)=p(x_{1},y)$；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是&lt;/span&gt;：$p(x,y)=p(y|x)·p(x)$,&lt;span&gt;其中条件概率&lt;/span&gt;$p(y|x)$&lt;span&gt;是一致的，即&lt;/span&gt;$p(y|x)=p(y|x_{1})=p(y|x_{1})=......$，&lt;span&gt;但由于神经网络每一层对输入分布的改变，导致边缘概率是不一致的，即&lt;/span&gt;$p(x)\neq p(x_{1})\neq p(x_{2})......$，&lt;span&gt;甚至随着网络深度的加深，前面层微小的变化会导致后面层巨大的变化&lt;/span&gt;。&lt;/p&gt;

&lt;p data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;BN整个算法过程&lt;/strong&gt;&lt;/span&gt;如下： &lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213442300-1929291972.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;以batch的方式做训练，对m个样本求期望和方差后对训练数据做白化，通过白化操作可以去除特征相关性并把数据缩放在一个球体上，这么做的好处既可以加快优化算法的优化速度也可能提高优化精度，一个直观的解释：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213525769-1070431385.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;166&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 左边是未做白化的原始可行域，右边是做了白化的可行域；&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;q7vu&quot;&gt;&lt;li&gt;&lt;span&gt;当原始输入对模型学习更有利时能够恢复原始输入（和残差网络有点神似）：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213546160-588739520.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;266&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里的参数$\gamma$和$\sigma$&lt;span&gt;是需要学习的。&lt;/span&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-185-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-186-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5132-卷积神经网络中的bn&quot; data-anchor-id=&quot;pem8&quot;&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;卷积神经网络中的BN&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　卷积网络中采用权重共享策略，每个feature map只有一对$\gamma$和$\sigma$&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-194-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-195-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;需要学习。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax_SVG&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213751206-122407428.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;235&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h2 id=&quot;514-googlenet-inception-v3&quot; data-anchor-id=&quot;by49&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-anchor-id=&quot;9xhz&quot;&gt;&lt;span&gt;GoogLeNet Inception V3在《Rethinking the Inception Architecture for Computer Vision》中提出（注意，在这篇论文中作者把该网络结构叫做v2版，我们以最终的v4版论文的划分为标准），该论文的亮点在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;6sez&quot;&gt;&lt;li&gt;&lt;span&gt;提出通用的网络结构设计准则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引入卷积分解提高效率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引入高效的feature map降维&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5141-网络结构设计的准则&quot; data-anchor-id=&quot;m5ig&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络结构设计的准则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;前面也说过，深度学习网络的探索更多是个实验科学，在实验中人们总结出一些结构设计准则，但说实话我觉得不一定都有实操性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;避免特征表示上的瓶颈，尤其在神经网络的前若干层 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;神经网络包含一个自动提取特征的过程，例如多层卷积，直观并符合常识的理解：如果在网络初期特征提取的太粗，细节已经丢了，后续即使结构再精细也没法做有效表示了；举个极端的例子：在宇宙中辨别一个星球，正常来说是通过由近及远，从房屋、树木到海洋、大陆板块再到整个星球之后进入整个宇宙，如果我们一开始就直接拉远到宇宙，你会发现所有星球都是球体，没法区分哪个是地球哪个是水星。所以feature map的大小应该是随着层数的加深逐步变小，但为了保证特征能得到有效表示和组合其通道数量会逐渐增加。 　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;下图违反了这个原则，刚开就始直接从35×35×320被抽样降维到了17×17×320，特征细节被大量丢失，即使后面有Inception去做各种特征提取和组合也没用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214036019-2049622062.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;171&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于神经网络的某一层，通过更多的激活输出分支可以产生互相解耦的特征表示，从而产生高阶稀疏特征，从而加速收敛，注意下图的1×3和3×1激活输出：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214217144-150696561.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;249&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;合理使用维度缩减不会破坏网络特征表示能力反而能加快收敛速度，典型的例如通过两个3×3代替一个5×5的降维策略，不考虑padding，用两个3×3代替一个5×5能节省1-（3×3+3×3）/(5×5)=28%的计算消耗。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214239628-2001866412.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;223&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以及一个n×n卷积核通过顺序相连的两个1×n和n×1做降维（有点像矩阵分解），如果n=3，计算性能可以提升1-(3+3)/9=33%，但如果考虑高性能计算性能，这种分解可能会造成L1 cache miss率上升。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214259378-866463491.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;295&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;2spf&quot;&gt;&lt;li&gt;&lt;span&gt;通过合理平衡网络的宽度和深度优化网络计算消耗（这句话尤其不具有实操性）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;抽样降维，传统抽样方法为pooling+卷积操作，为了防止出现特征表示的瓶颈，往往需要更多的卷积核，例如输入为n个d×d的feature map，共有k个卷积核，pooling时stride=2，为不出现特征表示瓶颈，往往k的取值为2n，通过引入inception module结构，即降低计算复杂度，又不会出现特征表示瓶颈，实现上有如下两种方式：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214334613-2045548073.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;292&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5142-平滑样本标注&quot; data-anchor-id=&quot;i73w&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;平滑样本标注&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-anchor-id=&quot;esus&quot;&gt;&lt;span&gt;对于多分类的样本标注一般是one-hot的，例如[0,0,0,1]，使用类似交叉熵的损失函数会使得模型学习中对ground truth标签分配过于置信的概率，并且由于ground truth标签的logit值与其他标签差距过大导致，出现过拟合，导致降低泛化性。一种解决方法是加正则项，即对样本标签给个概率分布做调节，使得样本标注变成“soft”的，例如[0.1,0.2,0.1,0.6]，这种方式在实验中降低了top-1和top-5的错误率0.2%。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5143-网络结构&quot; data-anchor-id=&quot;u3ju&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;网络结构&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214413253-565722322.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;589&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 data-anchor-id=&quot;6nav&quot;&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V4&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;GoogLeNet Inception V4/和ResNet V1/V2这三种结构在《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》一文中提出，论文的亮点是：提出了效果更好的GoogLeNet Inception v4网络结构；与残差网络融合，提出效果不逊于v4但训练速度更快的结构。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5151-googlenet-inception-v4网络结构&quot; data-anchor-id=&quot;9105&quot;&gt;&lt;span&gt;GoogLeNet Inception V4网络结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227215021394-1251296998.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;687&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5152-googlenet-inception-resnet网络结构&quot; data-anchor-id=&quot;ehr4&quot;&gt;&lt;span&gt;GoogLeNet Inception ResNet网络结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227215104441-1140736506.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;731&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;代码实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;Tensorflow的代码在slim模块下有完整的实现，paddlepaddle的可以参考上篇文章中写的inception v1的代码来写。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这篇文章比较偏理论，主要讲了GoogLeNet的inception模块的发展，包括在v2中提出的batch normalization，v3中提出的卷积分级与更通用的网络结构准则，v4中的与残差网络结合等，在实际应用过程中可以可以对同一份数据用不同的网络结构跑一跑，看看结果如何，实际体验一下不同网络结构的loss下降速率，对准确率的提升等。　 &lt;/span&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 14:02:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8127780.html</dc:identifier>
</item>
</channel>
</rss>