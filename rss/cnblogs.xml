<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>理解观察者、中介者模式 - BOT-Man</title>
<link>http://www.cnblogs.com/BOT-Man/p/7637308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BOT-Man/p/7637308.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2017/10/6&lt;/p&gt;
&lt;p&gt;Any fool can write code that a computer can understand.&lt;br/&gt;Good programmers write code that humans can understand.&lt;br/&gt;—— Martin Fowler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么要写这篇文章&quot;&gt;为什么要写这篇文章&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;观察者&lt;/strong&gt; &lt;em&gt;(observer)&lt;/em&gt; 模式和 &lt;strong&gt;中介者&lt;/strong&gt; &lt;em&gt;(mediator)&lt;/em&gt; 模式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles?post=2017/Design-Patterns-Notes-3#decouple-sender-receiver&quot;&gt;调用流程非常相似&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;网上相关资料、代码对两者区别的解释不够清楚&lt;/li&gt;
&lt;li&gt;两个设计模式在 &lt;strong&gt;图形界面&lt;/strong&gt; &lt;em&gt;(GUI)&lt;/em&gt; 编程中，被广泛使用&lt;/li&gt;
&lt;li&gt;学习的过程是：不知道 -&amp;gt; 知道 -&amp;gt; 能向别人解释清楚&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;首先需要知道 &lt;a href=&quot;https://bot-man-jl.github.io/articles?post=2017/Callback-Explained&quot;&gt;回调函数的基本概念&lt;/a&gt; 。。&lt;/p&gt;
&lt;h3 id=&quot;观察者-observer-模式&quot;&gt;观察者 &lt;em&gt;(observer)&lt;/em&gt; 模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;strong&gt;订阅-发布&lt;/strong&gt; &lt;em&gt;(subscribe-publish)&lt;/em&gt; 模型，消除组件之间双向依赖&lt;/li&gt;
&lt;li&gt;消息的 &lt;strong&gt;发布者&lt;/strong&gt; &lt;em&gt;(subject)&lt;/em&gt; 不需要知道 &lt;strong&gt;观察者&lt;/strong&gt; &lt;em&gt;(observer)&lt;/em&gt; 的存在&lt;/li&gt;
&lt;li&gt;两者只需要约定消息的格式（如何订阅、如何发布），就可以通信&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles?post=2017/Design-Patterns-Notes-3#observer&quot;&gt;笔记链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;中介者-mediator-模式&quot;&gt;中介者 &lt;em&gt;(mediator)&lt;/em&gt; 模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过设置 &lt;strong&gt;消息中心&lt;/strong&gt; &lt;em&gt;(message center)&lt;/em&gt;，避免组件之间直接依赖&lt;/li&gt;
&lt;li&gt;所有的 &lt;strong&gt;协同者&lt;/strong&gt; &lt;em&gt;(colleague)&lt;/em&gt; 只能通过 &lt;strong&gt;中介者&lt;/strong&gt; &lt;em&gt;(mediator)&lt;/em&gt; 进行通信，&lt;br/&gt;而相互之间不知道彼此的存在&lt;/li&gt;
&lt;li&gt;当各个组件的消息出现循环时，消息中心可以消除组件之间的依赖混乱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles?post=2017/Design-Patterns-Notes-3#mediator&quot;&gt;笔记链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;两者的联系&quot;&gt;两者的联系&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;中介者模式 一般通过 观察者模式 实现&lt;/li&gt;
&lt;li&gt;协同者 作为 发布者，中介者 作为 观察者&lt;/li&gt;
&lt;li&gt;协同者 发布消息 -&amp;gt; 中介者 收到并处理消息 -&amp;gt; 中介者 直接发送消息给 协同者&lt;/li&gt;
&lt;li&gt;协同者 不依赖于 中介者&lt;/li&gt;
&lt;li&gt;当组件之间依赖关系简单时，可以直接使用 观察者模式&lt;/li&gt;
&lt;li&gt;当组件之间依赖关系复杂是，需要借助 中介者模式 梳理关系&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;需求html&quot;&gt;需求（HTML）&lt;/h2&gt;
&lt;p&gt;我们需要实现一个简单的 输入框-选择框 同步的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从 输入框 输入：将输入的 文本 同步到 选择框（如果存在对应的 选择项）&lt;/li&gt;
&lt;li&gt;从 选择框 选择：将选择的 选择项 同步到 输入框&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;博客园已阻止脚本，可以到原文查看效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;no-number-在线演示-html-代码&quot;&gt;[no-number] 在线演示 HTML 代码&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;textbox&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       oninput=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;document.getElementById('listbox').value =&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;       document.getElementById('textbox').value&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;select&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;listbox&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        onchange=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;document.getElementById('textbox').value =&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;        document.getElementById('listbox').value&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;实现c&quot;&gt;实现（C++）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;代码使用 C++ 编写，可以通过 &lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/run.sh&quot;&gt;脚本&lt;/a&gt; 运行&lt;/li&gt;
&lt;li&gt;代码基于一个 &lt;del&gt;假想的&lt;/del&gt; 😂 &lt;strong&gt;组件库&lt;/strong&gt; &lt;em&gt;(Widget Library)&lt;/em&gt; 进行开发&lt;/li&gt;
&lt;li&gt;代码流程包含两个部分：&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Client&lt;/em&gt; 初始化流程：初始化组件，并设置依赖&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Invoker&lt;/em&gt; 模拟用户行为：模拟用户对组件的操作，并查看效果（自动化测试）&lt;/li&gt;
&lt;li&gt;如果所有的 &lt;em&gt;Invoker&lt;/em&gt; 行为符合预期，通过测试：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;设置 输入框 的文本，检查 选择框 的选择项是否同步&lt;/li&gt;
&lt;li&gt;设置 选择框 的选择项，检查 输入框 的文本是否同步&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;假想的-组件库&quot;&gt;&lt;del&gt;假想的&lt;/del&gt; 组件库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们使用的组件库包含两个基本组件：输入框 和 选择框&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/widget.h&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;利用 &lt;code&gt;using MyItem = std::string;&lt;/code&gt; 定义默认的文本类型为一般的字符类型，并填入模板参数 &lt;code&gt;Item&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;输入框-textbox&quot;&gt;输入框 &lt;code&gt;TextBox&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;设置输入框文本 &lt;code&gt;SetText&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取输入框文本 &lt;code&gt;GetText&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接收用户行为 &lt;code&gt;OnInput&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当用户在输入框输入文本时，组件库调用这个虚函数&lt;/li&gt;
&lt;li&gt;组件库的使用者重载这个函数，定义组件行为&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw&quot;&gt;typename&lt;/span&gt; Item&amp;gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TextBox {
    Item _item;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    TextBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;item);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetText (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;item);
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;GetText () &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;// Interface for Invoker&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnInput () = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;选择框-listbox&quot;&gt;选择框 &lt;code&gt;ListBox&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;设置选择项 &lt;code&gt;SetSelection&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取选择项 &lt;code&gt;GetSelection&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接收用户行为 &lt;code&gt;OnChange&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当用户在选择框选择项目时，组件库调用这个虚函数&lt;/li&gt;
&lt;li&gt;组件库的使用者重载这个函数，定义组件行为&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw&quot;&gt;typename&lt;/span&gt; Item&amp;gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ListBox {
    std::vector&amp;lt;Item&amp;gt; _items;
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; _index;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    ListBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; std::vector&amp;lt;Item&amp;gt; &amp;amp;items,
             &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetSelection (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;item);
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;GetSelection () &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;// Interface for Invoker&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnChange () = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;最简单的实现&quot;&gt;最简单的实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过自定义组件的方法，重载原始的用户行为，从而实现界面逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/solution-plain.cpp&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自定义输入框&quot;&gt;自定义输入框&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;继承于 &lt;code&gt;TextBox&amp;lt;MyItem&amp;gt;&lt;/code&gt;，额外保存一个 选择框 的引用&lt;/li&gt;
&lt;li&gt;当用户输入 &lt;code&gt;OnInput&lt;/code&gt; 时，调用 选择框 的设置函数 &lt;code&gt;SetSelection&lt;/code&gt;，设置为 输入框 的内容 &lt;code&gt;GetText&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyTextBox : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TextBox&amp;lt;MyItem&amp;gt; {
    std::weak_ptr&amp;lt;MyListBox&amp;gt; _listbox;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    MyTextBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetListBox (std::weak_ptr&amp;lt;MyListBox&amp;gt; &amp;amp;&amp;amp;p) { _listbox = p; }
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnInput () &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; p = _listbox.lock ())
            p-&amp;gt;SetSelection (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;GetText ());
    }
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;自定义选择框&quot;&gt;自定义选择框&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;继承于 &lt;code&gt;ListBox&amp;lt;MyItem&amp;gt;&lt;/code&gt;，额外保存一个 输入框 的引用&lt;/li&gt;
&lt;li&gt;当用户选择 &lt;code&gt;OnChange&lt;/code&gt; 时，调用 输入框 的设置函数 &lt;code&gt;SetText&lt;/code&gt;，设置为 选择框 的选项 &lt;code&gt;GetSelection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyListBox : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ListBox&amp;lt;MyItem&amp;gt; {
    std::weak_ptr&amp;lt;MyTextBox&amp;gt; _textbox;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    MyListBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; std::vector&amp;lt;MyItem&amp;gt; &amp;amp;items,
               &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetTextBox (std::weak_ptr&amp;lt;MyTextBox&amp;gt; &amp;amp;&amp;amp;p) { _textbox = p; }
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnChange () &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; p = _textbox.lock ())
            p-&amp;gt;SetText (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;GetSelection ());
    }
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;初始化流程&quot;&gt;初始化流程&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;分别构造一个 输入框 &lt;code&gt;textbox&lt;/code&gt; 和 选择框 &lt;code&gt;listbox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;相互设置为依赖对象&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; textbox = std::make_shared&amp;lt;MyTextBox&amp;gt; (items[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; listbox = std::make_shared&amp;lt;MyListBox&amp;gt; (items, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

textbox-&amp;gt;SetListBox (listbox);
listbox-&amp;gt;SetTextBox (textbox);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;相关讨论&quot;&gt;相关讨论&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;类似于在线演示的代码，&lt;code&gt;MyTextBox&lt;/code&gt; 和 &lt;code&gt;MyListBox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构成强耦合 —— 两者相互依赖，协同调用（一个类的成员函数内，调用另一个类的成员函数）&lt;/li&gt;
&lt;li&gt;不易于复用 —— 硬编码界面逻辑，难以重复利用&lt;/li&gt;
&lt;li&gt;当界面变得复杂时，不易于维护，例如&lt;/li&gt;
&lt;li&gt;新增组件：需要新组件和原有的两个组件分别耦合，界面逻辑变得复杂而且零散&lt;/li&gt;
&lt;li&gt;修改行为：如果需要修改个组件的行为，可能涉及到多处代码的改动（没遇到过，目前至少假设。。。）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;改进-基于-观察者模式-的实现&quot;&gt;改进 —— 基于 观察者模式 的实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;应用观察者模式，将用户行为委托到观察者的回调函数上，消除组件之间双向依赖&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/solution-observer.cpp&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在原有组件库 的基础上，我们封装了一个可观察的组件库 &lt;em&gt;(Observable Widget Library)&lt;/em&gt;，用于实现观察者模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;可观察的组件库&quot;&gt;可观察的组件库&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;继承于 &lt;code&gt;TextBox&amp;lt;Item&amp;gt;&lt;/code&gt;/&lt;code&gt;ListBox&amp;lt;Item&amp;gt;&lt;/code&gt;，额外保存一个 &lt;code&gt;Observer&lt;/code&gt; 的引用&lt;/li&gt;
&lt;li&gt;将原始的用户行为，重定向到 观察者 上：&lt;/li&gt;
&lt;li&gt;当用户输入 &lt;code&gt;OnInput&lt;/code&gt; 时，调用 观察者 的回调函数 &lt;code&gt;TextUpdated&lt;/code&gt;，设置为 输入框 的内容 &lt;code&gt;GetText&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当用户选择 &lt;code&gt;OnChange&lt;/code&gt; 时，调用 观察者 的回调函数 &lt;code&gt;SelectionChanged&lt;/code&gt;，设置为 选择框 的选项 &lt;code&gt;GetSelection&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/observable-widget.h&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw&quot;&gt;typename&lt;/span&gt; Item&amp;gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ObservableTextBox : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; TextBox&amp;lt;Item&amp;gt; {
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    ObservableTextBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;item);

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Observer {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;// Interface for Observer&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; TextUpdated (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;) = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    };
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetObserver (std::weak_ptr&amp;lt;Observer&amp;gt; &amp;amp;&amp;amp;p) { _observer = p; }

    &lt;span class=&quot;co&quot;&gt;// Interface for Invoker&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnInput () &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; p = _observer.lock ())
            p-&amp;gt;TextUpdated (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;GetText ());
    }

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;:
    std::weak_ptr&amp;lt;Observer&amp;gt; _observer;
};

&lt;span class=&quot;kw&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;kw&quot;&gt;typename&lt;/span&gt; Item&amp;gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ObservableListBox : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ListBox&amp;lt;Item&amp;gt; {
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    ObservableListBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; std::vector&amp;lt;Item&amp;gt; &amp;amp;items,
                       &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Observer {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;// Interface for Observer&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SelectionChanged (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; Item &amp;amp;) = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    };
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SetObserver (std::weak_ptr&amp;lt;Observer&amp;gt; &amp;amp;&amp;amp;p) { _observer = p; }

    &lt;span class=&quot;co&quot;&gt;// Interface for Invoker&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnChange () &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; p = _observer.lock ())
            p-&amp;gt;SelectionChanged (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;GetSelection ());
    }

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;:
    std::weak_ptr&amp;lt;Observer&amp;gt; _observer;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;相互观察的输入框选择框&quot;&gt;相互观察的输入框/选择框&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义观察关系：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyTextBox&lt;/code&gt; 继承于 &lt;code&gt;ObservableTextBox&amp;lt;MyItem&amp;gt;&lt;/code&gt; 和 &lt;code&gt;ObservableListBox&amp;lt;MyItem&amp;gt;::Observer&lt;/code&gt;，即 我们的输入框 作为 选择框的观察者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyListBox&lt;/code&gt; 继承于 &lt;code&gt;ObservableListBox&amp;lt;MyItem&amp;gt;&lt;/code&gt; 和 &lt;code&gt;ObservableTextBox&amp;lt;MyItem&amp;gt;::Observer&lt;/code&gt;，即 我们的选择框 作为 输入框的观察者&lt;/li&gt;
&lt;li&gt;定义观察行为：&lt;/li&gt;
&lt;li&gt;输入框 观察到 选择框变化 &lt;code&gt;SelectionChanged&lt;/code&gt; 时，更新文本 &lt;code&gt;SetText&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择框 观察到 输入框输入 &lt;code&gt;TextUpdated&lt;/code&gt; 时，更新选项 &lt;code&gt;SetSelection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyTextBox :
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ObservableTextBox&amp;lt;MyItem&amp;gt;,
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ObservableListBox&amp;lt;MyItem&amp;gt;::Observer
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    MyTextBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SelectionChanged (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item) &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;SetText (item);
    }
};

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyListBox :
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ObservableListBox&amp;lt;MyItem&amp;gt;,
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ObservableTextBox&amp;lt;MyItem&amp;gt;::Observer
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    MyListBox (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; std::vector&amp;lt;MyItem&amp;gt; &amp;amp;items,
               &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; TextUpdated (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item) &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;-&amp;gt;SetSelection (item);
    }
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;初始化流程-1&quot;&gt;初始化流程&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;分别构造一个 输入框 &lt;code&gt;textbox&lt;/code&gt; 和 选择框 &lt;code&gt;listbox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;相互设置为观察的对象（发布者）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; textbox = std::make_shared&amp;lt;MyTextBox&amp;gt; (items[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; listbox = std::make_shared&amp;lt;MyListBox&amp;gt; (items, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

textbox-&amp;gt;SetObserver (listbox);
listbox-&amp;gt;SetObserver (textbox);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;相关讨论-1&quot;&gt;相关讨论&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用观察者模式&lt;/li&gt;
&lt;li&gt;接收到用户行为的组件（发布者） 将 组件的用户行为 作为消息，发布到 订阅了这个消息的组件（观察者）上&lt;/li&gt;
&lt;li&gt;从而实现了 &lt;strong&gt;界面逻辑的处理&lt;/strong&gt; 从 &lt;strong&gt;接收到用户行为的组件&lt;/strong&gt; 转移到 &lt;strong&gt;对这个用户行为感兴趣的组件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;而不是由 接收到用户行为的组件 直接处理消息，从而解除了双向的相互依赖（因为接收到消息的一方需要依赖于处理消息的一方）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在这个例子中&lt;/strong&gt;，输入框内容 发生变化时，它本身不知道如何处理（因为它不是 选择框，不能更新选择项），而是通知对这个变化改兴趣的 选择框 去处理当前的用户行为（更新选择项）&lt;/li&gt;
&lt;li&gt;但是，当界面变得复杂时，组件对用户行为的处理逻辑仍然非常零散&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;再改进-基于-中介者模式-的实现&quot;&gt;再改进 —— 基于 中介者模式 的实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;应用中介者模式，将用户行为委托到中介者上，避免组件之间直接依赖&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/solution-mediator.cpp&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;中介者模式基于观察者模式实现，所以这里仍使用之前定义的可观察的组件库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;定义消息中心中介者&quot;&gt;定义消息中心（中介者）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;定义观察关系：&lt;/li&gt;
&lt;li&gt;输入框 &lt;code&gt;ObservableTextBox&amp;lt;MyItem&amp;gt;&lt;/code&gt; 和 选择框 &lt;code&gt;ObservableListBox&amp;lt;MyItem&amp;gt;&lt;/code&gt; 不再相互观察，而是作为独立的组件存在&lt;/li&gt;
&lt;li&gt;中介者 &lt;code&gt;Mediator&lt;/code&gt; 继承于 &lt;code&gt;MyTextBox::Observer&lt;/code&gt; 和 &lt;code&gt;MyListBox::Observer&lt;/code&gt;，即 作为 输入框、选择框的观察者&lt;/li&gt;
&lt;li&gt;定义观察行为：&lt;/li&gt;
&lt;li&gt;中介者 观察到 输入框输入 &lt;code&gt;TextUpdated&lt;/code&gt; 时，更新 选择框选项 &lt;code&gt;SetSelection&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中介者 观察到 选择框变化 &lt;code&gt;SelectionChanged&lt;/code&gt; 时，更新 输入框文本 &lt;code&gt;SetText&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; MyTextBox = ObservableTextBox&amp;lt;MyItem&amp;gt;;
&lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; MyListBox = ObservableListBox&amp;lt;MyItem&amp;gt;;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Mediator :
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; MyTextBox::Observer,
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; MyListBox::Observer
{
    std::shared_ptr&amp;lt;MyTextBox&amp;gt; _textbox;
    std::shared_ptr&amp;lt;MyListBox&amp;gt; _listbox;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    Mediator (std::shared_ptr&amp;lt;MyTextBox&amp;gt; &amp;amp;textbox,
              std::shared_ptr&amp;lt;MyListBox&amp;gt; &amp;amp;listbox);

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; TextUpdated (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item) &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        _listbox-&amp;gt;SetSelection (item);
    }

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; SelectionChanged (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; MyItem &amp;amp;item) &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; {
        _textbox-&amp;gt;SetText (item);
    }
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;初始化流程-2&quot;&gt;初始化流程&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;分别构造 输入框 &lt;code&gt;textbox&lt;/code&gt;、选择框 &lt;code&gt;listbox&lt;/code&gt; 和 中介者 &lt;code&gt;mediator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 中介者 作为另外两个对象（发布者）的 观察者&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; textbox = std::make_shared&amp;lt;MyTextBox&amp;gt; (items[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; listbox = std::make_shared&amp;lt;MyListBox&amp;gt; (items, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; mediator = std::make_shared&amp;lt;Mediator&amp;gt; (textbox, listbox);

textbox-&amp;gt;SetObserver (mediator);
listbox-&amp;gt;SetObserver (mediator);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;相关讨论-2&quot;&gt;相关讨论&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用中介者模式&lt;/li&gt;
&lt;li&gt;化简了观察关系：所有组件只能和 中介者 通信，组件之间没有消息传递&lt;/li&gt;
&lt;li&gt;化简了观察行为：原本零散的消息传递关系，集中于 中介者 内部实现&lt;/li&gt;
&lt;li&gt;相对于零散的观察者&lt;/li&gt;
&lt;li&gt;把 &lt;strong&gt;组件之间消息的耦合&lt;/strong&gt; 转化为 &lt;strong&gt;中介者的内聚&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从而实现了 高内聚、低耦合&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;另一种基于-中介者模式-的实现&quot;&gt;另一种基于 中介者模式 的实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;中介者 作为消息中心，保存了对所有组件的引用（依赖于所有的组件），从而对所有的组件进行协调&lt;/li&gt;
&lt;li&gt;所以，我们可以使用另一种 观察者模式 的实现 —— 基于 &lt;strong&gt;拉取模型&lt;/strong&gt; &lt;em&gt;(pull model)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/solution-mediator-pull.cpp&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基于拉取的可观察组件库&quot;&gt;基于拉取的可观察组件库&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;和 &lt;strong&gt;推送模型&lt;/strong&gt; &lt;em&gt;(push model)&lt;/em&gt; 不同，&lt;code&gt;Observer&lt;/code&gt; 的接口没有参数&lt;/li&gt;
&lt;li&gt;发布者 仅仅告知有消息到达，而不告知消息的内容&lt;/li&gt;
&lt;li&gt;观察者 不能直接从接收到的消息获取内容（进一步通过拉取的方式获取消息）&lt;/li&gt;
&lt;li&gt;这就类似于&lt;/li&gt;
&lt;li&gt;推送模型：手机（发布者）收到消息时，消息提示音响起，用户（观察者）能在锁屏界面上看到消息的内容&lt;/li&gt;
&lt;li&gt;拉取模型：朋友圈（发布者）更新时，只会显示一个小红点，用户（观察者）需要点进去才能看到更新&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2017/Observer-Mediator-Explained/observable-widget-pull.h&quot;&gt;代码链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ObservableTextBox::Observer {
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;co&quot;&gt;// Interface for Observer&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; TextUpdated () = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// omitting param 'const Item &amp;amp;'&lt;/span&gt;
};

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ObservableTextBox::OnInput () {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; p = _observer.lock ())
        p-&amp;gt;TextUpdated ();     &lt;span class=&quot;co&quot;&gt;// omitting argument 'this-&amp;gt;GetText ()'&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;重新定义消息中心中介者&quot;&gt;重新定义消息中心（中介者）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;当 观察者 收到消息时，中介者 通过被观察对象（发布者）获取需要的内容，而不是直接从推送的消息中获取&lt;/li&gt;
&lt;li&gt;由于 中介者 保存了对所有组件的引用（依赖于所有的组件），可以方便的直接获取需要的内容&lt;/li&gt;
&lt;li&gt;而对于 没有中介者 的设计，保存交叉引用会导致代码变得混乱，进而退化为最开始讨论的形式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Mediator::TextUpdated () {
    _listbox-&amp;gt;SetSelection (_textbox-&amp;gt;GetText ());
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Mediator::SelectionChanged () {
    _textbox-&amp;gt;SetText (_listbox-&amp;gt;GetSelection ());
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;no-number-写在最后&quot;&gt;[no-number] 写在最后&lt;/h2&gt;
&lt;p&gt;本文仅是我对设计模式的一些理解。如果有什么问题，望&lt;strong&gt;不吝赐教&lt;/strong&gt;。😄&lt;/p&gt;
&lt;p&gt;感谢 &lt;a href=&quot;https://github.com/thiefuniverse&quot;&gt;@flythief&lt;/a&gt; 提出的修改意见~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Related&lt;/strong&gt;: Design Patterns Notes&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2017/Observer-Mediator-Explained&quot; class=&quot;uri&quot;&gt;https://bot-man-jl.github.io/articles/?post=2017/Observer-Mediator-Explained&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号：BOTManJL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692813/201710/692813-20171008141411996-1252428893.jpg&quot; alt=&quot;BOTManJL&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Delivered under MIT License © 2017, BOT Man&lt;/p&gt;
</description>
<pubDate>Sun, 08 Oct 2017 06:15:00 +0000</pubDate>
<dc:creator>BOT-Man</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BOT-Man/p/7637308.html</dc:identifier>
</item>
<item>
<title>JavaWeb（三）JSP概述 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7637295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7637295.html</guid>
<description>&lt;p&gt;　　初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法。&lt;/p&gt;&lt;p&gt;　　销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例。&lt;/p&gt;&lt;p&gt;　　可以看到public final class NewFile_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent&lt;/p&gt;&lt;div readability=&quot;109&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5b66e120-002e-4edf-a34f-736859dadabc')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_5b66e120-002e-4edf-a34f-736859dadabc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5b66e120-002e-4edf-a34f-736859dadabc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5b66e120-002e-4edf-a34f-736859dadabc',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5b66e120-002e-4edf-a34f-736859dadabc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

package org.apache.jasper.runtime;

import java.io.IOException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.HttpJspPage;

import org.apache.jasper.compiler.Localizer;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * This is the super class of all JSP-generated servlets.
 *
 * @author Anil K. Vijendran
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpJspBase extends HttpServlet implements HttpJspPage {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;1L&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; HttpJspBase() {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(ServletConfig config) 
        throws ServletException 
    {
        super.init(config);
        jspInit();
        _jspInit();
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getServletInfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Localizer.getMessage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsp.engine.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
        jspDestroy();
        _jspDestroy();
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Entry point into service.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; service(HttpServletRequest request, HttpServletResponse response) 
        throws ServletException, IOException 
    {
        _jspService(request, response);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; jspInit() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; _jspInit() {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; jspDestroy() {
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; _jspDestroy() {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; _jspService(HttpServletRequest request, 
                                     HttpServletResponse response) 
        throws ServletException, IOException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;HttpJspBase.java&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　public abstract class HttpJspBase extends &lt;span&gt;HttpServlet &lt;/span&gt;implements &lt;span&gt;HttpJspPage &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　看到了一个熟悉的类，HttpServlet，我们编写Servlet时就是继承自该类，这里也是继承HttpServlet，并且HttpJspBase的源码会发现，&lt;/p&gt;
&lt;p&gt;　　生命周期也是有init()方法，service()方法，destory()方法，相当于_jspService()方法就是servlet的service()方法的执行，所以说JSP也是一个servlet。&lt;/p&gt;
&lt;p&gt;　　4）我们在JSP写的所有html代码，都会被转换为servlet中的out.write(html)代码来输出。看图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008131441278-2036316812.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;481&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.7、JSP概述总结&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008132342184-1205025459.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于jsp转换成的servlet源码，之后我们会在进行详细分析，现在只需要知道jsp中的内容在servlet中被转换成什么了，在哪里被转换了即可。&lt;/p&gt;
&lt;p&gt;　　注意：jsp 生成java源码，默认第一次生成，之后直接执行，除非内容修改，具体点说，&lt;span&gt;由于JSP只会在客户端第一次请求的时候被编译，因此第一次请求JSP时会感觉比较慢，而之后的请求因为不会编译JSP，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　所以速度就快多了&lt;/span&gt;，如果将&lt;span&gt;Tomcat保存的JSP编译后的class文件删除，Tomcat也会重新编译JSP&lt;/span&gt;。在&lt;span&gt;开发Web程序的时候经常需要修改JSP,Tomcat能够自动检测到JSP程序的改动，如果检测到JSP源代码发生了改动，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Tomcat会在下次客户端请求JSP时重新编译JSP,而不需要重启Tomcat，这种自动检测功能默认是开启的&lt;/span&gt;，检测改动会消耗少量的时间，在部署web应用程序的时候可以在web.xml中将它关掉。&lt;/p&gt;
&lt;p&gt;　　　　这也就是为什么我们能够在jsp页面直接修改内容，而不用重新启动服务器的原因。&lt;/p&gt;
&lt;p&gt;　　　　因为JSP就是servlet，那么生命周期也就是跟serlvet一样。&lt;/p&gt;
&lt;p&gt;　　　　JSP和servlet有一点区别就在于：jsp是先部署后编译，而servlet是先编译后部署。&lt;/p&gt;
&lt;p&gt;　　从上面分析得出：　　　　&lt;/p&gt;
&lt;p&gt;　　　　Servlet：控制器。重点编写java代码逻辑 （获取表单数据、处理业务逻辑、分发转向）&lt;br/&gt;　　　　JSP：代码显示模板。重点在于显示数据&lt;/p&gt;

&lt;h2&gt;2.1、JSP模板数据　&lt;/h2&gt;
&lt;p&gt;　　　就是JSP中的HTML代码，它的内容给是固定的，无论程序如何运行模版数据输出到客户端浏览器时都不会发生改变，当我们创建一个JSP时，模版就已经固定了。&lt;/p&gt;
&lt;p&gt;  　　元素：&lt;span&gt;JSP中的java部分，包括脚本(JavaScript，或者java代码)以及JSP指令(Directive)与JSP标签(Tag)等&lt;/span&gt;，元素决定着程序的流程，元素是不会显示到浏览器的。&lt;/p&gt;
&lt;h2&gt;2.2、JSP脚本&lt;/h2&gt;
&lt;p&gt;　　1）使用&amp;lt;% 编写java代码 %&amp;gt;，中间java代码必须遵循Java语法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008134906543-1337147561.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　来看看，jsp变为servlet时的代码是如何编写的&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008135007215-1443700797.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;432&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在JSP中JSP指令(后面会讲)：　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　&amp;lt;%@ page language=&quot;java&quot; &lt;span&gt;contentType=&quot;text/html; charset=UTF-8&quot;&lt;/span&gt; pageEncoding=&quot;UTF-8&quot;%&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　这句代码在servlet就变为了：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　response.setContentType(&quot;text/html; charset=UTF-8&quot;);//这句代码的意思就是通知tomcat和浏览器都使用UTF-8码表，并且发送回浏览器的数据类型是text/html。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　这是有JSP指令中画红色部分代码转变的，而指令中的pageEncoding=&quot;UTF-8&quot;的意思是JSP转换为Servlet时采用UTF-8码表编码，因为可能JSP中包含中文。&lt;/p&gt;
&lt;p&gt;　　　　　　对于JSP模版数据来说，就原封不动的使用out.write()来输出到浏览器。&lt;/p&gt;
&lt;p&gt;　　　　　　而对于JSP元素来说，就会变成普通的java代码，因为在servlet中，就可以直接编写java代码。&lt;/p&gt;
&lt;p&gt;　　2）使用&amp;lt;%=xxx %&amp;gt;来输出结果&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008135433856-1323846699.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　使用&lt;span&gt;&amp;lt;%=result %&amp;gt;来输出结果，servlet中就会将其转换为out.print(result)进行输出&lt;/span&gt;。输出各种类型数据：int、double、boolean、String、Object等。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008135523324-1891270266.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）注释　　　&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;%-- --%&amp;gt;：jsp注释&lt;/p&gt;
&lt;p&gt;　　　　　　//　：java单行注释&lt;/p&gt;
&lt;p&gt;　　　　　　/*  */　：Java多行注释&lt;/p&gt;
&lt;p&gt;　　　　　　&amp;lt;!-- --&amp;gt;：这个注释，会发送到浏览器端的源码中显示&lt;/p&gt;
&lt;p&gt;　　　　　　注释分别在servlet中如何显示：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008135806746-1378970248.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　在servlet中&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171008135839606-2137012250.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　总结：JSP注释不会在servlet文件中显示，而java注释则会，但其所有的注释到了浏览器端，都不会出现在源码中，只有&amp;lt;!-- --&amp;gt;这个注释会到浏览器的网页源码中去。&lt;/p&gt;
&lt;p&gt;　　4）JSP中申明方法与属性(全局变量)　　使用&amp;lt;%!  方法、属性%&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在JSP中编写方法或者属性时，使用&amp;lt;%! %&amp;gt;括起来&lt;/p&gt;
&lt;p&gt;　　5）在JSP中使用if语句，或者使用for循环，whilt循环等都可以实现，也就是编写脚本而已。　&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Sun, 08 Oct 2017 06:06:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7637295.html</dc:identifier>
</item>
<item>
<title>最好用的css辅助工具——SASS&amp;LESS - 白菜白</title>
<link>http://www.cnblogs.com/zxt-17862802783/p/7634996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxt-17862802783/p/7634996.html</guid>
<description>
&lt;p&gt;　　首先，小编给大家解释一下什么是SCSS和LESS，Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compasss）有助于更好地组织管理样式文件，以及更高效地开发项目。&lt;/p&gt;
&lt;p&gt;同样，Less 也是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。&lt;/p&gt;
&lt;p&gt;　　我相信，在大家的心中会与这么一个疑问，css真的是属于我们程序猿的语言吗？因为它不需要逻辑，只需要像写作文一样就可以将一个静态页面给“写”出来。而且，在平时的css编译中，我想大家最在意的就是样式的权重吧。简单的样式还好，复杂样式那从根目录开始的辣末长的选择器真心让人不忍直视。所以，为了照顾我们程序猿那么懒得生物，大神们编译了SCSS和LESS。他们最大的优势就是可以将css进行类似于逻辑编译。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、最常用的辅助工具——SCSS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;虽然SASS和LESS同样为css辅助工具，但是大部分都比较喜欢使用SASS，想要知道原因，让小编给你解释！&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;SCSS基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 1、scss中的变量&lt;br/&gt;  声明变量：$变量名：变量值；&lt;/p&gt;
&lt;p&gt; 而且，在SCSS中，允许将变量嵌套在字符串中，但是变量必须使用   ${} 包裹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;$width :100px;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$position:left;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#div1&lt;/span&gt;{
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; $width&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; $width/10&lt;/span&gt;;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    border-#{$position&lt;/span&gt;}&lt;span&gt;:10px solid yellow;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到声明变量的$符，是不是觉得很熟悉？没错！jQuery中的获取节点使用的也是$。所以在大部分的网页编译中，大部分都使用scss，便是为了编译时更舒服。不会有使用两种语言的感觉。&lt;/p&gt;
&lt;p&gt;  2、scss中的运算，会将单位进行运算，使用时需注意最终的单位是否正确。&lt;br/&gt;  eg:10px * 10px =100 px*px;&lt;br/&gt; &lt;br/&gt;  3、scss中的嵌套：选择器嵌套  属性嵌套  伪类嵌套&lt;/p&gt;
&lt;p&gt;在scss的使用中，我们通常把选择器嵌套和伪类嵌套一起使用。因为这会极大地节省scss的代码量；&lt;/p&gt;
&lt;p&gt;  ①选择器嵌套 ul{li{}}&lt;/p&gt;
&lt;p&gt;  嵌套默认表示后代选择器，如果需要子代选择器，可以在选择器前加&amp;gt;;可以在选择器的{}中，使用&amp;amp;表示上一层的选择器。&lt;/p&gt;
&lt;p&gt;  ②伪类嵌套： li{&amp;amp;:hover{}}&lt;br/&gt;  在选择器的{}中，使用&amp;amp;配合伪类事件，可以表示当前选择器的伪类。&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;section&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt;   
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; #CCC&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    p{color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;}
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    ul&lt;/span&gt;{
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        padding&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        li{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            &amp;amp;&lt;/span&gt;:&lt;span&gt;hover{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                background-color:red&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt;             }
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            font:&lt;/span&gt;{
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                size&lt;/span&gt;:&lt;span&gt;16px&lt;/span&gt;;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                weight&lt;/span&gt;:&lt;span&gt;bold&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                family&lt;/span&gt;:&lt;span&gt;&quot;微软雅黑&quot;&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                style&lt;/span&gt;:&lt;span&gt;&quot;italic&quot;&lt;/span&gt;;
&lt;span&gt;17&lt;/span&gt;             }
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt; &lt;br/&gt;  ③ 属性嵌套： font:{size:18px;}&lt;br/&gt;   对于属性名有-分割为多段的属性，可以使用属性嵌套，属性名的前半部分必须紧跟一个：才能用{}包裹属性的后半部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; font:&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;     size&lt;/span&gt;:&lt;span&gt;16px&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;     weight&lt;/span&gt;:&lt;span&gt;bold&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      family&lt;/span&gt;:&lt;span&gt;&quot;微软雅黑&quot;&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      style&lt;/span&gt;:&lt;span&gt;&quot;italic&quot;&lt;/span&gt;;
&lt;span&gt;6&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;属性嵌套类似于声明一的对象；对象名为属性名-以前的名字；对象里面的键名为-以后的属性名；值为想要设置的值；&lt;/p&gt;
&lt;p&gt;4、注释&lt;/p&gt;
&lt;p&gt;//注释一：编译时不会被编译到css文件中&lt;br/&gt;/*&lt;br/&gt; 注释二：在非compressed压缩模式下，会被编译到css文件中。&lt;br/&gt; * */&lt;br/&gt;/*!&lt;br/&gt; 注释三：重要注释。在各种压缩模式下，都会被编译到css文件中                                                    &lt;br/&gt; * */&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;混合宏、继承、占位符&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;  1、混合宏：使用@mixin声明混合宏，在其他选择器中使用@include调用混合宏。&lt;/p&gt;
&lt;p&gt;混合宏有三种方式；&lt;br/&gt;  第一种方式：无参数；&lt;br/&gt;  @mixin hunhe{}    .class{@include hunhe;}&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@mixin hunhe()&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; $color&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; }
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;.class1&lt;/span&gt;{
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    @include hunhe;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二种方式：有参数无默认值；&lt;br/&gt;  @mixin hunhe(@param){}    .class{@include hunhe(value);}&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@mixin hunhe($color)&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; $color&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; }
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;.class2&lt;/span&gt;{
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    @include hunhe(green);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; }
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;、&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三种：有参数有默认值；&lt;br/&gt;  @mixin hunhe(@param:value){}    .class{@include hunhe();}&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@mixin hunhe($color:red)&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; $color&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; }
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;.class3&lt;/span&gt;{
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    @include hunhe;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;优缺点：&lt;br/&gt;优点：①可以传参  ②不会产生同名的class&lt;br/&gt;缺点：调用时，会把混合宏中所有的代码copy到选择器中，产生大量重复代码&lt;br/&gt;2、继承：声明一个普通class，在其他选择器中使用@extend继承这个class；&lt;br/&gt;  .class{ }               .class{ @extend.class1;}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//继承
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;.class1&lt;/span&gt;{
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; }
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;.class&lt;/span&gt;{
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    @extend.class1;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;优缺点：&lt;br/&gt;优点：将相同代码，提取并集选择器，减少冗余代码；&lt;br/&gt;缺点：①不能传参；②会产生出一个多余的class；&lt;br/&gt; 3、占位符：使用%声明占位符，在其他选择器中使用@extend 继承占位符；&lt;br/&gt;   %class1{}             .class1{@extend %class1;}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//占位符
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;%class1&lt;/span&gt;{
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; }
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;.class4&lt;/span&gt;{
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @extend %class1;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; }
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;.class5&lt;/span&gt;{
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @extend %class1;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;优缺点：&lt;br/&gt;优点：①将相同代码，提取到并集选择器，减少冗余代码；②不会生出一个多余的代码&lt;br/&gt;缺点：不能传参&lt;br/&gt;  &lt;br/&gt;  &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;条件语句、循环、函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;scss作为css的辅助工具，赋予了css类似于js的一些功能，例如循环、if条件语句、函数等；其中，一定要记得@符号的使用！！！&lt;/p&gt;
&lt;p&gt;1、if条件结构：&lt;br/&gt;      条件结构需要卸载选择器里面，条件结构的大括号直接包裹样式属性。&lt;br/&gt;       @if 条件{}&lt;br/&gt;       @else{}&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//scss中的条件语句
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;.class6&lt;/span&gt;{
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @if 1&amp;gt;2{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt;     }&lt;span&gt;@else&lt;/span&gt;{
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        background-color&lt;/span&gt;:&lt;span&gt; green&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt;     }
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;2、for循环：有着两种方式，类似于开区间和闭区间；&lt;br/&gt;       @for $i from 1 to 10{}  //不包含10&lt;br/&gt;       @for $i from 1 through 10{}  //包含10&lt;br/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//for循环
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@for $i from 1 through 10&lt;/span&gt;{
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    .border-#{$i&lt;/span&gt;}{
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        border&lt;/span&gt;:&lt;span&gt;#{$i&lt;/span&gt;}&lt;span&gt;px solid yellow;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;3、while循环；&lt;br/&gt;      先使用$符定义一个变量，然后进行条件判断，在{}中进行循环；&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//while循环
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$i:0;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@while $i&amp;lt;10&lt;/span&gt;{
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    .while-#{$i&lt;/span&gt;}{
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        border&lt;/span&gt;:&lt;span&gt;#{$i&lt;/span&gt;}&lt;span&gt;px solid red;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    $i:$i+1;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;4、each 循环遍历&lt;br/&gt;      @each $item in a,b,c,d{&lt;br/&gt;       //$item  表示a,b,c,d的每一项&lt;br/&gt;   }&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//each循环遍历
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;$i:0;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@each $item in c1,c2,c3,c4&lt;/span&gt;{
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    $i&lt;/span&gt;:&lt;span&gt;$i+1&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    .#{$item&lt;/span&gt;}{
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        border&lt;/span&gt;:&lt;span&gt;#{$i&lt;/span&gt;}&lt;span&gt;px solid red;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、函数&lt;/p&gt;
&lt;p&gt;scss也可以想js一样进行函数的调用；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@function func($num)&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @return $num * 2;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;.funcTest&lt;/span&gt;{
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; func(10px)&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、LESS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;less作为和scss同等地位的css辅助工具，在一些方面有着相同点，另一方面也有这他的优点；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;less基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1、声明变量：@变量名：变量值&lt;br/&gt;     使用变量：@变量名&lt;br/&gt; 相对于scss，less变量的声明使用@符号；并且，变量一般使用在多次频繁出现的值，后期需要统一修改的值，牵扯到数值运算的值，推荐使用变量&lt;br/&gt;  &lt;br/&gt;  &amp;gt;&amp;gt;&amp;gt;less中的变量类型&lt;br/&gt;  在css中出现的属性值，在less中都可以用作变量名&lt;br/&gt;  ①数值类： 不带单位的 123    带单位的  1px&lt;br/&gt;  ②字符串：带引号的 &quot;hahahaah&quot;    不带引号的  red   #ff0000&lt;br/&gt;  ③颜色类：  red  #ff0000  RGB(255,255,0)&lt;br/&gt;  ④值列表类型： 多个值用逗号或空格分隔  10px solid  red&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@color :#ff0000;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@length:100px;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#div&lt;/span&gt;{
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; @length&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt;@length*2&lt;/span&gt;;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; @color&lt;/span&gt;;
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  2、混合(Mixins)，我们也亲切的叫做“米心”；相当scss的混合宏，同样有着三种方式：&lt;br/&gt;  ①无参数混合；实际上就是一个普通的class选择器，会被编译到css文件中；&lt;br/&gt;       声明： .class{}&lt;br/&gt;       调用：在选择器中，使用.class;直接调用&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//无参数混合
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;.borderRadius&lt;/span&gt;{
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    border-radius&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    -webkit-border-radius&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    -moz-border-radius&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt; ②有参无默认值混合：&lt;br/&gt;       声明：.class(@param){}&lt;br/&gt;       调用:.class(paramValue);&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//有参无默认值混合
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;.borderRadius1(@radius)&lt;/span&gt;{
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    -webkit-border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    -moz-border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; }
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;.class&lt;/span&gt;{
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    .borderRadius1(10px);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  ③有参有默认值混合：&lt;br/&gt;       声明：.class(@param：10px){}&lt;br/&gt;       调用:.class(paramValue); 或 .class();&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//有参有默认值混合
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;.borderRadius2(@radius:10px)&lt;/span&gt;{
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    -webkit-border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    -moz-border-radius&lt;/span&gt;:&lt;span&gt; @radius&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; }
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;.class&lt;/span&gt;{
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    .borderRadius2();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  &amp;gt;&amp;gt;&amp;gt;如果声明时没有给参数赋默认值，则调用时必须赋值，否则报错；&lt;br/&gt;     有参混合，在编译时，不会出现在css文件中；&lt;br/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;匹配、@argument、嵌套&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 1、LeSS的匹配默认&lt;br/&gt;       ①声明,类似于switch语句；&lt;br/&gt;       @pipei(条件一，参数){}    @pipei(条件二，参数){}   @pipei(@_，参数){}&lt;br/&gt;       ②调用：&lt;br/&gt;       @pipei(条件的值，参数的值){}&lt;br/&gt;       ③匹配规则：&lt;br/&gt;       根据调用时输入的条件值，去寻找与之匹配的混合执行；&lt;br/&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;匹配模式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;.pipei(lefts,@width:10px)&lt;/span&gt;{
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    margin-left&lt;/span&gt;:&lt;span&gt; @width&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; }
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;.pipei(rights,@width:10px)&lt;/span&gt;{
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    margin-right&lt;/span&gt;:&lt;span&gt; @width&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; }
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;.pipei(tops,@width:10px)&lt;/span&gt;{
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    margin-top&lt;/span&gt;:&lt;span&gt; @width&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; }
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;.pipei(bottoms,@width:10px)&lt;/span&gt;{
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    margin-bottom&lt;/span&gt;:&lt;span&gt; @width&lt;/span&gt;;
&lt;span&gt;13&lt;/span&gt; }
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;.pipei(@_,@width:10px)&lt;/span&gt;{
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   padding&lt;/span&gt;:&lt;span&gt;10px&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; }
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;@position:leftssssss;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//当上述条件都不符合时执行，相当于default；
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;.class1&lt;/span&gt;{
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    .pipei(@position,20px);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt; 2、@arguments  特殊变量：&lt;br/&gt;       在混合中，@arguments表示混合传入的所有参数。@arguments中的多个参数，用空格分隔。&lt;br/&gt;      &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;@arguments&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;.argu(@width,@style,@color)&lt;/span&gt;{
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    //border&lt;/span&gt;:&lt;span&gt;@width @style @color&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    border&lt;/span&gt;:&lt;span&gt;@arguments&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; }
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;.class2&lt;/span&gt;{
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    .argu(10px,solid,red);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;        &lt;br/&gt;               &lt;br/&gt; &lt;/em&gt;4、Less嵌套&lt;br/&gt;        less中允许css选择器按照HTML的结构进行嵌套。  相当于scss的选择器嵌套与伪类嵌套的组合；&lt;br/&gt;       &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;less嵌套&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;section&lt;/span&gt;{
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt; 800px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    background-color&lt;/span&gt;:&lt;span&gt; #cccbbb&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    &amp;gt;p{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        color&lt;/span&gt;:&lt;span&gt; blueviolet&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        font-size&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt;     }
&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    ul&lt;/span&gt;{
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        padding&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        list-style&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        li{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;:&lt;span&gt; yellow&lt;/span&gt;;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            &amp;amp;&lt;/span&gt;:&lt;span&gt;hover{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                background-color: cornflowerblue&lt;/span&gt;;
&lt;span&gt;25&lt;/span&gt;             }
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有两点值得注意；&lt;br/&gt;        ①less的嵌套，默认是后代选择器。如果需要自带选择器，需要在前面加&amp;gt;；&lt;br/&gt;        ②&amp;amp;符号，表示这个&amp;amp;所在的上一层表达器；比如上述嵌套：&amp;amp;:hover相当于section ul:hover&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、less&amp;amp;scss的使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;作为css的辅助工具，需要其操作环境最终还要转为css才能实现网页的布局；使用less直接创建Less文件就可以了吗？不，我们通常使用Koala进行less或scss到css的转换；&lt;/p&gt;
&lt;p&gt;将less或scss的文件夹拖进koala的主页中，就可以随心所欲的编译了！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205848/201710/1205848-20171008132125762-1511403250.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于一些简单的 项目，使用不使用scss和less并无区别，可在一些难度较大、比较复杂的项目上，less或scss就很有必要了。既节省我们的时间，有提高效率，一举多得！！！&lt;/p&gt;
</description>
<pubDate>Sun, 08 Oct 2017 05:37:00 +0000</pubDate>
<dc:creator>白菜白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxt-17862802783/p/7634996.html</dc:identifier>
</item>
<item>
<title>Docker入门之六端口映射与容器互联 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/7636953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/7636953.html</guid>
<description>&lt;p&gt;一、端口映射&lt;/p&gt;
&lt;p&gt;在之前的博客搭建私有仓库时用到这样一句:docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry来run一个仓库，其中可以看到-p 5000:5000,它的作用就是用来进行端口映射。那为什么需要端口映射呢?其实在启动容器时，如果不配置宿主机器与虚拟机的端口映射，外部程序是无法访问虚拟机的，因为没有端口，所以需要进行端口映射。&lt;/p&gt;
&lt;p&gt; 端口映射有两个关键词-P -p，一个是大写一个是小写，通过run --help也可以看到。大写的P是随机映射一个49000-49900的端口到内部容器开放的网络端口。小写p可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008120600856-1182897329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持的格式有三种:比较常用的是第三种，因为这样没有对ip进行限制，移植也方便。&lt;/p&gt;
&lt;p&gt;ip:hostPort:containerPort：映射指定地址的指定端口到虚拟机的指定端口（不常用） &lt;/p&gt;
&lt;p&gt;如：127.0.0.1:5000:5000，映射本机的5000端口到虚拟机的5000端口。 &lt;/p&gt;
&lt;p&gt;ip::containerPort：映射指定地址的任意端口到虚拟机的指定端口。（不常用） &lt;/p&gt;
&lt;p&gt;如：127.0.0.1::5000，映射本机的5000端口到虚拟机的5000端口。 &lt;/p&gt;
&lt;p&gt;hostPort:containerPort：映射本机的指定端口到虚拟机的指定端口。（常用） &lt;/p&gt;
&lt;p&gt;如：5000:5000，映射本机的5000端口到虚拟机的5000端口&lt;/p&gt;
&lt;p&gt;映射完之后我们可以通过ps来进行查看容器的映射情况:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008121601637-1535964199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以使用port命令来查看映射情况，下面是先通过help来查看port的语法和格式。然后查看了容器modest_payne的端口映射情况。最后要说的是可以多次使用-p来绑定多个端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008121940184-2071515056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、容器互联&lt;/p&gt;
&lt;p&gt; 在实际应用中往往需要多个容器交互，比如一个数据库容器来提供db服务，多个应用容器来部署应用，使用端口访问就会暴露端口，这样不太安全。有没有方法让容器互联呢？答案当然是有了。容器互联的方法有多种方式，今天主要学习link，但link是只针对单宿主主机的。&lt;/p&gt;
&lt;p&gt;1.启动mysql server&lt;/p&gt;
&lt;p&gt;这里run了一个mysql，容器名mysql，123为数据库的root密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name mysql -e MYSQL_ROOT_PASSWORD=&lt;span&gt;123&lt;/span&gt; -d mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008131650293-1657082406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.使用--link关联&lt;/p&gt;
&lt;p&gt;这里run了一个webapp的容器，关联了mysql容器，并为它取别名db，webapp容器的镜像就是普通的ubuntu镜像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name webapp --link mysql:db -it -d ubuntu /bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008132025949-635981888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个容器互联相当于在它们之间创建了一个虚拟通道，而且不用映射它们的端口到宿主主机上。通过两种方式为容器公开连接信息:&lt;/p&gt;
&lt;p&gt;1.更新环境变量&lt;/p&gt;
&lt;p&gt;2.更新/etc/hosts文件&lt;/p&gt;
&lt;p&gt;下面的截图就是进入容器webapp来查看它的环境变量和hosts文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171008132505528-219765960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Oct 2017 05:26:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/7636953.html</dc:identifier>
</item>
<item>
<title>C# 7.0 新特性：本地方法 - 冠军</title>
<link>http://www.cnblogs.com/haogj/p/7636915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haogj/p/7636915.html</guid>
<description>&lt;p&gt;VS 2017 的 C# 7.0 中引入了本地方法，本地方法是一种语法糖，允许我们在方法内定义本地方法。更加类似于函数式语言，但是，本质上还是基于面向对象实现的。&lt;/p&gt;
&lt;h2&gt;1. 本地方法&lt;/h2&gt;
&lt;p&gt;先看一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; System.Console;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; UseLocalFunctions
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sum of {x} and {y}: is {x + y}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&lt;span&gt;void&lt;/span&gt; Multiply(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Multiply of {x} and {y} is: {x * y}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Add(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             Add(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Multiply(&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            ReadLine();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在此示例中，在 Main 方法内，嵌套定义了两个方法：Add  和 Multiply。这个方法可以在 Main 方法内被使用。这种方法被称为&lt;em&gt;&lt;strong&gt;本地方法&lt;/strong&gt;&lt;/em&gt;。英文称为：&lt;strong&gt;&lt;em&gt;Local function&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;使用 ILDasm 工具，可以看到编译之后的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/13475/201710/13475-20171007180653099-234652375.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个本地方法被翻译成了两个静态的私有方法，它只能在定义的方法内被调用。&lt;/p&gt;
&lt;p&gt;本地方法的语法定义为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&amp;lt;modifiers: async | unsafe&lt;/span&gt;&amp;gt; &lt;span&gt;&amp;lt;return-type&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;method-name&amp;gt; &amp;lt;parameter-list&amp;gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法的修饰符只有两种：async 和 unsafe，所有的本地方法都是私有的&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果您使用了 private 修饰，会收到 编译器的错误提示：error CS0106, &quot;The modifier 'static' is not valid for this item.&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果您使用了 static，会收到编译器的错误提示：error CS0106, &quot;The modifier 'static' is not valid for this item.&quot;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2. 带有返回类型的本地方法&lt;/h2&gt;
&lt;p&gt;本地方法也可以带有返回类型。如果类型用错的话，Visual  Studio 可以给出提示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         PrintStudentMarks(&lt;span&gt;101&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subject
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 SubjectName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Math&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Marks = &lt;span&gt;96&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             }, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subject
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 SubjectName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;physics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Marks = &lt;span&gt;88&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             }, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Subject
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 SubjectName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Chem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Marks = &lt;span&gt;91&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        ReadLine();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrintStudentMarks(&lt;span&gt;int&lt;/span&gt; studentId, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; Subject[] subjects)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student Id{studentId} Total Marks: {CalculateMarks()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student wise marks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; subject &lt;span&gt;in&lt;/span&gt;&lt;span&gt; subjects)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Subject Name: {subject.SubjectName}\t Marks: {subject.Marks}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&lt;strong&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; CalculateMarks()
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;decimal&lt;/span&gt; totalMarks = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; subject &lt;span&gt;in&lt;/span&gt;&lt;span&gt; subjects)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 totalMarks +=&lt;span&gt; subject.Marks;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalMarks;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Subject
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; SubjectName
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; Marks
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3. 使用本地方法实现递归&lt;/h2&gt;
&lt;p&gt;本地方法不需要维护调用堆栈，而递归方法需要维护调用堆栈，本地方法效率更高。下面的示例演示了两种方法的区别。&lt;/p&gt;
&lt;p&gt;注意：该示例使用了类型 BigInteger ，需要添加对程序集 System.Numeric.dll 的引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/13475/201710/13475-20171008124744074-2081155202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Stopwatch watch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             BigInteger f1 = GetFactorialUsingLocal(&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using local function: {watch.ElapsedTicks}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            watch.Reset();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             BigInteger f2 = GetFactorial(&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using recursive function: {watch.ElapsedTicks}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BigInteger GetFactorialUsingLocal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (number &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;negative number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(number));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (number == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;BigInteger result =&lt;span&gt; number;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (number &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 Multiply(number - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 number--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&lt;span&gt;void&lt;/span&gt; Multiply(&lt;span&gt;int&lt;/span&gt; x) =&amp;gt; result *=&lt;span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BigInteger GetFactorial(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (number &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nagative number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(number));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; number == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt; : number * &lt;span&gt;GetFactorial(number - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在我的机器上，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;Using local function: 181770&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;Using recursive function: 456602&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到两者之间的性能差异。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，为了传递 result ，在生成的代码中，编译器会自动做一些额外的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/13475/201710/13475-20171008124555387-1886039583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4. 本地方法与 Lambda 的比较&lt;/h2&gt;
&lt;h3&gt;1. 性能&lt;/h3&gt;
&lt;p&gt;当创建 Lambda 的时候，将会创建一个委托，这需要内存分配，因为委托是一个对象。而本地方法则不需要，它是一个真正的方法。&lt;/p&gt;
&lt;p&gt;另外，本地方法可以更为有效地使用本地变量，Lambda 将变量放到类中，而本地方法可以使用结构，而不使用内存分配。&lt;/p&gt;
&lt;p&gt;这意味着调用本地方法更为节约且可能内联。&lt;/p&gt;
&lt;h3&gt;2. 本地方法可以递归&lt;/h3&gt;
&lt;p&gt;Lambda 也可以实现递归，但是代码丑陋，您需要先赋予 lambda 为 null。本地方法可以更为自然地递归。&lt;/p&gt;
&lt;h3&gt;3. 本地方法可以使用泛型&lt;/h3&gt;
&lt;p&gt;Lambda 不能使用泛型。这是因为需要赋予一个实例类型的变量。&lt;/p&gt;
&lt;h3&gt;4. 本地方法可以实现迭代器&lt;/h3&gt;
&lt;p&gt;Lambda 不能使用 yield return (以及 yield break)关键字，以实现 IEnumerable&amp;lt;T&amp;gt; 返回函数。本地方法可以。&lt;/p&gt;
&lt;h3&gt;5. 本地方法更为易读&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;5. 其它资源：&lt;/span&gt;&lt;/h2&gt;

</description>
<pubDate>Sun, 08 Oct 2017 04:54:00 +0000</pubDate>
<dc:creator>冠军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haogj/p/7636915.html</dc:identifier>
</item>
<item>
<title>PIC32MZ 通过USB在线升级 -- USB HID bootloader - GeekyGeek</title>
<link>http://www.cnblogs.com/geekygeek/p/usb_hid_bootloader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geekygeek/p/usb_hid_bootloader.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;了解 bootloader 的实现， 请加QQ： 1273623966（验证填bootloader); 欢迎咨询或定制bootloader; 我的博客主页&lt;/strong&gt;&lt;/span&gt; www.cnblogs.com/geekygeek&lt;/p&gt;
&lt;p&gt;        上一篇博文介绍了PIC32MZ 的USB CDC bootloader, 但是USB CDC bootloader是模拟UART通信，速度比较慢。所以我决定使用USB HID class替换USB CDC class. 让我的PIC32MZ bootloader更新程序时，有飞一般的感觉。整个PIC32MZ USB HID bootloader是在harmony 的bootloader例程基础上修改的。HID bootloader的开发环境如下。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; 1. IDE：  MPLABX IDE 4.01&lt;/p&gt;
&lt;p&gt;        2. Compiler:  XC32 1.40&lt;/p&gt;
&lt;p&gt;        3. Library:  Harmony 1.07&lt;/p&gt;
&lt;p&gt;        4. Example: c:/microchip/harmony/v1_07_01/apps/bootloader/basic/firmware/basic.X.&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;下位机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在harmony bootloader例程的基础上，首先修改的是项目属性的配置。让其适应我的硬件板子（PIC32MZ EC starter kit ）。项目中对应的芯片修改成PIC32MZ2048ECH144。Bootloader的Linker File,  bsp,  以及 peripheral Library修改成PIC32MZ2048ECH所对应的。&lt;/p&gt;
&lt;p&gt;       接着就是代码的修改。harmony bootloader例程的设计很成熟，只需要很少的改动，就可以适配到你的硬件板子。唯一的不足，就是例程的文档没有介绍到bootloader和应用程序的memory map。 这一点AN1388就做的很好，AN1388里面甚至有应用程序的例子，可以直接用来测试bootloader。 AN1388里面也有应用程序的Linker file。但是harmony bootloader例程文档中没有，我只好自己写应用程序的Linker script。 Linker script必须让bootloader和应用程序在flash中地址错开来。不能有overlap。 然后我在HID bootloader 的system_config.h中修改了以下与地址相关的宏定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:false;&quot;&gt;
#define BOOTLOADER_FLASH_BASE_ADDRESS   0x9D000000
#define BOOTLOADER_FLASH_END_ADDRESS    (0x9D000000 + 0x200000 - 1)

/* Address of  the Flash from where the application starts executing */
/* Rule: Set BOOTLOADER_FLASH_BASE_ADDRESS to _RESET_ADDR value of application linker script*/
#define BOOTLOADER_RESET_ADDRESS    0xBD000000        //(BOOTLOADER_FLASH_BASE_ADDRESS + 0x1000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些宏定义和我写的应用程序的Linker script中的定义相吻合。否则会烧写失败或跳转不成功。接着就试着编译我的HID bootloader, 一切都很顺利，一次就成功了。通过PICKit3将HID bootloader下载到了硬件板子上了。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;上位机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        这时候，我就去找harmony bootloader要用的电脑端的程序（上位机）。我找了harmony安装路径下的每一个角落，都没有发现。难道要自己写上位机， 这个可没那么简单。后来我突然想到了AN1388的上位机PIC32UBL.exe， 虽然AN1388的例程中bootloader的代码只支持PIC32MX， 不支持PIC32MZ。 但是上位机说不定是通用的。试完后，才知道PIC32UBL.exe果然是用好工具，对harmony bootloader的支持非常的好。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/818084/201710/818084-20171008122753543-2027054445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;更新步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1. 打开上位机PIC32UBL.exe, 选择勾选USB通信方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       2. 按住硬件板子的SW3 按键开关， 重启硬件板子。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       3. 点击上位机connect按钮，会提示发现bootloader，这个时候可以松开SW3按键开关。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       4. 点击上位机“Load Hex File&quot;按钮，加载应用程序的hex。 （应用程序编译时，要用上面提到的客制的Linker script ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       5. 点击上位机“erase-program-verify&quot;按钮，bootloader开始工作，等待其烧写完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       5. 点击上位机”Run application&quot;按钮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       整个步骤，就是这样。我非常满意这个HID bootloader， 操作简单，速度也快，完全可以用来作为产线生产时烧写的一个工具，有了它，就算产品出到客户端，如果需要更新程序，也不用召回，只需插上USB线，现场就可以完成更新，这个时候可以节省一大笔召回的成本。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 08 Oct 2017 04:48:00 +0000</pubDate>
<dc:creator>GeekyGeek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geekygeek/p/usb_hid_bootloader.html</dc:identifier>
</item>
<item>
<title>高速网络包过滤 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/7609137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/7609137.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/7609137.html 

　　作者：窗户

　　QQ：&lt;span&gt;6679072&lt;/span&gt;

　　E-mail：&lt;span&gt;6679072@qq.com
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　WAF(Web Applicantion firewall, Web防火墙)的实现有多种手段，基于regex(Regular Expression,正则表达式)，然后编译成一个大状态机是目前主流的方式。当然，阿拉云安全的主架构师讲了个ppt，直接说regex来做防火墙有不合理的地方，理由是使用regex做防火墙，其计算复杂度最高的那一个regex是整个系统的短板，如果这个regex的时间复杂度过高，攻击者完全可以利用这一点攻击WAF达到DDOS的效果。从而，他觉得regex迟早应该退出WAF的领域，而用人工智能白名单的新一代WAF才是未来WAF的主流。这位仁兄说的是有道理的，正则表达式做的WAF异常复杂，运算强度高，这些瓶颈业内早就熟知，未来应当属于人工智能。接下去的相当一段时间，我也的确需要思考思考下一代的WAF是具体如何更好的结合人工智能。话说回来，毕竟在可预见的时间里，基于regex的WAF还是主流。吐槽一下，正则表达式真的是一个我不知道该说是天才还是该说是垃圾的翻译，让我每当写到一次就想吐槽一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　话题有些扯远了，越是今天信息如此膨胀，WAF越是会偏向于用电脑来解决而非嵌入式设备，但和我要提到的话题牵涉到的都是包过滤。在信息膨胀的今天，百M甚至千M已经不能满足我们的需求，主干网上万M交换机用来满足大数据量的交换。速度太快，我们实在无法完全使用CPU来处理这一切，CPU只可以作为终端配置等功能，而对于万M网络本身的控制应使用ASIC(Application Specific Integrated Circuit，专用集成电路)，也就是为此应用专门设计一个芯片，而非用于多种场合的通用芯片。然而ASIC无法升级，若要升级只能替换。FPGA可以替代这个，同时满足ASIC的需求和升级的需求，目前高端的FPGA的主时钟可以很快，但当然也挺昂贵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　想起大约十年以前，我们利用FPGA处理NGN信令，涉及到网络包的过滤、统计等。当时，我们对于包的过滤是半定死的，比如UDP还是TCP、端口需要不需要过滤、如果需要端口过滤端口多少、IP需要补需要过滤、如需要IP过滤IP如何过滤，如此设计是因为对于当时的应用来说也已经足够。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果熟悉抓包工具，比如tcpdump，会想到平常的时候我们对于2~4层的抓包的确不会想WAF那样动辄regex作为判断条件，而是一堆基于固定位置（比如对于UDP包，其端口号、IP地址等在包中的偏移都是固定的）的数值等式或不等式作为bool值连成的bool表达式。我们就以tcpdump命令的参数来说明，比如tcpdump tcp and dst host 192.168.218.1 and src port 22，其中tcp、 dst host 192.168.1.1、src port 23就是三个不同的bool值。如果熟悉tcpdump和TCP/IP，对照资料，我们可以重新修改上述规则，把tcp、dst host、src port解析为偏移，从而整个规则写作偏移的形式。在绝大多数的应用下，一条过滤里面这样独立的bool值不超过8个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　硬件的好处是快速、直接，软件的好处是高扩展性，我们完全可以结合两者。用上位机（可能是控制的电脑，也可能只是内部的一个嵌入式CPU）把tcp and dst host 192.168.218.1 and src port 22这样容易阅读的东西翻译为偏移量、bool值这样的东西，并且给出各个bool值计算中偏移量从小到大排列，如果基础的bool值计算只有最多8条这样的情况，那么其实只需要FPGA内部做一个8位地址1位输出的RAM(可以设置，所以选择RAM而非ROM)即256bits的存储的RAM，上位机把RAM里面存储的所有值算出来并传给FPGA。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如之前，tcp and dst host 192.168.218.1 and src port 22，3个bool值映射到1个布尔值，其实只需要2^3=8bits存储，8个bits分别为0,0,0,0,0,0,0,1，这就是RAM存储的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　甚至于，软件还可以比这个更加强大，可以考虑合并多条规则，切割多条规则，其实多条规则的多个bool表达式最终也通过and或者or来连接的，最后或许还有一个not，从整体来看归根结底还是一条规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用RAM来计算bool表达式虽说无法通用，因为其存储伴随着bool表达式的长度是乘方级的扩展，但简单、快。设计此类电路，简单就是美，对于电路的综合来说是至关重要的。并且，可以可以如此设置多条规则，但每条规则基本是独立工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　随着FPGA收包的过程，依次匹配规则中的偏移量，计算出每个bool值，从而最终拼出查RAM的地址，从而查出该包是通过还是拦截。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我曾经考虑过用逆波兰式去计算，但对于这种场合似乎有很多的不方便，倒是RAM简单暴力直接。那可能会问，如何过滤规则过于复杂了怎么办，那就直接考虑不支持，任何产品都有一个设计规格，不可能无条件的满足所有人的需求。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Oct 2017 04:12:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/7609137.html</dc:identifier>
</item>
<item>
<title>httpd配置文件规则说明和一些基本指令 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/7636836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/7636836.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.1&quot;&gt;&lt;span&gt;1.1 httpd命令和apachectl命令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2&quot;&gt;&lt;span&gt;1.2 配置文件规则和常见指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.1&quot;&gt;&lt;span&gt;1.2.1 Listen指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.2&quot;&gt;&lt;span&gt;1.2.2 ServerRoot指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.3&quot;&gt;&lt;span&gt;1.2.3 DocumentRoot指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.4&quot;&gt;&lt;span&gt;1.2.4 DirectoryIndex指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.5&quot;&gt;&lt;span&gt;1.2.5 ServerName和ServerAlias&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.6&quot;&gt;&lt;span&gt;1.2.6 Include指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.7&quot;&gt;&lt;span&gt;1.2.7 Define和UnDefine指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.8&quot;&gt;&lt;span&gt;1.2.8 VirtualHost指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.9&quot;&gt;&lt;span&gt;1.2.9 Options和AllowOverride指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.10&quot;&gt;&lt;span&gt;1.2.10 Require指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.2.11&quot;&gt;&lt;span&gt;1.2.11 长连接相关指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.3&quot;&gt;&lt;span&gt;1.3 容器类指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.3.1&quot;&gt;&lt;span&gt;1.3.1 容器&amp;lt; Directory &amp;gt;和&amp;lt; Files &amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.3.2&quot;&gt;&lt;span&gt;1.3.2 容器&amp;lt; Location &amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.3.3&quot;&gt;&lt;span&gt;1.3.3 &amp;lt; IfDefine &amp;gt;、&amp;lt; IfModule &amp;gt;和&amp;lt; IfVersion &amp;gt;条件判断&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.3.4&quot;&gt;&lt;span&gt;1.3.4 &amp;lt; If &amp;gt;、&amp;lt; ElseIf &amp;gt;和&amp;lt; Else &amp;gt;容器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.4&quot;&gt;&lt;span&gt;1.4 配置文件的合并规则&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍介绍的是httpd的配置文件，包括一些最基本的指令、配置规则、配置合并规则。以下指令完全来自官方手册以及我自己的总结和整理。&lt;/p&gt;
&lt;hr/&gt;

&lt;h2 id=&quot;1-1-httpd-apachectl-&quot;&gt;1.1 httpd命令和apachectl命令&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]
Usage: httpd [-D name] [&lt;span class=&quot;hljs-operator&quot;&gt;-d&lt;/span&gt; directory] [&lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; file]
             [-C &lt;span class=&quot;hljs-string&quot;&gt;&quot;directive&quot;&lt;/span&gt;] [-c &lt;span class=&quot;hljs-string&quot;&gt;&quot;directive&quot;&lt;/span&gt;]
             [-k start|restart|graceful|graceful-stop|stop]
             [-v] [-V] [-h] [&lt;span class=&quot;hljs-operator&quot;&gt;-l&lt;/span&gt;] [-L] [-t] [-T] [-S] [-X]
Options:
  -D name            : 定义一个在&amp;lt; IfDefine name &amp;gt;中使用的name，以此容器中的指令
  &lt;span class=&quot;hljs-operator&quot;&gt;-d&lt;/span&gt; directory       : 指定ServerRoot
  &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt; file            : 指定配置文件
  -C &lt;span class=&quot;hljs-string&quot;&gt;&quot;directive&quot;&lt;/span&gt;     : 指定在加载配置文件前要处理的指令(directive)
  -c &lt;span class=&quot;hljs-string&quot;&gt;&quot;directive&quot;&lt;/span&gt;     : 指定在加载配置文件后要处理的指令
  &lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt; level           : 显示httpd启动时的日志调试级别
  -E file            : 将启动信息记录到指定文件中
  -v                 : 显示版本号
  -V                 : 显示编译配置选项
  -h                 : 显示帮助信息
  &lt;span class=&quot;hljs-operator&quot;&gt;-l&lt;/span&gt;                 : 显示已编译但非动态编译的模块，即静态编译的模块
  -L                 : 显示静态模块可用的指令列表
  -t -D DUMP_VHOSTS  : 显示虚拟主机的设置信息
  -t -D DUMP_RUN_CFG : 显示运行参数
  -S                 : 等价于-t -D DUMP_VHOSTS -D DUMP_RUN_CFG。在调试如何解析配置文件时非常非常有用
  -t -D DUMP_MODULES : 显示所有已被加载的模块，包括静态和动态编译的模块
  -M                 : 等价于-t -D DUMP_MODULES
  -t                 : 检查配置文件语法
  -T                 : 不检查DocumentRoot，直接启动
  -X                 : 调试模式，此模式下httpd进程依赖于终端
  -k                 : 管理httpd进程，接受start|restart|graceful|graceful-stop|stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;apachectl命令和httpd命令基本相同。httpd接受的选项，apachectl都接受。但apachectl还可以省略&quot;-k&quot;选项直接管理httpd进程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;apachectl [-k] start&lt;/code&gt;：按照默认路径，读取默认配置文件，并启动httpd。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apachectl [-k] stop&lt;/code&gt;：关闭httpd进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apachectl [-k] restart&lt;/code&gt;：重启httpd进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apachectl [-k] graceful-stop&lt;/code&gt;：graceful stop，表示让已运行的httpd进程不再接受新请求，并给他们足够的时间处理当前正在处理的事情，处理完成后才退出。所以在进程退出前，日志文件暂时不会关闭，正在进行的连接暂时不会断开。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apachectl [-k] graceful&lt;/code&gt;：graceful restart，即graceful-stop+start。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apachectl [-k] configtest&lt;/code&gt;：语法检查。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在systemd环境下，还可以使用&lt;code&gt;apacectl status&lt;/code&gt;或&lt;code&gt;systemctl status httpd&lt;/code&gt;查看httpd进程的详细信息。&lt;/p&gt;

&lt;h2 id=&quot;1-2-&quot;&gt;1.2 配置文件规则和常见指令&lt;/h2&gt;
&lt;p&gt;httpd的核心体现在配置文件，各种功能都通过配置文件来实现。使用rpm包安装的httpd默认配置文件为/etc/httpd/conf/httpd.conf。可以使用&lt;code&gt;httpd -f config_path&lt;/code&gt;指定要加载的配置文件。&lt;/p&gt;
&lt;p&gt;配置文件中全是一些指令配置，每个指令都是某个模块提供的。以下是配置文件的一些规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指令生效方式是从上往下读取，这一点非常非常重要。很多指令的位置强烈建议不要改变，例如&lt;code&gt;Include conf.d/*.conf&lt;/code&gt;指令建议不要移动位置。&lt;/li&gt;
&lt;li&gt;&quot;#&quot;开头的行为注释行，只能行头注释，不能行中注释。&lt;/li&gt;
&lt;li&gt;对大小写不敏感，但是建议指令名称采用&quot;驼峰式&quot;命名。例如ServerRoot，DocumentRoot。&lt;/li&gt;
&lt;li&gt;一行写不下的可以使用&quot;\&quot;续行，但是&quot;\&quot;后不能有任何字符，包括空格也不允许。&lt;/li&gt;
&lt;li&gt;指令配置格式为&quot;Directive value&quot;，例如&quot;ServerRoot /etc/httpd&quot;，如果value中包含特殊字符或空格，则必须使用双引号包围。&lt;/li&gt;
&lt;li&gt;由于可以通过Include指令包含其他配置文件，又支持各种路径的容器，所以在httpd启动时会先进行配置文件的合并。理解合并规则非常重要，具体见&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html#blog1.4&quot;&gt;&lt;span&gt;配置文件合并规则&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-2-1-listen-&quot;&gt;1.2.1 Listen指令&lt;/h3&gt;
&lt;p&gt;设置监听套接字。设置方式很简单，包括以下几种情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Listen&lt;/span&gt;&lt;/span&gt; 80
&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Listen&lt;/span&gt;&lt;/span&gt; 8000


&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Listen&lt;/span&gt;&lt;/span&gt; 192.170.2.1:80
&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Listen&lt;/span&gt;&lt;/span&gt; 192.170.2.5:8000
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-2-serverroot-&quot;&gt;1.2.2 ServerRoot指令&lt;/h3&gt;
&lt;p&gt;该指令设置httpd的安装位置，也就是常称之为的basedir，在此目录下应该具有module、logs等目录。rpm安装的httpd的ServerRoot默认为/etc/httpd，编译安装的ServerRoot路径由&quot;--prefix&quot;选项指定，例如/usr/local/apache。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
total &lt;span class=&quot;hljs-number&quot;&gt;52&lt;/span&gt;
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; bin
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; build
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; cgi-bin
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; error
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt; htdocs
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; icons
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;include&lt;/span&gt;
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt; logs
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; man
drwxr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;12288&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Jul&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;38&lt;/span&gt; manual
drwxr-xr-x  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt; modules
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个指令很关键，安装好apache后一般不会去做任何修改，因为很多指令的路径以及相对路径都是基于此路径的。严格地说，&lt;span&gt;&lt;strong&gt;除了网络路径，基本上所有本地文件系统类的路径只要不是绝对路径，相对路径都基于此路径展开&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;例如，当指定&quot;ServerRoot /usr/local/apache&quot;时，下面几个指令中描述的本地路径，等号前面的采用的都是相对路径，等号右边的都是他们等价的绝对路径写法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DocumentRoot &lt;span class=&quot;hljs-string&quot;&gt;&quot;htdocs&quot;&lt;/span&gt;                    = DocumentRoot &lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/local/apache/htdocs&quot;&lt;/span&gt;
LoadModule dir_module modules/mod_dir.so = LoadModule dir_module /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/apache/modules/mod_dir.so
ErrorLog &lt;span class=&quot;hljs-string&quot;&gt;&quot;logs/error_log&quot;&lt;/span&gt;                = ErrorLog /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/apache/logs/error_&lt;span class=&quot;hljs-built_in&quot;&gt;log&lt;/span&gt;
Alias /net_path &lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;_fs_path            = Alias /net_path /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/apache/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;_fs_path
Include conf.d/vhost.conf                = Include /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/apache/conf.d/vhost.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但注意，容器&amp;lt; Directory PATH &amp;gt;的PATH一般设置为文件系统的绝对路径，因为它是&lt;strong&gt;路径匹配&lt;/strong&gt;性质的。但它仍可以使用相对路径时，此时它相对的是根文件系统的&quot;/&quot;，而非ServerRoot。&lt;/p&gt;
&lt;p&gt;所以，这个指令强烈不建议做任何修改，修改是很简单，但是牵一发而动全身。&lt;/p&gt;

&lt;h3 id=&quot;1-2-3-documentroot-&quot;&gt;1.2.3 DocumentRoot指令&lt;/h3&gt;
&lt;p&gt;如果说，ServerRoot是httpd中本地文件相对路径的根，那么DocumentRoot就是网络路径相对路径的根。顾名思义，DocumentRoot是文档的根目录，这个文档的意思是展现在网络上的文档。使用rpm包安装的httpd的DocumentRoot默认值为&quot;/var/www&quot;，编译安装的httpd，其DocumentRoot默认为&quot;PREFIX/htdocs&quot;，也就是&quot;$ServerRoot/htdocs&quot;。&lt;/p&gt;
&lt;p&gt;设置DocumentRoot后，将需要在网络上访问的文件都放进此目录下即可。&lt;/p&gt;
&lt;p&gt;例如，假设httpd所在主机IP为192.168.100.14，DocumentRoot使用默认的/usr/local/apache/htdocs，那么下面几个URL中，左边的是浏览器中输入的值，右边的是其访问的服务器上的资源路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http:
http:
http:
http:
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，DocumentRoot的值对应的是&lt;code&gt;http://192.168.100.14/&lt;/code&gt;的&quot;/&quot;。&lt;/p&gt;

&lt;h3 id=&quot;1-2-4-directoryindex-&quot;&gt;1.2.4 DirectoryIndex指令&lt;/h3&gt;
&lt;p&gt;该指令设置的是&quot;当搜索的URL中的路径使用了&quot;/&quot;结尾时，httpd将搜索该指令所指定的文件响应给客户端&quot;。也就是说，当url表示搜索的是目录时，将查找该目录下的DirectoryIndex。注意，很多时候如果没有给定尾部的&quot;/&quot;，httpd的dir_module模块会自行加上&quot;/&quot;，当然，是否补齐尾随的&quot;/&quot;，也是可以控制的，见&lt;span&gt;&lt;a href=&quot;http://httpd.apache.org/docs/2.4/mod/mod_dir.html#directoryslash&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;DirectorySlash&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;指令。&lt;/p&gt;
&lt;p&gt;DirectoryIndex的设置格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DirectoryIndex disabled | &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;-url [&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;-url]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，当设置&quot;DirectoryIndex index.html&quot;时，如果在浏览器中输入下面左边的几个URL，httpd将响应右边对应的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.14&lt;/span&gt;           ==&amp;gt; &lt;span class=&quot;hljs-variable&quot;&gt;$DocumentRoot&lt;/span&gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html
http:&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.14&lt;/span&gt;/newdir/   ==&amp;gt; &lt;span class=&quot;hljs-variable&quot;&gt;$DocumentRoot&lt;/span&gt;/newdir/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以指定多个index文件，它们将按顺序从左向右依次查找，并返回第一个找到的index文件。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;IfModule dir_module&amp;gt;
    DirectoryIndex &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.php &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html /mydir/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/IfModule&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当浏览器中输入&lt;code&gt;http://192.168.100.14/&lt;/code&gt;时，将首先搜索index.php，如果该文件不存在，则再搜索index.html，如果还找不到，则再找该目录的子目录下的文件/mydir/index.html。但这不表示&lt;code&gt;http://192.168.100.14/mydir/&lt;/code&gt;会搜索/mydir/index.html。&lt;/p&gt;
&lt;p&gt;可以使用多个DirectoryIndex指令进行追加设置，它等价于单行设置多个值，例如下面的设置等价于&lt;code&gt;DirectoryIndex index.php index.html&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DirecotryIndex &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.php
DirectoryIndex &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要替换某个值，则直接修改或使用disabled关键字禁用其前面的Directoryindex。例如禁用index.php，只提供index.html的索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DirectoryIndex &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.php
DirectoryIndex disabled
DirectoryIndex &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但注意，&quot;disabled&quot;关键字必须独自占用一个DirectoryIndex指令，否则它将被解析成字面意思，也就是说将其当作一个index文件响应给客户端。&lt;/p&gt;
&lt;p&gt;DirectoryIndex指令可以设置在Server、Virtual host、Location和Directory上下文。所以，当设置在location或Directory容器中时，它将覆盖全局设置。例如，当DocumentRoot为/usr/local/apache/htdocs时：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; index.php
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;directory /usr/local/apache/htdocs/newdir&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; index.html
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;location /newdir&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; index.html
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/location&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在输入&lt;code&gt;http://IP/newdir/&lt;/code&gt;时，将提供index.html而非index.php。&lt;/p&gt;
&lt;p&gt;当DirectoryIndex提供的索引文件都不存在时，将根据Options中的Indexes选项设置决定是否列出文件列表，除非是提供文件下载，否则出于安全考虑，这个选项是强烈建议关闭的。例如以下设置为打开，当&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;directory /usr/local/apache/htdocs/newdir&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Options&lt;/span&gt;&lt;/span&gt; Indexes
    &lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; index.html
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-5-servername-serveralias&quot;&gt;1.2.5 ServerName和ServerAlias&lt;/h3&gt;
&lt;p&gt;ServerName用于唯一标识提供web服务的主机名，只有在基于名称的虚拟主机中该指令才是必须提供的。也就是说，如果不是在基于名称的虚拟主机中，可以任意指定该指令的值，只要你认为它能唯一标识你的主机。但如果不设置该指令，那么httpd在启动时，将会反解操作系统的IP地址。&lt;/p&gt;
&lt;p&gt;唯一标识主机的方式，也即ServerName的语法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;ServerName&lt;/span&gt;&lt;/span&gt; {domain-name|ip-address}[:port]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，在主机web.longshuai.com上提供了一个httpd web服务，如果还想使用www.longshuai.com提供同样的服务，还想效率更高点，则在设置DNS别名后再配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;ServerName&lt;/span&gt; www.longshuai.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServerAlias用于定义ServerName的别名。如果在定义ServerName之后再定义ServerAlias，那么ServerName和ServerName没有任何区别。当然，为了区分基于名称的虚拟主机，还是必须要定义ServerName。&lt;/p&gt;
&lt;p&gt;例如，下面几个ServerName和ServerAlias是完全等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;VirtualHost *:80&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;ServerName&lt;/span&gt;&lt;/span&gt;  server.example.com
  &lt;span class=&quot;hljs-keyword&quot;&gt;ServerAlias&lt;/span&gt; server server2.example.com server2
  &lt;span class=&quot;hljs-keyword&quot;&gt;ServerAlias&lt;/span&gt; *.example.com
  
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-6-include-&quot;&gt;1.2.6 Include指令&lt;/h3&gt;
&lt;p&gt;在httpd启动时，首先会解析配置文件。httpd支持include指令来包含其他文件，在解析配置文件时会进行配置合并。&lt;/p&gt;
&lt;p&gt;支持通配符&quot;*&quot;、&quot;?&quot;和&quot;[]&quot;，但它们不能匹配斜线&quot;/&quot;，如有必要，它们会按照&lt;span&gt;&lt;strong&gt;文件名的字母顺序依次&lt;/strong&gt;&lt;/span&gt;进行加载。如果include指令中指定包含一个目录，则会按照字母顺序加载该目录内的所有文件，这比较容易出错，因为有些时候会产生一些临时文件或非配置类的文件。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Include /usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/apache/conf/ssl.conf
Include /usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/apache/conf/vhosts/*.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用绝对路径，也可以使用相对路径，如果使用相对路径，则它相对于ServerRoot。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;Include&lt;/span&gt; conf/ssl.conf
Include conf/vhosts/&lt;span class=&quot;hljs-regexp&quot;&gt;*.conf&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果include包含的文件不存在时，将报错。这时可以使用IncludeOptional指令进行加载，这表示存在则加载，不存在就算了。例如下面的第一条指令中，如果vhosts下没有子目录，或者子目录中没有&quot;.conf&quot;文件都将失败，而第二条指令则不会。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;Include&lt;/span&gt; conf/vhosts/*/&lt;span class=&quot;hljs-regexp&quot;&gt;*.conf&lt;/span&gt;
IncludeOptional conf/vhosts/*/&lt;span class=&quot;hljs-regexp&quot;&gt;*.conf&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-7-define-undefine-&quot;&gt;1.2.7 Define和UnDefine指令&lt;/h3&gt;
&lt;p&gt;该指令用于定义参数或定义向后全局生效的变量。语法格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Define &lt;span class=&quot;hljs-tag&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[value]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当只给定一个param时，表示定义一个参数，这个参数用于&amp;lt; IfDefine param &amp;gt;容器进行判断，只有定义了的参数param，该容器才返回真，其内封装的指令才生效。它的等价行为是在httpd启动时(必须是启动时)，使用&quot;-D&quot;选项定义参数。例如下面两个方法是等价的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
shell&amp;gt; httpd -DMyName ......

Define MyName
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当给定了两个参数，即还指定了value时，将表示定义一个变量，该变量具有&lt;span&gt;&lt;strong&gt;向后全局性&lt;/strong&gt;&lt;/span&gt;。也就是说，定义在某个虚拟主机中的变量在后面的另一个虚拟主机中也有效。引用变量时，使用&lt;code&gt;${var}&lt;/code&gt;的方式。注意，变量名中不能包含冒号&quot;:&quot;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfDefine !TEST&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;Define&lt;/span&gt; servername www.example.com
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfDefine&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;DocumentRoot&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;/var/www/${servername}/htdocs&quot;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用UnDefine指令则是取消Define定义的参数或变量。语法为&lt;code&gt;UnDefine param&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1-2-8-virtualhost-&quot;&gt;1.2.8 VirtualHost指令&lt;/h3&gt;
&lt;p&gt;无疑，这是最重要的指令之一。用于封装一组指令只作用于指定主机名或IP地址的虚拟主机上。&lt;/p&gt;
&lt;p&gt;语法格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;VirtualHost&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;addr&lt;/span&gt;[&lt;span class=&quot;hljs-attribute&quot;&gt;:port&lt;/span&gt;] [&lt;span class=&quot;hljs-attribute&quot;&gt;addr&lt;/span&gt;[&lt;span class=&quot;hljs-attribute&quot;&gt;:port&lt;/span&gt;]] &lt;span class=&quot;hljs-attribute&quot;&gt;...&lt;/span&gt;&amp;gt;&lt;/span&gt; ... &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;VirtualHost&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中addr部分可以是以下几种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟主机的IP地址&lt;/li&gt;
&lt;li&gt;虚拟主机IP地址对应的FQDN(不推荐)&lt;/li&gt;
&lt;li&gt;字符&quot;*&quot;，匹配任意IP地址&lt;/li&gt;
&lt;li&gt;字符串&quot;_default_&quot;，是&quot;*&quot;的别名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;VirtualHost 10.1.2.3:80&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;ServerAdmin&lt;/span&gt; webmaster@host.example.com
  &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;DocumentRoot&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;/www/docs/host.example.com&quot;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;ServerName&lt;/span&gt;&lt;/span&gt; host.example.com
  &lt;span class=&quot;hljs-keyword&quot;&gt;ErrorLog&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;logs/host.example.com-error_log&quot;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;TransferLog&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;logs/host.example.com-access_log&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要为虚拟主机指定ServerName，否则它将会从主配置继承。对于基于名称的虚拟主机，ServerName更是不可缺少，否则将继承操作系统的FQDN。&lt;/p&gt;
&lt;p&gt;当一个请求到达时，将按照最佳匹配进行主机匹配：通配的内容越少，优先级越高，也就越佳。例如&quot;192.168.100.14:80&quot;的优先级高于&quot;*:80&quot;。如果基于名称的虚拟主机无法匹配上，则采用虚拟主机列表中的第一个虚拟主机作为响应主机。如果所有虚拟主机都无法匹配上，则采用从主配置段落中的主机，如果主配置段落中注释了DocumentRoot，则返回对应的错误。&lt;/p&gt;
&lt;p&gt;具体配置方法，见&lt;span&gt;&lt;a title=&quot;轻松配置httpd的虚拟主机&quot; href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7632878.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;配置httpd虚拟主机&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1-2-9-options-allowoverride-&quot;&gt;1.2.9 Options和AllowOverride指令&lt;/h3&gt;
&lt;p&gt;Options启用或禁用指定目录下的某些特性。有效值包括：All、None、ExecCGI、FollowSymLinks、Includes、IncludesNOEXEC、Indexes、MultiViews、SymLinksIfOwnerMatch。&lt;/p&gt;
&lt;p&gt;不指定options时，默认为all。一般除了提供下载服务会开启一个Indexes选项，其他选项都会关掉，即使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Options &lt;span class=&quot;hljs-attribute&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AllowOverride指令用于控制是否读取&quot;.htaccess&quot;配置文件。&lt;/p&gt;
&lt;p&gt;如何设置这个指令要看具体情况，有以下几种值，此外还可以设置为all和none，表示启用、禁用所有特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AuthConfig：基于用户认证时设置该值，此时将可以使用AuthGroupFile, AuthName, AuthType, AuthUserFile, equire等认证相关指令。&lt;/li&gt;
&lt;li&gt;FileInfo： 控制文档类型时使用该值，此时将可以使用ErrorDocument, SetHandler,以及一些URL重写的指令。&lt;/li&gt;
&lt;li&gt;Indexes：控制目录索引时使用该值，此时可以使用AddIcon, DirectoryIndex。&lt;/li&gt;
&lt;li&gt;Limit：是否允许使用order、allow、deny指令，这三个指令已经废弃，目前还存在是为了兼容老版本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如下面的指令使得在使用非认证类和索引控制类指令时，将产生服务器类的错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;AllowOverride&lt;/span&gt; AuthConfig Indexes
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-10-require-&quot;&gt;1.2.10 Require指令&lt;/h3&gt;
&lt;p&gt;见&lt;span&gt;&lt;a title=&quot;Require指令&quot; href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7634205.html#blog1.3&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Require指令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;h3 id=&quot;1-2-11-&quot;&gt;1.2.11 长连接相关指令&lt;/h3&gt;
&lt;p&gt;KeepAlive指令用于开启和关闭长连接功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;KeepAlive &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;/&lt;span class=&quot;hljs-literal&quot;&gt;off&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在没有开启长连接时，客户端每请求一个资源都需重新建立一次TCP连接，而使用了长连接后，客户端只需在最初请求一次TCP连接，之后就可以使用同一个TCP连接发送其他的http请求。长连接的状态是指在服务端处理完某一个请求后，它立即进入长连接状态以保持TCP连接不断开，等待客户端再次发送请求。&lt;/p&gt;
&lt;p&gt;但长连接自身的缺陷是会一直占用着连接不释放，所以必须得给出一个长连接的超时时间。这个超时时间由KeepAliveTimeout指令控制，进入长连接后如果在此时间间隔内客户端还没有发送新请求，则TCP连接自动断开。如果在长连接状态下，客户端再次发送了请求，则服务端处理请求，并在处理完请求后又再次进入长连接状态并计算KeepAliveTimeout。&lt;/p&gt;
&lt;p&gt;此外，还可以通过指令MaxKeepAliveRequests控制每个长连接下的TCP连接的能接受的最大请求数。无疑，这个值应该设置的大一些，设置为0表示无限制。这个指令是从数量的角度控制长连接的TCP应该何时断开。例如，在长连接超时时间内接受同一个客户端的500个请求才断开，然后该客户端再有新的请求只能重新建立TCP连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;MaxKeepAliveRequests&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1-3-&quot;&gt;1.3 容器类指令&lt;/h2&gt;
&lt;p&gt;路径和条件判断容器包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt; Directory &amp;gt;、&amp;lt; DirectoryMatch &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; Files &amp;gt;、&amp;lt; FilesMatch &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; Location &amp;gt;、&amp;lt; LocationMatch &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; IfModule &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; IfDefine &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; IfVersion &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; if &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; elseif &amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt; else &amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-1-directory-files-&quot;&gt;1.3.1 容器&amp;lt; Directory &amp;gt;和&amp;lt; Files &amp;gt;&lt;/h3&gt;
&lt;p&gt;还包括它们的正则匹配容器&amp;lt; DirectoryMatch &amp;gt;、&amp;lt; FilesMatch &amp;gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt; Directory &amp;gt;容器的作用是&quot;对于匹配到的目录，封装一组指令，这些指令只作用于该目录以及它的子目录中的文件&quot;。注意，&lt;span&gt;&lt;strong&gt;&amp;lt; Directory &amp;gt;容器通常都是用绝对路径，即&amp;lt; Directory /PATH/to/DIR &amp;gt;，如果使用相对路径，则它相对于根文件系统的&quot;/&quot;&lt;/strong&gt;&lt;/span&gt;。例如&amp;lt; directory newdir &amp;gt;等价于&amp;lt; directory /newdir &amp;gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;AllowOverride&lt;/span&gt; none
    &lt;span class=&quot;hljs-keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; denied
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/usr/local/apache/htdocs&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个容器表示拒绝所有对&quot;/&quot;下内容的访问，包括子目录中的文件，这个根是根文件系统的根，而不是ServerRoot。而第二个容器则表示允许/usr/local/apache/htdocs目录下文件的访问。&lt;/p&gt;
&lt;p&gt;由此可以想象得出，出于安全考虑，应该总是先将父目录进行限制，再在需要放宽权限的子目录中指定特定的权限。正如上面的设置，将最顶级目录&quot;/&quot;完全限制，然后在小范围的htdocs目录中放行。&lt;/p&gt;
&lt;p&gt;再看&amp;lt; Files &amp;gt;容器，它针对的是某个或某些特定的能被匹配上的文件。它匹配的范围是它所在的上下文。&lt;/p&gt;
&lt;p&gt;例如，下面的指令如果写在server上下文，那么将对任意private.html文件拒绝。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Files private.html&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; denied
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Files&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果将其写在&amp;lt; directory &amp;gt;容器中，则只对该目录容器中的所有private.html生效。由于&amp;lt; directory &amp;gt;会递归到子目录中，所以子目录中的private.html也会拒绝，但非private.html将被允许。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/usr/local/apache/htdocs&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Files private.html&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; denied
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Files&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt; directory &amp;gt;和&amp;lt; files &amp;gt;容器可以使用通配符，&quot;*&quot;表示任意字符，&quot;?&quot;表示任意单个字符，&quot;[]&quot;表示范围，如[a-z]、[0-9]，但是这些通配符都不能匹配&quot;/&quot;。所以要跨目录匹配时，必须显式指定各个目录的&quot;/&quot;符号。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;&amp;lt;directory /*/public.html&amp;gt;&lt;/code&gt;无法匹配/home/user/public.html，但&lt;code&gt;directory /home/*/public.html&lt;/code&gt;可以匹配。&lt;/p&gt;
&lt;p&gt;它还可以使用正则表达式匹配，只需使用一个&quot;~&quot;符号即可。这时和使用&amp;lt; DirectoryMatch &amp;gt;、&amp;lt; FilesMatch &amp;gt;是一样的，只不过Match类指令不需要使用&quot;~&quot;符号。&lt;/p&gt;
&lt;p&gt;例如，下面的设置。其中后两个Directory容器是等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;FilesMatch &quot;\.(?i:gif|jpe?g|png)$&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; denied
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/FilesMatch&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory ~ &quot;^/usr/local/apache/htdocs/[0-9]{3}&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; digest.html
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;DirectoryMatch &quot;^/usr/local/apache/htdocs/[0-9]{3}&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;DirectoryIndex&lt;/span&gt; digest.html
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/DirectoryMatch&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，httpd采用的pcre库提供的perl兼容正则。以下是官方手册提供的一个示例，使用的命名捕获语法，它将匹配/var/www/combined/目录下的一级子目录，但不进行递归。将每个匹配到的结果保存到命名的分组sitename中，并通过环境变量&quot;MATCH_capturename&quot;进行引用，其中capturename必须转为大写字母，因为它就是这样赋值的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;DirectoryMatch &lt;span class=&quot;hljs-string&quot;&gt;&quot;^/var/www/combined/(?&amp;lt;sitename&amp;gt;[^/]+)&quot;&lt;/span&gt;&amp;gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; ldap-group cn=%{env:MATCH_SITENAME},ou=combined,o=Example
&amp;lt;/DirectoryMatch&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前已经不能使用未命名的后向引用，例如$0,$1...。在URL重写时，正则语法至关重要，像grep/sed/awk中天然支持的基础正则和扩展正则语法虽然能解决大部分问题，但想要实现复杂的需求，只能使用语义丰富、完整的正则，如pcre提供的正则。&lt;/p&gt;

&lt;h3 id=&quot;1-3-2-location-&quot;&gt;1.3.2 容器&amp;lt; Location &amp;gt;&lt;/h3&gt;
&lt;p&gt;该容器和&amp;lt; Directory &amp;gt;、&amp;lt; Files &amp;gt;容器差不多，都是对满足匹配条件的路径封装一组指令，这些指令只生效于这些能匹配的路径。但是&amp;lt; Location &amp;gt;和&amp;lt; Directory &amp;gt;、&amp;lt; Files &amp;gt;最大的区别是：前者匹配的目标是WebSpace，即匹配URL中的路径，而后两者匹配的是本地文件系统的路径。&lt;/p&gt;
&lt;p&gt;例如，当设置下面的location容器时，将匹配&lt;code&gt;http://192.168.100.14/newdir/index.html&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;newdir&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    ......
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;location支持三种匹配模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;精确匹配：location的模式和URL中的路径部分精确对应。&lt;/li&gt;
&lt;li&gt;加尾随斜线：location的模式中加了尾随斜线时，将匹配该目录里面的内容。&lt;/li&gt;
&lt;li&gt;无尾随斜线：location的模式中没有尾随斜线时，将匹配该目录和目录里面的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，下面两个容器，第一个将匹配/private1、/private1/和/private1/file.txt，但不能匹配/private1other，而第二个将匹配/private2/和/private2/file.txt，但不能匹配/private2和/private2other。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;private1&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    ......
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;private2&lt;/span&gt;/&quot;&amp;gt;&lt;/span&gt;
    ......
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;location和sethandler指令一起使用时很方便。例如，开启状态信息页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Location &quot;/server-status&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;SetHandler&lt;/span&gt;&lt;/span&gt; server-status
    &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，除了支持&quot;*&quot;、&quot;?&quot;、&quot;[]&quot;的通配符匹配，还支持&quot;~&quot;和LocationMatch指令的正则匹配。方法见上面的&amp;lt; Directory &amp;gt;容器。&lt;/p&gt;

&lt;h3 id=&quot;1-3-3-ifdefine-ifmodule-ifversion-&quot;&gt;1.3.3 &amp;lt; IfDefine &amp;gt;、&amp;lt; IfModule &amp;gt;和&amp;lt; IfVersion &amp;gt;条件判断&lt;/h3&gt;
&lt;p&gt;这三个容器都是条件判断容器，&lt;span&gt;&lt;strong&gt;且都只在httpd启动时进行判断&lt;/strong&gt;&lt;/span&gt;，判断为真，则封装在其内的指令生效，否则忽略。且都可以在条件前加一个&quot;!&quot;以实现条件的否定，而且都可以嵌套以实现更复杂的配置。&lt;/p&gt;
&lt;p&gt;&amp;lt; IfModule &amp;gt;容器是指当启动时加载了某模块时，该容器内的指令生效。可以是静态加载的模块，或者使用LoadModule指令加载的，但如果这样的话，加载对应模块的LoadModule指令必须在&amp;lt; IfModule &amp;gt;指令之前。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; status_module modules/mod_status.so

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfModule &quot;status_module&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Location &quot;/server-status&quot;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;SetHandler&lt;/span&gt;&lt;/span&gt; server-status
        &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfModule&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt; IfDefine param &amp;gt;容器用于判断参数param是否已经定义，如果定义了，则条件为真，封装在其内的指令生效，否则忽略。加上感叹号则表示取反，例如&amp;lt; IfDefine !param &amp;gt;。&lt;/p&gt;
&lt;p&gt;那么如何定义参数呢？有两种方法：使用httpd命令的&quot;-D&quot;选项；使用Define指令。&lt;/p&gt;
&lt;p&gt;例如，在使用httpd启动时，加上一个&quot;-D&quot;选项定义MyName参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;httpd&lt;/span&gt; -DMyName ......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者在配置文件中使用Define指令进行定义，但必须在&amp;lt; IfDefine &amp;gt;容器之前定义。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;Define&lt;/span&gt; MyName
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt; IfDefine &amp;gt;可以进行嵌套。例如下面是官方的一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;httpd&lt;/span&gt; -DReverseProxy -DUseCache -DMemCache ...

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfDefine ReverseProxy&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; proxy_module   modules/mod_proxy.so
  &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; proxy_http_module   modules/mod_proxy_http.so
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfDefine UseCache&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; cache_module   modules/mod_cache.so
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfDefine MemCache&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; mem_cache_module   modules/mod_mem_cache.so
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfDefine&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;IfDefine !MemCache&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;LoadModule&lt;/span&gt;&lt;/span&gt; cache_disk_module   modules/mod_cache_disk.so
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfDefine&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfDefine&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/IfDefine&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt; IfVersion &amp;gt;容器用于判断httpd的版本。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;IfVersion &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;&amp;gt;
    # &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; happens only &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; versions greater or equal &lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;.0.
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/IfVersion&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-3-4-if-elseif-else-&quot;&gt;1.3.4 &amp;lt; If &amp;gt;、&amp;lt; ElseIf &amp;gt;和&amp;lt; Else &amp;gt;容器&lt;/h3&gt;
&lt;p&gt;意义不言自明。&amp;lt; If &amp;gt;...&amp;lt; /If &amp;gt;判断表达式是否为真，如果为真，则封装在其内的指令生效；&amp;lt; ElseIf &amp;gt;...&amp;lt; /ElseIf &amp;gt;作用于&amp;lt; If &amp;gt;...&amp;lt; /If &amp;gt;之后，而&amp;lt; Else &amp;gt;...&amp;lt; /Else &amp;gt;则作用于最后。&lt;/p&gt;
&lt;p&gt;表达式的写法和shell脚本的表达式差不多，例如数值比较&quot;-eq&quot;、&quot;-gt&quot;，字符串比较&quot;==&quot;、&quot;&amp;gt;=&quot;，以及其他一些表达式&quot;-z&quot;、&quot;-n&quot;、&quot;-f&quot;等，此外，它还支持正则匹配表达式&quot;~=&quot;、&quot;!~&quot;。具体相关函数、变量、表达式、语法等见 &lt;a href=&quot;http://httpd.apache.org/docs/2.4/expr.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://httpd.apache.org/docs/2.4/expr.html&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;If&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;-z req('Host')&quot;&lt;/span&gt;&amp;gt;
...
&amp;lt;/&lt;span class=&quot;hljs-keyword&quot;&gt;If&lt;/span&gt;&amp;gt;


&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;If&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;-R '10.1.0.0/16'&quot;&lt;/span&gt;&amp;gt;
  
&amp;lt;/&lt;span class=&quot;hljs-keyword&quot;&gt;If&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;ElseIf&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;-R '10.0.0.0/8'&quot;&lt;/span&gt;&amp;gt;
  
&amp;lt;/&lt;span class=&quot;hljs-keyword&quot;&gt;ElseIf&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;Else&lt;/span&gt;&amp;gt;
  
&amp;lt;/&lt;span class=&quot;hljs-keyword&quot;&gt;Else&lt;/span&gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;1-4-&quot;&gt;1.4 配置文件的合并规则&lt;/h2&gt;
&lt;p&gt;配置文件的段落以一种非常特殊的顺序生效。理解配置文件的合并规则非常重要，否则配置了半天可能发现根本不会生效。&lt;/p&gt;
&lt;p&gt;以下是5个组类合并的顺序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.&amp;lt; Directory &amp;gt; (正则匹配的容器除外)&lt;/li&gt;
&lt;li&gt;2.&amp;lt; DirectoryMatch &amp;gt; (以及&amp;lt; Directory &quot;~&quot; &amp;gt;)&lt;/li&gt;
&lt;li&gt;3.&amp;lt; Files &amp;gt;和&amp;lt; FilesMatch &amp;gt;同时处理&lt;/li&gt;
&lt;li&gt;4.&amp;lt; Location &amp;gt;和&amp;lt; LocationMatch &amp;gt;同时处理&lt;/li&gt;
&lt;li&gt;5.&amp;lt; If &amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，还需要注意的一些规则是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除了&amp;lt; Directory &amp;gt;容器，每个组以它们出现的顺序进行合并。例如一个/foo请求可以匹配&amp;lt; Location &quot;/foo/bar&quot; &amp;gt;和&amp;lt; Location &quot;/foo&quot; &amp;gt;，它们都属于上面列出的第4组，所以对于这两个Location容器，谁配置在前面就匹配谁。&lt;/li&gt;
&lt;li&gt;&amp;lt; Directory &amp;gt;容器即上面的第一组处理的顺序是先处理路径&quot;短&quot;的，再处理路径长的。这里的短指的是离根文件系统的&quot;/&quot;越近就越短。由于这个组不包含正则匹配的表达式(即&amp;lt; Directory ~ &amp;gt;)，所以这里的&quot;短&quot;就代表它的路径表达式短。例如&amp;lt; Directory &quot;/var/web/dir&quot; &amp;gt;将优先于&amp;lt; Directory &quot;/var/web/dir/subdir&quot; &amp;gt;被处理。&lt;/li&gt;
&lt;li&gt;如果出现多个&amp;lt; Directory &amp;gt;的路径完全一样的极端情况，那么将按照出现顺序处理。&lt;/li&gt;
&lt;li&gt;使用Include指令包含的文件将被插入到该指令的位置，然后按规则进行处理。&lt;/li&gt;
&lt;li&gt;&amp;lt; VirtualHost &amp;gt;段落的配置将在外部对应的段处理完毕以后再处理，这样就允许虚拟主机覆盖主服务器的设置。&lt;/li&gt;
&lt;li&gt;当请求是由mod_proxy处理的时候，&amp;lt; Proxy &amp;gt;容器将会在处理顺序中取代&amp;lt; Directory &amp;gt;容器的位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，配置文件中的指令都是由各个模块提供的，所以各指令是由各对于模块来解析、处理、合并的，配置文件的作用只不过是将各个模块的指令整合在一起方便定义。另外，上面定义的5个组别都是由httpd的核心模块提供的，因此它们才有处理顺序的要求。&lt;/p&gt;
&lt;p&gt;当在运行时进行请求匹配，将先按照上面合并规则提供的顺序进行匹配，如果某个组中出现了能成功匹配请求的模块，将提升一次合并的层次，使得这次模块的匹配变为第三次匹配。例如下面的配置使用了由mod_headers提供的Header指令用于设置HTTP的首部，如果请求/example/index.html，那么最终设置的CustomHeaderName首部的值是什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Header&lt;/span&gt;&lt;/span&gt; set CustomHeaderName one
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;FilesMatch &quot;.*&quot;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Header&lt;/span&gt;&lt;/span&gt; set CustomHeaderName three
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/FilesMatch&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/example&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-common&quot;&gt;Header&lt;/span&gt;&lt;/span&gt; set CustomHeaderName two
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先按照前面提供的合并顺序匹配到&quot;/&quot;，这会初始化设置CustomHeaderName的值为one，再匹配到/example，CustomHeaderName被设置为two。最后分组中提供的指令FilesMatch匹配成功，提升一次合并的层次，这是第三次匹配，导致CustomHeaderName最终设置为three。&lt;/p&gt;
&lt;p&gt;下面的例子中，如果这些指令都对请求生效，它们将按照&quot;A &amp;gt; B &amp;gt; C &amp;gt; D &amp;gt; E&quot;的顺序生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt; &quot;/&quot;&amp;gt;&lt;/span&gt;
    E
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Location&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Files&lt;/span&gt; &quot;&lt;span class=&quot;hljs-attribute&quot;&gt;f.html&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    D
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Files&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;VirtualHost&lt;/span&gt; *&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;a&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;b&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    B
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;VirtualHost&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;DirectoryMatch&lt;/span&gt; &quot;^&lt;span class=&quot;hljs-attribute&quot;&gt;.&lt;/span&gt;*&lt;span class=&quot;hljs-attribute&quot;&gt;b&lt;/span&gt;$&quot;&amp;gt;&lt;/span&gt;
    C
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;DirectoryMatch&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;a&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;b&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    A
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;D和E无疑是最后生效的。再看三个Directory类的容器，对于Directory和DirectoryMatch，前者先生效，所以C排在A和B后，对于A和B，虚拟主机会在外部段落处理完后再处理，所以在A和B进行合并时，B将覆盖A，也即A先生效。所以顺序为&quot;A&amp;gt;B&amp;gt;C&amp;gt;D&amp;gt;E&quot;。但如果将上面的A段落改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt; &quot;/&lt;span class=&quot;hljs-attribute&quot;&gt;a&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;b&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;
    A
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;FilesMatch&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;f.html&lt;/span&gt;&amp;gt;&lt;/span&gt;
        D1
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Files&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;Directory&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么最终的顺序为&quot;A&amp;gt;B&amp;gt;C&amp;gt;D&amp;gt;D1&amp;gt;E&quot;。&lt;/p&gt;
&lt;p&gt;以下示例则更有教育意义。尽管Directory设置了更严格的权限，但因为Location比Directory更后生效，它对所有访问都不做任何限制。也就是说，Directory在这里的权限设置是完全多余的。所以说，理解配置文件的合并规则对写配置文件至关重要。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Location &quot;/&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt;


&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;Directory &quot;/&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;RequireAll&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;all&lt;/span&gt; granted
        &lt;span class=&quot;hljs-keyword&quot;&gt;Require&lt;/span&gt; not host badguy.example.com
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/RequireAll&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7636836.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/7636836.html&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/h3&gt;
</description>
<pubDate>Sun, 08 Oct 2017 03:09:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/7636836.html</dc:identifier>
</item>
<item>
<title>【归纳整理】Ajax  /  JSON  /  WEB存储   /  iframe - 卡尔西法calcifer</title>
<link>http://www.cnblogs.com/wq1994/p/7636648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wq1994/p/7636648.html</guid>
<description>[unable to retrieve full-text content]Ajax 一、什么是 AJAX ？ AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载</description>
<pubDate>Sun, 08 Oct 2017 02:09:00 +0000</pubDate>
<dc:creator>卡尔西法calcifer</dc:creator>
<dc:identifier>http://www.cnblogs.com/wq1994/p/7636648.html</dc:identifier>
</item>
<item>
<title>移动HTML5前端框架—MUI - 姐姐jy</title>
<link>http://www.cnblogs.com/jiejiejy/p/7635179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiejiejy/p/7635179.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JRedu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      鉴于之前的很多前端框架（特别是响应式布局的框架），UI控件看起来太像网页，没有原生感觉，因此追求原生UI也是MUI的重要目标。MUI以iOS平台UI为基础，补充部分Android平台特有的UI控件。MUI主要有三种含义:一、一种单独发行的计算机操作系统Windows的多语种版本;二、世界上最权威的Halal认证的官方机构;三、在移动通讯技术中的专有名词。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 使用该框架之前的准备工作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;1. 新建含mui的HTML文件&lt;/h3&gt;
&lt;p&gt;在Hbuilder中，新建HTML文件，选择”含mui的HTML“模板，可以快速生成mui页面模板，该模板默认处理了mui的js、css资源引用。&lt;/p&gt;
&lt;h3&gt;2.输入mheader&lt;/h3&gt;
&lt;p&gt;顶部标题栏是每个页面都必需的内容，在Hbuilder中输入mheader，可以快速生成顶部导航栏。&lt;/p&gt;
&lt;h3&gt;3.输入mbody&lt;/h3&gt;
&lt;p&gt;除顶部导航、底部选项卡两个控件之外，其它控件都建议放在&lt;code&gt;.mui-content&lt;/code&gt;控件内，在Hbuilder中输入mbody，可快速生成包含&lt;code&gt;.mui-content&lt;/code&gt;的代码块。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、UI组件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.accordion(折叠面板)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;折叠面板和二级列表类似，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007100734427-885922591.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell mui-collapse&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;面板1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-collapse-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;面板1子内容&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell mui-collapse&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;面板2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-collapse-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;面板2子内容&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.buttons(按钮)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;普通按钮&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在button节点上增加&lt;code&gt;.mui-btn&lt;/code&gt;类，就可以生成默认按钮；如果需要其他颜色的按钮，则继续增加对应class即可，比如&lt;code&gt;.mui-btn-blue&lt;/code&gt;即可变成蓝色按钮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;默认&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-primary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;蓝色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;绿色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-warning&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;黄色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;红色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-royal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;紫色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行之后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007101429208-1922198342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;若希望无底色、有边框的按钮，仅需增加&lt;code&gt;.mui-btn-outlined&lt;/code&gt;类即可，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;默认&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-primary mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;蓝色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-success mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;绿色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-warning mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;黄色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-danger mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;红色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-btn mui-btn-royal mui-btn-outlined&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;紫色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007101925036-314727843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.gallery(图片轮播)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;图片轮播继承自&lt;a href=&quot;http://dev.dcloud.net.cn/mui/ui/#slide&quot;&gt;slide插件&lt;/a&gt;，因此其DOM结构、事件均和slide插件相同；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认不支持循环播放，DOM结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;2.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;3.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;4.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;component-description&quot;&gt;假设当前图片轮播中有1、2、3、4四张图片，从第1张图片起，依次向左滑动切换图片，当切换到第4张图片时，继续向左滑动，接下来会有两种效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持循环：左滑，直接切换到第1张图片；&lt;/li&gt;
&lt;li&gt;不支持循环：左滑，无反应，继续显示第4张图片，用户若要显示第1张图片，必须连续向右滑动切换到第1张图片；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当显示第1张图片时，继续右滑是否显示第4张图片，是同样问题；这个问题的实现需要通过&lt;code&gt;.mui-slider-loop&lt;/code&gt;类及DOM节点来控制；&lt;/p&gt;

&lt;p class=&quot;component-description&quot;&gt;若要支持循环，则需要在&lt;code&gt;.mui-slider-group&lt;/code&gt;节点上增加&lt;code&gt;.mui-slider-loop&lt;/code&gt;类，同时需要重复增加2张图片，图片顺序变为：4、1、2、3、4、1，代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-group mui-slider-loop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;支持循环，需要重复图片节点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item mui-slider-item-duplicate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;4.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;2.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;3.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;4.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;支持循环，需要重复图片节点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-slider-item mui-slider-item-duplicate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1.jpg&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mui框架内置了图片轮播插件，通过该插件封装的JS API，用户可以设定是否自动轮播及轮播周期，如下为代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得slider插件对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; gallery = mui('.mui-slider'&lt;span&gt;);
gallery.slider({
  interval:&lt;/span&gt;3000&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动轮播周期，若为0则不自动播放，默认为0；&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;component-description&quot;&gt;因此若希望图片轮播不要自动播放，而是用户手动滑动才切换，只需要通过如上方法，将interval参数设为0即可。&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;若要跳转到第x张图片，则可以使用图片轮播插件的gotoItem方法，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mui自带的on事件绑定，只能用事件委派方式&lt;/span&gt;
mui(&quot;.mui-content&quot;).on(&quot;tap&quot;,&quot;#btn&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    gallery.slider().gotoItem(&lt;/span&gt;2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调到第三张图片，index从0开始&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.input(输入表单)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有包裹在&lt;code&gt;.mui-input-row&lt;/code&gt; 类中的 input、textarea等元素都将被默认设置宽度属性为&lt;code&gt;width: 100%;&lt;/code&gt; 。 将 label 元素和上述控件控件包裹在&lt;code&gt;.mui-input-group&lt;/code&gt;中可以获得最好的排列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007110255833-1641323423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（密码输入框右侧还自带了一个眼睛图标呢，我觉得特别好用）&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt; 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-clear&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入用户名&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;密码&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-password&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入密码&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mui目前还提供了几个输入增强功能：快速删除、语音输入&lt;a class=&quot;snippet_a&quot;&gt;*5+ only&lt;/a&gt;和密码框显示隐藏密码。&lt;/p&gt;
&lt;p&gt; 1)快速删除：只需要在input控件上添加&lt;code&gt;.mui-input-clear&lt;/code&gt;类，当input 控件中有内容时，右侧会有一个&lt;span&gt;删除图标&lt;/span&gt;，点击会清空当前input的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007163835302-1518863078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;快速删除&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-clear&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入内容&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2)搜索框：在&lt;code&gt;.mui-input-row&lt;/code&gt;同级添加&lt;code&gt;.mui-input-search&lt;/code&gt; 类，就可以使用search控件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007164101786-856189551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-row mui-search&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-clear&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;component-example&quot;&gt;3)语音输入&lt;a class=&quot;snippet_a&quot;&gt;*5+ only&lt;/a&gt;：为了方便快速输入，mui集成了 &lt;a href=&quot;http://www.html5plus.org/doc/zh_cn/speech.html&quot; target=&quot;_blank&quot;&gt;HTML5+的语音输入&lt;/a&gt;，只需要在对应input控件上添加&lt;code&gt;.mui-input-speech&lt;/code&gt; 类，就可以在5+环境下使用语音输入&lt;/p&gt;

&lt;p class=&quot;component-example&quot;&gt;4)密码框：给input元素添加&lt;code&gt;.mui-input-password&lt;/code&gt;类即可使用&lt;/p&gt;
&lt;p class=&quot;component-example&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007164338474-1078466727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;component-example&quot;&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-row&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;密码框&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;mui-input-password&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入密码&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.list(列表)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mui封装的列表组件是比较简单也很好用的。只需要在&lt;code&gt;ul&lt;/code&gt;节点上添加&lt;code&gt;.mui-table-view&lt;/code&gt;类、在&lt;code&gt;li&lt;/code&gt;节点上添加&lt;code&gt;.mui-table-view-cell&lt;/code&gt;类即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007165523193-184387004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义列表高亮颜色&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;点击列表，对应列表项显示灰色高亮，若想自定义高亮颜色，只需要重写&lt;code&gt;.mui-table-view-cell.mui-active&lt;/code&gt;即可，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;点击变灰色高亮&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.mui-table-view-cell.mui-active&lt;/span&gt;{&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; gray&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;右侧添加导航箭头&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;若右侧需要增加导航箭头，变成导航链接，则只需在&lt;code&gt;li&lt;/code&gt;节点下增加&lt;code&gt;a&lt;/code&gt;子节点，并为该&lt;code&gt;a&lt;/code&gt;节点增加&lt;code&gt;.mui-navigate-right&lt;/code&gt;类即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-navigate-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Item 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007165936490-149911420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;右侧添加数字角标等控件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;badgeList&quot; class=&quot;component-description&quot;&gt;mui支持将数字角标、按钮、开关等控件放在列表中；mui默认将数字角标放在列表右侧显示，代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Item 1 
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-badge mui-badge-primary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Item 2 
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-badge mui-badge-success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;Item 3 
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-badge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007170254224-119455047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（图文列表）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;图文列表继承自列表组件，主要添加了&lt;code&gt;.mui-media&lt;/code&gt;、&lt;code&gt;.mui-media-object&lt;/code&gt;、&lt;code&gt;.mui-media-body&lt;/code&gt;、&lt;code&gt;.mui-pull-left/right&lt;/code&gt;几个类，如下为示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell mui-media&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-object mui-pull-left&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;img/a.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                幸福
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='mui-ellipsis'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;能和心爱的人一起睡觉，是件幸福的事情；可是，打呼噜怎么办？&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell mui-media&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-object mui-pull-left&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;img/b.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                木屋
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='mui-ellipsis'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;想要这样一间小木屋，夏天挫冰吃瓜，冬天围炉取暖.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-table-view-cell mui-media&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-object mui-pull-left&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;img/c.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;mui-media-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                CBD
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='mui-ellipsis'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;烤炉模式的城，到黄昏，如同打翻的调色盘一般.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1212256/201710/1212256-20171007170757771-2008196896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 结束语：mui框架使用起来确实很方便，它还有很多控件供我们使用，具体可在mui官网查看。&lt;/p&gt;
</description>
<pubDate>Sun, 08 Oct 2017 01:27:00 +0000</pubDate>
<dc:creator>姐姐jy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiejiejy/p/7635179.html</dc:identifier>
</item>
</channel>
</rss>