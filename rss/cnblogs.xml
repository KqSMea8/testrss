<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【小程序】微信小程序实现各种特效实例 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7616581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7616581.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; getApp()
Page({
  data: {
    stars: [&lt;/span&gt;0, 1, 2, 3, 4&lt;span&gt;],
    normalSrc: &lt;/span&gt;'../../../image/normal.png'&lt;span&gt;,
    selectedSrc: &lt;/span&gt;'../../../image/selected.png'&lt;span&gt;,
    halfSrc: &lt;/span&gt;'../../../image/half.png'&lt;span&gt;,
    key: &lt;/span&gt;1,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;评分&lt;/span&gt;
    path: ' '&lt;span&gt;,
    userInput:&lt;/span&gt;' '&lt;span&gt;
  },
  onLoad: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    
  },

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击右边,半颗星&lt;/span&gt;
  selectLeft: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; e.currentTarget.dataset.key
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.data.key == 0.5 &amp;amp;&amp;amp; e.currentTarget.dataset.key == 0.5&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有一颗星的时候,再次点击,变为0颗&lt;/span&gt;
      key = 0&lt;span&gt;;
    }
    console.log(&lt;/span&gt;&quot;得&quot; + key + &quot;分&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      key: key
    })

  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击左边,整颗星&lt;/span&gt;
  selectRight: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; e.currentTarget.dataset.key
    console.log(&lt;/span&gt;&quot;得&quot; + key + &quot;分&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      key: key
    })
  },



   upload: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
    wx.chooseImage({
      count: &lt;/span&gt;1&lt;span&gt;,
      sizeType: [&lt;/span&gt;'original', 'compressed'&lt;span&gt;],
      sourceType: [&lt;/span&gt;'album', 'camera'&lt;span&gt;],
      success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempFilePaths =&lt;span&gt; res.tempFilePaths
        console.log(tempFilePaths)
        wx.uploadFile({
          url: &lt;/span&gt;'http://example.weixin.qq.com/upload'&lt;span&gt;,
          filePath: tempFilePaths[&lt;/span&gt;0&lt;span&gt;],
          name: &lt;/span&gt;'file'&lt;span&gt;,
          formData: {
            &lt;/span&gt;'user': 'test'&lt;span&gt;
          },
          success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; res.data
            wx.showModal({
              title: &lt;/span&gt;'上传文件返回状态'&lt;span&gt;,
              content: &lt;/span&gt;'成功'&lt;span&gt;,
              success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.confirm) {
                  console.log(&lt;/span&gt;'用户点击确定'&lt;span&gt;)
                }
              }
            })                          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;          },
          fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
            console.log(res)
          }
        })
        that.setData({
          path: tempFilePaths
        })
      }
    })
  },
  

   textAreaCon:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
     that.setData({
       userInput: e.detail.value,
     })
   },
   saveAccess:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.data.userInput == ' '&lt;span&gt;){
       wx.showModal({
         title: &lt;/span&gt;'提示'&lt;span&gt;,
         content: &lt;/span&gt;'对不起，请输入留言内容'&lt;span&gt;,
       })
     }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.userInput);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  成功监听用户输入内容&lt;/span&gt;
&lt;span&gt;

     }
   }

})&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Sep 2017 18:08:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7616581.html</dc:identifier>
</item>
<item>
<title>Spring Framework 5.0 新特性 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7616578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7616578.html</guid>
<description>&lt;p&gt;Spring Framework 5.0是在Spring Framework 4.0之后将近四年内一次重大的升级。 在这个时间框架内，主要的发展之一就是Spring Boot项目的演变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-cb92fb78de12ecff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring Framework 5.0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Framework 5.0的最大特点之一是&lt;strong&gt;响应式编程（Reactive Programming）&lt;/strong&gt;。 响应式编程核心功能和对响应式endpoints的支持可通过Spring Framework 5.0中获得。 重要变动如下列表所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常规升级&lt;/li&gt;
&lt;li&gt;对JDK 9运行时兼容性&lt;/li&gt;
&lt;li&gt;在Spring Framework代码中使用JDK 8特性&lt;/li&gt;
&lt;li&gt;响应式编程支持&lt;/li&gt;
&lt;li&gt;函数式Web框架&lt;/li&gt;
&lt;li&gt;Jigsaw的Java模块化&lt;/li&gt;
&lt;li&gt;对Kotlin支持&lt;/li&gt;
&lt;li&gt;舍弃的特性&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;Spring Framework 5.0遵守JDK 8和Java EE 7规范。 基本上，这意味着以前的JDK和Java EE版本不再受支持了。&lt;/p&gt;
&lt;p&gt;Spring Framework 5.0的一些重要基于Java EE 7规范如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet 3.1&lt;/li&gt;
&lt;li&gt;JMS 2.0&lt;/li&gt;
&lt;li&gt;JPA 2.1&lt;/li&gt;
&lt;li&gt;JAX-RS 2.0&lt;/li&gt;
&lt;li&gt;Bean Validation 1.1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于几个Java框架的最低支持版本有很多变化。下面的列表包含了一些重要框架的最低支持版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hibernate 5&lt;/li&gt;
&lt;li&gt;Jackson 2.6&lt;/li&gt;
&lt;li&gt;EhCache 2.10&lt;/li&gt;
&lt;li&gt;JUnit 5&lt;/li&gt;
&lt;li&gt;Tiles 3&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面列表显示了受支持的服务器对应的版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tomcat 8.5+&lt;/li&gt;
&lt;li&gt;Jetty 9.4+&lt;/li&gt;
&lt;li&gt;WildFly 10+&lt;/li&gt;
&lt;li&gt;Netty 4.1+ (for web reactive programming with Spring Web Flux)&lt;/li&gt;
&lt;li&gt;Undertow 1.4+ (for web reactive programming with Spring Web Flux)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用早期版本的任何前述规范/框架的应用程序需要在使用Spring Framework 5.0之前至少升级到上边列出的版本。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;JDK 9预计将于2017年年中发布。Spring Framework 5.0期望与JDK 9运行时保持兼容性。&lt;/p&gt;
&lt;blockquote readability=&quot;5.3739130434783&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;关于Java 9的发布时间，定在9月末，关于更多关于Java 9 的知识，可以访问：&lt;a href=&quot;http://www.cnblogs.com/IcanFixIt/p/7278696.html&quot;&gt;Java 9揭秘&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;Spring Framework 4.x的基准版本是Java SE 6。这意味着它支持Java 6，7和8。必须支持Java SE 6和7对Spring Framework代码的约束。 框架代码不能使用Java 8中的任何新功能。所以，当世界其他地方升级到Java 8时，Spring Framework中的代码（至少主要部分）仅限于使用早期版本的Java。&lt;/p&gt;
&lt;p&gt;使用Spring Framework 5.0，基准版本是Java 8。Spring Framework代码现在已升级为使用Java 8中的新特性。会改进更可读和更有效的框架代码。 使用的一些Java 8特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核心Spring接口中的Java 8 static 方法&lt;/li&gt;
&lt;li&gt;基于Java 8反射增强的内部代码改进&lt;/li&gt;
&lt;li&gt;在框架代码中使用函数式编程——lambdas表达式和stream流&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;响应式编程是Spring Framework 5.0最重要的功能之一。&lt;/p&gt;
&lt;p&gt;微服务通常基于事件通信的架构构建。 应用程序被设计为对事件（或消息）做出反应。&lt;/p&gt;
&lt;p&gt;响应式编程提供了一种可选的编程风格，专注于构建应对事件的应用程序。&lt;/p&gt;
&lt;p&gt;虽然Java 8没有内置的响应式性编程支持，但是有一些框架提供了对响应式编程的支持：&lt;/p&gt;
&lt;p&gt;Reactive Streams：尝试定义与语言无关的响应性API。&lt;br/&gt;Reactor：Spring Pivotal团队提供的响应式编程的Java实现。&lt;br/&gt;Spring WebFlux：启用基于响应式编程的Web应用程序的开发。 提供类似于Spring MVC的编程模型。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;除了响应式特性之外，Spring 5还提供了一个函数式Web框架。&lt;/p&gt;
&lt;p&gt;函数式Web框架提供了使用函数式编程风格来定义endpoints的功能。 这里显示一个简单的hello world示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; RouterFunction&amp;lt;String&amp;gt; route =
    route(GET(&quot;/hello-world&quot;),
    request -&amp;gt; Response.ok().body(fromObject(&quot;Hello World&quot;)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数式Web框架也可用于定义更复杂的路由（routes），如以下示例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; RouterFunction&amp;lt;?&amp;gt; route = route(GET(&quot;/todos/{id}&quot;),
    request -&amp;gt; {
       Mono&amp;lt;Todo&amp;gt; todo = Mono.justOrEmpty(request.pathVariable(&quot;id&quot;))
       .map(Integer::valueOf)
       .then(repository::getTodo);
       return Response.ok().body(fromPublisher(todo, Todo.class));
      })
     .and(route(GET(&quot;/todos&quot;),
     request -&amp;gt; {
       Flux&amp;lt;Todo&amp;gt; people = repository.allTodos();
       return Response.ok().body(fromPublisher(people, Todo.class));
     }))
    .and(route(POST(&quot;/todos&quot;),
    request -&amp;gt; {
      Mono&amp;lt;Todo&amp;gt; todo = request.body(toMono(Todo.class));
      return Response.ok().build(repository.saveTodo(todo));
    }));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的几件重要事项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RouterFunction&lt;/code&gt;评估匹配条件，以将请求路由到适当的处理程序函数。&lt;/li&gt;
&lt;li&gt;定义了三个endpoints，两个GET请求，一个POST请求，并将它们映射到不同的处理函数。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;在Java 8之前，Java平台不是模块化的。因此存在一些重要的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Platform Bloa&lt;/strong&gt; Java模块化在过去的几十年中并没有引起人们的关注。然而，通过物联网(IOT-Internet of Things)和新的轻量级平台，如 Node.js迫切需要解决Java平台的膨胀问题。(最初版本的JDK的大小小于10 MB。最近的JDK版本需要超过200 MB。)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JAR Hell&lt;/strong&gt; 当ClassLoader找到一个类时，它不会看到是否有其他可用类的定义。 它立即加载找到的第一个类。 如果应用程序的两个不同部分需要来自不同jar包的同一个类，那么它们就无法指定要加载类的jar包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Open System Gateway initiative(OSGi)是在1999年开始的一项计划，它将模块化引入到Java应用程序中。&lt;/p&gt;
&lt;p&gt;每个模块（module ）定义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;import&lt;/strong&gt; 模块使用的其他包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;export&lt;/strong&gt; 模块导出的包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个模块都可以有自己的生命周期。 它可以自行安装，启动和停止。&lt;/p&gt;
&lt;p&gt;Jigsaw项目是Java Community Process（JCP）下的一个倡议，从Java 7开始，将模块化纳入Java。 它有两个主要目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义和实现JDK的模块化结构&lt;/li&gt;
&lt;li&gt;为Java平台上构建的应用程序定义模块系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Jigsaw将成为Java 9的一部分，Spring Framework 5.0将包含对Jigsaw模块的基本支持。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Kotlin是一种静态类型的JVM语言，可以实现具有更好的表达性，简洁性和可读性的代码。 Spring框架5.0对Kotlin有很好的支持。&lt;/p&gt;
&lt;p&gt;考虑一个简单的Kotlin程序，说明一个&lt;code&gt;data&lt;/code&gt;类，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.*
    data class Todo(var description: String, var name: String, var  
    targetDate : Date)
    fun main(args: Array&amp;lt;String&amp;gt;) {
      var todo = Todo(&quot;Learn Spring Boot&quot;, &quot;Jack&quot;, Date())
      println(todo)
        //Todo(description=Learn Spring Boot, name=Jack, 
        //targetDate=Mon May 22 04:26:22 UTC 2017)
      var todo2 = todo.copy(name = &quot;Jill&quot;)
      println(todo2)
         //Todo(description=Learn Spring Boot, name=Jill, 
         //targetDate=Mon May 22 04:26:22 UTC 2017)
      var todo3 = todo.copy()
      println(todo3.equals(todo)) //true
    }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在不到10行代码中，我们创建并测试了一个具有三个属性和以下方法的数据bean：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;equals()&lt;/li&gt;
&lt;li&gt;hashCode()&lt;/li&gt;
&lt;li&gt;toString()&lt;/li&gt;
&lt;li&gt;copy()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kotlin是强类型的。 但是不需要明确指定每个变量的类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  val arrayList = arrayListOf(&quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot;) 
    // Type is ArrayList&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命名参数允许你在调用方法时指定参数的名称，从而保持更可读的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var todo = Todo(description = &quot;Learn Spring Boot&quot;, 
    name = &quot;Jack&quot;, targetDate = Date())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Kotlin通过提供默认变量（&lt;code&gt;it&lt;/code&gt;）和诸如&lt;code&gt;take&lt;/code&gt;，&lt;code&gt;drop&lt;/code&gt;等方法使函数式编程更简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; var first3TodosOfJack = students.filter { it.name == &quot;Jack&quot;   
     }.take(3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以为Kotlin中的参数指定默认值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  import java.util.*
    data class Todo(var description: String, var name: String, var
    targetDate : Date = Date())
    fun main(args: Array&amp;lt;String&amp;gt;) {
      var todo = Todo(description = &quot;Learn Spring Boot&quot;, name = &quot;Jack&quot;)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于它的所有特性使代码简洁而富有表现力，我们希望Kotlin能够成为一门语言。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Spring Framework 5是一个主要的Spring版本，基准大幅度增加。 随着Java，Java EE和其他几个框架的基准版本的增加，Spring Framework 5删除了对几个框架的支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Portlet&lt;/li&gt;
&lt;li&gt;Velocity&lt;/li&gt;
&lt;li&gt;JasperReports&lt;/li&gt;
&lt;li&gt;XMLBeans&lt;/li&gt;
&lt;li&gt;JDO&lt;/li&gt;
&lt;li&gt;Guava&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你正在使用上面任何框架，建议计划迁移并使用Spring Framework 4.3——该框架一直支持到2019年。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Sep 2017 16:41:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7616578.html</dc:identifier>
</item>
<item>
<title>《Go in action》读后记录：Go的并发与并行 - melonstreet</title>
<link>http://www.cnblogs.com/QG-whz/p/7616547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QG-whz/p/7616547.html</guid>
<description>&lt;p&gt;本文的主要内容是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;了解goroutine，使用它来运行程序&lt;/li&gt;
&lt;li&gt;了解Go是如何检测并修正竞争状态的（解决资源互斥访问的方式）&lt;/li&gt;
&lt;li&gt;了解并使用通道chan来同步goroutine&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3 id=&quot;go的并发与并行&quot;&gt;1.Go的并发与并行&lt;/h3&gt;
&lt;p&gt;Go的并发能力，是指让某个函数独立于其他函数运行的能力。当为一个函数创建&lt;code&gt;goroutine&lt;/code&gt;时，该函数将作为一个独立的工作单元，被 调度器 调度到可用的逻辑处理器上执行。Go的运行时调度器是个复杂的软件，它做的工作大致是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;管理被创建的所有goroutine，为其分配执行时间&lt;/li&gt;
&lt;li&gt;将操作系统线程与语言运行时的逻辑处理器绑定&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考&lt;a href=&quot;http://morsmachine.dk/go-scheduler&quot;&gt;The Go scheduler&lt;/a&gt; ，这里较浅显地说一下Go的运行时调度器。操作系统会在物理处理器上调度&lt;code&gt;操作系统线程&lt;/code&gt;来运行，而Go语言的运行时会在&lt;code&gt;逻辑处理器&lt;/code&gt;上调度&lt;code&gt;goroutine&lt;/code&gt;来运行，每个逻辑处理器都分别绑定到单个操作系统线程上。这里涉及到三个角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;M：操作系统线程，这是真正的内核OS线程&lt;/li&gt;
&lt;li&gt;P：逻辑处理器，代表着调度的上下文，它使goroutine在一个M上跑&lt;/li&gt;
&lt;li&gt;G：goroutine，拥有自己的栈，指令指针等信息，被P调度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/610439/201710/610439-20171001000809340-997866611.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个P会维护一个全局运行队列（称为runqueue），处于ready就绪状态的&lt;code&gt;goroutine&lt;/code&gt;（灰色G）被放在这个队列中等待被调度。在编写程序时，每当&lt;code&gt;go func&lt;/code&gt;启动一个&lt;code&gt;goroutine&lt;/code&gt;时，&lt;code&gt;runqueue&lt;/code&gt;便在尾部加入一个&lt;code&gt;goroutine&lt;/code&gt;。在下一个调度点上，P就从&lt;code&gt;runqueue&lt;/code&gt;中取出一个&lt;code&gt;goroutine&lt;/code&gt;出来执行（蓝色G）。&lt;/p&gt;
&lt;p&gt;当某个操作系统线程M阻塞的时候（比如&lt;code&gt;goroutine&lt;/code&gt;执行了阻塞的系统调用)，P可以绑定到另外一个操作系统线程M上，让运行队列中的其他&lt;code&gt;goroutine&lt;/code&gt;继续执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/610439/201710/610439-20171001000820794-99295651.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中G0执行了阻塞操作，M0被阻塞，P将在新的系统线程M1上继续调度G执行。M1有可能是被新创建的，或者是从线程缓存中取出。Go调度器保证有足够的线程来运行所有的P，语言运行时默认限制每个程序最多创建10000个线程，这个现在可以通过调用runtime/debug包的&lt;code&gt;SetMaxThreads&lt;/code&gt;方法来更改。&lt;/p&gt;
&lt;p&gt;Go可以在在一个逻辑处理器P上实现并发，如果需要并行，必须使用多于1个的逻辑处理器。Go调度器会把&lt;code&gt;goroutine&lt;/code&gt;平等分配到每个逻辑处理器上，此时&lt;code&gt;goroutine&lt;/code&gt;将在不同的线程上运行，不过前提是要求机器拥有多个物理处理器。&lt;/p&gt;
&lt;h3 id=&quot;创建goroutine&quot;&gt;2.创建goroutine&lt;/h3&gt;
&lt;p&gt;使用关键字&lt;code&gt;go&lt;/code&gt;来创建一个&lt;code&gt;goroutine&lt;/code&gt;，并让所有的&lt;code&gt;goroutine&lt;/code&gt;都得到执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example1.go
package main

import (
   &quot;runtime&quot;
   &quot;sync&quot;
   &quot;fmt&quot;
)

var (
   wg sync.WaitGroup
)

func main() {
   //分配一个逻辑处理器Ｐ给调度器使用
   runtime.GOMAXPROCS(1)
   //在这里,wg用于等待程序完成，计数器加2，表示要等待两个goroutine
   wg.Add(2)
   //声明1个匿名函数，并创建一个goroutine
   fmt.Printf(&quot;Begin Coroutines\n&quot;)
   go func() {
      //在函数退出时，wg计数器减1
      defer wg.Done()
      //打印3次小写字母表
      for count := 0; count &amp;lt; 3; count++ {
         for char := 'a'; char &amp;lt; 'a'+26; char++ {
            fmt.Printf(&quot;%c &quot;, char)
         }
      }
   }()
   //声明1个匿名函数，并创建一个goroutine
   go func() {
      defer wg.Done()
      //打印大写字母表3次
      for count := 0; count &amp;lt; 3; count++ {
         for char := 'A'; char &amp;lt; 'A'+26; char++ {
            fmt.Printf(&quot;%c &quot;, char)
         }
      }
   }()

   fmt.Printf(&quot;Waiting To Finish\n&quot;)
   //等待2个goroutine执行完毕
   wg.Wait()

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序使用&lt;code&gt;runtime.GOMAXPROCS(1)&lt;/code&gt;来分配一个逻辑处理器给调度器使用，两个&lt;code&gt;goroutine&lt;/code&gt;将被该逻辑处理器调度并发执行。程序输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Begin Coroutines
Waiting To Finish
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出来看，是先执行完一个&lt;code&gt;goroutine&lt;/code&gt;，再接着执行第二个&lt;code&gt;goroutine&lt;/code&gt;的，大写字母全部打印完后，再打印全部的小写字母。那么，&lt;strong&gt;有没有办法让两个&lt;code&gt;goroutine&lt;/code&gt;并行执行呢？&lt;/strong&gt;为程序指定两个逻辑处理器即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//修改为2个逻辑处理器
runtime.GOMAXPROCS(2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时执行程序，输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Begin Coroutines
Waiting To Finish
A B C D E a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c F G H I J K L M N O P Q R S T U V W X d e f g h i j k l m n o p q r s Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那如果只有1个逻辑处理器，如何让两个goroutine交替被调度？&lt;/strong&gt;实际上，如果&lt;code&gt;goroutine&lt;/code&gt;需要很长的时间才能运行完，调度器的内部算法会将当前运行的&lt;code&gt;goroutine&lt;/code&gt;让出，防止某个&lt;code&gt;goroutine&lt;/code&gt;长时间占用逻辑处理器。由于示例程序中两个&lt;code&gt;goroutine&lt;/code&gt;的执行时间都很短，在为引起调度器调度之前已经执行完。不过，程序也可以使用&lt;code&gt;runtime.Gosched()&lt;/code&gt;来将当前在逻辑处理器上运行的&lt;code&gt;goruntine&lt;/code&gt;让出，让另一个&lt;code&gt;goruntine&lt;/code&gt;得到执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example2.go
package main

import (
   &quot;runtime&quot;
   &quot;sync&quot;
   &quot;fmt&quot;
)

var (
   wg sync.WaitGroup
)

func main() {
   //分配一个逻辑处理器Ｐ给调度器使用
   runtime.GOMAXPROCS(1)
   //在这里,wg用于等待程序完成，计数器加2，表示要等待两个goroutine
   wg.Add(2)
   //声明1个匿名函数，并创建一个goroutine
   fmt.Printf(&quot;Begin Coroutines\n&quot;)
   go func() {
      //在函数退出时，wg计数器减1
      defer wg.Done()
      //打印3次小写字母表
      for count := 0; count &amp;lt; 3; count++ {
         for char := 'a'; char &amp;lt; 'a'+26; char++ {
            if char=='k'{
               runtime.Gosched()
            }
            fmt.Printf(&quot;%c &quot;, char)
         }
      }
   }()
   //声明1个匿名函数，并创建一个goroutine
   go func() {
      defer wg.Done()
      //打印大写字母表3次
      for count := 0; count &amp;lt; 3; count++ {
         for char := 'A'; char &amp;lt; 'A'+26; char++ {
            if char == 'K'{
               runtime.Gosched()
            }
            fmt.Printf(&quot;%c &quot;, char)
         }
      }
   }()

   fmt.Printf(&quot;Waiting To Finish\n&quot;)
   //等待2个goroutine执行完毕
   wg.Wait()

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个&lt;code&gt;goroutine&lt;/code&gt;在循环的字符为k/K的时候会让出逻辑处理器，程序的输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Begin Coroutines
Waiting To Finish
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J a b c d e f g h i j K L M N O P Q R S T U V W X Y Z A B C D E F G H I J k l m n o p q r s t u v w x y z a b c d e f g h i j K L M N O P Q R S T U V W X Y Z k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里大小写字母果然是交替着输出了。不过从输出可以看到，第一次输出大写字母时遇到K没有让出逻辑处理器，这是什么原因还不是很清楚，调度器的调度机制？&lt;/p&gt;

&lt;p&gt;并发程序避免不了的一个问题是对资源的同步访问。如果多个&lt;code&gt;goroutine&lt;/code&gt;在没有互相同步的情况下去访问同一个资源，并进行读写操作，这时&lt;code&gt;goroutine&lt;/code&gt;就处于竞争状态下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example3.go
package main

import (
   &quot;sync&quot;
   &quot;runtime&quot;
   &quot;fmt&quot;
)

var (
   //counter为访问的资源
   counter int64
   wg      sync.WaitGroup
)

func addCount() {
   defer wg.Done()
   for count := 0; count &amp;lt; 2; count++ {
      value := counter
      //当前goroutine从线程退出
      runtime.Gosched()
      value++
      counter=value
   }
}

func main() {
   wg.Add(2)
   go addCount()
   go addCount()
   wg.Wait()
   fmt.Printf(&quot;counter: %d\n&quot;,counter)
}
//output:
counter: 4 或者counter: 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序中，&lt;code&gt;goroutine&lt;/code&gt;对&lt;code&gt;counter&lt;/code&gt;的读写操作没有进行同步，goroutine 1对counter的写结果可能被goroutine 2所覆盖。Go可通过如下方式来解决这个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用原子函数操作&lt;/li&gt;
&lt;li&gt;使用互斥锁锁住临界区&lt;/li&gt;
&lt;li&gt;使用通道&lt;code&gt;chan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;检测竞争状态&quot;&gt;1. 检测竞争状态&lt;/h3&gt;
&lt;p&gt;有时候竞争状态并不能一眼就看出来。Go 提供了一个非常有用的工具，用于检测竞争状态。使用方式是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;go build -race example4.go//用竞争检测器标志来编译程序&lt;br/&gt;./example4 //运行程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/610439/201710/610439-20171001001148575-245359976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工具检测出了程序存在一处竞争状态，并指出发生竞争状态的几行代码是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;22        counter=value
18        value := counter
28        go addCount()
29        go addCount()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用原子函数&quot;&gt;2. 使用原子函数&lt;/h3&gt;
&lt;p&gt;对整形变量或指针的同步访问，可以使用原子函数来进行。这里使用原子函数来修复example4.go中的竞争状态问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example5.go
package main

import (
    &quot;sync&quot;
    &quot;runtime&quot;
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
)

var (
    //counter为访问的资源
    counter int64
    wg      sync.WaitGroup
)

func addCount() {
    defer wg.Done()
    for count := 0; count &amp;lt; 2; count++ {
        //使用原子操作来进行
        atomic.AddInt64(&amp;amp;counter,1)
        //当前goroutine从线程退出
        runtime.Gosched()
    }
}

func main() {
    wg.Add(2)
    go addCount()
    go addCount()
    wg.Wait()
    fmt.Printf(&quot;counter: %d\n&quot;,counter)
}
//output：
counter: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用&lt;code&gt;atomic.AddInt64&lt;/code&gt;函数来对一个整形数据进行加操作，另外一些有用的原子操作还有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;atomic.StoreInt64() //写
atomic.LoadInt64()  //读&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多的原子操作函数请看&lt;code&gt;atomic&lt;/code&gt;包中的声明。&lt;/p&gt;
&lt;h3 id=&quot;使用互斥锁&quot;&gt;3. 使用互斥锁&lt;/h3&gt;
&lt;p&gt;对临界区的访问，可以使用互斥锁来进行。对于example4.go的竞争状态，可以使用互斥锁来解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example5.go
package main

import (
   &quot;sync&quot;
   &quot;runtime&quot;
   &quot;fmt&quot;
)

var (
   //counter为访问的资源
   counter int
   wg      sync.WaitGroup
   mutex   sync.Mutex
)

func addCount() {
   defer wg.Done()

   for count := 0; count &amp;lt; 2; count++ {
      //加上锁，进入临界区域
      mutex.Lock()
      {
         value := counter
         //当前goroutine从线程退出
         runtime.Gosched()
         value++
         counter = value
      }
      //离开临界区，释放互斥锁
      mutex.Unlock()
   }
}
func main() {
   wg.Add(2)
   go addCount()
   go addCount()
   wg.Wait()
   fmt.Printf(&quot;counter: %d\n&quot;, counter)
}

//output:
counter: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;Lock()&lt;/code&gt;与&lt;code&gt;Unlock()&lt;/code&gt;函数调用来定义临界区，在同一个时刻内，只有一个goroutine能够进入临界区，直到调用&lt;code&gt;Unlock()&lt;/code&gt;函数后，其他的goroutine才能够进入临界区。&lt;/p&gt;
&lt;p&gt;在Go中解决共享资源安全访问，更常用的使用通道chan。&lt;/p&gt;

&lt;p&gt;Go语言采用CSP消息传递模型。通过在&lt;code&gt;goroutine&lt;/code&gt;之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。这里就需要用到通道&lt;code&gt;chan&lt;/code&gt;这种特殊的数据类型。当一个资源需要在&lt;code&gt;goroutine&lt;/code&gt;中共享时，chan在&lt;code&gt;goroutine&lt;/code&gt;中间架起了一个通道。通道使用&lt;code&gt;make&lt;/code&gt;来创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unbuffered := make(char int) //创建无缓存通道，用于int类型数据共享
buffered := make(chan string,10)//创建有缓存通道，用于string类型数据共享
buffered&amp;lt;- &quot;hello world&quot; //向通道中写入数据
value:= &amp;lt;-buffered //从通道buffered中接受数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通道用于放置某一种类型的数据。创建通道时指定通道的大小，将创建有缓存的通道。无缓存通道是一种同步通信机制，它要求发送&lt;code&gt;goroutine&lt;/code&gt;和接收&lt;code&gt;goroutine&lt;/code&gt;都应该准备好，否则会进入阻塞。&lt;/p&gt;
&lt;h3 id=&quot;无缓存的通道&quot;&gt;1. 无缓存的通道&lt;/h3&gt;
&lt;p&gt;无缓存通道是同步的——一个&lt;code&gt;goroutine&lt;/code&gt;向channel写入消息的操作会一直阻塞，直到另一个&lt;code&gt;goroutine&lt;/code&gt;从通道中读取消息。反过来也是，一个&lt;code&gt;goroutine&lt;/code&gt;从channel读取消息的操作会一直阻塞，直到另一个&lt;code&gt;goroutine&lt;/code&gt;向通道中写入消息。《Go in action》中关于无缓存通道的解释有一个非常棒的例子：网球比赛。在网球比赛中，两位选手总是处在以下两种状态之一：要么在等待接球，要么在把球打向对方。球的传递可看为通道中数据传递。下面这段代码使用通道模拟了这个过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//example6.go
package main

import (
    &quot;sync&quot;
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

var wg sync.WaitGroup

func player(name string, court chan int) {
    defer wg.Done()
    for {
        //如果通道关闭,那么选手胜利
        ball, ok := &amp;lt;-court
        if !ok {
            fmt.Printf(&quot;Player %s Won\n&quot;, name)
            return
        }
        n := rand.Intn(100)

        //随机概率使某个选手Miss
        if n%13 == 0 {
            fmt.Printf(&quot;Player %s Missed\n&quot;, name)
            //关闭通道
            close(court)
            return
        }
        fmt.Printf(&quot;Player %s Hit %d\n&quot;, name, ball)
        ball++
        //否则选手进行击球
        court &amp;lt;- ball
    }
}


func main() {
    rand.Seed(time.Now().Unix())
    court := make(chan int)
    //等待两个goroutine都执行完
    wg.Add(2)
    //选手1等待接球
    go player(&quot;candy&quot;, court)
    //选手2等待接球
    go player(&quot;luffic&quot;, court)
    //球进入球场（可以开始比赛了）
    court &amp;lt;- 1
    wg.Wait()
}
//output:
Player luffic Hit 1
Player candy Hit 2
Player luffic Hit 3
Player candy Hit 4
Player luffic Hit 5
Player candy Missed
Player luffic Won&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;有缓存的通道&quot;&gt;2. 有缓存的通道&lt;/h3&gt;
&lt;p&gt;有缓存的通道是一种在被接收前能存储一个或者多个值的通道，它与无缓存通道的区别在于：无缓存的通道保证进行发送和接收的goroutine会在同一时间进行数据交换，有缓存的通道没有这种保证。有缓存通道让&lt;code&gt;goroutine&lt;/code&gt;阻塞的条件为：通道中没有数据可读的时候，接收动作会被阻塞；通道中没有区域容纳更多数据时，发送动作阻塞。向已经关闭的通道中发送数据，会引发panic，但是&lt;code&gt;goroutine&lt;/code&gt;依旧能从通道中接收数据，但是不能再向通道里发送数据。所以，发送端应该负责把通道关闭，而不是由接收端来关闭通道。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;goroutine被逻辑处理器执行，逻辑处理器拥有独立的系统线程与运行队列&lt;/li&gt;
&lt;li&gt;多个goroutine在一个逻辑处理器上可以并发执行，当机器有多个物理核心时，可通过多个逻辑处理器来并行执行。&lt;/li&gt;
&lt;li&gt;使用关键字 go 来创建goroutine。&lt;/li&gt;
&lt;li&gt;在Go中，竞争状态出现在多个goroutine试图同时去访问一个资源时。&lt;/li&gt;
&lt;li&gt;可以使用互斥锁或者原子函数，去防止竞争状态的出现。&lt;/li&gt;
&lt;li&gt;在go中，更好的解决竞争状态的方法是使用通道来共享数据。&lt;/li&gt;
&lt;li&gt;无缓冲通道是同步的，而有缓冲通道不是。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（完）&lt;/p&gt;
</description>
<pubDate>Sat, 30 Sep 2017 16:14:00 +0000</pubDate>
<dc:creator>melonstreet</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QG-whz/p/7616547.html</dc:identifier>
</item>
<item>
<title>再起航，我的学习笔记之JavaScript设计模式27(链模式) - 东城慕水</title>
<link>http://www.cnblogs.com/chen-jie/p/JavaScript-Operatc-Of-Responsibility.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-jie/p/JavaScript-Operatc-Of-Responsibility.html</guid>
<description>&lt;h2 id=&quot;链模式&quot;&gt;链模式&lt;/h2&gt;
&lt;h3 id=&quot;概念介绍&quot;&gt;概念介绍&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;链模式(Operatc of Responsibility):&lt;/strong&gt;&lt;br/&gt;通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;原型式继承&lt;/h3&gt;
&lt;p&gt;链模式顾名思义就是像链子一样一个接一个的，我们可以通过点语法在一个方法的后面接着调用另一个方法，那么这种模式是怎么做到的呢？一般来说链模式是基于原型继承的，并且在每一个原型方法的实现上都返回当前对象this，使当前对象一直处于原型链作用域的顶端。这样我们就可以实现链式调用&lt;br/&gt;我们创建一个对象A，并且给A的原型对象上添加一个length属性，和size方法，如果我们要调用的话就要通过new来创建新对象访问&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototypee&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234102544-665816173.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到这样调用我们可以正常访问，但是下面两种方式去访问程序就会报错&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234116840-1409596718.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为size绑定在A的原型上没有绑定在其自身上。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234123231-740927407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为A函数对象执行的结果没有返回值所以找不到size方法&lt;br/&gt;上述两种方式都是因为size方法绑定在A类的原型上导致的。那么我们如果能让其访问呢？&lt;br/&gt;我们可以借助另一个对象来实现。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; B&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; B&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototypee&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来看看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(A().size());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234141450-1743894832.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取元素&quot;&gt;获取元素&lt;/h3&gt;
&lt;p&gt;我们看到现在这个A().size()的形态是不是就有链式结构的雏形了，如果这个A()能获取对象该多好，那我们接着往下面拓展功能&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototypee&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(selector)
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234204294-936648267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经能获取到元素了，但是如果想一级一级的去调用，我们还要让A对象返回的结果能拥有A.fn中的方法，这个时候我们就可以通过返回this来达到我们的目的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//作为当前对象的属性值保存&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//校正length属性&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//返回当前对象&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来测试一下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; demo&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(demo)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234822715-1044478299.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想把结果像数组那样访问，我们可以将他们的属性值顺序地设置为数字索引。为了更像数组我们还校正了它的length属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但我们这样做有个弊端，就是后面获取的对象会把我们前面的对象覆盖掉&lt;br/&gt;var test=A('container');&lt;br/&gt;console.log(demo);&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201710/774226-20171001000105825-1355462989.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现这种情况的原因是因为每次在A的构造函数中返回的A.fn.init(selector)对象都指向同一个对象造成的，我们直接使用new来创建即可&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;))
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'container'&lt;/span&gt;))
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们发现虽然我们解决了元素覆盖的问题，但是我们那种链式的写法好像也失效了，为什么会出现这种情况呢？&lt;br/&gt;这是因为A.fn.init(selector)与new A.fn.init(selector)的实现的差别造成的，牵着返回的this指向当前的对象，而后者用new对对象内的属性进行了复制，所以this指向的就不当前对象了，我们来测试说明一下。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;init&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototypee&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234343231-148071000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A.fn.init(selector)返回结果如下&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234353262-16690128.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;new A.fn.init(selector)返回结果如下&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234402247-327124967.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们如何去解决这个问题呢，其实只用将构造函数的原型指向一个已存在的对象即可&lt;br/&gt;A.fn.init.prototype=A.fn;&lt;/p&gt;
&lt;p&gt;我们再试试&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; A&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;init&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(selector)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;init&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234411950-763023973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了现在我们可以接着像之前那样调用了&lt;/p&gt;
&lt;h3 id=&quot;方法拓展&quot;&gt;方法拓展&lt;/h3&gt;
&lt;p&gt;那么现在我们也能获取到对象了也能调用方法了，那我们怎么通过点语法链式使用呢，我们又要如何添加呢？&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//对象拓展&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//拓展对象从第二个参数算起&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//获取参数长度&lt;/span&gt;
    len&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arguments&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//第一个参数为源对象&lt;/span&gt;
    target&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arguments[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//拓展对象中属性&lt;/span&gt;
    j&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//如果只穿一个参数&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(i&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;len)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//源对象为当前对象&lt;/span&gt;
        target&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//i从0计数&lt;/span&gt;
        i&lt;span class=&quot;op&quot;&gt;--;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//遍历参数中拓展对象&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;len&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//遍历拓展对象中的属性&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(j &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arguments[i])&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//拓展源对象&lt;/span&gt;
        target[j]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arguments[i][j]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//返回源对象&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; target&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来调用试试&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; demo&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;},{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;third&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(demo)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'1.0'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;version&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;getVersion&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}}&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;getVersion&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(A&lt;span class=&quot;op&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'李四'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;names&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201709/774226-20170930234609528-1598883849.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现链式调用&quot;&gt;实现链式调用&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//分割带“-”样式，变为驼峰式写法&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;camelCase&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(str)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;str&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\-(\w)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/g&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(all&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;letter)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;letter&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toUpperCase&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//设置css样式&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arg&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arguments&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        len&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arg&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//只有一个参数时&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(len&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//如果为字符串则为获取一个元素CSS样式&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'string'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//IE&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;currentStyle&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;currentStyle&lt;/span&gt;[name]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getComputedStyle&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)[name]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//为对象时则设置多个样式&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//遍历每个样式&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;co&quot;&gt;//分割-为驼峰式写法&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[j].&lt;span class=&quot;at&quot;&gt;style&lt;/span&gt;[&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;camelCase&lt;/span&gt;(i)]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//两个参数则设置一个样式&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(len&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[j].&lt;span class=&quot;at&quot;&gt;style&lt;/span&gt;[&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;camelCase&lt;/span&gt;(arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arg[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//设置属性&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arg&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arguments&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        len&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arg&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//如果一个参数&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (len&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//为字符串获取第一个元素属性&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'string'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;getAttribute&lt;/span&gt;(arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//为对象设置每个元素的多个属性&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//遍历属性&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[j].&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(i&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//两个参数则设置每个元素单个属性&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(len&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; j&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;j&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[j].&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;arg[i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//获取或设置元素的内容&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arg&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arguments&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        len&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;arg&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//如果没参数则取第一个元素的内容&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (len&lt;span class=&quot;op&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;innerHTML&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//一个参数则设置每个元素的内容&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[i].&lt;span class=&quot;at&quot;&gt;innerHTML&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;arg[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;A&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;fn&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//添加时间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//如果支持DOM2级事件&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fn)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[i].&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fn&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//IE浏览器DOM2级事件&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;attachEvent&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fn)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[i].&lt;span class=&quot;at&quot;&gt;addEvent&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'on'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//不支持DOM2级浏览器添加事件&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(type&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;fn)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;[i][&lt;span class=&quot;st&quot;&gt;'on'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;type]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;fn&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看一下效果&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;A&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;css&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'30px'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;borer&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'1px solid #000'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'background-color'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'red'&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
.&lt;span class=&quot;at&quot;&gt;attr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'class'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'demo'&lt;/span&gt;)
.&lt;span class=&quot;at&quot;&gt;html&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'添加文字'&lt;/span&gt;)
.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'click'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'触发点击事件'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/774226/201710/774226-20171001000302434-1429292443.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;JavaScript中的链模式的核心思想就是通过在对象中的每个方法调用执行完毕后返回当前对象this来实现，由于链模式使得代码紧凑简洁而高效，目前的主流代码库都已该模式作为一种风格，比如我们最熟悉的jQuery。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也谢谢大家看到这里：）如果你觉得我的分享还可以请点击推荐，分享给你的朋友让我们一起进步~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了以上就是本次分享的全部内容，本次示例参考自JavaScript设计模式一书，让我们一点点积累一点点成长，希望对大家有所帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明作者，原文出处。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Sep 2017 16:04:00 +0000</pubDate>
<dc:creator>东城慕水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-jie/p/JavaScript-Operatc-Of-Responsibility.html</dc:identifier>
</item>
<item>
<title>TCP/IP（七）之玩转HTTP协议 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7614800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7614800.html</guid>
<description>&lt;p&gt;　　前面一篇的博文简单的介绍了一下属于应用层的HTTP协议，这一篇我将详细的学习HTTP协议，这也是做Web开发中一定要用到的协议。虽然我是做大数据的，但是多学习一点肯定是&lt;/p&gt;&lt;p&gt;　　没有坏处的。国庆放假7天，很多人都是想着怎么玩，我也很想出去玩，但是没有办法，努力才能有出路，加油！&lt;/p&gt;&lt;p&gt;　　1）协议：&lt;span&gt;计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则&lt;/span&gt;，超文本传输协议(HTTP)是一种&lt;span&gt;通信协议&lt;/span&gt;，它允许&lt;span&gt;将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　2）HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　3）HTTP是一个基于&lt;span&gt;TCP/IP通信协议来传递数据&lt;/span&gt;（HTML 文件, 图片文件, 查询结果等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　4）&lt;/span&gt;HTTP是一个&lt;span&gt;属于应用层的面向对象的协议&lt;/span&gt;，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。&lt;/p&gt;&lt;p&gt;　　　　目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。&lt;/p&gt;&lt;p&gt;　　5）HTTP协议工作于&lt;span&gt;客户端-服务端架构为上&lt;/span&gt;。&lt;span&gt;浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息&lt;/span&gt;。&lt;/p&gt;&lt;div readability=&quot;321&quot;&gt;
&lt;p&gt;　　1）简单快速：客户向服务器请求服务时，&lt;span&gt;只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST&lt;/span&gt;。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。&lt;/p&gt;
&lt;p&gt;　　2）灵活：&lt;span&gt;HTTP允许传输任意类型的数据对象&lt;/span&gt;。正在传输的类型由Content-Type加以标记。&lt;/p&gt;
&lt;p&gt;　　3）无连接：无连接的含义是&lt;span&gt;限制每次连接只处理一个请求&lt;/span&gt;。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/p&gt;
&lt;p&gt;　　4）无状态：HTTP协议是&lt;span&gt;无状态协议&lt;/span&gt;。&lt;span&gt;无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　另一方面，在服务器不需要先前信息时它的应答就较快。&lt;br/&gt;　　5）支持B/S及C/S模式。　&lt;/p&gt;

&lt;h2&gt;2.1、URL&lt;/h2&gt;
&lt;p&gt;　　其实前面已经简单的知道了什么是URL。&lt;/p&gt;
&lt;p&gt;　　HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）描述一个网络上的资源，来&lt;span&gt;传输数据和建立连接&lt;/span&gt;。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。&lt;/p&gt;
&lt;p&gt;　　URL,全称是UniformResourceLocator, 中文叫&lt;span&gt;统一资源定位符&lt;/span&gt;,是互联网上用来标识某一处资源的地址，它的组成部分是：&lt;/p&gt;
&lt;p&gt;　　　　http://www.zyh.com:8080/woss/index.html?username=10086&amp;amp;password=123456#name　&lt;/p&gt;
&lt;p&gt;　　从上面的URL可以看出，一个完整的URL包括以下几部分：&lt;br/&gt;　　　　1）协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在&quot;HTTP&quot;后面的“//”为分隔符&lt;/p&gt;
&lt;p&gt;　　　　2）域名部分：该URL的域名部分为“www.zyh.com”。一个URL中，也可以使用IP地址作为域名使用&lt;/p&gt;
&lt;p&gt;　　　　3）端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（80）&lt;/p&gt;
&lt;p&gt;　　　　4）虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/woss/”&lt;/p&gt;
&lt;p&gt;　　　　5）文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　都是文件名部分。本例中的文件名是“index.html”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名&lt;/p&gt;
&lt;p&gt;　　　　6）锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分&lt;/p&gt;
&lt;p&gt;　　　　7）参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=10086&amp;amp;password=123456”。参数可以允许有多个参数，参数与参数之间用“&amp;amp;”作为分隔符。&lt;/p&gt;
&lt;h2&gt;2.2、URI和URI的区别&lt;/h2&gt;
&lt;p&gt;　　1）URI，是uniform resource identifier，&lt;span&gt;统一资源标识符，用来唯一的标识一个资源&lt;/span&gt;。&lt;br/&gt;　　　　Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的&lt;br/&gt;　　　　URI一般由三部组成：&lt;br/&gt;　　　　　　访问资源的命名机制&lt;br/&gt;　　　　　　存放资源的主机名&lt;br/&gt;　　　　　　资源自身的名称，由路径表示，着重强调于资源。&lt;/p&gt;
&lt;p&gt;　　2）URL是uniform resource locator，统一资源定位器，&lt;span&gt;它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源&lt;/span&gt;。&lt;br/&gt;　　　　URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。&lt;br/&gt;　　　　采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：&lt;br/&gt;　　　　　　协议(或称为服务方式)&lt;br/&gt;　　　　　　存有该资源的主机IP地址(有时也包括端口号)&lt;br/&gt;　　　　　　主机资源的具体地址。如目录和文件名等&lt;/p&gt;

&lt;p&gt;一次HTTP操作称为一个事务，其工作过程可分为四步：&lt;br/&gt;1）首先&lt;span&gt;客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始&lt;/span&gt;。&lt;br/&gt;2）建立连接后，&lt;span&gt;客户机发送一个请求给服务器&lt;/span&gt;，请求方式的格式为：&lt;span&gt;统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容&lt;/span&gt;。&lt;br/&gt;3）服务器接到请求后，给予相应的&lt;span&gt;响应信息&lt;/span&gt;，其格式为&lt;span&gt;一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。&lt;/span&gt;&lt;br/&gt;4）客户端接收服务器所返回的信息&lt;span&gt;通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接&lt;/span&gt;。&lt;br/&gt;如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。&lt;/p&gt;
&lt;p&gt;我们用图来理解一下：　　&lt;/p&gt;
&lt;p&gt;　　当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 &lt;/p&gt;
&lt;p&gt;　　实际上我们输入URL后，我们的&lt;span&gt;浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页&lt;/span&gt;，过程如下图所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930132020294-1539783244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930132125137-685597381.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　代理服务器就是网络信息的中转站，它的功能是：&lt;/p&gt;
&lt;p&gt;　　　　 提高访问速度， 大多数的代理服务器都有缓存功能。&lt;/p&gt;
&lt;p&gt;　　　　 突破限制， 也就是FQ了&lt;/p&gt;
&lt;p&gt;　　　　隐藏身份。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;　　HTTP是基于&lt;span&gt;传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。&lt;/span&gt;所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。&lt;/p&gt;
&lt;p&gt;　　下图所示TCP连接的三次握手。&lt;br/&gt;　　在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既&lt;span&gt;HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930133829184-1642006770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.1、请求消息格式&lt;/h2&gt;
&lt;p&gt; 　　客户端发送一个HTTP请求到服务器的请求消息是有一定的格式：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930210336403-1134722875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上面可以看出来，请求消息由四部分组成：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;请求行（request line）、请求头部（header）、空行和请求数据&lt;/span&gt;四个部分组成&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930210549184-1505946240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一行中的Method&lt;span&gt;表示请求方法&lt;/span&gt;,比如&quot;POST&quot;,&quot;GET&quot;,  &lt;span&gt;Path-to-resoure表示请求的资源（url）&lt;/span&gt;， Http/version-number 表示&lt;span&gt;HTTP协议的版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当使用的是&quot;GET&quot; 方法的时候， body是为空的。&lt;/p&gt;
&lt;h2&gt;4.2、用GET请求的请求报文&lt;/h2&gt;
&lt;p&gt;　　当我们访问搜狐的官网的时候，我使用的是Firebug抓取的请求消息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930211630450-1434056493.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一部分：请求行，用来说明&lt;span&gt;请求类型,要访问的资源以及所使用的HTTP版本&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　GET　/http://www.sohu.com HTTP/1.1 请求行，只不过这里被分开了，请求的方式  URL　版本&lt;/p&gt;
&lt;p&gt;　　第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来&lt;span&gt;说明服务器要使用的附加信息&lt;/span&gt;。　&lt;/p&gt;
&lt;p&gt;　　　　1）Host：主机名 www.solu.com　　　　　　&lt;/p&gt;
&lt;p&gt;　　　　2）User-Agent：使用什么代理服务器，这里就是FireFox，也就是火狐&lt;/p&gt;
&lt;p&gt;　　　　3）Accept：能&lt;span&gt;接收的数据类型有哪些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　4）Accept-Language：表示用户希望&lt;span&gt;优先想得到的版本，一次排列下去，先是中文，再是英文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　5）Accept-Encoding：通知&lt;span&gt;服务端可以发送的数据压缩格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　6）Cookie：浏览器端的一个技术，在&lt;span&gt;服务器上记录用户信息，但是也会在浏览器中保存一份&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　7）Connection：连接的方式，有两种，&lt;span&gt;非持续连接和持续连接，非持续连接，一次请求/响应就对应一个TCP连接，接到了响应该连接就关闭，然后在发送请求就在建立TCP连接，持续连接就相反，这里使用的是持续连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　8）Upgrade-Insecure-Requests：该指令用于让浏览器自动升级请求从http到https,用于大量包含http资源的http网页直接升级到https而不会报错.简洁的来讲,就相当于在http和https之间起的一个过渡作用。&lt;/p&gt;
&lt;p&gt;　　第三部分：空行，请求头部后面的空行是必须的&lt;br/&gt;　　　　即使第四部分的&lt;span&gt;请求数据为空，也必须有空行&lt;/span&gt;。　&lt;/p&gt;
&lt;p&gt;　　第四部分：请求数据也叫主体，可以添加任意的其他数据。&lt;br/&gt;　　　　使用GET方式请求时请求数据为空。&lt;/p&gt;
&lt;p&gt;　　由于一般请求报文都不会有请求数据的，所以在9后面就没有内容了，一般如果想要发送数据过去度会通过在域名后面加?然后将数据创送过去&lt;/p&gt;
&lt;h2&gt;4.3、用POST请求的请求报文&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930212852669-786954344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第一部分：请求行，第一行明了是post请求，以及http1.1版本。&lt;br/&gt;　　第二部分：请求头部，第二行至第六行。&lt;br/&gt;　　第三部分：空行，第七行的空行。&lt;br/&gt;　　第四部分：请求数据，第八行。&lt;/p&gt;

&lt;h2&gt;5.1、HTTP请求方法&lt;/h2&gt;
&lt;p&gt;　　根据HTTP标准，HTTP请求可以使用多种请求方法。&lt;br/&gt;　　HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GET：&lt;span&gt;请求指定的页面信息，并返回实体主体&lt;/span&gt;。
POST： &lt;span&gt;向指定资源提交数据进行处理请求&lt;/span&gt;（例如提交表单或者上传文件）。&lt;span&gt;数据被包含在请求体中。POST请求可能会导致新的资源的建立和&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&lt;span&gt;或已有资源的修改&lt;/span&gt;。
HEAD： 类似于get请求，&lt;span&gt;只不过返回的响应中没有具体的内容，用于获取报头&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT：从客户端向服务器传送的数据取代指定的文档的内容。
DELETE ：请求服务器删除指定的页面。
CONNECT：HTTP&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS： 允许客户端查看服务器的性能。
TRACE：回显服务器收到的请求，主要用于测试或诊断。&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.2、GET和POST请求的区别&lt;/h2&gt;
&lt;p&gt;　　Http协议定义&lt;span&gt;了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE.。&lt;/span&gt;一个URL地址用于描述&lt;span&gt;一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　   我们最常见的就是GET和POST了。&lt;span&gt;GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1）提交数据方式：GET提交，&lt;span&gt;请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;amp;连接&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　例 如：login.action?name=hyddd&amp;amp;password=idontknow&amp;amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是&lt;span&gt;英文字母/数字，原样发送&lt;/span&gt;，如果是空格，转换为+，&lt;/p&gt;
&lt;p&gt;　　　　　　    如果是&lt;span&gt;中文/其他字符，则直接把字符串用BASE64加密&lt;/span&gt;，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。&lt;/p&gt;
&lt;p&gt;　　　　POST提交：把&lt;span&gt;提交的数据放置在是HTTP包的包体&lt;/span&gt;中。在前面的例子中提交的数据就是在回车换行的下面。　&lt;/p&gt;
&lt;p&gt;　　2）传输数据的大小：首先声明：&lt;span&gt;HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制&lt;/span&gt;。而在实际开发中存在的限制主要有：　　&lt;/p&gt;
&lt;p&gt;　　　　GET：&lt;span&gt;特定浏览器和服务器对URL长度有限制&lt;/span&gt;，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。&lt;/p&gt;
&lt;p&gt;　　　　　　因此对于GET提交时，传输数据就会受到URL长度的 限制。&lt;/p&gt;
&lt;p&gt;　　　　POST：由于不是通过URL传值，理论上数据不受 限。但&lt;span&gt;实际各个WEB服务器会规定对post提交数据大小进行限制&lt;/span&gt;，Apache、IIS6都有各自的配置。&lt;/p&gt;
&lt;p&gt;　　3）安全性：&lt;span&gt;POST的安全性要比GET的安全性高&lt;/span&gt;。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，&lt;/p&gt;
&lt;p&gt;　　　　除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。&lt;/p&gt;
&lt;p&gt;　　4）Http  get,post,soap协议都是在http上运行的　&lt;/p&gt;
&lt;div readability=&quot;40&quot;&gt;
&lt;p&gt;　　　　get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的&lt;br/&gt;　　　　　　查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全&lt;/p&gt;
&lt;p&gt;　　　　post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。&lt;/p&gt;
&lt;p&gt;　　　　　　   post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。&lt;/p&gt;
&lt;p&gt;　　　　soap：是http post的一个专用版本，遵循一种特殊的xml消息格式，Content-type设置为: text/xml 任何数据都可以xml化。&lt;br/&gt;　　总结上面所说的，GET和POST的区别：　　&lt;/p&gt;
&lt;p&gt;　　 GET提交的&lt;span&gt;数据会放在URL之后&lt;/span&gt;，以?分割URL和传输数据，参数之间以&amp;amp;相连，如login.action?name=hyddd&amp;amp;password=idontknow&amp;amp;verify=%E4%BD%A0 %E5%A5%BD。POST方法是把&lt;span&gt;提交的数据放在HTTP包的Body中&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;　　 GET提交的&lt;span&gt;数据大小有限制&lt;/span&gt;（因为浏览器对URL的长度有限制），而POST方法提&lt;span&gt;交的数据没有限制.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 GET方式需要&lt;span&gt;使用Request.QueryString来取得变量的值&lt;/span&gt;，而POST方式通过&lt;span&gt;Request.Form来获取变量的值&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　 GET方式&lt;span&gt;提交数据，会带来安全问题&lt;/span&gt;，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.&lt;/p&gt;
&lt;h2&gt;5.3、打开一个网页需要浏览器发送多次Request请求&lt;/h2&gt;
&lt;p&gt;　　1） 当你在浏览器输入URL http://www.cnblogs.com 的时候，浏览器发送一个Request去获取 http://www.cnblogs.com 的html. 服务器把Response发送回给浏览器.&lt;br/&gt;　　2） 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件。&lt;br/&gt;　　3） 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件。&lt;br/&gt;　　4） 等所有的文件都下载成功后。 网页就被显示出来了。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;6.1、响应消息格式&lt;/h2&gt;
&lt;p&gt;　　一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。格式如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930213225653-1491450577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。&lt;/p&gt;
&lt;h2&gt;6.2、响应消息&lt;/h2&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201709/999804-20170930214158278-1011067028.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　第一部分：&lt;span&gt;状态行&lt;/span&gt;，由&lt;span&gt;HTTP协议版本号， 状态码， 状态消息&lt;/span&gt; 三部分组成。&lt;/p&gt;
&lt;p&gt;　　　　第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）&lt;/p&gt;
&lt;p&gt;　　第二部分：&lt;span&gt;消息报头&lt;/span&gt;，用来说明客户端要使用的一些附加信息&lt;/p&gt;
&lt;p&gt;　　　　第二行和第三行为消息报头。Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8&lt;/p&gt;
&lt;p&gt;　　第三部分：&lt;span&gt;空行&lt;/span&gt;，消息报头后面的空行是必须的&lt;/p&gt;
&lt;p&gt;　　第四部分：&lt;span&gt;响应正文&lt;/span&gt;，服务器返回给客户端的文本信息。&lt;/p&gt;
&lt;p&gt;　　　　空行后面的html部分为响应正文。&lt;/p&gt;
&lt;h2&gt;6.3、响应状态码&lt;/h2&gt;
&lt;p&gt;　　状态代码有&lt;span&gt;三位数字组成，第一个数字定义了响应的类别&lt;/span&gt;，共分五种类别：&lt;br/&gt;　　　　1xx：指示信息--表示&lt;span&gt;请求已接收，继续处理&lt;/span&gt;&lt;br/&gt;　　　　2xx：成功--表示请求已被成功接收、理解、接受&lt;br/&gt;　　　　3xx：重定向--要完成请求必须进行更进一步的操作&lt;br/&gt;　　　　4xx：客户端错误--请求有语法错误或请求无法实现&lt;br/&gt;　　　　5xx：服务器端错误--服务器未能实现合法的请求&lt;/p&gt;
&lt;p&gt;　　常见的状态码有：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;200&lt;/span&gt; OK                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端请求成功&lt;/span&gt;
&lt;span&gt;400&lt;/span&gt; Bad Request               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端请求有语法错误，不能被服务器所理解&lt;/span&gt;
&lt;span&gt;401&lt;/span&gt; Unauthorized              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 &lt;/span&gt;
&lt;span&gt;403&lt;/span&gt; Forbidden                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器收到请求，但是拒绝提供服务&lt;/span&gt;
&lt;span&gt;404&lt;/span&gt; Not Found                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求资源不存在，eg：输入了错误的URL&lt;/span&gt;
&lt;span&gt;500&lt;/span&gt; Internal Server Error     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器发生不可预期的错误&lt;/span&gt;
&lt;span&gt;503&lt;/span&gt; Server Unavailable        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器当前不能处理客户端的请求，一段时间后可能恢复正常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面把HTTP的内容讲的非常的细致，那我们来总体的看一下它的工作原理吧！&lt;/p&gt;
&lt;div readability=&quot;60&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;HTTP协议定义&lt;span&gt;Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端&lt;/span&gt;。HTTP协议采用了&lt;span&gt;请求/响应模型&lt;/span&gt;。客户端向服务器&lt;span&gt;发送一个请求报文&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;请求报文包含&lt;span&gt;请求的方法、URL、协议版本、请求头部和请求数据&lt;/span&gt;。服务器以&lt;span&gt;一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数&lt;/span&gt;据。&lt;/p&gt;
&lt;p&gt; HTTP 请求/响应的步骤：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　1）客户端连接到Web服务器&lt;/p&gt;
&lt;p&gt;　　　　一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个&lt;span&gt;TCP套接字连接&lt;/span&gt;。例如，http://www.oakcms.cn。&lt;/p&gt;
&lt;p&gt;　　2）发送HTTP请求&lt;/p&gt;
&lt;p&gt;　　　　通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。&lt;/p&gt;
&lt;p&gt;　　3）服务器接受请求并返回HTTP响应&lt;/p&gt;
&lt;p&gt;　　　　Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。&lt;/p&gt;
&lt;p&gt;　　4）释放连接TCP连接&lt;/p&gt;
&lt;p&gt;　　　　若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;&lt;/p&gt;
&lt;p&gt;　　5）客户端浏览器解析HTML内容&lt;/p&gt;
&lt;p&gt;　　　　客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。&lt;/p&gt;
&lt;p&gt;　　　　客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。&lt;/p&gt;
&lt;p&gt;　　例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：&lt;/p&gt;
&lt;p&gt;　　　　浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;&lt;/p&gt;
&lt;p&gt;　　　　解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;&lt;/p&gt;
&lt;p&gt;　　　　浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;&lt;/p&gt;
&lt;p&gt;　　　　服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;&lt;/p&gt;
&lt;p&gt;　　　　释放 TCP连接;&lt;/p&gt;
&lt;p&gt;　　　　浏览器将该 html 文本并显示内容;&lt;/p&gt;
&lt;br/&gt;到此结束，真的好多，喜欢就“推荐”哦！ &lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 30 Sep 2017 14:25:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7614800.html</dc:identifier>
</item>
<item>
<title>Android开发之基于监听的事件处理 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/7616285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/7616285.html</guid>
<description>
&lt;div readability=&quot;10&quot;&gt;&lt;p&gt;在Android 应用开发过程中，常用监听事件如下:&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(1) ListView事件监听&lt;/strong&gt;&lt;br/&gt;setOn ItemSelectedListener:鼠标滚动时触发&lt;br/&gt;setOnItemClickListener: 点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(2 )EditText 事件监听&lt;/strong&gt;&lt;br/&gt;setOnKeyListener: 获取焦点时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(3) RadioGroup事件监听&lt;/strong&gt;&lt;br/&gt;setOnCheckedChangeListener: 点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(4) CheckBox事件监听&lt;/strong&gt;&lt;br/&gt;setOnCheckedChangeListener :点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(5 )Spinner事件监听&lt;/strong&gt;&lt;br/&gt;setOnltemSelectedListener:点击时触发&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(6) DatePicker 事件监听&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;onDateChangedListener： 日期改变时触发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(7 )DatePickerDialog 事件监听&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;onDateSetListener:设置日期时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(8) TimePicker 事件监听&lt;/strong&gt;&lt;br/&gt;onTimeChangedListener:时间改变时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(9 )TimePickerDialog 事件监听&lt;/strong&gt;&lt;br/&gt;onTimeSetListener: 设置时间时触发&lt;br/&gt;&lt;strong&gt;&lt;span&gt;(10)Button.ImageButton 事件监听&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;setOnClickListener: 点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(11)Menu 事件监听&lt;/strong&gt;&lt;br/&gt;onOptionsltemSelected; 点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(12 )Gallery 事件监听&lt;/strong&gt;&lt;br/&gt;setOnItemClickListener: 点击时触发&lt;br/&gt;&lt;span&gt;&lt;strong&gt;(13 )GridView 事件监听&lt;/strong&gt;&lt;br/&gt;setOnltemClickListener: 点击时触发&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现事件监听器的方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内部类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;外类类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Activity本身作为事件监听器类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名内部类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直接绑定到标签&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;内部类形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将事件监听器类定义在当前类的内部&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        MyButtonlistener listener = &lt;span&gt;new&lt;span&gt; MyButtonlistener();
        button.setOnClickListener(listener);
    }
    &lt;span&gt;class MyButtonlistener &lt;span&gt;implements&lt;span&gt; View.OnClickListener{
        @Override
        &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
            &lt;span&gt;//&lt;span&gt;相关事件处理
&lt;span&gt;        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;






&lt;h2&gt;&lt;span&gt;外类类形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Test类&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        MyButtonlistener listener = &lt;span&gt;new&lt;span&gt; MyButtonlistener();
        button.setOnClickListener(listener);
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MyButtonlistener类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class MyButtonlistener &lt;span&gt;implements&lt;span&gt; View.OnClickListener {
    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
        &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;Activity本身作为事件监听器类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　将Activity本身作为事件监听器类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends Activity &lt;span&gt;implements&lt;span&gt; View.OnClickListener{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        button.setOnClickListener(&lt;span&gt;this&lt;span&gt;);

    }

    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
        &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;匿名内部类形式&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity {
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        button.setOnClickListener(&lt;span&gt;new&lt;span&gt; View.OnClickListener() {
            @Override
            &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
                &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;            }
        });
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;直接绑定到标签&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在xml的布局文件中加入onClick属性，设置相关的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201709/1210268-20170930215059434-1405388576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个方法，&lt;span&gt;记得参数是View&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201709/1210268-20170930215011575-911361216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 30 Sep 2017 14:02:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/7616285.html</dc:identifier>
</item>
<item>
<title>深入浅出AQS之条件队列 - 凌风郎少</title>
<link>http://www.cnblogs.com/lfls/p/7615982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lfls/p/7615982.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;相比于独占锁跟共享锁，AbstractQueuedSynchronizer中的条件队列可能被关注的并不是很多，但它在阻塞队列的实现里起着至关重要的作用，同时如果想全面了解AQS，条件队列也是必须要学习的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.jianshu.com/p/3f8b08ca21cd&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/p/3f8b08ca21cd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章会涉及到AQS中独占锁跟共享锁的一些知识，如果你已经对这两块内容很了解了，那就直接往下看。否则在读本文之前还是建议读者先去看看我之前写的两篇文章温习一下。&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/lfls/p/7598380.html&quot;&gt;深入浅出AQS之独占锁模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/lfls/p/7599863.html&quot;&gt;深入浅出AQS之共享锁模式&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;一使用场景介绍&quot;&gt;一、使用场景介绍&lt;/h4&gt;
&lt;p&gt;区别于前面两篇文章，可能之前很多人都没有太在意AQS中的这块内容，所以这篇文章我们先来看下条件队列的使用场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//首先创建一个可重入锁，它本质是独占锁
private final ReentrantLock takeLock = new ReentrantLock();
//创建该锁上的条件队列
private final Condition notEmpty = takeLock.newCondition();
//使用过程
public E take() throws InterruptedException {
        //首先进行加锁
        takeLock.lockInterruptibly();
        try {
            //如果队列是空的，则进行等待
            notEmpty.await();
            //取元素的操作...
            
            //如果有剩余，则唤醒等待元素的线程
            notEmpty.signal();
        } finally {
            //释放锁
            takeLock.unlock();
        }
        //取完元素以后唤醒等待放入元素的线程
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码片段截取自LinkedBlockingQueue，是Java常用的阻塞队列之一。&lt;br/&gt;从上面的代码可以看出，条件队列是建立在锁基础上的，而且必须是独占锁（原因后面会通过源码分析）。&lt;/p&gt;
&lt;h4 id=&quot;二执行过程概述&quot;&gt;二、执行过程概述&lt;/h4&gt;
&lt;p&gt;等待条件的过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在操作条件队列之前首先需要成功获取独占锁，不然直接在获取独占锁的时候已经被挂起了。&lt;/li&gt;
&lt;li&gt;成功获取独占锁以后，如果当前条件还不满足，则在当前锁的条件队列上挂起，与此同时释放掉当前获取的锁资源。这里可以考虑一下如果不释放锁资源会发生什么？&lt;/li&gt;
&lt;li&gt;如果被唤醒，则检查是否可以获取独占锁，否则继续挂起。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;条件满足后的唤醒过程（以唤醒一个节点为例，也可以唤醒多个）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把当前等待队列中的第一个有效节点（如果被取消就无效了）加入同步队列等待被前置节点唤醒，如果此时前置节点被取消，则直接唤醒该节点让它重新在同步队列里适当的尝试获取锁或者挂起。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注：说到这里必须要解释一个知识点，整个AQS分为两个队列，一个同步队列，一个条件队列。只有同步队列中的节点才能获取锁。前面两篇独占锁共享锁文章中提到的加入队列就是同步队列。条件队列中所谓的唤醒是把节点从条件队列移到同步队列，让节点有机会去获取锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;二源码深入分析&quot;&gt;二、源码深入分析&lt;/h4&gt;
&lt;p&gt;下面的代码稍微复杂一点，因为它考虑了中断的处理情况。我由于想跟文章开头的代码片段保持一致，所以选取了该方法进行说明。如果只想看核心逻辑的话，那推荐读者看看awaitUninterruptibly()方法的源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //条件队列入口，参考上面的代码片段
        public final void await() throws InterruptedException {
            //如果当前线程被中断则直接抛出异常
            if (Thread.interrupted())
                throw new InterruptedException();
            //把当前节点加入条件队列
            Node node = addConditionWaiter();
            //释放掉已经获取的独占锁资源
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //如果不在同步队列中则不断挂起
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                //中断处理，另一种跳出循环的方式
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            //走到这里说明节点已经条件满足被加入到了同步队列中或者中断了
            //这个方法很熟悉吧？就跟独占锁调用同样的获取锁方法，从这里可以看出条件队列只能用于独占锁
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            //走到这里说明已经成功获取到了独占锁，接下来就做些收尾工作
            //删除条件队列中被取消的节点
            if (node.nextWaiter != null) 
                unlinkCancelledWaiters();
            //根据不同模式处理中断
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流程比较复杂，一步一步来分析，首先看下加入条件队列的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //注：1.与同步队列不同，条件队列头尾指针是firstWaiter跟lastWaiter
        //注：2.条件队列是在获取锁之后，也就是临界区进行操作，因此很多地方不用考虑并发
        private Node addConditionWaiter() {
            Node t = lastWaiter;
            //如果最后一个节点被取消，则删除队列中被取消的节点
            //至于为啥是最后一个节点后面会分析
            if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
                //删除所有被取消的节点
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            //创建一个类型为CONDITION的节点并加入队列，由于在临界区，所以这里不用并发控制
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }

        //删除取消节点的逻辑虽然长，但比较简单，就不单独说了，就是链表删除
        private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            Node trail = null;
            while (t != null) {
                Node next = t.nextWaiter;
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    if (trail == null)
                        firstWaiter = next;
                    else
                        trail.nextWaiter = next;
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    trail = t;
                t = next;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把节点加入到条件队列中以后，接下来要做的就是释放锁资源：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //入参就是新创建的节点，即当前节点
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            //这里这个取值要注意，获取当前的state并释放，这从另一个角度说明必须是独占锁
            //可以考虑下这个逻辑放在共享锁下面会发生什么？
            int savedState = getState();
            //跟独占锁释放锁资源一样，不赘述
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                //如果这里释放失败，则抛出异常
                throw new IllegalMonitorStateException();
            }
        } finally {
            //如果释放锁失败，则把节点取消，由这里就能看出来上面添加节点的逻辑中只需要判断最后一个节点是否被取消就可以了
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走到这一步，节点也加入条件队列中了，锁资源也释放了，接下来就该挂起了（先忽略中断处理，单看挂起逻辑）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     //如果不在同步队列就继续挂起（signal操作会把节点加入同步队列）
     while (!isOnSyncQueue(node)) {
           LockSupport.park(this);
           //中断处理后面再分析
           if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
     }
    //判断节点是否在同步队列中
    final boolean isOnSyncQueue(Node node) {
        //快速判断1：节点状态或者节点没有前置节点
        //注：同步队列是有头节点的，而条件队列没有
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        //快速判断2：next字段只有同步队列才会使用，条件队列中使用的是nextWaiter字段
        if (node.next != null) 
            return true;
        //上面如果无法判断则进入复杂判断
        return findNodeFromTail(node);
    }

    //注意这里用的是tail，这是因为条件队列中的节点是被加入到同步队列尾部，这样查找更快
    //从同步队列尾节点开始向前查找当前节点，如果找到则说明在，否则不在
    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果被唤醒且已经被转移到了同步队列，则会执行与独占锁一样的方法acquireQueued()进行同步队列独占获取。&lt;br/&gt;最后我们来梳理一下里面的中断逻辑以及收尾工作的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     while (!isOnSyncQueue(node)) {
           LockSupport.park(this);
           //这里被唤醒可能是正常的signal操作也可能是中断
           if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
     }

     //这里的判断逻辑是：
     //1.如果现在不是中断的，即正常被signal唤醒则返回0
     //2.如果节点由中断加入同步队列则返回THROW_IE，由signal加入同步队列则返回REINTERRUPT
     private int checkInterruptWhileWaiting(Node node) {
           return Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
                0;
     }

     //修改节点状态并加入同步队列
     //该方法返回true表示节点由中断加入同步队列，返回false表示由signal加入同步队列
     final boolean transferAfterCancelledWait(Node node) {
        //这里设置节点状态为0，如果成功则加入同步队列
        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
            //与独占锁同样的加入队列逻辑，不赘述
            enq(node);
            return true;
        }
        //如果上面设置失败，说明节点已经被signal唤醒，由于signal操作会将节点加入同步队列，我们只需自旋等待即可
        while (!isOnSyncQueue(node))
            Thread.yield();
        return false;
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在把唤醒后的中断判断做好以后，看await()中最后一段逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//在处理中断之前首先要做的是从同步队列中成功获取锁资源
if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
      interruptMode = REINTERRUPT;
//由于当前节点可能是由于中断修改了节点状态，所以如果有后继节点则执行删除已取消节点的操作
//如果没有后继节点，根据上面的分析在后继节点加入的时候会进行删除
if (node.nextWaiter != null) 
      unlinkCancelledWaiters();
if (interruptMode != 0)
      reportInterruptAfterWait(interruptMode);

//根据中断时机选择抛出异常或者设置线程中断状态
private void reportInterruptAfterWait(int interruptMode) throws InterruptedException {
      if (interruptMode == THROW_IE)
           throw new InterruptedException();
      else if (interruptMode == REINTERRUPT)
           //实现代码为：Thread.currentThread().interrupt();
           selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此条件队列await操作全部分析完毕。signal()方法相对容易一些，一起看源码分析下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //条件队列唤醒入口
   public final void signal() {
       //如果不是独占锁则抛出异常，再次说明条件队列只适用于独占锁
       if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
       //如果条件队列不为空，则进行唤醒操作
       Node first = firstWaiter;
       if (first != null)
            doSignal(first);
   }

   //该方法就是把一个有效节点从条件队列中删除并加入同步队列
   //如果失败则会查找条件队列上等待的下一个节点直到队列为空
   private void doSignal(Node first) {
        do {
            if ( (firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
        } while (!transferForSignal(first) &amp;amp;&amp;amp;(first = firstWaiter) != null);
   }

    //将节点加入同步队列
    final boolean transferForSignal(Node node) {
        //修改节点状态，这里如果修改失败只有一种可能就是该节点被取消，具体看上面await过程分析
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
        //该方法很熟悉了，跟独占锁入队方法一样，不赘述
        Node p = enq(node);
        //注：这里的p节点是当前节点的前置节点
        int ws = p.waitStatus;
        //如果前置节点被取消或者修改状态失败则直接唤醒当前节点
        //此时当前节点已经处于同步队列中，唤醒会进行锁获取或者正确的挂起操作
        if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三总结&quot;&gt;三、总结&lt;/h4&gt;
&lt;p&gt;相比于独占锁跟共享锁，条件队列可能是最不受关注的了，但由于它是阻塞队列实现的关键组件，还是有必要了解一下其中的原理。其实我认为关键点有两条，第一是条件队列是建立在某个具体的锁上面的，第二是条件队列跟同步队列是两个队列，前者依赖条件唤醒后者依赖锁释放唤醒，了解了这两点以后搞清楚条件队列就不是什么难事了。&lt;br/&gt;***&lt;br/&gt;至此，Java同步器AQS中三大锁模式就都分析完了。虽然已经尽力思考，尽量写的清楚，但鉴于水平有限，如果有纰漏的地方，欢迎广大读者指正。&lt;br/&gt;明天就是国庆长假了，我自己也计划出国玩一趟，散散心。&lt;br/&gt;提前祝广大朋友国庆快乐。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Sep 2017 11:30:00 +0000</pubDate>
<dc:creator>凌风郎少</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lfls/p/7615982.html</dc:identifier>
</item>
<item>
<title>leetCode没那么难啦 in Java (一) - 祈求者-</title>
<link>http://www.cnblogs.com/invoker-/p/7615981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/invoker-/p/7615981.html</guid>
<description>&lt;p&gt;   感觉写博客是一个很耗心力的东西T_T，简单的写了似乎没什么用，复杂的三言两语也只能讲个大概，呸呸...怎么能有这些消极思想呢QAQ!那想来想去,先开一个leetcode的坑,虽然已经工作了,但是每天拿一两道题打发打发也不错嘛，不仅能锻炼思维，还能复习一些算法思想，又不怎么耗费时间撰写...还能骗博客数...,额好像又说了啥内心的真实想法:)...&lt;/p&gt;

&lt;h2 id=&quot;两数相加-two-sum&quot;&gt;两数相加 Two Sum&lt;/h2&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;br/&gt;You may assume that each input would have exactly one solution.&lt;br/&gt;Example:&lt;br/&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;br/&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;br/&gt;return [0, 1].&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;翻译: 两数之和&lt;br/&gt;给定一个整形数组和一个整数target，返回2个元素的下标，它们满足相加的和为target。&lt;br/&gt;你可以假定每个输入，都会恰好有一个满足条件的返回结果,也就是多种答案的情况不予考虑&lt;br/&gt;例如给定了数组 nums = [2, 7, 11, 15], 需要的target = 9,&lt;br/&gt;因为 nums[0] + nums[1] = 2 + 7 = 9,&lt;br/&gt;所以返回 [0, 1]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;思路一&lt;br/&gt;暴力解法，好吧程序员做久了人有时候容易变傻，就好像现在让你求从1加到100的和你想都不想for循环100次还说这是复杂度为O(n)哦,殊不知几百年前还在读小学的高斯就用求和公式O(1)时间就解决了T_T&lt;br/&gt;废话说完了，既然暴力解法这么傻，为啥还要讲，因为很多题目实在想不到解法时，可以先拟定一个暴力解法，然后再在这上面去优化时间与空间，寻找思路。&lt;br/&gt;最简单暴力解决就是多次遍历，两轮循环，把他们的和加起来，等于target就返回下标，如果啥都没就返回[-1,-1]&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;twoSum01&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; target) {

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;};

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i++) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; j &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; j++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr[i] + arr[j] == target) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{i, j};
        }
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;};
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;核心代码就是中间的三行,很简单的两次遍历,数据量如果是在&lt;span class=&quot;math inline&quot;&gt;\(10^4\)&lt;/span&gt;这个范围内，&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;级别的算法的时间在1秒内左右,所以如果数据量不是很大，这种暴力解法也是可以接受的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;20.5&quot;&gt;
&lt;p&gt;思路二&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;的时间复杂度如果数据量很大自然是不能接受的,这里就从上面的暴力算法改进，在思路一中，每次遍历元素的时候都要把他和剩下的所有元素都比一遍，这真是太蠢了，你给一个小朋友做这道题他都不会这么解，那小朋友怎么解呢？&lt;br/&gt;假设数组内容是[2,7,11,15],目标值是17，那小朋友会先看2，17-2=15，那他就会去找有没有15，有15就把他们的位置给记下来,没有15就再看下一个数字。这里我们再把这种想法优化一下，程序化一下，代码如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] &lt;span class=&quot;fu&quot;&gt;twoSum&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; target) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nums == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;};
    Map&amp;lt;Integer, Integer&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;span class=&quot;co&quot;&gt;// 答案MAP，用于存储答案，key为数字,value为在数字集合中下标位置&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; nums.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
        Integer exceptNum = target - nums[i];&lt;span class=&quot;co&quot;&gt;//期望的答案&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (map.&lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(exceptNum)) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{map.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(exceptNum), i}; &lt;span class=&quot;co&quot;&gt;//如果寻找到答案了,直接返回&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(nums[i], i); &lt;span class=&quot;co&quot;&gt;//如果没有找到对应的答案,那么就把这个数本身作为答案放入答案map，根据a+b=b+a,正在遍历的数即是请求也是答案&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[]{-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;};
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里最初的思路就是拿空间换时间，最简单的处理是把所有的数组里的数都放到哈希表中，然后直接遍历get就可以了，但是这样未免太浪费空间，所以引入第二步优化思路，我需要多少，我就存多少元素，利用加法交换律a + b = b + a，正在遍历的元素同时就成为了备选答案存入map，这样比单纯的存入map中时间与空间的消耗期望值都是会少一些的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  题目很简单，算法题也有很多，但是思路其实并没有那么繁杂，合理利用这些思路，理解了一道题，这一类的题目就都理解了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在没有头绪的时候先尝试暴力解法，然后看看暴力解法里哪一步是可以优化的，例如本题中最外层循环肯定是不可避免的，但是内循环对于每一个数字都遍历所有就很没有必要，就可以在这点上作优化&lt;/li&gt;
&lt;li&gt;空间换时间，哈希表往往是最常用的选择之一，当然不仅仅是哈希表，树，堆，图，都是值得考虑的对象&lt;/li&gt;
&lt;li&gt;在使用空间换时间的优化中，充分利用已知的元素，最好能将已经遍历的过的元素存储再利用，这样往往能降低不少空间使用与时间消耗，虽然都是O(N)级别的空间，但是前面的常数系数明显是要小的。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 30 Sep 2017 11:28:00 +0000</pubDate>
<dc:creator>祈求者-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/invoker-/p/7615981.html</dc:identifier>
</item>
<item>
<title>简易RPC框架-心跳与重连机制 - min.jiang</title>
<link>http://www.cnblogs.com/ASPNET2008/p/7615973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ASPNET2008/p/7615973.html</guid>
<description>&lt;p&gt;就是告诉其它人自己还活着。在简易RPC框架中，采用的是TCP长连接，为了确保长连接有效，就需要客户端与服务端之间有一种通知机制告知对方的存活状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201709/17071-20170930191516325-1806744437.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;客户端发送心跳消息&lt;/h2&gt;
&lt;p&gt;在状态空闲的时候定时给服务端发送消息类型为PING消息。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;服务端接收心跳消息&lt;/h2&gt;
&lt;p&gt;捕获通道空闲状态事件，如果接收客户端PING消息，则发送PONG消息给服务端。如果在一定时间内没有收到客户端的PING消息，则说明客户端已经不在线，此时关闭通道。&lt;/p&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;客户端管理可用连接&lt;/h2&gt;
&lt;p&gt;由于服务端会因为长时间接收不到服务端的PING消息而关闭通道，这就导致缓存在客户端的连接的可用性发生变化。需要将不可用的从可用列表中转移出去，并对不可用连接进行处理，比如直接丢弃或者是重新连接。&lt;/p&gt;

&lt;p&gt;ChannelPipeline与handle的关系。netty中的这些handle和spring mvc中的filter作用是类似的，ChannelPipeline可以理解成handle的容器，里面可以被注册众多处理不同业务功能的事件处理器，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编码&lt;/li&gt;
&lt;li&gt;解码&lt;/li&gt;
&lt;li&gt;心跳&lt;/li&gt;
&lt;li&gt;权限&lt;/li&gt;
&lt;li&gt;加密&lt;/li&gt;
&lt;li&gt;解密&lt;/li&gt;
&lt;li&gt;业务代码执行&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;toc_7&quot;&gt;空闲状态处理器&lt;/h2&gt;
&lt;p&gt;可以利用netty提供的IdleStateHandler来发送PING-PONG消息。这个处理器主要是捕获通道超时事件，主要有三类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读超时，一定时间内没有从通道内读取到任何数据&lt;/li&gt;
&lt;li&gt;写超时，一定时间内没有从通道内写入任何数据&lt;/li&gt;
&lt;li&gt;读写超时，一定时间内没有从通道内读取或者是写入任何数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_8&quot;&gt;客户端加入空闲状态处理器&lt;/h3&gt;
&lt;p&gt;客户端捕获读写超时，如果事件触发就给服务端发送PING消息。&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;服务端加入空闲状态处理器&lt;/h3&gt;
&lt;p&gt;服务端只需要捕获读超时即可，当读超时触发后就关闭通道。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么在空闲状态才发送心跳消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正常客户端与服务端有交互的情况下，说明双方都在正常工作不需要额外的心跳来告知对方的存活。只有双方在一定时间内没有接收到对方的消息时才开始采用心跳消息来探测对方的存活，这也是一种提升效率的做法。&lt;/p&gt;
&lt;h2 id=&quot;toc_10&quot;&gt;抽象心跳处理器&lt;/h2&gt;
&lt;p&gt;创建AbstractHeartbeatHandler，并继承ChannelInboundHandlerAdapter，服务于客户端与服务端的心跳处理器。在读取方法中判断消息类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是PING消息就发送PONG消息给客户端&lt;/li&gt;
&lt;li&gt;如果收到的是PONG消息，则直接打印消息说明客户端已经成功接收到服务端返回的PONG消息&lt;/li&gt;
&lt;li&gt;如果是其它类型的消息，则通知下一个处理器处理消息&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void channelRead(ChannelHandlerContext channelHandlerContext, Object msg) throws Exception {

        if(!(msg instanceof RpcMessage)){
            channelHandlerContext.fireChannelRead(msg);
            return;
        }
        RpcMessage message=(RpcMessage)msg;

        if(null==message||null==message.getMessageHeader()){
            channelHandlerContext.fireChannelRead(msg);
            return;
        }
        if(message.getMessageHeader().getType()== Constants.MESSAGE_TYPE_HEARTBEAT_PONG){
            logger.info(&quot;ClientHeartbeatHandler.channelRead0 ,pong data is:{}&quot;,message.getMessageBody());
        }
        else if(message.getMessageHeader().getType()== Constants.MESSAGE_TYPE_HEARTBEAT_PING){
            this.sendPong(channelHandlerContext);
        }
        else {
            channelHandlerContext.fireChannelRead(msg);
        }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;空闲状态事件，可以根据不同的状态做不同的行为处理，定义三个可重写事件供客户端与服务端处理器具体确认处理事件。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent e = (IdleStateEvent) evt;
            switch (e.state()) {
                case READER_IDLE:
                    this.handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    this.handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    this.handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_11&quot;&gt;客户端心跳处理器&lt;/h2&gt;
&lt;p&gt;继承抽象心跳处理器，并重写事件发送PING消息。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class ClientHeartbeatHandler extends AbstractHeartbeatHandler {

    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        this.sendPing(ctx);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;服务端心跳处理器&lt;/h2&gt;
&lt;p&gt;继承抽象心跳处理器，并重写事件关闭通道。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class ServerHeartbeatHandler extends AbstractHeartbeatHandler {

    @Override
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
        logger.info(&quot;ServerHeartbeatHandler.handleReaderIdle reader timeout ,close channel&quot;);
        ctx.close();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_13&quot;&gt;客户端ChannelPipeline中加入心跳处理器&lt;/h2&gt;
&lt;p&gt;比如5秒内未写入或者读取通道数据就触发超时事件。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
.addLast(new IdleStateHandler(0, 0, Constants.ALLIDLE_TIME_SECONDS));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_14&quot;&gt;服务端ChannelPipeline中加入心跳处理器&lt;/h2&gt;
&lt;p&gt;比如10秒未接收到通道消息就触发读超时事件。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
 .addLast(new IdleStateHandler(Constants.READER_TIME_SECONDS, 0, 0))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_15&quot;&gt;客户端消息示例&lt;/h2&gt;
&lt;p&gt;正常情况下心跳消息显示如下图所示，消息的内容可以根据自己的情况自行定义。&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201709/17071-20170930191801919-709222725.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2 id=&quot;toc_16&quot;&gt;客户端下线消息示例&lt;/h2&gt;
&lt;p&gt;停止客户端程序，然后服务端读超时事件触发，并关闭通道。&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17071/201709/17071-20170930191818215-1131512577.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2 id=&quot;toc_17&quot;&gt;客户端可用连接管理&lt;/h2&gt;
&lt;p&gt;由于上述的服务端心跳处理器，在触发读超时后会关闭通信管道，这导致客户端缓存的连接状态会出现不可用的情况，为了让客户端一直只能取到可用连接就需要对从缓存中获取到的连接做状态判断，如果可用直接返回，如果不可用则将连接从可用列表中删除然后取下一个可用连接。&lt;/p&gt;
&lt;h3 id=&quot;toc_18&quot;&gt;修改获取连接方法&lt;/h3&gt;
&lt;p&gt;通过channel的isActive属性可以判断连接是否可用，如果不可以做删除并重新获取的操作。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public RpcClientInvoker getInvoker() {
        // ...
        int index = loadbalanceService.index(size);
        RpcClientInvoker invoker= RpcClientInvokerCache.get(index);
        if(invoker.getChannel().isActive()) {
            return invoker;
        }
        else {
            RpcClientInvokerCache.removeHandler(invoker);
            logger.info(&quot;invoker is not active,so remove it and get next one&quot;);
            return this.getInvoker();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_19&quot;&gt;后台启动任务处理不可用连接&lt;/h3&gt;
&lt;p&gt;启动一个每隔5秒执行一次任务的线程，定时取出不可用连接，然后重连，并将不可用连接删除。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我处理的重连是直接丢弃原有不可用连接，然后重新创建新连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
    private static final Logger logger = LoggerFactory.getLogger(RpcClientInvokerManager.class);

    static {
        executorService.schedule(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    List&amp;lt;RpcClientInvoker&amp;gt; notConnectedHandlers = RpcClientInvokerCache.getNotConnectedHandlers();
                    if (!CollectionUtils.isEmpty(notConnectedHandlers)) {
                        for (RpcClientInvoker invoker : notConnectedHandlers) {
                            RpcClientInvokerManager.getInstance(referenceConfig).connect();
                        }
                        RpcClientInvokerCache.clearNotConnectedHandler();
                    }
                }
            }
        }, Constants.RECONNECT_TIME_SECONDS,TimeUnit.SECONDS);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;https://github.com/jiangmin168168/jim-framework&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中代码是依赖上述项目的，如果有不明白的可下载源码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文中的图取自于网格&lt;/p&gt;

</description>
<pubDate>Sat, 30 Sep 2017 11:22:00 +0000</pubDate>
<dc:creator>min.jiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ASPNET2008/p/7615973.html</dc:identifier>
</item>
<item>
<title>实习那些事儿 - LO-gin</title>
<link>http://www.cnblogs.com/LO-gin/p/7615922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LO-gin/p/7615922.html</guid>
<description>&lt;p&gt;　　转眼都毕业一年多了，时光荏苒。一些学弟学妹们也要找工作找实习了。最近一个师弟问我应该怎样充实的度过实习生活。聊了大半天，总结起来就4个字：埋头苦干。&lt;/p&gt;
&lt;p&gt;　　话说回来，2015年11月初开始找实习，拿了三个offer。第一个是能源公司的技术部，做一些日常技术维护和公司一些B/S系统开发，该公司正在准备上市，感觉也还不错。面试通过了，并且已经通知下周一可以入职了，结果到入职前的那个周五，一个电话过来被告知公司不太想要实习生，而是要招正式职员……顿时心里不良情绪都涌上来了。不过还是调整好状态，去做完毕业论文报告后，跑回宿舍“反思”了。当然，没有第一个我还有第二个offer，虽然第二个offer的公司跟第一个比差距有点大，不过离我学校近，平时回趟学校作报告、开会等还是比较方便的，所以还是抱着将就的心情去入职了。第三个就不提了，各方面都不是我想要的。&lt;/p&gt;
&lt;p&gt;　　12月初入职，从此开启我的职业生涯。入职第一天，各种失望又通通涌上心头。公司规模小是可以接受的，但发展有点乱，制度之类的也有点乱。此时去留的问题又来了。但就这样走了又不太像我的风格，最后还是决定留下来，也许我还能改变点什么呢。结果事实证明，确实因此而改变了自己。&lt;/p&gt;
&lt;p&gt;　　你曾经在学校里学的专业知识，即使课程学得再好，还是跟现实有很大差距。毕竟，课本上的东西都是基础，当然，基础很重要。刚刚入职，走完程序后，经理就开始叫我做一些东西，好看看我的实际水平在哪个层次。实话说，做的结果不仅让经理失望了。连我自己都失望了。原本以为不就是做点数据库增删查改的操作吗，而且还是用PHP做后端脚本的，确实，增删查改实现起来不难，但如果你需要多表查询，而且每个表都是有上千万行数据的话，那么问题来了，在学校学的那些东西还能支撑起自己现在做的这些东西吗？明显不能，一时间不知所措了。因为我不熟悉如何优化SQL语句，我也不熟悉要怎样做才能提高程序的性能。那都不熟悉能怎么办？自学啊，或者你也可以无惧别人的不耐烦，问到懂了为止……就这样，从这个不懂，那个也熟悉，那个了解一点点，到后面基本能够自己完成一些功能的编写和优化。在这背后，是需要你付出很多时间和精力去学习的。这可能是在学校里你没意识到的，也可能是在学校里没有那种压力，所以就没有那种动力去学，当然还可能是你在学校里没有方向跟目标，所以无从下手。但这一切，从入职那一刻起，你都得逐一解决。不然，谈何职业发展。&lt;/p&gt;
&lt;p&gt;　　被动成长的同时也要自己的积极主动性。做web的分为前端和后端，要是在一些比较缺人手的公司呢，一般一个系统的前端后端就要让一个人全包了。所以，仅仅懂得前端语言或者后端语言是远远不够的。我实习三个月后，有一次，经理突然问我会不会做视频，我只回了一句：”P下图还行，视频没弄过。” 结果经理就丢给我一句：”我们需要搞个宣传动画，不用太长，几分钟就好！”。我一时间还没晃过神来，难道是我没说清楚，我明明说视频我没弄过的。于是，我又重申了一遍我不会做视频，但经理又简单地丢给我一句：”这个视频下周五就要，具体要求我待会发给你，你想想办法！”。此时我内心有千万只草泥马在奔腾，我不懂，我是真不懂，这是要逼我走人么？也有那么一会，想到了走人。但我也不知道那时我为什么又留下了。可能是如果就那样走了未免太不负责任，也显得太无能。于是用两三天学了点Adobe Premiere Pro和Adobe Flash的基础操作，周末再看一些视频教程，并自己动手做些简单的东西。再加上本身一点点的PS基础。终于还是搞出了一段自己都很不满意的”作品”，心想：”不管了，行不行都是那样了”。发过去之后，经理也没说好，也没说不好（肯定是不好啦），我也懒得问。”视频事件”就算这么过去了。后面想想，这也未必是坏事，换成平时，难道你会那么积极地，紧迫地去学习一些你从来没接触过的东西？况且，学起来的东西就都是自己的了。编程过程中也是一样，虽然做着PHP，但还得学JavaScript，不然，在现代的web开发中，没有众多前端框架的支持，还能写出又酷炫又有用的系统？这些也让我在实习结束后找工作中受益。&lt;/p&gt;
&lt;p&gt;　　当然啦，实习生也少不了一堆杂活，没事就被叫去给这台电脑装个系统，给那台电脑加个内存什么的，更坑的是客户需要拉条网线，经理也义不容辞让我去了，心中无数省略号飘过。但是无可否认的是，这些也让我学到一些大学课堂里学不到的技能。至少装配个电脑或者配置下网络什么的都可以不用麻烦别人了。有付出总会有收获的。只是在付出时有个好的心态，也许能收获的更多。&lt;/p&gt;
&lt;p&gt;　　实习是一段很宝贵的经历，我在实习中的实践就是对大学所学的东西最好的检验，尽管不是很全面。当然，实习更是一个人成长的开始。要学会在实习中get到该岗位的技能。最好是能定下目标。让自己在实习阶段完成一次蜕变。从学生到职场人士的蜕变。至于如何设置目标，这个就根据个人情况了。目标是每个人都有的，但有些人向来都是眼高手低，高不成低不就。最后就只能得过且过，荒废时光。我个人给的建议是：目标划分，将目前无法实现的大目标划分成可以实现小目标。比如，要成为一个优秀的后端程序员，你需要会很多技能，像一些后端脚本，服务器，数据库，缓存等等都得学。不然就称不上优秀。而这些不是你花个几个月或者半年就能完成的。需要你长期学习积累。所以你可以就目前的情况做目标划分。如果你不熟悉linux系统，那么你可以先体系化学习一下linux系统，然后学习各种运营环境和开发环境的搭建。就这样逐个突破自己的局限性，这种积累的本身就是成长。一两年后你自然成长了不少。&lt;/p&gt;
&lt;p&gt;        反正，出来混，迟早是要还的。&lt;/p&gt;

</description>
<pubDate>Sat, 30 Sep 2017 10:52:00 +0000</pubDate>
<dc:creator>LO-gin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LO-gin/p/7615922.html</dc:identifier>
</item>
</channel>
</rss>