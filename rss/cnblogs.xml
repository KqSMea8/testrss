<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>操作系统中的同步互斥（锁与信号量） - miao_zheng</title>
<link>http://www.cnblogs.com/miachel-zheng/p/9351833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miachel-zheng/p/9351833.html</guid>
<description>&lt;p&gt;操作系统的同步与互斥可以从线程和进程两个角度进行理解。如果从线程的角度理解，这里本文以两个线程为例，需要考虑这两个线程是否属于同一个进程，对于不同进程的线程来说，它们本质上和从两个进程的角度进行理解是一样的，在之后讨论两个进程间的同步互斥时会详细说明。对于同一进程的两个线程，假设有这样一段代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;int res, temp=0;
res = temp++;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上文的代码是通过C语言编写的，需要经过编译、链接之后才能执行，经过编译后，“res=temp++;”可能被翻译成如下的汇编指令。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;load temp, reg1
store reg1, res
inc reg1
store temp, reg1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果两个线程同时执行这样一段代码，在执行过程中，可能发生线程切换，导致一个线程没有全部执行完这4条指令，就将执行权限交到另一个线程的情况。考虑这样一种情况，线程1在执行完inc reg1之后发生线程切换，第二个线程开始执行，如果第二个线程正常执行完毕，将temp置为1，然后切回线程1，再次将temp置为1。其实这已经和我们的初衷不符，因为正常情况下，我们通常认为temp应该等于2，而且更重要的是，这个代码带有不确定性，如果两个线程执行时，temp可能为1也可能为2，res的值也不确定。&lt;/p&gt;
&lt;p&gt;一种简单的做法是加锁，还是看一段代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;int res,temp=0;
LOCK(p);
res = temp++;
UNLOCK(p);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里假设p是一个全局变量，初始化为1，函数LOCK(p)可以理解为读取p的值，如果p&amp;gt;0则p执行自减操作，如果p=0则将当前线程睡眠一个固定的时间，然后再来查询p的值，这个过程可以表示为如下代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;void LOCK(int p)
{
    while(1)
    {
        if(p &amp;gt; 0)
        {
            p--;
            return;
        }
        sleep(10);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UNLOCK的代码同理，这里不详细写了。看到这里读者可能会发现，这段代码看似解决了以前的问题，但是带来了两个新的问题：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这段代码并不能真正让多线程正确工作，比如线程1执行时，假设p=1，那么(p&amp;gt;0)是成立的，但是如果恰巧执行完p&amp;gt;0以后线程切换，线程1让出执行权限给线程2，那么线程2在判断p&amp;gt;0时也是成立的，这时两个线程仍然同时进入到临界区（我们把不允许多线程同时执行的区域称为临界区或互斥区，下同)，因此不能解决上述问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二个问题是，即使多个线程不会同时进入到临界区，也会导致忙等待的问题。具体来说，如果线程1进入到临界区，这时切换到线程2，线程2可能也执行这段代码，当它试图执行LOCK(p)时，它会一直轮询p的状态，此时线程1没有执行，那么它这个时间片(线程2的执行时间)事实上是浪费了，如果线程2的优先级高于线程1，而且线程的调度算法是优先级高的线程总是先执行，那将产生可怕的后果，线程1永远也不能执行，因此永远也不会释放锁，而线程2永远在轮询，永远在浪费时间片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;显然，上述两个问题是不能回避的，这两个问题必须得到解决。针对第一个问题，事实上我们采用硬件提供的方法，由硬件确保查询和更改操作是原子操作，简单来说，就是判断(p&amp;gt;0)和执行p--这两个操作是原子操作，要么都做要么都不做，我记得C库会提供一个大致叫CompareAndChange的函数来完成这个操作。&lt;br/&gt;针对第二个问题，要解决起来就复杂的多。首先，操作系统将线程分为三种状态，分别是就绪（Ready）、挂起（Suspend）、执行（Execute），事实上这三种状态在很多地方都会用到，这里只考虑在访问临界区时的应用。首先介绍一下这三种状态，就绪态的线程是指一个线程已经就绪，简单来说就是可以被调度执行，需要注意，同一时刻可能存在多个就绪态的线程，如果当前执行的线程执行完毕后，会从当前多个就绪线程中选取一个线程（一般选择优先级最高的）切换到执行态。执行态的线程在同一时刻只有一个（事实上执行态的线程个数取决于CPU核的个数，但又不仅仅取决于CPU核的个数，这里不详细讨论），挂起态比较特殊，这类线程往往是由于资源得不到满足而挂起，等到资源满足以后再被唤醒切换到就绪态。举个简单的挂起态的例子，比如一个线程想要读磁盘，那么它只需要发一个系统调用告诉内核，再由内核告诉磁盘读取指定区域的数据，但是这个读取是需要时间的，此时这个线程就被阻塞了，因此给它时间片也没用，所以它会被os挂起，当磁盘读取完成后，可以告诉内核，然后由内核再将上述挂起线程唤醒。&lt;/p&gt;
&lt;p&gt;回到这个问题，当线程1执行了LOCK(p)之后进入到临界区以后，如果这时线程1让出执行权限，由线程2开始执行，那么当它执行到LOCK(p)时，它不会再去轮询p到状态，而是会将自己从执行态（因为此时线程2在执行，所以必然处于执行态）变为挂起状态。需要注意的是，无论线程2的优先级多么高，此时线程2再也没有执行的可能了。接下来，如果线程1执行完毕后，它会执行UNLOCK(p)，那么此时UNLOCK(p)也不能仅仅做p++了，它需要唤醒线程2，也就是唤醒等待p的线程。此时p已经不仅仅是一个整数那么简单了，准备的说，p已经是一个信号量了，信号量肯定比一个整数要复杂很多，但从原理上讲，也不需要很复杂。那么一个信号量需要什么呢？我想它应该需要两样东西：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个整数记录当前信号量的值，信号量的值不总是1，比如临界区的代码是操作打印机，而此时存在十个打印机，那么允许十个线程同时进入到临界区，因此信号量可以是10，当然大多数情况下信号量只有0、1两个取值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;应该有一个队列作为信号量的等待队列，简单来说，如果线程1在临界区中执行时让出执行权限，在线程1再次被调度执行以前，有线程2、线程3两个线程都试图进入临界区，因此这两个线程会进入到一个队列中，当信号量被线程1释放时，我们一般会唤醒先等待信号量的线程，假设线程2先试图访问这个临界区，那么就先唤醒线程2，等线程2再次执行完毕后再唤醒线程3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此，一个简单的信号量就设计完成了，对于信号量的操作，一般称为P和V操作，P相当于LOCK、V相当于UNLOCK。当然，现在的操作系统对于信号量的设计远没有这么简单，考虑的情况也要复杂很多，这只是一个简单的分析，如果有读者在这方面想要交流，欢迎发邮件给我。&lt;/p&gt;

&lt;p&gt;上述考虑的是互斥的情况，下面考虑同步的情况。首先，操作系统为什么要有同步操作？举个例子，福特是汽车行业的先驱，尽管汽车的发明者是benz（关于汽车的发明者，现在仍然争论不休，这里不详细说了），但是福特真正把汽车带进了千家万户，他最大的贡献就是发明了流水线作业，大幅度降低了汽车制造的成本。流水线作业的本质是每个人只负责一小部分，整个工厂像流水线一样完成汽车制造。对于计算机来说，我们考虑这样一种情况，假设一个音乐播放软件，首先需要有一个线程负责告诉磁盘把音乐读到内存中，然后另一个线程负责把内存中的数据发送到声卡处理。那么整个音乐播放就是一个同步问题，首先需要将数据读到内存，才能将数据发送给声卡，播放出我们可以听见的声音。如果将这个问题抽象一下，可以认为有A、B、C、D四个操作，需要按照A、B、C、D的顺序执行，对于这类问题，应用上述信号量的机制就可以很好解决。比如设计三个信号量，这里分别记为a，b，c。线程B等待信号量a，线程C等待信号量b，线程D等待信号量c，初始化阶段将三个信号量都设置为0，因此线程B、C、D都会阻塞。当线程A执行完毕后，唤醒B，然后依次唤醒就可以让四个线程严格按照顺序执行。&lt;/p&gt;
&lt;p&gt;当然，这里考虑的仍然是非常简单的情况，读者可以考虑按照这种思路会出现哪些无法解决的问题？？或者仍有哪些问题没有考虑到？？&lt;/p&gt;
&lt;p&gt;欢迎留言以及邮件交流。&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 15:31:00 +0000</pubDate>
<dc:creator>miao_zheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miachel-zheng/p/9351833.html</dc:identifier>
</item>
<item>
<title>MySQL-备份与还原 - 一入IT深似海·</title>
<link>http://www.cnblogs.com/xsuid/p/9416593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xsuid/p/9416593.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于我们运维来说，在mysql数据库领域，别的不说，最起码要会两大技能！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一大技能：备份与还原&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二大技能：主从异步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这两大技能我们先来说说第一个&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;备份与还原&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;备份：我们按时定点来备份数据，当下数据最值钱，所以我们要确保数据的安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平常我们都是7天一大备，三天两头一小备，也就是说，一周来一个完全备份，1、2、天来一个增量或差异备份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确保那天服务器宕机或误操作，能恢复过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还原：当服务器负重过量会导致宕机，或有时候我们误操作，删除了某张重要的数据表等等，这时候就要用到我们之前备份的数据来恢复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说下备份的类型，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冷备：读写操作均不可进行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;温备：读操作可执行；但写操作不可执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;热备：读写操作均可执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MyISAM：温备，不支持热备&lt;br/&gt;InnoDB: 都支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说下常用的备份工具，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LVM的快照：先加锁，做快照后解锁，几乎热备；借助文件系统工具进行备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysqldump：逻辑备份工具，适用所有存储引擎，温备；支持完全或部分备份；对InnoDB存储引擎支持热备，结合binlog的增量备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;xtrabackup：由Percona提供支持对InnoDB做热备(物理备份)的工具，支持完全备份、增量备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：以上除了xtrabackup，都是基于完整备份包以及二进制日志来恢复数据库的，二进制日志记录了增删改语句的操作指令，拿过来重放，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议：建议二进制日志和数据文件分开存放 --&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、关闭网络链接，只监听本地端口访问，(在备份还原的时候用)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip-networking=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、禁止主机名解析，ip地址访问的时候，禁止反向解析（建议加上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip_name_resolve = on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个表单独使用一个表空间存储表的数据和索引（建议加上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innodb_file_per_table = on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、开启并指定二进制文件存放位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;log_bin=/...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、准备两台主机，我用.17充当mysql主服务器，.57来还原用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、17主mysql数据库有以下几个表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222145643-2046072471.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222145958-2113440543.png&quot; alt=&quot;image&quot; width=&quot;565&quot; height=&quot;270&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/data/mysq/：下存放数据库数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/app/logs/：下存放二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;实战&lt;/h2&gt;
&lt;h3&gt;备份阶段&lt;/h3&gt;
&lt;h4&gt;1、完全备份&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqldump -pcentos -A -F --master-data=2 --single-transaction |gzip &amp;gt; /data/all-`date +%F`.sql.gz
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-A：备份全部数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-F：切换二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--master-data=2：记录了基于二进制那个位置备份的，这个点之后是新数据，备份结束点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--single-transaction：保证数据的一致性&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2、解压并查看&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
gzip -d all-2018-08-03.sql.gz
less all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222146322-1801452241.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222146658-1546290035.png&quot; alt=&quot;image&quot; width=&quot;1113&quot; height=&quot;186&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：记住这个文件以及数字，一会还原的时候要用&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3、修改students表（新数据和日志）&lt;/h4&gt;
&lt;p&gt;1）没修改前&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147085-67617119.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147447-1574011042.png&quot; alt=&quot;image&quot; width=&quot;569&quot; height=&quot;595&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）加记录&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda1hao',20);
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147790-1299839807.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148145-2142196695.png&quot; alt=&quot;image&quot; width=&quot;571&quot; height=&quot;614&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）查看现在的二进制变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148537-1583064080.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148955-1576042839.png&quot; alt=&quot;image&quot; width=&quot;1152&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）假设现在这台mysql服务器宕机崩溃了，下面开始还原&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;还原阶段&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面规划的是用57这台主机来还原，首先这台主机必须是干净的mysql数据库&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1、scp传送&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）传送完全备份文件到目标主机&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
scp all-2018-08-03.sql 192.168.43.57:
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）传送上面图中00005文件以及之后的二进制文件到目标主机&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
scp mysql-bin.000005 192.168.43.57:
&lt;/pre&gt;
&lt;h4&gt;2、57主机来还原&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意：还原的时候要禁止除了你之外的所有用户的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;停止mysql服务，在my.cnf配置文件中可以加上上面说到一项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）开启服务前提下并完全备份数据包&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt; all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：现在只还原到了，备份时的状态，下面再次还原备份后到宕机这段时候发生的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）导入二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqlbinlog  --start-position=385 /root/mysql-bin.000005 &amp;gt; /app/binlog.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：把00005中从385开始的指令语句导入到一个文件中&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt; /app/binlog.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：导入二进制记录的指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、看表存在不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149320-1880267645.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149631-552964432.png&quot; alt=&quot;image&quot; width=&quot;518&quot; height=&quot;271&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、看表数据正不正确&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149930-1146816210.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150273-31162997.png&quot; alt=&quot;image&quot; width=&quot;578&quot; height=&quot;614&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK 还原成功&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;下面再来演示一个案例-误删除表的恢复&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;比如我们在某天的12点中做了完全备份，在下一次做完全备份中间有一天执行了删除某张表，删除后等了几个小时才发现表删除了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这种场景下，来恢复数据，下面来模拟下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟顺序：完全备份--用户对表的数据修改--删除某张表--未发现用户继续对其他表操作--当访问被删除的表时发现--&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备工作和上面一样，下面进入正题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前几步和前面一样&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、完全备份&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqldump -pcentos -A -F --master-data=2 --single-transaction |gzip &amp;gt; /data/all-`date +%F`.sql.gz
&lt;/pre&gt;
&lt;h3&gt;2、模拟误删除表前的修改&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda1hao',20);
&lt;/pre&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：这期间加了好多数据，可能二进制文件已经满了，进行了切换&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、模拟二进制文件的切换&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
flush logs;
#
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;接着增加几条记录&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda2hao',22);
&lt;/pre&gt;
&lt;h3&gt;4、模拟误删除数据表&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
drop table students;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：删除后还么有发现，接着增加其他表的数据&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert teachers (name,age)values('gaoda3',30);
&lt;/pre&gt;
&lt;h3&gt;5、发现问题并及时禁止用户写权限（只能读）&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
flush tables with read lock;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：现在只能root用户可以读写其他用户是不能修改数据的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150532-504193403.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150813-1442568093.png&quot; alt=&quot;image&quot; width=&quot;809&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h3&gt;6、干净系统还原&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）停止服务&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
systemctl stop mairadb
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;2）删除所有mysql数据库数据&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
rm -rf /var/lib/mysql/
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;3）确保用户不能访问服务器 配置文件加上&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
skip-networking
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;4）启动服务&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7、还原完全备份&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）解压完全备份包&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
gzip -d all-2018-08-03.sql.gz
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）查看解压的文件确定位置&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
less all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222151187-1212919439.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222151722-949715581.png&quot; alt=&quot;image&quot; width=&quot;1069&quot; height=&quot;184&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）把完整备份传送到57目标主机还原&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt;all-2018-08-03.sql
&lt;/pre&gt;
&lt;h3&gt;8、还原增量备份&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）合并00004以及之后的二进制日志文件&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqlbinlog  --start-position=385 mysql-bin.000004 &amp;gt; /data/binlogs.sql
mysqlbinlog   mysql-bin.000005 &amp;gt;&amp;gt; /data/binlogs.sql
mysqlbinlog   mysql-bin.000006 &amp;gt;&amp;gt; /data/binlogs.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）从合并的二进制日志文件中找到误操作的指令删除或注释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152103-557850186.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152598-869911048.png&quot; alt=&quot;image&quot; width=&quot;1109&quot; height=&quot;241&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）scp传送到57目标主机还原&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt;binlogs.sql
&lt;/pre&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、删除的表看看有了没&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152985-1438580326.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153410-1119901566.png&quot; alt=&quot;image&quot; width=&quot;617&quot; height=&quot;652&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在表删除后其他的表改的记录还在不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153672-173900761.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153976-667808280.png&quot; alt=&quot;image&quot; width=&quot;630&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还原成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎补充--&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 14:28:00 +0000</pubDate>
<dc:creator>一入IT深似海&amp;#183;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xsuid/p/9416593.html</dc:identifier>
</item>
<item>
<title>聊聊 JDK 非阻塞队列源码（CAS实现） - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9416596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9416596.html</guid>
<description>&lt;p&gt;正如上篇文章&lt;a href=&quot;http://www.hchstudio.cn/article/2018/22ff/&quot;&gt;聊聊 JDK 阻塞队列源码（ReentrantLock实现）&lt;/a&gt;所说，队列在我们现实生活中队列随处可见，最经典的就是去银行办理业务，超市买东西排队等。今天楼主要讲的就是JDK中安全队列的另一种实现使用CAS算法实现的安全队列。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jdk-中的队列&quot;&gt;JDK 中的队列&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;JDK&lt;/strong&gt;中的队列都实现了 &lt;strong&gt;java.util.Queue&lt;/strong&gt; 接口，下面就是楼主要说的无锁版本的队列实现：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;LinkedTransferQueue&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ConcurrentLinkedQueue&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;linkedtransferqueue-源码分析&quot;&gt;LinkedTransferQueue 源码分析&lt;/h2&gt;
&lt;p&gt;LinkedTransferQueue 的原理就是通过使用原子变量compare and swap（简称“CAS”）这种不加锁的方式来实现的进行并发控制，LinkedTransferQueue是一个无界的安全队列，其长度可以无限延伸，当然其带来的问题也是显而易见的。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要方法源码实现&quot;&gt;主要方法源码实现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;add：添加元素到队列里，添加成功返回true；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;offer：添加元素到队列里，添加成功返回true，添加失败返回false；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;put：添加元素到队列里，如果容量满了会阻塞直到容量不满；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除。&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;add&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;offer&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean offer(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    return xfer(null, false, NOW, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;take&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E take() throws InterruptedException {
    E e = xfer(null, false, SYNC, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码中可以看出，这些方法最终都指向了 &lt;code&gt;xfer&lt;/code&gt; 方法，只不过传入的不同的参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implements all queuing methods. See above for explanation.
 *
 * @param e the item or null for take
 * @param haveData true if this is a put, else a take
 * @param how NOW, ASYNC, SYNC, or TIMED
 * @param nanos timeout in nanosecs, used only if mode is TIMED
 * @return an item if matched, else e
 * @throws NullPointerException if haveData mode but e is null
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码的 doc 注释中可以知道&lt;br/&gt;第一个参数，如果是 put 类型，就是实际的值，反之就是 null。&lt;br/&gt;第二个参数，是否包含数据，put 类型就是 true，take 就是 false。&lt;br/&gt;第三个参数，执行类型，有立即返回的NOW，有异步的ASYNC，有阻塞的SYNC， 有带超时的 TIMED。&lt;br/&gt;第四个参数，只有在 TIMED类型才有作用。&lt;/p&gt;
&lt;p&gt;接下来我们来看看 &lt;code&gt;xfer&lt;/code&gt; 到底是何方神圣&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private E xfer(E e, boolean haveData, int how, long nanos) {
    if (haveData &amp;amp;&amp;amp; (e == null))
        throw new NullPointerException();
    Node s = null;                        // the node to append, if needed

    retry:
    for (;;) {                            // restart on append race
        // 从  head 开始
        for (Node h = head, p = h; p != null;) { // find &amp;amp; match first node
            // head 的类型。
            boolean isData = p.isData;
            // head 的数据
            Object item = p.item;
            // item != null 有 2 种情况,一是 put 操作, 二是 take 的 itme 被修改了(匹配成功)
            // (itme != null) == isData 要么表示 p 是一个 put 操作, 要么表示 p 是一个还没匹配成功的 take 操作
            if (item != p &amp;amp;&amp;amp; (item != null) == isData) { 
                // 如果当前操作和 head 操作相同，就没有匹配上，结束循环，进入下面的 if 块。
                if (isData == haveData)   // can't match
                    break;
                // 如果操作不同,匹配成功, 尝试替换 item 成功,
                if (p.casItem(item, e)) { // match
                    // 更新 head
                    for (Node q = p; q != h;) {
                        Node n = q.next;  // update by 2 unless singleton
                        if (head == h &amp;amp;&amp;amp; casHead(h, n == null ? q : n)) {
                            h.forgetNext();
                            break;
                        }                 // advance and retry
                        if ((h = head)   == null ||
                            (q = h.next) == null || !q.isMatched())
                            break;        // unless slack &amp;lt; 2
                    }
                    // 唤醒原 head 线程.
                    LockSupport.unpark(p.waiter);
                    return LinkedTransferQueue.&amp;lt;E&amp;gt;cast(item);
                }
            }
            // 找下一个
            Node n = p.next;
            p = (p != n) ? n : (h = head); // Use head if p offlist
        }
        // 如果这个操作不是立刻就返回的类型    
        if (how != NOW) {                 // No matches available
            // 且是第一次进入这里
            if (s == null)
                // 创建一个 node
                s = new Node(e, haveData);
            // 尝试将 node 追加对队列尾部，并返回他的上一个节点。
            Node pred = tryAppend(s, haveData);
            // 如果返回的是 null, 表示不能追加到 tail 节点,因为 tail 节点的模式和当前模式相反.
            if (pred == null)
                // 重来
                continue retry;           // lost race vs opposite mode
            // 如果不是异步操作(即立刻返回结果)
            if (how != ASYNC)
                // 阻塞等待匹配值
                return awaitMatch(s, pred, e, (how == TIMED), nanos);
        }
        return e; // not waiting
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码有点长，其实逻辑很简单。就是找到 &lt;code&gt;head&lt;/code&gt; 节点,如果 &lt;code&gt;head&lt;/code&gt; 节点是匹配的操作,就直接赋值,如果不是,添加到队列中。&lt;br/&gt;注意：队列中永远只有一种类型的操作,要么是 &lt;code&gt;put&lt;/code&gt; 类型, 要么是 &lt;code&gt;take&lt;/code&gt; 类型.&lt;/p&gt;
&lt;h2 id=&quot;concurrentlinkedqueue-源码分析&quot;&gt;ConcurrentLinkedQueue 源码分析&lt;/h2&gt;
&lt;p&gt;与 &lt;code&gt;LinkedTransferQueue&lt;/code&gt; 一样，ConcurrentLinkedQueue 一样是采用原子变量实现的并发控制，&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt; 是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现。&lt;/p&gt;
&lt;h3 id=&quot;主要方法源码实现-1&quot;&gt;主要方法源码实现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;add：添加元素到队列里，添加成功返回true；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;offer：添加元素到队列里，添加成功返回true，添加失败返回false；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;put：添加元素到队列里，如果容量满了会阻塞直到容量不满；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false；&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;add&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    return offer(e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;offer&lt;/code&gt;方法：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;是无界的，所以&lt;code&gt;offer&lt;/code&gt;永远返回true，不能通过返回值来判断是否入队成功，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean offer(E e) {
    // 校验是否为空
    checkNotNull(e);
    //入队前，创建一个入队节点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

    //循环CAS直到入队成功。
    // 1、根据tail节点定位出尾节点（last node）；
    // 2、将新节点置为尾节点的下一个节点，
    // 3、更新尾节点casTail。
    for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
        Node&amp;lt;E&amp;gt; q = p.next;
        //判断p是不是尾节点，tail节点不一定是尾节点，判断是不是尾节点的依据是该节点的next是不是null
        if (q == null) { 
            // p is last node
            if (p.casNext(null, newNode)) {
                 //设置P节点的下一个节点为新节点，如果p的next为null，说明p是尾节点，casNext返回true；
                 // 如果p的next不为null，说明有其他线程更新过队列的尾节点，casNext返回false。
                // Successful CAS is the linearization point
                // for e to become an element of this queue,
                // and for newNode to become &quot;live&quot;.
                if (p != t) // hop two nodes at a time
                    casTail(t, newNode);  // Failure is OK.
                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
        else if (p == q)
            //p节点是null的head节点刚好被出队，更新head节点时h.lazySetNext(h)把旧的head节点指向自己
            // We have fallen off list.  If tail is unchanged, it
            // will also be off-list, in which case we need to
            // jump to head, from which all live nodes are always
            // reachable.  Else the new tail is a better bet.
            p = (t != (t = tail)) ? t : head;
        else
            // Check for tail updates after two hops.
            //判断tail节点有没有被更新，如果没被更新，1）p=q：p指向p.next继续寻找尾节点;
            //如果被更新了，2)p=t:P赋值为新的tail节点
            p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    restartFromHead:
    //两层循环
    for (;;) {
        for (Node&amp;lt;E&amp;gt; h = head, p = h, q;;) {
            E item = p.item;

            if (item != null &amp;amp;&amp;amp; p.casItem(item, null)) {
                // Successful CAS is the linearization point
                // for item to be removed from this queue.
                if (p != h) // hop two nodes at a time
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            //队列为空，更新head节点
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            else if (p == q)
                //p节点是null的head节点刚好被出队，更新head节点时h.lazySetNext(h);把旧的head节点指向自己。
                //重新从head节点开始
                continue restartFromHead;
            else
                p = q;    //将p执行p的下一个节点
        }
    }
}

//更新head节点
final void updateHead(Node&amp;lt;E&amp;gt; h, Node&amp;lt;E&amp;gt; p) {
    //通过CAS将head更新为P
    if (h != p &amp;amp;&amp;amp; casHead(h, p))
        h.lazySetNext(h);//把旧的head节点指向自己
}

void lazySetNext(Node&amp;lt;E&amp;gt; val) {
    UNSAFE.putOrderedObject(this, nextOffset, val);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;remove&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean remove(Object o) {
    if (o != null) {
        Node&amp;lt;E&amp;gt; next, pred = null;
        // 循环CAS直到删除节点
        for (Node&amp;lt;E&amp;gt; p = first(); p != null; pred = p, p = next) {
            boolean removed = false;
            E item = p.item;
            if (item != null) {
                if (!o.equals(item)) {
                    next = succ(p);
                    continue;
                }
                // 通过CAS删除节点
                removed = p.casItem(item, null);
            }

            next = succ(p);
            if (pred != null &amp;amp;&amp;amp; next != null) // unlink
                pred.casNext(p, next);
            if (removed)
                return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了两种CAS算法实现的安全队列，然而稳定性要较高的系统中，为了防止生产者速度过快，导致内存溢出，通常是不建议选择无界队列的。当然楼主水平有限，文章中不免有纰漏，望小伙伴谅解并指出，在技术的道路上一起成长。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
</description>
<pubDate>Fri, 03 Aug 2018 14:23:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9416596.html</dc:identifier>
</item>
<item>
<title>Net Core平台灵活简单的日志记录框架NLog+Mysql组合初体验 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9416439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9416439.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前几天分享的&quot;[Net Core集成Exceptionless分布式日志功能以及全局异常过滤][https://www.cnblogs.com/yilezhu/p/9339017.html]&quot; 有人说比较重量，生产环境部署也比较麻烦。因此就有了今天的这篇文章。如果你的项目（网站或者中小型项目）不是很大，日志量也不多的话可以考虑NLog+Mysql的组合。因为NLog具有高性能，易于使用，易于扩展和灵活配置的特点能够让你快速集成日志记录功能。&lt;br/&gt;作者：yilezhu&lt;br/&gt;本文链接 ：https://www.cnblogs.com/yilezhu/p/9416439.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;nlog是什么&quot;&gt;NLog是什么？&lt;/h3&gt;
&lt;p&gt;这里还是简单介绍一下吧，为了让小白也知道。NLog是一个灵活的免费日志记录平台，适用于各种.NET平台，包括.NET Core。NLog可以通过简单地配置就可以可以很方便的写入多个日志仓库中（数据库，文件，控制台）。&lt;/p&gt;
&lt;h3 id=&quot;nlog在net-core中怎么用啊&quot;&gt;NLog在Net Core中怎么用啊？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用之前你得新建一个asp.net core项目吧。这里以net core api为例吧。如下图所示是博主刚刚创建的net core api项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214801905-1166916829.png&quot; alt=&quot;net core api项目&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;35&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;建好项目之后干什么呢、当然得添加引用了。你可以随心所欲的使用Nuget或者命令进行安装&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package NLog -Version 4.5.7
Install-Package NLog.Web.AspNetCore -Version 4.5.4&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;上面说了，NLog只需要简单地修改配置就可以使用，那接下来就是新建一个NLog配置文件了。你可以通过Nuget或者程序包控制台进行安装，也可以自己新建一个NLog.config文件。这里还是通过程序包控制台进行安装吧&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package NLog -Version 4.5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后看到项目目录多了一个NLog.config文件。这里需要注意，右键设置一下这个NLog.config的属性为“始终复制”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214801467-1670483707.png&quot; alt=&quot;1532873688872&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;打开Nlog.config文件，看看里面的结构，发现有两个重要节点，一个是&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       autoReload=&quot;true&quot;
      throwExceptions=&quot;true&quot;
      internalLogLevel=&quot;Off&quot;&amp;gt;
  &amp;lt;targets&amp;gt;
    &amp;lt;target xsi:type=&quot;Null&quot; name=&quot;blackhole&quot; /&amp;gt;
    &amp;lt;target name=&quot;database&quot; xsi:type=&quot;Database&quot;
              dbProvider=&quot;MySql.Data.MySqlClient.MySqlConnection, MySql.Data&quot;
              connectionString=&quot;server=127.0.0.1;Database=nlog;user id=root;password=123456;SslMode=none&quot;
             &amp;gt;
      &amp;lt;!--
CREATE TABLE `log` (
  `Id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `Application` varchar(50) DEFAULT NULL,
  `Logged` datetime DEFAULT NULL,
  `Level` varchar(50) DEFAULT NULL,
  `Message` varchar(512) DEFAULT NULL,
  `Logger` varchar(250) DEFAULT NULL,
  `Callsite` varchar(512) DEFAULT NULL,
  `Exception` varchar(512) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

--&amp;gt;
      &amp;lt;commandText&amp;gt;
        insert into nlog.log (
        Application, Logged, Level, Message,
        Logger, CallSite, Exception
        ) values (
        @Application, @Logged, @Level, @Message,
        @Logger, @Callsite, @Exception
        );
      &amp;lt;/commandText&amp;gt;
      &amp;lt;parameter name=&quot;@application&quot; layout=&quot;NLogTestDemo&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@logged&quot; layout=&quot;${date}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@level&quot; layout=&quot;${level}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@message&quot; layout=&quot;${message}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@logger&quot; layout=&quot;${logger}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@callSite&quot; layout=&quot;${callsite:filename=true}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@exception&quot; layout=&quot;${exception:tostring}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

  &amp;lt;/targets&amp;gt;

  &amp;lt;rules&amp;gt;
    &amp;lt;!--Skip Microsoft logs and so log only own logs--&amp;gt;
    &amp;lt;logger name=&quot;Microsoft.*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;blackhole&quot; final=&quot;true&quot; /&amp;gt;
    &amp;lt;logger name=&quot;NLogTestDemo.*&quot; minlevel=&quot;Info&quot; writeTo=&quot;database&quot; /&amp;gt;
  &amp;lt;/rules&amp;gt;
&amp;lt;/nlog&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;上面的代码中我是以写入mysql为例进行的NLog配置。下面就可以进行简单地使用了。首先需要在。首先在Startup中的Configure中来加入中间件：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            //使用NLog作为日志记录工具
            loggerFactory.AddNLog();
            //引入Nlog配置文件
            env.ConfigureNLog(&quot;Nlog.config&quot;);
            //app.AddNLogWeb();
            app.UseMvc();
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在Program中进行如下配置：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
    {
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
            .UseNLog()
                .UseStartup&amp;lt;Startup&amp;gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;下面就可以在代码中愉快的玩耍了，&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly Logger nlog = LogManager.GetCurrentClassLogger(); //获得日志实;

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            nlog.Log(NLog.LogLevel.Debug, $&quot;yilezhu测试Debug日志&quot;);
            nlog.Log(NLog.LogLevel.Info, $&quot;yilezhu测试Info日志&quot;);
            try
            {
                throw new Exception($&quot;yilezhu故意抛出的异常&quot;);
            }
            catch (Exception ex)
            {

                nlog.Log(NLog.LogLevel.Error, ex, $&quot;yilezhu异常的额外信息&quot;);
            }
            return &quot;yilezhu的返回信息&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;下面运行起来项目，然到数据库里面就可以看到记录的日志信息如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214800844-711521626.png&quot; alt=&quot;1533303655993&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里大家可能会问，为什么没有Debug信息输出呢，这是因为我们上面NLog配置设置的记录日志的最低级别为Info.所以比Info级别小的Debug信息不会记录。如果想记录的话就把这个级别设置成Debug或者比Debug小的Trace就可以记录了。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214800211-816318726.png&quot; alt=&quot;1533303848950&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文开头讲述了分布式日志记录框架Exceptionless部署困难说起，然后引出轻量级简单易用的NLog日志框架，并通过一个简单地api项目讲述了NLog如何在Net Core中使用。并且给出了NLog日志记录在mysql中的使用配置。以及mysql的建表语句。希望能对大家有所参考！&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 13:51:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9416439.html</dc:identifier>
</item>
<item>
<title>基于Win10极简SonarQube C#代码质量分析 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9416376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9416376.html</guid>
<description>&lt;p&gt;博客有些好些时间未更新了，这几个月的时间里，离开了实习的公司、大学毕了业、来了新公司、转了户口，有点忙，最近总算稍微闲下来了，打算重新拾起博客，坚持写下去。&lt;/p&gt;
&lt;p&gt;言归正转，什么是SonarQube ?&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;SonarQube&lt;/strong&gt;（曾用名&lt;strong&gt;Sonar&lt;/strong&gt;（声纳））是一个优秀的开源代码分析系统管理系统，支持超过25+种编程语言，对.Net Core当然也是支持的。&lt;/p&gt;
&lt;p&gt;最近公司做的项目是用的Framework开发的，久仰SonarQube大名，今天在本地搭建SonarQube之后对项目进行分析，效果惊人。揪出了系统中潜藏的若干Bug,功不可没，所以在这里搭建的方法分享给大家，希望对大家有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213552776-1906527707.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213553399-1517244704.png&quot; alt=&quot;image&quot; width=&quot;782&quot; height=&quot;518&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在网上找一些资料，关于Sonar的介绍在Linux平台下较多，所以我下面的介绍主要是基于Win平台的，其他平台大同小异。&lt;/p&gt;
&lt;p&gt;安装Sonar主要有以下几步：&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;Sonar是一款基于JAVA开发的工具，安装JAVA SDK的过程在此不再叙述，建议安装好之后配置好JAVA_HOME的环境变量，以下是下载地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;首先到官网下载安装包，值得注意的是，该安装包是不分平台的，下载下来之后，选择Windows的文件夹中StartSonar.bat文件运行即可。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.sonarqube.org/#downloads&quot; href=&quot;https://www.sonarqube.org/#downloads&quot;&gt;https://www.sonarqube.org/#downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213553957-761521924.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213554170-86375700.png&quot; alt=&quot;image&quot; width=&quot;541&quot; height=&quot;232&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果java环境安装正常，Sonar应该是能正常启动的，启动后浏览。启动效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213554927-1364544695.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555198-1095559429.png&quot; alt=&quot;image&quot; width=&quot;559&quot; height=&quot;279&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚刚装好是英文的，我是安装了中文包，如何安装中文包，后面会叙述。&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;我们需要对Sonar进行简单配置，使其能连接上MySQL数据库。&lt;/p&gt;
&lt;p&gt;打开MySQL数据库，执行以下指令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt; sonar &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt;&lt;span&gt; utf8 COLLATE utf8_general_ci; 
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;USER&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;GRANT&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; sonar.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;GRANT&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; sonar.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
FLUSH &lt;/span&gt;&lt;span&gt;PRIVILEGES&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该操作是为Sonar创建数据库并添加该数据库的用户，数据库名称是sonar ,用户名是sonar，密码是sonar。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555414-113925061.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555634-237342991.png&quot; alt=&quot;image&quot; width=&quot;594&quot; height=&quot;147&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开sonar.properties将内容替换成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sonar.jdbc.username=sonar
sonar.jdbc.password=sonar
sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&lt;/span&gt;&lt;span&gt;&amp;amp;characterEncoding&lt;/span&gt;=utf8&lt;span&gt;&amp;amp;rewriteBatchedStatements&lt;/span&gt;=true&lt;span&gt;&amp;amp;useConfigs&lt;/span&gt;=maxPerformance&lt;span&gt;&amp;amp;useSSL&lt;/span&gt;=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中sonar.jbc.url是mysql数据库的连接字符串。&lt;/p&gt;
&lt;p&gt;重新启动Sonar(关闭运行startsonar.bat控制台，并在任务管理器中关闭所有和java有关的进程，重新运行startsonor.bat),使用管理员账户登录（admin/admin）。&lt;/p&gt;
&lt;p&gt;登录之后，安装中文包，如下，安装之后需要点击重新启动，启动之后，Sonar就变成中文的了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555882-253619850.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213556137-1448221060.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;下载并解压SonarQube Scanner for MSBuild，它是C# Framework的分析插件。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&quot; href=&quot;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&quot;&gt;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压之后，设置SonarQube Scanner for MSBuild的环境变量，如我的解压路径是：C:\MyWorkSpace\Tools\sonar-scanner-msbuild-4.3.1.1372-net46，则把该路径添加到path下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213556399-1080920025.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213558019-846940078.png&quot; alt=&quot;image&quot; width=&quot;799&quot; height=&quot;507&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改SonarQube.Analysis.xml文件&lt;/p&gt;
&lt;p&gt;要修改的地方只是关于sonarQube服务器的一些配置，关于服务器URL、USER、PASSWORD等，修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
  This file defines properties which would be understood by the SonarQube Scanner for MSBuild, if not overridden (see below)
  By default the SonarScanner.MSBuild.exe picks-up a file named SonarQube.Analysis.xml in the folder it
  is located (if it exists). It is possible to use another properties file by using the /s:filePath.xml flag

  The overriding strategy of property values is the following:
  - A project-specific property defined in the MSBuild *.*proj file (corresponding to a SonarQube module) can override:
  - A property defined in the command line (/d:propertyName=value) has which can override:
  - A property defined in the SonarQube.Analysis.xml configuration file [this file] which can override:
  - A property defined in the SonarQube User Interface at project level which can override:
  - A property defined in the SonarQube User Interface at global level which can't override anything.

  Note that the following properties cannot be set through an MSBuild project file or an SonarQube.Analysis.xml file:
  sonar.projectName, sonar.projectKey, sonar.projectVersion
  The following flags need to be used to set their value: /n:[SonarQube Project Name] /k:[SonarQube Project Key] /v:[SonarQube Project Version]

&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SonarQubeAnalysisProperties  &lt;/span&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsd&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.sonarsource.com/msbuild/integration/2015/1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.host.url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;http://localhost:9000&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 

  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Required only for versions of SonarQube prior to 5.2 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql://localhost:3306/sonar?useUnicode=true;characterEncoding=utf8;rewriteBatchedStatements=true;useConfigs=maxPerformance;useSSL=false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SonarQubeAnalysisProperties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，重要的一步，找到你电脑中的MSBuild.exe并添加到path环境变量，便于后面在命令行中调用MSBuild,我的是在vs 2017的安装目录下&lt;/p&gt;
&lt;p&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\15.0\Bin\amd64&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213558976-629642874.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213559410-932387153.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;657&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;CMD进入C#项目所在的&lt;span&gt;根目录&lt;/span&gt;，依此执行以下三条命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MSBuild.SonarQube.Runner.exe begin /k:&quot;xxh.xzc.api&quot; /n:&quot;xhh.xzc.api&quot; /v:&quot;1.0&quot;
MSBuild.exe /t:Rebuild
MSBuild.SonarQube.Runner.exe end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;/key(简写k)：对应projectKey即项目的唯一代码，如两套源代码使用同一个projectKey那扫描的结果将混在一起，所以一个项目需要有一个单独的projectKey&lt;/p&gt;
&lt;p&gt;/name(简写n)：对应projectName即项目的名称，为项目的一个显示的名称，建立使用完整的项目名称&lt;/p&gt;
&lt;p&gt;/version(简写v)：对应projectVersion即项目的版本，项目在不同的时期版本也是不一样的，如果方便，可以在sonarQube的服务器中查看到不同的版本代码其中问题的变化&lt;/p&gt;
&lt;p&gt;三条命令分别是分析的前期准备，MSBuild编译，将报告上传给SonarQube。&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601096-1965043271.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601366-74949686.png&quot; alt=&quot;image&quot; width=&quot;751&quot; height=&quot;486&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，进入&lt;a title=&quot;http://localhost:9000/projects&quot; href=&quot;http://localhost:9000/projects&quot;&gt;http://localhost:9000/projects&lt;/a&gt;  查看分析结果吧，惊喜不惊喜？&lt;/p&gt;
&lt;p&gt;界面中功能强大，很多认为绝对发现不了的Bug都展现出来了，还可以查看单元测试的覆盖率，相信如果坚持使用该工具，一定会对编码习惯有很大帮助。&lt;/p&gt;
&lt;p&gt;快快搭建一个SonarQube看看自己的代码有没有BUG!! &lt;img class=&quot;wlEmoticon wlEmoticon-openmouthedsmile&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601614-1899774408.png&quot; alt=&quot;大笑&quot;/&gt;&lt;/p&gt;



&lt;p&gt;参考文献：&lt;a title=&quot;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&quot; href=&quot;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&quot;&gt;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9416376.html</dc:identifier>
</item>
<item>
<title>AQS(AbstractQueuedSynchronizer)同步器的底层解析 - 上帝爱吃苹果-Soochow</title>
<link>http://www.cnblogs.com/keeya/p/9416094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keeya/p/9416094.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch等等&lt;strong&gt;是用来构建锁或者其他同步组件的基础框架&lt;/strong&gt;，它使用了一个volatile int state 成员变量表示&lt;strong&gt;同步状态&lt;/strong&gt;，通过内置的FIFO队列来完成资源获取线程的排队工作，该队列就是&lt;strong&gt;CLH同步队列&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其核心思想是，&lt;strong&gt;如果被请求的共享资源空闲&lt;/strong&gt;，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么&lt;strong&gt;就需要一套线程阻塞等待以及被唤醒时锁分配的机制&lt;/strong&gt;，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLH&lt;/strong&gt;(Craig,Landin,and Hagersten)队列是一个&lt;strong&gt;虚拟的双向队列&lt;/strong&gt;（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。&lt;strong&gt;AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;state的访问方式有三种:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getState()&lt;/li&gt;
&lt;li&gt;setState()&lt;/li&gt;
&lt;li&gt;compareAndSetState()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。&lt;/p&gt;
&lt;p&gt;自定义同步器实现时主要实现以下几种方法：&lt;/p&gt;
&lt;p&gt;同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入CLH同步队列，&lt;strong&gt;同时会阻塞当前线程(自旋判断自己是否要阻塞)&lt;/strong&gt;，当同步状态释放时，会把首节点中的线程唤醒（公平锁），使其再次尝试获取同步状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/338/1530782590x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530861936x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，&lt;strong&gt;因此设置头节点的方法并不需要使用CAS来保证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530861980x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;独占式状态获取&quot;&gt;独占式状态获取&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;独占式，同一时刻仅有一个线程持有同步状态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。&lt;strong&gt;在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态&lt;/strong&gt;，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获得同步状态操作&quot;&gt;获得同步状态操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。&lt;strong&gt;该方法自定义同步组件自己实现&lt;/strong&gt;，该方法必须要保证线程安全的获取同步状态。&lt;/li&gt;
&lt;li&gt;addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。&lt;/li&gt;
&lt;li&gt;acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。&lt;/li&gt;
&lt;li&gt;selfInterrupt：产生一个中断。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;acquire(int arg)方法为AQS提供的模板方法，该方法为独占式获取同步状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;acquireQueued方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        //中断标志
        boolean interrupted = false;
        //自旋过程——死循环
        for (;;) {
            //获得当前线程的前驱节点
            final Node p = node.predecessor();
            //如果当前线程的前驱节点是头节点，同步状态成功了
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);//设置头节点为自己（非CAS方法）
                p.next = null; // help GC
                failed = false;
                return interrupted;//在此处返回
            }
            //如果前驱节点不是首结点，或者同步失败，则判断是否阻塞当前线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    //获得前驱节点的状态
    int ws = pred.waitStatus;
    //如果前驱节点的等待状态是SIGNAL，表示当前节点将来可以被唤醒，那么当前节点就可以安全的挂起了，返回true
    if (ws == Node.SIGNAL)
        return true;
    //如果前驱结点状态大于0，表明节点已经超时或者被中断，需要移出队列
    if (ws &amp;gt; 0) {
        //移出队列逻辑并返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else {
        //上述条件都不符合则通过CAS将前驱节点设置为signal
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;shouldParkAfterFailedAcquire(Node pred, Node node)方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//停止自旋,等待将来被唤醒
    return Thread.interrupted();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。&lt;/li&gt;
&lt;li&gt;第二，维护同步队列的FIFO原则。&lt;br/&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530863186x-1404817575.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;释放同步状态操作&quot;&gt;释放同步状态操作&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当线程释放同步状态后，则需要唤醒该线程的后继节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            //唤醒后继节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}

private void unparkSuccessor(Node node) {
    //当前节点状态
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);
    //当前节点的后继节点
    Node s = node.next;
    //后继节点超时或者中断了
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        //从tail尾节点回溯找到第一个可用节点
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    //唤醒后继节点
    if (s != null)
        LockSupport.unpark(s.thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;共享式状态获取&quot;&gt;共享式状态获取&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。&lt;/strong&gt; 以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。这部分其实要看读写锁是怎么实现的，AQS只是提供了一个模板，具体共享是怎么实现的可以看读写锁的源码！&lt;br/&gt;&lt;img src=&quot;http://chuantu.biz/t6/350/1532867301x-1404817491.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tryAcquireShared(int)：&lt;strong&gt;共享方式&lt;/strong&gt;。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;AQS提供acquireShared(int arg)方法共享式获取同步状态，方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &amp;lt; 0)
        //获取失败则自旋获取同步状态
        doAcquireShared(arg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;private void doAcquireShared(int arg) {
    //共享式节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            //前驱节点
            final Node p = node.predecessor();
            //如果是前驱节点则尝试获取同步状态
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aqs应用举例&quot;&gt;AQS应用举例&lt;/h2&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;以ReentrantLock为例&lt;/strong&gt;，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再以&lt;strong&gt;CountDownLatch&lt;/strong&gt;以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如&lt;strong&gt;ReentrantReadWriteLock&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 12:12:00 +0000</pubDate>
<dc:creator>上帝爱吃苹果-Soochow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keeya/p/9416094.html</dc:identifier>
</item>
<item>
<title>redux源码解读（二） - 渔歌</title>
<link>http://www.cnblogs.com/yugege/p/9416059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/9416059.html</guid>
<description>&lt;p&gt;之前，已经写过一篇&lt;a href=&quot;https://github.com/zhanyuzhang/chess-blogs/issues/3&quot;&gt;redux源码解读（一）&lt;/a&gt;，主要分析了 &lt;code&gt;redux&lt;/code&gt; 的核心思想，并用100多行代码实现一个简单的 &lt;code&gt;redux&lt;/code&gt; 。但是，那个实现还不具备合并 &lt;code&gt;reducer&lt;/code&gt; 和添加 &lt;code&gt;middleware&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;p&gt;今天我们一起来看看合并 &lt;code&gt;reducer&lt;/code&gt; （即 &lt;code&gt;combineReducers&lt;/code&gt;） 的原理和实现。&lt;/p&gt;
&lt;p&gt;在分析原理之前，先来看看&lt;code&gt;combineReducers&lt;/code&gt; 的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { createStore, combineReducers } from 'redux';
const addScore = (state, action) =&amp;gt; {};
const deleteScore = (state, action) =&amp;gt; {};
const rootReducer = combineReducers({addStore, deleteScore});
const store = createStore(rootReducer);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可以看出，&lt;code&gt;combineReducers&lt;/code&gt; 接收的参数类型是一个原生对象，其中这个对象的每个键值都是一个 &lt;code&gt;reducer&lt;/code&gt; 纯函数。另外，因为 &lt;code&gt;combineReducer()&lt;/code&gt; 返回的结果可以传递给&lt;code&gt;createStore&lt;/code&gt;作为参数，可以推出它返回的结果也是一个 &lt;code&gt;reducer&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;了解了 &lt;code&gt;combineReducer&lt;/code&gt; 用法之后 ，那开始一步一步的用代码来实现其功能吧。&lt;/p&gt;
&lt;p&gt;首先，需要先声明 &lt;code&gt;combineReducers&lt;/code&gt; 的参数，然后判断传进来的参数是不是原生对象类型（ &lt;code&gt;plain object&lt;/code&gt; ），如果不是，则抛出异常，如果是，则需要获取该对象的所有属性（key）并存放到变量 &lt;code&gt;reducerKeys&lt;/code&gt; 里面，然后对这些key进行遍历，过滤掉那些不是函数的值，并将结果放到 &lt;code&gt;finalReducerKeys&lt;/code&gt; 里面。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default function combineReducers(reducers) {
  // 判断参数reducers是否为对象
  if(Object.prototype.toString.call(reducer) !== '[object Object]') {
    throw new Error('combineReducers expected plain object params');
  }

  const reducerKeys = Object.keys(reducers);
  let finalReducerKeys = [];
  // 过滤掉value不是Function类型的键名，然后将结果放到fianlReducerKeys里面
  reducerKeys.forEach((key, i) =&amp;gt; {
    if(typeof reducers[key] === 'function') {
      finalReducerKeys.push(key);
    }
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面已经提到过了 &lt;code&gt;combineReducers&lt;/code&gt; 返回的结果是一个纯函数。那这个返回的函数需要处理些什么逻辑呢？因为他合并了其他的 &lt;code&gt;reducers&lt;/code&gt;，所以需要遍历这些 &lt;code&gt;reducer&lt;/code&gt; 并执行他们。然后，并对比一下执行 &lt;code&gt;reducer&lt;/code&gt; 之后的数据有没有变化 ，如果有变化则返回新的 &lt;code&gt;state&lt;/code&gt;， 否则直接返回之前的 &lt;code&gt;state&lt;/code&gt;。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default function combineReducers(reducers) {
  // 省略和前面相同的部分

  // 返回一个新的、经过组合的reducer函数
  return function(state = {}, action) {
    let hasChanged = false;
    const nextState = {};
    // 遍历finalReducerKeys，并调用对应的reducer。
    finalReducerKeys.forEach((key, i) =&amp;gt; {
      const stateForKey = state[key];
      const nextStateForKey = reducers[key](stateForKey, action);
      nextState[key] = nextStateForKey;
      // 如果前后状态不一样，则hasChanged设为true
      if(stateForKey !== nextStateForKey) {
        hasChanged = true;
      }
    });
    // 如果有变化，则返回新的state，否则返回旧的
    return hasChanged ? nextState : state;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，《&lt;code&gt;redux&lt;/code&gt; 源码解读（二）》就写到这里，今天周五啦，祝大家周末愉快哈！如果对 &lt;code&gt;combineReducer&lt;/code&gt;还有不明白的地方，欢迎留言讨论哈。另外，可能有些地方我分析得不到位的，建议到我的github去下载代码自己再好好研究一下。重要的事情说三遍：&lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;! &lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;! &lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;!&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 12:03:00 +0000</pubDate>
<dc:creator>渔歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/9416059.html</dc:identifier>
</item>
<item>
<title>一个微服务框架的细节 - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/9415768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/9415768.html</guid>
<description>&lt;p&gt;  &lt;span&gt;KingWorks微服务系列文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）&lt;a href=&quot;https://www.cnblogs.com/wcd144140/p/6991394.html&quot; target=&quot;_blank&quot;&gt;一个微服务框架的故事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）&lt;a href=&quot;https://www.cnblogs.com/wcd144140/p/7617402.html&quot; target=&quot;_blank&quot;&gt;一个微服务框架的情节&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从KingWorks-0.0.0版本（想象版本）开始，我就知道我踏上了一条“不归的自主研发路线”，到目前的KingWorks-3.0.0，我始终坚守着这一份执着。曾经想过放弃，因为它不是“开源主流”；曾经想过放弃，因为它很费力；曾经想过放弃，因为为了让它生命力不断，我需要付出的精力比专研几个新框架还要累得累。我坚守了，是因为它的简单；我坚守了，是因为同事们的喜欢；我坚守了，是因为它让我的心血在许多一线系统中滚滚流动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803181728580-1009863087.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务初心&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们微服务是为了把“大事化小小事化无”，但问题往往是从“小事作大”，如果我们以“微服务”理念从事小捉起，虽不可避免未来不确定性，但至少可以抵御历史风险。从过去经验可以知道，一个系统的成长基本要经历“单体-集群-分布式”的发展模式，前提是你开发的系统生命力足够强大。我们都知道，“微服务”是一种分布式架构，一个小小的应用系统直接“分布式”感觉未免有点“关公刀削苹果”，但如何避免一百个“小生命”当中有那么其中一两个可以粗壮成长所带来的痛楚呢？也就是说，如何用一个“微服务”理念的架构更简单、便捷与高效地去孵化一个个从0到N的关键机会。如果一个系统的每一个发展阶段都需要大动干戈，除了资金成本外，最重要的还是时间成本，综合来说，这都是试错成本。这已经不是一个“如何把一个大问题解决”的问题，而是一个“如何解决由一个小问题发展到大问题等一些列问题”的问题。我相信没有天生的大问题，每一个创（chuang）新（ye）都是一个从小到大的试错过程，如何把试错成本降到最低，是我最为关心的问题，因为机会是留个有准备的人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803181932430-1139614150.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 最简单、便捷以及高效的理想状态就是系统发展过程的一个“趋0变动”。也就是系统从“单体”到“集群”，再从“集群”到“微服务”的发展过程中无须改动（过多）代码即可简单达到各种支撑模式的切换。为了达到这种效果，我想到了“容器”的概念。例如Docker容器或JVM容器，它们提供的只是“单元”运行的环境，轻松聚合和分离单例的运行。从“微服务”理念看，“服务”作为我们业务的“执行单元”，同样可以存在一个微服务应用容器，给个“服务单元”提供轻量级的运行环境，从而达到轻松聚合和分离服务的可能性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182010150-1348233740.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KingWorks-MSAC（微服务应用容器，以下简称“微容器”）是我们KingWorks微服务框架的核心组件，它主要有六大功能特点，分别是映射、驱动、代理、管控、管理以及适配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;映射：&lt;/strong&gt;按照规则可以根据URI访问路径信息分发到指定的服务处理当中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;驱动：&lt;/strong&gt;激活每个框架约定下的服务线程执行单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代理：&lt;/strong&gt;代理执行应用六大生命周期模块组件，如初始化模块组件、销毁模块组件、业务前置模块组件、业务逻辑模块组件、业务后置模块组件以及定时器模块组件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管控：&lt;/strong&gt;对服务生命周期内的状态进行统一管控，如服务注册、服务注销、服务发现、服务心跳、服务访问限制、服务并发限制以及远程配置同步等状态行为；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;管理：&lt;/strong&gt;对服务信息的统一管理，如服务单元信息、统一配置信息、服务列表信息以及各种服务状态信息；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;适配器：&lt;/strong&gt;服务与“外界”联系的中间件统称“适配器”，如数据量连接组件、Redis连接组件、远程访问。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182307396-1336460267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上单元服务工程的构建目录结构主要是基于KingWorks微服务框架的高约束和高标准的体现，具体说明如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务目录：一个服务的身份和标准定义（com.kingworks.xxxsop/smp），其中xxx为服务标识，如以上例子，test就是本演示服务的标识，smp/sop为服务类型，smp代表面向信息管理服务、sop代表面向业务支撑服务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块组件目录：&lt;/strong&gt;是服务初始化、销毁以及业务前、后置模块组件的父目录；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;销毁模块组件目录：&lt;/strong&gt;是服务进程销毁时执行的模块单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;初始化模块组件目录：&lt;/strong&gt;是服务进程初始化时执行的模块单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务后置模块组件目录：&lt;/strong&gt;是服务线程在执行业务逻辑模块组件后执行的模块单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务前置模块组件目录：&lt;/strong&gt;是服务线程在执行业务逻辑模块组件前执行的模块单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务处理模块组件目录：&lt;/strong&gt;是服务业务处理的核心逻辑单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定时器模块组件目录：&lt;/strong&gt;是服务整个生命周期内运行的定时器执行模块单元；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器会根据以上约定分别在容器内扫描服务单元以及服务单元内各模块执行的组件单元。此外，微容器可以通过两种方式识别出服务单元，一种就是以上的“明文工程”模式，也就是源码工程；而另一种是jar包形式，可以对服务源码工程打包成“kingworks-xxxsmp/sop-v.jar”格式的jar引入容器工程里，其中xxx就是服务标识，而v就是服务版本号，这也就是所谓的微服务插件化架构模式。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：service&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182343390-1117137126.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;testsop为本（微）服务演示样例，其中kingwors-msac-3.0.0就是我们的微容器，Talk is cheap，show the code：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182407873-1708863429.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务），通过以下URI即可访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182428355-6758652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：serviceBefore&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; serviceBefore模块组件顾名思义也就是service业务处理模块执行前的一个前置执行组件单元，有点类似于Filter的角色，Demo如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182457323-387464568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务），通过以下URI即可访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182522248-991173650.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：serviceAfter&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; serviceBefore模块组件顾名思义也就是service业务处理模块执行后的一个后置执行组件单元，如果结合业务前置模块来使用，这就是一种约定的AOP模式，Demo如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182603387-2095085818.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务），通过以下URI即可访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182623990-20401421.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：contextInitialized&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; contextInitialized是服务单元初始化时容器会扫描执行的模块组件单元，Demo如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182653031-1592765190.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182714179-1583714642.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：contextDestroyed&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; contextDestroyed是服务单元销毁时容器会扫描执行的模块组件单元，Demo如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182800074-1773513025.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182821528-1899172658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务样例：timer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; timer是服务单元在启动时会扫描执行的模块组件单元，在整个服务生命周期内执行，Demo如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182851204-36713442.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动微容器（服务）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182911725-2043016408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务管控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 其实“微容器”本身也是一个拥有标准服务单元目录结构的服务，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803182946266-1344875598.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器的所有管控行为都是一样通过服务标准六大模块组件单元执行管控的，例如“服务的注册”是在容器服务的初始化模块组件中执行，“服务的注销”是在容器服务的销毁模块组件中执行，“服务的心跳”、“服务的发现”以及“远程配置同步”都是在容器服务的定时器模块组件中执行，“服务的访问限制”和“服务的并发限制”都是在服务前置模块组件中执行的。此外，容器还拥有自身的service业务处理单元（“^KINGWORKS_000”业务标识归属于容器服务所有），这些业务处理单元暴露了容器的一些基本管控和信息输出，如远程配置实时更新通知、容器服务状态信息查询等，如下Demo所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183006382-1678634647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183016331-1986769128.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 微容器除了对基本的服务属性、状态信息等基本服务信息管理外，还充当了统一信息配置与统一RPC服务信息管理两大“功能”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【服务属性信息】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;namespace：命名空间，容器内置默认值为default&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;serverCode：服务标识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP：协议地址，当IP为空时，容器动态获取本地IP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;port：服务端口，容器内置默认值为80&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;scope：服务范围（private：自己可见|default：同命名空间可见|protect：同命名空间或子命名空间可见|public：所有服务可见），容器内置默认值为default&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;zone：服务领域（私域标识），当[zone=public]时，表示该服务为公域信息配置（非服务实例，不能注册，混合云关键点所在），容器内置默认值为default&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;weight：服务权重（0~9），容器内置默认值为2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【服务状态信息】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务总体并发以及各业务处理并发信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务网关调用状态信息（如RPC连接池信息、服务熔断次数、RPC状态信息等）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库连接池实体状态信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis连接池实例状态信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kafka连接池实体状态信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【统一信息配置】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器规范约束的配置文件有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kingworks.properties：微容器服务基本信息管理与控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rdc.yml：服务注册发现中心静态配置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;datasource.properties：关系数据库配置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;redis.properties：Redis配置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;kafka.properties：Kafka配置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上五大配置文件的配置规范都是微容器有一定的要规范配置格式，如关系数据库配置信息文件，poolName就是数据库连接池实例名称，如果没有特别指定，微容器的数据适配器组件（后续会介绍）默认会先选择poolName=serverCode的数据库连接池实例，如果不存在则匹配寻找poolName=default的数据库连接池实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183109615-1531182068.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统一信息配置除了统一静态解析之外，还可以通过配置conf服务进行动态解析，无论是静态解析还是远程动态解析，对服务内部调用来说完全是透明的。服务内部实现还可以通过对文件变动的动态监听，以便实时做出处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183128304-919632482.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【统一RPC服务信息管理】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rdc.yml（服务注册发现中心信息配置文件）就是RPC匹配的一个服务信息中心，当系统初期阶段为“单体模式”的时候，可以通过走“静态服务解析”模式，也就是把所有的服务信息填写（注册）在这个文件下即可达到本地静态服务注册发现中心的效果。就算后续服务模式扩展改成动态加载模式，只需要配置rdc服务即可，对服务业务调用逻辑来说完全是透明的，无须改动任何一行代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183200075-1964059591.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【统一日志信息输出管理】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器对日志输出一共有三种规范化约定模式，分别是标准输出、文件输出、流输出（Kafka）三种模式，可通过kingworks.properties文件进行配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183221568-1299133898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器的日志输出管理是通过logback引擎自定义以上三种日志模式Appender，有着高约束和规范的日志属性和输出格式（JSON）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183247604-570849884.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（微）服务适配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微容器把服务以外的对接中间件工具组件统称“适配器”，例如数据库连接适配器，Redis连接适配器组件，远程过程调用适配器组件等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【数据库连接适配器】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库连接适配器组件是微容器高约束规则并基于标准化原生JDBC的API进行封装的，具体使用如下Demo所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183321723-2117854011.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上Demo是通过testsop服务的KINGWORKS_001_001_002业务实现单元实现的，通过URI访问即可删除相关查询信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183343969-1618708770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【远程过程调用适配器组件】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微服务跟传统系统最大的一个差别之一就是服务的信息交互已经多样化，例如数据库、内存数据库、服务与服务之间交付等，已经弱化了传统数据源的概念，这也是“适配器”统称的来源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183410252-838349286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要微容器存在服务信息（无论是本地静态解析还是远程动态解析），RPCClient即可根据serverCode、serviceCode以及请求参数即可进行服务远程过程调用，其中调用过程的一些列动作如负载、路由、降级、服务访问权限、以及夸私有云访问等过程都已经被RPCClient封装起来，我们可以通过kingworks.properties配置文件对服务远程过程调用进行个性化配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183432833-1915340985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183445417-662433582.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务切面服务：BASESMP/SOP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; basesop是所有sop服务的基础切面服务，basesmp是所有smp服务的基础切面服务，何为基础切面服务，请看下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183542168-75282047.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上述介绍可以知道，微容器本身也内置了一个框架（Framework）级别的服务，其实框架服务、基础切面服务以及业务服务的各个模块的执行过程和顺序就如上图所示。严格来说，基础SMP/SOP切面服务是所有SMP/SOP的切面服务，那么微容器框架服务是所有服务的最顶层切面服务。基础切面服务跟框架服务一样，不是一个独立的业务服务，更多是所有业务服务的上一层抽象。例如所有SMP服务都会有一个公共的前置操作（如会话验证），可以通过BASESMP的serviceBefore实现即可达到所有SMP服务的公共前置操作。其它组件一样道理，但有一点跟微容器框架服务有点相似，基础切面服务的service如果实现了某业务逻辑实现，那么此业务逻辑实现的标识不会在其它业务服务上生效，因为为容器先会在基础切面服务检测才到业务服务检测。以下测试是在testsop服务的基础上新增一个basesop服务的引用，basesop服务的所有组件实现跟testsop服务一样，具体演示过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183601192-2094142934.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动服务后，我们通过console的打印信息观察testsop服务与basessp服务之间的关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183615897-1511723698.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183630830-365510819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183650598-428617401.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183705329-1149150408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; KingWorks微容器抽象了服务单元的实现，让应用系统架构的模式切换对服务来说完全是透明的，当系统在“单体”模式的时候，更多是处于一种静态服务解析模式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183729154-126334756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当应用系统规模到一定程度时，可以对原单体应用模式进行扩展，进入分布式模式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183754005-2063850660.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;分布式模式并不代表一定使用服务动态解析（服务远程注册发现中心），如果业务相抵稳定，其实还是可以保留rdc.yml配置文件的静态解析，省去了动态的成本和不确定性。如果系统发展到一定业务规模，其实系统还可以发展成为混合云分布式模式：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183825692-141159247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于KingWorks微服务“zone”和“scope”属性的定义，可以让不同私有域的服务通过公有域的入口进行远程相互调用。&lt;strong&gt;在微容器的支撑下，最为突出和困难反而是对服务业务领域边界的定义与抽象的设计&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 微服务总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 以上的总结，仅仅只是微容器的一些基本玩法，受限于自己的文章篇幅控制，更多好玩的玩法和思路以后会慢慢分享。同样由于诸多因素的受限和考虑，暂时无法公开源码，但我更愿意分享和记录整个解决问题的思考过程。其实，KingWorks已经不仅仅只是一个框架，它承载更多地是我解决问题的一种思维方式的体现，它的内涵也不仅仅只是通过KingWorks微容器的数千行代码就能体现，基于KingWorks之上的，还有一整套基于微服务（应用）云上运用“云开发”模式的一个“应用云容器” ......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/758472/201808/758472-20180803183904470-722248226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 10:43:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/9415768.html</dc:identifier>
</item>
<item>
<title>Consul在.Net Core中初体验 - 蓝夏</title>
<link>http://www.cnblogs.com/bluesummer/p/9415764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluesummer/p/9415764.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在阅读本文前我想您应该对微服务架构有一个基本的或者模糊的了解&lt;/p&gt;
&lt;p&gt;Consul是一个服务管理软件，它其实有很多组件，包括服务发现配置共享键值对存储等&lt;/p&gt;
&lt;p&gt;本文主要讲解Consul的服务注册服务发现以及集群的配置&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/younger_china/article/details/79462530&quot; class=&quot;uri&quot; title=&quot;Consul系列文章索引&quot;&gt;https://blog.csdn.net/younger_china/article/details/79462530&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/6286207.html&quot; class=&quot;uri&quot; title=&quot;搭建consul 集群&quot;&gt;https://www.cnblogs.com/shanyou/p/6286207.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务发现&quot;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;假设有服务A,B,C.服务A需要调用服务B和C，传统的方式我们需要在服务A中记录服务B和C的ip及端口号。这些配置一般写在配置文件等地方存储。&lt;/p&gt;
&lt;p&gt;这种做法有两个显而易见的缺点：1.如果将来B的ip改变了就需要修改所有调用者的ip配置。 2.难以做负载均衡&lt;/p&gt;
&lt;p&gt;而服务发现就是用来解决这个问题的，怎么解决呢？请看下面这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1017082/201808/1017082-20180803183306391-1757972929.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图中在服务消费者和服务生产者之间加了一个服务注册中心的模块，用上面的服务器ABC来举例，服务B在发布的时候会在注册中心注册，注册中心会记录服务B的名字及ip地址。当服务A请求服务B的时候，只需要带着服务B的名字来注册中心查询即可。集群情况下，注册中心会有多个服务B。同时注册中心会定期检查每一个服务否可以正常访问，移除不可访问的服务。（健康检查）&lt;/p&gt;
&lt;p&gt;总的来说，服务发现就是通过一个标志来获取服务列表，并且服务列表可随着每个服务的上线或下线动态变更&lt;/p&gt;
&lt;h2 id=&quot;consul术语及解释&quot;&gt;Consul术语及解释&lt;/h2&gt;
&lt;p&gt;下面列出几个consul中出现频率较高的术语&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;&lt;strong&gt;Agent&lt;/strong&gt;，Agent是长期运行在每个consul集群成员节点上守护进程。通过命令consul agent启动。Agent有client和server两种模式。由于每个节点都必须运行agent，所有节点要么是client要么是server。所有的Agent都可以可以调用DNS或HTTP API，并负责检查和维护服务同步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client&lt;/strong&gt; 运行client模式的Agent，将所有的RPCs转发到Server。Client是相对无状态的。Client唯一所做的是在后台参与LAN gossip pool。只消耗少量的资源，少量的网络带宽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt; 运行Server模式的Agent，参与Raft quorum，维护集群的状态，响应RPC查询，与其他数据中心交互WAN gossip，转发查询到Leader或远程数据中心。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;datacenter&lt;/strong&gt; 数据中心的定义似乎是显而易见的，有一些细节是必须考虑的。例如，在EC2，多个可用性区域是否被认为组成了单一的数据中心？我们定义数据中心是在同一个网络环境中——私有的，低延迟，高带宽。这不包括基于公共互联网环境，但是对于我们而言，在同一个EC2的多个可用性区域会被认为是一个的数据中心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;关于client和server我搞了好久才搞明白，实际上client不存储数据，发送到client的请求，client都会转发给它绑定的server，也就是说client必须绑定server。server会存储数据，如果只有一个server并在上面注册了一个服务，这个server挂了然后你又重启了，那么这个服务的注册信息仍然保存在server上。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果你在一台服务器上运行了一个server，它会默认有一个client绑定到server上，并且地址是127.0.0.1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;consul安装&quot;&gt;consul安装&lt;/h2&gt;
&lt;p&gt;consul下载地址：&lt;a href=&quot;https://www.consul.io/downloads.html&quot; class=&quot;uri&quot; title=&quot;https://www.consul.io/downloads.html&quot;&gt;https://www.consul.io/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我用的win10 系统，所以下载的最后一个windows64位的，下载下来有个exe文件，随便放个到一个文件夹下就可以了。&lt;/p&gt;
&lt;p&gt;进入cmd，转到consul的存放目录，打命令就可以了。&lt;/p&gt;
&lt;p&gt;或者可以把consul的目录路径加入到Path环境变量中，就不用每次到目录下打命令了&lt;/p&gt;
&lt;h2 id=&quot;启动consul&quot;&gt;启动consul&lt;/h2&gt;
&lt;p&gt;上面说过，consul可以以client和server的方式启动&lt;/p&gt;
&lt;p&gt;Server：consul agent -server -bootstrap-expect 1 -data-dir=C:\consul -node=n1 -bind=192.168.3.233 -ui-dir=C:\consul\dist -client=0.0.0.0&lt;/p&gt;
&lt;p&gt;Client：consul agent -bootstrap-expect 1 -data-dir=C:\consul -node=n1 -bind=192.168.3.233 -ui-dir=C:\consul\dist&lt;/p&gt;
&lt;p&gt;把&lt;strong&gt;-server&lt;/strong&gt;去掉就是client模式了&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;consul agent：启动consul的命令，要么是server要么是client&lt;/li&gt;
&lt;li&gt;-bootstrap-expect：期望的server节点数目，如果集群中的server节点小于这个数据，集群则失效，并且该server也失效，一直等到集群中的数目达到相应的数量才生效，如果是1的话，代表一个server就可以了&lt;/li&gt;
&lt;li&gt;-data-dir：data存放的目录，server会保存一些配置缓存等信息，存在此目录下&lt;/li&gt;
&lt;li&gt;-node：该节点的名称，急群众名称必须唯一&lt;/li&gt;
&lt;li&gt;-client：代表该server对外暴漏的client地址，0.0.0.0代表我可以通过：127.0.0.1和192.168.3.233访问，不设置的话默认是：127.0.0.1&lt;/li&gt;
&lt;li&gt;-bind:这是设置集群中server之间互相通信的地址，必须可以互相访问到&lt;/li&gt;
&lt;li&gt;-ui-dir：设置webui的界面，理论上通过命令可以查看到我们需要的任何信息，但是通过ui来查看更直观&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;搭建集群&quot;&gt;搭建集群&lt;/h2&gt;
&lt;p&gt;我开启了两台虚拟机和本机一共是三台机器，所以我搭建了三个server节点&lt;/p&gt;
&lt;p&gt;Ser1：consul agent -server -bootstrap-expect=3 -data-dir=C:\consul -node=node1 -bind=192.168.3.233 -client=0.0.0.0&lt;/p&gt;
&lt;p&gt;Ser2：consul agent -server -bootstrap-expect=3 -data-dir=C:\consul -node=node2 -join=192.168.3.233 -bind=192.168.3.201 -client=0.0.0.0&lt;/p&gt;
&lt;p&gt;Ser3: consul agent -server -bootstrap-expect=3 -data-dir=C:\consul -node=node3 -join=192.168.3.233 -bind=192.168.3.243 -client=0.0.0.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-join&lt;/strong&gt;：表示加入到哪个集群内，ser2中我们指定加入到了ser1中，这时候ser1和ser2组成了集群，ser3我们可以指定加入到ser1和ser2，不管加入哪个最终这三个server都组成了一个集群，最终三个server商量了一下选出了一个leader&lt;/p&gt;
&lt;h2 id=&quot;服务注册&quot;&gt;服务注册&lt;/h2&gt;
&lt;p&gt;可以通过命令来注册服务，因为最终是要在.net core上使用，所以我就直接贴上.net core中的相关代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime appLifeTime)
    {
        string ip = Configuration[&quot;ip&quot;];
        string port = Configuration[&quot;port&quot;];
        string serviceName = &quot;MsgService&quot;;
        string serviceId = serviceName + Guid.NewGuid();
        Action&amp;lt;ConsulClientConfiguration&amp;gt; ConsulConfig = (config) =&amp;gt;
         {
             config.Address = new Uri(&quot;http://192.168.3.201:8500&quot;); //服务注册的地址，集群中任意一个地址
             config.Datacenter = &quot;dc1&quot;;
         };
        using (var consulClient = new ConsulClient(ConsulConfig))
        {
            AgentServiceRegistration asr = new AgentServiceRegistration
            {
                Address = ip,
                Port = Convert.ToInt32(port),
                ID = serviceId,
                Name = serviceName,
                Check = new AgentServiceCheck
                {
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),
                    HTTP = $&quot;http://{ip}:{port}/api/Health&quot;,//健康检查访问的地址
                    Interval = TimeSpan.FromSeconds(10),   //健康检查的间隔时间
                    Timeout = TimeSpan.FromSeconds(5),     //多久代表超时
                },
            };
            consulClient.Agent.ServiceRegister(asr).Wait();
        }
        //注销Consul 
        appLifeTime.ApplicationStopped.Register(() =&amp;gt;
        {
            using (var consulClient = new ConsulClient(ConsulConfig))
            {
                consulClient.Agent.ServiceDeregister(serviceId).Wait();  //从consul集群中移除服务
            }
        });
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序后向consul集群注册了一个服务，访问集群的任何一个ip都可取到该服务的ip。客户端查询服务的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; static void Main(string[] args)
    {
        using (var consul = new Consul.ConsulClient(c =&amp;gt;
        {
            c.Address = new Uri(&quot;http://192.168.3.233:8500&quot;); //Consul地址
        }))
        {
            var services = consul.Catalog.Service(&quot;MsgService&quot;).Result.Response;

            foreach (var s1 in services)
            {
                Console.WriteLine($&quot;ID={s1.ServiceID},Service={s1.ServiceName},Addr={s1.Address},Port={s1.ServicePort}&quot;);
            }

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们一个基本的consul集群就可以正常使用了&lt;/p&gt;
&lt;p&gt;对于consul和服务发现目前还只是刚刚开始接触。还是有很多问题暂时没有搞明白。&lt;/p&gt;
&lt;p&gt;比如客户端连接的server突然挂了怎么办如何切换到另一个server？以及一个服务下线了如何通知客户端删除缓存等等。还请大家不吝赐教&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 10:39:00 +0000</pubDate>
<dc:creator>蓝夏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluesummer/p/9415764.html</dc:identifier>
</item>
<item>
<title>《前端之路》之 前端图片 类型 &amp; 优化 &amp; 预加载 &amp; 懒加载 &amp; 骨架屏 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/9415733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/9415733.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前端图片-类型-优化-预加载-懒加载-骨架屏&quot;&gt;前端图片 类型 &amp;amp; 优化 &amp;amp; 预加载 &amp;amp; 懒加载 &amp;amp; 骨架屏&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;这是一篇关于在前端开发中 与图片相关的一些常见问题，回想一下，我们在日常的开发过程中前端与图片打交道的次数可以说是比所有开发职位都要多吧。特别是在 nodeJs 盛行以后。

从我们最开始学习前端的那一天，我们是不是认识了 一个叫 &amp;lt;img /&amp;gt; 的 标签，这个标签的 src 属性可以引用对应路径的图片，然后手动刷新页面，我们的图片就显示在了页面上了， 哇～ 大学的教师里大家都不约而同的发出了哇的声音，回想起来还是历历在目啊～

那么 从业前端 这个岗位也这么多年了，总结一下在前端中与图片打交道的一些经验或者总结吧&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一-前端图片的类型&quot;&gt;一、 前端图片的类型&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;jpg、png、gif、base64、字体图标。貌似日常开发中，我们常常会用到的就说这些了。

那我们来纵向的来统计一下图片的类型 和 这些类型的图片在不同场景下有哪些优缺点。

（ 因为本身对于图片的理解度还是不够的，所以询问了公司的 UI设计师的小姐姐们来帮忙答疑解惑 ）&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;矢量图-和-位图&quot;&gt;1.1、矢量图 和 位图&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;先上和UI部门的小姐姐的聊天～&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675289/201808/675289-20180801162405143-20694085.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;其实我觉得 小姐姐的回答 可以说是非常容易懂了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;矢量图：&lt;/code&gt; 一般来说矢量图表示的是几何图形，文件相对较小，并且放大缩小不会失真。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;用途：SVG，图标字体font-awesome&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;位 图：&lt;/code&gt; 位图又叫像素图或栅格图，它是通过记录图像中每一个点的颜色、深度、透明度等信息来存储和显示图像。 放大会失真（变模糊）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;用途：png,gif,jpg,canvas&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;有损压缩-和-无损压缩&quot;&gt;1.2、有损压缩 和 无损压缩&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675289/201808/675289-20180801172640157-636907593.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;有损压缩&lt;/code&gt;是对图像数据进行处理，去掉那些图像上会被人眼忽略的细节，然后使用附件的颜色通过渐变或其他形式进行填充。&lt;code&gt;适用于&lt;/code&gt;: JPG。 从字面意义上理解就是 对图片会有一定的损伤。像素的损伤，从而压缩了 图片的体积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无损压缩&lt;/code&gt;是先判断图像上哪些区域的颜色是相同的，哪些是不同的，然后把这些相同的数据信息进行压缩记录，而把不同的数据另外保存。&lt;code&gt;适用于&lt;/code&gt;: PNG。对于图片的压缩也会造成一定的损伤，但是相对有限。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;看完上面的 对比，仿佛发现了&lt;code&gt;上帝是公平的&lt;/code&gt; 开了一扇门，也关上了一扇窗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;透明度&quot;&gt;1.3、透明度&lt;/h5&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;索引透明&lt;/p&gt;
&lt;p&gt;即布尔透明，类似于GIF，某一个像素只有全透和全不透明两者效果，不能对透明度进行设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Alpha透明&lt;/p&gt;
&lt;p&gt;半透明，可以设置 0～100 的透明度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;常用图片格式&quot;&gt;1.4、常用图片格式&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;JPN 、PNG、 GIF&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;新图片格式---webp&quot;&gt;1.5、新图片格式 - WebP&lt;/h5&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;出自于谷歌，是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式VP8。&lt;/p&gt;
&lt;p&gt;具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。&lt;/p&gt;
&lt;p&gt;具备了无损和有损的压缩模式&lt;/p&gt;
&lt;p&gt;支持Alpha透明以及动画的特性&lt;/p&gt;
&lt;p&gt;在JPEG和PNG的转化效果都非常优秀，稳定和统一。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;base64-图片格式&quot;&gt;1.6、Base64 图片格式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;如何生成 Base64 格式的图片&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var reader = new FileReader(),htmlImage;
reader.onload = function(e){
    //e.target.result 就是base64编码
    htmlImage = '&amp;lt;img src=&quot;' + e.target.result + '&quot;/&amp;gt;';
}
reader.readAsDataURL(file);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;优缺点：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;br/&gt;减少HTTP请求&lt;br/&gt;没有图片更新要重新上传，清理缓存的问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;br/&gt;增加了CSS文件的尺寸&lt;br/&gt;编码成本&lt;/p&gt;
&lt;h4 id=&quot;二-前端中图片相关的优化处理&quot;&gt;二、 前端中图片相关的优化处理&lt;/h4&gt;
&lt;h5 id=&quot;经常会用到的方法&quot;&gt;2.1 经常会用到的方法：&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;图片大小与展示区一致 （图片大小合适不过多浪费下载资源）&lt;/li&gt;
&lt;li&gt;GIF转为PNG8 （减少gif 体积）&lt;/li&gt;
&lt;li&gt;缩略图（大图片，先加载一张缩略图）（避免页面中图片的位置出现长时间的空白，影响用户体验）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;三预加载&quot;&gt;三、预加载&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;3.1、原理&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 通过CSS或者JavaScript，先请求图片到本地，再利用浏览器的缓存机制，当要使用图片时（图片路径一致），浏览器直接从本地缓存获取到图片，加快图片的加载速度。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;3.2、场景&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;背景，幻灯片，相册等，将要展示的前一张和后一张优先下载&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;3.3、优缺点&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果都在首页进行预加载肯定会加长首页加载时间，首屏加载变慢，影响体验。
但是在 http2 来临的时候这个问题，应该可以很有效的进行一个解决。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;3.4、实现方法&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;#preload{ backgroud: url(./01.png) no-repeat -9999px -9999px;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这个方法加载图片会同页面的其他内容一起加载，增加了页面的整体加载时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JS&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
let img = document.createElement('img')
img.src = './02.png'
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let img = new Image()
img.src = './01.png'

// 但是这种方法是无法添加的 DOM 树中去的。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四-懒加载&quot;&gt;四、 懒加载&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;4.1、原理&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当要使用到图片时，再加载图片，而不是一下子加载完所有的图片的方式，来提高页面其他图片的加载速度。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;4.2、场景&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前页面的图片数量过多，且页面长度很长。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;4.3、JS 实现&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;思路很简单，一般都是在页面上添加一个滚动条事件，判断图片位置与浏览器顶部的距离是否小于（可视高度+滚动距离），如果小于则优先加载。

下面我们就基于 react 来进行懒加载的实现。

或者可以查看 github 地址：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/Run-react/tree/master/app/pages/lazyLoad&quot;&gt;github传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码如下:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    componentDidMount() {

        const lazyload = (options) =&amp;gt; {
            // 获取图片外部dom
            let doc = options.id ? document.getElementById(options.id) : document
            if (doc === null) return
            // 获取当前dom 内，所有的图片标签
            let tmp = doc.getElementsByTagName('img')
            let tmplen = tmp.length
            let imgobj = []

            // 判断当前 元素是否到了应该显示的 位置
            const isLoad = (ele) =&amp;gt; {
                let scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop
                if (typeof ele === 'undefined') return false
                let edit = ~~ele.getAttribute('data-range') || options.lazyRange
                let clientHeight = scrollTop + document.documentElement.clientHeight + edit
                let offsetTop = 0
    
                while (ele.tagName.toUpperCase() !== 'BODY') {
                    offsetTop += ele.offsetTop
                    ele = ele.offsetParent
                }
                return (clientHeight &amp;gt; offsetTop)
            }

            // 给已经到了可以显示图片位置的 img 标签添加 src 值
            const setimg = (ele) =&amp;gt; {
                ele.src = ele.getAttribute('data-src')
            }

            // 遍历当前 dom 内所有要显示的 img 标签
            for (let i = 0; i &amp;lt; tmplen; i++) {
                var _tmpobj = tmp[i]
                if (_tmpobj.getAttribute('data-src') !== null) {
                    if (isLoad(_tmpobj)) {
                        setimg(_tmpobj)
                    } else {
                        imgobj.push(_tmpobj)
                    }
                }
            }

            // 滚动的时候动态 判断当前 元素的是否 可以赋值
            let len = imgobj.length
            const handler = () =&amp;gt; {
                for (let i = 0, end = len; i &amp;lt; end; i++) {
                    let obj = imgobj[i]
                    if (isLoad(obj)) {
                        _setimg(obj)
                        imgobj.splice(i, 1)
                        len--
                        if (len === 0) {
                            loadstop()
                        }
                    }
                }
            }
    
            // 根据上下文要求动态低进行 图片 src 赋值
            const _setimg = (ele) =&amp;gt; {
                if (options.lazyTime) {
                    setTimeout(function () {
                        setimg(ele)
                    },
                    options.lazyTime + ~~ele.getAttribute('data-time'))
                } else {
                    setimg(ele)
                }
            }
            
            // 去除 滚动事件监听
            const loadstop = () =&amp;gt; {
                window.removeEventListener ? window.removeEventListener('scroll', handler, false) : window.detachEvent('onscroll', handler)
            }
    
            loadstop()
            // 添加滚动事件监听
            window.addEventListener ? window.addEventListener('scroll', handler, false) : window.attachEvent('onscroll', handler)
        }

        lazyload({
            id: 'imgs',
            lazyTime: 200,
            lazyRange: 100
        })
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上的基础上，其实可以进行很好的 &lt;code&gt;组件化&lt;/code&gt; 的操作。 是一个 很好的面向对象的一个 JS 代码的实现的例子。后面的文章当中。我们也会加大 JS 中 OOP 相关文章的篇幅，敬请期待～&lt;/p&gt;
&lt;h4 id=&quot;五-骨架屏首屏加载优化&quot;&gt;五、 骨架屏（首屏加载优化）&lt;/h4&gt;
&lt;p&gt;今天终于要讲到我们的主角了， &lt;code&gt;骨架屏&lt;/code&gt;。 终于不是首页进去就是加载一个 &lt;code&gt;菊花&lt;/code&gt;了，让你成为 &lt;code&gt;菊外人&lt;/code&gt;了。而是一个 科技感满满的的 &lt;code&gt;骨架屏&lt;/code&gt; 。 好了，话不多说，开始今天的讨论吧！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5.1、原理&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5.2、场景&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5.3、JS实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;5.4、优缺点&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不知不觉已经下班了，周五了，就先回家，争取晚上再完善跟新一下～&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Github传送门，欢迎 Star - -&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%08%E4%B9%8B%E8%B7%AF/09%EF%BC%9A%20%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%20%E7%B1%BB%E5%9E%8B%20%26%20%E4%BC%98%E5%8C%96%20%26%20%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%20%26%20%E6%87%92%E5%8A%A0%E8%BD%BD%20%26%20%E9%AA%A8%E6%9E%B6%E5%B1%8F.md&quot;&gt;Github地址，欢迎 Star&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 10:32:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/9415733.html</dc:identifier>
</item>
</channel>
</rss>