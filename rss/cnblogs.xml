<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Lucene-Query的使用及其索引库的维护 - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/9398964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/9398964.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene是使用Query对象执行查询的, 由Query对象生成查询的语法. 如bookName:java, 表示搜索bookName域中包含java的文档数据.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;query对象的两种创建方法&quot;&gt;1.1 Query对象的两种创建方法&lt;/h2&gt;
&lt;h3 id=&quot;使用query子类对象&quot;&gt;1.1.1 使用Query子类对象&lt;/h3&gt;
&lt;h4 id=&quot;常用的query子类对象&quot;&gt;1.1.1.1 常用的Query子类对象&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;TermQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不使用分析器, 对关键词做精确匹配搜索. 如:订单编号、身份证号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;NumericRangeQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;数字范围查询, 比如: 图书价格大于80, 小于100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;BooleanQuery&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;布尔查询, 实现组合条件查询. 组合关系有: 1. MUST与MUST: 表示“与”, 即“交集” 2. MUST与MUST NOT: 包含前者, 排除后者 3. MUST NOT与MUST NOT: 没有意义 4. SHOULD与MUST: 表示MUST, SHOULD失去意义 5. SHOULD与MUST NOT: 等于MUST与MUST NOT 6. SHOULD与SHOULD表示“或”, 即“并集”&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;常用的query子类对象使用&quot;&gt;1.1.1.2 常用的Query子类对象使用&lt;/h4&gt;
&lt;h5 id=&quot;使用termquery&quot;&gt;1.1.1.2.1 使用TermQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书名称中包含java的图书.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 搜索索引(封装搜索方法)
 */
private void seracher(Query query) throws Exception {
    // 打印查询语法
    System.out.println(&quot;查询语法: &quot; + query);
    
    // 1.创建索引库目录位置对象(Directory), 指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
    
    // 2.创建索引读取对象(IndexReader), 用于读取索引
    IndexReader reader = DirectoryReader.open(directory);
    
    // 3.创建索引搜索对象(IndexSearcher), 用于执行搜索
    IndexSearcher searcher = new IndexSearcher(reader);  

    // 4. 使用IndexSearcher对象执行搜索, 返回搜索结果集TopDocs
    // 参数一:使用的查询对象, 参数二:指定要返回的搜索结果排序后的前n个
    TopDocs topDocs = searcher.search(query, 10);

    // 5. 处理结果集
    // 5.1 打印实际查询到的结果数量
    System.out.println(&quot;实际查询到的结果数量: &quot; + topDocs.totalHits);
    // 5.2 获取搜索的结果数组
    // ScoreDoc中有文档的id及其评分
    ScoreDoc[] scoreDocs = topDocs.scoreDocs;
    
    for (ScoreDoc scoreDoc : scoreDocs) {
        System.out.println(&quot;= = = = = = = = = = = = = = = = = = =&quot;);
        // 获取文档的id和评分
        int docId = scoreDoc.doc;
        float score = scoreDoc.score;
        System.out.println(&quot;文档id= &quot; + docId + &quot; , 评分= &quot; + score);
        
        // 根据文档Id, 查询文档数据 -- 相当于关系数据库中根据主键Id查询数据
        Document doc = searcher.doc(docId);
        System.out.println(&quot;图书Id: &quot; + doc.get(&quot;bookId&quot;));
        System.out.println(&quot;图书名称: &quot; + doc.get(&quot;bookName&quot;));
        System.out.println(&quot;图书价格: &quot; + doc.get(&quot;bookPrice&quot;));
        System.out.println(&quot;图书图片: &quot; + doc.get(&quot;bookPic&quot;));
        System.out.println(&quot;图书描述: &quot; + doc.get(&quot;bookDesc&quot;));
    }
    
    // 6. 关闭资源
    reader.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试使用TermQuery:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用TermQuery: 需求: 查询图书名称中包含java的图书
 */
@Test
public void testTermQuery() throws Exception {
    //1. 创建TermQuery对象
    TermQuery termQuery = new TermQuery(new Term(&quot;bookName&quot;, &quot;java&quot;));
    // 2.执行搜索
    this.seracher(termQuery);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233454131-917596653.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;使用numericrangequery&quot;&gt;1.1.1.2.2 使用NumericRangeQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书价格在80-100之间的图书(不包含80和100):&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用NumericRangeQuery: 需求: 查询图书价格在80-100之间的图书
 */
@Test
public void testNumericRangeQuery() throws Exception{
    // 1.创建NumericRangeQuery对象, 参数说明: 
    // field: 搜索的域; min: 范围最小值; max: 范围最大值
    // minInclusive: 是否包含最小值(左边界); maxInclusive: 是否包含最大值(右边界)
    NumericRangeQuery numQuery = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, false, false);

    // 2.执行搜索
    this.seracher(numQuery); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233520895-829754029.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试包含80和100:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 测试包含80和100

NumericRangeQuery numQuery = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, true, true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233535883-1029468024.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;使用booleanquery&quot;&gt;1.1.1.2.3 使用BooleanQuery&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;需求: 查询图书名称中包含Lucene, 并且价格在80-100之间的图书.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用BooleanQuery: 需求: 查询图书名称中包含Lucene, 且价格在80-100之间的图书
 */
@Test
public void testBooleanQuery() throws Exception {
    // 1.创建查询条件
    // 1.1.创建查询条件一
    TermQuery query1 = new TermQuery(new Term(&quot;bookName&quot;, &quot;lucene&quot;));
    
    // 1.2.创建查询条件二
    NumericRangeQuery query2 = NumericRangeQuery.newFloatRange(&quot;bookPrice&quot;, 80f, 100f, true, true);
    // 2.创建组合查询条件
    BooleanQuery bq = new BooleanQuery();
    // add方法: 添加组合的查询条件
    // query参数: 查询条件对象
    // occur参数: 组合条件
    bq.add(query1, Occur.MUST);
    bq.add(query2, Occur.MUST);
    
    // 3.执行搜索
   this.seracher(bq);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询语法中, &quot;+&quot;表示并且条件, &quot;-&quot;表示不包含后面的条件:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233551268-970801123.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用queryparser&quot;&gt;1.1.2 使用QueryParser&lt;/h3&gt;
&lt;p&gt;说明: 使用QueryParser对象解析查询表达式, 实例化Query对象.&lt;/p&gt;
&lt;h4 id=&quot;queryparse表达式语法&quot;&gt;1.1.2.1 QueryParse表达式语法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;关键词基本查询: 域名+&quot;:&quot;+关键词, 比如: bookname:lucene&lt;/li&gt;
&lt;li&gt;范围查询: 域名+&quot;:&quot;+[最小值 TO 最大值], 比如: price:[80 TO 100]. &lt;strong&gt;需要注意QueryParser不支持数字范围查询, 仅适用于字符串范围查询. 如果有数字范围查询需求, 请使用NumericRangeQuery.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;组合查询:&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.MUST&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件必须满足, 相当于AND&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.SHOULD&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件可选, 相当于OR&lt;/td&gt;
&lt;td&gt;空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Occur.MUST_NOT&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;搜索条件不能满足, 相当于NOT非&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;使用queryparser-1&quot;&gt;1.1.3 使用QueryParser&lt;/h3&gt;
&lt;p&gt;需求: 查询图书名称中包含java, 并且图书名称中包含&quot;Lucene&quot;的图书.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试使用QueryParser: 需求: 查询图书名称中包含Lucene, 且包含java的图书
 */
@Test
public void testQueryParser() throws Exception {
    // 1.创建查询对象
    // 1.1.创建分析器对象
    Analyzer analyzer = new IKAnalyzer();
    // 1.2.创建查询解析器对象
    QueryParser qp = new QueryParser(&quot;bookName&quot;, analyzer);
    // 1.3.使用QueryParser解析查询表达式
    Query query = qp.parse(&quot;bookName:java AND bookName:lucene&quot;);
    
    // 2.执行搜索
    this.seracher(query);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233712304-564682659.jpg&quot; width=&quot;60%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意: 使用QueryParser, 表达式中的组合关键字AND/OR/NOT必须要大写. 设置了默认搜索域后, 若查询的域没有改变, 则可不写.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;数据保存在关系型数据库中, 需要实现增、删、改、查操作; 索引保存在索引库中, 也需要实现增、删、改、查操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;增加索引&quot;&gt;2.1 增加索引&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://www.cnblogs.com/shoufeng/p/9367789.html&quot;&gt;Lucene-入门程序及Java API的简单使用&lt;/a&gt; 中的内容:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233725702-1570320147.jpg&quot; width=&quot;45%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除索引&quot;&gt;2.2 删除索引&lt;/h2&gt;
&lt;h3 id=&quot;根据term删除索引&quot;&gt;2.2.1 根据Term删除索引&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 用于指定索引库的位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引;&lt;/li&gt;
&lt;li&gt;创建删除条件对象(Term);&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行删除;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 根据Term删除索引
 */
@Test
public void deleteIndexByTerm() throws IOException {
    // 1.创建分析器对象(Analyzer), 用于分词
    Analyzer analyzer = new IKAnalyzer(); 

    // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
    IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);

    // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
    
    // 4.创建索引写入对象(IndexWriter), 用于操作索引
    IndexWriter writer = new IndexWriter(directory, iwc);
    
    // 5.创建删除条件对象(Term)
    // 删除图书名称域中, 包含&quot;java&quot;的索引
    // delete from table where name=&quot;java&quot;
    // 参数一: 删除的域的名称, 参数二: 删除的条件值
    Term term = new Term(&quot;bookName&quot;, &quot;java&quot;); 

    // 6.使用IndexWriter对象, 执行删除
    // 可变参数, 能传多个term
    writer.deleteDocuments(term);
  
   // 7.释放资源
    writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据Term执行删除操作(&lt;strong&gt;indexWriter.deleteDocuments(term)&lt;/strong&gt;)时, &lt;strong&gt;要求对应的Field不能分词且只能是一个词, 且这个Field必须索引过&lt;/strong&gt;, Lucene将先去搜索, 然后将所有满足条件的记录删除(伪删除, 做了&quot;.del&quot;标记) -- 最好定义一个唯一标识来做删除操作.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233905132-480067076.jpg&quot; width=&quot;25%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否删除索引, 需要分情况讨论: 我们知道, Lucene是以段(segment)来组织索引内容的, 通过Term执行删除操作(indexWriter.deleteDocuments(term))时, 若索引段中仍包含符合条件的文档对象的其他分词的索引, 就会保留整个索引数据(若采取更新操作, 则会降低性能), 如果没有, 则也将删除索引数据:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731233857746-963949999.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看删除了的文档的编号:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234057152-902287296.jpg&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除全部索引慎用&quot;&gt;2.2.2 删除全部索引(慎用)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 指定索引库位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引库;&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行删除;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 删除全部索引
*/
@Test
public void deleteAllIndex() throws IOException {
   // 1.创建分析器对象(Analyzer), 用于分词
   Analyzer analyzer = new IKAnalyzer();

   // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
   IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);
   
   // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
   Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));
   
   // 4.创建索引写入对象(IndexWriter), 用于操作索引
   IndexWriter writer = new IndexWriter(directory, iwc);
   
   // 5.使用IndexWriter对象, 执行删除
   writer.deleteAll();
   
   // 6.释放资源
  writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除后的索引结果:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234113496-232488901.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;删除全部索引, 将文档域的数据, 索引域的数据都删除.&lt;/p&gt;
&lt;p&gt;类似于关系型数据库的Truncate删除: 完全删除数据, 包括存储结构, 因而更快速.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;更新索引&quot;&gt;2.3 更新索引&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene是根据Term对象更新索引: 先根据Term执行查询, 查询到则执行更新, 查询不到则执行添加索引.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建分析器对象(Analyzer), 用于分词;&lt;/li&gt;
&lt;li&gt;创建索引配置对象(IndexWriterConfig), 用于配置Lucene;&lt;/li&gt;
&lt;li&gt;创建索引库目录对象(Directory), 用于指定索引库的位置;&lt;/li&gt;
&lt;li&gt;创建索引写入对象(IndexWriter), 用于操作索引库;&lt;/li&gt;
&lt;li&gt;创建文档对象(Document);&lt;/li&gt;
&lt;li&gt;创建Term对象;&lt;/li&gt;
&lt;li&gt;使用IndexWriter对象, 执行更新;&lt;/li&gt;
&lt;li&gt;释放资源.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 更新索引
 */
@Test
public void updateIndexByTerm() throws IOException{
    // 1.创建分析器对象(Analyzer), 用于分词
    Analyzer analyzer = new IKAnalyzer();
   
    // 2.创建索引配置对象(IndexWriterConfig), 用于配置Lucene
    IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_4_10_4, analyzer);   

    // 3.创建索引库目录对象(Directory), 用于指定索引库的位置
    Directory directory = FSDirectory.open(new File(&quot;/Users/healchow/Documents/index&quot;));   

    // 4.创建索引写入对象(IndexWriter), 用于操作索引
    IndexWriter writer = new IndexWriter(directory, iwc);
 
    // 5.创建文档对象(Document)
    Document doc = new Document();
    doc.add(new TextField(&quot;id&quot;, &quot;1234&quot;, Store.YES));
    // doc.add(new TextField(&quot;name&quot;, &quot;MyBatis and SpringMVC&quot;, Store.YES));
    doc.add(new TextField(&quot;name&quot;, &quot;MyBatis and Struts2&quot;, Store.YES)); 

    // 6.创建Term对象
    Term term = new Term(&quot;name&quot;, &quot;SpringMVC&quot;); 

    // 7.使用IndexWriter对象, 执行更新
    writer.updateDocument(term, doc);
   
    // 8.释放资源
    writer.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次执行, 由于没有查找到对应的索引, 故执行添加功能, 结果如图(不区分大小写):&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234129306-1488602472.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次执行时, 由于索引库中已有&lt;strong&gt;&quot;name&quot;=&quot;SpringMVC&quot;&lt;/strong&gt;的内容, 故执行更新操作: 将整个TextField的内容:&lt;strong&gt;&quot;MyBatis and Struts2&quot;&lt;/strong&gt;添加到索引库中, 并与上次的结果合并, 结果如下图示:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1438655/201807/1438655-20180731234143699-1293111662.jpg&quot; width=&quot;70%&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若第二次执行时更改了Term中name域的条件值(索引中没有对应的), 将继续执行添加功能: 将整个TextField中的内容添加到索引中.&lt;/p&gt;
&lt;blockquote readability=&quot;16.067073170732&quot;&gt;
&lt;h3 id=&quot;版权声明&quot;&gt;版权声明&lt;/h3&gt;
&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;http://www.cnblogs.com/shoufeng/&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但未经博主同意必须保留此段声明, 且在文章页面明显位置给出原文链接, 否则博主保留追究法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:45:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/9398964.html</dc:identifier>
</item>
<item>
<title>做程序员的这五年 - 海角在眼前</title>
<link>http://www.cnblogs.com/lovesong/p/9398952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesong/p/9398952.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/555379/201807/555379-20180731233155553-1773790022.png&quot; alt=&quot;&quot; width=&quot;100%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    到昨天为止，做程序员，已经整整五年。最近半年来，我时常思考我走过这五年，反思我的职业工作，反思我的生活，我选择错了很多，也做错了很多。有些道理，到最近才幡然醒悟，遂决定谈谈我个人对软件工作的看法，以及一些生活的感悟。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;苦苦攒钱的年轻人&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    我还在苦苦地攒钱，也许有人不信，我当初一万二的收入，每个月能存一万。我花钱不多，也有些克制自己的欲望，但这就导致我很多想做的事情不敢去做。&lt;/p&gt;
&lt;p&gt;    想学吉他，想报健身班，想去进修课程，想有段长时间的旅游等等。都没有去做，并不是没有钱去做，而是怕尝试太费钱，万一我只是三分钟热度呢？&lt;/p&gt;
&lt;p&gt;    可是就是这种心理，丢失了太多的可能性，看到的风光太过狭隘，一直过着一种平庸的生活。我总觉得，以后要买房买车娶媳妇，这钱还远远不够呢。&lt;/p&gt;
&lt;p&gt;    到这几个月，我才醒悟，我根本没有为自己而活，我把自己困在牢笼中，望着我想尝试的东西，即便是那些可能不需费多少钱。我这种行为，限制自己的心，也限制自己成长。明明心心念念且合理的需求，却不去做，苦苦攒钱至今，实在是太愚蠢了，以至于到如今，我没有一件值得纪念的事情。&lt;/p&gt;
&lt;p&gt;    年轻时，对自己投资太重要了，磨刀都还不误砍柴工。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作的格局&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    工作上更是不堪回首，倒不是做得多差，而是只会埋头工作，却忽略了长远的规划发展。一个人在一个位置做得太久，导致格局太小，眼界太窄。做的东西太熟悉了，用的东西也长久不变。不过问题不在于技术上，技术只是实现需求的方式，这并不重要。眼界格局才是年轻人最需拓宽的。&lt;/p&gt;
&lt;p&gt;    我相信面过试的人，都会被问到一个问题，那就是，“你想做什么东西？”以前的我，是不知道怎么回答的，也不在意，你叫我做什么我就做什么。而现在，我会认真了解自己能做什么，想做什么，想往哪个方向走，薪酬不再是最需要考虑的事情。&lt;/p&gt;
&lt;p&gt;    懂得自己要做什么，老板想让自己做什么。人如果只是被动接受任务，是没有多大进步的。从分配的任务，分析到老大为什么这么分，考虑点在哪，该做到什么效果，继而推导出更好的方案。从任务的执行者，变成指派者的角度去看问题，这才算成长。&lt;/p&gt;
&lt;p&gt;    在职业规划方面，我觉得，年轻人，就该多出去见见世面，多看看别人做的东西。可能你在这家工作所做的好，到了另一家公司，就变成下等了。我是在这几个月才明白这个道路，但也有些晚了。&lt;/p&gt;
&lt;p&gt;    水往低处流，人往高处走，遇见强者，自己才能更强。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台的重要性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    两个相差无几的产品，在不同平台上的效果可能差距非常大。有些时候，我们的技术能力不错，做的产品也不错，但就是卖得不好，原因就在于平台。&lt;/p&gt;
&lt;p&gt;    换句话说，就是小公司没办法跟大公司拼，特别做大众产品。我如今做的产品，虽然是行业里最早投入研发的，但公司没有能够像阿里、腾讯这种大公司做推广，一直都默默无闻。虽然后来有点起色，但等到大公司也开始着手做这一类产品，就被远远的抛下。&lt;/p&gt;
&lt;p&gt;    另外，也是公司能支援的有限，投入的人力也不能与大公司比拟。大公司发展的速度非常快，以至于到后来，我们需要反过来学习这些大公司的产品。这是个硬伤，成员的素质也因成本问题，无法雇佣更有能力的人，也就没法做出优秀的产品，这也使得领导“无人可用”。&lt;/p&gt;
&lt;p&gt;    到最后，我们还在只能卖项目，被项目推着走，做成一个伪产品。&lt;/p&gt;
&lt;p&gt;    我倒不是在抱怨公司的无能为力，只是有些感叹，软件产品，也是越来越不好做了，BAT这三座大山，已经将很多路子生生切断。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;人到三十&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    再过两年，我就要三十了。虽然现在还是孑然一身，有些许积蓄，但也不免有些担忧未来。&lt;/p&gt;
&lt;p&gt;    如果是刚入职场，倒也还有几年可以拼搏莽撞；如果已有老婆孩子，其实路已经是确定了。对于后一种，我没能有什么建议，对于前一种，我的建议是，去冲去闯，无论是工作还是生活。我这一类人，倒也是另一种典型的分类，似乎有很多选择，也似乎没有选择。&lt;/p&gt;
&lt;p&gt;    一个人，在一座大都市，走到了十字路口，前方有几条路，犹豫不决，怕走下去，就再回不了头了。 &lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>海角在眼前</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesong/p/9398952.html</dc:identifier>
</item>
<item>
<title>Cocos文档案例游戏设计的梳理与分析 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/9397622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/9397622.html</guid>
<description>&lt;p&gt;    &lt;span&gt;&lt;em&gt;导语：这是一篇新手教程，适用于已看完&lt;/em&gt;Cocos官方文档&lt;em&gt;，但还对游戏设计、运行流程不熟悉的新人。这篇教程是对文档【快速上手】里那款名叫&quot;&lt;/em&gt;摘星星&lt;em&gt;&quot;的坑爹小游戏(文档原话)流程的梳理，以期望见微知著，得到游戏设计的一些普适性的方法，为看完文档仍然迷迷糊糊的新人提供一个游戏制作、运行的大体方向。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一、游戏元素&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743168-284103117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1、图片资源&lt;/h3&gt;
&lt;p&gt;    ·背景图 background&lt;/p&gt;
&lt;p&gt;    ·开始按钮 btn_play&lt;/p&gt;
&lt;p&gt;    ·主角 PurpleMonster&lt;/p&gt;
&lt;p&gt;    ·地面 ground&lt;/p&gt;
&lt;p&gt;    ·星星 star&lt;/p&gt;
&lt;h3&gt;2、场景&lt;/h3&gt;
&lt;p&gt;        ·Game&lt;/p&gt;
&lt;h3&gt;    3、脚本&lt;/h3&gt;
&lt;p&gt;        ·Game.js&lt;/p&gt;
&lt;p&gt;        ·Player.js&lt;/p&gt;
&lt;p&gt;        ·Star.js&lt;/p&gt;
&lt;h3&gt;    4、字体及声音&lt;/h3&gt;
&lt;p&gt;        ·jump&lt;/p&gt;
&lt;p&gt;        ·score&lt;/p&gt;
&lt;p&gt;        ·mikado_outline_shadow&lt;/p&gt;
&lt;h3&gt;    5、预制资源&lt;/h3&gt;
&lt;p&gt;        ·Star&lt;/p&gt;

&lt;h2&gt;二、游戏场景&lt;/h2&gt;
&lt;p&gt;    场景Game:&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743422-813678844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    官方：在 Cocos Creator 中，游戏场景（Scene）是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        ·场景图像和文字（Sprite，Label）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;·角色&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;·以组件形式附加在场景节点上的游戏逻辑脚本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;    &lt;/em&gt;1、渲染根节点——Canvas&lt;/h3&gt;
&lt;p&gt;        可以理解为一块要展示的黑板，后续需要添加的各种资源都会在这块&quot;黑板&quot;上。&lt;/p&gt;
&lt;h3&gt;    2、背景图——background&lt;/h3&gt;
&lt;p&gt;        在这款游戏中，可以理解为整个游戏的背景。&lt;/p&gt;
&lt;h3&gt;    3、地面——ground&lt;/h3&gt;
&lt;p&gt;        地面覆盖了一部分背景图，也算是整个游戏静态背景的一部分。&lt;/p&gt;
&lt;h3&gt;    4、角色——Player&lt;/h3&gt;
&lt;h3&gt;    5、分数——Score&lt;/h3&gt;
&lt;h3&gt;    6、层级渲染关系&lt;/h3&gt;
&lt;p&gt;        &lt;span&gt;&lt;span&gt;显示在下方的节点的渲染顺序是在上方节点的后面，也就是说下方的节点是在上方节点之后绘制的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;三、脚本&lt;/h2&gt;
&lt;h3&gt;    1、游戏逻辑脚本——Game.js&lt;/h3&gt;
&lt;p&gt;        Game.js的内容可分为四部分，分别是属性、onload函数、update函数与其他函数。&lt;/p&gt;
&lt;h4&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;            a. star预制资源&lt;/p&gt;
&lt;p&gt;            b. star消失时间范围&lt;/p&gt;
&lt;p&gt;            c. 地面节点&lt;/p&gt;
&lt;p&gt;d. Play节点&lt;/p&gt;
&lt;p&gt;e. Label分数节点&lt;/p&gt;
&lt;p&gt;f.得分音效&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·onLoad函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;&lt;span&gt;&lt;span&gt;onLoad&lt;/span&gt;&lt;span&gt;方法会在场景加载后立刻执行，初始化相关的操作和逻辑都放在这里面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 得到地面坐标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 初始化计时器&lt;/p&gt;
&lt;p&gt;            c. 生成新的星星&lt;/p&gt;
&lt;p&gt;            d. 初始化计分&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·update函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;&lt;span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;在场景加载后就会每帧调用一次，一般把需要经常计算或及时更新的逻辑内容放在这里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            a. 计时器更新&lt;/p&gt;
&lt;p&gt;            b. 超时判断&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·其他函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 生成星星&lt;/p&gt;
&lt;p&gt;            b. 生成星星的随机位置&lt;/p&gt;
&lt;p&gt;            c. 得分&lt;/p&gt;
&lt;p&gt;            d. 游戏结束&lt;/p&gt;
&lt;h3&gt;    2、Player节点脚本——Player.js&lt;/h3&gt;
&lt;p&gt;        这个脚本绑定的是场景元素Player，也包含属性、onload函数、update函数与其他函数。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 跳跃高度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 跳跃持续时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 移速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;d. 加速度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;e. 音效资源&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·onload函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 执行跳跃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 监听初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 加速度&lt;/p&gt;
&lt;p&gt;            d. 水平速度&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·update函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 速度更新&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 速度限制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 位置更新&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·其他函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 跳跃&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 输入控制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 播放声音&lt;/p&gt;
&lt;h3&gt;    3、Star节点脚本——Star.js&lt;/h3&gt;
&lt;p&gt;        star.js为Star预制资源的脚本。Star预制资源为脚本Game.js属性Star的引用。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;·属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 星星与player的距离&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. Game对象引用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        ·onLoad&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 根据属性a判断位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 星星的生成与销毁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;c. 调用得分方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        ·update&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;a. 判断距离&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            &lt;/strong&gt;b. 星星透明度的变化&lt;/p&gt;
&lt;h2&gt;四、小游戏分析&lt;/h2&gt;
&lt;h3&gt;    1、白话文版本&lt;/h3&gt;
&lt;p&gt;        在一个背景图中有一个会不断跳跃的小妖怪，并且场景里会随机生成一个星星。当小妖怪把星星吃掉时，星星消失，得分加一，并生成新的星星，星星消失时仍然没有被吃掉，小妖怪GG，游戏结束。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;2、正式版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        绑定到根节点的Game.js脚本负责游戏主逻辑，它负责生成背景图（background&amp;amp;ground）等各种资源（见Game.js属性），以及不同资源的调配（见Game.js函数）。场景中有一只会不断跳跃（Player.js）的小妖怪（Player）供玩家操作。场景随机产生（脚本中动态生成）一个星星（见star.js函数b）。当玩家按下键盘上的键时，触发Player节点的输入控制函数（Player.js.其他函数.b），对输入进行筛选，并更改加速度及方向的属性。当星星与Player的距离小于属性规定的距离时，星星消失，加一分，再生成新的星星。当星星超时消失，游戏结束。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;3、图示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233743785-40602678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、游戏设计流程的梳理&lt;/h2&gt;
&lt;p&gt;    在这个游戏中，我们可以看到这款游戏得以运行的三要素（资源、脚本、场景）。其中资源和场景负责游戏的视觉、图像效果，而脚本则是串联各资源，既可以是单个元素的脚本（Player.js），也可以是整个游戏流程、规则的脚本（Game.js）。&lt;/p&gt;
&lt;p&gt;    除了上述提到 的游戏运行需要的条件，一个游戏的推出还需要其他要素的支持，如激励、剧情、交互等。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1219242/201807/1219242-20180731233744346-1672020250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、改进与进阶&lt;/h2&gt;
&lt;h3&gt;    1、在原游戏模式上的改进&lt;/h3&gt;
&lt;p&gt;        ·对触屏事件的处理。（&lt;span&gt;&lt;span&gt;cc.Node.EventType.TOUCH_START&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;·加入菜单模块，添加重新开始、暂停、退出等功能。&lt;/p&gt;
&lt;p&gt;·加入手游摇杆（见附录）。&lt;/p&gt;
&lt;p&gt;        ·加入边界，限制Player移到屏幕外。&lt;/p&gt;
&lt;h3&gt;    2、略微改变游戏模式的案例——贪吃蛇&lt;/h3&gt;
&lt;p&gt;        ·星星改为食物，该模块可直接复制。&lt;/p&gt;
&lt;p&gt;        ·加入手游摇杆，控制蛇身移动。&lt;/p&gt;
&lt;p&gt;        ·重新定义蛇身类。&lt;/p&gt;
&lt;p&gt;        ·基于案例小游戏的贪吃蛇正在酝酿之中，挖坑后填。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;附录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    手游摇杆系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75141161&quot;&gt;四方向摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75268705&quot;&gt;八方向摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            ·&lt;a href=&quot;https://blog.csdn.net/xufeng0991/article/details/75332160&quot;&gt;跟随式摇杆&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:38:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/9397622.html</dc:identifier>
</item>
<item>
<title>Confluence 6 任务的类型 - huyuchengus</title>
<link>http://www.cnblogs.com/huyuchengus/p/9398922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huyuchengus/p/9398922.html</guid>
<description>&lt;p&gt;下面是有关你可以调整的计划任务列表。&lt;/p&gt;

&lt;table class=&quot;wrapped confluenceTable tablesorter tablesorter-default&quot;&gt;&lt;tbody readability=&quot;46.292890075224&quot;&gt;&lt;tr readability=&quot;5.71875&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;Confluence 备份（Back Up Confluence）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;对 Confluence 站点执行&lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/Configuring+Backups&quot;&gt;备份&lt;/a&gt;操作。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;At 2am every day&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;检查集群安全（Check Cluster Safety）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;针对集群方式的 Confluence 安装，这个计划任务将会保证在集群中只有一个 Confluence 节点向数据库中写入信息。&lt;br/&gt;针对标准方式（非集群方式）版本的 Confluence，这个任务被用来警告用户，谁错误的连接到第二个 Confluence 数据库实例，这个数据库已经被一个 Confluence 使用了。in use.&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;Every 30 seconds&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;清理 Journal 实体（Clean Journal Entries）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;周期化的清理 journal  实体，这个能够保证数据的大小能够保持正常的增长速度而避免过度膨胀。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每节点（Per node）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每天的 2 AM&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;清理临时目录（Clean Temporary Directory）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;清理 &lt;code&gt;&amp;lt;confluence-home&amp;gt;/temp&lt;/code&gt; 目录中的临时文件。这个目录被导出任务或其他一些任务创建。&lt;br/&gt;&lt;img class=&quot;emoticon emoticon-information&quot; src=&quot;https://www.cwiki.us/s/en_GB/7701/88819522251e178b5cc83bc1e3ddc18a884c1aed/_/images/icons/emoticons/information.svg&quot; alt=&quot;(info)&quot; data-emoticon-name=&quot;information&quot;/&gt; 这个清理不包括 Confluence 安装目录中文件的清理。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每节点（Per node）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每天的 4 AM&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.6561403508772&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;清理过期的邮件错误（Clear Expired Mail Errors）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;清理 &lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/The+Mail+Queue&quot;&gt;The Mail Queue&lt;/a&gt; 队列中的通知错误。当一个邮件因为某个原因而发送失败没有发送成功的话，一个通知错误将会被发送到邮件错误队列中。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每天的 3 AM&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;清理过期的记住我令牌（Clear Expired Remember Me Tokens）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;清理所有过期的记住我（Remember Me）令牌。记住我这个令牌超过两周后就会过期。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每个月的 20 号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.6666666666667&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;邮件每日报表（Email Daily Reports）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;针对 Confluence 的内容的修改，为&lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/Scheduled+Jobs#ScheduledJobs-emailreportsubscription&quot;&gt;所有订阅者&lt;/a&gt;发送每天的更新通知。&lt;br/&gt;&lt;img class=&quot;emoticon emoticon-information&quot; src=&quot;https://www.cwiki.us/s/en_GB/7701/88819522251e178b5cc83bc1e3ddc18a884c1aed/_/images/icons/emoticons/information.svg&quot; alt=&quot;(info)&quot; data-emoticon-name=&quot;information&quot;/&gt; 所有有关 Confluence 的内容修改记录将会只记录最后 24 小时的修改。这个推荐你只能修改任务发送邮件的时间为每 24 个小时中的某一个时间、&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每天的 12 AM&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;刷新边际索引队列（Flush Edge Index Queue）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;刷新边际索引队列，能够保证 Confluence 的索引是最新的索引。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每节点（Per node）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每 30 秒&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;刷新本地任务队列（Flush Local Task Queue）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;刷新本地任务队列。（Confluence 的内部任务通常具有很高的刷新频率）。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每节点（Per node）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每分钟&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.7507788161994&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;刷新邮件队列（Flush Mail Queue）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;发送 &lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/The+Mail+Queue&quot;&gt;mail queue&lt;/a&gt; 队列中已经队列的邮件通知。这并不包括批量的通知。编辑 发送批量的通知（&lt;strong&gt;Send batched notifications&lt;/strong&gt;）任务，如果你同时希望修改通知的发送频率包括页面或者博客的更新。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每分钟&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;发送批量通知（Send batched notifications）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;从有关上次任务运行后，发送有关页面或者博客更新的邮件通知。如果邮件并不是很多的话，可以增加这个发送的频率，如果你有很多邮件通知的话，你可以减少发送邮件的频率。这个设置对 Confluence 的性能提升会有很大的影响。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每 10 分钟&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;confluenceTd&quot;&gt;刷新任务队列（Flush Task Queue）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;刷新任务队列（Confluence 的内部任务通常具有很高的刷新频率）。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每节点（Per node）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;每分钟&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;发送推荐更新邮件（Send Recommended Updates Email）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;触发发送推荐更新邮件给用户。这个任务是每个小时运行一次的，但是用户可以收到每周更新或者每日更新，这个是根据用户自己属性的设置不同而不同的。这个时间与时区是对应的。&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每小时&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.605960264901&quot;&gt;&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;清理老的计划任务运行信息（Purge Old Job Run Details）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot; readability=&quot;10.620689655172&quot;&gt;
&lt;p&gt;Confluence 存储每一个计划任务的运行情况在数据库表 &lt;code&gt;scheduler_run_details&lt;/code&gt; 中。为了保持数据库中保存有足够的信息，但是又不至于扩大数据库的存储，清理老的计划任务细节（&lt;strong&gt;Purge Old Job Run Details&lt;/strong&gt;）任务将会日常运行删除细节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;超过 90 的天成功任务。&lt;/li&gt;
&lt;li&gt;超过 7 天的未成功的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有可以重置 &lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/Configuring+System+Properties&quot;&gt;system properties&lt;/a&gt; 中的一些设置；&lt;code&gt;jobs.limit.per.purge&lt;/code&gt;, &lt;code&gt;all.jobs.ttl.hours&lt;/code&gt; and &lt;code&gt;unsuccessful.jobs.ttl.hours&lt;/code&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每集群（Per cluster）&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot; colspan=&quot;1&quot;&gt;每天的 11 PM&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;a href=&quot;https://www.cwiki.us/display/CONF6ZH/Scheduled+Jobs&quot;&gt;https://www.cwiki.us/display/CONF6ZH/Scheduled+Jobs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:31:00 +0000</pubDate>
<dc:creator>huyuchengus</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huyuchengus/p/9398922.html</dc:identifier>
</item>
<item>
<title>【好记性不如烂笔头】之小程序要点记录 - 牙疼哥哥</title>
<link>http://www.cnblogs.com/pomelott/p/9398919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pomelott/p/9398919.html</guid>
<description>&lt;p&gt;1. 每添加一个页面需要在app.json中注册，第一个页面为首页。&lt;/p&gt;
&lt;p&gt;2. 例如注册一个welcome页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 注意： 路径最前面不需要加 ‘/’ ， 不需要加文件名&lt;br/&gt;{
  &lt;/span&gt;&quot;pages&quot;&lt;span&gt;: [
      &lt;/span&gt;&quot;pages/welcome/welcome&quot;&lt;span&gt;
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 每增加新页面后，js文件不能为空，需要调用 Page ({}) 初始化， 同样，页面的json文件也不能为空，应写为 {}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面对应的js文件&lt;/span&gt;
&lt;span&gt;
Page({

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面对应的json文件, 不能为空，最简单也要写成下面的格式&lt;/span&gt;
&lt;span&gt;
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 通过在啊app.json里面注册页面，IDE会自动为开发者创建 .wxml, .js, .wxss, .json 的四个对应的文件&lt;/p&gt;
&lt;p&gt;5. 每个页面都有一个名字为page的根结点&lt;/p&gt;
&lt;p&gt;6. 小程序中支持一下几种css选择器&lt;/p&gt;
&lt;p&gt;.class(.box)   #id(#box)  element(view)      element,Element (view, checkbox)   ::after(view::after)    ::before (view::before)&lt;/p&gt;
&lt;p&gt;7. 小程序中新定义了 rpx的适配单位：在宽度为750px的设计稿中， 1物理像素 = 1rpx = 0.5px &lt;/p&gt;
&lt;p&gt;8. Boolean的陷阱：在swiper组件中，用vertical属性来设置是否垂直排列，若要设置为水平排列，只有一下三种方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 不加如vertical属性&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2. vertical = ‘’&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 3. vertical = ‘{{false}}’         &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9. 小程序为image组件增加了 mode 属性用以控制图片的裁剪，常用的是widthFix（宽度充满，高度自适应）&lt;/p&gt;
&lt;p&gt;10. page页面的声明周期&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Page({
    data: {},
    onLoad: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; (options) {},      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  页面初始化  options 为页面跳转所带来的参数， 一个页面只会调用一次&lt;/span&gt;
    onShow: &lt;span&gt;function&lt;/span&gt; () {},             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面显示，每次打开页面都会调用&lt;/span&gt;
    onReady: &lt;span&gt;function&lt;/span&gt; () {},            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面初次渲染完成，一个页面只会调用一次，代表页面已经准备好，可进行视觉交互&lt;/span&gt;
    onHide: &lt;span&gt;function&lt;/span&gt; () {},             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面隐藏&lt;/span&gt;
    onUnload: &lt;span&gt;function&lt;/span&gt; () {}            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面关闭&lt;/span&gt;
&lt;span&gt;})


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意： &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 1. 一个页面的加载顺序（onLoad &amp;gt; onShow &amp;gt; onReady）&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2. onLoad和onReady在整个页面的声明周期内只会执行一次，除非这个页面执行了onUnload卸载掉了，卸载意味着这个页面的一个声明周期结束了&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 3. onReady 仅仅用来监听页面的第一次渲染&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11.  小程序中提供的其他特定事件的监听程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; onPullDownRefresh : 监听用户下拉动作的事件处理函数&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; onReachBottom: 页面上拉触底事件的处理函数&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; onShareAppMessage : 用户点击右上角分享&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 持续更新中。。。。。。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:29:00 +0000</pubDate>
<dc:creator>牙疼哥哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pomelott/p/9398919.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——使用GitHub实现简单的CI/CD - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9398738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9398738.html</guid>
<description>&lt;p&gt;　　软件开发一般来说是一项团队作业，在本系列文章开始就提到过软件的编码是由一个团队“并行”完成的，为了保证编码任务正常完成，首先引入版本控制工具来完成代码管理，为了保证代码质量引入了代码分析器以及代码测试。&lt;/p&gt;
&lt;p&gt;　　版本控制工具可以保证代码有一个主版本，但代码分析和测试均是开发人员手动在本地完成的(通过编译、执行测试等方式)，在进行代码分析和测试时可能并没有将本地代码更新到最新版本，这样就会出现一个问题，当多个开发人员向版本库提交代码时，无法保证最新代码库的代码是正确的，为了解决这个问题，提出了持续集成，持续集成的集成指的是&lt;span&gt;持续的对多个开发人员编写的代码进行集成&lt;/span&gt;，本文从下面几个方面介绍持续集成以及基于Github进行持续集成实践：&lt;/p&gt;
&lt;h2&gt;CI&amp;amp;CD&lt;/h2&gt;
&lt;p&gt;　　持续集成(Continuous integration，CI)指的是在开发过程中持续地将所有开发人员的代码合并到代码库的主线上，然后对该主线代码进行编译、测试运行等操作对代码进行检验，其目的是&lt;span&gt;尽可能早的发现代码集成后导致的问题&lt;/span&gt;。&lt;br/&gt;　　实现持续集成的要点主要有：共享的代码库、自动化编译、自动化测试等，同时要保证合理的集成频率，一般持续集成的时机在于开发人员将代码提交到代码库时自动进行，但是如果提交过于频繁，那么应该使用时间间隔的形式进行持续集成。&lt;br/&gt;　　持续发布(Continuous delivery,CD)实际上是持续集成上的一个拓展，在持续集成的基础上将发布工作自动化，&lt;span&gt;避免人为操作从而减少发布时间和发布时人为造成的错误&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;常用的持续集成工具&lt;/h2&gt;
&lt;p&gt;　　持续集成经过多年的发展，在不同的应用场景、平台/语言、商业化等因素下产生了许多持续集成工具，可参考(但不限于这些)：　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&lt;/a&gt;&lt;br/&gt;　　比较常用的持续集成工具有：&lt;br/&gt;　　Jenkins&lt;br/&gt;　　Jenkins是一个开源的跨平台持续集成工具，它提供了GUI界面以及大量的拓展插件，通过GUI界面可以简单、快速的完成项目持续集成配置，更重要的是Jenkins支持所有的版本控制工具。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　TeamCity&lt;br/&gt;　　TeamCity是JetBrains公司开发的持续集成工具，它有免费和收费两种授权，免费版本的TeamCity拥有所有功能，其限制仅仅是只能创建100个编译配置和只能并行运行3个代理。&lt;br/&gt;　　项目地址：&lt;a href=&quot;http://www.jetbrains.com/teamcity/&quot; target=&quot;_blank&quot;&gt;http://www.jetbrains.com/teamcity/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　GitLab&lt;br/&gt;　　GitLab是一个Git的代码管理工具，使用GitLab可以轻松的在Linux环境搭建一个Git的远程代码托管平台，同时GitLab中也内置的CI/CD功能。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot;&gt;https://about.gitlab.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Travis CI&lt;br/&gt;　　Travis CI是一个持续集成托管平台，它为开源项目提供免费支持，但Travis CI不支持Windows下编译。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://www.travis-ci.org/&quot; target=&quot;_blank&quot;&gt;https://www.travis-ci.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　AppVeyor&lt;br/&gt;　　AppVeyor也是一个持续集成的托管平台，它支持Windows和Linux，并且AppVeyor可以对环境进行定制：&lt;a href=&quot;https://www.appveyor.com/docs/build-environment/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/build-environment/&lt;/a&gt;，是一个非常强大的CI工具，AppVeyor对开源项目提供免费支持。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://www.appveyor.com/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　VSTS&lt;br/&gt;　　VSTS(Visual Studio Team Services)是微软的软件开发管理解决方案，它包含了代码版本管理、持续集成/发布、敏捷等特性，并且VSTS为5人以下团队提供了免费使用。&lt;br/&gt;　　项目地址：&lt;a href=&quot;https://visualstudio.microsoft.com/zh-hans/team-services/&quot; target=&quot;_blank&quot;&gt;https://visualstudio.microsoft.com/zh-hans/team-services/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　总的来说持续集成工具分为可本地安装和平台托管两类，本地安装类型的工具适合有专用构建服务器资源的闭源项目(当然开源项目也可以使用)，而托管平台则比较适合开源或者没有专用构建服务器资源的项目，使用上托管平台更加省心，这些工具需要根据实际情况来进行选用。&lt;/p&gt;
&lt;h2&gt;GitHub市场简介&lt;/h2&gt;
&lt;p&gt;　　GitHub作为一个分布式的软件管理解决方案，它除了提供代码托管外，还通过应用市场的方式提供了拓展应用，这些应用主要用于持续继承、部署、测试、代码审查、项目管理等等，详情查看：&lt;a href=&quot;https://github.com/marketplace/&quot; target=&quot;_blank&quot;&gt;https://github.com/marketplace/&lt;/a&gt;&lt;br/&gt;　　下图为Github市场中的CI工具：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224241490-203279483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般来说市场中提供的应用对于开源项目都是可以免费使用的，下面就介绍如何将Github上的开源项目使用其市场应用完成持续集成。&lt;/p&gt;
&lt;h2&gt;使用AppVeyor实现持续集成&lt;/h2&gt;
&lt;p&gt;　　AppVeyor是一个支持自定义持续集成环境的CI工具，它对.Net程序的支持非常强大，同时对开源项目免费，所以AppVeyor是.Net Core项目持续集成的首选，下面就介绍如何使用AppVeyor完成持续基础：&lt;br/&gt;　　1. 在GitHub市场中找到AppVeyor，并完成安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224434634-1397204928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 添加项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224454829-790756155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择GitHub仓库，并完成授权：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224556974-2123963496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加需要的仓库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224613353-624953312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击“NEW BUILD”进行一次编译：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224631579-297863656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从编译的信息可以看到，此次编译失败了，并且给出了相应的错误信息，这是由于编译环境导致的。&lt;/p&gt;
&lt;p&gt;　　3. 环境配置：&lt;br/&gt;　　将编译镜像选择为VS2017：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224657740-64294683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在编译前先执行dotnet restore命令还原项目依赖：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224715527-959964128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 开始一个新的编译：&lt;br/&gt;　　编译结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224738984-420054646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从编译结果可以看出Appveyor不仅仅是完成了编译工作，而且还搜索了测试信息，并完成了测试。另外有一个要点是本项目中的测试是依赖数据库的，这就意味着Appveyor的编译环境提供了SQL Server数据的支持。&lt;/p&gt;
&lt;p&gt;　　5. 将编译后的内容发布到GitHub release：&lt;br/&gt;　　为xUnitTestDemo代码库添加一个Tag：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224804801-623813258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后Appveyor将会检测到代码库的变化，自动编译Tag，并将结果部署到Github的Release中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224855084-754570041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自动部署的Release内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224910330-847102152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于appveryor部署的更多信息参考：&lt;a href=&quot;https://www.appveyor.com/docs/deployment/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/deployment/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　6. 将编译状态显示到GitHub上：&lt;br/&gt;　　Appveyor的Badges(标记)配置界面中可以获取到状态标记地址：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224934211-1651502373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将MarkDown的代码复制到项目的README.md文件中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731224949442-308545953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225008993-978936522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7. 导出appveyor.yml文件以及通过appveyor.yml来完成配置：&lt;br/&gt;　　上面的方法是通过Appveyor的Web界面上完成配置的，除此之外还可以通过appveyor.yml文件来完成配置，appveyor.yml文件可以自己创建或导出已有配置：&lt;br/&gt;　　导出已有配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225032904-289342027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将appveyor.yml文件放置到代码根目录，并通过修改该文件来变更配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225054968-1673214677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图在原有配置基础上修改为release的方式编译代码，并且指定生成结果目录，将结果进行压缩。&lt;br/&gt;　　更多appveyor.yml配置可参考：&lt;a href=&quot;https://www.appveyor.com/docs/appveyor-yml/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/appveyor-yml/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;使用Codecov显示代码覆盖率&lt;/h2&gt;
&lt;p&gt;　　Codecov也是Github市场的一个应用，它用于生成代码覆盖率报告，codecov对C#的支持是基于OpenCover的(使用OpenCover检测代码覆盖率参考：&lt;a href=&quot;https://www.cnblogs.com/selimsong/p/9263957.html&quot; target=&quot;_blank&quot;&gt;好代码是管出来的——.Net Core中的单元测试与代码覆盖率&lt;/a&gt;)，Codecov对Github的公开项目是免费的，下面就开始介绍如何使用codecov来实现测试代码覆盖率的统计：&lt;br/&gt;　　1. 安装Codecov：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225150706-886391554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：安装完成Codecov后，会有一个Upload Token用来将代码覆盖报告上传到Codecov，但Appveyor的公共仓库可以不需要：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225241143-2002965002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 修改appveyor.yml文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225349063-598536888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加使用choco管理器安装OpenCover及codecov，然后在test_script中添加代码覆盖率分析报告以及上传脚本。&lt;br/&gt;　　&lt;span&gt;注：当上述变更push到Github后，Appveyor将开始自动编译并完成包括代码覆盖率报告生成、上传等所有工作，此时打开codecov页面将会看到报告信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225557132-1620931801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 在README.md文件中添加Codecov的标签：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225649783-322910257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225712173-812784126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180731225731519-240305522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文介绍了CI和CD的基本概念，前者目的在于尽可能早的发现多人开发时代码集成的错误，而后者目的是避免人为造成的错误，将一些重复的事情交由程序自动完成，既可以减少成本又可以提高正确率，现在流行的DevOps的基础之一就是自动化也就是CI和CD。&lt;br/&gt;　　另外本文还介绍了在Github上使用Appvoyer和Codecov工具实现了简单的持续集成，当把新代码推到GitHub仓库时，Appvoyer会自动的完成一系列构建操作。Appvoyer是一个非常强大的CI工具，对C#的支持也非常好可以选择VS版本(包括预览版)，多种数据库(包括Linux下的SQL Server)，所以在执行测试时依赖数据库的测试也能通过。&lt;br/&gt;　　下篇文章将介绍如何使用Jenkins完成本地CI服务器的搭建。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_integration&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Continuous_integration&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_delivery&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Continuous_delivery&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://cakebuild.net/&quot; target=&quot;_blank&quot;&gt;https://cakebuild.net/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.codecov.io/docs&quot; target=&quot;_blank&quot;&gt;https://docs.codecov.io/docs&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.appveyor.com/docs/&quot; target=&quot;_blank&quot;&gt;https://www.appveyor.com/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——使用GitHub实现简单的CI/CD&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9398738.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9398738.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9398738.html</dc:identifier>
</item>
<item>
<title>将项目发布到Maven中央仓库的不完整纪要 - 网无忌</title>
<link>http://www.cnblogs.com/netWild/p/maven.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/netWild/p/maven.html</guid>
<description>&lt;p&gt;有几个Utils性质的Jar需要跨项目引用，原本想部署私有Maven仓库，后来感觉太麻烦，索性直接发布到中央库，引用时也方便。&lt;/p&gt;
&lt;p&gt;发布成功之后，觉得某些细节还是有必要记录一下。&lt;/p&gt;


&lt;p&gt;此处将整个发布流程进行梳理，目的是从宏观上对这项工作有个感性认识，这是我之前最想找，却无论如何也没找到的。&lt;/p&gt;
&lt;p&gt;图中的“&lt;strong&gt;重点&lt;/strong&gt;”都是需要注意的，也是最终能否成功发布的关键，基本上这几个“&lt;strong&gt;重点&lt;/strong&gt;”都做到，就没什么问题了&lt;/p&gt;
&lt;p&gt;至于每个步骤的实现细节就不再重复了，可以很方便的搜索到相关文章。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/8859/201807/8859-20180731230940680-284646696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>网无忌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/netWild/p/maven.html</dc:identifier>
</item>
<item>
<title>web server性能优化浅谈 - Jack47</title>
<link>http://www.cnblogs.com/Jack47/p/performance-optimizing-for-gateway.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack47/p/performance-optimizing-for-gateway.html</guid>
<description>&lt;p&gt;作者:&lt;a href=&quot;http://www.cnblogs.com/Jack47/&quot;&gt;Jack47, ZhiYan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请保留作者和&lt;a href=&quot;http://www.cnblogs.com/Jack47/&quot;&gt;原文出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;性能优化，优化的东西一定得在主路径上，结合测量的结果去优化。不然即使性能再好，逻辑相对而言执行不了几次，其实对提示性能的影响微乎其微。记得抖哥以前说多隆在帮忙查广告搜索引擎的问题，看到了一处代码，激动的说这里用他的办法，性能可以提升至少10倍。但实际上，这里的逻辑基本走不到 face_palm。&lt;/p&gt;
&lt;p&gt;性能优化的几个跟语言无关的大方向：&lt;/p&gt;
&lt;h2 id=&quot;减少算法的时间复杂度&quot;&gt;减少算法的时间复杂度&lt;/h2&gt;
&lt;h3 id=&quot;例子1&quot;&gt;例子1&lt;/h3&gt;
&lt;p&gt;我们实现了一个CallBack的机制，一段执行流程里，会有多个plugin，每个plugin可以添加callback，每个callback有唯一的名字；添加callback时，需要注意覆盖的问题，如果覆盖了，需要返回老的callback。一开始我们的实现机制是使用数组，这样添加时，需要挨个遍历，查看是否时覆盖的情况。Update操作的时间复杂度为O(n)；后来我们添加了一个辅助的Map，用来存储 &amp;lt;name, callbackIdx&amp;gt;的映射关系。Update的平均时间复杂度降低为O(1)&lt;/p&gt;
&lt;h3 id=&quot;例子2&quot;&gt;例子2&lt;/h3&gt;
&lt;p&gt;在我们的pipeline场景里，类似net/http里的context，我们有个task的概念的。每个阶段(plugin)都可以向里面塞数据，一开始为了支持cancel某个阶段，重新执行这个阶段的功能，我们是使用嵌套，类似递归的方式。这样就可以很方便的撤销某个阶段放入的数据。但是这种设计，如果要从里面取数据，需要层层遍历，类似递归一样，时间复杂度为O(n);因为每个plugin都会与task打交道，所以这里 task里数据的存取是高频操作，而且我们后来经过权衡，觉得支持取消掉某个阶段对task的操作，不是必须的，不支持也没关系，所以后来简化了task的设计，直接用一个map来做，这样时间复杂度又降下来了。&lt;/p&gt;
&lt;h2 id=&quot;根据业务逻辑设计优化的数据结构&quot;&gt;根据业务逻辑，设计优化的数据结构&lt;/h2&gt;
&lt;p&gt;我们有个场景，是要对URL执行类似归一化的操作，把里面重复的&lt;code&gt;\&lt;/code&gt;字符删掉，比如 &lt;code&gt;\\&lt;/code&gt; -&amp;gt; &lt;code&gt;\&lt;/code&gt;。这个逻辑对于网关，是高频逻辑，因为每个请求来了，都需要判断，但是真正要删掉重复的&lt;code&gt;\&lt;/code&gt;的操作，其实比较少，大部分场景是检查完，发现正常，不需要做修改。&lt;/p&gt;
&lt;p&gt;一开始我们的实现是把url字符挨个检查，没问题的放入 bytes.Buffer 中，最终返回 buffer.String()；后来我们优化了一下，采用了标准库中 &lt;a href=&quot;https://github.com/golang/go/blob/master/src/path/filepath/path.go#L21-L24&quot;&gt;path/path.go&lt;/a&gt; 中的 Lazybuf 的方式，LazyBuf中发现要写入的字符和基准的字符不一样时，才分配内存来存储修改后的字符串，不然最终还是基准的字符，直接返回就行，避免了无谓的内存拷贝操作。&lt;/p&gt;
&lt;p&gt;这里其实体现了一个小技巧，尽量想想自己需要的操作，是否标准库里有，同时也要多看看标准库的实现，吸取经验。&lt;/p&gt;
&lt;h2 id=&quot;尽量减少磁盘io次数&quot;&gt;尽量减少磁盘IO次数&lt;/h2&gt;
&lt;p&gt;IO操作尽量批量进行。比如我们的网关会记录访问日志，类似Nginx的access.log。在生产环境/压测环境下，会生成大量的日志，虽然操作系统写入文件是有缓冲的，但是这个缓冲机制我们应用程序没法直接控制，而且写入文件时调用系统API，也比较耗时。我们可以在应用层面，给日志留缓冲区(buffer)，定时或达到一定量(4k,跟虚拟文件系统的块大小保持一致）时调用操作系统IO操作来写入日志。&lt;/p&gt;
&lt;p&gt;总结一下，就是写入日志是异步的，同时是攒够一批之后，再调用操作系统的写入&lt;/p&gt;
&lt;p&gt;具体实现：进来的数据，先放到一个2048字节大小的channel里，由一个固定的go routine负责不断的从channel里读取数据，写入到buffered io里。这里2048字节的channel，类似队列一样，是有削峰作用的。当有大批日志写入时，channel可以暂时缓冲一下，降低 buffer.io 真正flush的频率。；写入文件时，套上一个 &lt;code&gt;bufio.Writer(size=512)&lt;/code&gt;，即内部是有512字节大小的缓冲区，满了才使用整块数据调用Write()；&lt;/p&gt;
&lt;h2 id=&quot;尽量复用资源&quot;&gt;尽量复用资源&lt;/h2&gt;
&lt;p&gt;资源的申请和释放，跟内存(也是一种资源)的申请和释放其实是一样的，尽量复用，避免重复/频繁申请；&lt;br/&gt;比如下面的这个&lt;a href=&quot;https://github.com/golang/go/blob/master/src/time/tick.go#L49-L53&quot;&gt;time.Tick&lt;/a&gt;，适用于使用者不需要关闭它，即非频繁调用的情况。使用它很方便，但是要注意，它没法关闭，所以垃圾回收器也没法回收它。来看一下下面的这段代码修改记录：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;+   ticker := time.NewTicker(time.Second)
+   defer ticker.Stop()
+
    for {
        select {
-       case &amp;lt;-time.Tick(time.Second):
+       case &amp;lt;-ticker.C:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改前，for循环里会频繁创建time.Ticker,但都没有回收机制。改动后，for循环里复用同一个time.Ticker,而且会在当前函数执行结束时释放time.Ticker。&lt;/p&gt;
&lt;h2 id=&quot;sync.map的使用&quot;&gt;sync.Map的使用&lt;/h2&gt;
&lt;p&gt;其实看清楚&lt;a href=&quot;https://github.com/golang/go/blob/master/src/sync/map.go#L12-L26&quot;&gt;map.go&lt;/a&gt;里的注释，注意使用场景。&lt;/p&gt;
&lt;p&gt;sync.Map适合两种用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指定的key，value只会被写入一次，但是会被读取很多次&lt;/li&gt;
&lt;li&gt;多个goroutine读取、写入、覆盖的数据都是没有交集的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;只有上述情况下，sync.Map才能相比Go map搭配单独的Mutex或RWMutex而言，显著降低锁的竞争，均摊复杂度是常数(amortized constant time)&lt;/p&gt;
&lt;p&gt;大部分情况下，应该用 map ，然后用单独的锁或者同步机制，这样类型安全，而且可以有其他的逻辑&lt;/p&gt;
&lt;h2 id=&quot;锁相关&quot;&gt;锁相关&lt;/h2&gt;
&lt;h3 id=&quot;mutexes&quot;&gt;Mutexes&lt;/h3&gt;
&lt;p&gt;锁在满足以下条件的情况下，是很快的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有其他人竞争 (想象为挤公交车，此时没人跟你抢，你直接上车)&lt;/li&gt;
&lt;li&gt;锁覆盖的代码，执行时间非常快 (想象为挤公交车，大家速度都很快，嗖嗖就上去了，下一个人等待上一个人挤上去的时间很短)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当竞争越激烈，锁的性能下降的越厉害。&lt;/p&gt;
&lt;p&gt;Reference:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://preshing.com/20111118/locks-arent-slow-lock-contention-is/&quot;&gt;locks aren't slow, lock contention is&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;锁的粒度尽量小&quot;&gt;锁的粒度尽量小&lt;/h3&gt;
&lt;p&gt;比如我们的pipeline生命周期的管理，一开始是通过一把大锁来控制并发的，后续优化时，发现里面可以细分成两块，各自可以用一把锁来控制，这样锁的粒度变小，并发程度会提高。&lt;/p&gt;
&lt;p&gt;这里比较好的例子是&lt;a href=&quot;https://github.com/allegro/bigcache&quot;&gt;BigCache&lt;/a&gt;的实现。它使用分片（sharding）的方式，&lt;br/&gt;跟Java 7里的&lt;a href=&quot;https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/ConcurrentHashMap.java#L107&quot;&gt;concurrent hash map&lt;/a&gt;的实现类似，对数据进行分片，分片之间是独立的，可以并发的进行写操作。对细分后的分片进行并发控制，这样能有效减小锁的粒度，让并发度尽可能高。&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href=&quot;https://allegro.tech/2016/03/writing-fast-cache-service-in-go.html&quot;&gt;Writing Fast Cache Service in Go&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;rwmutexes&quot;&gt;RWMutexes&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;是否有多读少写的场景，如果是，尽量用读写锁；这样尽量把写锁的粒度缩小，能用读锁解决的，就不需要用写锁，真正需要修改结果时，才使用写锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/megaease/easegateway/commit/04d42e9779a276ef222b23186c9c65d79d48a85b&quot; class=&quot;uri&quot;&gt;https://github.com/megaease/easegateway/commit/04d42e9779a276ef222b23186c9c65d79d48a85b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (b *DataBucket) QueryDataWithBindDefault(key interface{}, defaultValueFunc DefaultValueFunc) (interface{}, error) {
    先上读锁，看key是否存在，如果存在，就返回 // 大部分情况下是这样，所以这个优化肯定很有意义
    否则，上写锁，把默认值加上 // 这种情况只会发生一次
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;尽量使用无锁的方式&quot;&gt;尽量使用无锁的方式：&lt;/h3&gt;
&lt;p&gt;是否真的需要加锁？是否能用CAS的操作来代替Mutex？&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;利用 atmoic int stopped = 0／1 来代表是否停止，需要停止时，设置为1。&lt;/p&gt;
&lt;p&gt;golang里Atomic操作有：Atomic.CompareAndSet, LoadInt(), StoreInt()&lt;/p&gt;
&lt;p&gt;如果利用某个变量代表现在是否在干活，close时需要等别人干完活，那么在close时，需要通过spin的方式等待干活的人结束:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for atomic.LoadInt(&amp;amp;doing) &amp;gt; 0 {
    sleep(1ms)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内存相关&quot;&gt;内存相关&lt;/h2&gt;
&lt;p&gt;减少内存分配的次数&lt;/p&gt;
&lt;h3 id=&quot;生成字符串时尽量写入-bytes.buffer-而不是用-fmt.sprintf&quot;&gt;生成字符串时，尽量写入 bytes.Buffer, 而不是用 fmt.Sprintf()&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;+   var repeatingRune rune
-   result := string(s[0])  
+   result := bytes.NewBuffer(nil)
    for _, r := range s[:1] {
-       result = fmt.Sprintf(&quot;%s%s&quot;, result, string(r)) 
+       result.WriteRune(r)
+   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据结构初始化时尽量指定合适的容量&quot;&gt;数据结构初始化时，尽量指定合适的容量&lt;/h3&gt;
&lt;p&gt;比如Java或者Go里面，如果数组，Map的大小已知，可以在声明时指定大小，这样避免后续追加数据时需要扩展内部容量，造成多次内存分配&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;-   eventStream := make(chan cluster.Event)
+   eventStream := make(chan cluster.Event, 1024)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;语言go相关&quot;&gt;语言(Go)相关&lt;/h3&gt;
&lt;p&gt;语言相关的其实还有很多，但是随着语言的发展，基本上都会被解决掉，所以这里只提一下下面的这个，对Go语言感兴趣的同学，可以看&lt;a href=&quot;https://www.slideshare.net/TylerTreat/so-you-wanna-go-fast-80300458&quot;&gt;So You Wanna Go Fast&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;避免内存拷贝&quot;&gt;避免内存拷贝&lt;/h4&gt;
&lt;p&gt;如下的代码，两者有什么区别？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-   for _, bucket := range s.buckets {
-       bucket.Update(v)
+   for i := 0; i &amp;lt; len(s.buckets); i++ {
        buckets[i].Update(v)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改前的这种方式，bucket是通过拷贝生成的临时变量；而且这种方式下，由于操作的是临时变量，所以 s.buckets并不会被更新！&lt;/p&gt;
&lt;h3 id=&quot;go-routine虽好也有代价&quot;&gt;Go routine虽好，也有代价&lt;/h3&gt;
&lt;p&gt;我们的网关，一开始的时候，由于大家也都是刚接触Go语言，用Go routine用的也顺手，所以很喜欢用Go routine;比如我们的主流程里，需要记录本次请求的一些指标，为了不影响主流程的执行，这些记录指标的逻辑都是启动一个新的go routine去执行的。后来发现我们在一台机器上，一个程序里，某一时刻启动了十万计的go routine，而这些go routine生命周期很短，会不断的销毁和创建。我也简单的用Go Benchmark测试模拟了一个场景，测试了之后发现go routine数量上去后，性能下降很大，说明此时的调度开销也比较大了。后来我们修改了设计，让大家把需要更新的数据放到channel里，启动固定的go routine去做更新的事情，这样可以避免频繁创建go routine的情况。&lt;/p&gt;
&lt;h3 id=&quot;使用多个http.client来发送请求&quot;&gt;使用多个http.Client来发送请求&lt;/h3&gt;
&lt;p&gt;一开始我们是通过一个http.Client来发送同一个API的请求，后来担心这里可能存在并发的瓶颈，尝试了创建多个http.Client,发送时随机使用某一个发送的机制，发现性能提升了。其实性能有多少提升，取决于使用场景的，还是得实际测量，用数值说话，我们的方法不一定对你们有用！&lt;/p&gt;
&lt;p&gt;Go语言在benchmark方面，提供了很多强有力的工具，可以参加下面的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://talks.godoc.org/github.com/davecheney/high-performance-go-workshop/high-performance-go-workshop.slide&quot;&gt;High performance go workshop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://about.sourcegraph.com/go/an-introduction-to-go-tool-trace-rhys-hiltner/&quot;&gt;An Introduction to go tool trace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dgryski/go-perfbook/blob/master/performance.md&quot;&gt;Writing and Optimizing Go code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rakyll.org/go-tool-flags/&quot;&gt;Go tooling essentials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，以上就是所有内容了，欢迎留下你的性能优化的思路和方法！&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;如果您看了本篇博客,有所收获，请点击右下角的“推荐”，让更多人看到！
&lt;p&gt;打赏也是对自己的肯定&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img class=&quot;wp-image-558 size-thumbnail&quot; src=&quot;http://img2.tbcdn.cn/L1/461/1/f553ea55e9814b43fb39bb1e6543bee82c2db72f&quot; alt=&quot;pay_weixin&quot; width=&quot;150&quot; height=&quot;150&quot;/&gt;&lt;/div&gt;
&lt;p&gt;微信打赏&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 15:11:00 +0000</pubDate>
<dc:creator>Jack47</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack47/p/performance-optimizing-for-gateway.html</dc:identifier>
</item>
<item>
<title>webpack4 系列教程(二): 编译 ES6 - YuanXin.me</title>
<link>http://www.cnblogs.com/geyouneihan/p/9398779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9398779.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今天介绍&lt;code&gt;webpack&lt;/code&gt;怎么编译&lt;code&gt;ES6&lt;/code&gt;的各种函数和语法。敲黑板：&lt;strong&gt;这是&lt;code&gt;webpack4&lt;/code&gt;版本哦, 有一些不同于&lt;code&gt;webpack3&lt;/code&gt;的地方。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos/tree/master/demo02&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 本节课源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 所有课程源码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;了解babel&quot;&gt;1. 了解&lt;code&gt;babel&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;说起编译&lt;code&gt;es6&lt;/code&gt;，就必须提一下&lt;code&gt;babel&lt;/code&gt;和相关的技术生态：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;babel-loader&lt;/code&gt;: 负责 es6 语法转化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel-preset-env&lt;/code&gt;: 包含 es6、7 等版本的语法转化规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel-polyfill&lt;/code&gt;: es6 内置方法和函数转化垫片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;: 避免 polyfill 污染全局变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要注意的是, &lt;code&gt;babel-loader&lt;/code&gt;和&lt;code&gt;babel-polyfill&lt;/code&gt;。前者负责语法转化，比如：箭头函数；后者负责内置方法和函数，比如：&lt;code&gt;new Set()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;安装相关库&quot;&gt;2. 安装相关库&lt;/h3&gt;
&lt;p&gt;这次，我们的&lt;code&gt;package.json&lt;/code&gt;文件配置如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.26.3&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.5&quot;,
    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
    &quot;webpack&quot;: &quot;^4.15.1&quot;
  },
  &quot;dependencies&quot;: {
    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,
    &quot;babel-runtime&quot;: &quot;^6.26.0&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos/blob/master/demo02/package.json&quot;&gt;&amp;gt;&amp;gt;&amp;gt; package.json 配置地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;webpack中使用babel&quot;&gt;3. &lt;code&gt;webpack&lt;/code&gt;中使用&lt;code&gt;babel&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;的相关配置，推荐单独写在&lt;code&gt;.babelrc&lt;/code&gt;文件中。下面，我给出这次的相关配置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;{
  &quot;presets&quot;: [
    [
      &quot;env&quot;,
      {
        &quot;targets&quot;: {
          &quot;browsers&quot;: [&quot;last 2 versions&quot;]
        }
      }
    ]
  ],
  &quot;plugins&quot;: [&quot;transform-runtime&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;webpack&lt;/code&gt;配置文件中，关于&lt;code&gt;babel&lt;/code&gt;的调用需要写在&lt;code&gt;module&lt;/code&gt;模块中。对于相关的匹配规则，除了匹配&lt;code&gt;js&lt;/code&gt;结尾的文件，还应该去除&lt;code&gt;node_module/&lt;/code&gt;文件夹下的第三库的文件（发布前已经被处理好了）。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = {
  entry: {
    app: &quot;./app.js&quot;
  },
  output: {
    filename: &quot;bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /(node_modules)/,
        use: {
          loader: &quot;babel-loader&quot;
        }
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos/blob/master/demo02/.babelrc&quot;&gt;&amp;gt;&amp;gt;&amp;gt; .babelrc 地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dongyuanxin/webpack-demos/blob/master/demo02/webpack.config.js&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 配置文件地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后babel-polyfill&quot;&gt;4. 最后：&lt;code&gt;babel-polyfill&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们发现整个过程中并没有使用&lt;code&gt;babel-polyfill&lt;/code&gt;。&lt;strong&gt;它需要在我们项目的入口文件中被引入&lt;/strong&gt;，或者在&lt;code&gt;webpack.config.js&lt;/code&gt;中配置。这里我们采用第一种方法编写&lt;code&gt;app.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import &quot;babel-polyfill&quot;;
let func = () =&amp;gt; {};
const NUM = 45;
let arr = [1, 2, 4];
let arrB = arr.map(item =&amp;gt; item * 2);

console.log(arrB.includes(8));
console.log(&quot;new Set(arrB) is &quot;, new Set(arrB));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行中进行打包，然后编写&lt;code&gt;html&lt;/code&gt;文件引用打包后的文件即可在不支持&lt;code&gt;es6&lt;/code&gt;规范的老浏览器中看到效果了。&lt;/p&gt;
&lt;h3 id=&quot;相关资料&quot;&gt;5. 相关资料&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.7560975609756&quot;&gt;
&lt;p&gt;欢迎技术交流，引用请注明出处。&lt;br/&gt;个人网站：&lt;a href=&quot;http://yuanxin.me&quot;&gt;Yuan Xin&lt;/a&gt;&lt;br/&gt;原文链接：&lt;a href=&quot;http://yuanxin.me/#/blog/passage/31&quot;&gt;webpack4 系列教程(二): 编译 ES6&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 31 Jul 2018 14:51:00 +0000</pubDate>
<dc:creator>YuanXin.me</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9398779.html</dc:identifier>
</item>
<item>
<title>Java8新特性(一)_interface中的static方法和default方法 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9398682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9398682.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为什么要单独写个Java8新特性，一个原因是我目前所在的公司用的是jdk8，并且框架中用了大量的Java8的新特性，如上篇文章写到的stream方法进行过滤map集合。stream方法就是接口Collection中的default方法。所以准备专门写写关于java8新特性的文章，虽然现在10已经发布了。但还是要认真的去了解下新版本的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;static方法&quot;&gt;static方法&lt;/h3&gt;
&lt;p&gt;java8中为接口新增了一项功能：定义一个或者更多个静态方法。用法和普通的static方法一样。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public interface InterfaceA {

    /**
     * 静态方法
     */
    static void showStatic() {
        System.out.println(&quot;InterfaceA++showStatic&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        InterfaceA.show();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InterfaceA++showStatic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意，实现接口的类或者子接口不会继承接口中的静态方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;default方法&quot;&gt;default方法&lt;/h3&gt;
&lt;p&gt;在接口中，增加default方法， 是为了既有的成千上万的Java类库的类增加新的功能， 且不必对这些类重新进行设计。 比如， 只需在Collection接口中&lt;br/&gt;增加default Stream stream(), 相应的Set和List接口以及它们的子类都包含此的方法， 不必为每个子类都重新copy这个方法。&lt;/p&gt;
&lt;h4 id=&quot;代码示例-1&quot;&gt;代码示例&lt;/h4&gt;
&lt;h5 id=&quot;实现单一接口仅实现接口&quot;&gt;实现单一接口，仅实现接口&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public interface InterfaceA {

    /**
     * 静态方法
     */
    static void showStatic() {
        System.out.println(&quot;InterfaceA++showStatic&quot;);
    }

    /**
     * 默认方法
     */
    default void showDefault() {
        System.out.println(&quot;InterfaceA ++showDefault&quot;);
    }

}



/**先只实现这个接口
 * @author: curry
 * @Date: 2018/7/31
 */
public class InterfaceAImpl implements InterfaceA{


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        InterfaceA.showStatic();
        new InterfaceAImpl().showDefault();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InterfaceA++showStatic
InterfaceA ++showDefault&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;实现单一接口重写接口中的default方法&quot;&gt;实现单一接口，重写接口中的default方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceAImpl implements InterfaceA{

    /**
     * 跟接口default方法一致,但不能再加default修饰符
     */
    @Override
    public void showDefault(){
        System.out.println(&quot;InterfaceAImpl++ defaultShow&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        InterfaceA.showStatic();
        new InterfaceAImpl().showDefault();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InterfaceA++showStatic
InterfaceAImpl++ defaultShow&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现多个接口且接口中拥有相同的default方法和static方法&quot;&gt;实现多个接口，且接口中拥有相同的default方法和static方法&lt;/h5&gt;
&lt;p&gt;新创建个接口InterfaceB&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * @author: curry
 * @Date: 2018/7/31
 */
public interface InterfaceB {
    /**
     * 静态方法
     */
    static void showStatic() {
        System.out.println(&quot;InterfaceB++showStatic&quot;);
    }

    /**
     * 默认方法
     */
    default void showDefault() {
        System.out.println(&quot;InterfaceB ++showDefault&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改实现类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InterfaceAImpl implements InterfaceA,InterfaceB{
    @Override
    public void showDefault() {
        System.out.println(&quot;InterfaceAImpl ++ showDefault&quot;);
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InterfaceA++showStatic
InterfaceAImpl ++ showDefault&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;看了接口中新增的这个新特性，感觉还是不错的，内容也比较简单。需要注意一点就是如果实现多个接口时，每个接口都有相同的default方法需要重写该方法。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Jul 2018 14:29:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9398682.html</dc:identifier>
</item>
</channel>
</rss>