<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【ABP框架系列学习】启动配置(5) - 大龄Giser</title>
<link>http://www.cnblogs.com/OlderGiser/p/10035819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OlderGiser/p/10035819.html</guid>
<description>&lt;p&gt;ABP提供了在启动时配置模块的基础设施和模型。&lt;/p&gt;

&lt;p&gt;配置ABP是在模块的&lt;strong&gt;PreInitialize&lt;/strong&gt;方法中完成的，例如：&lt;/p&gt;

&lt;p&gt;ABP是基于模块设计的。不同的模块都可以配置ABP。例如：不同的模块可以添加导航提供者(navigation providers)往主菜单添加自定义子菜单。&lt;/p&gt;
&lt;h2&gt;替换内置(Built-In)服务&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Configuration.ReplaceService()&lt;/strong&gt;方法可以覆盖内置服务。例如，你可以用定义实现的类替换IAbpSession服务：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ReplaceService()&lt;/strong&gt;方法通过重载操作以定义方式实现替换(也可以直接使用Castle Windsor高级的注册API)。&lt;/p&gt;
&lt;p&gt;同一个服务可以多次被替换，尤其是在不同的模块间。生效的服务是最后被替换的那个。&lt;strong&gt;PreInitialize()&lt;/strong&gt;方法按依赖顺序执行。&lt;/p&gt;

&lt;p&gt;除了ABP框架自身的启动配置外，模块也可以通过扩展IAbpModuleConfigurations接口，为模块提供配置点。&lt;/p&gt;

&lt;p&gt;在上述代码中，配置AbpWebCommon模块把所有异常发送给客户端。&lt;/p&gt;
&lt;p&gt;不是每个模块都应该定义类似这种类型的配置，通常情况是在不同的应用程序中需要重复使用的才定义，并且要在启动时进行配置。&lt;/p&gt;

&lt;p&gt;假设我们有一个叫MyModule的模块，它带有一些配置属性。首先，为这些配置属性创建一个类：&lt;/p&gt;

&lt;p&gt;然后在PreInitialize方法中通过DI(Dependency Injection)注册这个类(因此，MyModuleConfig是可注册的类)：&lt;/p&gt;

&lt;p&gt;像本事例那样注册为单例对象。那么，我们可以使用如下代码在PreInitialize方法中配置MyModule模块：&lt;/p&gt;

&lt;p&gt;然而我们可以类似如下代码，通过创建IModuleConfigurations扩展方法，使用IAbpStartupConfiguration.Get()方法获得引用：&lt;/p&gt;

&lt;p&gt;那么，其它模块可以通过扩展方法配置MyModule模块：&lt;/p&gt;

&lt;p&gt;这使得查询模块配置和收集它们变得容易(Configuration.Modules...)。ABP本身为它自己的模块配置定义了扩展方法。&lt;/p&gt;
&lt;p&gt;在某些地方，MyModule模块需要这些配置，你可以通过构造函数注入并使用配置值。如下：&lt;/p&gt;

&lt;p&gt;这样，在ABP系统中，模块可以创建集中配置的点。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:49:00 +0000</pubDate>
<dc:creator>大龄Giser</dc:creator>
<og:description>ABP提供了在启动时配置模块的基础设施和模型。 1.配置ABP 配置ABP是在模块的PreInitialize方法中完成的，例如： public class SimpleTaskSystemModul</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OlderGiser/p/10035819.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core MVC 授权的扩展：自定义 Authorize Attribute 和 IApplicationModelProvide - alby</title>
<link>http://www.cnblogs.com/alby/p/10035813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alby/p/10035813.html</guid>
<description>&lt;h2 id=&quot;一、概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ASP.NET Core MVC&lt;/code&gt; 提供了基于角色( &lt;code&gt;Role&lt;/code&gt; )、声明( &lt;code&gt;Chaim&lt;/code&gt; ) 和策略 ( &lt;code&gt;Policy&lt;/code&gt; ) 等的授权方式。在实际应用中，可能采用部门（ &lt;code&gt;Department&lt;/code&gt; , 本文采用用户组 &lt;code&gt;Group&lt;/code&gt; ）、职位 ( 可继续沿用 &lt;code&gt;Role&lt;/code&gt; )、权限( &lt;code&gt;Permission&lt;/code&gt; )的方式进行授权。要达到这个目的，仅仅通过自定义 &lt;code&gt;IAuthorizationPolicyProvider&lt;/code&gt; 是不行的。本文通过自定义 &lt;code&gt;IApplicationModelProvide&lt;/code&gt; 进行扩展。&lt;/p&gt;

&lt;h2 id=&quot;二、PermissionAuthorizeAttribute-IPermissionAuthorizeData&quot;&gt;二、PermissionAuthorizeAttribute : IPermissionAuthorizeData&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AuthorizeAttribute&lt;/code&gt; 类实现了 &lt;code&gt;IAuthorizeData&lt;/code&gt; 接口：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;namespace Microsoft.AspNetCore.Authorization&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  /// &amp;lt;summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  /// Defines the set of data required to apply authorization rules to a resource.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  /// &amp;lt;/summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  public interface IAuthorizeData&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// Gets or sets the policy name that determines access to the resource.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;/summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   string Policy { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// Gets or sets a comma delimited list of roles that are allowed to access the resource.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;/summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   string Roles { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// Gets or sets a comma delimited list of schemes from which user information is constructed.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   /// &amp;lt;/summary&amp;gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;   string AuthenticationSchemes { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 AuthorizeAttribute 不外乎如下几种形式：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[Authorize]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[Authorize(&quot;SomePolicy&quot;)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[Authorize(Roles = &quot;角色1,角色2&quot;)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当然，参数还可以组合起来。另外，Roles 和 AuthenticationSchemes 的值以半角逗号分隔，是 &lt;code&gt;Or&lt;/code&gt; 的关系；多个 Authorize 是 &lt;code&gt;And&lt;/code&gt; 的关系；Policy 、Roles 和 AuthenticationSchemes 如果同时使用，也是 &lt;code&gt;And&lt;/code&gt; 的关系。&lt;/p&gt;
&lt;p&gt;如果要扩展 AuthorizeAttribute，先扩展 IAuthorizeData 增加新的属性：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;public interface IPermissionAuthorizeData : IAuthorizeData&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    string Groups { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    string Permissions { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后定义 AuthorizeAttribute:&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public class PermissionAuthorizeAttribute : Attribute, IPermissionAuthorizeData&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public string Policy { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public string Roles { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public string AuthenticationSchemes { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public string Groups { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public string Permissions { get; set; }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;现在，在 Controller 或 Action 上就可以这样使用了：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[PermissionAuthorize(Roles = &quot;经理,副经理&quot;)] // 经理或部门经理&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[PermissionAuthorize(Groups = &quot;研发部,生产部&quot;, Roles = &quot;经理&quot;] // 研发部经理或生成部经理。Groups 和 Roles 是 `And` 的关系。&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[PermissionAuthorize(Groups = &quot;研发部,生产部&quot;, Roles = &quot;经理&quot;, Permissions = &quot;请假审批&quot;] // 研发部经理或生成部经理，并且有请假审批的权限。Groups 、Roles 和 Permission 是 `And` 的关系。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;数据已经准备好，下一步就是怎么提取出来。通过扩展 AuthorizationApplicationModelProvider 来实现。&lt;/p&gt;
&lt;h2 id=&quot;三、PermissionAuthorizationApplicationModelProvider-IApplicationModelProvider&quot;&gt;三、PermissionAuthorizationApplicationModelProvider : IApplicationModelProvider&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AuthorizationApplicationModelProvider&lt;/code&gt; 类的作用是构造 &lt;code&gt;AuthorizeFilter&lt;/code&gt; 对象放入 &lt;code&gt;ControllerModel&lt;/code&gt; 或 &lt;code&gt;ActionModel&lt;/code&gt; 的 &lt;code&gt;Filters&lt;/code&gt; 属性中。具体过程是先提取 Controller 和 Action 实现了 &lt;code&gt;IAuthorizeData&lt;/code&gt; 接口的 Attribute，如果使用的是默认的&lt;code&gt;DefaultAuthorizationPolicyProvider&lt;/code&gt;，则会先创建一个 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 对象作为 &lt;code&gt;AuthorizeFilter&lt;/code&gt; 构造函数的参数。&lt;br/&gt;创建 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 对象是由 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 的静态方法 &lt;code&gt;public static async Task&amp;lt;AuthorizationPolicy&amp;gt; CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)&lt;/code&gt; 来完成的。该静态方法会解析 &lt;code&gt;IAuthorizeData&lt;/code&gt; 的数据，但不懂解析 &lt;code&gt;IPermissionAuthorizeData&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;AuthorizationApplicationModelProvider&lt;/code&gt; 类对 &lt;code&gt;AuthorizationPolicy.CombineAsync&lt;/code&gt; 静态方法有依赖，这里不得不做一个类似的 &lt;code&gt;PermissionAuthorizationApplicationModelProvider&lt;/code&gt; 类，在本类实现 &lt;code&gt;CombineAsync&lt;/code&gt; 方法。暂且不论该方法放在本类是否合适的问题。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;28.5&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;42&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;43&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;44&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;45&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;46&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;47&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;48&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;49&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;50&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;51&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;52&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;53&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;54&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;55&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;56&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;57&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;58&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;59&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;60&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;61&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;62&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;63&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;64&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;65&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;66&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;67&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;68&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;69&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;70&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;71&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;72&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;73&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;74&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;75&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;76&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;77&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;78&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;79&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;80&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;81&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;82&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;83&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;       public static AuthorizeFilter GetFilter(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authData)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           // The default policy provider will make the same policy for given input, so make it only once.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           // This will always execute synchronously.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           if (policyProvider.GetType() == typeof(DefaultAuthorizationPolicyProvider))&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               var policy = CombineAsync(policyProvider, authData).GetAwaiter().GetResult();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               return new AuthorizeFilter(policy);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           else&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               return new AuthorizeFilter(policyProvider, authData);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       private static async Task&amp;lt;AuthorizationPolicy&amp;gt; CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           if (policyProvider == null)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               throw new ArgumentNullException(nameof(policyProvider));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           if (authorizeData == null)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               throw new ArgumentNullException(nameof(authorizeData));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           var policyBuilder = new AuthorizationPolicyBuilder();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           var any = false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           foreach (var authorizeDatum in authorizeData)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               any = true;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               var useDefaultPolicy = true;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               if (!string.IsNullOrWhiteSpace(authorizeDatum.Policy))&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   var policy = await policyProvider.GetPolicyAsync(authorizeDatum.Policy);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   if (policy == null)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       //throw new InvalidOperationException(Resources.FormatException_AuthorizationPolicyNotFound(authorizeDatum.Policy));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       throw new InvalidOperationException(nameof(authorizeDatum.Policy));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;policyBuilder.Combine(policy);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   useDefaultPolicy = false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               var rolesSplit = authorizeDatum.Roles?.Split(',');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               if (rolesSplit != null &amp;amp;&amp;amp; rolesSplit.Any())&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   var trimmedRolesSplit = rolesSplit.Where(r =&amp;gt; !string.IsNullOrWhiteSpace(r)).Select(r =&amp;gt; r.Trim());&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   policyBuilder.RequireRole(trimmedRolesSplit);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   useDefaultPolicy = false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               if(authorizeDatum is IPermissionAuthorizeData permissionAuthorizeDatum )&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   var groupsSplit = permissionAuthorizeDatum.Groups?.Split(',');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   if (groupsSplit != null &amp;amp;&amp;amp; groupsSplit.Any())&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       var trimmedGroupsSplit = groupsSplit.Where(r =&amp;gt; !string.IsNullOrWhiteSpace(r)).Select(r =&amp;gt; r.Trim());&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       policyBuilder.RequireClaim(&quot;Group&quot;, trimmedGroupsSplit); // TODO: 注意硬编码&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       useDefaultPolicy = false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   var permissionsSplit = permissionAuthorizeDatum.Permissions?.Split(',');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   if (permissionsSplit != null &amp;amp;&amp;amp; permissionsSplit.Any())&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       var trimmedPermissionsSplit = permissionsSplit.Where(r =&amp;gt; !string.IsNullOrWhiteSpace(r)).Select(r =&amp;gt; r.Trim());&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       policyBuilder.RequireClaim(&quot;Permission&quot;, trimmedPermissionsSplit);// TODO: 注意硬编码&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       useDefaultPolicy = false;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               var authTypesSplit = authorizeDatum.AuthenticationSchemes?.Split(',');&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               if (authTypesSplit != null &amp;amp;&amp;amp; authTypesSplit.Any())&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   foreach (var authType in authTypesSplit)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       if (!string.IsNullOrWhiteSpace(authType))&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                           policyBuilder.AuthenticationSchemes.Add(authType.Trim());&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                       }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;                   }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               if (useDefaultPolicy)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;policyBuilder.Combine(await policyProvider.GetDefaultPolicyAsync());&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;               }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;           return any ? policyBuilder.Build() : null;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;       }&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;if(authorizeDatum is IPermissionAuthorizeData permissionAuthorizeDatum )&lt;/code&gt; 为扩展部分。&lt;/p&gt;
&lt;h2 id=&quot;四、Startup&quot;&gt;四、Startup&lt;/h2&gt;
&lt;p&gt;注册 &lt;code&gt;PermissionAuthorizationApplicationModelProvider&lt;/code&gt; 服务，需要在 &lt;code&gt;AddMvc&lt;/code&gt; 之后替换掉 &lt;code&gt;AuthorizationApplicationModelProvider&lt;/code&gt; 服务。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;services.AddMvc();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;services.Replac(ServiceDescriptor.Transient&amp;lt;IApplicationModelProvider,PermissionAuthorizationApplicationModelProvider&amp;gt;());&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;五、Jwt-示例&quot;&gt;五、Jwt 示例&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;48&quot;&gt;&lt;td class=&quot;gutter&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[Route(&quot;api/[controller]&quot;)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;[ApiController]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;public class ValuesController : ControllerBase&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    private readonly JwtSecurityTokenHandler _tokenHandler = new JwtSecurityTokenHandler();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [HttpGet]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [Route(&quot;SignIn&quot;)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public async Task&amp;lt;ActionResult&amp;lt;string&amp;gt;&amp;gt; SignIn()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var user = new ClaimsPrincipal(new ClaimsIdentity(new[]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            // 备注：Claim Type: Group 和 Permission 这里使用的是硬编码，应该定义为类似于 ClaimTypes.Role 的常量；另外，下列模拟数据不一定合逻辑。&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(ClaimTypes.Name, &quot;Bob&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(ClaimTypes.Role, &quot;经理&quot;),  // 注意：不能使用逗号分隔来达到多个角色的目的，下同。&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(ClaimTypes.Role, &quot;副经理&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(&quot;Group&quot;, &quot;研发部&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(&quot;Group&quot;, &quot;生产部&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(&quot;Permission&quot;, &quot;请假审批&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(&quot;Permission&quot;, &quot;权限1&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            new Claim(&quot;Permission&quot;, &quot;权限2&quot;),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        }, JwtBearerDefaults.AuthenticationScheme));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var token = new JwtSecurityToken(&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &quot;SignalRAuthenticationSample&quot;,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            &quot;SignalRAuthenticationSample&quot;,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            user.Claims,&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            expires: DateTime.UtcNow.AddDays(30),&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;            signingCredentials: SignatureHelper.GenerateSigningCredentials(&quot;1234567890123456&quot;));&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        return _tokenHandler.WriteToken(token);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [HttpGet]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [Route(&quot;Test&quot;)]&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    [PermissionAuthorize(Groups = &quot;研发部,生产部&quot;, Roles = &quot;经理&quot;, Permissions = &quot;请假审批&quot;] // 研发部经理或生成部经理，并且有请假审批的权限。Groups 、Roles 和 Permission 是 `And` 的关系。&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    public async Task&amp;lt;ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; Test()&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        var user = HttpContext.User;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        return new string[] { &quot;value1&quot;, &quot;value2&quot; };&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;六、问题&quot;&gt;六、问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AuthorizeFilter&lt;/code&gt; 类显示实现了 &lt;code&gt;IFilterFactory&lt;/code&gt; 接口的 &lt;code&gt;CreateInstance&lt;/code&gt; 方法：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;IFilterMetadata IFilterFactory.CreateInstance(IServiceProvider serviceProvider)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;{&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    if (Policy != null || PolicyProvider != null)&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    {&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        // The filter is fully constructed. Use the current instance to authorize.&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;        return this;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    }&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    Debug.Assert(AuthorizeData != null);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    var policyProvider = serviceProvider.GetRequiredService&amp;lt;IAuthorizationPolicyProvider&amp;gt;();&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;    return AuthorizationApplicationModelProvider.GetFilter(policyProvider, AuthorizeData);&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;竟然对 &lt;code&gt;AuthorizationApplicationModelProvider.GetFilter&lt;/code&gt; 静态方法产生了依赖。庆幸的是，如果通过 &lt;code&gt;AuthorizeFilter(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)&lt;/code&gt; 或 &lt;code&gt;AuthorizeFilter(AuthorizationPolicy policy)&lt;/code&gt; 创建 &lt;code&gt;AuthorizeFilter&lt;/code&gt; 对象不会产生什么不良影响。&lt;/p&gt;
&lt;h2 id=&quot;七、下一步&quot;&gt;七、下一步&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;[PermissionAuthorize(Groups = &quot;研发部,生产部&quot;, Roles = &quot;经理&quot;, Permissions = &quot;请假审批&quot;]&lt;/code&gt; 这种形式还是不够灵活，哪怕用多个 Attribute, &lt;code&gt;And&lt;/code&gt; 和 &lt;code&gt;Or&lt;/code&gt; 的逻辑组合不一定能满足需求。可以在 &lt;code&gt;IPermissionAuthorizeData&lt;/code&gt; 新增一个 &lt;code&gt;Rule&lt;/code&gt; 属性，实现类似的效果：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;line&quot;&gt;[PermissionAuthorize(Rule = &quot;(Groups:研发部,生产部)&amp;amp;&amp;amp;(Roles:请假审批||Roles:超级权限)&quot;]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;通过 &lt;code&gt;Rule&lt;/code&gt; 计算复杂的授权。&lt;/p&gt;
&lt;h2 id=&quot;八、如果通过自定义-IAuthorizationPolicyProvider-实现？&quot;&gt;八、如果通过自定义 IAuthorizationPolicyProvider 实现？&lt;/h2&gt;
&lt;p&gt;另一种方式是自定义 &lt;code&gt;IAuthorizationPolicyProvider&lt;/code&gt; ，不过还需要自定义 &lt;code&gt;AuthorizeFilter&lt;/code&gt;。因为当不是使用 &lt;code&gt;DefaultAuthorizationPolicyProvider&lt;/code&gt; 而是自定义 &lt;code&gt;IAuthorizationPolicyProvider&lt;/code&gt; 时，&lt;code&gt;AuthorizationApplicationModelProvider&lt;/code&gt;（或前文定义的 &lt;code&gt;PermissionAuthorizationApplicationModelProvider&lt;/code&gt;）会使用 &lt;code&gt;AuthorizeFilter(IAuthorizationPolicyProvider policyProvider, IEnumerable&amp;lt;IAuthorizeData&amp;gt; authorizeData)&lt;/code&gt; 创建 &lt;code&gt;AuthorizeFilter&lt;/code&gt; 对象，而不是 &lt;code&gt;AuthorizeFilter(AuthorizationPolicy policy)&lt;/code&gt;。这会造成 &lt;code&gt;AuthorizeFilter&lt;/code&gt; 对象在 &lt;code&gt;OnAuthorizationAsync&lt;/code&gt; 时会间接调用 &lt;code&gt;AuthorizationPolicy.CombineAsync&lt;/code&gt; 静态方法。&lt;/p&gt;
&lt;p&gt;这可以说是一个设计上的缺陷，不应该让 &lt;code&gt;AuthorizationPolicy.CombineAsync&lt;/code&gt; 静态方法存在，哪怕提供个 &lt;code&gt;IAuthorizationPolicyCombiner&lt;/code&gt; 也好。另外，上文提到的 &lt;code&gt;AuthorizationApplicationModelProvider.GetFilter&lt;/code&gt; 静态方法同样不是一种好的设计。等微软想通吧。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-2.1&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;排版问题：&lt;a href=&quot;http://blog.tubumu.com/2018/11/28/aspnetcore-mvc-extend-authorization/&quot; target=&quot;_blank&quot;&gt;http://blog.tubumu.com/2018/11/28/aspnetcore-mvc-extend-authorization/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:48:00 +0000</pubDate>
<dc:creator>alby</dc:creator>
<og:description>ASP.NET Core MVC 提供了基于角色( Role )、声明( Chaim ) 和策略 ( Policy ) 等的授权方式。在实际应用中，可能采用部门（ Department , 本文采用用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alby/p/10035813.html</dc:identifier>
</item>
<item>
<title>C#语言中字段和属性相关知识剖析 - firefox逍遥一下</title>
<link>http://www.cnblogs.com/xu-yi/p/10025735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu-yi/p/10025735.html</guid>
<description>&lt;p&gt;针对C#中的字段和属性，很多初学者无法区分这两者之间的区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段与属性比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段;&lt;/strong&gt;是一种“成员变量”，一般在类的内部做数据交互使用，占用内存空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性：a.&lt;/strong&gt;是一种逻辑变量，一般跟字段一起结合起来使用，是字段的扩展，并不占用实际的内存。&lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;b&lt;/strong&gt;.属性其实就是外界访问私有字段的入口，属性本身不保存任何数据。在面向对象设计中主要使用属性描述对象的静态特征。&lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;c&lt;/strong&gt;.属性设置过程中一般会用到get和set两个方法。可以在方法里加入逻辑处理数据，灵活拓展使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标注：因为属性不占用实际内存，所以属性不能用于方法的ref类型参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面举个栗子，如下所示&lt;/p&gt;
&lt;p&gt;public Class Student&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  private DateTime _Birthday;&lt;/p&gt;
&lt;p&gt;   private string _Name;&lt;/p&gt;
&lt;p&gt;  public string Name&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;    get{return _Name;}&lt;/p&gt;
&lt;p&gt;   set {this._Name=value;}&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt; public int Age&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  get {return DateTime.Now.Year-this._Birthday.Year}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在这个例子中，_Name是字段，而Name为属性，Name属性的get方法为返回学生的姓名，Set方法则是对_Name字段进行赋值。&lt;/p&gt;
&lt;p&gt;Age也是类中的一个属性，只不过这个属性是只读属性，get方法返回格式化之后的年龄数据，这就是使用属性很好的控制了返回数据的格式，不然还得专门写个方法去格式化数据。&lt;/p&gt;
&lt;p&gt;同时，属性也可以通过相应的条件对字段赋值进行相应的限制，比如我们要限定Student的名字长度最长不能超过5个字，超过5个字的，我们就只截取前面5个字符即可。&lt;/p&gt;
&lt;p&gt;为了实现这种效果，我们可以在set方法内做逻辑规则运算,即可轻松实现想要的效果，如下所示，设置Name属性为：&lt;/p&gt;
&lt;p&gt;Public string Name&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;      get {return _Name}&lt;/p&gt;
&lt;p&gt;      set&lt;/p&gt;
&lt;p&gt;     {&lt;/p&gt;
&lt;p&gt;            if(value.Length&amp;gt;5)&lt;/p&gt;
&lt;p&gt;                    this._Name=value.Substring(0,5);&lt;/p&gt;
&lt;p&gt;           else&lt;/p&gt;
&lt;p&gt;                    this._Name=value;&lt;/p&gt;
&lt;p&gt;     }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;直接对字段赋值是无法达到上述效果，你需要在每次给字段赋值的时候，调用函数获取理想值。使用属性可以完美避免非法数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用属性的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要求字段只能读或者只能写；&lt;/li&gt;
&lt;li&gt;需要限制字段的取值范围；&lt;/li&gt;
&lt;li&gt;在改变一个字段的值的时候希望改变对象的其它一些状态； &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用字段的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许自由读写；&lt;/li&gt;
&lt;li&gt;取值范围只受数据类型约束而无其他任何特定限制；&lt;/li&gt;
&lt;li&gt;值的变动不需要引发类中其它任何成员的相应变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;最后，附上我的ASP.NET学习群，欢迎各位同行入群指导交流。技术群：【ASP.NET技术社区】872894940&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 28 Nov 2018 15:43:00 +0000</pubDate>
<dc:creator>firefox逍遥一下</dc:creator>
<og:description>针对C#中的字段和属性，很多初学者无法区分这两者之间的区别。 字段与属性比较 字段;是一种“成员变量”，一般在类的内部做数据交互使用，占用内存空间。 属性：a.是一种逻辑变量，一般跟字段一起结合起来使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu-yi/p/10025735.html</dc:identifier>
</item>
<item>
<title>补习系列(13)-springboot redis 与发布订阅 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10035786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10035786.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一订阅发布&quot;&gt;一、订阅发布&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;订阅发布&lt;/strong&gt;是一种常见的设计模式，常见于消息系统的场景。&lt;br/&gt;如下面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233806987-440877065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;[图来自百科]&lt;br/&gt;消息发布者是消息载体的生产者，其通过某些主题来向&lt;strong&gt;调度中心&lt;/strong&gt;发送消息；&lt;br/&gt;而消息订阅者会事先向&lt;strong&gt;调度中心&lt;/strong&gt;订阅其&lt;strong&gt;&quot;感兴趣&quot;&lt;/strong&gt;的主题，随后会获得新消息。&lt;br/&gt;在这里，&lt;strong&gt;调度中心&lt;/strong&gt;是一个负责消息控制中转的逻辑实体，可以是消息队列如ActiveMQ，也可以是Web服务等等。&lt;/p&gt;
&lt;h3 id=&quot;常见应用&quot;&gt;常见应用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;微博，每个用户的粉丝都是该用户的订阅者，当用户发完微博，所有粉丝都将收到他的动态；&lt;/li&gt;
&lt;li&gt;新闻，资讯站点通常有多个频道，每个频道就是一个主题，用户可以通过主题来做订阅(如RSS)，这样当新闻发布时，订阅者可以获得更新。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二redis-与订阅发布&quot;&gt;二、Redis 与订阅发布&lt;/h2&gt;
&lt;p&gt;Redis 支持 (pub/sub) 的订阅发布能力，客户端可以通过channel(频道)来实现消息的发布及接收。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端通过 SUBSCRIBE 命令订阅 channel；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233829563-1376860022.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端通过PUBLISH 命令向channel 发送消息；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201811/242916-20181128233841819-2136859731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而后，订阅 channel的客户端可实时收到消息。&lt;/p&gt;
&lt;p&gt;除了简单的SUBSCRIBE/PUBLISH命令之外，Redis还支持订阅某一个模式的主题(正则表达式)，&lt;br/&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PSUBSCRIBE  /topic/cars/*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，我们可以利用这点实现相对复杂的订阅能力，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在电商平台中订阅多个品类的商品促销信息；&lt;/li&gt;
&lt;li&gt;智能家居场景，APP可以订阅所有房间的设备消息。&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽管如此，Redis pub/sub 机制存在一些缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息无法持久化，存在丢失风险；&lt;/li&gt;
&lt;li&gt;没有类似 RabbitMQ的ACK机制；&lt;/li&gt;
&lt;li&gt;由于是广播机制，无法通过添加worker 提升消费能力；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，Redis 的订阅发布建议用于&lt;strong&gt;&lt;em&gt;实时且可靠性要求不高&lt;/em&gt;&lt;/strong&gt;的场景。&lt;/p&gt;
&lt;h2 id=&quot;三springboot-与订阅发布&quot;&gt;三、SpringBoot 与订阅发布&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来，看一下SpringBoot 怎么实现订阅发布的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-starter-data-redis&lt;/strong&gt; 帮我们实现了Jedis的引入，pom 依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;!-- redis --&amp;gt;
  &amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;&lt;em&gt;application.properties&lt;/em&gt;&lt;/strong&gt; 中指定配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# redis 连接配置
spring.redis.database=0 
spring.redis.host=127.0.0.1
spring.redis.password=
spring.redis.port=6379
spring.redis.ssl=false

# 连接池最大数
spring.redis.pool.max-active=10 
# 空闲连接最大数
spring.redis.pool.max-idle=10
# 获取连接最大等待时间(s)
spring.redis.pool.max-wait=600000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;a.-消息模型&quot;&gt;A. 消息模型&lt;/h3&gt;
&lt;p&gt;消息模型描述了订阅发布的数据对象，这要求生产者与消费者都能理解&lt;br/&gt;以下面的POJO为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static class SimpleMessage {

        private String publisher;
        private String content;
        private Date createTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SimpleMessage类中，我们声明了几个字段：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;publisher&lt;/td&gt;
&lt;td&gt;发布者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;文本内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;createTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;b.-序列化&quot;&gt;B. 序列化&lt;/h3&gt;
&lt;p&gt;如下的代码采用了JSON 作为序列化方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class RedisConfig {

    private static final Logger logger = LoggerFactory.getLogger(RedisConfig.class);

    /**
     * 序列化定制
     * 
     * @return
     */
    @Bean
    public Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonSerializer() {
        Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&amp;lt;&amp;gt;(
                Object.class);

        // 初始化objectmapper
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(Include.NON_NULL);
        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(mapper);
        return jackson2JsonRedisSerializer;
    }

    /**
     * 操作模板
     * 
     * @param connectionFactory
     * @param jackson2JsonRedisSerializer
     * @return
     */
    @Bean
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(JedisConnectionFactory connectionFactory,
            Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer) {

        RedisTemplate&amp;lt;String, Object&amp;gt; template = new RedisTemplate&amp;lt;String, Object&amp;gt;();
        template.setConnectionFactory(connectionFactory);

        // 设置key/hashkey序列化
        RedisSerializer&amp;lt;String&amp;gt; stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer);
        template.setHashKeySerializer(stringSerializer);

        // 设置值序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;c.-发布消息&quot;&gt;C. 发布消息&lt;/h3&gt;
&lt;p&gt;消息发布，需要先指定一个ChannelTopic对象，随后通过RedisTemplate方法操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class RedisPubSub {  
    private static final Logger logger = LoggerFactory.getLogger(RedisPubSub.class);

    @Autowired
    private RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;

    private ChannelTopic topic = new ChannelTopic(&quot;/redis/pubsub&quot;);

  
    @Scheduled(initialDelay = 5000, fixedDelay = 10000)
    private void schedule() {
        logger.info(&quot;publish message&quot;);
        publish(&quot;admin&quot;, &quot;hey you must go now!&quot;);
    }

    /**
     * 推送消息
     * 
     * @param publisher
     * @param message
     */
    public void publish(String publisher, String content) {
        logger.info(&quot;message send {} by {}&quot;, content, publisher);

        SimpleMessage pushMsg = new SimpleMessage();
        pushMsg.setContent(content);
        pushMsg.setCreateTime(new Date());
        pushMsg.setPublisher(publisher);

        redisTemplate.convertAndSend(topic.getTopic(), pushMsg);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码使用一个定时器(@Schedule)来做发布，为了保证运行需要在主类中启用定时器注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@EnableScheduling
@SpringBootApplication
public class BootSampleRedis{
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;d.-接收消息&quot;&gt;D. 接收消息&lt;/h3&gt;
&lt;p&gt;定义一个消息接收处理的Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Component
    public static class MessageSubscriber {

        public void onMessage(SimpleMessage message, String pattern) {
            logger.info(&quot;topic {} received {} &quot;, pattern, JsonUtil.toJson(message));
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，利用 MessageListenerAdapter 可将消息通知到Bean方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       /**
         * 消息监听器，使用MessageAdapter可实现自动化解码及方法代理
         * 
         * @return
         */
        @Bean
        public MessageListenerAdapter listener(Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jackson2JsonRedisSerializer,
                MessageSubscriber subscriber) {
            MessageListenerAdapter adapter = new MessageListenerAdapter(subscriber, &quot;onMessage&quot;);
            adapter.setSerializer(jackson2JsonRedisSerializer);
            adapter.afterPropertiesSet();
            return adapter;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，关联到消息发布的Topic：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /**
         * 将订阅器绑定到容器
         * 
         * @param connectionFactory
         * @param listenerAdapter
         * @return
         */
        @Bean
        public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                MessageListenerAdapter listener) {

            RedisMessageListenerContainer container = new RedisMessageListenerContainer();
            container.setConnectionFactory(connectionFactory);
            container.addMessageListener(listener, new PatternTopic(&quot;/redis/*&quot;));
            return container;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;br/&gt;启动程序，从控制台可输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.RedisPubSub : publish message
.RedisPubSub : message send hey you must go now! by admin
.RedisPubSub : topic /redis/* received {&quot;publisher&quot;:&quot;admin&quot;,&quot;content&quot;:&quot;hey you must go now!&quot;,&quot;createTime&quot;:1543418694007} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们便完成了订阅发布功能。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;消息订阅发布是分布式系统中的常用手段，也经常用来实现系统解耦、性能优化等目的；&lt;br/&gt;当前小节结合SpringBoot 演示了 Redis订阅发布(pub/sub)的实现，在部分场景下可以参考使用。&lt;br/&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:39:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、订阅发布 订阅发布 是一种常见的设计模式，常见于消息系统的场景。 如下面的图： [图来自百科] 消息发布者是消息载体的生产者，其通过某些主题来向 调度中心 发送消息； 而消息订阅者会事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10035786.html</dc:identifier>
</item>
<item>
<title>eShopOnContainers 知多少[4]：Catalog microservice - 『圣杰』</title>
<link>http://www.cnblogs.com/sheng-jie/p/10035771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/10035771.html</guid>
<description>&lt;p&gt;Catalog microservice（目录微服务）维护着所有产品信息，包括库存、价格。所以该微服务的核心业务为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;产品信息的维护&lt;/li&gt;
&lt;li&gt;库存的更新&lt;/li&gt;
&lt;li&gt;价格的维护&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-8ee92fc413d17822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据驱动/CRUD 微服务设计&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，本微服务采用简单的数据驱动的CRUD微服务架构，来执行产品信息的创建、读取、更新和删除（CRUD）操作。&lt;br/&gt;这种类型的服务在单个 ASP.NET Core Web API 项目中即可实现所有功能，该项目包括数据模型类、业务逻辑类及其数据访问类。其项目结构如下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-2283cbfdcc9a7271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;核心技术选型：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;ASP.NET Core Web API&lt;/li&gt;
&lt;li&gt;Entity Framework Core&lt;/li&gt;
&lt;li&gt;SQL Server&lt;/li&gt;
&lt;li&gt;Swashbuckle（可选）&lt;/li&gt;
&lt;li&gt;Autofac&lt;/li&gt;
&lt;li&gt;Eventbus&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Polly&lt;/p&gt;

&lt;p&gt;该微服务的核心领域实体是商品，其类图如下：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-0ffd78f8c096b32d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于实体这一块，有两个小知识点需要说明一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行数据库字段映射时，主键都使用了&lt;code&gt;ForSqlServerUseSequenceHiLo&lt;/code&gt;指定使用&lt;code&gt;HI-LO&lt;/code&gt;高低位序列进行主键生成。&lt;/li&gt;
&lt;li&gt;使用NoTracking提升查询速度&lt;br/&gt;在&lt;code&gt;CatalogController&lt;/code&gt;的构造方法中，明确指定以下代码来进行查询优化，这一点也是我们值得学习的地方。&lt;code&gt;((DbContext)context).ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在进行种子数据的预置时，使用了&lt;code&gt;Polly&lt;/code&gt;开启了Retry机制。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;private Policy CreatePolicy( ILogger&amp;lt;CatalogContextSeed&amp;gt; logger, string prefix,int retries = 3)
{
    return Policy.Handle&amp;lt;SqlException&amp;gt;().
        WaitAndRetryAsync(
            retryCount: retries,
            sleepDurationProvider: retry =&amp;gt; TimeSpan.FromSeconds(5),
            onRetry: (exception, timeSpan, retry, ctx) =&amp;gt;
            {
                logger.LogTrace($&quot;[{prefix}] Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}&quot;);
            }
        );
}
public async Task SeedAsync(CatalogContext context,IHostingEnvironment env,IOptions&amp;lt;CatalogSettings&amp;gt; settings,ILogger&amp;lt;CatalogContextSeed&amp;gt; logger)
{
    var policy = CreatePolicy(logger, nameof(CatalogContextSeed));

    await policy.ExecuteAsync(async () =&amp;gt;
    {
        //...
    });       
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-fda90fdfdbaec4bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;CatalogDb&quot;/&gt;&lt;br/&gt;你肯定会好奇为什么会多了一张&lt;code&gt;IntegrationEventLog&lt;/code&gt;表，这里先按住不表。&lt;/p&gt;

&lt;p&gt;如果eShopOnContainers采用的是单体式应用架构而非微服务架构，那么以上业务逻辑的实现并不复杂，使用简单的CRUD再辅以ACID事务就能很好的完成业务需求。本文的介绍也就可以到此为止了。&lt;/p&gt;
&lt;p&gt;然而将其抽取出来成为独立的基础微服务，那么我们要考虑的问题就多了。比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改产品价格时，需要同步更新购物车中保存的产品信息的价格。&lt;/li&gt;
&lt;li&gt;下订单时，需要验证当前商品库存是否充足，进行锁库抢占，以避免库存不足导致的订单无效。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而这一切我们都不能再享受单体应用中直接使用ACID事务的便利了。因为在微服务应用里，产品表和购物篮表被各自的微服务所占有。任何微服务不应该在自己的事务中包含其他微服务的表或存储，即使是直接查询也是不可以的。目录微服务不能直接更新购物篮表，因为购物篮表被购物篮微服务占有。要更新购物篮微服务，产品微服务应该使用基于异步通信，如集成事件（消息和基于事件的通信）来实现最终一致性。&lt;/p&gt;
&lt;p&gt;那下一节我们就来详细阐述eShopOnContainers是如何通过事件机制完成最终一致性的。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>『圣杰』</dc:creator>
<og:description>引言 Catalog microservice（目录微服务）维护着所有产品信息，包括库存、价格。所以该微服务的核心业务为： 1. 产品信息的维护 2. 库存的更新 3. 价格的维护 架构模式 如上图所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheng-jie/p/10035771.html</dc:identifier>
</item>
<item>
<title>Go标准库：深入剖析Go template - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10035768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10035768.html</guid>
<description>&lt;p&gt;本文只关注Go text/template的底层结构，带上了很详细的图片以及示例帮助理解，有些地方也附带上了源码进行解释。有了本文的解释，对于Go template的语法以及html/template的用法，一切都很简单。&lt;/p&gt;
&lt;h2 id=&quot;入门示例&quot;&gt;入门示例&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;html/template&quot;
    &quot;os&quot;
)

type Person struct {
    Name string
    Age    int
}

func main() {
    p := Person{&quot;longshuai&quot;, 23}
    tmpl, err := template.New(&quot;test&quot;).Parse(&quot;Name: {{.Name}}, Age: {{.Age}}&quot;)
    if err != nil {
        panic(err)
    }
    err = tmpl.Execute(os.Stdout, p)
    if err != nil {
        panic(err)
    }
    fmt.Println(tmpl)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个Person结构，有两个&lt;strong&gt;大写字母开头&lt;/strong&gt;(意味着这俩字段是导出的)的字段Name和Age。然后main()中创建了Person的实例对象p。&lt;/p&gt;
&lt;p&gt;紧接着使用template.New()函数创建了一个空Template实例(对象)，然后通过这个template实例调用Parse()方法，Parse()方法用来解析、评估模板中需要执行的action，其中需要评估的部分都使用&lt;code&gt;{{}}&lt;/code&gt;包围，并将评估后(解析后)的结果赋值给tmpl。&lt;/p&gt;
&lt;p&gt;最后调用Execute()方法，该方法将数据对象Person的实例p应用到已经解析的tmpl模板，最后将整个应用合并后的结果输出到os.Stdout。&lt;/p&gt;
&lt;p&gt;上面的示例很简单，两个注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;流程：构建模板对象New()--&amp;gt;解析数据Parse()--&amp;gt;应用合并Execute()&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Parse()解析的对象中包含了&lt;code&gt;{{}}&lt;/code&gt;，其中使用了点(.)，&lt;code&gt;{{.Name}}&lt;/code&gt;代表Execute()第二个参数p对象的Name字段，同理&lt;code&gt;{{.Age}}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说，&lt;code&gt;{{.}}&lt;/code&gt;代表的是要应用的对象，类似于java/c++中的this，python/perl中的self。&lt;/p&gt;
&lt;p&gt;更通用地，&lt;code&gt;{{.}}&lt;/code&gt;表示的是所处作用域的当前对象，而不仅仅只代表Execute()中的第二个参数对象。例如，本示例中&lt;code&gt;{{.}}&lt;/code&gt;代表顶级作用域的对象p，如果Parse()中还有嵌套的作用域range，则&lt;code&gt;{{.}}&lt;/code&gt;代表range迭代到的每个元素对象。如果了解perl语言，&lt;code&gt;{{.}}&lt;/code&gt;可以理解为默认变量&lt;code&gt;$_&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;模板关联associate&quot;&gt;模板关联(associate)&lt;/h2&gt;
&lt;p&gt;template中有不少函数、方法都直接返回&lt;code&gt;*Template&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128115459994-1350629608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中使用红色框线框起来一部分返回值是&lt;code&gt;*Template&lt;/code&gt;的函数、方法。对于函数，它们返回一个Template实例(假设为t)，对于使用t作为参数的Must()函数和那些框起来的Template方法，它们返回的&lt;code&gt;*Template&lt;/code&gt;&lt;strong&gt;其实是原始实例t&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t := template.New(&quot;abc&quot;)
tt,err := t.Parse(&quot;xxxxxxxxxxx&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的t和tt其实都指向同一个模板对象。&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;t称为模板的关联名称&lt;/strong&gt;。通俗一点，就是创建了一个模板，关联到变量t上。但&lt;strong&gt;注意，t不是模板的名称，因为Template中有一个未导出的name字段，它才是模板的名称&lt;/strong&gt;。可以通过Name()方法返回name字段的值，而且仔细观察上面的函数、方法，有些是以name作为参数的。&lt;/p&gt;
&lt;p&gt;之所以要区分模板的关联名称(t)和模板的名称(name)，是因为&lt;strong&gt;一个关联名称t(即模板对象)上可以&quot;包含&quot;多个name，也就是多个模板，通过t和各自的name，可以调用到指定的模板&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;模板结构详解&quot;&gt;模板结构详解&lt;/h2&gt;
&lt;p&gt;首先看Template结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Template struct {
    name string
    *parse.Tree
    *common
    leftDelim  string
    rightDelim string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;name是这个Template的名称，Tree是解析树，common是另一个结构，稍后解释。leftDelim和rightDelim是左右两边的分隔符，默认为&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;}}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要关注name和common两个字段，name字段没什么解释的。common是一个结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type common struct {
    tmpl   map[string]*Template // Map from name to defined templates.
    option option
    muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
    parseFuncs FuncMap
    execFuncs  map[string]reflect.Value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结构的第一个字段tmpl是一个Template的map结构，key为template的name，value为Template。也就是说，一个common结构中可以包含多个Template，而Template结构中又指向了一个common结构。所以，common是一个模板组，在这个模板组中的(tmpl字段)所有Template都共享一个common(模板组)，模板组中包含parseFuncs和execFuncs。&lt;/p&gt;
&lt;p&gt;大概结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128144435142-440659768.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了需要关注的name和common，parseFuncs和execFuncs这两个字段也需要了解下，它们共同成为模板的FuncMap。&lt;/p&gt;
&lt;h3 id=&quot;new函数和init方法&quot;&gt;New()函数和init()方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用template.New()函数可以创建一个空的、无解析数据的模板，同时还会创建一个common，也就是模板组&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func New(name string) *Template {
    t := &amp;amp;Template{
        name: name,
    }
    t.init()
    return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中t为模板的关联名称，name为模板的名称，t.init()表示如果模板对象t还没有common结构，就构造一个新的common组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) init() {
    if t.common == nil {
        c := new(common)
        c.tmpl = make(map[string]*Template)
        c.parseFuncs = make(FuncMap)
        c.execFuncs = make(map[string]reflect.Value)
        t.common = c
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，&lt;strong&gt;template.New()函数不仅创建了一个模板，还创建了一个空的common结构(模板组)。需要注意，新创建的common是空的，只有进行模板解析(Parse()，ParseFiles()等操作)之后，才会将模板添加到common的tmpl字段(map结构)中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tmpl := template.New(&quot;mytmpl1&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完后将生成如下结构，其中tmpl为模板关联名称，mytmpl1为模板名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128161909028-1756603346.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为还没有进行解析操作，所以上图使用虚线表示尚不存在的部分。&lt;/p&gt;
&lt;p&gt;实际上，在template包中，很多涉及到操作Template的函数、方法，都会调用init()方法保证返回的Template都有一个有效的common结构。当然，因为init()方法中进行了判断，对于已存在common的模板，不会新建common结构。&lt;/p&gt;
&lt;p&gt;假设现在执行了Parse()方法，将会把模板name添加到common tmpl字段的map结构中，其中模板name为map的key，模板为map的value。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    tmpl,_ := t1.Parse(
            `{{define &quot;T1&quot;}}ONE{{end}}
            {{define &quot;T2&quot;}}TWO{{end}}
            {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
            {{template &quot;T3&quot;}}`)
    fmt.Println(t1)
    fmt.Println(tmpl)
    fmt.Println(t1.Lookup(&quot;test1&quot;))  // 使用关联名称t1检索test1模板
    fmt.Println(t1.Lookup(&quot;T1&quot;))
    fmt.Println(tmpl.Lookup(&quot;T2&quot;)) // 使用关联名称tmpl检索T2模板
    fmt.Println(tmpl.Lookup(&quot;T3&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的执行结果：注意前3行的结果完全一致，所有行的第二个地址完全相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{test1 0xc0420a6000 0xc0420640c0  }
&amp;amp;{T1 0xc0420a6100 0xc0420640c0  }
&amp;amp;{T2 0xc0420a6200 0xc0420640c0  }
&amp;amp;{T3 0xc0420a6300 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先使用template.New()函数创建了一个名为test1的模板，同时创建了一个模板组(common)，它们关联在t1变量上。&lt;/p&gt;
&lt;p&gt;然后调用Parse()方法，在Parse()的待解析字符串中使用define又定义了3个新的模板对象，模板的name分别为T1、T2和T3，其中T1和T2嵌套在T3中，因为调用的是t1的Parse()，所以这3个新创建的模板都会关联到t1上。&lt;/p&gt;
&lt;p&gt;也就是说，现在t1上关联了4个模板：test1、T1、T2、T3，它们全都共享同一个common。因为已经执行了Parse()解析操作，这个Parse()会将test1、T1、T2、T3的name添加到common.tmpl的map中。也就是说，common的tmpl字段的map结构中有4个元素。&lt;/p&gt;
&lt;p&gt;结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128171511862-2078777047.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必须注意，虽然test1、T1、T2、T3都关联在t1上，但t1只能代表test1(所以上图中只有test1下面标注了t1)，因为t1是一个Template类型。可以认为test1、T1、T2、T3这4个模板共享一个组，但T1、T2、T3都是对外部不可见的，只能通过特殊方法的查询找到它们。&lt;/p&gt;
&lt;p&gt;另外，前文说过，template包中很多返回&lt;code&gt;*Template&lt;/code&gt;的函数、方法返回的其实是原始的t(看源代码即可知道)，这个规则也适用于这里的Parse()方法，所以tmpl和t1这两个变量是完全等价的，都指向同一个template，即test1。所以前面的执行结果中前3行完全一致。&lt;/p&gt;
&lt;p&gt;再回头看上面代码的执行结果，假设结果中的每一行都分为3列，&lt;strong&gt;第一列为template name，第二个字段为parseTree的地址，第三列为common结构的地址&lt;/strong&gt;。因为tmpl1、t1都指向test1模板，所以前3行结果完全一致。因为test1、T1、T2、T3共享同一个common，所以第三列全都相同。因为每个模板的解析树不一样，所以第二列全都不一样。&lt;/p&gt;
&lt;h3 id=&quot;new方法&quot;&gt;New()方法&lt;/h3&gt;
&lt;p&gt;除了template.New()函数，还有一个Template.New()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// New allocates a new, undefined template associated with the given one and with the same
// delimiters. The association, which is transitive, allows one template to
// invoke another with a {{template}} action.
func (t *Template) New(name string) *Template {
    t.init()
    nt := &amp;amp;Template{
        name:       name,
        common:     t.common,
        leftDelim:  t.leftDelim,
        rightDelim: t.rightDelim,
    }
    return nt
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看注释很难理解，但是看它的代码，结合前文的解释，New()方法的作用很明显。&lt;/p&gt;
&lt;p&gt;首先t.init()保证有一个有效的common结构，然后构造一个新的Template对象nt，这个nt除了name和解析树parse.Tree字段之外，其它所有内容都和t完全一致。换句话说，nt和t共享了common。&lt;/p&gt;
&lt;p&gt;也就是说，New()方法使得名为name的nt模板对象加入到了关联组中。更通俗一点，&lt;strong&gt;通过调用&lt;code&gt;t.New()&lt;/code&gt;方法，可以创建一个新的名为name的模板对象，并将此对象加入到t模板组中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这和New()函数的作用基本是一致的，只不过New()函数是构建新的模板对象并构建一个新的common结构，而New()方法则是构建一个新的模板对象，并加入到已有的common结构中。&lt;/p&gt;
&lt;p&gt;只是还是要说明，因为New()出来的新对象在执行解析之前(如Parse())，它们暂时都还不会加入到common组中，在New()出来之后，仅仅只是让它指向已有的一个common结构。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t1 = t1.Parse(...)
t2 := t1.New(&quot;test2&quot;)
t2 = t2.Parse(...)
t3 := t1.New(&quot;test3&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128195700011-1903510599.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果t1和t2的Parse()中，都定义一个或多个name相同的模板会如何？例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t2 := t1.New(&quot;test2&quot;)
t1, _ = t1.Parse(
    `{{define &quot;T1&quot;}}ONE{{end}}
    {{define &quot;T2&quot;}}TWO{{end}}
    {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
    {{template &quot;T3&quot;}}`)
t2, _ = t2.Parse(
    `{{define &quot;T4&quot;}}ONE{{end}}
    {{define &quot;T2&quot;}}TWOO{{end}}
    {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
    {{template &quot;T3&quot;}}`)

    _ = t1.Execute(os.Stdout, &quot;a&quot;)
    _ = t2.Execute(os.Stdout, &quot;a&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的t1和t2中，它们共享同一个common，且t1.Parse()中定义了T1、T2和T3，t2.Parse()中定义了T4、T2和T3，且两个T2的解析内容不一样(解析树不一样)。&lt;/p&gt;
&lt;p&gt;因为T1、T2、T3、T4都会加入到t1和t2共享的common中，所以无论是通过t1还是通过t2这两个关联名称都能找到T1、T2、T3、T4。但是后解析的会覆盖先解析的，也就是说，无论是&lt;code&gt;t1.Lookup(&quot;T2&quot;)&lt;/code&gt;还是&lt;code&gt;t2.Lookup(&quot;T2&quot;)&lt;/code&gt;得到的T2对应的template，都是在t2.Parse()中定义的。当&lt;code&gt;t1.Execute()&lt;/code&gt;的时候，会得到t2中定义的T2的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ONE TWOO
ONE TWOO&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parse&quot;&gt;Parse()&lt;/h2&gt;
&lt;p&gt;Parse(string)方法用于解析给定的文本内容string。用法上很简单，前面也已经用过几次了，没什么可解释的。重点在于它的作用。&lt;/p&gt;
&lt;p&gt;当创建了一个模板对象后，会有一个与之关联的common(如果不存在，template包中的各种函数、方法都会因为调用init()方法而保证common的存在)。&lt;strong&gt;只有在Parse()之后，才会将相关的template name放进common中，表示这个模板已经可用了，或者称为已经定义了(defined)，可用被Execute()或ExecuteTemplate()，也表示可用使用Lookup()和DefinedTemplates()来检索模板&lt;/strong&gt;。另外，调用了Parse()解析后，会将给定的FuncMap中的函数添加到common的FuncMap中，只有添加到common的函数，才可以在模板中使用。&lt;/p&gt;
&lt;p&gt;Parse()方法是解析字符串的，且只解析New()出来的模板对象。如果想要解析文件中的内容，见后文ParseFiles()、ParseGlob()。&lt;/p&gt;
&lt;h2 id=&quot;lookupdefinedtemplates和templates方法&quot;&gt;Lookup()、DefinedTemplates()和Templates()方法&lt;/h2&gt;
&lt;p&gt;这三个方法都用于检索已经定义的模板，Lookup()根据template name来检索并返回对应的template，DefinedTemplates()则是返回所有已定义的templates。Templates()和DefinedTemplates()类似，但是它返回的是&lt;code&gt;[]*Template&lt;/code&gt;，也就是已定义的template的slice。&lt;/p&gt;
&lt;p&gt;前面多次说过，只有在解析之后，模板才加入到common结构中，才算是已经定义，才能被检索或执行。&lt;/p&gt;
&lt;p&gt;当检索不存在的templates时，Lookup()将返回nil。当common中没有模板，DefinedTemplates()将返回空字符串&quot;&quot;，Templates()将返回空的slice。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t2 := t1.New(&quot;test2&quot;)
    t1, _ = t1.Parse(
        `{{define &quot;T1&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)
    t2, _ = t2.Parse(
        `{{define &quot;T4&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWOO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)

    fmt.Println(t1.DefinedTemplates())
    fmt.Println(t2.DefinedTemplates())
    fmt.Println(t2.Templates())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;, &quot;test1&quot;, &quot;T4&quot;, &quot;test2&quot;
; defined templates are: &quot;test1&quot;, &quot;T4&quot;, &quot;test2&quot;, &quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;
[0xc04201c280 0xc042064100 0xc04201c1c0 0xc04201c2c0 0xc04201c300 0xc042064080]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果可见，返回的顺序虽然不一致，但包含的template name是完全一致的。&lt;/p&gt;
&lt;h2 id=&quot;clone方法&quot;&gt;Clone()方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Clone()&lt;/code&gt;方法用于克隆一个完全一样的模板，包括&lt;strong&gt;common结构也会完全克隆&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;test1&quot;)
t1 = t1.Parse(...)
t2 := t1.New(&quot;test2&quot;)
t2 = t2.Parse(...)

t3, err := t1.Clone()
if err != nil {
    panic(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的t3和t1在内容上完全一致，但在内存中它们是两个不同的对象。但无论如何，目前t3中会包含t1和t2共享的common，即使t2中定义了&lt;code&gt;{{define &quot;Tx&quot;}}...{{end}}&lt;/code&gt;，这个Tx也会包含在t3中。&lt;/p&gt;
&lt;p&gt;因为是不同的对象，所以修改t3，不会影响t1/t2。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t2 := t1.New(&quot;test2&quot;)
    t1, _ = t1.Parse(
        `{{define &quot;T1&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)
    t2, _ = t2.Parse(
        `{{define &quot;T4&quot;}}ONE{{end}}
        {{define &quot;T2&quot;}}TWOO{{end}}
        {{define &quot;T3&quot;}}{{template &quot;T4&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{template &quot;T3&quot;}}`)

    t3, err := t1.Clone()
    if err != nil {
        panic(err)
    }

    // 结果完全一致
    fmt.Println(t1.Lookup(&quot;T4&quot;))
    fmt.Println(t3.Lookup(&quot;T4&quot;))
    
    // 修改t3
    t3,_ = t3.Parse(`{{define &quot;T4&quot;}}one{{end}}`)
    // 结果将不一致
    fmt.Println(t1.Lookup(&quot;T4&quot;))
    fmt.Println(t3.Lookup(&quot;T4&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;must函数&quot;&gt;Must()函数&lt;/h2&gt;
&lt;p&gt;正常情况下，很多函数、方法都返回两个值，一个是想要返回的值，一个是err信息。template包中的函数、方法也一样如此。&lt;/p&gt;
&lt;p&gt;但有时候不想要err信息，而是直接取第一个返回值，并赋值给变量。操作大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1 := template.New(&quot;ttt&quot;)
t1,err := t1.Parse(...)
if err != nil {
    panic(err)
}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Must()函数将上面的过程封装了，使得Must()可以简化上面的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Must(t *Template, err error) *Template {
    if err != nil {
        panic(err)
    }
    return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当某个返回&lt;code&gt;*Template,err&lt;/code&gt;的函数、方法需要直接使用时，可用将其包装在Must()中，它会自动在有err的时候panic，无错的时候只返回其中的&lt;code&gt;*Template&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这在赋值给变量的时候非常简便，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var t = template.Must(template.New(&quot;name&quot;).Parse(&quot;text&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parsefiles和parseglob&quot;&gt;ParseFiles()和ParseGlob()&lt;/h2&gt;
&lt;p&gt;Parse()只能解析字符串，要解析文件中的内容，需要使用ParseFiles()或ParseGlob()。&lt;/p&gt;
&lt;p&gt;template包中有ParseFiles()和ParseGlob()函数，也有ParseFiles()和ParseGlob()方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128205842554-814542634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个函数和这两个方法的区别，看一下文档就很清晰：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go doc template.ParseFiles
func ParseFiles(filenames ...string) (*Template, error)
    ParseFiles creates a new Template and parses the template definitions from
    the named files. The returned template's name will have the (base) name and
    (parsed) contents of the first file. There must be at least one file. If an
    error occurs, parsing stops and the returned *Template is nil.

$ go doc template.template.ParseFiles
func (t *Template) ParseFiles(filenames ...string) (*Template, error)
    ParseFiles parses the named files and associates the resulting templates
    with t. If an error occurs, parsing stops and the returned template is nil;
    otherwise it is t. There must be at least one file.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释很清晰。ParseFiles()函数是直接解析一个或多个文件的内容，并返回第一个文件名的basename作为Template的名称，也就是说这些文件的template全都关联到第一个文件的basename上。ParseFiles()方法则是解析一个或多个文件的内容，并将这些内容关联到t上。&lt;/p&gt;
&lt;p&gt;看示例就一目了然。&lt;/p&gt;
&lt;p&gt;例如，当前go程序的目录下有3个文件：a.cnf、b.cnf和c.cnf，它们的内容无所谓，反正空内容也可以解析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1,err := template.ParseFiles(&quot;a.cnf&quot;,&quot;b.cnf&quot;,&quot;c.cnf&quot;)
    if err != nil {
        panic(err)
    }
    fmt.Println(t1.DefinedTemplates())
    fmt.Println()
    fmt.Println(t1)
    fmt.Println(t1.Lookup(&quot;a.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;b.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;c.cnf&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;

&amp;amp;{a.cnf 0xc0420ae000 0xc042064140  }
&amp;amp;{a.cnf 0xc0420ae000 0xc042064140  }
&amp;amp;{b.cnf 0xc0420bc000 0xc042064140  }
&amp;amp;{c.cnf 0xc0420bc100 0xc042064140  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中可以看到，已定义的template name都是文件的basename，且t1和a.cnf这个template是完全一致的，即t1是文件列表中的第一个模板对象。&lt;/p&gt;
&lt;p&gt;结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181128214151396-595751013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解了ParseFiles()函数，理解ParseFiles()方法、ParseGlob()函数、ParseGlob()方法，应该不会再有什么问题。但是还是有需要注意的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test&quot;)
    t1,err := t1.ParseFiles(&quot;a.cnf&quot;,&quot;b.cnf&quot;,&quot;c.cnf&quot;)
    if err != nil {
        panic(err)
    }
    // 先注释下面这行
    //t1.Parse(&quot;&quot;)
    fmt.Println(t1.DefinedTemplates())
    fmt.Println()
    fmt.Println(t1)
    fmt.Println(t1.Lookup(&quot;a.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;b.cnf&quot;))
    fmt.Println(t1.Lookup(&quot;c.cnf&quot;))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;

&amp;amp;{test &amp;lt;nil&amp;gt; 0xc0420640c0  }
&amp;amp;{a.cnf 0xc0420b0000 0xc0420640c0  }
&amp;amp;{b.cnf 0xc0420be000 0xc0420640c0  }
&amp;amp;{c.cnf 0xc0420be100 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现template.New()函数创建的模板对象test并没有包含到common中。为什么？&lt;/p&gt;
&lt;p&gt;因为t.ParseFiles()、t.ParseGlob()方法的解析过程是独立于t之外的，它们只解析文件内容，不解析字符串。而New()出来的模板，需要Parse()方法来解析才会加入到common中。&lt;/p&gt;
&lt;p&gt;将上面的注释行取消掉，执行结果将如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;; defined templates are: &quot;a.cnf&quot;, &quot;b.cnf&quot;, &quot;c.cnf&quot;, &quot;test&quot;

&amp;amp;{test 0xc0420bc200 0xc0420640c0  }
&amp;amp;{a.cnf 0xc0420ae000 0xc0420640c0  }
&amp;amp;{b.cnf 0xc0420bc000 0xc0420640c0  }
&amp;amp;{c.cnf 0xc0420bc100 0xc0420640c0  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体原因可分析parseFiles()源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func parseFiles(t *Template, filenames ...string) (*Template, error) {
    if len(filenames) == 0 {
        // Not really a problem, but be consistent.
        return nil, fmt.Errorf(&quot;template: no files named in call to ParseFiles&quot;)
    }
    for _, filename := range filenames {
        b, err := ioutil.ReadFile(filename)
        if err != nil {
            return nil, err
        }
        s := string(b)

        // name为文件名的basename部分
        name := filepath.Base(filename)

        var tmpl *Template
        if t == nil {
            t = New(name)
        }
        // 如果调用t.Parsefiles()，则t.Name不为空
        // name也就不等于t.Name
        // 于是新New(name)一个模板对象给tmpl
        if name == t.Name() {
            tmpl = t
        } else {
            tmpl = t.New(name)
        }
        // 解析tmpl。如果选中了上面的else分支，则和t无关
        _, err = tmpl.Parse(s)
        if err != nil {
            return nil, err
        }
    }
    return t, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;execute和executetemplate&quot;&gt;Execute()和ExecuteTemplate()&lt;/h2&gt;
&lt;p&gt;这两个方法都可以用来应用已经解析好的模板，应用表示对需要评估的数据进行操作，并和无需评估数据进行合并，然后输出到io.Writer中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) Execute(wr io.Writer, data interface{}) error
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两者的区别在于Execute()是应用整个common中已定义的模板对象，而ExecuteTemplate()可以选择common中某个已定义的模板进行应用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    t1 := template.New(&quot;test1&quot;)
    t1, _ = t1.Parse(`{{define &quot;T1&quot;}}ONE{{end}}
        {{- define &quot;T2&quot;}}TWO{{end}}
        {{- define &quot;T3&quot;}}{{template &quot;T1&quot;}} {{template &quot;T2&quot;}}{{end}}
        {{- template &quot;T3&quot;}}`)
    
    _ = t1.Execute(os.Stdout,&quot;&quot;)
    fmt.Println()
    fmt.Println(&quot;-------------&quot;)
    _ = t1.ExecuteTemplate(os.Stdout, &quot;T2&quot;, &quot;&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ONE TWO
-------------
TWO&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;funcmap和funcs&quot;&gt;FuncMap和Funcs()&lt;/h2&gt;
&lt;p&gt;template内置了一系列函数，但这些函数毕竟有限，可能无法满足特殊的需求。template允许我们定义自己的函数，添加到common中，然后就可以在待解析的内容中像使用内置函数一样使用自定义的函数。&lt;/p&gt;
&lt;p&gt;自定义函数的优先级高于内置的函数优先级，即先检索自定义函数，再检索内置函数。也就是说，如果自定义函数的函数名和内置函数名相同，则内置函数将失效。&lt;/p&gt;
&lt;p&gt;本文只对此稍作解释，本文的重点不是template的具体语法和用法。&lt;/p&gt;
&lt;p&gt;在common结构中，有一个字段是FuncMap类型的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type common struct {
    tmpl   map[string]*Template
    option option
    muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
    parseFuncs FuncMap
    execFuncs  map[string]reflect.Value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类型的定义为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type FuncMap map[string]interface{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是一个map结构，key为模板中可以使用的函数名，value为函数对象(为了方便称呼，这里直接成为函数)。函数必须只有1个值或2个值，如果有两个值，第二个值必须是error类型的，当执行函数时err不为空，则执行自动停止。&lt;/p&gt;
&lt;p&gt;函数可以有多个参数。假如函数str有两个参数，在待解析的内容中调用函数str时，如果调用方式为&lt;code&gt;{{str . &quot;aaa&quot;}}&lt;/code&gt;，表示第一个参数为当前对象，第二个参数为字符串&quot;aaa&quot;。&lt;/p&gt;
&lt;p&gt;假如，要定义一个将字符串转换为大写的函数，可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import &quot;strings&quot;
func upper(str string) string {
    return strings.ToUpper(str)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将其添加到FuncMap结构中，并将此函数命名为&quot;strupper&quot;，以后在待解析的内容中就可以调用&quot;strupper&quot;函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: upper,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，直接将匿名函数放在FuncMap内部：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: func(str string) string { return strings.ToUpper(str) },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在只是定义了一个FuncMap实例，这个实例中有一个函数。还没有将它关联到模板，严格地说还没有将其放进common结构。要将其放进common结构，调用Funcs()方法(其实调用此方法也没有将其放进common，只有在解析的时候才会放进common)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (t *Template) Funcs(funcMap FuncMap) *Template&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;funcMap := template.FuncMap{
    &quot;strupper&quot;: func(str string) string { return strings.ToUpper(str) },
}
t1 := template.New(&quot;test&quot;)
t1 = t1.Funcs(funcMap)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，和t1共享common的所有模板都可以调用&quot;strupper&quot;函数。&lt;/p&gt;
&lt;p&gt;注意，必须在解析之前调用Funcs()方法，在解析的时候会将函数放进common结构。&lt;/p&gt;
&lt;p&gt;下面是完整的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;os&quot;
    &quot;strings&quot;
    &quot;text/template&quot;
)

func main() {
    funcMap := template.FuncMap{
        &quot;strupper&quot;: upper,
    }
    t1 := template.New(&quot;test1&quot;)
    tmpl, err := t1.Funcs(funcMap).Parse(`{{strupper .}}`)
    if err != nil {
        panic(err)
    }
    _ = tmpl.Execute(os.Stdout, &quot;go programming&quot;)
}

func upper(str string) string {
    return strings.ToUpper(str)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面调用了&lt;code&gt;{{strupper .}}&lt;/code&gt;，这里的strupper是我们自定义的函数，&quot;.&quot;是它的参数(注意，参数不是放进括号里)。这里的&quot;.&quot;代表当前作用域内的当前对象，对于这个示例来说，当前对象就是那段字符串对象&quot;go programming&quot;。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:35:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>本文只关注Go text/template的底层结构，带上了很详细的图片以及示例帮助理解，有些地方也附带上了源码进行解释。有了本文的解释，对于Go template的语法以及html/template</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10035768.html</dc:identifier>
</item>
<item>
<title>人活着就是要学会持续的奔跑！【二】 - 风口商学院</title>
<link>http://www.cnblogs.com/fksxy/p/10035643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fksxy/p/10035643.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525674/201811/1525674-20181128230325450-636587416.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;共900字，预计阅读3分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;在美国跑完San Diego半程马拉松后不久就要回国，4月还有一个武汉马拉松的全程比赛，所以除了抓紧工作以外，还必须保持一定的训练量，以免无法完成。要知道武汉马拉松的名额现在非常紧俏，抽签的中签率只有1/6左右，参赛还得找人拿赞助商名额才行。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128225824980.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128225824980.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128225824980.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4月1日返回武汉后工作也特别忙，完全没有时间倒时差，一回来就按照国内作息时间，就这样强行别过来。为了保存体力也没有继续多练，2个星期后就参加比赛。在开赛前一周正好中学同学约着踢球，体力还有点搞狠了，估计对比赛会有点影响。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128225845332.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128225845332.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128225845332.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这次没有住在起点处，早上起来骑单车、坐&lt;strong&gt;地铁到达江汉区，再步行来到武汉关起跑点，存衣、检录都还顺利。在武汉主场比赛的好处就是熟人多、热闹。沿途都可以遇到武汉越野的跑步朋友、文科班足球队的球友。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/2018112822585629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/2018112822585629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/2018112822585629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5公司跑过武胜路的时候看到两位姐姐在拐弯的老地方给我加油、拍照&lt;/strong&gt;。然后去到汉阳、上长江大桥，在10公里后腿就感觉有点酸了，但必须坚持。在21公里半程后来到水果湖，见到两拨非洲鼓的老师、同学在擂鼓助威，很是热闹，我也跑过去停下来和大家一起互动、拍照。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128225909381.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128225909381.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128225909381.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再到东湖边上，还可以看到皮划艇的教练、学员也组织在水上为马拉松选手加油助威。这时已经是很有些累了，和同行的跑友分享盐丸、补给，向东湖绿道跑去。记得以前有在医院工作的同学在医疗站的，但这次好不容易跑到武汉第一医院的医疗站，同学因为出差没有来，他的其他同事倒是非常热情，给我送了葡萄糖等补给，歇了一会儿再继续。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128225923278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128225923278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128225923278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;后面也无所谓快慢了，需要歇一下的我就稍微走一小段，甚至中途还去了一个按摩点，让自愿者帮忙做了一会儿拉伸，不过好像也没有特别用，只有靠自己坚持向终点一点点迈进。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128225947656.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128225947656.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128225947656.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后4小时44分的时间才到达终点，算是最慢的几次之一吧。不过能在武汉跑完比赛，沿途和熟人打个招呼，也是非常好的，成绩不行就以娱乐为主，呵呵。&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20181128230006561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20181128230006561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20181128230006561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM5MTcyMA==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;后面一个星期还报名了一项潜江马拉松的全马，是预备武汉马拉松报名没有报上再去的，但武汉的比赛可以参加了，而且跑完累得不行，第二周再跑全程太勉强，就果断放弃不去了。在后面练得也不多，5月份和同事去汉口江滩参加了城市乐跑活动，5月底天气很热了，但5公里跑下来还是没特别问题的。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 15:04:00 +0000</pubDate>
<dc:creator>风口商学院</dc:creator>
<og:description>共900字，预计阅读3分钟 在美国跑完San Diego半程马拉松后不久就要回国，4月还有一个武汉马拉松的全程比赛，所以除了抓紧工作以外，还必须保持一定的训练量，以免无法完成。要知道武汉马拉松的名额现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fksxy/p/10035643.html</dc:identifier>
</item>
<item>
<title>Java NIO 学习笔记（一）----概述，Channel/Buffer - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10035631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10035631.html</guid>
<description>&lt;p&gt;Java NIO （来自 Java 1.4）可以替代标准 IO 和 Java Networking API ，NIO 提供了与标准 IO 不同的使用方式。学习 NIO 之前建议先掌握标准 IO 和 Java 网络编程，推荐教程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文目的：&lt;/strong&gt; 掌握了标准 IO 之后继续学习 NIO 知识。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程 &lt;a href=&quot;http://tutorials.jenkov.com/java-nio/index.html&quot;&gt;Java NIO Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-nio-概览&quot;&gt;Java NIO 概览&lt;/h2&gt;
&lt;p&gt;NIO 由以下核心组件组成：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通道和缓冲区&lt;br/&gt;在标准 IO API 中，使用字节流和字符流。 在 NIO 中使用通道和缓冲区。 数据总是从通道读入缓冲区，或从缓冲区写入通道。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;非阻塞IO&lt;br/&gt;NIO 可以执行非阻塞 IO 。 例如，当通道将数据读入缓冲区时，线程可以执行其他操作。 并且一旦数据被读入缓冲区，线程就可以继续处理它。 将数据写入通道也是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;选择器&lt;br/&gt;NIO 包含“选择器”的概念。 选择器是一个可以监视多个事件通道的对象（例如：连接打开，数据到达等）。 因此，单个线程可以监视多个通道的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;NIO 有比这些更多的类和组件，但在我看来，Channel，Buffer 和 Selector 构成了 API 的核心。 其余的组件，如 Pipe 和 FileLock ，只是与三个核心组件一起使用的实用程序类。&lt;/p&gt;
&lt;h5 id=&quot;channelsbuffers-通道和缓冲区&quot;&gt;Channels/Buffers 通道和缓冲区&lt;/h5&gt;
&lt;p&gt;通常，NIO 中的所有 IO 都以 Channel 开头，频道有点像流。 数据可以从 Channel 读入 Buffer，也可以从 Buffer 写入 Channel ：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png&quot; alt=&quot;通道将数据读入缓冲区，缓冲区将数据写入通道&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有几种 Channel 和 Buffer ，以下是 NIO 中主要 Channel 实现类的列表，这些通道包括 UDP + TCP 网络 IO 和文件 IO：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel ：文件通道&lt;/li&gt;
&lt;li&gt;DatagramChannel ：数据报通道&lt;/li&gt;
&lt;li&gt;SocketChannel ：套接字通道&lt;/li&gt;
&lt;li&gt;ServerSocketChannel ：服务器套接字通道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些类也有一些有趣的接口，但为了简单起见，这里暂时不提，后续会进行学习的。&lt;/p&gt;
&lt;p&gt;以下是 NIO 中的核心 Buffer 实现，其实就是 7 种基本类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;NIO 还有一个 MappedByteBuffer，它与内存映射文件一起使用，同样这个后续再讲。&lt;/p&gt;
&lt;h5 id=&quot;selectors-选择器&quot;&gt;Selectors 选择器&lt;/h5&gt;
&lt;p&gt;选择器允许单个线程处理多个通道。 如果程序打开了许多连接（通道），但每个连接只有较低的流量，使用选择器就很方便。 例如，在聊天服务器中， 以下是使用 Selector 处理 3 个 Channel 的线程图示：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/overview-selectors.png&quot; alt=&quot;1个线程使用选择器处理3个通道&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要使用选择器，需要使用它注册通道。 然后你调用它的 select() 方法。 此方法将阻塞，直到有一个已注册通道的事件准备就绪。 一旦该方法返回，该线程就可以处理这些事件。 事件可以是传入连接，接收数据等。&lt;/p&gt;
&lt;h2 id=&quot;channel-通道&quot;&gt;Channel （通道）&lt;/h2&gt;
&lt;p&gt;NIO 通道类似于流，但有一些区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通道可以读取和写入。 流通常是单向的（读或写）。&lt;/li&gt;
&lt;li&gt;通道可以异步读取和写入。&lt;/li&gt;
&lt;li&gt;通道始终读取或写入缓冲区，即它只面向缓冲区。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上所述，NIO 中总是将数据从通道读取到缓冲区，或将数据从缓冲区写入通道。 这是一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 文件内容是 123456789
RandomAccessFile accessFile = new RandomAccessFile(&quot;D:\\test\\1.txt&quot;, &quot;rw&quot;);
FileChannel fileChannel = accessFile.getChannel();

ByteBuffer buffer = ByteBuffer.allocate(48);

int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;buffer缓冲区&quot;&gt;Buffer（缓冲区）&lt;/h2&gt;
&lt;p&gt;使用 Buffer 与 Channel 交互，数据从通道读入缓冲区，或从缓冲区写入通道。&lt;br/&gt;缓冲区本质上是一个可以写入数据的内存块，之后可以读取数据。 Buffer 对象包装了此内存块，提供了一组方法，可以更轻松地使用内存块。&lt;/p&gt;
&lt;h5 id=&quot;buffer-的基本用法&quot;&gt;Buffer 的基本用法&lt;/h5&gt;
&lt;p&gt;使用 Buffer 读取和写入数据通常遵循以下四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据写入缓冲区&lt;/li&gt;
&lt;li&gt;调用 buffer.flip() 反转读写模式&lt;/li&gt;
&lt;li&gt;从缓冲区读取数据&lt;/li&gt;
&lt;li&gt;调用 buffer.clear() 或 buffer.compact() 清除缓冲区内容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将数据写入Buffer 时，Buffer 会跟踪写入的数据量。 当需要读取数据时，就使用 flip() 方法将缓冲区从写入模式切换到读取模式。 在读取模式下，缓冲区允许读取写入缓冲区的所有数据。&lt;/p&gt;
&lt;p&gt;读完所有数据之后，就需要清除缓冲区，以便再次写入。 可以通过两种方式执行此操作：通过调用 clear() 或调用 compact() 。区别在于 clear() 是方法清除整个缓冲区，而 compact() 方法仅清除已读取的数据，未读数据都会移动到缓冲区的开头，新数据将在未读数据之后写入缓冲区。&lt;/p&gt;
&lt;p&gt;这是一个简单的缓冲区用法示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ChannelExample {
    public static void main(String[] args) throws IOException {
    // 文件内容是 123456789
        RandomAccessFile accessFile = new RandomAccessFile(&quot;D:\\test\\1.txt&quot;, &quot;rw&quot;);
        FileChannel fileChannel = accessFile.getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(48); //创建容量为48字节的缓冲区

        int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数
        while (data != -1) {
            System.out.println(&quot;Read &quot; + data); // Read 9
            buffer.flip(); // 将 buffer 从写入模式切换为读取模式
            while (buffer.hasRemaining()) {
                System.out.print((char) buffer.get()); // 每次读取1byte，循环输出 123456789
            }
            buffer.clear(); // 清除当前缓冲区
            data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区
        }
        accessFile.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;buffer-的-capacityposition-和-limit&quot;&gt;Buffer 的 capacity，position 和 limit&lt;/h5&gt;
&lt;p&gt;缓冲区有 3 个需要熟悉的属性，以便了解缓冲区的工作原理。 这些是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;capacity : 容量缓冲区的容量，是它所包含的元素的数量。不能为负并且不能更改。&lt;/li&gt;
&lt;li&gt;position ：缓冲区的位置 是下一个要读取或写入的元素的索引。不能为负，并且不能大于 limit&lt;/li&gt;
&lt;li&gt;limit : 缓冲区的限制，缓冲区的限制不能为负，并且不能大于 capacity&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外还有标记 mark ，&lt;br/&gt;标记、位置、限制和容量值遵守以下不变式：&lt;br/&gt;0 &amp;lt;= mark&amp;lt;= position &amp;lt;= limit&amp;lt;= capacity&lt;/p&gt;
&lt;p&gt;position 和 limit 的含义取决于 Buffer 是处于读取还是写入模式。 无论缓冲模式如何，capacity 总是一样的表示容量。&lt;/p&gt;
&lt;p&gt;以下是写入和读取模式下的容量，位置和限制的说明：&lt;br/&gt;&lt;img src=&quot;http://tutorials.jenkov.com/images/java-nio/buffers-modes.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;capacity&quot;&gt;capacity&lt;/h5&gt;
&lt;p&gt;作为存储器块，缓冲区具有一定的固定大小，也称为“容量”。 只能将 capacity 多的 byte，long，char 等写入缓冲区。 缓冲区已满后，需要清空它（读取数据或清除它），然后才能将更多数据写入。&lt;/p&gt;
&lt;h5 id=&quot;position&quot;&gt;position&lt;/h5&gt;
&lt;p&gt;将数据写入缓冲区时，可以在某个位置执行操作。 position​ 初始值为 ​0 ，当一个 byte，long，char 等已写入缓冲区时，position 被移动，指向缓冲区中的下一个单元以插入数据。 position 最大值为 capacity -1&lt;/p&gt;
&lt;p&gt;从缓冲区读取数据时，也可以从给定位置开始读取数据。 当缓冲区从写入模式切换到读取模式时，position 将重置为 0 。当从缓冲区读取数据时，将从 position 位置开始读取数据，读取后会将 position 移动到下一个要读取的位置。&lt;/p&gt;
&lt;h5 id=&quot;limit&quot;&gt;limit&lt;/h5&gt;
&lt;p&gt;在写入模式下，Buffer 的 limit 是可以写入缓冲区的数据量的限制，此时 limit=capacity。&lt;/p&gt;
&lt;p&gt;将缓冲区切换为读取模式时，limit 表示最多能读到多少数据。 因此，当将 Buffer 切换到读取模式时，limit被设置为之前写入模式的写入位置（position ），换句话说，你能读到之前写入的所有数据（例如之前写写入了 6 个字节，此时 position=6 ，然后切换到读取模式，limit 代表最多能读取的字节数，因此 limit 也等于 6）。&lt;/p&gt;
&lt;h5 id=&quot;分配缓冲区&quot;&gt;分配缓冲区&lt;/h5&gt;
&lt;p&gt;要获取 Buffer 对象，必须先分配它。 每个 Buffer 类都有一个 allocate() 方法来执行此操作。 下面是一个显示ByteBuffer分配的示例，容量为48字节：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuffer buffer = ByteBuffer.allocate(48); //创建容量为48字节的缓冲区&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;将数据写入缓冲区&quot;&gt;将数据写入缓冲区&lt;/h5&gt;
&lt;p&gt;可以通过两种方式将数据写入 Buffer：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据从通道写入缓冲区&lt;/li&gt;
&lt;li&gt;通过缓冲区的 put() 方法,自己将数据写入缓冲区。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一个示例，显示了 Channel 如何将数据写入 Buffer：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int data = fileChannel.read(buffer); // 将 Channel 的数据读入缓冲区，返回读入到缓冲区的字节数
buffer.put(127); // 此处的 127 是 byte 类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;put() 方法有许多其他版本，允许以多种不同方式将数据写入 Buffer 。 例如，在特定位置写入，或将一个字节数组写入缓冲区。&lt;/p&gt;
&lt;h5 id=&quot;flip-切换缓冲区的读写模式&quot;&gt;flip() 切换缓冲区的读写模式&lt;/h5&gt;
&lt;p&gt;flip() 方法将 Buffer 从写入模式切换到读取模式。 调用 flip() 会将 position 设置回 0，并将 limit 的值设置为切换之前的 position 值。换句话说，limit 表示之前写进了多少个 byte、char 等 —— 现在能读取多少个 byte、char 等。&lt;/p&gt;
&lt;h5 id=&quot;从缓冲区读取数据&quot;&gt;从缓冲区读取数据&lt;/h5&gt;
&lt;p&gt;有两种方法可以从 Buffer 中读取数据：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将数据从缓冲区读入通道。&lt;/li&gt;
&lt;li&gt;使用 get() 方法之一，自己从缓冲区读取数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下是将缓冲区中的数据读入通道的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int bytesWritten = fileChannel.write(buffer);
byte aByte = buffer.get();    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和 put() 方法一样，get() 方法也有许多其他版本，允许以多种不同方式从 Buffer 中读取数据。有关更多详细信息，请参阅JavaDoc以获取具体的缓冲区实现。&lt;/p&gt;
&lt;p&gt;以下列出 ByteBuffer 类的部分方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;byte[] array()&lt;/td&gt;
&lt;td&gt;返回实现此缓冲区的 byte 数组，此缓冲区的内容修改将导致返回的数组内容修改，反之亦然。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;CharBuffer asCharBuffer()&lt;/td&gt;
&lt;td&gt;创建此字节缓冲区作为新的独立的char 缓冲区。新缓冲区的内容将从此缓冲区的当前位置开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;XxxBuffer asXxxBuffer()&lt;/td&gt;
&lt;td&gt;同上，创建对应的 Xxx 缓冲区，Xxx 可为 Short/Int/Long/Float/Double&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;byte get()&lt;/td&gt;
&lt;td&gt;相对 get 方法。读取此缓冲区当前位置的字节，然后该 position 递增。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ByteBuffer get(byte[] dst, int offset, int length)&lt;/td&gt;
&lt;td&gt;相对批量 get 方法，后2个参数可省略&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;byte get(int index)&lt;/td&gt;
&lt;td&gt;绝对 get 方法。读取指定索引处的字节。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;char getChar()&lt;/td&gt;
&lt;td&gt;用于读取 char 值的相对 get 方法。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;char getChar(int index)&lt;/td&gt;
&lt;td&gt;用于读取 char 值的绝对 get 方法。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;xxx getXxx(int index)&lt;/td&gt;
&lt;td&gt;用于读取 xxx 值的绝对 get 方法。index 可以选，指定位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;众多 put() 方法&lt;/td&gt;
&lt;td&gt;参考以上 get() 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;static ByteBuffer wrap(byte[] array)&lt;/td&gt;
&lt;td&gt;将 byte 数组包装到缓冲区中。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;rewind-倒带&quot;&gt;rewind() 倒带&lt;/h5&gt;
&lt;p&gt;Buffer对象的 rewind() 方法将 position 设置回 0，因此可以重读缓冲区中的所有数据， limit 则保持不变。&lt;/p&gt;
&lt;h5 id=&quot;clear-和-compact&quot;&gt;clear() 和 compact()&lt;/h5&gt;
&lt;p&gt;如果调用 clear() ,则将 position 设置回 0 ，并将 limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。 但是 Buffer 中的实际存放的数据并未清除。&lt;/p&gt;
&lt;p&gt;如果在调用 clear() 时缓冲区中有任何未读数据，数据将被“遗忘”，这意味着不再有任何标记告诉读取了哪些数据，还没有读取哪些数据。&lt;/p&gt;
&lt;p&gt;如果缓冲区中仍有未读数据，并且想稍后读取它，但需要先写入一些数据，这时候应该调用 compact() ，它会将所有未读数据复制到 Buffer 的开头，然后它将 position 设置在最后一个未读元素之后。 limit 属性仍设置为 capacity ，就像 clear() 一样。 现在缓冲区已准备好写入，并且不会覆盖未读数据。&lt;/p&gt;
&lt;h5 id=&quot;mark-和-reset&quot;&gt;mark() 和 reset()&lt;/h5&gt;
&lt;p&gt;以通过调用 Buffer 对象的 mark() 方法在 Buffer 中标记给定位置。 然后，可以通过调用 Buffer.reset() 方法将位置重置回标记位置，就像在标准 IO 中一样。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;buffer.mark();
// 调用 buffer.get() 等方法读取数据...

buffer.reset();  // 设置 position 回到 mark 位置。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;equals-和-compareto&quot;&gt;equals() 和 compareTo()&lt;/h5&gt;
&lt;p&gt;可以使用 equals() 和 compareTo() 比较两个缓冲区。&lt;/p&gt;
&lt;p&gt;equals() 成立的条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它们的类型相同（byte，char，int等）&lt;/li&gt;
&lt;li&gt;它们在缓冲区中具有相同数量的剩余字节，字符等。&lt;/li&gt;
&lt;li&gt;所有剩余的字节，字符等都相等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如上，equals 仅比较缓冲区的一部分，而不是它内部的每个元素。 实际上，它只是比较缓冲区中的其余元素。&lt;/p&gt;
&lt;p&gt;compareTo() 方法比较两个缓冲区的剩余元素（字节，字符等）， 在下列情况下，一个 Buffer 被视为“小于”另一个 Buffer：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个不相等的元素小于另一个 Buffer 中对应的元素 。&lt;/li&gt;
&lt;li&gt;所有元素都相等，但第一个 Buffer 在第二个 Buffer 之前耗尽了元素（第一个 Buffer 元素较少）。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 28 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>掌握了标准 IO 之后继续学习 NIO 知识。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程 [Java NIO Tutorial]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10035631.html</dc:identifier>
</item>
<item>
<title>Python-定时爬取指定城市天气(二)-邮件提醒 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/10035127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/10035127.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/10023491.html&quot;&gt;python-定时爬取指定城市天气(一)-发送给关心的微信好友&lt;/a&gt;中我们讲述了怎么定时爬取城市天气，并发送给指定微信好友，文末遗留两个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定时任务做成windows服务，这样更优雅，随开机启动&lt;/li&gt;
&lt;li&gt;发送消息给微信好友换成发送邮件给指定邮箱&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇文章我们在原来代码的基础上进行了一定的模块拆分，并处理以上两个问题&lt;/p&gt;
&lt;h2 id=&quot;二模块重新划分&quot;&gt;二、模块重新划分&lt;/h2&gt;
&lt;p&gt;1、 新增my_job.py文件，把任务模块单独划分出来&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;之前的定时任务使用的是apscheduler库做的，并且任务类在main函数所在py文件中，这样导致主py文件很难进行修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、 新增util.py文件&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含公用的方法，比如目前的字典转字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.、新增weather_service.py文件&lt;/p&gt;
&lt;blockquote readability=&quot;6.8901734104046&quot;&gt;
&lt;p&gt;主要负责构造windows服务，也是一个主py文件，不同于第一篇文章的主py文件weath_report.py，这是我们实现的两种定时任务，可分别运行，如果想把天气信息通知微信好友则启动weath_report.py，可参考文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/10023491.html&quot;&gt;ython-定时爬取指定城市天气(一)-发送给关心的微信好友&lt;/a&gt;，如果是通过发送邮件的方式则直接把weather_service.py安装成windows服务，并启动即可，记住需要配置运行的任务列表，下边会讲述怎么配置任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4、 新增timing_task.py文件&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;包含任务方法executeJob()，主要是在服务中循环跑，然后在合适的时间爬取天气并发送到指定邮箱，任务的参数是通过配置json串来实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三优化定时任务&quot;&gt;三、优化定时任务&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇文章的定时任务是运行在windows服务中的，因此我们首先需要安装pywin32模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.、安装pywin32&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install pywin32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.、服务操作相关命令&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1.安装服务 python PythonService.py install
2.让服务自动启动 python PythonService.py --startup auto install
3.启动服务 python PythonService.py start
4.重启服务 python PythonService.py restart
5.停止服务 python PythonService.py stop
6.删除/卸载服务 python PythonService.py remove&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.、启动服务时被拒绝&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Installing service timingTaskDaemon
Error installing service: 拒绝访问。 (5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;a.大多数原因是由于python环境配置的问题，python默认安装时配置的pah是用户环境变量，这里我们需要改成系统环境变量，具体可以参考&lt;a href=&quot;https://blog.csdn.net/fxy0325/article/details/83389030&quot;&gt;Python 写windows service 及 start service 出现错误 1053：服务没有及时响应启动或控制请求&lt;/a&gt;&lt;br/&gt;b.考虑命令行是否有权限，我自己的win8系统默认权限就不够，需要右键管理员启动才可以&lt;/p&gt;
&lt;p&gt;4、 实现windows服务功能，我们需要继承win32serviceutil.ServiceFramework这个类，把需要执行的业务逻辑放入SvcDoRun函数中，如下代码中executeJob()函数即为我们定时执行的任务&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class WeatherPythonService(win32serviceutil.ServiceFramework):
    _svc_name_ = &quot;weather_service_test4&quot;
    _svc_display_name_ = &quot;weather_service_test4&quot;
    _svc_description_ = &quot;i am a test weather_service_test&quot;
    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        # Create an event which we will use to wait on.
        # The &quot;service stop&quot; request will set this event.
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)
        self.run = True
    def SvcStop(self):
        # Before we do anything, tell the SCM we are starting the stop process.
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        # And set my event.
        win32event.SetEvent(self.hWaitStop)
        self.run = False
    def SvcDoRun(self):
        #what to do#
        while self.run:
            executeJob()
            time.sleep(5)
        #win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE)
if __name__ == '__main__':
    #executeJob()
    win32serviceutil.HandleCommandLine(WeatherPythonService)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.、任务执行函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def executeJob():
    now_time = time.localtime(time.time())
    now_hour = now_time.tm_hour
    now_minute = now_time.tm_min
    for job in my_jobs:
        ts = job['time']
        for t in ts.split(','):
            jobtime = t.split('.')
            h = jobtime[0]
            m = jobtime[1]
            if (now_hour != h and now_minute != m):
                code = city_code.find_code(job['city'])
                wea = getWeath(code)
                strWea = strDic(wea)
                title = '{}天气预报'.format(job['city'])
                send_email(job['receivers'], 'title', title + &quot;：\n&quot; + strWea)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任务执行时，需要配置任务执行列表，即上述代码中my_jobs对象，该对象是一个标准的json串，不同于上一篇文章的json格式，本篇文章的任务参数如下，任务整体是一个数组，数组中包含了任务对象，每一个对象由3个字段组成，分别是邮件接收者邮箱receivers、爬取城市city和爬取时间time&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;my_jobs = [{
    &quot;receivers&quot;:['1134024095@qq.com'],
    &quot;city&quot;:&quot;昌平&quot;,
    &quot;time&quot;:&quot;6.30,17.30&quot;
    },{
    &quot;receivers&quot;:['1134024095@qq.com'],
    &quot;city&quot;:&quot;海淀&quot;,
    &quot;time&quot;:&quot;6.30,17.30&quot;
    }]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.、安装服务，成功启动后，但是任务没有正常执行，可以通过查看系统任务事件来确定错误的原因，如下图所示，这是我在排查错误的时候截图&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;查询系统日志：&lt;code&gt;win+r&lt;/code&gt; 回车输入 &lt;code&gt;eventvwr.exe&lt;/code&gt; 在回车&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1351403/t_look_log.png&quot; alt=&quot;查询系统日志&quot;/&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四发送邮件&quot;&gt;四、发送邮件&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我们使用QQ邮箱作为示例进行演示，发送邮件使用smtplib库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.、QQ邮箱发送需要申请口令，&lt;a href=&quot;http://www.runoob.com/python/python-email.html&quot;&gt;申请方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、 选择邮箱发送服务器&lt;code&gt;smtp.qq.com&lt;/code&gt;和端口号&lt;code&gt;465&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.、构造发件人、收件人和邮件内容&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;message = MIMEText(text, 'plain', 'utf-8')
message['From'] = formataddr([&quot;就差一点儿&quot;, sender])  # 括号里的对应发件人邮箱昵称、发件人邮箱账号
message['To'] = Header(','.join(receivers), 'utf-8')#接受者
message['Subject'] = Header(title, 'utf-8')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;text为邮件内容，通过From构造发件人信息，To构造收件人信息，这个构造的只是显示的文本串，如本小节底部截图所示的收件人和发件人等，真正的接受邮件的账号在发送邮件时指定。&lt;/p&gt;
&lt;p&gt;4.、连接邮箱服务器、登陆&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;smtpObj = smtplib.SMTP_SSL()
smtpObj.connect(mail_host, mail_port)    # mail_port 为 SMTP 端口号
smtpObj.login(mail_user, mail_pass)  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、 发送邮件&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;smtpObj.sendmail(sender, receivers, message.as_string())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.、邮件发送成功&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1351403/t_success.png&quot; alt=&quot;邮件发送成功&quot;/&gt;&lt;/div&gt;
&lt;p&gt;7、 完整发送邮件代码&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码
def send_email(receivers, title, text):
    message = MIMEText(text, 'plain', 'utf-8')
    message['From'] = formataddr([&quot;就差一点儿&quot;, sender])  # 括号里的对应发件人邮箱昵称、发件人邮箱账号
    message['To'] = Header(','.join(receivers), 'utf-8')#接受者

    message['Subject'] = Header(title, 'utf-8')
    
    ret = True
    try:
        smtpObj = smtplib.SMTP_SSL()
        smtpObj.connect(mail_host, mail_port)    # mail_port 为 SMTP 端口号
        smtpObj.login(mail_user, mail_pass)  
        smtpObj.sendmail(sender, receivers, message.as_string())
    except smtplib.SMTPException:
        ret = False
    
    f = open('./sendemail_weather.log', 'a', encoding = 'utf-8')
    if ret:
        f.write(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') + ':邮件发送成功\n')
    else:
        f.write(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') +':无法发送邮件\n')
    f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、测试发送邮件&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;send_email(['1134024095@qq.com','1024068757@qq.com'], &quot;昌平&quot;, &quot;6.30&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五源代码&quot;&gt;五、源代码&lt;/h2&gt;
&lt;blockquote readability=&quot;6.4296296296296&quot;&gt;
&lt;p&gt;以前写博客测试程序都是放在csdn，最近几次发现csdn审核流程太慢了，导致和博客发布时间不统一，因此后续测试程序代码我都尽量放在git上，本篇文章的测试程序有需要的朋友可以去&lt;a href=&quot;https://github.com/ASwarmOfBees/weather_report_service&quot;&gt;weather_report_service&lt;/a&gt;下载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇文章是使用markdown语法写的，排版实在不怎么样，大家凑合看吧，博客园的markdown解释器没有简书好，简书地址&lt;a href=&quot;https://www.jianshu.com/p/7ef56a51ab8b&quot;&gt;Python-定时爬取指定城市天气（二） - 邮件提醒&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;转载声明：本站文章无特别说明，皆为原创，版权所有，转载请注明：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Wed, 28 Nov 2018 14:59:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 一、概述 上一篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swarmbees/p/10035127.html</dc:identifier>
</item>
<item>
<title>Oracle如何查询当前的crs/has自启动状态 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10009473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10009473.html</guid>
<description>&lt;p&gt;我们知道在某些停机测试场景，是需要人为禁用crs/has的自启动的，防止过程中主机反复重启对数据库集群造成影响。&lt;br/&gt;使用crsctl disable/enable crs命令可以禁用/启用crs的自启动，但没有命令去查看当前自启动状态，虽然命令可以反复执行，但看不到实际状态总归还是让人不放心。&lt;/p&gt;
&lt;p&gt;我在Linux测试环境下试了几个Oracle RAC版本：&lt;br/&gt;Oracle RAC 10.2.0.5&lt;br/&gt;Oracle RAC 11.2.0.4&lt;br/&gt;Oracle RAC 12.1.0.2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发现对于Oracle RAC 10.2.0.5来说：&lt;/strong&gt;&lt;br/&gt;使用root用户crsctl disable/enable crs时，改变的是这个文件的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--10.2.0.5
[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl disable crs
[root@rac1-server ~]# more /etc/oracle/scls_scr/rac1-server/root/crsstart 
disable
[root@rac1-server ~]# /s01/oracle/product/10.2.0/crs_1/bin/crsctl enable crs
[root@rac1-server ~]# more /etc/oracle/scls_scr/rac1-server/root/crsstart 
enable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对于Oracle RAC 11.2.0.4和Oracle RAC 12.1.0.2来说：&lt;/strong&gt;&lt;br/&gt;使用root用户crsctl disable/enable crs时，改变的是这个文件的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--11.2.0.4
[root@db01 ~]# /opt/app/11.2.0/grid/bin/crsctl disable crs
CRS-4621: Oracle High Availability Services autostart is disabled.
[root@db01 ~]# more /etc/oracle/scls_scr/db01/root/ohasdstr 
disable
[root@db01 ~]# /opt/app/11.2.0/grid/bin/crsctl enable crs
CRS-4622: Oracle High Availability Services autostart is enabled.
[root@db01 ~]# more /etc/oracle/scls_scr/db01/root/ohasdstr 
enable

--12.1.0.2
[root@oemapp1 ~]# /app/12.1.0.2/grid/bin/crsctl disable crs
CRS-4621: Oracle High Availability Services autostart is disabled.
[root@oemapp1 ~]# more /etc/oracle/scls_scr/oemapp1/root/ohasdstr 
disable
[root@oemapp1 ~]# /app/12.1.0.2/grid/bin/crsctl enable crs
CRS-4622: Oracle High Availability Services autostart is enabled.
[root@oemapp1 ~]# more /etc/oracle/scls_scr/oemapp1/root/ohasdstr 
enable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本上可以认定是10.2.0.5版本，都是去对应crsstart这个文件的值。11.2.0.4和12.1.0.2版本都是去对应ohasdstr这个文件值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于主流的小机环境：&lt;/strong&gt;&lt;br/&gt;对于AIX系统，跟Linux的配置文件路径没有区别；&lt;br/&gt;而对于SUN Solaris和HP-UX，需要注意配置文件的路径有所区别（/etc/oracle/.. -&amp;gt; /var/opt/oracle/..）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--10.2.0.5
/var/opt/oracle/scls_scr/$hostname/root/crsstart
--11.2.0.4
/var/opt/oracle/scls_scr/$hostname/root/ohasdstr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关案例：&lt;/strong&gt;&lt;br/&gt;最近某客户AIX的一套10g RAC，现场运维DBA反映说是之前主机重启，crs不会自启动，每次都需要人工启动crs。但协助排查发现其配置文件crsstart的值已经是enable，且查到该配置文件的修改日期在7年前。说明配置是自启动的，而且7年没有人动过这个配置，比较诡异，最终是让其尝试disable再enable的方式，同时观察到配置文件的修改日期也会正常变，且在后续一次主机重启的维护中发现crs已经可以正常自启动。目前还无法解释为何之前无法自启动，先记录下这个现象。&lt;/p&gt;
</description>
<pubDate>Wed, 28 Nov 2018 14:56:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>我们知道在某些停机测试场景，是需要人为禁用crs/has的自启动的，防止过程中主机反复重启对数据库集群造成影响。 使用crsctl disable/enable crs命令可以禁用/启用crs的自启动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10009473.html</dc:identifier>
</item>
</channel>
</rss>