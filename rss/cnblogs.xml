<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaScript OOP（三）：prototype原型对象（即构造函数的prototype属性） - why_not_try</title>
<link>http://www.cnblogs.com/why-not-try/p/8005756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/why-not-try/p/8005756.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有的对象的原型对象如果一层层往上“回溯”，最后可以回溯到Object.prototype;而Object.prototype的原型对象是null,null没有自己的原型对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;68.642787183434&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(Object.getPrototypeOf(Object.prototype));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208143218609-339325931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;表明Object.prototype的原型对象是null&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果&lt;strong&gt;尝试获取null或undefined的原型对象&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(Object.getPrototypeOf(&lt;span&gt;null&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错 Cannot convert undefined or null to object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：读取对象的某个属性时，js引擎会先在对象本身属性上寻找，如果找不到，那么去原型对象上找，一层一层往上&quot;回溯&quot;,直至null.所以如果找寻某个不存在的属性，会将完整的原型链遍历一变，对性能影响较大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;constructor属性&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;prototype原型对象有一个constructor属性&lt;/strong&gt;&lt;/span&gt;，默认指向prototype所在的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; O5=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; O5.prototype=&lt;span&gt;new&lt;/span&gt; Array();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;O5的prototype属性等于new Array();那么O5的实例化对象共享着Array对象的所有属性和方法，并且O5.prototype的constructor也与Array.prototype的constructor一样&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; O5.prototype.constructor=O5;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o6=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; O5();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; o6.push(1,2,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;console.log(o6);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; console.log(O5.prototype.constructor===Array.prototype.constructor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208144007999-828014705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 因为&lt;strong&gt;constructor属性定义在prototype上&lt;/strong&gt;，所以&lt;span&gt;&lt;strong&gt;所有实例对象都能访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; O6();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; O6();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(a1.constructor===a2.constructor &amp;amp;&amp;amp; a1.constructor===O6.prototype.constructor);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208144147452-657172145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;

&lt;p&gt;&lt;strong&gt;所以使用constructor属性，&lt;span&gt;能确定对象使用的构造函数&lt;/span&gt;&lt;/strong&gt;；&lt;strong&gt;同时我们可以根据constructor属性，&lt;span&gt;间接调用构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a3=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; a2.constructor();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; console.log(a3.constructor===a1.constructor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意原型对象被覆盖可能出现的问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Abc(){};
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Abc.prototype.constructor=&lt;span&gt;Abc;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Abc.prototype.f=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     console.log('hello'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a4=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Abc();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; console.log(a4.constructor===&lt;span&gt;Abc.prototype.constructor);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; Abc.prototype=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     f1:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         console.log('hi'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时，定义Abc.prototype为一个新对象，原先定义在prototype上面的属性和方法均失效&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以调用原先prototype的f方法，报错&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a5=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Abc();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a5.f();//a5.f is not a function&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是能调用新定义的属性或方法&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; a5.f1();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;'hi'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208144453156-1173191611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;name属性&lt;/strong&gt;，可以查看构造函数的名字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Obj2(){};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o7=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Obj2();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(o7.constructor.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Obj2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208144655249-1126140260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;总结起来&lt;/strong&gt;:&lt;span&gt;&lt;strong&gt;1.　&lt;/strong&gt;&lt;/span&gt;构造函数生成对象；构造函数的原型(prototype)属性上面定义的方法或属性被所有实例化对象共享；构造函数的原型属性是实例对象的原型对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.  &lt;/strong&gt;&lt;/span&gt;constructor属性时定义在构造函数的prototype属性(原型对象)，被所有实例化对象共享；所以实例化的对象能够直接调用constructor属性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.  &lt;/strong&gt;&lt;/span&gt;原型对象=构造函数的prototype属性&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;instanceof 关键字&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;判断对象是否为构造函数的实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Obj3(){};
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o8=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Obj3();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; console.log(o8 &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Obj3);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; console.log(o8 &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Object);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instanceof对整个原型链上对象均有效&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; n1=&lt;span&gt;new&lt;/span&gt; Number(10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var n1=new Object(10);&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; console.log(n1 &lt;span&gt;instanceof&lt;/span&gt; Number,n1 &lt;span&gt;instanceof&lt;/span&gt; Object);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; o8 instanceof Obj3等同于Obj3.prototype.isPrototypeOf&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(Obj3.prototype.isPrototypeOf(o8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以翻译成Obj3构造函数的prototype(原型)属性是o8的原型对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;null,undefined instanceof Object均为false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208144959546-696545438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object.getPrototypeOf()：&lt;span&gt;获取一个对象的原型对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(Object.getPrototypeOf(null),Object.getPrototypeOf(undefined));//Cannot convert undefined or null to object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;不能获取null或者undefined的原型对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test1(){}
console.log(Object.getPrototypeOf(test1));
console.log(Object.getPrototypeOf(test1)&lt;/span&gt;===&lt;span&gt;Function.prototype)
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Test(){}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
console.log(Object.getPrototypeOf(t1));
console.log(Object.getPrototypeOf(t1)&lt;/span&gt;===Test.prototype);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208145220671-1211759646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; Object.setPrototypeOf():&lt;/strong&gt;&lt;span&gt;第一个参数是现有对象，第二个是原型对象；返回一个新对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     name:'apple'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     f:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         console.log('this is a test function'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o9=&lt;span&gt;Object.setPrototypeOf({},a);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;o9本身是空对象，它的原型对象是a;o9能调用a的属性和方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;console.log(o9);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; console.log(o9.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; o9.f();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208145342343-1781403844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以我们通过&lt;strong&gt;构造函数生成实例化对象&lt;/strong&gt;，&lt;strong&gt;本质&lt;/strong&gt;其实就是&lt;strong&gt;将构造函数的property属性赋值给实例对象的原型对象&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; f1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;console.log(f1);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; * 相当于
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt; * var f1=Object.setPrototypeOf({},F.prototype);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt; * F.call(f1);//调用F函数，this指向f1
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Object.create()使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;有时候，我们不能拿到对象的构造函数，只能取到实例对象；比如如下生成的：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o10=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     name:'chrome'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     speed:'fast'
&lt;span&gt;4&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;o10是一个实例对象，但是并不是很容易找到它的构造函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么如何以o10为原型，另外生成一个实例对象？使用Object.create()&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o11=&lt;span&gt;Object.create(o10);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;console.log(o11);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;console.log(o11.name,o11.speed);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(Object.getPrototypeOf(o11)===o10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true;说明o11的原型对象等于o10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208145854843-1668195636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Object.prototype.isPrototypeOf：&lt;span&gt;判断是否是某个对象的原型对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(o10.isPrototypeOf(o11));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true;o10是o11的原型对象&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;console.log(o11.isPrototypeOf(o10));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(Object.prototype.isPrototypeOf(&lt;span&gt;null&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除了null或者Object.create(null)生成对象，其它对象的原型对象往原型链回溯一定可以回溯到Object.prototype&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; console.log(Object.prototype.isPrototypeOf(Array));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208150103296-1127347954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;__proto__:&lt;/strong&gt;&lt;span&gt;内部属性，不应该对使用者显露&lt;/span&gt;；尽量减少使用这个属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__pro__：&lt;span&gt;设置对象的原型对象&lt;/span&gt;&lt;/strong&gt;；其实&lt;strong&gt;一般都可以用Object.getPrototypeOf()和Object.setPrototypeOf()替代&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o12=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     name:'apple'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     age:100
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; o13=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     sex:'male'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     email:'qq@com'
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; o12.__proto__=&lt;span&gt;o13;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; console.log(Object.getPrototypeOf(o12)===&lt;span&gt;o13);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;即__pro__是指定对象的原型对象，也就是构造函数的prototype属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208150211187-207603299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JavaScript的继承机制主要是基于prototype的。&lt;/li&gt;
&lt;li&gt;构造函数生成实例化对象；构造函数的prototype属性就是实例化对象的原型对象；原型对象上的属性和方法被所有实例化对象所共享！&lt;/li&gt;
&lt;li&gt; 原型链一般往上回溯可以回溯到Object.prototype；Object.prototype的原型对象是null；而null的原型对象不存在！&lt;/li&gt;
&lt;li&gt;原型对象上有construtor属性，等于构造函数名；因为是定义在原型对象上，所以被所有实例对象共享（由此我们也可以间接调用构造函数生成实例对象）！&lt;/li&gt;
&lt;li&gt;Object.getPrototypeOf()：获取某个对象的原型；不能获取null或者undefined的原型&lt;/li&gt;
&lt;li&gt;Object.setPrototypeOf()：第一个参数是现有对象，第二个是原型对象；返回一个新对象&lt;/li&gt;
&lt;li&gt;Object.create()：以参数为原型对象生成新对象&lt;/li&gt;
&lt;li&gt;__proto__属性：设置对象的原型对象；尽量减少使用该属性&lt;/li&gt;
&lt;li&gt;instanceof：判断对象是否是某构造函数的实例对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;自己用Excel画的一张图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1064142/201712/1064142-20171208153618609-291746343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 参考：&lt;a href=&quot;http://javascript.ruanyifeng.com/#&quot; target=&quot;_blank&quot;&gt;阮一峰JavaScript标准参考教程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Fri, 08 Dec 2017 07:51:00 +0000</pubDate>
<dc:creator>why_not_try</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/why-not-try/p/8005756.html</dc:identifier>
</item>
<item>
<title>数据结构与算法（C/C++版）【绪论/线性表】 - 李小小小伟</title>
<link>http://www.cnblogs.com/liwei1153300111/p/7987527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei1153300111/p/7987527.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;声明：数据结构与算法系列博文参考了《天勤高分笔记》、《王道复习指导》、C语言中文网。非商业用途，仅为学习笔记总结！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一章《绪论》&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、基本概念及入门常识 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_735cf654-f147-46f5-97d5-092316e6c8c4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_735cf654-f147-46f5-97d5-092316e6c8c4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_735cf654-f147-46f5-97d5-092316e6c8c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/（一）数据结构的基本概念和术语&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 数据
数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 数据元素
数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。
注意：不要混淆数据、数据元素、数据项之间的概念，也要注意和数据库中的相关术语进行区别：如数据记录、数据字段等概念。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. 数据对象
数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，整数数据对象是集合 N&lt;/span&gt;= {&lt;span&gt;0&lt;/span&gt;,±&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, 士2, ...}。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;. 数据类型
数据类型是一个值的集合和定义在此集合上一组操作的总称。
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 原子类型：其值不可再分的数据类型。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 结构类型：其值可以再分解为若千成分（分量）的数据类型。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 抽象数据类型：抽象数据组织和与之相关的操作。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;. 抽象数据类型

抽象数据类型(ADT)是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。通常用（数据对象、 数据关系、基本操作集）这样的三元组来表示抽象数据类型。
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;. 数据结构
在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（structure)。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所釆用的存储结构。

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/（二）数据结构三要素：数据逻辑结构、数据存储结构和数据的运算&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 数据的逻辑结构
逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。数据的逻辑结构分类
    集合结构中的数据元素之间除了 “同属于一个集合”的关系外，别无其他关系。
    线性结构结构中的数据元素之间只存在一对一的关系。
    树形结构结构中的数据元素之间存在一对多的关系。
    图状结构或网状结构结构中的数据元素之间存在多对多的关系。

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 数据的存储结构
存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 链接存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针表示元素之间的逻辑关系。其优点是不会出现碎片现象，充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，并且只能实现顺序存取。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每一项称为索引项，索引项的一般形式是：（关键字，地址）。其优点是检索速度快；缺点是增加了附加的索引表，会占用较多的存储空间。另外，在增加和删除数据时要修改索引表，因而会花费较多的时间。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) 散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。其优点是检索、增加和删除结点的操作都很快；缺点是如果散列函数不好可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. 数据的运算

施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。    
    
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/（三）算法的基本概念及特性(有穷性、确定性、可行性、输入和输出)&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/    &lt;/span&gt;
&lt;span&gt;算法(algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特性：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 有穷性
一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) 确定性
算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。即对于相同的输入只能得出相同的输出。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 可行性
一个算法是可行的，即算法中描述的操作都是吋以逋过已经实现的基本运算执行有限次来实现的。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;) 输入
一个算法有零个或多个的输入，这些输入取自于某个特定的对象的集合。
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) 输出
一个算法有一个或多个的输出，这些输出是同输入有着某种特定关系的量。

通常设计一个“好”的算法应考虑达到以下目标：
正确性：算法应当能够正确地解决求解问题。
可读性：算法应当具有良好的可读性，以助于人们理解。
健壮性：当输入非法数据时，算法也能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。    
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/算法效率度量：时间复杂度和空间复杂度&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/    &lt;/span&gt;
&lt;span&gt;算法效率的度量是通过时间复杂度和空间复杂度来描述的。
时间复杂度
一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。算法中的基本运算（最深层循环内的语句）的频度与T(n)同数量级，所以通常釆用算法中基本运算的频度 f(n)来分析算法的时间复杂度。因此，算法的时间复杂度也记为：
T(n)&lt;/span&gt;=&lt;span&gt;O(f(n))
上式中“O”的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n0，使得当n&lt;/span&gt;&amp;gt;=n0时，都满足0 &amp;lt;= T(n) &amp;lt;= C *&lt;span&gt; f(n)。
注意：取f(n)中随n增长最快的项将其系数置为1作为时间复杂度的度量。例如，fi(n) &lt;/span&gt;= a * n3 + b * n2 + c *&lt;span&gt; n，则其时间复杂度为O(n3)。
算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。

例如：在数组A[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;...n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]中，查找给定值K的算法大致如下：
i&lt;/span&gt;=n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( i&amp;gt;=&lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (A[i]!=&lt;span&gt;k) )
    i&lt;/span&gt;--;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语句(3)&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;

此算法中的语句(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)（基本运算）的频度不仅与问题规模n有关，还与输入实例中A 的各元素取值及K的取值有关：
若A中没有与K相等的元素，则语句(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;)的频度 f(n)=&lt;span&gt;n。
若A的最后一个元素等于K，则语句(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)的频度f(n)是常数0。
最坏时间复杂度是指在最坏情况下，算法的时间复杂度。
平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
最好时间复杂度是指在最好情况下，算法的时间复杂度。
一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。
在分析一个程序的时间复杂性时，有以下两条规则：
a) 加法规则
T(n) &lt;/span&gt;= T1(n) + T2(n) = O(f(n)) + O(g(n)) =&lt;span&gt; O(max(f(n), g(n)))
b) 乘法规则
T(n) &lt;/span&gt;= T1(n) * T2(n) = O(f(n)) * O(g(n)) = O( f(n) *&lt;span&gt; g(n) )
常见的渐近时间复杂度有：
O(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;O(log2n)&amp;lt;O(n)&amp;lt;O(nlog2n)&amp;lt;O(n2)&amp;lt;O(n3)&amp;lt;O(2n)&amp;lt;O(n!)&amp;lt;&lt;span&gt;O(nn)
空间复杂度
算法的空间复杂度S(n)，定义为该算法所耗费的存储空间，它是问题规模n的函数。渐近空间复杂度也常简称为空间复杂度，记作S(n)&lt;/span&gt;=&lt;span&gt;O(g(n))。
一个上机程序除了需要存储空间来存放本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间，若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。
算法原地工作是指算法所需辅助空间是常量，即O(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;#侃大山（密集恐惧症者慎入）0.0&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;第二章《线性表》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概述 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;线性表&lt;/strong&gt;：具有相同特性数据元素的有限序列&lt;br/&gt;　　---相同特性：把同一类事物归类，方便批量处理&lt;br/&gt;　　---有限：表中元素个数为n，n有限大，n可以为0&lt;br/&gt;　　---序列：表中元素排成一列，体现了一对一的逻辑特性（每个元素有且仅有一个前驱和一个后继）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑结构&lt;/strong&gt;：只有一个表头元素，只有一个表尾元素，表头元素没有前驱，表尾元素没有后继，除表头表尾之后的其他元素只有一个前驱，也只有一个后继。&lt;br/&gt;&lt;strong&gt;存储结构&lt;/strong&gt;：①顺序存储结构（顺序表）；②链式存储结构（单链表、双链表、单循环链表、双循环链表）&lt;/p&gt;
&lt;p&gt;①&lt;strong&gt;顺序存储结构&lt;/strong&gt;：利用数组的连续存储空间顺序存放线性表的各元素，每个结点包含所储存元素的信息。&lt;br/&gt;②&lt;strong&gt;链式存储结构&lt;/strong&gt;：不要求逻辑上相邻的两个元素物理上也相邻；通过“链”建立起数据元素之间的逻辑关系。每个结点不仅包含所储存元素的信息，还包含元素之间的逻辑关系信息；比如可以通过前驱结点中的地址信息找到后继结点的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特征对比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1.在顺序表中插入和删除元素可能会导致移动大量元素的连带操作（表尾位置除外），而链表不会；&lt;br/&gt;　　2.在单链表中找到任意一个结点的位置不想顺序表那么简单，因为顺序表支持随机存取（存取），而单链表不支持；&lt;br/&gt;　　3.为了弥补上一天单链表的不足，开发了双链表、循环单链表和循环双链表等存储结构，这些存储结构可以在仅知道链表中任意一个结点地址的情况下的推测其余             所有结点的地址，但仍然不支持随机存取。&lt;br/&gt;　　4.有时候还会给链表定义一个额外的指针，最常见的表尾指针，它指向链表中最后一个结点。可以借助它来提高某些常见操作的执行效率&lt;br/&gt;　　5.线性表采用顺序存储结构，必须占用一片连续的存储单元，而采用链式存储结构则不需要这样。&lt;br/&gt;　　6.从整体来看，一般顺序表存储空间利用率低于链表；而从单个存储单元来看，顺序表存储空间利用率要高于链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性表的基本操作&lt;/strong&gt;&lt;br/&gt;一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可以通过调用其基本操作来实现。线性表的主要操作如下：&lt;br/&gt;　　①InitList(&amp;amp;L)：初始化表。构造一个空的线性表。&lt;br/&gt;　　②Length(L)：求表长度。返回线性表L的长度，即L中数据元素的个数。&lt;br/&gt;　　③LocateElem(L, e)：按值查找操作。在表L中查找具有给定关键字值的元素。&lt;br/&gt;　　④GetElem(L, i)：按位查找操作。获取表L中第i个位置的元素的值。&lt;br/&gt;　　⑤ListInsert(&amp;amp;L, i, e)：插入操作。在表L中第i个位置上插入指定元素。&lt;br/&gt;　　⑥ListDelete(&amp;amp;L, i, &amp;amp;e)：删除操作。删除表L中第i个位置的元素。&lt;br/&gt;　　⑦PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。&lt;br/&gt;　　⑧Empty(L)：判空操作。若L为空表，则返回true,否则返回false。&lt;br/&gt;　　⑨DestroyList(&amp;amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、线性表的操作 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;（1）顺序表 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207142958956-778931056.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、顺序表的结构体定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; maxSize 50 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义线性表的最大长度&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data[maxSize]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序表的元素（这里我们假设是int类型，也可能为其他类型）&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; length;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序表的当前长度&lt;/span&gt;
}Sqlist;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序表的类型定义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、顺序表的操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;①初始化&lt;/span&gt;
viod InitList(Sqlist &lt;/span&gt;&amp;amp;&lt;span&gt;L)
{
    L.length&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;span&gt;②按值查找元素
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要求：用e获取P位置上的元素&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; GetElem(Sqlist L,&lt;span&gt;int&lt;/span&gt; p,&lt;span&gt;int&lt;/span&gt; &amp;amp;e)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;e本身要发生变化，所以用引用型&amp;amp;e（从没有元素到有元素）&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p&amp;lt;&lt;span&gt;0&lt;/span&gt;||p&amp;gt;L.length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    e&lt;/span&gt;=&lt;span&gt;L.data[p];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;span&gt;③按序号位置查找元素
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要求：查找元素e的序号&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; LocateElem(Sqlist L,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; e) 
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;L.length;i++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e==&lt;span&gt;L.data[i])
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;span&gt;④插入元素
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要求：插入元素e&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ListInsert(Sqlist &amp;amp;L,&lt;span&gt;int&lt;/span&gt; p,&lt;span&gt;int&lt;/span&gt; e)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;L本身要发生变化，所以用引用型&amp;amp;L&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p&amp;lt;&lt;span&gt;0&lt;/span&gt;||p&amp;gt;L.length||L.length==max.Size)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;位置错误或者已经达到最大允许值，插入失败&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=L.length-&lt;span&gt;1&lt;/span&gt;;i&amp;gt;=p;--&lt;span&gt;i)
        L.data[i&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]==L.data[i];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用先移动最右边的元素；若先移动最左边，右边的元素会被覆盖&lt;/span&gt;
    L.data[p]=e;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将e赋值给p位置（成为p位置上的新元素）&lt;/span&gt;
    ++(L.length);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表内多了一个元素e，表长自增1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;span&gt;⑤删除元素
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要求：删除元素p，并把删除的元素赋值给e&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; ListDelete(Sqlist &amp;amp;L,&lt;span&gt;int&lt;/span&gt; p,&lt;span&gt;int&lt;/span&gt; &amp;amp;e)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;L、e本身要发生变化，所以用引用型&amp;amp;L，&amp;amp;e&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p&amp;lt;&lt;span&gt;0&lt;/span&gt;||p&amp;gt;L.length-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将p位置上的元素赋值给e&lt;/span&gt;
    e=&lt;span&gt;L.data[p];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=p;i&amp;lt;L.length-&lt;span&gt;1&lt;/span&gt;;++&lt;span&gt;i)
        L.data[i]&lt;/span&gt;==L.data[i+&lt;span&gt;1&lt;/span&gt;];               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;被删除元素右边的所有元素都往左边移动一个位置&lt;/span&gt;
    --&lt;span&gt;(L.length);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表内多了一个元素e，表长自减1&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）单链表 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：在每个结点中除了包含数据域外，还包含一个指针域，用以指向其后继结点；这两部分信息组成数据元素的存储结构，称之为“结点”。n个结点通过指针域相互链接，组成一个链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207143757363-6726485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207143809253-1020547572.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;①带头结点&lt;/strong&gt;：头指针head指向头结点，头结点的值域不含任何信息，从头结点的后继结点开始存储数据信息；头指针始终不等于NULL，当head-&amp;gt;next等于NULL的时候，链表为空。&lt;br/&gt;&lt;strong&gt;②不带头结点&lt;/strong&gt;：头指针head直接指向开始结点；当head等于NULL的时候，链表为空&lt;br/&gt;区分头指针和头结点：不论链表是否带头结点，头指针都指向链表中第一个结点；而带头结点的链表中头结点是第一个结点，只作为链表存在的标志，一般不储存信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207143923675-570889189.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;span&gt;注：暂时默认操作的链表都带头结点，以后有时间再回头总结不带头结点的相关操作。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;1&amp;gt;单链表结点定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; LNode *&lt;span&gt;next;
}LNode;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;2&amp;gt;查找结点&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①按序号查找结点&lt;/span&gt;&lt;br/&gt;在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。&lt;br/&gt;LNode GetElem(LNode *C,int i)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
LNode GetElem(LNode *C,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本算法取出单链表C（带头结点,L为头结点）中第i个位置的结点指针&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数，初始为1&lt;/span&gt;
    LNode *p;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义指针p（指向结点）&lt;/span&gt;
    p= C;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针P指向头结点C（因为此时头结点也是终端结点）&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; L;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若i等于0，则返回头结点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; NULL;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若 i 无效，则返回 NULL&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;( p &amp;amp;&amp;amp; j&amp;lt;i )    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第1个结点开始找，查找第i个结点&lt;/span&gt;
&lt;span&gt;    {  
        p&lt;/span&gt;=p-&amp;gt;&lt;span&gt;next;
        j&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回第i个结点的指针，如果i大于表长，p=NULL，直接返回p即可&lt;/span&gt;
&lt;span&gt;}

&lt;strong&gt;时间复杂度&lt;/strong&gt;：按序号查找操作的时间复杂度为O(n)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②按值查找表结点&lt;/span&gt;&lt;br/&gt;从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针。若整个单链表中没有这样的结点，则返回NULL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
LNode *&lt;span&gt;LocateElem (LinkList L, ElemType e) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本算法查找单链表 C（带头结点）中数据域值等于e的结点指针，否则返回NULL&lt;/span&gt;
    LNode *&lt;span&gt;p;
    p&lt;/span&gt;=&lt;span&gt;C;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( p!=NULL &amp;amp;&amp;amp; p-&amp;gt;data!=e)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第1个结点开始查找data域为e的结点&lt;/span&gt;
        p=p-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到后返回该结点指针，否则返回NULL&lt;/span&gt;
&lt;span&gt;}

&lt;strong&gt;时间复杂度&lt;/strong&gt;：按值查找操作的时间复杂度为O(n)。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;3&amp;gt;插入结点&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①后插操作（利用前驱结点）&lt;/span&gt;：插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207144940534-220084459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
p=GetElem(L, i-&lt;span&gt;1&lt;/span&gt;) ;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①查找插入位置的前驱结点&lt;/span&gt;
s-&amp;gt;next=p-&amp;gt;next;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②令新结点*s的指针域指向*p的后继结点&lt;/span&gt;
p-&amp;gt;next=s;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;③令结点*p的指针域指向新插入的结点*s&lt;/span&gt;
&lt;span&gt;
注意：语句②③的顺序不能颠倒，否则，当先执行p-&amp;gt;next=s后，指向其原后继的指针就不存在了，再执行s-&amp;gt;next = p-&amp;gt;next时，相当于执行了 s-&amp;gt;next=&lt;/span&gt;&lt;span&gt;&lt;span&gt;s,显然是错误的。&lt;/span&gt;
&lt;strong&gt;时间复杂度&lt;/strong&gt;：本算法主要的时间&lt;span&gt;开销在于查找第i&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-1个元素&lt;/span&gt;，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(&lt;span&gt;1&lt;/span&gt;)。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②前插操作（利用后继结点）&lt;/span&gt;：设待插入结点为*s，将插入到*p的前面。我们仍然将*s插入到*p的后面，然后将p-&amp;gt;data与s-&amp;gt;data交换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207145036878-166790927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
s-&amp;gt;next = p-&amp;gt;next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①令新结点*s的指针域指向*p的后继结点&lt;/span&gt;
p-&amp;gt;next = s;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②令结点*p的指针域指向新插入的结点*s&lt;/span&gt;
temp = p-&amp;gt;data;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;③把*p的指针域赋值给temp                  &lt;/span&gt;
p-&amp;gt;data=s-&amp;gt;data;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;④把*s的指针域赋值给*p      （③④⑤为交换数据域部分）&lt;/span&gt;
s-&amp;gt;data=temp;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;⑤把temp的指针域赋值给*s&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;
时间复杂度&lt;/strong&gt;：O(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;4&amp;gt;删除结点&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①删除结点（利用前驱结点）&lt;/span&gt;：先从链表的头结点开始顺序找到其前驱结点，然后再执行删除操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207145543691-1243414350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
p=GetElem(L,i-&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①查找删除位置的前驱结点&lt;/span&gt;
q=p-&amp;gt;next;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②令q指向被删除结点&lt;/span&gt;
p-&amp;gt;next=q-&amp;gt;next    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;③将*q结点从链中“断开”&lt;/span&gt;
free (q) ;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;④释放结点的存储空间&lt;/span&gt;
&lt;br/&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：该算法的主要时间也是耗费在查找操作上，时间复杂度为O(n)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②删除结点（利用后继结点）&lt;/span&gt;：用删除*p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点，也能使得时间复杂度为O(1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207145704034-1210515286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
q=p-&amp;gt;next;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①令q指向*p的后继结点&lt;/span&gt;
p-&amp;gt;data=p-&amp;gt;next-&amp;gt;data;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②和后继结点交换数据域（删除操作只考虑被留下来的数据即可）&lt;/span&gt;
p-&amp;gt;next=q-&amp;gt;next;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;③将*q结点从链中“断开”&lt;/span&gt;
free (q) ;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;④释放后继结点的存储空间&lt;br/&gt;&lt;/span&gt;
&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;5&amp;gt;创建链表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：n个元素已经储存在数组a中，建立链表C&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①尾插法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
viod creatlistR(LNode *&amp;amp;C,&lt;span&gt;int&lt;/span&gt; a[],&lt;span&gt;int&lt;/span&gt; n)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要改变的变量用引用型&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（R代表rear 尾巴）&lt;/span&gt;
&lt;span&gt;{
    LNode &lt;/span&gt;*s,*r;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义指针s（指向新申请的结点）；r（指向C的终端结点）&lt;/span&gt;
    C=(LNode*)malloc(&lt;span&gt;sizeof&lt;/span&gt;(LNode));      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建头结点（申请C的头结点空间）&lt;/span&gt;
    C-&amp;gt;next=NULL;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化成空链表（链表取头结点作为新链表的头）&lt;/span&gt;
    r=C;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针r指向头结点C（因为此时头结点也是终端结点）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;                                
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;++i)                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环申请n个结点来接收数组a[]中的元素&lt;/span&gt;
&lt;span&gt;    {
        s&lt;/span&gt;=(LNode*)malloc(&lt;span&gt;sizeof&lt;/span&gt;(LNode));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针s指向新申请的结点&lt;/span&gt;
        s-&amp;gt;data=a[i];                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用新申请的结点来接收a数组中的一个元素&lt;/span&gt;
        r-&amp;gt;next=s;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用r来接纳新结点&lt;/span&gt;
        r=r-&amp;gt;next;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;r始终指向终端结点，以便接收下一个新来的结点&lt;/span&gt;
&lt;span&gt;    }
    r&lt;/span&gt;-&amp;gt;next=NULL;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（r始终指向终端结点）r下一个设置为NULL，链表C建立完成&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②头插法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
viod creatlistF(LNode *&amp;amp;C,&lt;span&gt;int&lt;/span&gt; a[],&lt;span&gt;int&lt;/span&gt; n)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（F代表first 第一个，开头）&lt;/span&gt;
&lt;span&gt;{
    LNode &lt;/span&gt;*&lt;span&gt;s;                          
    C&lt;/span&gt;=(LNode*)malloc(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(LNode));   
    C&lt;/span&gt;-&amp;gt;next=&lt;span&gt;NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;++&lt;span&gt;i)
    {
        s&lt;/span&gt;=(LNode*)malloc(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(LNode));
        s&lt;/span&gt;-&amp;gt;data=&lt;span&gt;a[i];
        s&lt;/span&gt;-&amp;gt;next=C-&amp;gt;next;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;s所指新结点的指针域next指向C中的开始结点&lt;/span&gt;
        C-&amp;gt;next=s;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点的指针域next指向s结点，使得s成为新的开始结点（插入结点操作）&lt;/span&gt;
&lt;span&gt;    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;6&amp;gt;求表长&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;求表长操作就是计算单链表中数据结点（不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每一个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止。算法的时间复杂度为O(n)。&lt;br/&gt;注：因为单链表的长度是不包括头结点的，因此，不带头结点和带头结点的单链表在求表长操作上会略有不同。对不带头结点的单链表，当表为空时，要单独处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）双链表 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;概念&lt;/strong&gt;：单链表中只有一个指针，指向直接后继，整个链表只能单方向从表头访问到表尾。如果算法中需要频繁地找某结点的前驱结点，单链表的解决方式是遍历整个链表，增加算法的时间复杂度，影响整体效率。&lt;br/&gt;&lt;strong&gt;双链表&lt;/strong&gt;：在单向链表的基础上，给各个结点额外配备一个指针变量，用于指向每个结点的直接前驱元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：双链表可以很方便地找到其前驱结点，因此，插入、删除结点算法的时间复杂度仅为O(1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207155235706-1039806801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207155243878-2076175934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;1&amp;gt;双链表结点定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt; DLNode      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义双链表结点类型&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据域&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; DLNode *prior;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向直接前驱&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; DLNode *next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向直接后继&lt;/span&gt;
}DLNode;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;2&amp;gt;插入结点&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;需求&lt;/strong&gt;：1,2结点之间插入4结点（双链表中p所指的结点之后插入结点*q）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207164150988-921264449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
p-&amp;gt;next-&amp;gt;prior=q;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①把4变成2的前驱结点（新结点*q的指针域指向*p的后继结点）&lt;/span&gt;
q-&amp;gt;next=p-&amp;gt;next;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ②把2变成4的后继结点（结点*p的指针域指向新插入的结点*s）&lt;/span&gt;
q-&amp;gt;prior=p;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ③把1变成4的前驱结点&lt;/span&gt;
p-&amp;gt;next=q;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ④把4变成1的后继结点&lt;/span&gt;
&lt;span&gt;
注：代码的语句顺序不是唯一的，但也不是任意的，①②两步必须在④步之前，否则*p 的后继结点的指针就丢掉了，导致插入失败。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;3&amp;gt;删除结点&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;双链表删除结点时，直接遍历链表，找到要删除的结点，然后利用该结点的两个指针域完成删除操作。&lt;br/&gt;&lt;strong&gt;需求&lt;/strong&gt;：删除2结点（删除双链表中结点*p的后继结点*q）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171207165256175-1645071014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
p-&amp;gt;next=q-&amp;gt;next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①把3变成1的后继结点&lt;/span&gt;
q-&amp;gt;next-&amp;gt;prior=p;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②把1变成3的前驱结点&lt;/span&gt;
free (q) ;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;③释放结点空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立双链表的操作中，也可以采用如同单链表的头插法和尾插法，但是在操作上需要注意指针的变化和单链表有所不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）循环单链表 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171208084530863-1269653407.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;在循环单链表中，表尾结点的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。&lt;/p&gt;
&lt;p&gt;循环单链表的插入、删除算法与单链表的几乎一样，所不同的是如果操作是在表尾进行，则执行的操作不相同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个 “环”，因此，在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。&lt;/p&gt;
&lt;p&gt;在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时可对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。原因：若设置头指针，则对表尾进行操作需要时间复杂度O(n)；若设置尾指针r，则头指针为r-&amp;gt;next，即对表头表尾操作的时间复杂度都为O(1)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）循环双链表 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171208084735331-1354094420.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在循环双链表中，头结点的prior 指针还要指向表尾结点。&lt;br/&gt;在循环双链表L中，某结点*p为尾结点时，p-&amp;gt;next=L;当循环双链表为空表时，其头结点的prior域和next域都等于L。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（6）静态链表 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1077788/201712/1077788-20171208105041113-488273454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;静态链表是借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域 next，与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址（数组下标），又称为游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。&lt;br/&gt;&lt;strong&gt;静态链表和动态链表的区别&lt;/strong&gt;：静态链表限制了数据元素存放的位置范围；动态链表是整个内存空间。数据元素只允许在这块内存空间中随机存放。&lt;/p&gt;
&lt;p&gt; 静态链表&lt;strong&gt;结构体定义&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; MaxSize 50   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态链表的最大长度&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;{      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态链表结构类型的定义&lt;/span&gt;
    ElemType data;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储数据元素&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; next;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个元素的数组下标&lt;/span&gt;
}SLinkList[MaxSize];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态链表以next==-1作为其结束的标志。静态链表的插入、删除操作与动态链表相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但是在一些不支持指针的高级语言（如Basic）中，这又是一种非常巧妙的设计方法。&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;下一篇预告&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三章《栈与队列》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 07:47:00 +0000</pubDate>
<dc:creator>李小小小伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liwei1153300111/p/7987527.html</dc:identifier>
</item>
<item>
<title>[C#]使用Label标签控件模拟窗体标题的移动 - cnc</title>
<link>http://www.cnblogs.com/cncc/p/8005667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cncc/p/8005667.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;本文为原创文章、源代码为原创代码，如转载/复制，请在网页/代码处明显位置标明原文名称、作者及网址，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;开发工具：VS2017&lt;/p&gt;
&lt;p&gt;语言：C#&lt;/p&gt;
&lt;p&gt;DotNet版本：.Net FrameWork 4.0及以上&lt;/p&gt;
&lt;p&gt;一、使用的WIN32 API有两个，一个为ReleaseCapture，另外一个为SendMessage，这两个函数说明如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReleaseCapture函数&lt;/strong&gt;：为了说明ReleaseCapture的用法，需要先知道SetCapture的用法，MSDN是这样描述SetCapture函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
该函数在属于当前线程的指定窗口里设置鼠标捕获。一旦窗口捕获了鼠标，所有鼠标输入都针对该窗口，无论光标是否在窗口的边界内。同一时刻只能有一个窗口捕获鼠标。如果鼠标光标在另一个线程创建的窗口上，只有当鼠标键按下时系统才将鼠标输入指向指定的窗口。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而ReleaseCapture悄悄相反，函数的功能就是释放对鼠标的捕捉。&lt;/p&gt;
&lt;p&gt;为什么要使用这个ReleaseCapture函数，原因在于移动窗体标题时，需要释放对鼠标的捕捉，否则，就不能移动窗体标题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SendMessage函数&lt;/strong&gt;：该函数是用来给窗体发送Windows消息，&lt;/p&gt;
&lt;p&gt;在本文中，该函数是模拟给非窗体客户区域（如窗体标题、最大化、最小化及关闭按钮区域）发送Windows消息，使特定区域能收到拖动窗体标题的消息。&lt;/p&gt;
&lt;p&gt;两者在C#的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ReleaseCapture();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage(IntPtr hwnd, &lt;span&gt;int&lt;/span&gt; msg, &lt;span&gt;int&lt;/span&gt; wParam, &lt;span&gt;int&lt;/span&gt; lParam);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于hwnd、msg、wParam，lParam的具体说明，可以自行百度。&lt;/p&gt;
&lt;p&gt;二、构建模拟移动窗体标题的应用程序，在这里我们使用了一个label（左边，label1），用来将鼠标移到该控件并拖动时，可以移动窗体，&lt;/p&gt;
&lt;p&gt;另外一个label（右边，label2）则用来关闭窗体，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/580518/201712/580518-20171208152424749-304359544.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在label1的MouseDown事件写下如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; label1_MouseDown(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
{
    ReleaseCapture();
     SendMessage(Handle, WM_NCLBUTTONDOWN, HT_CAPTION, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，WM_NCLBUTTONDOWN(0x00A1)，用来给非客户端发送左键按下消息，&lt;/p&gt;
&lt;p&gt;HT_CAPTION(0x0002)，为所需要作用的区域，此次为窗体标题。&lt;/p&gt;
&lt;p&gt;我们在label2的MouseEnter、MouserLeave、Click事件写下如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; label2_MouseEnter(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    label2.BackColor &lt;/span&gt;= Color.FromArgb(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;191&lt;/span&gt;&lt;span&gt;);
    toolTip1.SetToolTip(label2, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; label2_MouseLeave(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    label2.BackColor &lt;/span&gt;=&lt;span&gt; Color.Silver;
    toolTip1.SetToolTip(label2, &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; label2_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，需要为关闭按钮填写显示“关闭”按钮的提示，因此需要使用ToolTip控件。&lt;/p&gt;
&lt;p&gt;三、构建完的程序界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/580518/201712/580518-20171208153406937-959422686.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很简单呢，本文只要掌握ReleaseCapture及SendMessage函数即可。&lt;/p&gt;
&lt;p&gt;四、源代码及EXE如下：&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;0&quot;&gt;
&lt;pre&gt;
&lt;a href=&quot;https://pan.baidu.com/s/1bo3SJan&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://pan.baidu.com/s/1bo3SJan&lt;/span&gt;&lt;/a&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EXE：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;0&quot;&gt;
&lt;pre&gt;
&lt;a href=&quot;https://pan.baidu.com/s/1gfITSSN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://pan.baidu.com/s/1gfITSSN&lt;/span&gt;&lt;/a&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 08 Dec 2017 07:39:00 +0000</pubDate>
<dc:creator>cnc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cncc/p/8005667.html</dc:identifier>
</item>
<item>
<title>Python函数篇（2）-递归函数、匿名函数及高阶函数 - 无敌小怪兽</title>
<link>http://www.cnblogs.com/Chen-Zhipeng/p/8005627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chen-Zhipeng/p/8005627.html</guid>
<description>&lt;h2&gt;1.全局变量和局部变量&lt;/h2&gt;
&lt;p&gt;　　一般定义在程序的最开始的变量称为函数变量，在子程序中定义的变量称为局部变量，可以简单的理解为，无缩进的为全局变量，有缩进的是局部变量，全局变量的作用域是整个程序，而局部变量的作用域是子程序内部，当程序运行时，首先会找程序内部有没有局部变量，如果有，则调用，如果没有，才会去调用全局变量。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name=&quot;czp&quot;&lt;/span&gt;　　　　　　　　　　　　#全局变量
def&lt;span&gt; func():
   &lt;span&gt; name=&quot;czp1&quot;&lt;/span&gt;　　　　　　　　　#局部变量
    print&lt;span&gt;(name)
func()
运行结果：
czp1　　　　　　　　　　　　 　调用func()函数，程序会先在函数内部找有没有name这个变量，如果有，就会调用该name的值，而如果没有定义局部变量的话，函数会去找全局name。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过global关键字，通过局部变量修改全局变量，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name=&quot;czp&quot;&lt;/span&gt;　　　　　　　　　　#定义全局变量
def&lt;span&gt; func():
    &lt;span&gt;global&lt;/span&gt;&lt;span&gt;&lt;span&gt; name&lt;/span&gt;　　　　　　　在函数内部，通过global关键字，通过局部变量修改全局变量的值
    name=&quot;czp1&quot;
    print&lt;span&gt;(name)
func()　　　　　　　　　　　　打印局部变量中name的值
print&lt;span&gt;(name)　　　　　　　　　打印全局变量中name的值
运行结果：
czp1
czp1　　　　　　　　　　　　　在运行结果中可以明显看出，通过global，在定义局部变量的同时，也修改了全局变量的值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　global与nonlocal的区别：&lt;/p&gt;
&lt;p&gt;　　python引用变量的顺序： 当前作用域局部变量-&amp;gt;外层作用域变量-&amp;gt;当前模块中的全局变量-&amp;gt;python内置变量&lt;/p&gt;
&lt;p&gt;　　global关键字用来在函数或局部作用域中使用全局变量，并通过glabal关键字在局部作用域中修改全局变量（一般不推荐这么做）&lt;/p&gt;
&lt;p&gt;　　nonlocal关键字用来在函数或局部作用域使用外层（非全局）变量。&lt;/p&gt;
&lt;h2&gt;2.递归函数&lt;/h2&gt;
&lt;p&gt;　　在一个函数的内部，可以调用其他的函数，如果某一个函数在内部调用的函数仍然是自身，这个函数就可以称为递归函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; calc(n):
    print&lt;span&gt;(n)
    if int(n/2)==&lt;span&gt;0:
        return&lt;span&gt; n
    return &lt;span&gt;calc(int(n/2&lt;/span&gt;&lt;span&gt;&lt;span&gt;))　　&lt;/span&gt;　　　　　　在calc函数中，反复调用calc自身，这样的函数就是递归函数
calc(10&lt;span&gt;)
运行结果：
10
5
2
1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：在递归函数中，并不是可以让自身永远的循环下去，递归函数中必须定义一个明确的结束条件，每进行更深一次的递归，解决问题的规模必须要较上一层有所减少，&lt;/p&gt;
&lt;p&gt;　　递归函数常用来进行二分查找。。&lt;/p&gt;
&lt;h2&gt;3.匿名函数&lt;/h2&gt;
&lt;p&gt;　　匿名函数其实就是不需要指定显示的函数。用lambda关键字定义，通常我们定义一个函数用这种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def&lt;span&gt; calc(x):
    return x+1
print(calc(2&lt;span&gt;))
运行结果：
3&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而上段代码 用匿名函数使用的话，就可以使用如下的方式，通过lambda关键字，传入一个形参x，用冒号隔开，后面加入return的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;res=lambda x:x+1&lt;/span&gt;
print(res(2&lt;span&gt;))
运行结果：
3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　匿名函数单独这么用意义不大，但是和其他函数一起用的时候，功能就显现的很明显了。如下面的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;res=map(lambda x:x**2,[2,4,6,])&lt;/span&gt;
for i in&lt;span&gt; res:
    print&lt;span&gt;(i)
运行结果：
4
16
36&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我会在接下来写内置方法的时候具体的展示出使用匿名函数的好处。&lt;/p&gt;
&lt;h2&gt;4.高阶函数&lt;/h2&gt;
&lt;p&gt;　　高阶函数的特点如下：1）函数接收的参数是一个函数 ；2）函数的返回值是一个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
将函数作为参数传给另一个函数&lt;br/&gt;def&lt;span&gt; foo(n):　　
    print&lt;span&gt;(n)
def&lt;span&gt; bar(name):
    print(&quot;my name is %s&quot;%&lt;span&gt;name)
&lt;span&gt;print(foo(bar(&quot;尼古拉斯赵四&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)))&lt;/span&gt;
运行结果：
my name is&lt;span&gt; 尼古拉斯赵四
None
None　　　　　　　　　　　　　　　　　　　　返回两个None，因为在foo（）和bar（）函数中我没有定义retturn。默认返回None&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
将函数作为另一个函数的返回值&lt;br/&gt;def&lt;span&gt; bar():
    print(&quot;from bar&quot;&lt;span&gt;)
def&lt;span&gt; foo():
    print(&quot;from foo&quot;&lt;span&gt;)
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; bar&lt;/span&gt;
foo()()
运行结果：
from&lt;span&gt; foo
from bar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.内置函数&lt;/h2&gt;
&lt;p&gt;　　首先我先介绍3个比较重要，也是比较常用的内置函数，map；reduce，filter3个内置函数&lt;/p&gt;
&lt;h3&gt;　　1.map：&lt;/h3&gt;
&lt;p&gt;　  　将函数作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。&lt;/p&gt;
&lt;p&gt;　　  模拟一下这个需求：有一个列表[1,2,3,4],我要让列表中的每一个元素自增1，然后打印出来，这个程序可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
name=[1,2,3,4&lt;span&gt;]　　　　　　　　
res=&lt;span&gt;[]　　　　　　　　　　　　　　　　　　定义一个空列表，用来接收自增一后的值
def&lt;span&gt; calc(array):
    for i in&lt;span&gt; array:　　　　　　　　　　 使用for循环，遍历传入列表中的每一个元素
        res.append(i+1)　　　　　　　　
    return&lt;span&gt; res
print&lt;span&gt;(calc(name))
运行结果：
[2, 3, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那如果 我想要的需求是让列表自减1，自乘呢，难道要把这段代码重复写一段，只是改一句res.append（i-1），或者更高级一点，我们在定义一个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
def increase(x):
    return x-1　　　　　　　　　　　　　　　定义一个自减1的函数&lt;span&gt;
name=[1,2,3,4&lt;span&gt;]
res=&lt;span&gt;[]
&lt;span&gt;def&lt;/span&gt;&lt;span&gt;&lt;span&gt; calc(func,array):　&lt;/span&gt;　　　　　　　　　 在这里定义两个形参，一个用来传入函数increase，一个用来传入列表name
    for i in&lt;span&gt; array:
        res.append(increase(i))　　　　 
    return&lt;span&gt; res
print&lt;span&gt;(calc(increase,name))
运行结果：
[0, 1, 2, 3]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更高级一点呢？我们用map+上面提到的匿名函数，可以很好的完成这样的需求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
name=[1,2,3,4]&lt;br/&gt;&lt;span&gt;print(list(map(lambda x:x+1,name)))&lt;/span&gt;&lt;br/&gt;运行结果：&lt;br/&gt;[2,3,4,5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok,上面写了那么多，两行代码搞定。&lt;/p&gt;
&lt;h3&gt;　　2.reduce：&lt;/h3&gt;
&lt;p&gt;　　reduce()函数接收的参数和 map()类似，&lt;strong&gt;一个函数 f，一个list&lt;/strong&gt;，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。可以简单的理解为，map接受一个列表，返回的仍然是一个列表，而reduce会进行计算，返回一个值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
from functools import&lt;span&gt; reduce                  必须导入reduce方法
name=[1,2,3,4&lt;span&gt;]
&lt;span&gt;print((reduce(lambda x,y:x+&lt;/span&gt;&lt;span&gt;&lt;span&gt;y,name)))　&lt;/span&gt;　　　　　函数必须传入两个参数，然后传入list。
运行结果：
10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　reduce还有一个默认参数 ，就是可以在list后再传入一个初始值。&lt;/p&gt;
&lt;pre&gt;
　def reduce(function, sequence, initial=None)    这个初始值默认为None
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
from functools import&lt;span&gt; reduce
name=[1,2,3,4&lt;span&gt;]
print&lt;span&gt;((reduce(lambda x,y:x+y,name,5&lt;/span&gt;&lt;span&gt;&lt;span&gt;)))&lt;/span&gt;　　　　 还是上面的例子，我在最后加了初始值5（默认是none）
运行结果：
15&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.filter&lt;/h3&gt;
&lt;p&gt;　　 filter读入iterable所有的项，判断这些项对function是否为真，返回一个包含所有为真的项的迭代器。如果function是None，返回非空的项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
name=[&quot;czp&quot;,&quot;cc&quot;,&quot;zp1&quot;&lt;span&gt;]
&lt;span&gt;print(list(filter(lambda n:n.endswith(&quot;c&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;),name)))&lt;/span&gt;　　　　通过匿名函数判断条件，返回值为真，就会打印成列表的形式
运行结果：
['cc']&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　在下一篇文章中，我会介绍其他的常用内置函数&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 07:37:00 +0000</pubDate>
<dc:creator>无敌小怪兽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chen-Zhipeng/p/8005627.html</dc:identifier>
</item>
<item>
<title>为什么选择Django？ - 刘江-Python-Django</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8004775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8004775.html</guid>
<description>&lt;p&gt;Web开发是Python语言应用领域的重要部分，也是工作岗位比较多的领域。如果你对基于Python的Web开发有兴趣，正打算开始学习使用Python做Web开发，或者已经是一个Web开发者有工作需要，要做Web服务、自动化运维、数据的图形化展示等，那么学习一门基于Python的Web开发框架是必修课。&lt;/p&gt;
&lt;p&gt;Python作为当前最火爆最热门，也是最主要的Web开发语言之一，在其二十多年的历史中出现了数十种Web框架，比如Django、Tornado、Flask、Twisted、Bottle和Web.py等，它们有的历史悠久，有的发展迅速，还有的已经停止维护。&lt;/p&gt;
&lt;h2 id=&quot;一基于python的代表性web框架&quot;&gt;一、基于Python的代表性Web框架&lt;/h2&gt;
&lt;p&gt;下面是一些比较有代表性的框架：&lt;/p&gt;
&lt;h4 id=&quot;django&quot;&gt;&lt;strong&gt;Django：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/30dct42onatblc9ser5dr8zu/image.png&quot; alt=&quot;image.png-11.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布于2003年，是当前Python世界里最负盛名且最成熟的Web框架，最初被用来制作在线新闻的Web站点。Django的各模块之间结合得比较紧密，所以在功能强大的同时又是一个相对封闭的系统（依然是可以自定义的），但是其健全的在线文档及开发社区，使开发者在遇到问题时能找到解决办法。&lt;/p&gt;
&lt;h4 id=&quot;tornado&quot;&gt;&lt;strong&gt;Tornado：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/51oe6tygqztk89fqypysh8vf/image.png&quot; alt=&quot;image.png-25.1kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个强大的、支持协程、高效并发且可扩展的Web服务器，发布于2009年9月，应用于FriendFeed、Facebook等社交网站。它的强项在于可以利用异步协程机制实现高并发的服务。&lt;/p&gt;
&lt;h4 id=&quot;flask&quot;&gt;&lt;strong&gt;Flask：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/0w66o08kjzrbkx4jkh12lbzp/image.png&quot; alt=&quot;image.png-60.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Python Web框架家族里比较年轻的一个，发布于2010年，它吸收了其他框架的优点并且把自己的主要领域定义在了微小项目上，以短小精干，简洁明了著称。&lt;/p&gt;
&lt;h4 id=&quot;twisted&quot;&gt;&lt;strong&gt;Twisted：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/jnqcs1g2n6ms0lo1l260m3mf/image.png&quot; alt=&quot;image.png-41.1kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个有着十多年历史的开源事件驱动框架。它不像前三种着眼于Web应用开发，而是适用从传输层到自定义应用协议的所有类型的网络程序的开发，并能在不同的操作系统上提供很高的运行效率。但是，目前对Python3的支持有限，建议使用Python2.7。&lt;/p&gt;
&lt;h2 id=&quot;二选择框架的原则&quot;&gt;二、选择框架的原则&lt;/h2&gt;
&lt;p&gt;这么多的Web框架，我们没有那么多的精力全都学一遍，也不可能全部精通，必然要有所取舍，那么该如何选择呢？有哪些可以参考的原则呢？&lt;/p&gt;
&lt;p&gt;下面的原则不一定正确，但可以作为参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择更主流的框架。因为它们的文档更齐全，技术积累更多，社区更繁盛，能得到更好的帮助和支持。&lt;/li&gt;
&lt;li&gt;选择更活跃的框架。关注项目在GitHub等环境中的更新频率、Issue和Pull Request的响应情况。如果一个项目长期没有更新，或者有一堆的问题需要解决但是没有得到响应，就不应该是你学习的对象。&lt;/li&gt;
&lt;li&gt;选择能够满足需求的框架。没有最好的框架，只有更合适的框架。你所选择的Web框架不仅需要满足当前的需求，还要充分考虑项目发展一段时间后的情况，即前瞻性，避免盲目选择而导致将来推倒重来的情况。&lt;/li&gt;
&lt;li&gt;选择时效性好的框架。在学习和使用框架的时候经常需要查阅和参考各种网络上的文章、博客和教程，但是需要注意他们的发表时间。有些框架的相关文章已经很老了，很久没更新了，应该放弃这种框架；有的框架一直以来都有不断的新文章、新博客出现，就是比较不错的选择。&lt;/li&gt;
&lt;li&gt;选择入门友好的框架。这条只对新手适用。详细的框架文档、官方教程对新手来说都是极大的帮助和鼓励。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三为什么选择django&quot;&gt;三、为什么选择Django？&lt;/h2&gt;
&lt;p&gt;首先介绍一下Django，Django具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能完善、要素齐全：该有的、可以没有的都有，自带大量常用工具和框架，无须你自定义、组合、增删及修改。&lt;/li&gt;
&lt;li&gt;完善的文档：经过十多年的发展和完善，Django有广泛的实践案例和完善的在线文档。开发者遇到问题时可以搜索在线文档寻求解决方案。&lt;/li&gt;
&lt;li&gt;强大的数据库访问组件：Django的Model层自带数据库ORM组件，使得开发者无须学习其他数据库访问技术（SQL、pymysql、SQLALchemy等）。&lt;/li&gt;
&lt;li&gt;灵活的URL映射：Django使用正则表达式管理URL映射，灵活性高。新版的2.0，进一步提高了URL编写的优雅性。&lt;/li&gt;
&lt;li&gt;丰富的Template模板语言：类似jinjia模板语言，不但原生功能丰富，还可以自定义模板标签，并且与其ORM的用法非常相似。&lt;/li&gt;
&lt;li&gt;自带后台管理系统admin：只需要通过简单的几行配置和代码就可以实现一个完整的后台数据管理控制平台。&lt;/li&gt;
&lt;li&gt;完整的错误信息提示：在开发调试过程中如果出现运行错误或者异常，Django可以提供非常完整的错误信息帮助定位问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，我们根据前面的选择原则我们来逐条对比一下：&lt;/p&gt;
&lt;h4 id=&quot;主流活跃程度&quot;&gt;1.主流、活跃程度：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/4trx7nyt8ipjw2tv5xinhf6k/image.png&quot; alt=&quot;image.png-100.2kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从Github的数据来看，Django的开发非常活跃，迭代速度也非常快。&lt;/p&gt;
&lt;h4 id=&quot;是否可以满足需求&quot;&gt;2.是否可以满足需求：&lt;/h4&gt;
&lt;p&gt;Django以要素齐全、工具丰富、框架庞大著称，基本上别的框架有的它有，别的框架没有的它也有，如果Django满足不了需求，那么别的框架同样也一样。&lt;/p&gt;
&lt;h4 id=&quot;时效性&quot;&gt;3.时效性：&lt;/h4&gt;
&lt;p&gt;Django有很长的开发和实践过程，或早或晚的文档、教程、帮助、博客等等非常多，资料更新速度也很快，比如博主个人网站的Django教程，大家没事可以逛逛，^-^。&lt;/p&gt;
&lt;h4 id=&quot;入门友好程度&quot;&gt;4.入门友好程度：&lt;/h4&gt;
&lt;p&gt;一个框架能否流行起来，对新手入门是否友好非常关键。Django在这一点做的非常好。&lt;/p&gt;
&lt;h2 id=&quot;四django的不足&quot;&gt;四、Django的不足&lt;/h2&gt;
&lt;p&gt;不能光说优点，也说说一些缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;框架庞大，被认为不够精简、捆绑的内容太多&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实我不认同这一条，我真不认为这是个缺点。&lt;/p&gt;
&lt;p&gt;首先，对于新手，Django集成好的工具和部件，让你无须再费脑力去学习如何安装、调试、集成、兼容别的工具。Django帮你把它们都集成好了，而且保证兼容性、可用性和方便性，就好比联想一体机，开机即用，效率也高。而一些如flask的框架，虽然精简，但是你要自己安装各种工具、ORM、插件等等，好比DIY电脑，在用之前，要知道买什么配件，怎么搭配，怎么组装，怎么配置效率才高，将新手的热情大量消耗在非关键性的内容上。&lt;/p&gt;
&lt;p&gt;其次，对于老手，Django也是开放的，你完全可以关闭不必要的功能，忽略不使用的组件，或者自定义希望的组件，包括ORM和Template在内，都可以自由选择。&lt;/p&gt;
&lt;p&gt;因此，我认为Django系统庞大、捆绑工具不是问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在异步通信方面略有欠缺&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从本质上来说，Tornado在异步协程机制实现高并发的服务上要更强一点。Django在这方面有追赶的目标，但这不是说Django就差到不能用了，对么？&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;五基于python进行web开发的技术栈&quot;&gt;五、基于Python进行Web开发的技术栈&lt;/h2&gt;
&lt;p&gt;想要熟练地使用Django进行Web开发，设计生产环境可用的，能够应对一定规模访问量的Web应用，开发者要学会的远远不止Django本身。Python基础、环境搭建、前端语言、API设计、网站架构、系统管理、持续集成、服务化、数据处理、并发处理等等，都是相关的知识领域，包括但不限于以下的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;熟悉Python语言&lt;/li&gt;
&lt;li&gt;对前端的HTML\CSS\Javascript比较熟悉&lt;/li&gt;
&lt;li&gt;对网络基础，比如HTTP、TCP/IP等比较熟悉&lt;/li&gt;
&lt;li&gt;熟悉数据库、缓存、消息队列等技术的使用场景和使用方法&lt;/li&gt;
&lt;li&gt;日常能使用Linux或Mac系统工作（Windows属于标配）&lt;/li&gt;
&lt;li&gt;有性能优化经验，能快速定位问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，还要对业务有深刻理解，能够写出可维护性足够高的代码。当然，以上都是对经验丰富的开发者而言，对于新手刚入门者，我们朝着这个目标努力学习就好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面是基于Python的Web开发技术栈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/feixuelove1009/5sctaeogep83yofhm4xqxrxo/image.png&quot; alt=&quot;image.png-27.6kB&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;欢迎大家访问我的个人网站刘江的博客和教程www.liujiangblog.com&quot;&gt;欢迎大家访问我的个人网站《刘江的博客和教程》&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;www.liujiangblog.com&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;主要分享python-及django教程以及相关的博客&quot;&gt;主要分享Python 及Django教程以及相关的博客！&lt;/h2&gt;
&lt;h2 id=&quot;交流qq群514549650&quot;&gt;交流QQ群：514549650&lt;/h2&gt;
</description>
<pubDate>Fri, 08 Dec 2017 07:34:00 +0000</pubDate>
<dc:creator>刘江-Python-Django</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8004775.html</dc:identifier>
</item>
<item>
<title>比特币如何达成共识 - 最长链的选择 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/8005563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/8005563.html</guid>
<description>&lt;p&gt;比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？&lt;/p&gt;
&lt;h2 id=&quot;为什么要遵守协议&quot;&gt;为什么要遵守协议&lt;/h2&gt;
&lt;p&gt;这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，&lt;br/&gt;而只有遵守规则才会得到其他的节点认同。&lt;br/&gt;因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;共识：共同遵守的协议规范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;去中心化共识&quot;&gt;去中心化共识&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://learnblockchain.cn/2017/11/04/bitcoin-pow/&quot;&gt;工作量证明&lt;/a&gt;一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，&lt;br/&gt;实际上，比特币的共识由所有节点的4个&lt;strong&gt;独立过程&lt;/strong&gt;相互作用而产生：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个节点（挖矿节点）依据标准对每个交易进行独立验证&lt;/li&gt;
&lt;li&gt;挖矿节点通过完成工作量证明，将交易记录独立打包进新区块&lt;/li&gt;
&lt;li&gt;每个节点独立的对新区块进行校验并组装进区块链&lt;/li&gt;
&lt;li&gt;每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。&lt;/p&gt;
&lt;p&gt;第1 2 3步在&lt;a href=&quot;https://learnblockchain.cn/2017/11/04/bitcoin-pow/&quot;&gt;比特币如何挖矿-工作量证明&lt;/a&gt;一篇有提到过，下面着重讲第4步。&lt;/p&gt;
&lt;h2 id=&quot;最长链的选择&quot;&gt;最长链的选择&lt;/h2&gt;
&lt;p&gt;先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为&lt;strong&gt;主链&lt;/strong&gt;&lt;br/&gt;每一个（挖矿）节点总是选择并尝试延长主链。&lt;/p&gt;
&lt;h3 id=&quot;分叉&quot;&gt;分叉&lt;/h3&gt;
&lt;p&gt;当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。&lt;br/&gt;当这个两个区块传播时，一些节点首先收到#3458A, 一些节点首先收到#3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/289351/201712/289351-20171208152327437-403425492.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为&lt;strong&gt;备用链&lt;/strong&gt;保存（保存是因为备用链将来可能会超过主链难度称为新主链）。&lt;/p&gt;
&lt;h3 id=&quot;分叉解决&quot;&gt;分叉解决&lt;/h3&gt;
&lt;p&gt;收到#3458A的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受#3458B区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为B链）。&lt;br/&gt;这时总会有一方抢先发现工作量证明解并将其传播出去，假设以#3458B为父区块的工作量证明首先解出，如图：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/289351/201712/289351-20171208152337812-952924504.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当原本以#3458A为父区块求解的节点在收到#3458B, #3459B之后，会立刻将B链作为主链（因为#3458A为顶点的链已经不是最长链了）继续挖矿。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;节点也有可能先收到#3459B，再收到#3458B，收到#3459B时，会被认为是“孤块“（因为还找不到#3459B的父块#3458B）保存在孤块池中，一旦收到父块#3458B时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt; - 系统学习区块链，打造最好的区块链技术博客&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 07:24:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/8005563.html</dc:identifier>
</item>
<item>
<title>TFS2017持续发布中调用PowerShell启停远程应用程序 - JiaLiWei</title>
<link>http://www.cnblogs.com/jlw123199/p/8005385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlw123199/p/8005385.html</guid>
<description>&lt;p&gt;目前团队项目中有多个Web、服务以及与大数据平台对接接口等应用，每次的发布和部署采用手工的方式进行。停止应用程序，拷贝发布包，启动应用程序，不停的循环着，并且时不时地会出现一些人为错误性问题。这种模式消耗的很多团队时间和精力。&lt;/p&gt;
&lt;p&gt;为了解决该问题，决定引入自动构建和持续部署的一些辅助工具，采用的是微软公司的TeamFoundationServer2017，并把DevOps相关模式推广到团队中。&lt;/p&gt;
&lt;p&gt;在这个过程中，有一系列已遇到或会将遇到的问题需要解决，作为一个整理和记录，希望以后可以快速处理类似的问题。&lt;/p&gt;
&lt;p&gt;在我们的应用中，有一个数据计算和文件上传入库计算的两个Self-Host WCF服务，服务运行在多个服务器上，每台服务器运行一个或多个服务实例进行着大量和较长时间的计算服务。服务以控制台的形式运行在WindowServer2012 R2系统上，并提供一些数据计算过程信息的过程步骤监控信息。基于这样的操作环境和应用服务类型，使用Invoke-Command等方式，因为操作系统内权限等问题，是无法正常启动远程机器上带有界面的应用程序的，通常是进程启动了但是没有应用的交互界面（比如启动远程服务上的计算器）。针对这样的应用，下面是我采用实现停止、发布和启动服务过程的一些具体实现方法。&lt;/p&gt;
&lt;p&gt;实现这个发布流程需要两个PowerShell脚本，一个应用在构建服务Agent服务器上，负责完成对分发服务器的认证授权和指令发送，另一个运行在服务所运行在的服务上，负责启动和关闭服务器上的Self-Host应用程序。TFS构建代理上通过调用代理服务上的脚本，实现基本认证和授权，传递命令到服务寄宿的服务上，并调用脚本完成应用程序的启动和停止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建服务器上的脚本文件1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;param(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$applicationName = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;**.Service.WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$switchType = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$account = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;administrator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;[]]$computername=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.0.0.102&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$applicationType =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UploadHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Write-Host &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ApplicatnonName:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; $applicationName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Write-Host &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SwithType:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; $switchType
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; Write-Host &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Account:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; $account
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; Write-Host &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Password:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; $password
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; Write-Host &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IP:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; $computername
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; $secpwd = convertto-securestring $password -asplaintext -&lt;span&gt;force
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; $cred = &lt;span&gt;new&lt;/span&gt;-&lt;span&gt;object&lt;/span&gt; System.Management.Automation.PSCredential -&lt;span&gt;argumentlist $account,$secpwd
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; $session_many = &lt;span&gt;new&lt;/span&gt;-pssession -computername $computername -&lt;span&gt;Credential $cred
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( $applicationType -eq &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebSocketHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;($switchType -eq &lt;span&gt;'&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Invoke-Command -Session $session_many -ThrottleLimit &lt;span&gt;1&lt;/span&gt; -ScriptBlock { C:\CICD\ExecutedAppManagement.ps1 -applicationName &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\ODWebSocketHost\ Service.WebSocketHost.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -switchType &lt;span&gt;'&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -applicationType &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;($switchType -eq &lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Invoke-Command -Session $session_many -ThrottleLimit &lt;span&gt;1&lt;/span&gt; -ScriptBlock { C:\CICD\ExecutedAppManagement.ps1 -applicationName &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Service.WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -switchType &lt;span&gt;'&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -applicationType &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;服务器端的脚本文件2&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;脚本文件1中对应ExecutedAppManagement.ps1文件名&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;param(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$applicationName = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;applicationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$switchType = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [&lt;span&gt;string&lt;/span&gt;]$applicationType = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Write-&lt;span&gt;Host $switchType
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;($switchType -eq &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     Write-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Turn on App!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $applicationName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    #开启WebSocket应用程序
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;($applicationType -eq &lt;span&gt;'&lt;/span&gt;&lt;span&gt;WebSocketHost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         $registerTask = Get-ScheduledTaskInfo -TaskName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TaskODWebSocketHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;$registerTask)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;            Write-&lt;span&gt;Host  $registerTask
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;            $taskAction = New-ScheduledTaskAction $applicationName #&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\ODWebSocketHost\Service.WebSocketHost.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;            $taskTrigger = New-ScheduledTaskTrigger -&lt;span&gt;AtStartup
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;            Register-ScheduledTask TaskODWebSocketHost -Action $taskAction -&lt;span&gt;Trigger $taskTrigger 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Start-ScheduledTask -TaskName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TaskODWebSocketHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;($switchType -eq &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     Write-Host &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Turn off App!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $applicationName
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     stop-process -&lt;span&gt;name $applicationName
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     Write-Host $applicationName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;has turn off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;控制过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先需要在构建代理服务器上添加对应用寄宿服务器上的信任&lt;/p&gt;
&lt;p&gt;Set-Item wsman:\localhost\Client\TrustedHosts -value 10.0.0.*&lt;/p&gt;
&lt;p&gt;将脚本文件2拷贝的应用寄宿服务器上指定的违章。&lt;/p&gt;
&lt;p&gt;通过调用脚本文件1，并传递适当的参数实现对Sefl-Host服务器的启停控制。&lt;/p&gt;
&lt;p&gt;最后将调用脚本文件1的命令集成到TFS2107的发布定义中，实现对类似Windows环境上运行的带有交互界面的应用程序进行启动、发布和停止控制。下图是持续发布结果&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/28076/201712/28076-20171208145625218-971907788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Dec 2017 06:58:00 +0000</pubDate>
<dc:creator>JiaLiWei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jlw123199/p/8005385.html</dc:identifier>
</item>
<item>
<title>程序员的自我救赎---4.2：消息中心讲解与应用 - Near_wen</title>
<link>http://www.cnblogs.com/demon28/p/8005376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon28/p/8005376.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;《前言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（一） Winner2.0 框架基础分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（二）PLSQL报表系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（三）SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（四） 短信中心与消息中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（五）钱包系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（六）GPU支付中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（七）权限系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（八）监控系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（九）会员中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十） APP版本控制系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十一）Winner前端框架与RPC接口规范讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十二）上层应用案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十三）总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《消息中心讲解与应用》&lt;/p&gt;

&lt;p&gt;在讲消息中心之前我希望看我这篇博客的园友们能先看一些《&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7991355.html&quot; target=&quot;_blank&quot;&gt;短信中心源码分析与应用（工厂）&lt;/a&gt;》，因为这两个项目很类似，但是在Winner中的意义却差别很大。&lt;/p&gt;
&lt;p&gt;首先短信中心的主要职责是发送短信，消息中心中包含短信模块。除此之外消息中心支持：微信消息推送，邮件推荐，APP消息推送，站内信等等。&lt;/p&gt;
&lt;p&gt;常言道：“一图胜过千言万语”。我们直接上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171208143838187-2118229576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 消息中心是符合标准工厂的方式来做的，使用静态工厂却创建。这跟前面的《&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7991355.html&quot; target=&quot;_blank&quot;&gt;短信中心源码分析与应用（工厂）&lt;/a&gt;》里讲到的1.0是一模一样的，在消息中心中我们并没有&lt;/p&gt;
&lt;p&gt; 去SaaS。 这是也有一点历史原因，其实就是 短信中心是 后来重构了一次，而消息中心没有。&lt;/p&gt;

&lt;p&gt;消息中心在Winner体系中应用最多的地方就是APP的消息推送。我们使用的“极光推送”。这个第三方平台还可以，当然类似的平台还有几个，目前我们只用了极光推送&lt;/p&gt;
&lt;p&gt;我们没有去对比其他平台，总归极光符合我们的需求，就一直用他。关于APP如何实现极光推送这里我就直接引用极光推送的官网：&lt;a href=&quot;https://www.jiguang.cn&quot; target=&quot;_blank&quot;&gt;https://www.jiguang.cn &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后就是微信公众号的推送，这中间如何申请微信公众号，如何实现发送消息官网上都很清楚我也不去赘述了:&lt;a href=&quot;https://mp.weixin.qq.com/&quot; target=&quot;_blank&quot;&gt; https://mp.weixin.qq.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只是微信有比较恶心的一点就是必须按照它模板的格式去发，甚至说发送的内容什么字体什么颜色都有明确的要求。 至此，这里对我们来说要求每个项目都要去&lt;/p&gt;
&lt;p&gt;编写模板信息就太费事了，所以我们将常用模板保存在了数据库，并自己开发了模板解析的方法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171208151322718-188226168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;其实透一点就是数据库存储了膜拜内容，而膜拜内容中我们用了类似之前&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7986177.html&quot; target=&quot;_blank&quot;&gt;《PLSQL报表系统》&lt;/a&gt;中的关键字替换，而这些关键字我们都有对应的实体类。&lt;/p&gt;
&lt;p&gt;整个项目不复杂，但是战略位置却很有意义，还是那句话：“职责分离”。&lt;/p&gt;

&lt;p&gt;最后，发送邮件、站内信 都是自己开发的具体实现，区别在于，站内信我们没有去开发一个“站内信系统”、“邮件系统”。这个是没有开发的，相对而言这两个的需求&lt;/p&gt;
&lt;p&gt;在我们所开发的项目中还是较少的，邮件我们用的腾讯的企业邮箱（&lt;a href=&quot;https://exmail.qq.com&quot; target=&quot;_blank&quot;&gt;https://exmail.qq.com&lt;/a&gt;）有每天有500条免费发送量，足够我们用了。如果对此后续还业务量的需求，我们也会像短信中心&lt;/p&gt;
&lt;p&gt;那样开发一个“邮件系统”。甚至还要单独拿台服务器出来做邮件服务器。 &lt;/p&gt;

&lt;p&gt;另外，我图上也特地画了一下Web模块，之前的“短信中心”是没有Web模块，假如这个时候有一个需求就是：临时需要推送一条通知给制定用户的话，怎么办？&lt;/p&gt;
&lt;p&gt;短信中心是没有操作界面给我们的市场人员去操作的。&lt;/p&gt;
&lt;p&gt;其实不是不能，而是这个需求的实现者不是短信中心，而是消息中心。由消息中心的Web管理后台的给用户发送消息，甚至是群发短信，微信短信组合发送 都可以的。&lt;/p&gt;

&lt;p&gt;消息中心其实没有必要单独拿出来开一个篇章，但是还是因为它的是项目开发中必不可少的一个组件，重要的还是表达一个Winner2.0的“&lt;strong&gt;组件化&lt;/strong&gt;”思想。&lt;/p&gt;
&lt;p&gt;（补充一点：其实消息中心又那么点“工厂方法”的味道， 如果把消息中心和短信中心组合在一个项目里面的话，那这就完整的工厂方法模式了。）&lt;/p&gt;

&lt;p&gt;有兴趣一起探讨Winner框架的可以加我们QQ群：261083244。或者扫描左侧二维码加群。&lt;/p&gt;

</description>
<pubDate>Fri, 08 Dec 2017 06:57:00 +0000</pubDate>
<dc:creator>Near_wen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon28/p/8005376.html</dc:identifier>
</item>
<item>
<title>这些 Drawable 的小技巧，你都了解吗？ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/8005297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/8005297.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb09fd227fd?w=900&amp;amp;h=500&amp;amp;f=jpeg&amp;amp;s=170828&quot; alt=&quot;173&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;在 Android 的开发过程中，Drawable 经常会被用到，一般会用 Drawable 为 View 设置一个显示的效果。而在 Android 下，也提供了很多 Drawable 的默认实现，它们涉及到的内容非常的多，从属性到方法，但是日常生活中，会用到的只有那么些方式。&lt;/p&gt;
&lt;p&gt;本文就在工作中，Drawable 的常用方式，整理出一篇文章，会携带一些场景，如有缺漏的，可以在文末留言，本文采用精益编写，如有必要，会一直长期更新。&lt;/p&gt;
&lt;h2 id=&quot;二什么是-drawabe&quot;&gt;二、什么是 Drawabe&lt;/h2&gt;
&lt;p&gt;Drawable 实际上是一个抽象类，主要用于将一个可绘制的资源，按要求绘制成图形，显示在屏幕之上。&lt;/p&gt;
&lt;p&gt;Android 为了让开发者更方便的使用 Drawable ，提供了很多 Drawable 的实现类，并提供对应的 xml 的属性配置。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb09aa62b0f?w=585&amp;amp;h=82&amp;amp;f=jpeg&amp;amp;s=16657&quot; alt=&quot;/d-shapedefault.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时它也可以使用代码的方式实现，它们的效果是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0a1ed9d25?w=598&amp;amp;h=95&amp;amp;f=jpeg&amp;amp;s=25431&quot; alt=&quot;/d-shapecode.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，不管是使用 xml 资源的方式，还是直接在逻辑中硬编码的方式，它们最终显示的效果都是一样的，如下图，一个蓝色的方块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb09a9dcfbe?w=1049&amp;amp;h=404&amp;amp;f=jpeg&amp;amp;s=20840&quot; alt=&quot;/d-shapeimage.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Android 中，为我们提供了非常多默认的 Drawable，正常来说，一般是足够我们使用的，它们的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb09ab964e3?w=620&amp;amp;h=479&amp;amp;f=jpeg&amp;amp;s=77013&quot; alt=&quot;/d-normal.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上，从 XxxDrawable 这种类名，就可以看出来它对应的 Xml 资源的命名，唯一需要注意的是&lt;/p&gt;
&lt;h2 id=&quot;三drawable-的常用实现&quot;&gt;三、Drawable 的常用实现&lt;/h2&gt;
&lt;h3 id=&quot;圆角的按钮&quot;&gt;3.1 圆角的按钮&lt;/h3&gt;
&lt;p&gt;有些 App 中，按钮的圆角，如果背景只是一个纯色或者是简单的规则渐变，是可以使用&lt;/p&gt;
&lt;p&gt;如果想要为其增加一个圆角，可以在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb09fe24285?w=583&amp;amp;h=107&amp;amp;f=jpeg&amp;amp;s=19864&quot; alt=&quot;/d-shapecornes.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0bd798536?w=1070&amp;amp;h=419&amp;amp;f=jpeg&amp;amp;s=21908&quot; alt=&quot;/d-shapecornesimg.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;带边框的圆角按钮&quot;&gt;3.2 带边框的圆角按钮&lt;/h3&gt;
&lt;p&gt;想在圆角的&lt;/p&gt;
&lt;p&gt;stroke 用于设置边框，可以指定颜色和边框的宽度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0bd828a6c?w=575&amp;amp;h=118&amp;amp;f=jpeg&amp;amp;s=24621&quot; alt=&quot;/d-strokexml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里指定了一个黄色的边框，效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0bd5bb205?w=1040&amp;amp;h=414&amp;amp;f=jpeg&amp;amp;s=22599&quot; alt=&quot;/d-strokeimage.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;单边边框&quot;&gt;3.3 单边边框&lt;/h3&gt;
&lt;p&gt;在&lt;/p&gt;
&lt;p&gt;这个时候，就可以使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0bf819886?w=632&amp;amp;h=247&amp;amp;f=jpeg&amp;amp;s=32482&quot; alt=&quot;bottom-line&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的一个 Drawable，如果作为背景的话，显示效果就是在白色背景下，有一条 1px 的灰线。当然其他方向可以参考这个方案，截图发现 1px 的线不太明显，这里就不放图了。&lt;/p&gt;
&lt;h3 id=&quot;渐变的背景色&quot;&gt;3.4 渐变的背景色&lt;/h3&gt;
&lt;p&gt;例如一些视频 App 的 UI 设计，会将视频名称直接布局在视频海报上，就可以使用线性渐变的&lt;/p&gt;
&lt;p&gt;例如一般的视频App ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0bf90b4ec?w=673&amp;amp;h=304&amp;amp;f=jpeg&amp;amp;s=49915&quot; alt=&quot;/d-tengxun.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到其实海报下面的文字，底部是有一个渐变的背景色的。&lt;/p&gt;
&lt;p&gt;这种渐变的效果，可以使用 &lt;code&gt;gradient&lt;/code&gt; 标签来设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0d05c5c41?w=595&amp;amp;h=219&amp;amp;f=jpeg&amp;amp;s=30368&quot; alt=&quot;/d-gradientxml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradient&lt;/code&gt; 支持的属性，基本上看名称就可以知道意思，唯一需要注意的是 &lt;code&gt;android:angle&lt;/code&gt; 这个属性，用于设定渐变的角度，但是它不是任何值都支持的，只支持 45 的倍数。&lt;/p&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0dce5bf01?w=1048&amp;amp;h=425&amp;amp;f=jpeg&amp;amp;s=19125&quot; alt=&quot;/d-gradientimage.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;海报的默认图&quot;&gt;3.5 海报的默认图&lt;/h3&gt;
&lt;p&gt;通常在图片加载的过程中，会为其定义一个默认图片。一般的设计都是会将这个默认图做的非常的简洁，例如中间一个 App 主题的 Icon，然后其它地方纯色铺平。&lt;/p&gt;
&lt;p&gt;类似下面这种效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0df39e189?w=404&amp;amp;h=195&amp;amp;f=jpeg&amp;amp;s=8806&quot; alt=&quot;/d-aqiyi.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种默认的图片，当然你可以使用一张等大的图，但是这样不利于适配，不同的 UI 设计尺寸，你需要提供不同的图片。当然你也可以使用 9patch 的图片，但是你会发现有些 density 为 2.75 这种奇葩的手机下，图标会微微偏移，不在正中间。所以这里可以使用一个&lt;/p&gt;
&lt;p&gt;所以这样的场景下，我们就需要一个纯色的背景加一张小图，即可实现默认图的效果。&lt;/p&gt;
&lt;p&gt;下面是 xml 的实现代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0e0e9d6ea?w=767&amp;amp;h=228&amp;amp;f=jpeg&amp;amp;s=37502&quot; alt=&quot;/d-layerxml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是运行后的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0dee67328?w=1022&amp;amp;h=401&amp;amp;f=jpeg&amp;amp;s=6261&quot; alt=&quot;/d-layerimage.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;带按下效果的按钮&quot;&gt;3.6 带按下效果的按钮&lt;/h3&gt;
&lt;p&gt;对一个按钮，设计一个按下的效果。可以使用&lt;/p&gt;
&lt;p&gt;这些不同的状态，在 xml 里，都是以 android:state_Xxx 开头来定义的，将其设置为 true 即可生效。&lt;/p&gt;
&lt;p&gt;Android 为我们提供了非常多的状态，比较常用的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;state_pressed：按下的效果。&lt;/li&gt;
&lt;li&gt;state_checkable:是否可设置 checked 状态的效果。&lt;/li&gt;
&lt;li&gt;state_selected：支持 selected 并且当前处于 selected 的效果。&lt;/li&gt;
&lt;li&gt;state_checked：支持 checkeable 并且当前处于 checked 的效果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来让我们看一个实际的按钮例子，这里只为其设置按下的效果，xml 代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0e1970046?w=621&amp;amp;h=291&amp;amp;f=jpeg&amp;amp;s=35746&quot; alt=&quot;/d-pressxml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0f93552a8?w=398&amp;amp;h=213&amp;amp;f=jpeg&amp;amp;s=8159&quot; alt=&quot;/d-pressDemo.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一个带按下效果的圆角按钮&quot;&gt;3.7 一个带按下效果的圆角按钮&lt;/h3&gt;
&lt;p&gt;这个没啥好说的，结合上面的效果就可以做到。你可以选择将它们写在不同的 Drawable 中，也可以在一个 xml 文件中，使用不同 item 来完成。Item 标签是可以支持内部再嵌套一个 Drawable 的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0fb4475fb?w=656&amp;amp;h=323&amp;amp;f=jpeg&amp;amp;s=42532&quot; alt=&quot;/d-cornespress.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;带按下动画&quot;&gt;3.8 带按下动画&lt;/h3&gt;
&lt;p&gt;按下效果除了使用&lt;/p&gt;
&lt;p&gt;具体细节可以看看我之前的一篇文章：《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247484963&amp;amp;idx=1&amp;amp;sn=620b6d0da02efc4e163503a0db651f4c&amp;amp;chksm=97851f02a0f296144a90ec4df052ff5a2c9da42fdab65f53b144475a9ebaf668f6d4548c0d09#rd&quot;&gt;利用 StateListAnimator 为你的点击加个动画吧！&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;StateListAnimtor 使用起来非常的简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 res 中创建一个 animator 目录。&lt;/li&gt;
&lt;li&gt;在其中创建一个 xml 资源文件，就是一个 &lt;/li&gt;
&lt;li&gt;在 xml 资源中使用 &lt;/li&gt;
&lt;li&gt;最终将定义好的 animtor 通过 View 的 &lt;code&gt;setStateListAnimator()&lt;/code&gt; 方法或者 &lt;code&gt;android:stateListAnimator&lt;/code&gt; 属性，设置到 View 上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子。&lt;/p&gt;
&lt;p&gt;首先在 /res/animtor 目录下，创建一个 &lt;code&gt;btn_press_animator.xml&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb0fcd4c7a1?w=1404&amp;amp;h=1566&amp;amp;f=jpeg&amp;amp;s=303187&quot; alt=&quot;animator-xml&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，和 StateListDrawable 一样，它也是通过 &lt;code&gt;android:state_xxx&lt;/code&gt; 属性来定义不同的 Animator 的，如果存在多个 Animator ，可以使用&lt;/p&gt;
&lt;p&gt;然后，定义一个 View，为其设置属性 &lt;code&gt;android:stateListAnimator=&quot;@animator/btn_press_animator&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来看看运行的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efe792f463ea?w=223&amp;amp;h=232&amp;amp;f=gif&amp;amp;s=49051&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三角形的-drawable&quot;&gt;3.9 三角形的 Drawable&lt;/h3&gt;
&lt;p&gt;假如有类似气泡提示的效果，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb1007229a3?w=339&amp;amp;h=193&amp;amp;f=jpeg&amp;amp;s=5807&quot; alt=&quot;qipao&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的效果，除了使用 9patch 来实现之外，还可以拿两个 Drawable 来拼接实现，这就需要一个圆角的矩形和一个三角的 Drawable。&lt;/p&gt;
&lt;p&gt;三角 Drawable 的实现思路很清奇，是使用一个矩形的 shape ，通过使用 rotate 实现的旋转，来达到尖角的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb123f48097?w=590&amp;amp;h=219&amp;amp;f=jpeg&amp;amp;s=32498&quot; alt=&quot;daosanjiao&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子，就是上图的实现效果，是一个黄色的倒三角。如果想要的是一个正三角，只需要改变旋转的角度就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb10dfba0c7?w=566&amp;amp;h=212&amp;amp;f=jpeg&amp;amp;s=30682&quot; alt=&quot;zhensanjiao&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;tint-着色的-drawable&quot;&gt;3.10 Tint 着色的 Drawable&lt;/h3&gt;
&lt;p&gt;在 Drawable 中，如果使用的是 BitmapDrawable 或者 NinePatchDrawable(9patch) 的资源的话，可以使用 android:tint 属性为其着色。&lt;/p&gt;
&lt;p&gt;默认情况下，待着色的图片资源，会将其所有有颜色地方，都着色成我们指定的颜色，但是会保留透明度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb123d3e7f8?w=587&amp;amp;h=114&amp;amp;f=jpeg&amp;amp;s=18280&quot; alt=&quot;/d-tintxml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果图如下，上面是原图，下面是使用 tint 之后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb123f01b7a?w=393&amp;amp;h=485&amp;amp;f=jpeg&amp;amp;s=12533&quot; alt=&quot;/d-tintimage.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面这里给的是 tint 默认的效果，还可以通过 android:tintMode 指定成不同的着色效果，例如下面将 android:tintMode 指定成 screen 之后，效果就完全不一样了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb12b35fb29?w=381&amp;amp;h=496&amp;amp;f=jpeg&amp;amp;s=14524&quot; alt=&quot;/d-tintimage1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;铺平的-drawable&quot;&gt;3.11 铺平的 Drawable&lt;/h3&gt;
&lt;p&gt;有时候，作为一些有规则的图片的背景，可以使用一张很小的图片，然后设定 android:tileMode 属性，为其设定一个平铺的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb12b409a9d?w=591&amp;amp;h=117&amp;amp;f=jpeg&amp;amp;s=18909&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tileMode 可以指定多个属性值，用于指定不同的效果，以下就是两个比较常用的，上图使用的是 repeat ，下图使用的是 mirror。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb15306fe9d?w=240&amp;amp;h=340&amp;amp;f=jpeg&amp;amp;s=10740&quot; alt=&quot;/d-tileimage.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;状态可控的层级-drawable&quot;&gt;3.12 状态可控的层级 Drawable&lt;/h3&gt;
&lt;p&gt;如果想要一个 ImageView 上，根据不同的条件显示不同的 Drawable ，可以使用&lt;/p&gt;
&lt;p&gt;今天举一个例子，给某个图标加红点的逻辑。当然我们也可以使用通过一个 FrameLayout 来实现，但是今天我们试试用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb1307a931a?w=826&amp;amp;h=327&amp;amp;f=jpeg&amp;amp;s=62968&quot; alt=&quot;red-point&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用一个&lt;/p&gt;
&lt;p&gt;最终我们可以通过 ImageView 的 &lt;code&gt;setImageLevel()&lt;/code&gt; 方法来控制显示的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/7/1602efb154bcf071?w=125&amp;amp;h=77&amp;amp;f=jpeg&amp;amp;s=1773&quot; alt=&quot;d-red-demo&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四结语&quot;&gt;四、结语&lt;/h2&gt;
&lt;p&gt;到这里基本上涵盖了 Drawable 大部分的使用场景，在实际例子中学东西是印象最深刻的。当然，Drawable 的使用不止这些，还有一些例如拿 ClipDrawable 来实现一个切割进度的效果之类的，这种还需要写逻辑代码，就不在本文的范围内了，本文主要介绍一些静态能实现的效果。&lt;/p&gt;
&lt;p&gt;你只需要掌握最基本的规则，什么 Drawable 能实现什么效果，具体碰到实际需求的时候，再来细致的研究，基本上微调一下就可以使用。&lt;/p&gt;
&lt;p&gt;如果你还又什么更有意思的 Drawable 使用技巧，欢迎在文末留言，我们一起讨论一下，如有需要，会持续更新。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今天在&lt;strong&gt;承香墨影&lt;/strong&gt;公众号的后台，回复『&lt;strong&gt;成长&lt;/strong&gt;』。我会送你一些我整理的学习资料，包含：Android反编译、算法、设计模式、虚拟机、Linux、Kotlin、Python、爬虫、Web项目源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/11/13/15fb3c95b1f1f263?w=600&amp;amp;h=600&amp;amp;f=jpeg&amp;amp;s=54770&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Dec 2017 06:44:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/8005297.html</dc:identifier>
</item>
<item>
<title>golang关于一些新手不注意会出现的小问题 - 锁千秋</title>
<link>http://www.cnblogs.com/turnswing/p/7999992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/turnswing/p/7999992.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在整理之前写程序，学习时所记录的有道云笔记，发现一些有意思的小点跟大家分享一下。如有错误请大家给指出&lt;/p&gt;
&lt;h2&gt;一、闭包 defer&lt;/h2&gt;
&lt;p&gt;闭包（匿名函数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func test(){
    i, n :&lt;/span&gt;= &lt;span&gt;1&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;span&gt;defer&lt;/span&gt; func(a &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;){
        fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;defer:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a , n); //n被闭包引用
    }(i) //复制i的值
    i , n &lt;/span&gt;= i+&lt;span&gt;1&lt;/span&gt;,n+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    fmt.Println(i , n);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看一下结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 4&lt;br/&gt;defer: 1 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会这样？是因为闭包复制的是&lt;strong&gt;原对象指针&lt;/strong&gt;，出现了延迟引用现象。我们在使用闭包的时候要注意这个问题，同样在for 循环中 也会出现类似现象。&lt;/p&gt;
&lt;h2&gt; 二、Map&lt;/h2&gt;
&lt;p&gt;前一段时间在论坛看到一个问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Data struct{
    AABB [2]float64
}

var m map[string]Data = make(map[string]Data,1)

m[&quot;xxx&quot;] = Data{}

m[&quot;xxx&quot;].AABB[0]=1.0
m[&quot;xxx&quot;].AABB[1]=2.0&lt;br/&gt;#以上代码go build 通不过，错误提示cannot assign to m[&quot;xxx&quot;].AABB[0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个网友给出的答案&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Data struct{
    AABB [2]float64
}

m := make(map[string]*Data,1)
m[&quot;xxxx&quot;] = Data{}
m[&quot;xxxx&quot;].AABB[0] = 1.0 
m[&quot;xxxx&quot;].AABB[1] = 2.0 
#这样写就对了，你的 m[&quot;xxxx&quot;] 返回的是值，不是一个可取地址的变量
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个网友的答案可以编译成功，但是不可取，他犯了很多新手都容易出现的问题&lt;/p&gt;
&lt;blockquote readability=&quot;7.360824742268&quot;&gt;
&lt;p&gt;why？Golang中的map元素属性被设计为只读的，并不期望被修改，并且从 map 中取回的是一个value也是临时复制品。并且map是一个hash 结构，当hash扩容时，键值的存储位置就会发生改变。如果这个时候我们对 m[&quot;xxxx&quot;].AABB[0] = 1.0 修改，不知道指针会发什么。大家有兴趣可以看看&lt;a href=&quot;https://ninokop.github.io/2017/10/24/Go-Hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0/&quot; target=&quot;_blank&quot;&gt;Go Hashmap内存布局和实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 如果我们想修改最好这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Data struct{
    AABB [2]float64
}

m := make(map[string]*Data,1)
m[&quot;xxxx&quot;] = &amp;amp;Data{}
d ：= m[&quot;xxxx&quot;]
d.AABB[0] = 1.0 
d.AABB[1] = 2.0 
m[&quot;xxxx&quot;] = d
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、nil&lt;/h2&gt;
&lt;p&gt;先看一段代码，当然这种场景不常见，但是能让我们更好的理解nil&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func t(){
        var i *int = nil;
        var n interface{}  = i;
        fmt.Println(n==nil); //false 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可能很多小伙伴都会有疑问都是nil 为啥会不相等。我们先分别看一下pointer，interface的结构体和当pointer，interface为nil时的结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
uintptr 
type interfaceStruct struct {
　　v *_value // 实际值
　　t *_type // 实际值的类型信息 
}
uintptr(0) == nil
type interfaceStruct struct {
　　v:uintptr(0)
　　t:uintptr(0)
} == nil
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由此我们可以看出nil其实就是指针 interface的零值&lt;/p&gt;
&lt;p&gt;这时候我们在来解释为啥为flase就很容易了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func t(){
        var i *int = nil;    // (*int)nil
        var n interface{}  = i; //  interace{}((*int)nil)
        fmt.Println(n==nil); // type interfaceStruct struct {
　　　　　　　　　　　　　 　　   //     v: uintptr(0),
　　　　　　　　　　　　　 　　   //     t: (*int)
　　　　　　　　　　　　　 　　   // }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;官方文档规定可以为nil的类型还有 slice ，map ，channel ，function 。&lt;/p&gt;
&lt;p&gt;可能有些朋友可能会问为啥没有error类型，那是因为error 只是程序预设的接口方法， err nil 也会出现类似的问题，官方有一个文档也给出了解释，&lt;a href=&quot;https://golang.org/doc/faq#nil_error&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:false;&quot;&gt;
type error interface { 
    Error() string 
}　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;感谢阅读，欢迎提供建议&lt;/p&gt;

</description>
<pubDate>Fri, 08 Dec 2017 06:36:00 +0000</pubDate>
<dc:creator>锁千秋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/turnswing/p/7999992.html</dc:identifier>
</item>
</channel>
</rss>