<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>计算机基础与操作系统 - 马一特</title>
<link>http://www.cnblogs.com/mayite/p/9972720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayite/p/9972720.html</guid>
<description>[unable to retrieve full-text content]第一章：计算机系统简介 第二章：计算机基础知识 第三章：计算机的发展史及多道技术 第四章：计算机网络知识简单介绍 第五章：Windows系统，Mac系统与Linux系统的的安装与简介 第六章：服务器硬件基础 第七章：Linux发展史 第八章：Linux服务器远程登录 第九章：Linux常用的150个</description>
<pubDate>Fri, 16 Nov 2018 17:26:00 +0000</pubDate>
<dc:creator>马一特</dc:creator>
<og:description>第一章：计算机系统简介 第二章：计算机基础知识 第三章：计算机的发展史及多道技术 第四章：计算机网络知识简单介绍 第五章：Windows系统，Mac系统与Linux系统的的安装与简介 第六章：服务器硬</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayite/p/9972720.html</dc:identifier>
</item>
<item>
<title>xamarin forms中的Button文本默认大写 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/9972579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/9972579.html</guid>
<description>&lt;h4 id=&quot;问题来源&quot;&gt;问题来源&lt;/h4&gt;
&lt;p&gt;使用xamarin forms创建的android项目中，Button、Toolbar的右侧菜单按钮上的如果是字母的话，在android5.0以上，默认的文本都是大写，这种情况iOS项目不存在，是正常的显示。google公司把android的按钮文本默认大写，这个肯定和英语国家阅读习惯有关，但是iOS却是正常显示，有点难以解释google为什么将android的按钮文本默认成大写。问题如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201811/1220420-20181117004658556-335989222.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;
&lt;p&gt;其实这个问题的产生的原因还是因为 在5.0中在Button使用的Theme是这个，默认已经textAllCaps改为true了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;style name=&quot;TextAppearance.Material.Button&quot;&amp;gt;
      &amp;lt;item name=&quot;textSize&quot;&amp;gt;@dimen/text_size_button_material&amp;lt;/item&amp;gt;
      &amp;lt;item name=&quot;fontFamily&quot;&amp;gt;@string/font_family_button_material&amp;lt;/item&amp;gt;
      &amp;lt;item name=&quot;textAllCaps&quot;&amp;gt;true&amp;lt;/item&amp;gt;
      &amp;lt;item name=&quot;textColor&quot;&amp;gt;?attr/textColorPrimary&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在android中我们只需要将按钮的属性textAllCaps都改为false就可以了，最好还是全局设置这个属性，直接在Activity的Theme中去设置就行了。&lt;br/&gt;那在xamarin forms中如何解决呢？&lt;/p&gt;
&lt;h4 id=&quot;解决方法&quot;&gt;解决方法&lt;/h4&gt;
&lt;p&gt;Button 和Toolbar的按钮文本都是默认的大写，问题的解决方式有两种，第一种是直接android项目中的MainActivity的Theme中去全局添加样式，&lt;br/&gt;第二种方式在xamarin forms中使用Render这些UI，不管哪种方式都能解决，个人推荐既然要改变这种默认样式，还是直接在全局Theme中去设置样式吧。&lt;/p&gt;
&lt;h5 id=&quot;android-mainactivity的theme修改样式textallcaps&quot;&gt;1.android MainActivity的Theme修改样式textAllCaps&lt;/h5&gt;
&lt;p&gt;这个新建的xamarin forms项目中的android项目的默认的Theme，添加样式最后一行，这样可以修改Button和Toolbar的按钮文本默认大写，但是.......有个小问题，TabLayout的标题文本还是会默认大写，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;style name=&quot;MainTheme&quot; parent=&quot;MainTheme.Base&quot;&amp;gt;
  &amp;lt;/style&amp;gt;
  &amp;lt;!-- Base theme applied no matter what API --&amp;gt;
  &amp;lt;style name=&quot;MainTheme.Base&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&amp;gt;
    &amp;lt;!--If you are using revision 22.1 please use just windowNoTitle. Without android:--&amp;gt;
    &amp;lt;item name=&quot;windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;!--We will be using the toolbar so no need to show ActionBar--&amp;gt;
    &amp;lt;item name=&quot;windowActionBar&quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;!-- Set theme colors from http://www.google.com/design/spec/style/color.html#color-color-palette --&amp;gt;
    &amp;lt;!-- colorPrimary is used for the default action bar background --&amp;gt;
    &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;#2196F3&amp;lt;/item&amp;gt;
    &amp;lt;!-- colorPrimaryDark is used for the status bar --&amp;gt;
    &amp;lt;item name=&quot;colorPrimaryDark&quot;&amp;gt;#1976D2&amp;lt;/item&amp;gt;
    &amp;lt;!-- colorAccent is used as the default value for colorControlActivated
         which is used to tint widgets --&amp;gt;
    &amp;lt;item name=&quot;colorAccent&quot;&amp;gt;#FF4081&amp;lt;/item&amp;gt;
    &amp;lt;!-- You can also set colorControlNormal, colorControlActivated
         colorControlHighlight and colorSwitchThumbNormal. --&amp;gt;
    &amp;lt;item name=&quot;windowActionModeOverlay&quot;&amp;gt;true&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;android:datePickerDialogTheme&quot;&amp;gt;@style/AppCompatDialogStyle&amp;lt;/item&amp;gt;
    &amp;lt;item name=&quot;textAllCaps&quot;&amp;gt;false&amp;lt;/item&amp;gt;
  &amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用render-button-设置属性textallcaps&quot;&gt;2.使用Render Button 设置属性textAllCaps&lt;/h5&gt;
&lt;p&gt;Render的目的就是自定义各平台的UI展现，相关的介绍如下：&lt;br/&gt;https://docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/custom-renderer/renderers&lt;br/&gt;render button的步骤如下：&lt;br/&gt;&lt;strong&gt;step1&lt;/strong&gt;：在forms的.net standard 项目中添加MyButton.cs ,继承xamarin forms 的Button。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Xamarin.Forms;

namespace DefaultUpperSample
{
    public class MyButton:Button
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt; 在android项目新建MyButtonRender.cs,修改默认属性。&lt;br/&gt;继承ViewRenderer时一定要重写OnElementChanged方法，这个方法的作用是创建UI元素，会在UI初始化时调用。注意命名空间上的特性定义，iOS平台上不需要处理，就不用去处理。&lt;br/&gt;[assembly: ExportRenderer(typeof(DefaultUpperSample.MyButton), typeof(DefaultUpperSample.Droid.MyButtonRender))]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[assembly: ExportRenderer(typeof(ButtonTextDefaultUpperSample.MyButton), typeof(ButtonTextDefaultUpperSample.Droid.MyButtonRender))]

namespace DefaultUpperSample.Droid
{
    public class MyButtonRender:ButtonRenderer
    {
        protected override void OnElementChanged(ElementChangedEventArgs&amp;lt;Xamarin.Forms.Button&amp;gt; e)
        {
            base.OnElementChanged(e);
            if (Control == null)
            {
                SetNativeControl(new Android.Widget.Button(Context));
            }
            else
            {
                Control.SetAllCaps(false);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;step3&lt;/strong&gt; 在forms中使用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                &amp;lt;defaultuppersample:MyButton Margin=&quot;0,10,0,0&quot; Text=&quot;Learn more&quot;
                        Command=&quot;{Binding OpenWebCommand}&quot;
                        BackgroundColor=&quot;{StaticResource Primary}&quot;
                        TextColor=&quot;White&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1220420/201811/1220420-20181117005015513-1819580350.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码下载地址：&lt;br/&gt;https://download.csdn.net/download/kebi007/10790030&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;其实第一种方法直接在android里面写style更为靠谱，不用一个一个render ui，但是第一种方法会有一个问题，就是toolbar、button的文本修改样式textAllCaps可以解决默认大写的问题，但是TabLayout的标题文本却不能通过这个属性来解决，解决方式是一样的，这种文体在android中非常容易，一百度全都出来了，但是在xamarin forms中有时候总要走很多弯路。&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 16:31:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>Button 和Toolbar的按钮文本都是默认的大写，问题的解决方式有两种，第一种是直接android项目中的MainActivity的Theme中去全局添加样式， 第二种方式在xamarin f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/9972579.html</dc:identifier>
</item>
<item>
<title>Springboot中Jackson的操作 - 涅槃重生，</title>
<link>http://www.cnblogs.com/maolinjava/p/9972530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maolinjava/p/9972530.html</guid>
<description>&lt;p&gt;有一段时间没写博客了，虽然是菜鸟一枚但毕竟总要有东西记录学习的，我相信有志者事竟成。今天在工作中使用Jackson转换了一个javabean，传到测试服上之后发现日期少了一天，使用的是@JsonFormat注解。这里写了一个简单的小demo记录一下：&lt;/p&gt;
&lt;p&gt;　　表数据：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201811/1305443-20181116235658671-440221171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实体类属性：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201811/1305443-20181116235736710-1208011843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　controller层就省略掉了，就是调用dao进行数据查询。　　&lt;/p&gt;
&lt;p&gt;　　使用postman请求结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201811/1305443-20181116235900037-808008605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现时间是2018/11/15，但数据库中是2018-11-16，少了一天，原因是在进行日期格式化的时候没有加入要格式化日期的时区，中国的时区是东八区，&lt;/p&gt;
&lt;p&gt;　　需要加入timezone=&quot;GMT+8&quot;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201811/1305443-20181117000331986-365127434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次测试：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305443/201811/1305443-20181117000349004-1147381175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这次就可以了！&lt;/p&gt;
&lt;p&gt; 　　另外还有几个常用的注解：&lt;/p&gt;
&lt;p&gt;　　@JsonIgnore： 在转换的时候忽略该字段；&lt;/p&gt;
&lt;p&gt;　　@JsonProperty：将该字段的名称在转换成json格式后以该名称显示；&lt;/p&gt;
&lt;p&gt;　　@JsonIgnorePeroperty({&quot;id&quot;,&quot;name&quot;})：忽略该注解所包含的全部属性，里面的参数是一个数组，会把包含的名称的全部字段都忽略掉，包括子类；&lt;/p&gt;
&lt;p&gt;　　@JsonInclude(Include.NON_EMPTY)：在属性不为空时序列化此字段，对于字符串，即null或空字符串；&lt;/p&gt;

&lt;p&gt; 用到的暂时就这些了，欢迎各位大牛补充！&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 16:15:00 +0000</pubDate>
<dc:creator>涅槃重生，</dc:creator>
<og:description>有一段时间没写博客了，虽然是菜鸟一枚但毕竟总要有东西记录学习的，我相信有志者事竟成。今天在工作中使用Jackson转换了一个javabean，传到测试服上之后发现日期少了一天，使用的是@JsonFor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maolinjava/p/9972530.html</dc:identifier>
</item>
<item>
<title>String求求你别秀了 - 卓庆森</title>
<link>http://www.cnblogs.com/zhuoqingsen/p/String.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuoqingsen/p/String.html</guid>
<description>&lt;p&gt;　　小鲁班今年计算机专业大四了，在学校可学了不少软件开发的东西，也自学了一些JAVA的后台框架，踌躇满志，一心想着找个好单位实习。当投递了无数份简历后，终于收到了一个公司发来的面试通知，小鲁班欣喜若狂。&lt;/p&gt;
&lt;p&gt;　　到了人家单位后，前台小姐姐给了小鲁班一份笔试题目，要求在一个小时内完成，小鲁班双手接过题目后，粗略的看了一下题目，心里暗喜，嘻嘻这个还不简单。一顿操作猛如虎，做完了感觉也没什么错误。就交卷了，等待片刻后，小姐姐亲切的说需要一周内等通知哦。于是呢，小鲁班就回去耐心的等待了。可是半个月都快过去了，什么消息都没有，小鲁班就纳闷了，明明我做的挺好的呀，为什么连面试的机会都不给我。&lt;/p&gt;
&lt;p&gt;　　小鲁班于是找到了他表哥鲁班大师，把一些当时面试的题目重现了一些，并把自己对题目的理解也说了遍，鲁班大师一看他填的答案就知道为什么了，前5道题目关于String类的判断题可真是完全避开了正确答案呀，而且后边的题目也是大部分都是错了，人家当然不给你机会呀。&lt;/p&gt;
&lt;p&gt;　　小鲁班你可要虚心学习了，就拿下边最简单的一题来说，你怎么连&lt;strong&gt;==对于非基本数据类型是比较引用而不是比较值&lt;/strong&gt;的都不知道呀&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String str1 = new String(&quot;AA&quot;);
String str2 = new String(&quot;AA&quot;);
System.out.println(str1 == str2);&lt;br/&gt;这里的正确答案是false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　鲁班大师：感觉你的JAVA基础不咋地呀，你说说你在学校学习你所掌握的关于String类的知识点，你表哥今天有空帮你恶补一波吧。&lt;/p&gt;
&lt;p&gt;　　小鲁班低声的说到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;String类有如下这些特点&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。&lt;/li&gt;
&lt;li&gt;String类其实是通过char数组来保存字符串的。&lt;/li&gt;
&lt;li&gt;String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　鲁班大师：嗯，不错嘛，那有没有深入一点的理解呢，比如关于字符串常量池&lt;/p&gt;
&lt;p&gt;　　小鲁班：这个我~~忘记了！&lt;/p&gt;
&lt;p&gt;　　鲁班大师：没关系，那你得认真听讲了&lt;/p&gt;
&lt;p&gt;　　小鲁班：em&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;字符串常量池&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。&lt;/li&gt;
&lt;li&gt;字符串池的出现避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　String a=&quot;AA&quot;;&lt;/p&gt;
&lt;p&gt;　　String b=&quot;AA&quot;;&lt;/p&gt;
&lt;p&gt;　　String c=new String(&quot;AA&quot;);&lt;/p&gt;
&lt;p&gt;　　a、b和字面上的AA都是指向JVM字符串常量池中的&quot;AA&quot;对象，他们指向同一个对象。&lt;/p&gt;
&lt;p&gt;　　new关键字一定会产生一个对象AA，同时这个对象是存储在堆中。所以上面这一句应该产生了两个对象：保存在方法区中字符串常量池的AA和保存堆中AA。但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的AA应该是引用字符串常量池中AA。所以c、堆AA、池AA的关系应该是：c---&amp;gt;堆AA---&amp;gt;池AA。&lt;/p&gt;
&lt;p&gt;　　虽然a、b、c、c是不同的引用，但是从String的内部结构我们是可以理解上面的。String c = new String(&quot;AA&quot;);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的AA的value，它构造AA时所用的参数依然是AA字符串常量。所以a==b是ture,因为内存地址是一样的 a==c是false，因为c的内存地址是在堆中new的是新的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1294463/201803/1294463-20180316231823442-1674977289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　鲁班大师又问了：我看你还挺懵的，你知道==和equals吗&lt;/p&gt;
&lt;p&gt;　　小鲁班：这个我知道。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;对于==，如果&lt;strong&gt;作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），&lt;/strong&gt;&lt;strong&gt;则直接比较其存储的&quot;值&quot;是否相等&lt;/strong&gt;；如果&lt;strong&gt;作用于引用类型的变量（String），则比较的是所指向的对象的地址&lt;/strong&gt;（即是否指向同一个对象）。&lt;/li&gt;
&lt;li&gt;对于equals方法，注意：&lt;strong&gt;equals方法不能作用于基本数据类型的变量&lt;/strong&gt;。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来&lt;strong&gt;比较指向的字符串对象所存储的字符串是否相等&lt;/strong&gt;。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　鲁班大师：嗯，答的不错，但是要应付一些面试题，你还要知道这些。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单独使用&quot;&quot;引号创建的字符串都是常量,编译期就已经确定存储到String Pool中；&lt;/li&gt;
&lt;li&gt;使用new String(&quot;&quot;)创建的对象会存储到heap中,是运行期新创建的；&lt;/li&gt;
&lt;li&gt;使用只包含常量的字符串连接符如&quot;aa&quot; + &quot;aa&quot;创建的也是常量,编译期就能确定,已经确定存储到String Pool中；&lt;/li&gt;
&lt;li&gt;使用包含变量(引用)的字符串连接符如&quot;aa&quot; + s1创建的对象是运行期才创建的,存储在heap中；&lt;/li&gt;
&lt;li&gt;但是如果s1是被final修饰的话，则s1是属于常量。结果存在String Pool，但是 final修饰的是一个方法返回的值也是在编译器确定。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　好了，这些你都知道了，那你把刚那份题目在做一些看看&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String str1 = &quot;aaa&quot;;
String str2 = &quot;aaa&quot;;
System.out.println(str1 == str2);// true 因为String有常量池

String str3 = new String(&quot;aaa&quot;);
String str4 = new String(&quot;aaa&quot;);
System.out.println(str3 == str4);// false 可以看出用new的方式是生成不同的对象,比较堆上的
                
String s0=&quot;helloworld&quot;;  
String s1=&quot;helloworld&quot;;  
String s2=&quot;hello&quot;+&quot;world&quot;;  
System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象   
System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象   
            
String st0=&quot;helloworld&quot;;   
String st1=new String(&quot;helloworld&quot;);   
String st2=&quot;hello&quot; + new String(&quot;world&quot;);   
System.out.println( st0==st1 ); //false    用new String() 创建的字符串不是常量，不能在编译期就确定
System.out.println( st0==st2 ); //false   st2地址存在堆中，不可能相同
System.out.println( st1==st2 ); //false  
            
            
String stri1=&quot;abc&quot;;     
String stri2=&quot;def&quot;;     
String stri3=stri1+stri2;  
System.out.println(stri3==&quot;abcdef&quot;); //false    变量相+是在的堆内存中创建
            
String strin0 = &quot;a1&quot;;   
String strin1 = &quot;a&quot; + 1;   //这种不是变量，是常量
System.out.println((strin0 == strin1)); //result = true    

String strin2 = &quot;atrue&quot;;   
String strin3= &quot;a&quot; + &quot;true&quot;;   
System.out.println((strin2 == strin3)); //result = true    

String strin4 = &quot;a3.4&quot;;   
String strin5 = &quot;a&quot; + 3.4;   
System.out.println((strin4 == strin5)); //result = true  
            
            
String string0 = &quot;ab&quot;;   
String string1 = &quot;b&quot;;   
String string2 = &quot;a&quot; + string1;   
System.out.println((string0 == string2)); //result = false  在字符串的&quot;+&quot;连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的
            
            
String test=&quot;javalanguagespecification&quot;;  
String test2=&quot;java&quot;;  
String test3=&quot;language&quot;;  
String test4=&quot;specification&quot;;      
System.out.println(test == &quot;java&quot; + &quot;language&quot; + &quot;specification&quot;);  //true 字符串字面量拼接操作是在Java编译器编译期间就执行了
System.out.println(test == test2 + test3 + test4);  //false  字符串引用的&quot;+&quot;运算是在Java运行期间执行的
            
            
String ss0 = &quot;ab&quot;;   
final String ss1 = &quot;b&quot;;   
String ss2 = &quot;a&quot; + ss1;           
System.out.println((ss0 == ss2)); //result = true  对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的&quot;a&quot; + s1和&quot;a&quot; + &quot;b&quot;效果是一样的
            
String ss10 = &quot;ab&quot;;   
final String ss11 = getS1();   
String ss12 = &quot;a&quot; + ss11;         
System.out.println((ss10 == ss12)); //result = false   这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定
        
public static String getS1(){
         return &quot;b&quot;;     
}               
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　鲁班大师：优秀呀，小鲁班！不过呢我们既然都研究了String，那么关于StringBuffer和StringBuilder也得知道，给你布置个作业，把他们3者的区别写一下自己的简介，发到我的邮件，今天就到此为止了。&lt;/p&gt;
&lt;p&gt;　　小鲁班：谢谢表哥，我一定好好整理的&lt;/p&gt;
&lt;p&gt;　　send to 鲁班大师@qq.com　&lt;/p&gt;
&lt;h3&gt;　　String、StringBuffer、StringBuilder的区别？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。&lt;/li&gt;
&lt;li&gt;是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的。&lt;/li&gt;
&lt;li&gt;String、StringBuilder、StringBuffer三者的执行效率如下：&lt;/li&gt;
&lt;li&gt;StringBuilder &amp;gt; StringBuffer &amp;gt; String 当然这个是相对的，不一定在所有情况下都是这样。比如String str = &quot;hello&quot;+ &quot;world&quot;的效率就比 StringBuilder st  = new 　　StringBuilder().append(&quot;hello&quot;).append(&quot;world&quot;)要高。因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：&lt;/li&gt;
&lt;li&gt;当字符串相加操作或者改动较少的情况下，建议使用 String str=&quot;hello&quot;这种形式；&lt;/li&gt;
&lt;li&gt;当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　虚心的小鲁班除了整理了这些之外，同时自己继续学习&lt;strong&gt;封装类的比较&lt;/strong&gt;，因为同样是被坑惨了呀！&lt;/p&gt;
&lt;p&gt;1.两个基本类型的只能用 ==&lt;br/&gt;2.基本型和封装型用==，封装型将会自动拆箱变为基本型后再进行比较&lt;br/&gt;3.用==来比较两个封装类的话，比较的是地址。(其中-127到127之间的Integer地址相同)&lt;br/&gt;4.至少有一个封装型的建议使用.equals。用==对基本型和封装性比较必须保证封装型不为null。如果为null则不能转化为基本型就会报错。&lt;br/&gt;5.两个封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true&lt;br/&gt;6.封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型,若类型不同返回false,若装箱后类型相同，则比较值，如果值相同，则返回true&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int a=128;
int a2=127；
Integer b=128;
Integer b2=127;
Integer c=128;
Integer c2=127;
Integer d=new Integer(a);
Integer d2=new Integer(a);

Integer b2=57;
Integer c2=57;

System.out.println(a==b);//true     

System.out.println(b==c);//false
System.out.println(b2==c2);//3true

System.out.println(a==d);//true
System.out.println(b==d);//false
System.out.println(d==d2);//false

//由强类型向弱类型转换需要强制转换，而由弱类型向强类型转换则系统自动转换。
//double 类型相比int类型是属于强类型，则由double类型的数据向int类型数据转换就需要强制转换，反之则自动转换。数据类型的强弱关系如下：byte&amp;lt;short=char&amp;lt;int&amp;lt;long&amp;lt;float&amp;lt;double,同级之间相互转换也需要强制转换。   
//对于未声明数据类型的整形，其默认类型为int型。
//在浮点类型（float/double）中，对于未声明数据类型的浮点型，默认为double型。
System.out.println(b.equals(128.0));//false
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　写完这些后小鲁班，小鲁班关了台灯，休息一下准备明天的面试~&lt;/p&gt;





</description>
<pubDate>Fri, 16 Nov 2018 16:13:00 +0000</pubDate>
<dc:creator>卓庆森</dc:creator>
<og:description>小鲁班今年计算机专业大四了，在学校可学了不少软件开发的东西，也自学了一些JAVA的后台框架，踌躇满志，一心想着找个好单位实习。当投递了无数份简历后，终于收到了一个公司发来的面试通知，小鲁班欣喜若狂。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuoqingsen/p/String.html</dc:identifier>
</item>
<item>
<title>数据降维 - jin_hao_chen</title>
<link>http://www.cnblogs.com/megachen/p/9972443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/megachen/p/9972443.html</guid>
<description>&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;PCA(主成分分析降维)&lt;/li&gt;
&lt;li&gt;相关系数降维&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;pca-降维不常用&quot;&gt;PCA 降维(不常用)&lt;/h2&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对数据进行&lt;strong&gt;&lt;em&gt;标准化&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;计算出数据的&lt;strong&gt;&lt;em&gt;相关系数矩阵&lt;/em&gt;&lt;/strong&gt;(是方阵, 维度是nxn, n是特征的数量)&lt;/li&gt;
&lt;li&gt;计算出&lt;strong&gt;&lt;em&gt;相关系数矩阵&lt;/em&gt;&lt;/strong&gt;的特征值和特征向量(虽然这里说的是向量, 但是是矩阵, 这个矩阵的每一列都是特征值或者特征向量, 是nxn), 特征值是每一个特征的特征值的集合, 但是在特征向量是每一个特征的特征向量的集合, 前者我们提到的特征值和特征向量是集合&lt;/li&gt;
&lt;li&gt;多特征值进行降序排序&lt;/li&gt;
&lt;li&gt;根据已经得到的特征值计算出贡献率和累计贡献率(主要看累计贡献率, 单单一个贡献率指的是一个主成分保存的原始特征的信息, 累计贡献率是总共保存的原始特征信息)&lt;/li&gt;
&lt;li&gt;设置信息阈值T, 一般设置为0.9, 如果大于T, 则记录下来当前的位置k(k也就是我们选择的主成分的个数, &lt;strong&gt;&lt;em&gt;主成分就是特征, 也就是一列&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;根据k选择主成分对应的特征向量&lt;/li&gt;
&lt;li&gt;将标准化之后的数据(矩阵)&lt;strong&gt;&lt;em&gt;右乘&lt;/em&gt;&lt;/strong&gt;在上一步中选择出来的特征向量(在这一步得到的矩阵就是m x new_n维度的了), 得到的就是主成分的分数, 也就是降维之后的数据集合&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;伪代码&quot;&gt;伪代码&lt;/h3&gt;
&lt;pre class=&quot;matlab&quot;&gt;
&lt;code&gt;X = load('data.xlsx', 'B1:I11');
m = size(X, 1); % m 表示样本的数量
n = size(X, 2); % n 表示特征的数量
% 数据标准化
for i = 1:m
    SX(:, i) = (X(:, i) - mean(X(:, i))) / std(X(:, i));
end

% 计算相关系数
CM = corrcoef(SX);
% V 是特征向量, D 是特征值
[V D] = eig(CM);

% 对D特征值进行降序排序, 将结果保存到DS的第一列
for i = 1:n
    DS(:, 1) = D(n + 1 - i, n + 1 - i);
end

% 计算贡献率和累计贡献率
for i = 1:n
    % 第二列为当前单个, 每一个, 主成分的贡献率
    DS(:, 2) = D(i, 1) / sum(D(:, 1));
    % 第三列为到当前主成分的累计贡献率
    DS(:, 3) = sum(D(1:i, 1)) / sum(D(:, 1));
end

% 选择主成分
T = 0.9;
for i = 1:n
    if DS(:, i) &amp;gt; T
        k = i;
        break;
    end
end

% 获取主成分对应的特征向量
for i = 1:n
    PV(:, i) = DS(:, n + 1 - i);
end

% 获取新的特征样本
X_new = SX * PV;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;相关系数降维&quot;&gt;相关系数降维&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;公式: &lt;span class=&quot;math display&quot;&gt;\[r=\sum_{j=1}^{m}{{(x_{j}-\overline{x_{j}})({y_{j}-\overline{y_{j}}})}\over{std(x_{j})std(y_{j})}}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果|r|在[0.7, 1]时表示强线性关系, 说明x和y有很紧密的线性关系&lt;/li&gt;
&lt;li&gt;如果|r|在[0.5, 0.7]时表示中线性关系&lt;/li&gt;
&lt;li&gt;如果|r|在[0.2, 0.5]时表示低线性关系&lt;/li&gt;
&lt;li&gt;如果|r|在[0, 0.2]时表示没有关系&lt;/li&gt;
&lt;li&gt;r &amp;gt; 0表示正相关, r &amp;lt; 0表示负关系&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 16 Nov 2018 15:54:00 +0000</pubDate>
<dc:creator>jin_hao_chen</dc:creator>
<og:description>数据降维 分类 + PCA(主成分分析降维) + 相关系数降维 PCA 降维(不常用) 实现思路 + 对数据进行 标准化 + 计算出数据的 相关系数矩阵 (是方阵, 维度是nxn, n是特征的数量)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/megachen/p/9972443.html</dc:identifier>
</item>
<item>
<title>.net core 实践笔记（三）--封装底层 - Grom</title>
<link>http://www.cnblogs.com/grom/p/9972377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grom/p/9972377.html</guid>
<description>&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;　　有了前面的工作，简单的架子基本搭建起来了，因为条件有限，只能先测试SqlServer的了，源码放出来，也希望有兴趣的伙伴可以一起改善，相信可以成为未来进阶架构师的第一步，自己有小项目的时候可以直接拿来修改使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;　　因为第一次在.net core搭建，经验欠缺，不足之处，欢迎批评指正。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;　　后面将增加日志记录。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;38.373983739837&quot;&gt;
&lt;p&gt;** 温馨提示：如需转载本文，请注明内容出处。**&lt;/p&gt;
&lt;p&gt;本文链接:&lt;a href=&quot;https://www.cnblogs.com/grom/p/9972377.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/grom/p/9972377.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;源码：&lt;a href=&quot;https://github.com/Grom-Li/ASP.NET-Core-WebApi&quot; target=&quot;_blank&quot;&gt;https://github.com/Grom-Li/ASP.NET-Core-WebApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;再次邀请大神们改善指点，感激不尽。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　如图，像前几篇所述，简单的搭建了三层架构，本篇重点封装底层 （WebApi.Repository）。&lt;/p&gt;
&lt;p&gt;　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116211233843-1782172457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt; 层的文件夹用于EF进行从数据库拉取实体，因为没有字段备注，故将实体类修改后拖出文件夹，以免日后更新时被覆盖掉。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116211658752-1973169735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;IDBRepository &lt;/strong&gt;接口，定义了最常用的五个数据库查询接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116212017668-1236341443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DBRepository &lt;/strong&gt;使用Dapper和Dapper.Contrib实现接口，同时指定实现接口的数据库类型，默认MSSQL,也可在派生类中改写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116232616564-231340875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ConnectionFactory &lt;/strong&gt;根据不同的数据库实例化Connect对象，这里因为条件有限，只写MSSQL和Mysql的，只测试了MSSQL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CONN_STRING_MSSQL、CONN_STRING_MYSQL &lt;/strong&gt;为不同数据库的连接字符串，初始化时由Setup读取配置文件后赋值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116232348110-1357317386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SQLTYPE&lt;/strong&gt; 默认数据库类型，设置后在调用ConnectionFactory.CreateSqlConnection()方法时作为缺省参数sqltype的默认值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116233031585-1679423273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;appsettings.json 配置文件，配置数据库类型、所有数据库的配置字符串&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116233306165-543094398.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;URL&lt;/strong&gt;: {Path}/api-docs/index.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;选择Management API&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116213609581-1414120394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码所有接口均已测试，这里只列举一个&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116233446531-1133551125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;注意 &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;初次编译代码需要重新制定文档路径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/913480/201811/913480-20181116233646420-698517934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次发布时需要手动复制 &lt;strong&gt;WebApi.WebApi.xml &lt;/strong&gt;文件至发布目录，后期会编写脚本将文件自动复制过去。&lt;/li&gt;
&lt;li&gt;Models下 DBContext.cd 通过EF拉取实体类会生成链接数据库的字符串，不用时最好删掉，拉取方法可查看前面的文章。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 种草&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;希望有大神帮忙扩充优化，可以成为大家开发小项目时拿过来就能用的小框架。 &lt;/span&gt;&lt;em&gt; &lt;/em&gt;=。=&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 15:53:00 +0000</pubDate>
<dc:creator>Grom</dc:creator>
<og:description>前言： 有了前面的工作，简单的架子基本搭建起来了，因为条件有限，只能先测试SqlServer的了，源码放出来，也希望有兴趣的伙伴可以一起改善，相信可以成为未来进阶架构师的第一步，自己有小项目的时候可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grom/p/9972377.html</dc:identifier>
</item>
<item>
<title>并发编程之多线程 - 伍萬</title>
<link>http://www.cnblogs.com/wanlei/p/9947474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/9947474.html</guid>
<description>&lt;p&gt;&lt;span&gt;在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线  &lt;/span&gt;&lt;span&gt;流水线的工作需要电源，电源就相当于cpu&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程（即多个控制线程）的概念是，在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启线程的两种方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1158a710-f26c-4b8b-81ef-71f26d4c57ba&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1158a710-f26c-4b8b-81ef-71f26d4c57ba&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1158a710-f26c-4b8b-81ef-71f26d4c57ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sayhi(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s say hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t&lt;/span&gt;=Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    t.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;方式一&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_af232ac6-9e46-40c3-9a80-03d5298cbbd8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_af232ac6-9e46-40c3-9a80-03d5298cbbd8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_af232ac6-9e46-40c3-9a80-03d5298cbbd8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sayhi(Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name&lt;/span&gt;=&lt;span&gt;name
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        time.sleep(&lt;/span&gt;2&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s say hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t &lt;/span&gt;= Sayhi(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    t.start()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;方式二&lt;/span&gt; &lt;/div&gt;

&lt;p&gt;&lt;span&gt;线程 和进程的区别&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;进程是一个资源单位&lt;/span&gt;，&lt;span&gt;一个进程可以包含多个线程&lt;/span&gt;，&lt;span&gt;多个线程之间数据可以共享&lt;/span&gt;，&lt;span&gt;线程开销比进程小&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在多线程中CPU的切换速度会非常快 但资源消耗没有进程高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;英文锻炼：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、Threads share the address space of the process that created it; processes have their own address space.
&lt;/span&gt;2&lt;span&gt;、Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.
&lt;/span&gt;3&lt;span&gt;、Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.
&lt;/span&gt;4&lt;span&gt;、New threads are easily created; new processes require duplication of the parent process.
&lt;/span&gt;5&lt;span&gt;、Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.
&lt;/span&gt;6、Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process does &lt;span&gt;not&lt;/span&gt; affect child processes.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_28ebe391-bbce-45e8-a74d-29a407f4d145&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28ebe391-bbce-45e8-a74d-29a407f4d145&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28ebe391-bbce-45e8-a74d-29a407f4d145&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。详细的讲分为4点：

　　&lt;/span&gt;1&lt;span&gt;. 多线程共享一个进程的地址空间

      &lt;/span&gt;2. 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-&lt;span&gt;100倍，在有大量线程需要动态和快速修改时，这一特性很有用

      &lt;/span&gt;3. 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/&lt;span&gt;O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。

      &lt;/span&gt;4. 在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python）
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;为何要用多线程&lt;/span&gt; &lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1c8d19d2-4d28-47bc-b643-e80908346ac6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1c8d19d2-4d28-47bc-b643-e80908346ac6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1c8d19d2-4d28-47bc-b643-e80908346ac6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Thread实例对象的方法
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; isAlive(): 返回线程是否活动的。&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; getName(): 返回线程名。&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; setName(): 设置线程名。&lt;/span&gt;
&lt;span&gt;
threading模块提供的一些方法：
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.currentThread(): 返回当前的线程变量。&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;介绍&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_073c8f45-c66f-4997-b9bd-35e048b11bf5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_073c8f45-c66f-4997-b9bd-35e048b11bf5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_073c8f45-c66f-4997-b9bd-35e048b11bf5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work():
    &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(threading.current_thread().getName())


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在主进程下开启线程&lt;/span&gt;
    t=Thread(target=&lt;span&gt;work)
    t.start()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(threading.current_thread().getName())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(threading.current_thread()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(threading.enumerate()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;连同主线程在内有两个运行的线程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(threading.active_count())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主线程/主进程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;验证&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_98b17bf7-ad7f-4a68-9982-8d77f8b81644&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_98b17bf7-ad7f-4a68-9982-8d77f8b81644&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_98b17bf7-ad7f-4a68-9982-8d77f8b81644&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MainThread
&lt;/span&gt;&amp;lt;_MainThread(MainThread, started 140735268892672)&amp;gt;&lt;span&gt;
[&lt;/span&gt;&amp;lt;_MainThread(MainThread, started 140735268892672)&amp;gt;, &amp;lt;Thread(Thread-1, started 123145307557888)&amp;gt;&lt;span&gt;]
主线程&lt;/span&gt;/&lt;span&gt;主进程
Thread&lt;/span&gt;-1
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;执行结果&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f6f521b1-fbc5-4fee-b5a7-79ed05315f2b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f6f521b1-fbc5-4fee-b5a7-79ed05315f2b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6f521b1-fbc5-4fee-b5a7-79ed05315f2b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sayhi(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s say hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t&lt;/span&gt;=Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    t.start()
    t.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(t.is_alive())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;主线程等待子线程结束&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_33076c88-295b-4ee7-9184-5fd43451903d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_33076c88-295b-4ee7-9184-5fd43451903d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_33076c88-295b-4ee7-9184-5fd43451903d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;egon say hello
主线程
False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;执行结果&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要强调的是：运行完毕并非终止运行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、对主进程来说，运行完毕指的是主进程代码运行完毕

&lt;/span&gt;2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_948ad02b-3f19-4e46-92e2-d439d18c2d31&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_948ad02b-3f19-4e46-92e2-d439d18c2d31&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_948ad02b-3f19-4e46-92e2-d439d18c2d31&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sayhi(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s say hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t&lt;/span&gt;=Thread(target=sayhi,args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    t.setDaemon(True) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;必须在t.start()之前设置&lt;/span&gt;
&lt;span&gt;    t.start()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(t.is_alive())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;验证&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_de1ce6c7-3ed6-40ce-9246-e9366c06c7de&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de1ce6c7-3ed6-40ce-9246-e9366c06c7de&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de1ce6c7-3ed6-40ce-9246-e9366c06c7de&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
&lt;span&gt;主线程
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;执行结果&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;什么是GIL?   &lt;/span&gt;&lt;span&gt;全局解释器锁 仅存在与Cpython&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为什么需要它?&lt;/span&gt;   &lt;span&gt;在同一时间只有一个线程在使用解释器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果程序中只有一个线程还需要吗?&lt;/span&gt;  &lt;span&gt;解释器会自己启动垃圾回收机制,也会造成解释器的竞争问题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;例如 GC发现变量x引用计数为0 正准备清扫 CPU突然切换到了另一个线程a
a拿着x进行使用 在使用的过程中 又切换到了GC GC接着把X指向的空间进行释放
这样一来a中的x就无法使用了 GIL将分配内存回收内存相关的操作加了锁
GIL无法避免自定义的线程中的数据竞争问题&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;GIL带来的问题？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;加锁虽然保证了数据的安全 但是降低了性能 在多CPU的机器上 无法利用多核提升效率
其他线程要想执行 必须等到之前的线程释放了GIL 这就意味着 同一时间只有一个线程在运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为什么不用其他解释器?&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
因为cpython是c语言实现 可以无缝对接c现有的所有库 就是很多现成的功能
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;GIL 和 自定义互斥锁的异同点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;相同点:都是互斥锁 争抢执行权是无序的 执行被锁定的代码时有序的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不同点:GIL锁的是解释器的数据 自定义互斥锁所得是用户自定义的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GIL的加锁与解锁 是自动执行的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;自动释放的时间点: io/代码执行完毕 同一线程执行时间过长3ms(py3中)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;执行的字节码指令数量达到一定值(py2中)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e9ee9437-d256-47f7-a5c7-20f741beb625&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e9ee9437-d256-47f7-a5c7-20f741beb625&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e9ee9437-d256-47f7-a5c7-20f741beb625&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,Lock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; n
    lock.acquire()
    temp&lt;/span&gt;=&lt;span&gt;n
    time.sleep(&lt;/span&gt;0.1&lt;span&gt;)
    n&lt;/span&gt;=temp-1&lt;span&gt;
    lock.release()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    lock&lt;/span&gt;=&lt;span&gt;Lock()
    n&lt;/span&gt;=100&lt;span&gt;
    l&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
        p&lt;/span&gt;=Thread(target=&lt;span&gt;work)
        l.append(p)
        p.start()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l:
        p.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(n) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全，不加锁则结果可能为99&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代码示范&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_ab885382-533b-41ff-89d8-52f8c2c3c38d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab885382-533b-41ff-89d8-52f8c2c3c38d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab885382-533b-41ff-89d8-52f8c2c3c38d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,Lock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
mutexA&lt;/span&gt;=&lt;span&gt;Lock()
mutexB&lt;/span&gt;=&lt;span&gt;Lock()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        self.func1()
        self.func2()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(self):
        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[41m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)

        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[42m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexB.release()

        mutexA.release()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(self):
        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[43m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        time.sleep(&lt;/span&gt;2&lt;span&gt;)

        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[44m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexA.release()

        mutexB.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        t&lt;/span&gt;=&lt;span&gt;MyThread()
        t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;死锁&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_c453ea70-4a8e-434c-9dc4-438f18ff5ef7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c453ea70-4a8e-434c-9dc4-438f18ff5ef7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c453ea70-4a8e-434c-9dc4-438f18ff5ef7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
Thread-1&lt;span&gt; 拿到A锁
Thread&lt;/span&gt;-1&lt;span&gt; 拿到B锁
Thread&lt;/span&gt;-1&lt;span&gt; 拿到B锁
Thread&lt;/span&gt;-2 拿到A锁 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;出现死锁，整个程序阻塞住&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;执行结果&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁，二者的区别是：递归锁可以连续acquire多次，而互斥锁只能acquire一次&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce98b152-645d-4660-859f-f88d267125dd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce98b152-645d-4660-859f-f88d267125dd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce98b152-645d-4660-859f-f88d267125dd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,RLock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

mutexA&lt;/span&gt;=mutexB=RLock() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一个线程拿到锁，counter加1,该线程内又碰到加锁的情况，则counter继续加1，这期间所有其他线程都只能等待，等待该线程释放所有锁，即counter递减到0为止&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThread(Thread):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        self.func1()
        self.func2()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1(self):
        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[41m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)

        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[42m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexB.release()

        mutexA.release()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(self):
        mutexB.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[43m%s 拿到B锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        time.sleep(&lt;/span&gt;2&lt;span&gt;)

        mutexA.acquire()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[44m%s 拿到A锁\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name)
        mutexA.release()

        mutexB.release()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        t&lt;/span&gt;=&lt;span&gt;MyThread()
        t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;同步：提交任务需要等待任务执行完成才能继续执行
异步：提交任务不需要等待任务执行 可以立即继续执行
指的都是提交任务的方式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;阻塞：遇到IO 失去了CPU执行权 看上去也是在等 与同步会混淆
非阻塞：就绪，运行，代码正常执行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;异步回调：
为什么需要回调?
子进程帮助主进程完成任务 处理任务的结果应该交还给准进程
其他方式也可以将数据交还给主进程
&lt;/span&gt;1&lt;span&gt;.shutdown 主进程会等到所有任务完成
&lt;/span&gt;2&lt;span&gt;.result函数 会阻塞直到任务完成
都会阻塞 导致效率降低 所以使用回调
注意:
回调函数什么时候被执行? 子进程任务完成时
谁在执行回调函数? 主进程
线程的异步回调
使用方式都相同 唯一的不同是执行回调函数 是子线程在执行&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;class queue.Queue(maxsize=0) #队列：先进先出&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue

q&lt;/span&gt;=&lt;span&gt;queue.Queue()
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;third&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())



&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
结果(先进先出):
first
second
third
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;class queue.LifoQueue(maxsize=0) #堆栈：last in fisrt out&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue

q&lt;/span&gt;=&lt;span&gt;queue.LifoQueue()
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;third&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())



&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
结果(后进先出):
third
second
first
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;class queue.PriorityQueue(maxsize=0) #优先级队列：存储数据时可设置优先级的队列&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue

q&lt;/span&gt;=&lt;span&gt;queue.PriorityQueue()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高&lt;/span&gt;
q.put((20,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
q.put((&lt;/span&gt;10,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
q.put((&lt;/span&gt;30,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())



&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
结果(数字越小优先级越高,优先级高的优先出队):
(10, 'b')
(20, 'a')
(30, 'c')
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_2575f8a7-86df-4b5a-853f-54836d4931a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2575f8a7-86df-4b5a-853f-54836d4931a1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2575f8a7-86df-4b5a-853f-54836d4931a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; queue
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通队列 先进先出&lt;/span&gt;
q =&lt;span&gt; queue.Queue()
q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 堆栈队列  先进后出 后进先出  函数调用就是进栈  函数结束就出栈 递归造成栈溢出&lt;/span&gt;
q2 =&lt;span&gt; queue.LifoQueue()
q2.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
q2.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q2.get())


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 优先级队列&lt;/span&gt;
q3 = queue.PriorityQueue()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数值越小优先级越高  优先级相同时 比较大小 小的先取&lt;/span&gt;
q3.put((-100,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
q3.put((&lt;/span&gt;1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
q3.put((&lt;/span&gt;100,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(q3.get())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;三种形式&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;什么是池? 一种存储数据的容器 要存储的数据是线程或进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为什么使用? 为了方便管多线程或进程 (在有很多子进程或子线程的情况下)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有什么特点:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.管理进程的创建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.管理进程的销毁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.负责任务的分配&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.控制最大并发数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;注意:用池来处理TCP 是不正确的 因为进程中代码执行完毕才算空闲&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_dbfbd703-c023-4391-a1c4-5d16d02e6738&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dbfbd703-c023-4391-a1c4-5d16d02e6738&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dbfbd703-c023-4391-a1c4-5d16d02e6738&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
1、submit(fn, *args, **&lt;span&gt;kwargs)
异步提交任务

&lt;/span&gt;2、map(func, *iterables, timeout=None, chunksize=1&lt;span&gt;) 
取代for循环submit的操作

&lt;/span&gt;3、shutdown(wait=&lt;span&gt;True) 
相当于进程池的pool.close()&lt;/span&gt;+&lt;span&gt;pool.join()操作
wait&lt;/span&gt;=&lt;span&gt;True，等待池内所有任务执行完毕回收完资源后才继续
wait&lt;/span&gt;=&lt;span&gt;False，立即返回，并不会等待池内的任务执行完毕
但不管wait参数为何值，整个程序都会等到所有任务执行完毕
submit和map必须在shutdown之前

&lt;/span&gt;4、result(timeout=&lt;span&gt;None)
取得结果

&lt;/span&gt;5&lt;span&gt;、add_done_callback(fn)
回调函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;基本使用方法&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_0afd14d3-f8ff-43c0-a6f9-655596b3c098&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0afd14d3-f8ff-43c0-a6f9-655596b3c098&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0afd14d3-f8ff-43c0-a6f9-655596b3c098&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor,ProcessPoolExecutor

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,time,random
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is runing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;os.getpid())
    time.sleep(random.randint(&lt;/span&gt;1,3&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n**2

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

    executor&lt;/span&gt;=ProcessPoolExecutor(max_workers=3&lt;span&gt;)

    futures&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(11&lt;span&gt;):
        future&lt;/span&gt;=&lt;span&gt;executor.submit(task,i)
        futures.append(future)
    executor.shutdown(True)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+++&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; future &lt;span&gt;in&lt;/span&gt;&lt;span&gt; futures:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(future.result())
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;进/线程池用法&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_7f92869c-f762-4ad5-bffb-f6230c728a05&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f92869c-f762-4ad5-bffb-f6230c728a05&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f92869c-f762-4ad5-bffb-f6230c728a05&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor,ProcessPoolExecutor

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os,time,random
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is runing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;os.getpid())
    time.sleep(random.randint(&lt;/span&gt;1,3&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n**2

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

    executor&lt;/span&gt;=ThreadPoolExecutor(max_workers=3&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; for i in range(11):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     future=executor.submit(task,i)&lt;/span&gt;
&lt;span&gt;
    executor.map(task,range(&lt;/span&gt;1,12)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;map取代了for+submit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;map用法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 回调函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以为进程池或线程池内的每个进程或线程绑定一个函数，该函数在进程或线程的任务执行完毕后自动触发，并接收任务的返回值当作参数，该函数称为回调函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_394cffd5-065e-4797-afb1-cd7ce254e0f7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_394cffd5-065e-4797-afb1-cd7ce254e0f7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_394cffd5-065e-4797-afb1-cd7ce254e0f7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor,ProcessPoolExecutor
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_page(url):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;进程%s&amp;gt; get %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(os.getpid(),url))
    respone&lt;/span&gt;=&lt;span&gt;requests.get(url)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; respone.status_code == 200&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:url,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:respone.text}

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_page(res):
    res&lt;/span&gt;=&lt;span&gt;res.result()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;进程%s&amp;gt; parse %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(os.getpid(),res[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
    parse_res&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url:&amp;lt;%s&amp;gt; size:[%s]\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(res[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],len(res[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
    with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        f.write(parse_res)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    urls&lt;/span&gt;=&lt;span&gt;[
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.python.org&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.openstack.org&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://help.github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.sina.com.cn/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ]

    p&lt;/span&gt;=ProcessPoolExecutor(3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urls:
        p.submit(get_page,url).add_done_callback(parse_page) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;view code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;信号量&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread,Semaphore,current_thread,active_count

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于控制 同时执行被锁定代码的线程数量   也就是线程的并发数量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 也是一种锁&lt;/span&gt;
sm = Semaphore(1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task():
    sm.acquire()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(current_thread())
        time.sleep(&lt;/span&gt;0.5&lt;span&gt;)
    sm.release()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task2():
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(current_thread())
        time.sleep(&lt;/span&gt;0.5&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
    Thread(target&lt;/span&gt;=&lt;span&gt;task).start()
    Thread(target&lt;/span&gt;=&lt;span&gt;task2).start()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(active_count())
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;事件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;事件是什么? &lt;/span&gt;&lt;span&gt;某件事情发生的信号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用来干什么?&lt;/span&gt; &lt;span&gt;在线程间通讯 然而线程本来就能通讯&lt;/span&gt;  &lt;span&gt;作用只有一个就是简化代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程间通讯的例子&lt;/span&gt;&lt;br/&gt;&lt;span&gt;服务器启动需要五秒&lt;/span&gt;&lt;br/&gt;&lt;span&gt;客户端启动后去连接服务器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;去连接服务器必须保证服务器已经开启成功了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是否启动完成就是要通讯的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意 Event线程通讯 仅仅用于简单的条件判断 说白了代替bool类型 和if判断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set() 将状态修改为True&lt;/span&gt;&lt;br/&gt;&lt;span&gt;wati() 等待状态为True才继续执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
boot &lt;/span&gt;=&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; server_task():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; boot
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在启动....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    time.sleep(&lt;/span&gt;5&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;启动....成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    boot &lt;/span&gt;=&lt;span&gt; True

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; client_task():
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接服务器....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; boot:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error 连接失败 服务器未启动!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

t1 &lt;/span&gt;= Thread(target=&lt;span&gt;server_task)
t1.start()

t2 &lt;/span&gt;= Thread(target=&lt;span&gt;client_task)
t2.start()

t1.join()
t2.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6cdf63ab-619c-4f1f-b1d0-fdb78821c41d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6cdf63ab-619c-4f1f-b1d0-fdb78821c41d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6cdf63ab-619c-4f1f-b1d0-fdb78821c41d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; import time&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; from threading import Thread,Event&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; event =Event()&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; def server_task():&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(&quot;正在启动....&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     time.sleep(5)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(&quot;启动....成功&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     event.set()&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; def client_task():&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     event.wait() #一个阻塞的函数  会阻塞直到对event执行set函数为止&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(&quot;连接成功!&quot;)&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; t1 = Thread(target=server_task)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; t1.start()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; t2 = Thread(target=client_task)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; t2.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;使用事件实现&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;定时器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;定时器，指定n秒后执行某个操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Timer
 
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello, world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
t &lt;/span&gt;= Timer(1&lt;span&gt;, hello)
t.start()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; after 1 seconds, &quot;hello, world&quot; will be printed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 16 Nov 2018 15:45:00 +0000</pubDate>
<dc:creator>伍萬</dc:creator>
<og:description>一、什么是线程 在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程 线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程 车间负责把资源整合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/9947474.html</dc:identifier>
</item>
<item>
<title>MYSQL数据库知识点总结 - 沸水香茶</title>
<link>http://www.cnblogs.com/bobi-PHP-blog/p/9972396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobi-PHP-blog/p/9972396.html</guid>
<description>&lt;h2&gt;一、SQL语句篇&lt;/h2&gt;
&lt;h3&gt;　　*特别说明：FILED代表数据表字段，CONDITIONS代表where之后的条件，TABLENAME代表数据表名   []中括号内的内容代表 可有可无。&lt;/h3&gt;
&lt;h4&gt;　　创建数据库&lt;/h4&gt;
&lt;p&gt;　　　　create  database  DATABASE;&lt;/p&gt;
&lt;h4&gt;　　删除数据库&lt;/h4&gt;
&lt;p&gt;　　　　drop database  DATABASE&lt;/p&gt;
&lt;h4&gt;　　创建数据表&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;create   table&lt;/strong&gt; TABLENAME(&lt;/p&gt;
&lt;p&gt;　　　　　　`id`   i&lt;strong&gt;nt   unsigned  auto_increment  primary key,&lt;/strong&gt;     //把id设置为主键，数据类型是无符号int型，自动递增       &lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　//注：unsigned 只能紧跟在数据类型 后，顺序不能乱  unsigned相当于去掉数字负数部分   例：tinyint  默认取值范围 -128到127  unsigned 后  取值范围变 0到 255 &lt;/p&gt;
&lt;p&gt;　　　　　　`userid`   int   unsigned r&lt;strong&gt;eferences&lt;/strong&gt;  FOREIGNTABLE(FOREIGNFILED),  //把userid设置为无符号整型，并设置成外键。关联主键表(FOREIGNTABLE)中的主键（FOREIGNFILED）&lt;/p&gt;
&lt;p&gt;　　　　　　`imgid`   int  unsigned  not null default 1  comment '图片ID',   //把imgid  设置成无符号整数  且不为空  默认值为1  注释说明为  “图片ID”&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;foreign key(imgid)&lt;/strong&gt;  &lt;strong&gt;references &lt;/strong&gt; FOREIGNTABLE(FOREIGNFILED)　   //设置  imgid 为外键。 关联主键表(FOREIGN_TABLE)中的主键（FOREIGN_FILED）   （下同）&lt;/p&gt;
&lt;p&gt;　　　　)&lt;strong&gt;engine&lt;/strong&gt;=MYISAM  &lt;strong&gt;default charset&lt;/strong&gt;=utf8  &lt;strong&gt;collate&lt;/strong&gt;=utf8_general_ci    //设置数据表引擎为MYISAM  ，默认字符集为utf8  且字符集排序规则为   utf8_general_ci&lt;/p&gt;
&lt;h4&gt;　　删除数据表&lt;/h4&gt;
&lt;p&gt;　　　　drop table if  exists TABLENAME;&lt;/p&gt;
&lt;h4&gt;　　添加字段&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table&lt;/strong&gt; TABLENAME   &lt;strong&gt;add  colum&lt;/strong&gt;  FIELD   DATATYPE   ATTRIBUTES    //DATATYPE   ：字段数据类型     ATTRIBUTES字段属性      &lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;eg: &lt;/strong&gt; alter table test  ADD COLUMN  ceshi varchar(50)  not null default ''  comment  '测试字段'&lt;/p&gt;
&lt;h4&gt;　　删除字段&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table&lt;/strong&gt; TABLENAME   &lt;strong&gt;drop colum&lt;/strong&gt;  FIELD ;&lt;/p&gt;
&lt;p&gt;　　　　eg:alter table test  DROP COLUMN  ceshi;&lt;/p&gt;
&lt;h4&gt;　　修改字段属性&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter&lt;/strong&gt; &lt;strong&gt;table&lt;/strong&gt;  TABENAME &lt;strong&gt;modify&lt;/strong&gt; FIELD char(10) default 0 COMMENT &quot;这是整数&quot;;&lt;/p&gt;
&lt;h4&gt;　　修改字段名称&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table&lt;/strong&gt; TABENAME  &lt;strong&gt;change&lt;/strong&gt; FIELD mytest int unsigned not null default 1;&lt;/p&gt;
&lt;h4&gt;　　添加默认值&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;eg:   alter table&lt;/strong&gt; test alter column user_id &lt;strong&gt;set default&lt;/strong&gt; 1;&lt;/p&gt;
&lt;h4&gt;　　删除默认值&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table &lt;/strong&gt;TABENAME &lt;strong&gt;alter column&lt;/strong&gt; FIELD &lt;strong&gt;drop default&lt;/strong&gt;; &lt;/p&gt;
&lt;h4&gt;　　设置主键&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table&lt;/strong&gt; TABENAME &lt;strong&gt;add primary key&lt;/strong&gt;(FIELD1  [ ,FIELD2,.. ] );    &lt;/p&gt;
&lt;h4&gt;　　删除主键&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table&lt;/strong&gt; TABLENAME &lt;strong&gt;drop primary key;   //注意：如果表里的主键是具有自增长属性的；那么直接删除是会报错的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　添加唯一索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　alter table&lt;/strong&gt; TABLENAME    &lt;strong&gt;add  constraint&lt;/strong&gt;   KEY_NAME  &lt;strong&gt;unique&lt;/strong&gt;(FIELD);   //KEY_NAME  ：索引名称  (下同)&lt;/p&gt;
&lt;h4&gt;　　添加外键索引&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter table &lt;/strong&gt;TABLENAME    &lt;strong&gt;add  constraint&lt;/strong&gt;   KEY_NAME  &lt;strong&gt;foreign&lt;/strong&gt; &lt;strong&gt;key&lt;/strong&gt;(FIELD)  &lt;strong&gt;references&lt;/strong&gt;  FOREIGN_TABLE(FOREIGN_FIELD) ;&lt;/p&gt;
&lt;h4&gt;　　删除索引（外键、唯一）&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter  table&lt;/strong&gt;  TABLENAME    &lt;strong&gt;drop  index &lt;/strong&gt;KEY_NAME&lt;/p&gt;
&lt;p&gt;　　　　或&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter  table&lt;/strong&gt;  TABLENAME    &lt;strong&gt;drop  key&lt;/strong&gt;  KEY_NAME&lt;/p&gt;
&lt;h4&gt;　　检查约束 :注意，MYSQL 目前并不支持check检查约束。可以右一下方法,设置字段为枚举值&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;eg:   alter table&lt;/strong&gt; TABENAME &lt;strong&gt;modify&lt;/strong&gt; sex &lt;strong&gt;ENUM&lt;/strong&gt;(&quot;男&quot;,&quot;女&quot;);&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;修改表的存储引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　alter table&lt;/strong&gt; TABENAME &lt;strong&gt;engine&lt;/strong&gt;=INNODB&lt;/p&gt;
&lt;h4&gt;　　修改数据表的自增长值&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;alter&lt;/strong&gt; &lt;strong&gt;table&lt;/strong&gt; TABENAME AUTO_INCREMENT=100;&lt;/p&gt;
&lt;h4&gt;　　添加数据&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;insert &lt;/strong&gt; [ into ]  TABLENAME (FIELD1，FELD2，...)  values(值1，值2，值3，...) ，(值1,值2，值3，...)，...&lt;/p&gt;
&lt;h4&gt;　　修改数据&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;update &lt;/strong&gt; TABLENAME   set FILED1=值1，FEILD2=值2，....  where   CONDITISONS&lt;/p&gt;
&lt;h4&gt;　　删除数据&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;delete  from&lt;/strong&gt;  TABLENAME    [  where  CONDITIONS ];&lt;/p&gt;
&lt;h4&gt;　　清空数据 &lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;truncate   table &lt;/strong&gt;  TABLENAME;   自增ID会重置。&lt;/p&gt;
&lt;h4&gt;　　查询数据表所有&lt;/h4&gt;
&lt;p&gt;　　　　select  &lt;strong&gt;* &lt;/strong&gt; from   TABLENAME  &lt;/p&gt;
&lt;h4&gt;　　统计查询（查询结果集中的数据条数）&lt;/h4&gt;
&lt;p&gt;　　　　select &lt;strong&gt;count&lt;/strong&gt;(FIELD)  from  TABLENAME  [ where  CONDITIONS]&lt;/p&gt;
&lt;h4&gt;　　查询某个字段的最大、最小、平均、求和的值&lt;/h4&gt;
&lt;p&gt;　　select &lt;strong&gt;max&lt;/strong&gt;(FIELD)  from TABLENAME  [where  CONDITIONS];&lt;/p&gt;
&lt;p&gt;　　select &lt;strong&gt;min&lt;/strong&gt;(FIELD)  from  TABLENAME  [where  CONDITIONS];&lt;/p&gt;
&lt;p&gt;　　select  &lt;strong&gt;avg&lt;/strong&gt;(FIELD)  from  TABLENAME  [where  CONDITIONS];&lt;/p&gt;
&lt;p&gt;　　select  &lt;strong&gt;sum&lt;/strong&gt;(FIELD)  from  TABLENAME  [where  CONDITIONS];&lt;/p&gt;
&lt;h4&gt;　　排序查询&lt;/h4&gt;
&lt;p&gt;　　select  *  from   TABLENAME  [ where CONDITIONS]   &lt;strong&gt;order by&lt;/strong&gt; FIELD ;  从小到大排&lt;/p&gt;
&lt;p&gt;　　select  *  from   TABLENAME  [ where CONDITIONS]   order by FIELD  &lt;strong&gt;desc&lt;/strong&gt;;  从大到小排&lt;/p&gt;
&lt;h4&gt;　　限制查询&lt;/h4&gt;
&lt;p&gt;　　select * from TABLENAME   [ where CONDITIONS]   [ order by FIELD ]  &lt;strong&gt;limit&lt;/strong&gt; START，NUM      //START代表数据集的开始位置，0为第一条数据的位置，依次往后为数据的位置。NUM代表限制数据集的数据条数。至少1条。&lt;/p&gt;
&lt;h4&gt;　　去重查询 &lt;/h4&gt;
&lt;p&gt;　　select &lt;strong&gt;distinct &lt;/strong&gt; FILED1,FIELD2,...  from  TABLENAME    [ where CONDITIONS]   [ order by FIELD ]  [ limit START，NUM ]   //代表FIELD1,FIELD2,....所有字段都重复时，才去除重复的数据条。&lt;/p&gt;
&lt;h4&gt;　　分组查询  (  group  by  FIELD)&lt;/h4&gt;
&lt;p&gt;　　　示例：：select name, first_letter,sum(parent_id) as &lt;strong&gt;cid&lt;/strong&gt;  from mm_city &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;where &lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;`parent_id` = 18 &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;group by&lt;/strong&gt;   &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;first_letter  &lt;strong&gt;having&lt;/strong&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;strong&gt;cid&lt;/strong&gt;&amp;gt;50   limit 0,1   //顺序不能乱。当有统计字段别名做条件时，不能用where，只能用 having。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;em&gt;　　&lt;/em&gt;模糊查询&lt;/h4&gt;
&lt;p&gt;　　　　select *  from  TABLENAME  where FIELD &lt;strong&gt;like&lt;/strong&gt;  '%值%';      //  %  代表任意多个任意字符&lt;/p&gt;
&lt;h4&gt;　　内连接查询&lt;/h4&gt;
&lt;p&gt;　　　　select  &lt;strong&gt;TABLENAME1&lt;/strong&gt;.FIELD1,TABLENAME2.FIELD2,TABLENAME3.FIELD3,...  from  &lt;strong&gt;TABLENAME1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;join &lt;/strong&gt; &lt;strong&gt;TBALENAME2 &lt;/strong&gt; &lt;strong&gt;on&lt;/strong&gt; T&lt;strong&gt;ABLENAME1.FIELD &lt;/strong&gt; = T&lt;strong&gt;ABLENAME2.FIELD&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;　　　　( &lt;strong&gt;join&lt;/strong&gt;  &lt;strong&gt;TBALENAME3 &lt;/strong&gt; &lt;strong&gt;on TABLENAME1&lt;/strong&gt;.&lt;strong&gt;FIELD&lt;/strong&gt;  = TABLENAME3.&lt;strong&gt;FIELD )  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　或   &lt;/p&gt;
&lt;p&gt;　　　　( &lt;strong&gt;join  TBALENAME3 on TABLENAME2.FIELD  = TABLENAME3.FIELD&lt;/strong&gt;  )&lt;/p&gt;
&lt;p&gt;　　　　[  where   TABLENAME1.FIELD = 值 ...  ]        //查询或作为条件的字段中，若所有表中任意两张表都有该字段，则必须要指明数据表。即在字段前用 表名连上点(.)&lt;/p&gt;
&lt;h4&gt;　　外连接&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;左联接：left join   ；查询出来的数据，若有空值，则以在left join前面的表中的数据条数为准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;em id=&quot;__mceDel&quot;&gt;select  &lt;strong&gt;TABLENAME1&lt;/strong&gt;.FIELD1,TABLENAME2.FIELD2,TABLENAME3.FIELD3,...  from  &lt;strong&gt;TABLENAME1&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;left&lt;/strong&gt; &lt;strong&gt;join &lt;/strong&gt; &lt;strong&gt;TBALENAME2 &lt;/strong&gt; &lt;strong&gt;on&lt;/strong&gt; T&lt;strong&gt;ABLENAME1.FIELD &lt;/strong&gt; = &lt;strong&gt;TABLENAME2.FIELD&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;　　　　(&lt;strong&gt;left &lt;/strong&gt; &lt;strong&gt;join&lt;/strong&gt;  &lt;strong&gt;TBALENAME3 &lt;/strong&gt; &lt;strong&gt;on TABLENAME1&lt;/strong&gt;.&lt;strong&gt;FIELD&lt;/strong&gt;  = &lt;strong&gt;TABLENAME3&lt;/strong&gt;.&lt;strong&gt;FIELD )  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　或   &lt;/p&gt;
&lt;p&gt;　　　　(&lt;strong&gt;left&lt;/strong&gt; &lt;strong&gt;join  TBALENAME3 on TABLENAME2.FIELD  = TABLENAME3.FIELD&lt;/strong&gt;  )&lt;/p&gt;
&lt;p&gt;　　　　[  where   TABLENAME1.FIELD = 值 ...  ]        //查询或作为条件的字段中，若所有表中任意两张表都有该字段，则必须要指明数据表。即在字段前用 表名连上点(.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　右联接：&lt;/strong&gt;rightjoin   ；查询出来的数据，若有空值，则以在left join后面的表中的数据条数为准&lt;/p&gt;
&lt;p&gt;　　　　&lt;em id=&quot;__mceDel&quot;&gt;select  &lt;strong&gt;TABLENAME1&lt;/strong&gt;.FIELD1,TABLENAME2.FIELD2,TABLENAME3.FIELD3,...  from  &lt;strong&gt;TABLENAME1&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;right&lt;/strong&gt; &lt;strong&gt;join &lt;/strong&gt; &lt;strong&gt;TBALENAME2 &lt;/strong&gt; &lt;strong&gt;on&lt;/strong&gt; T&lt;strong&gt;ABLENAME1.FIELD &lt;/strong&gt; = &lt;strong&gt;TABLENAME2.FIELD&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;　　　　(&lt;strong&gt;right &lt;/strong&gt;&lt;strong&gt;join&lt;/strong&gt;  &lt;strong&gt;TBALENAME3 &lt;/strong&gt; &lt;strong&gt;on TABLENAME1&lt;/strong&gt;.&lt;strong&gt;FIELD&lt;/strong&gt;  = &lt;strong&gt;TABLENAME3&lt;/strong&gt;.&lt;strong&gt;FIELD )  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　或   &lt;/p&gt;
&lt;p&gt;　　　　(&lt;strong&gt;right &lt;/strong&gt;&lt;strong&gt;join  TBALENAME3 on TABLENAME2.FIELD  = TABLENAME3.FIELD&lt;/strong&gt;  )&lt;/p&gt;
&lt;p&gt;　　　　[  where   TABLENAME1.FIELD = 值 ...  ]        //查询或作为条件的字段中，若所有表中任意两张表都有该字段，则必须要指明数据表。即在字段前用 表名连上点(.)&lt;/p&gt;
&lt;h4&gt;　　常用数据库函数&lt;/h4&gt;
&lt;p&gt;　　　　&lt;strong&gt;LENGTH&lt;/strong&gt;  ：返回字符串或列的数据的长度&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;e&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;span&gt;g: select length(city)  as citylen  from  Demo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;lower/upper:&lt;/span&gt;返回字符串的小写/大写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　&lt;span&gt;eg: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;select UPPER(account)  from admininfo;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;REPLACE :替换字符串&lt;/strong&gt;&lt;br/&gt;　　　　　　&lt;strong&gt;eg:&lt;/strong&gt; select REPLACE('SQL SERVER','SQL','sql') 结果是'sql SERVER' 　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;POWER() 取数值的幂值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;eg:&lt;/strong&gt;select POWER(5,3) 结果是125&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;ABS 返回绝对值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;eg:&lt;/strong&gt;select ABS(-99) 结果是99&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;ROUND 根据指定精度返回数值的四舍五入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;eg:&lt;/strong&gt; select ROUND(3.1415926,3) 结果是3.142&lt;/p&gt;

&lt;h4&gt;　　数据库对象&lt;/h4&gt;
&lt;h4&gt;　　　　创建存储过程&lt;/h4&gt;
&lt;p&gt;　　　　　　drop procedure if exists pr_multi;   //如果存在名为pr_multi的存储过程，则删掉&lt;br/&gt;　　　　　　&lt;strong&gt;create procedure&lt;/strong&gt; pr_multi( &lt;strong&gt;ou&lt;/strong&gt;t &lt;strong&gt;c&lt;/strong&gt; &lt;strong&gt;int&lt;/strong&gt;, &lt;strong&gt;a int&lt;/strong&gt;, b int )      //创建名为pr_multi的存储过程（函数）,第一个为数据类型int的输出参数，第二、三个分别为数据类型int的输入参数&lt;br/&gt;　　　　　　&lt;strong&gt;begin&lt;/strong&gt;　　　　　　　　　　　　　　//过程体开始标记&lt;br/&gt;　　　　　　　　if a is null THEN         //判断  a 参数是否为空，若果为空，&lt;br/&gt;　　　　　　　　　　set a=10;      //给  a赋值10&lt;br/&gt;　　　　　　　　end if;&lt;br/&gt;　　　　　　　　if b is null THEN     //判断  b 参数是否为空，若果为空，&lt;br/&gt;　　　　　　　　　　set b=20;     //给  b 赋值20&lt;br/&gt;　　　　　　　　end if;     &lt;br/&gt;　　　　　　　　set c=a*b;      //将参数c设置为  a  和  b  的乘积&lt;br/&gt;　　　　　　&lt;strong&gt;end &lt;/strong&gt;    　　　　　　　　　　//过程体结束标记&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　　　&lt;strong&gt;call pr_multi(@name,5,3); &lt;/strong&gt;   //调用存储过程pr_multi     用变量  name  接收输出参数  c  ，给参数  a  传值  5，b传值  3&lt;/p&gt;
&lt;p&gt;　　　　　　select @name     //查询变量name的值。。  上述结果为  15  &lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;　　&lt;/h4&gt;




</description>
<pubDate>Fri, 16 Nov 2018 15:44:00 +0000</pubDate>
<dc:creator>沸水香茶</dc:creator>
<og:description>一、SQL语句篇 *特别说明：FILED代表数据表字段，CONDITIONS代表where之后的条件，TABLENAME代表数据表名 []中括号内的内容代表 可有可无。 创建数据库 create da</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobi-PHP-blog/p/9972396.html</dc:identifier>
</item>
<item>
<title>Mysql查询性能优化 - 将来-小志</title>
<link>http://www.cnblogs.com/will-xz/p/9972286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/will-xz/p/9972286.html</guid>
<description>&lt;h3 id=&quot;慢查询优化基础优化数据访问&quot; data-source-line=&quot;4&quot;&gt;慢查询优化基础：优化数据访问&lt;/h3&gt;
&lt;ul data-source-line=&quot;6&quot;&gt;&lt;li&gt;查询需要的记录。查询100条，应用层仅需要10条。&lt;/li&gt;
&lt;li&gt;多表关联时返回全部列。*，多表关联，字段查询要加前缀。&lt;/li&gt;
&lt;li&gt;总是取出全部列。*&lt;/li&gt;
&lt;li&gt;重复查询相同的数据。例如：在用户评论的地方需要查询用户头像URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重构查询方式&quot; data-source-line=&quot;12&quot;&gt;重构查询方式&lt;/h3&gt;
&lt;h4 id=&quot;切分查询&quot; data-source-line=&quot;14&quot;&gt;切分查询&lt;/h4&gt;
&lt;ul data-source-line=&quot;15&quot;&gt;&lt;li&gt;将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。如果一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;分解关联查询&quot; data-source-line=&quot;17&quot;&gt;分解关联查询&lt;/h4&gt;
&lt;ul data-source-line=&quot;18&quot;&gt;&lt;li&gt;很多高性能的应用都会对关联查询进行分解。&lt;/li&gt;
&lt;li&gt;简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;20&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag &lt;span class=&quot;hljs-keyword&quot;&gt;join tag_post &lt;span class=&quot;hljs-keyword&quot;&gt;on tag_post.id = tag.id &lt;span class=&quot;hljs-keyword&quot;&gt;join post &lt;span class=&quot;hljs-keyword&quot;&gt;on post.id = tag_post.id
&lt;span class=&quot;hljs-keyword&quot;&gt;where tag.tag = &lt;span class=&quot;hljs-string&quot;&gt;'msyql';

&lt;span class=&quot;zh-hans&quot;&gt;分解为：

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag &lt;span class=&quot;hljs-keyword&quot;&gt;from &lt;span class=&quot;hljs-keyword&quot;&gt;where tag = &lt;span class=&quot;hljs-string&quot;&gt;'msyql';
&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tag_post &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;id = &lt;span class=&quot;hljs-number&quot;&gt;1234;
&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from post &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;id &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-number&quot;&gt;3);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;优势&quot; data-source-line=&quot;31&quot;&gt;优势&lt;/h6&gt;
&lt;ul data-source-line=&quot;32&quot;&gt;&lt;li&gt;让缓存的效率更高。许多应用程序可以方便地缓存单表查询对应的结果对象。例如：上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为1，2的内容，那么第三个查询的in（）中就可以少了几个ID，对MYSQL的查询缓存来说，如果关联中的某个表发生了变化，那么久无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。&lt;/li&gt;
&lt;li&gt;将查询分解后，执行单个查询就可以减少锁的竞争。&lt;/li&gt;
&lt;li&gt;在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和高扩展。&lt;/li&gt;
&lt;li&gt;查询本身效率也可能会有所提升。使用IN（）代替关联查询，可以让MYSQL按照ID顺序进行查询，这可能比随机的关联要更搞笑。&lt;/li&gt;
&lt;li&gt;可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。&lt;/li&gt;
&lt;li&gt;更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MYSQL的潜逃循环关联。某些场景哈希关联的效率要高很多。&lt;/li&gt;
&lt;li&gt;在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询的结果的时候，当可以将数据分布到不同的MYSQL服务器上的时候，当能够使用IN的方式代替关联查询的时候、当查询中使用同一个数据表的时候。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查询执行基础&quot; data-source-line=&quot;41&quot;&gt;查询执行基础&lt;/h3&gt;
&lt;h3 id=&quot;mysql接收到请求都做了什么&quot; data-source-line=&quot;43&quot;&gt;MYSQL接收到请求都做了什么？&lt;/h3&gt;
&lt;ol data-source-line=&quot;44&quot;&gt;&lt;li&gt;客户端发送一条查询给服务器。&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。&lt;/li&gt;
&lt;li&gt;服务器进行SQL解析、预处理，再由优化器生成对应的执行计划。&lt;/li&gt;
&lt;li&gt;MYSQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。&lt;/li&gt;
&lt;li&gt;将结果返回给客户端。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;MYSQLk客户端/服务端通信协议&lt;/p&gt;
&lt;h5 id=&quot;mysql客户端和服务端之间的通信协议是半双工的这意味着在任何一个时刻要么是由服务器向客户端发送数据要么是由客户端向服务器发送数据这两个动作不能同时发生-一旦一端开始发送消息另一端要接收完整个消息才能响应它-这就像来回抛球的游戏在任何时刻只能一个人控制球而且只能空值求得人才能将球抛回去&quot; data-source-line=&quot;53&quot;&gt;MYSQL客户端和服务端之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它。这就像来回抛球的游戏：在任何时刻，只能一个人控制球，而且只能空值求得人才能将球抛回去。&lt;/h5&gt;
&lt;h5 id=&quot;客户端用一个单独的数据包将数据传给服务器这也是为什么当查询的语句很长的时候参数mac_allow_package就特别重要了-一旦客户端发送了请求它能做的事情就只能是等待结果了&quot; data-source-line=&quot;55&quot;&gt;客户端用一个单独的数据包将数据传给服务器，这也是为什么当查询的语句很长的时候，参数mac_allow_package就特别重要了。一旦客户端发送了请求，它能做的事情就只能是等待结果了。&lt;/h5&gt;
&lt;h5 id=&quot;相反的一般服务器响应给用户的数据通常很多由多个数据包组成-当服务器开始响应客户端请求时客户端必须完整地接收整个返回结果而不能简单地只取前面几条结果然后让服务器停止发送数据-这种情况下客户端若接收完成的结果然后取前面几条需要的结果或者接完几条结果后就粗暴地断开连接都不是好主意-这也是在必要的时候一定要在查询中加上limit限制的原因&quot; data-source-line=&quot;57&quot;&gt;相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完成的结果，然后取前面几条需要的结果，或者接完几条结果后就“粗暴”地断开连接，都不是好主意。这也是在必要的时候一定要在查询中加上LIMIT限制的原因。&lt;/h5&gt;
&lt;h4 id=&quot;查询状态&quot; data-source-line=&quot;59&quot;&gt;查询状态&lt;/h4&gt;
&lt;h6 id=&quot;对于一个mysql连接或者说一个线程任何时刻都有一个状态该状态表示了mysql当前正在做什么-有很多方式能查询当前状态最简单的是使用show-full-processlist命令-一个查询的生命周期中状态会变化很多次&quot; data-source-line=&quot;61&quot;&gt;对于一个MYSQL连接，或者说一个线程，任何时刻都有一个状态，该状态表示了MYSQL当前正在做什么。有很多方式能查询当前状态，最简单的是使用show full processlist命令。一个查询的生命周期中，状态会变化很多次。&lt;/h6&gt;
&lt;ul data-source-line=&quot;63&quot;&gt;&lt;li&gt;Sleep&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在等待客户端发送新的请求。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Query&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在执行查询或者正在将结果发送给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Locked&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在MYSQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁。例如：Innodb的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常出现。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Analyzing and statistics&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在收集存储引擎的统计信息，并生成查询执行计划。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Copying to tmp table [on disk]&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么在做Group By操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MYSQL正在讲一个内存临时表放到磁盘上。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sorting result&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;线程正在对结果集进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sending data&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在客户端返回数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote data-source-line=&quot;78&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;了解这些状态的基本含义非常有用，这可以让你很好地了解当前“谁正在持球”。在一个繁忙的服务器上，可能会看到大量的不正常状态，例如statistics正占用大量的时间。这通常表示，某个地方有异常了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查询优化&quot; data-source-line=&quot;81&quot;&gt;查询优化&lt;/h3&gt;
&lt;h4 id=&quot;mysql如何执行关联查询&quot; data-source-line=&quot;83&quot;&gt;MYSQL如何执行关联查询&lt;/h4&gt;
&lt;h5 id=&quot;对于union查询mysql先将一系列的单个查询结果放到一个临时表中然后再重新读取临时表数据来完成union查询&quot; data-source-line=&quot;85&quot;&gt;对于UNION查询，MYSQL先将一系列的单个查询结果放到一个临时表中，然后再重新读取临时表数据来完成UNION查询。&lt;/h5&gt;
&lt;blockquote data-source-line=&quot;87&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;在MYSQL的概念中，每个查询都是一次关联，所以读取结果临时表也是一次关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote data-source-line=&quot;89&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;当前MYSQL关联执行的策略很简单：MYSQL对任何关联都执行嵌套循环关联操作，即MYSQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，知道找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MYSQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MYSQL返回到上一层次关联表，看是否能够找到更多匹配记录，一次类推迭代执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre data-source-line=&quot;91&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;zh-hans&quot;&gt;简单的内连接查询：

&lt;span class=&quot;hljs-keyword&quot;&gt;select tab1.col1, tab2.col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 inner &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col3) &lt;span class=&quot;hljs-keyword&quot;&gt;where tab1.col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2);

&lt;span class=&quot;zh-hans&quot;&gt;实际执行的伪代码表示：

outer_iter = iterator over tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2)
outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;while outer_row
    inner_iter = iterator over tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = outer_row.col3
    inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    &lt;span class=&quot;hljs-keyword&quot;&gt;while inner_row
        output [ outer_row.col1, inner_row.col2]
        inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    &lt;span class=&quot;hljs-keyword&quot;&gt;end
    outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;end

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre data-source-line=&quot;114&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;zh-hans&quot;&gt;简单的外连接查询：

&lt;span class=&quot;hljs-keyword&quot;&gt;select tab1.col1, tab2.col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 outer &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col3) &lt;span class=&quot;hljs-keyword&quot;&gt;where tab1.col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2);

&lt;span class=&quot;zh-hans&quot;&gt;实际执行的伪代码表示：

outer_iter = iterator over tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2)
outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;while outer_row
    inner_iter = iterator over tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = outer_row.col3
    inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;if inner_row
    
        &lt;span class=&quot;hljs-keyword&quot;&gt;while inner_row
            output [ outer_row.col1, inner_row.col2]
            inner_row = inner_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
        &lt;span class=&quot;hljs-keyword&quot;&gt;end
        
    &lt;span class=&quot;hljs-keyword&quot;&gt;else
        
        output [ outer_row.col, null ]
    &lt;span class=&quot;hljs-keyword&quot;&gt;end
    outer_row = outer_iter.&lt;span class=&quot;hljs-keyword&quot;&gt;next
&lt;span class=&quot;hljs-keyword&quot;&gt;end

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-source-line=&quot;144&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;MYSQL的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。这一点对UNION查询也是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关联子查询&quot; data-source-line=&quot;146&quot;&gt;关联子查询&lt;/h3&gt;
&lt;h5 id=&quot;mysql的子查询实现得非常糟糕-最糟糕的一类查询是where条件中包含in的子查询语句&quot; data-source-line=&quot;148&quot;&gt;MYSQL的子查询实现得非常糟糕。最糟糕的一类查询是where条件中包含IN（）的子查询语句。&lt;/h5&gt;
&lt;pre data-source-line=&quot;150&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;
)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;mysql对in列表中的-选项有专门的优化策略一般会认为mysql会先执行子查询返回所有包含col3为1的col2-一般来说in列查询速度很快所以我们会认为上面的查询会这样执行&quot; data-source-line=&quot;159&quot;&gt;MYSQL对IN（）列表中的 选项有专门的优化策略，一般会认为MYSQL会先执行子查询返回所有包含col3为1的col2。一般来说，IN（）列查询速度很快，所以我们会认为上面的查询会这样执行：&lt;/h5&gt;
&lt;pre data-source-line=&quot;161&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;- &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT &lt;span class=&quot;hljs-keyword&quot;&gt;GROUP_CONCAT(col2) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;
- Reuslt : 1,2,3,4,

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tabl1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;in (&lt;span class=&quot;hljs-number&quot;&gt;1,&lt;span class=&quot;hljs-number&quot;&gt;2,&lt;span class=&quot;hljs-number&quot;&gt;3,&lt;span class=&quot;hljs-number&quot;&gt;4);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;很不幸mysql不是这样做的-mysql会将相关的外层表压到子查询中它认为这样可以更高效率地查找到数据行-也就是说mysql会将查询改成下面的这样&quot; data-source-line=&quot;169&quot;&gt;很不幸，MYSQL不是这样做的。MYSQL会将相关的外层表压到子查询中，它认为这样可以更高效率地查找到数据行。也就是说，MYSQL会将查询改成下面的这样：&lt;/h5&gt;
&lt;pre data-source-line=&quot;171&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 
&lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;exists (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1
    &lt;span class=&quot;hljs-keyword&quot;&gt;and tab1.col1 = tab2.col1
);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;这时子查询需要根据col1来关联外部表的film因为需要到col1字段所以mysql认为无法先执行这个子查询&quot; data-source-line=&quot;181&quot;&gt;这时，子查询需要根据col1来关联外部表的film，因为需要到col1字段，所以MYSQL认为无法先执行这个子查询。&lt;/h5&gt;
&lt;h5 id=&quot;如果tab1表数据量小性能还不是很糟糕如果是一个非常大的表那这个查询性能会非常糟糕-改写这个子查询&quot; data-source-line=&quot;183&quot;&gt;如果tab1表数据量小，性能还不是很糟糕，如果是一个非常大的表，那这个查询性能会非常糟糕。改写这个子查询&lt;/h5&gt;
&lt;pre data-source-line=&quot;185&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;inner &lt;span class=&quot;hljs-keyword&quot;&gt;join tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;using(col1) &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1;

&amp;amp;&amp;amp;

&lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 
&lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;exists (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select * &lt;span class=&quot;hljs-keyword&quot;&gt;from tab2 &lt;span class=&quot;hljs-keyword&quot;&gt;where col3 = &lt;span class=&quot;hljs-number&quot;&gt;1 
    &lt;span class=&quot;hljs-keyword&quot;&gt;and tab1.col1 = tab2.col1
);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;一旦使用了distinct和group-by在查询执行的过程中通常产生临时中间表-可以使用exists子查询优化&quot; data-source-line=&quot;199&quot;&gt;一旦使用了DISTINCT和GROUP by，在查询执行的过程中，通常产生临时中间表。可以使用EXISTS子查询优化&lt;/h5&gt;
&lt;h4 id=&quot;union的限制&quot; data-source-line=&quot;201&quot;&gt;UNION的限制&lt;/h4&gt;
&lt;h5 id=&quot;通过将两个表查询结果集合并取前20条&quot; data-source-line=&quot;203&quot;&gt;通过将两个表查询结果集合并取前20条&lt;/h5&gt;
&lt;pre data-source-line=&quot;205&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;select *from tab1 order by col1) &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union &lt;span class=&quot;hljs-title&quot;&gt;all (&lt;span class=&quot;hljs-title&quot;&gt;select * &lt;span class=&quot;hljs-title&quot;&gt;from &lt;span class=&quot;hljs-title&quot;&gt;tab2 &lt;span class=&quot;hljs-title&quot;&gt;order &lt;span class=&quot;hljs-title&quot;&gt;by &lt;span class=&quot;hljs-title&quot;&gt;col2) &lt;span class=&quot;hljs-title&quot;&gt;limit 20;

&lt;span class=&quot;zh-hans&quot;&gt;优化为:

(&lt;span class=&quot;hljs-keyword&quot;&gt;select *from tab1 order by col1 limit &lt;span class=&quot;hljs-number&quot;&gt;20) &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;union &lt;span class=&quot;hljs-title&quot;&gt;all (&lt;span class=&quot;hljs-title&quot;&gt;select * &lt;span class=&quot;hljs-title&quot;&gt;from &lt;span class=&quot;hljs-title&quot;&gt;tab2 &lt;span class=&quot;hljs-title&quot;&gt;order &lt;span class=&quot;hljs-title&quot;&gt;by &lt;span class=&quot;hljs-title&quot;&gt;limit 20)

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote data-source-line=&quot;214&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;UNION 临时表的数据会大大减少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-source-line=&quot;217&quot;&gt; &lt;/h3&gt;
&lt;h3 data-source-line=&quot;217&quot;&gt;优化COUNT()查询&lt;/h3&gt;
&lt;h5 id=&quot;count是一个特殊的函数有两种非常不同的作用它可以统计某个列的数量也可以统计行数-在统计列值时要求列值是非空的不统计null-如果在count的括号中指定了列或者列的表达式则统计的就是这个表达式有值的结果数&quot; data-source-line=&quot;219&quot;&gt;Count()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列的数量，也可以统计行数。在统计列值时要求列值是非空的（不统计NULL）。如果在COUNT()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。&lt;/h5&gt;
&lt;h5 id=&quot;count的另外一个作用是统计结果集的行数-当mysql确定括号内的表达式值不可能为空时实际上就是在统计行数-最简单的就是count&quot; data-source-line=&quot;221&quot;&gt;Count()的另外一个作用是统计结果集的行数。当MYSQL确定括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是COUNT(*)。&lt;/h5&gt;
&lt;h5 id=&quot;简单的优化&quot; data-source-line=&quot;223&quot;&gt;简单的优化&lt;/h5&gt;
&lt;pre data-source-line=&quot;225&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;col &amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;优化为:

&lt;span class=&quot;hljs-keyword&quot;&gt;select (&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 ) - &lt;span class=&quot;hljs-keyword&quot;&gt;count(*) &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where &lt;span class=&quot;hljs-keyword&quot;&gt;col &amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;扫描的数量会减少很多

&lt;span class=&quot;zh-hans&quot;&gt;子查询也会当成常数，使用expand&lt;span class=&quot;zh-hans&quot;&gt;可知

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;情景在同一个查询中统计一个列的不同值的数量以减少查询的语句量&quot; data-source-line=&quot;239&quot;&gt;情景：在同一个查询中统计一个列的不同值的数量，以减少查询的语句量&lt;/h5&gt;
&lt;pre data-source-line=&quot;241&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;select &lt;span class=&quot;hljs-built_in&quot;&gt;sum(&lt;span class=&quot;hljs-keyword&quot;&gt;if(color = blue), &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;as blue , &lt;span class=&quot;hljs-built_in&quot;&gt;sum(&lt;span class=&quot;hljs-keyword&quot;&gt;if(color = red), &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;as red &lt;span class=&quot;hljs-keyword&quot;&gt;from items ;

&lt;span class=&quot;zh-hans&quot;&gt;同样也可以使用Count

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优化关联查询&quot; data-source-line=&quot;249&quot;&gt;优化关联查询&lt;/h3&gt;
&lt;ul data-source-line=&quot;251&quot;&gt;&lt;li&gt;确保ON或者USING子句中的列有索引。&lt;/li&gt;
&lt;li&gt;确保任何group by和order by只涉及到一个表中的列。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优化limit分页&quot; data-source-line=&quot;254&quot;&gt;优化LIMIT分页&lt;/h3&gt;
&lt;pre data-source-line=&quot;256&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col3 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;50,&lt;span class=&quot;hljs-number&quot;&gt;5;

&lt;span class=&quot;zh-hans&quot;&gt;改写成：

&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;inner &lt;span class=&quot;hljs-keyword&quot;&gt;join (
    &lt;span class=&quot;hljs-keyword&quot;&gt;select col1 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col3 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;50,&lt;span class=&quot;hljs-number&quot;&gt;5
) &lt;span class=&quot;hljs-keyword&quot;&gt;as lim &lt;span class=&quot;hljs-keyword&quot;&gt;using(col1);

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-source-line=&quot;267&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里的“延迟关联”将大大提升查询效率，它让MYSQL扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的所有列。这个技术可以优化LIMIT查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有时候也可以将LIMIT查询转换为已知位置的查询，让MYSQL通过范围扫描获得到对应的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;271&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &lt;span class=&quot;hljs-keyword&quot;&gt;between &lt;span class=&quot;hljs-number&quot;&gt;30 &lt;span class=&quot;hljs-keyword&quot;&gt;and &lt;span class=&quot;hljs-number&quot;&gt;50;

&lt;span class=&quot;hljs-keyword&quot;&gt;select col1, col2 &lt;span class=&quot;hljs-keyword&quot;&gt;from tab1 &lt;span class=&quot;hljs-keyword&quot;&gt;where col1 &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;500 &lt;span class=&quot;hljs-keyword&quot;&gt;order &lt;span class=&quot;hljs-keyword&quot;&gt;by col1 &lt;span class=&quot;hljs-keyword&quot;&gt;limit &lt;span class=&quot;hljs-number&quot;&gt;20;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>将来-小志</dc:creator>
<og:description>Mysql查询性能优化 慢查询优化基础：优化数据访问 查询需要的记录。查询100条，应用层仅需要10条。 多表关联时返回全部列。*，多表关联，字段查询要加前缀。 总是取出全部列。* 重复查询相同的数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/will-xz/p/9972286.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用GraphQL - 最终章  Data Loader - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9972233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9972233.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181116225913505-148847985.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL - 目录&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在之前的几章中，我们的&lt;code&gt;GraphQL&lt;/code&gt;查询是没有优化过的。下面我们以&lt;code&gt;CustomerType&lt;/code&gt;中的&lt;code&gt;orders&lt;/code&gt;查询为例&lt;/p&gt;
&lt;h5 id=&quot;customertype.cs&quot;&gt;&lt;em&gt;CustomerType.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;ListGraphType&amp;lt;OrderType&amp;gt;, IEnumerable&amp;lt;Order&amp;gt;&amp;gt;()  
    .Name(&quot;Orders&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {
        return dataStore.GetOrdersAsync();
    }); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个查询中，我们获取了某个顾客中所有的订单， 这里如果你只是获取一些标量字段，那很简单。&lt;/p&gt;
&lt;p&gt;但是如果需要获取一些关联属性呢？例如查询系统中的所有订单，在订单信息中附带顾客信息。&lt;/p&gt;
&lt;h5 id=&quot;ordertype&quot;&gt;&lt;em&gt;OrderType&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public OrderType(IDataStore dataStore, IDataLoaderContextAccessor accessor)  
{
    Field(o =&amp;gt; o.Tag);
    Field(o =&amp;gt; o.CreatedAt);
    Field&amp;lt;CustomerType, Customer&amp;gt;()
        .Name(&quot;Customer&quot;)
        .ResolveAsync(ctx =&amp;gt;
        {            
            return dataStore.GetCustomerByIdAsync(ctx.Source.CustomerId);  
        });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里当获取&lt;code&gt;customer&lt;/code&gt;信息的时候，系统会另外初始化一个请求，以便从数据仓储中查询订单相关的顾客信息。&lt;/p&gt;
&lt;p&gt;如果你了解&lt;code&gt;dotnet cli&lt;/code&gt;, 你可以针对以下查询，在控制台输出所有的EF查询日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  orders{
    tag
    createdAt
    customer{
      name
      billingAddress
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;orders&quot;: [
      {
        &quot;tag&quot;: &quot;XPS 13&quot;,
        &quot;createdAt&quot;: &quot;2018-11-11&quot;,
        &quot;customer&quot;: {
          &quot;name&quot;: &quot;Lamond Lu&quot;,
          &quot;billingAddress&quot;: &quot;Test Address&quot;
        }
      },
      {
        &quot;tag&quot;: &quot;XPS 15&quot;,
        &quot;createdAt&quot;: &quot;2018-11-11&quot;,
        &quot;customer&quot;: {
          &quot;name&quot;: &quot;Lamond Lu&quot;,
          &quot;billingAddress&quot;: &quot;Test Address&quot;
        }
      }
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;产生日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (16ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [o].[OrderId], [o].[CreatedAt], [o].[CustomerId], [o].[CustomerId1], [o].[Tag]
      FROM [Orders] AS [o]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (6ms) [Parameters=[@__get_Item_0='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      
      SELECT TOP(1) [e].[CustomerId], [e].[BillingAddress], [e].[Name]
      FROM [Customers] AS [e]
      WHERE [e].[CustomerId] = @__get_Item_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__get_Item_0='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      
      SELECT TOP(1) [e].[CustomerId], [e].[BillingAddress], [e].[Name]
      FROM [Customers] AS [e]
      WHERE [e].[CustomerId] = @__get_Item_0
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[2]
      Request finished in 864.2749ms 200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志上我们很清楚的看到，这个查询使用了3个查询语句，第一个语句查询所有的订单信息，第二个和第三个请求分别查询了2个订单的顾客信息。这里可以想象如果这里有N的订单，就会产生N+1个查询语句，这是非常不效率的。正常情况下我们其实可以通过2条语句就完成上述的查询，后面查询单个顾客信息其实可以整合成一条语句。&lt;/p&gt;
&lt;p&gt;为了实现这个效果，我们就需要介绍一下&lt;code&gt;GraphQL&lt;/code&gt;中的&lt;code&gt;DataLoader&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DataLoader&lt;/code&gt;是&lt;code&gt;GraphQL&lt;/code&gt;中的一个重要功能，它为&lt;code&gt;GraphtQL&lt;/code&gt;查询提供了批处理和缓存的功能。&lt;/p&gt;
&lt;p&gt;为了使用&lt;code&gt;DataLoader&lt;/code&gt;, 我们首先需要在&lt;code&gt;Startup.cs&lt;/code&gt;中注册2个新服务&lt;code&gt;IDataLoaderContextAccessor&lt;/code&gt; 和&lt;code&gt;DataLoaderDocumentListener&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;startup.cs&quot;&gt;&lt;em&gt;Startup.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IDataLoaderContextAccessor, DataLoaderContextAccessor&amp;gt;();  
services.AddSingleton&amp;lt;DataLoaderDocumentListener&amp;gt;();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你的某个&lt;code&gt;GraphQL&lt;/code&gt;类型需要&lt;code&gt;DataLoader&lt;/code&gt;, 你就可以在其构造函数中注入一个&lt;code&gt;IDataLoaderContextAccessor&lt;/code&gt;接口对象。&lt;/p&gt;
&lt;p&gt;但是为了使用&lt;code&gt;DataLoader&lt;/code&gt;, 我们还需要将它添加到我们的中间件中。&lt;/p&gt;
&lt;h5 id=&quot;graphqlmiddleware.cs&quot;&gt;&lt;em&gt;GraphQLMiddleware.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task InvokeAsync(HttpContext httpContext, ISchema schema, IServiceProvider serviceProvider)  
{
    ....
    ....
        
    var result = await _executor.ExecuteAsync(doc =&amp;gt;
    {
        ....
        ....
        doc.Listeners.Add(serviceProvider                                                             .GetRequiredService&amp;lt;DataLoaderDocumentListener&amp;gt;());
    }).ConfigureAwait(false);

    ....
    ....            
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下一步，我们需要为我们的仓储类，添加一个新方法，这个方法可以根据顾客的id列表，返回所有的顾客信息。&lt;/p&gt;
&lt;h5 id=&quot;datastore.cs&quot;&gt;&lt;em&gt;DataStore.cs&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;Dictionary&amp;lt;int, Customer&amp;gt;&amp;gt; GetCustomersByIdAsync(
    IEnumerable&amp;lt;int&amp;gt; customerIds,
    CancellationToken token)  
{
    return await _context.Customers
        .Where(i =&amp;gt; customerIds.Contains(i.CustomerId))
        .ToDictionaryAsync(x =&amp;gt; x.CustomerId);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改&lt;code&gt;OrderType&lt;/code&gt;类&lt;/p&gt;
&lt;h5 id=&quot;ordertype-1&quot;&gt;&lt;em&gt;OrderType&lt;/em&gt;&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;CustomerType, Customer&amp;gt;()  
    .Name(&quot;Customer&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {            
        var customersLoader = accessor.Context.GetOrAddBatchLoader&amp;lt;int, Customer&amp;gt;(&quot;GetCustomersById&quot;, dataStore.GetCustomersByIdAsync);
        return customersLoader.LoadAsync(ctx.Source.CustomerId);  
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成以上修改之后，我们重新运行项目, 使用相同的&lt;code&gt;query&lt;/code&gt;, 结果如下，查询语句的数量变成了2个，效率大大提高&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info: Microsoft.EntityFrameworkCore.Infrastructure[10403]
      Entity Framework Core 2.1.4-rtm-31024 initialized 'ApplicationDbContext' using provider 'Microsoft.EntityFrameworkCore.SqlServer' with options: None
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (19ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [o].[OrderId], [o].[CreatedAt], [o].[CustomerId], [o].[CustomerId1], [o].[Tag]
      FROM [Orders] AS [o]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (10ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[CustomerId], [i].[BillingAddress], [i].[Name]
      FROM [Customers] AS [i]
      WHERE [i].[CustomerId] IN (1)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;DataLoader&lt;/code&gt;背后的原理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetOrAddBatchLoader&lt;/code&gt;方法会等到所有查询的顾客id列表准备好之后才会执行，它会一次性把所有查询id的顾客信息都收集起来。 这种技术就叫做批处理，使用了这种技术之后，无论有多少个关联的顾客信息，系统都只会发出一次请求来获取所有数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20X%E4%B9%AC&quot;&gt;本文源代码： https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20X&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 16 Nov 2018 15:01:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中使用GraphQL 目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9972233.html</dc:identifier>
</item>
</channel>
</rss>