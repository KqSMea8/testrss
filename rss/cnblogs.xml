<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程间的协作机制 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/9605048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/9605048.html</guid>
<description>&lt;p&gt;上篇文章我们介绍了 synchronized 这个关键字，通过它可以基本实现线程间在临界区对临界资源正确的访问与修改。但是，它依赖一个 Java 对象内置锁，某个时刻只能由一个线程占有该锁，其他试图占有的线程都得阻塞在对象的阻塞队列上。&lt;/p&gt;
&lt;p&gt;但实际上还有一种情况也是存在的，如果某个线程获得了锁但在执行过程中由于某些条件的缺失，比如数据库查询的资源还未到来，磁盘读取指令的数据未返回等，这种情况下，让线程依然占有 CPU 等待是一种资源上的浪费。&lt;/p&gt;
&lt;p&gt;所以，每个对象上也存在一个等待队列，这个队列上阻塞了所有获得锁并处于运行期间缺失某些条件的线程，所以整个对象的锁与队列状况是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/02/Px0A1J.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Entry Set 中阻塞了所有试图获得当前对象锁而失败的线程，Wait Set 中阻塞了所有在获得锁运行期间由于缺失某些条件而交出 CPU 的线程集合。&lt;/p&gt;
&lt;p&gt;而当某个现场称等待的条件满足了，就会被移除等待队列进入阻塞队列重新竞争锁资源。&lt;/p&gt;
&lt;h3 id=&quot;waitnotify-方法&quot;&gt;wait/notify 方法&lt;/h3&gt;
&lt;p&gt;Object 类中有几个方法我们虽然不常使用，但是确实线程协作的核心方法，我们通过这几个方法控制线程间协作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final native void wait(long timeout)

public final void wait()

public final native void notify();

public final native void notify();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wait 类方法用于阻塞当前线程，将当前线程挂载进 Wait Set 队列，notify 类方法用于释放一个或多个处于等待队列中的线程。&lt;/p&gt;
&lt;p&gt;所以，这两个方法主要是操作对象的等待队列，也即是将那些获得锁但是运行期间缺乏继续执行的条件的线程阻塞和释放的操作。&lt;/p&gt;
&lt;p&gt;但是有一个前提大家需要注意，wait 和 notify 操作的是对象内置锁的等待队列，也就是说，必须在获得对象内置锁的前提下才能阻塞和释放等待队列上的线程。简单来说，&lt;strong&gt;这两个方法的只能在 synchronized 修饰的代码块内部进行调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面我们看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    private static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(){
            @Override
            public void run(){
                synchronized (lock){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        Thread thread2 = new Thread(){
            @Override
            public void run(){
                synchronized (lock){
                    System.out.println(&quot;hello&quot;);
                }
            }
        };
        thread1.start();
        thread2.start();

        Thread.sleep(2000);

        System.out.println(thread1.getState());
        System.out.println(thread2.getState());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/02/PxTXIU.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，程序是没有正常结束的，也就是说，有线程还未正常退出。线程一优先启动于线程二，所以它将先获得 lock 锁，接着调用 wait 方法将自己阻塞在 lock 对象的等待队列上，并释放锁交出 CPU。&lt;/p&gt;
&lt;p&gt;线程二启动时可能由于线程一依然占有锁而阻塞，但当线程一释放锁以后，线程二将获得锁并执行打印语句，随后同步方法结束并释放锁。&lt;/p&gt;
&lt;p&gt;此时，线程一依然阻塞在 lock 对象的等待队列上，所以整个程序没有正常退出。&lt;/p&gt;
&lt;p&gt;演示这么一段程序的意义是什么呢？就是想告诉大家，虽然阻塞队列和等待队列上的线程都不能得到 CPU 正常执行指令，但是它们却属于两种不同的状态，阻塞队列上的线程在得知锁已经释放后将公平竞争锁资源，而等待队列上的线程则必须有其他线程通过调用 notify 方法通知并移出等待队列进入阻塞队列，重新竞争锁资源。&lt;/p&gt;
&lt;h3 id=&quot;相关方法的实现&quot;&gt;相关方法的实现&lt;/h3&gt;
&lt;p&gt;1、sleep 方法&lt;/p&gt;
&lt;p&gt;sleep 方法用于阻塞当前线程指定时长，线程状态随即变成 TIMED_WAITING，但区别于 wait 方法。两者都是让出 CPU，但是 sleep 方法不会释放当前持有的锁。&lt;/p&gt;
&lt;p&gt;也就是说，sleep 方法不是用于线程间同步协作的方法，它只是让线程暂时交出 CPU，暂停运行一段时间，时间到了将由系统调度分配 CPU 继续执行。&lt;/p&gt;
&lt;p&gt;2、join 方法&lt;/p&gt;
&lt;p&gt;join 方法用于实现两个线程之间相互等待的一个操作，看段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testJoin() throws InterruptedException {
    Thread thread = new Thread(){
        @Override
        public void run(){
            for (int i=0; i&amp;lt;1000; i++)
                System.out.println(i);
        }
    };
    thread.start();

    thread.join();
    System.out.println(&quot;main thread finished.....&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抛开 join 方法不谈，main 线程中的打印方法一定是先执行的，而实际上这段程序会在线程 thread 执行完成之后才执行主线程的打印方法。&lt;/p&gt;
&lt;p&gt;实现机理区别于 sleep 方法，我们一起看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/04/iS2K4s.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/04/iS2QCn.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方法的核心就是调用 wait(delay) 阻塞当前线程，当线程被唤醒计算从进入方法到当前时间共经过了多久。&lt;/p&gt;
&lt;p&gt;接着比较 millis 和 这个 now，如果 millis 小于 now 说明，说明等待时间已经到了，可以退出方法返回了。否则则说明线程提前被唤醒，需要继续等待。&lt;/p&gt;
&lt;p&gt;需要注意的是，既然是调用的 wait 方法，那么等待的线程必然是需要释放持有的当前对象内置锁的，这区别于 sleep 方法。&lt;/p&gt;
&lt;h3 id=&quot;一个典型的线程同步问题&quot;&gt;一个典型的线程同步问题&lt;/h3&gt;
&lt;p&gt;下面我们写一个很有意思的代码，实现操作系统中的生产者消费者模型，借助我们的 wait 和 notify 方法。&lt;/p&gt;
&lt;p&gt;生产者不停生产产品到仓库中直到仓库满，消费者不停的从仓库中取出产品直到仓库为空。如果生产者发现仓库已经满了，就不能继续生产产品，而消费者如果发现仓库为空，就不能从仓库中取出产品。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Repository {
    private List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    private int limit = 10;  //设置仓库容量上限

    public synchronized void addGoods(int count) throws InterruptedException {
        while(list.size() == limit){
            //达到仓库上限，不能继续生产
            wait();
        }
        list.add(count);
        System.out.println(&quot;生产者生产产品：&quot; + count);
        //通知所有的消费者
        notifyAll();
    }

    public synchronized void removeGoods() throws InterruptedException {
        while(list.size() &amp;lt;= 0){
            //仓库中没有产品
            wait();
        }

        int res = list.get(0);
        list.remove(0);
        System.out.println(&quot;消费者消费产品：&quot; + res);
        //通知所有的生产者
        notifyAll();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写一个仓库类，该类提供两个方法供外部调用，一个是往仓库放产品，如果仓库满了则阻塞到仓库对象的等待队列上，一个是从仓库中取出产品，如果仓库为空则阻塞在仓库的等待队列上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Producer extends Thread{
    Repository repository = null;

    public Producer(Repository p){
        this.repository = p;
    }

    @Override
    public void run(){
        int count = 1;
        while(true){
            try {
                Thread.sleep((long) (Math.random() * 500));
                repository.addGoods(count++);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个生产者类，生产者随机的向仓库添加产品。如果没有能成功的添加，会被阻塞在循环里。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Customer extends Thread{
    Repository repository = null;

    public Customer(Repository p){
        this.repository = p;
    }

    @Override
    public void run(){
        while(true){
            try {
                Thread.sleep((long) (Math.random() * 500));
                repository.removeGoods();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个消费者类，消费者类随机的从仓库中取一个产品。如果没有成功的取出一个产品，同样会被阻塞在循环里。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testProducerAndCustomer() {
    Repository repository = new Repository();
    Thread producer = new Producer(repository);
    Thread consumer = new Customer(repository);

    producer.start();
    consumer.start();

    producer.join();
    consumer.join();
    System.out.println(&quot;main thread finished..&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主线程启动这两个线程，程序运行的情况大致是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;生产者生产产品：1
消费者消费产品：1
生产者生产产品：2
消费者消费产品：2
生产者生产产品：3
消费者消费产品：3
。。。。。
。。。。。
消费者消费产品：17
生产者生产产品：21
消费者消费产品：18
生产者生产产品：22
消费者消费产品：19
生产者生产产品：23
消费者消费产品：20
生产者生产产品：24
生产者生产产品：25
生产者生产产品：26
消费者消费产品：21
生产者生产产品：27
生产者生产产品：28
消费者消费产品：22
消费者消费产品：23
生产者生产产品：29
生产者生产产品：30
。。。。。。
。。。。。。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细观察，你会发现，消费者者永远不会消费一个不存在的产品，消费的一定是生产者生产的产品。刚开始可能是生产者生产一个产品，消费者消费一个产品，而一旦消费者线程执行的速度超过了生产者，必然会由于仓库容量为空而被阻塞。&lt;/p&gt;
&lt;p&gt;生产者线程的执行速度可以超过消费者线程，而消费者线程的执行速度如果一直超过生产者就会导致仓库容量为空而致使自己被阻塞。&lt;/p&gt;
&lt;p&gt;总结一下，synchronized 修饰的代码块是直接使用的对象内置锁的阻塞队列，线程获取不到锁自然被阻塞在该队列上，而 wait/notify 则是我们手动的控制等待队列的入队和出队操作。但本质上都是利用的对象内置锁的两个队列。&lt;/p&gt;
&lt;p&gt;这两篇文章介绍的是利用 Java 提供给我们的对象中的内置锁来完成基本的线程间同步操作，这部分知识是后续介绍的各种同步工具，集合类框架等实现的底层原理。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(https://github.com/SingleYam/overview_java)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：OneJavaCoder，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/06/19/Czmcad.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 07:37:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<og:description>上篇文章我们介绍了 synchronized 这个关键字，通过它可以基本实现线程间在临界区对临界资源正确的访问与修改。但是，它依赖一个 Java 对象内置锁，某个时刻只能由一个线程占有该锁，其他试图占</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/9605048.html</dc:identifier>
</item>
<item>
<title>（数据科学学习手札50）基于Python的网络数据采集-selenium篇（上） - 费弗里</title>
<link>http://www.cnblogs.com/feffery/p/9570171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feffery/p/9570171.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着几个月之前的&lt;strong&gt;（数据科学学习手札31）基于Python的网络数据采集（初级篇）&lt;/strong&gt;，在那篇文章中，我们介绍了关于网络爬虫的基础知识（基本的请求库，基本的解析库，CSS，正则表达式等），在那篇文章中我们只介绍了如何利用urllib、requests这样的请求库来将我们的程序模拟成一个请求网络服务的一端，来直接取得设置好的url地址中朴素的网页内容，再利用BeautifulSoup或pyspider这样的解析库来对获取的网页内容进行解析，在&lt;strong&gt;初级篇&lt;/strong&gt;中我们也只了解到如何爬取静态网页，那是网络爬虫中最简单的部分，事实上，现在但凡有价值的网站都或多或少存在着自己的一套反爬机制，例如利用JS脚本来控制网页中部分内容的请求和显示，使得最原始的直接修改静态目标页面url地址来更改页面的方式失效，这一部分，我在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（数据科学学习手札47）基于Python的网络数据采集实战（2）&lt;/strong&gt;中爬取马蜂窝景点页面下蜂蜂点评区域用户评论内容的时候，也详细介绍过，但之前我在所有爬虫相关的文章中介绍的内容，都离不开这样的一个过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;整理url规则（静态页面直接访问，JS控制的动态页面通过浏览器的开发者工具来找到真实网址和参数）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;伪装浏览器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用urllib.urlopen()或requests.get()对目标url发起访问&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;获得返回的网页原始内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用BeautifulSoup或PySpider对网页原始内容进行解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结合观察到的CSS标签属性等信息，利用BeautifulSoup对象的findAll()方法提取需要的内容，利用正则表达式来完成精确提取&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;存入数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而本文将要介绍的一种新的网络数据采集工具就不再是伪装成浏览器端，而是基于自动化测试工具selenium来结合对应浏览器的驱动程序，开辟真实的、显性的浏览器窗口，来完成一系列动作，以应对更加动态灵活的网页；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、selenium&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;2.1 介绍&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　selenium也是一个用于Web应用程序测试的工具。selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE、Mozilla Firefox、Mozilla Suite、Chrome等。这个工具的主要功能是测试与浏览器的兼容性，但由于其能够真实模拟浏览器，模拟网页点击、下拉、拖拽元素等行为的功能，使得其在网络数据采集上开辟出一片天地；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2 环境搭建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要想基于Python（这里我们说的是Python3，Python2，就让它在历史的长河里隐退吧。。。）来使用selenium创建爬虫程序，我们需要：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.安装selenium包，直接pip安装即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.下载浏览器（废话-_-！），以及对应的驱动程序，本文选择使用的浏览器为Chrome，需要下载chromedriver.exe，这里提供一个收录所有版本chromedriver.exe资源的地址：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://npm.taobao.org/mirrors/chromedriver/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，要下载与你的浏览器版本兼容的资源，这里给一个建议：将你的Chrome浏览器更新到最新版本，再到上述地址中下载发布时间最新的chromedriver.exe；在下载完毕后，将chromedriver.exe放到你的Python根目录下，和python.exe放在一起，譬如我就将其放在我的anaconda环境下的对应位置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180901164156095-434141572.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.测试一下~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在完成上述操作之后，我们要检验一下我们的环境有没有正确搭建完成，在你的Python编辑器中，写下如下语句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;创建一个新的Chrome浏览器窗体&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在browser对应的浏览器中访问百度首页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果在执行上述语句之后，顺利地打开了Chrome浏览器并访问到我们设置的网页，则selenium+Chrome的开发环境配置完成；&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.3 利用selenium进行网络数据采集的基本流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在本文的一开始我们总结了之前进行网络数据采集的基本流程，下面我们以类似的形式介绍一下selenium进行网络数据采集的基本流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建浏览器（可能涉及对浏览器一些设置的预配置，如不需要采集图片时设置禁止加载图片以提升访问速度）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用.get()方法直接打开指定url地址&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用.page_source()方法获取当前主窗口（浏览器中可能同时打开多个网页窗口，这时需要利用页面句柄来指定我们关注的主窗口网页）页面对应的网页内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;利用BeautifulSoup或pyspider等解析库对指定的网页内容进行解析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;|&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结合观察到的CSS标签属性等信息，利用BeautifulSoup对象的findAll()方法提取需要的内容，利用正则表达式来完成精确提取&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;|&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;存入数据库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;　　可以看出，利用selenium来进行网络数据采集与之前的方法最大的不同点在于对目标网页发起请求的过程，在使用selenium时，我们无需再伪装浏览器，且有了非常丰富的浏览器动作可以设置，譬如说之前我们需要对页面进行翻页操作，主要是通过修改url中对应控制页面值的参数来完成，所以在遇到JS控制的动态网页时，可以不需要去费心寻找控制对应资源翻页的真实url地址，只需要在selenium中，通过其内置的丰富的定位方法对页面中的翻页按钮进行定位&lt;/span&gt; &lt;span&gt;，再通过对定位到的元素运用.click()，即可实现真实的翻页操作，下面我们根据上述过程中列出的selenium部分，涉及到的常用方法进行介绍以及举例说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、selenium常用操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1 浏览器配置部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在调出一个真实的浏览器对象之前，我们可以结合实际需要对浏览器的设置进行参数配置，这在selenium中是通过对应浏览器的XXXOptions类来设置的，例如本文只介绍Chrome浏览器，则我们通过ChromeOptions类中的方法来实现浏览器预配置，下面我们来了解一下ChromeOptions类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ChromeOptions：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ChromeOptions是一个在selenium创建Chrome浏览器之前，对该浏览器对象进行预配置的类，其主要功能有&lt;strong&gt;添加Chrome启动参数、修改Chrome设置、添加扩展应用&lt;/strong&gt;等，&lt;/span&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1.禁止网页中图片加载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;创建一个新的Chrome浏览器窗体，通过add_experimental_option()方法来设置禁止图片加载&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
chrome_options &lt;/span&gt;=&lt;span&gt; webdriver.ChromeOptions()
prefs &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;profile.managed_default_content_settings.images&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 2&lt;span&gt;}
chrome_options.add_experimental_option(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, prefs)
browser &lt;/span&gt;= webdriver.Chrome(chrome_options=&lt;span&gt;chrome_options)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在browser对应的浏览器中，以禁止图片加载的方式访问百度首页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;查看当前浏览器中已设置的参数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
chrome_options.experimental_options&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180902223151454-1645475929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180902223215676-1280596925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出，在进行如上设置后，我们访问的网页中所有图片都没有加载，这在不需要采集图片资源的任务中，对于提升访问速度有着重要意义；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2.设置代理IP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;有些时候，在面对一些对访问频率有所限制的网站时，一旦我们爬取频率过高，就会导致我们本机的IP地址遭受短暂的封禁，这时我们可以通过收集一些IP代理来建立我们的代理池，关于这一点我们会在之后单独开一篇博客来详细介绍，下面简单演示一下如何为我们的Chrome()浏览器对象设置IP代理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;设置代理IP&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
IP &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;106.75.9.39:8080&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;为Chrome浏览器配置chrome_options选项&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
chrome_options &lt;/span&gt;=&lt;span&gt; webdriver.ChromeOptions()
chrome_options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--proxy-server=http://{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(IP))

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;将配置好的chrome_options选项传入新的Chrome浏览器对象中&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;= webdriver.Chrome(chrome_options=&lt;span&gt;chrome_options)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;尝试访问百度首页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　但是如果你不是付费购买的高速IP代理，而是从网上所谓的免费IP代理网站扒下来的一些IP地址，那么上述设置之后打开的浏览器中不一定能在正常时间内显示目标网页（原因你懂的）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;另一种思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;　　除了使用ChromeOptions()中的方法来设置，还有一种简单直接粗暴的方法，我们可以直接访问对应当前浏览器设置页面的地址：&lt;/span&gt;&lt;span&gt;chrome://settings/content&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;直接访问设置页面&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome://settings/content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904154232899-1091845760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着再使用自己编写的模拟点击规则，即可完成对应的设置内容，这里便不再多说；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.2 浏览器运行时的实用方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过了3.1中介绍的方式，对浏览器进行预配置，并成功打开对应的浏览器之后，selenium中还存在着非常丰富的浏览器方法，下面我们就其中实用且常用的一些方法和类内的变量进行介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　假设我们构造了一个叫做browser的浏览器对象，可以使用的方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;browser.get(url)：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;在浏览器主窗口中打开url指定的网页；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.title：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;获得当前浏览器中主页面的网页标题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;直接访问设置页面&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://hao.360.cn/?wd_xp1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;打印网页标题&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(browser.title)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904162836943-283017250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;browser.current_url：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;返回当前主页面url地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.page_source：&lt;/strong&gt;获取当前主界面的页面内容，相当于requests.get(url).content&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;browser.close()：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;关闭当前主页面对应的网页&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.quit()：&lt;/strong&gt;直接关闭当前浏览器&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.maximize_window()&lt;/strong&gt;：将浏览器窗口大小最大化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.fullscreen_window()&lt;/strong&gt;：将浏览器窗口全屏化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.back()&lt;/strong&gt;：控制当前主页面进行后退操作（前提是它有上一页面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.forward()&lt;/strong&gt;：控制当前主页面进行前进操作（前提是它有下一页面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.refresh()&lt;/strong&gt;：控制当前主页面进行刷新操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.set_page_load_timeout(time_to_wait)&lt;/strong&gt;：为当前浏览器设置一个最大页面加载耗时容忍阈值，单位秒，类似urllib.urlopen()中的timeout参数，即当加载某个界面时，持续time_to_wait秒还未加载完成时，程序会报错，我们可以利用错误处理机制捕捉这个错误，此方法适用于长时间采样中某个界面访问超时假死的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;browser.set_window_size(&lt;/span&gt;&lt;span&gt;width, height, windowHandle='current'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;)&lt;/strong&gt;：用于调节浏览器界面长宽大小&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于主页面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里要额外介绍一下，我们在前面一大段中提到过很多次主页面这个概念，是因为在selenium控制浏览器时，无论浏览器中开了多少个网页，都只将唯一一个网页视为主页面，相应的很多webdriver()方法也都是以该主页面为对象，下面是一个示例，我们以马蜂窝地方游记页面为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;访问马蜂窝重庆游记汇总页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mafengwo.cn/search/s.php?q=%E9%87%8D%E5%BA%86&amp;amp;t=info&amp;amp;seid=71F18E8D-AA90-4870-9928-2BE01E53DDBD&amp;amp;mxid=&amp;amp;mid=&amp;amp;mname=&amp;amp;kt=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　打开目标页面如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904190602429-642186377.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我们手动点开一篇游记（模拟点击的方法下文会介绍），浏览器随即跳转到一个新的页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904190710088-889831038.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这时我们运行下列代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;打印网页标题&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(browser.title)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904190815348-1140308802.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，虽然在我们的视角里，通过点击，进入到一个新的界面，但当我们利用对应方法获取当前页面标题时，仍然是以之前的页面作为对象，这就涉及到我们之前提到的主页面的问题，当在原始页面中，因为点击事件而跳转到另一个页面（这里指的是新开一个窗口显示新界面，而不是在原来的窗口覆盖掉原页面），浏览器中的主页面依旧是锁定在原始页面中，即get()方法跳转到的网页，这种情况我们就需要用到网页的句柄来唯一标识每一个网页；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在selenium中，关于获取网页句柄，有以下两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.current_window_handle&lt;/strong&gt;：获取主页面的句柄，以上面马蜂窝的为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;打印主页面句柄&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(browser.current_window_handle)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904192642280-717126462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;browser.window_handles&lt;/strong&gt;：获取当前浏览器中所有页面的句柄，按照打开的时间顺序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;打印当前浏览器下所有页面的句柄&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(browser.window_handles)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1344061/201809/1344061-20180904192908154-130855776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　既然句柄相当于网页的身份证，那么我们可以基于句柄切换当前的主网页到其他网页之上，延续上面的例子，此时的主网页是.get()方法打开的网页，之前打印browser.title也是指向的该网页，现在我们利用browser.switch_to.window(handle)方法，将主网页转到最近打开的网页中，并打印当前主网页的标题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;切换主网页至最近打开的网页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.switch_to.window(browser.window_handles[&lt;/span&gt;-1&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;打印当前主网页的网页标题&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(browser.title)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180907094437245-1243770755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看到，使用主网页切换方法后，我们的主网页转到指定的网页中，这在对特殊的网页跳转方式下新开的网页内容的采集很受用；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.3 页面元素定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在介绍selenium的精髓——模拟浏览器行为之前，我们需要知道如何对网页内的元素进行定位，譬如说我们要想定位到网页中的翻页按钮，就需要对翻页按钮所在的位置进行定位，这里的定位不是指在屏幕的平面坐标上进行定位，而是基于网页自身的CSS结构，其实selenium中对网页元素进行定位的方式非常多，但是通过我大量的实践，其中很多方法效果并不尽如人意，唯有其中基于xpath的定位方法十分方便，定位非常准确方便，因此本文不会浪费你的时间介绍其他效果不太好的方法，直接介绍基于xpath的定位方法，我们先了解一下什么是xpath：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于xpath&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　xpath是一门在xml文档中查找信息的语言，只是为了在selenium中定位网页元素的话，我们只需要掌握xpath路径表达式即可；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　xpath使用路径表达式来识别xml文档中的节点或节点集，我们先从一个示例出发来对xpath路径表达式有一个认识：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还是以马蜂窝游记页面为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;访问马蜂窝重庆游记汇总页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mafengwo.cn/search/s.php?q=%E9%87%8D%E5%BA%86&amp;amp;t=info&amp;amp;seid=71F18E8D-AA90-4870-9928-2BE01E53DDBD&amp;amp;mxid=&amp;amp;mid=&amp;amp;mname=&amp;amp;kt=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过浏览器的开发者工具，我们找到“下一页”按钮元素在CSS结构中所在的位置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180907101024949-1235580971.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先把该元素完整的xpath路径表达式写出来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//div/div/a[@class='ti next _j_pageitem']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们使用基于xpath的定位方法，定位按钮的位置并模拟点击：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;定位翻页按钮的位置并保存在新变量中&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
ChagePageElement &lt;/span&gt;= browser.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div/div/a[@class='ti next _j_pageitem']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;对按钮位置变量使用click方法进行模拟点击&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
ChagePageElement.click()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上述代码运行之后，我们的浏览器执行了对翻页按钮的模拟点击，实现了翻页：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180907102328354-2026639572.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在我们来介绍一下xpath路径表达式中的一些基本知识：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nodename：标明一个结点的标签名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/：父节点与子节点之间的分隔符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//：代表父节点与下属某个节点之间若干个中间节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[]：指定最末端结点的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@：在[]中指定属性名称和对应的属性值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在xpath路径表达式中还有很多其他内容，但在selenium中进行基本的元素定位了解到上面这些规则就可以了，所以我们上面的例子中的规则，表示的就是定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若干节点-&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　... ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　... ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&amp;lt;a class='ti next _j_pageitem'&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　... ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　... ...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　   &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　利用这样的方式，基于browser.find_element_by_xpath()和browser.find_elements_by_xpath()，我们就可以找到页面中单个独特元素或多个同类型元素，再使用.click()方法即可完成对页面内任意元素的模拟点击；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.4 基础的浏览器动作模拟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了上面一小节介绍的使用元素.click()控制点击动作以外，selenium还支持丰富多样的其他常见动作，因为本文是我介绍selenium的上篇，下面只介绍两个常用的动作，更复杂的组合动作放在之后的文章中介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模拟网页下滑&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很多时候我们会遇到这样的动态加载的网页，如光点壁纸的各个壁纸板块，这里以风景板块为例http://pic.adesk.com/cate/landscape：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180907145139368-463456743.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个网页的特点是，大多数情况下没有翻页按钮，而是需要用户将页面滑到底部之后，才会自动加载下一页的内容，并且这种机制持续固定几次后，会参杂一个必须点击才可以进行翻页操作的按钮，我们可以在selenium中使用browser.execute_script()方法来传入JavaScript脚本来执行浏览器动作，进而实现下滑功能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对应下滑到底的JavaScript脚本为&lt;/span&gt;&lt;span&gt;'window.scrollTo(0, document.body.scrollHeight)'，我们用下面这段代码来实现持续下滑，并及时捕捉翻页按钮进行点击（利用错误处理机制来实现）：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;访问光点壁纸风景板块页面&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://pic.adesk.com/cate/landscape&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;这里尝试的时候不要循环太多次，快速加载图片比较吃网速和内存&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 20&lt;span&gt;):
     &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;这里使用一个错误处理机制，
     如果有定位到加载下一页按钮就进行
     点击下一页动作，否则继续每隔1秒，下滑到底&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
          &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;定位加载下一页按钮&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
          LoadMoreElement &lt;/span&gt;= browser.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div/div[@class='loadmore']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          LoadMoreElement.click()

     &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
          &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;浏览器执行下滑动作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
          browser.execute_script(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0, document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          time.sleep(&lt;/span&gt;1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;模拟输入&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有些时候，我们需要对界面中出现的输入框，即标签为&amp;lt;input&amp;gt;&amp;lt;/input&amp;gt;代表的对象进行模拟输入操作，这时候我们只需要对输入框对应的网页对象进行定位，然后使用browser.send_keys(输入内容)来往输入框中添加文本信息即可，下面是一个简单的例子，我们从百度首页出发，模拟了点击登陆-点击注册-在用户名输入框中输入指定的文本内容，这样一个简单的过程：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;访问百度首页&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;对页面右上角的登陆超链接进行定位，这里因为同名超链接有两个，
所以使用find_elements_by_xpath来捕获一个元素列表，再对其中
我们指定的对象执行点击操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
LoginElement &lt;/span&gt;= browser.find_elements_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//a[@name='tj_login']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;对指定元素进行点击操作&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
LoginElement[&lt;/span&gt;1&lt;span&gt;].click()

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;这段while语句是为了防止信息块没加载完成导致出错&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
     &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
          &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;捕获弹出的信息块中的注册按钮元素&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
          SignUpElement &lt;/span&gt;= browser.find_elements_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//a[@class='pass-reglink pass-link']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;点击弹出的信息块中的注册超链接&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
          SignUpElement[0].click()
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
          &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;将主网页切换至新弹出的注册页面中以便对其页面内元素进行定位&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
browser.switch_to.window(browser.window_handles[&lt;/span&gt;-1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;对用户名称输入框对应元素进行定位&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
InputElement &lt;/span&gt;= browser.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@name='userName']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;模拟输入指定的文本信息&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
InputElement.send_keys(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Keras&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1344061/201809/1344061-20180907153313264-2065440611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　以上就是关于selenium进行网络数据采集的上篇内容，其余的内容我会挤出时间继续整理介绍，敬请关注，如有笔误，望指出。&lt;/span&gt;&lt;/p&gt;
















</description>
<pubDate>Fri, 07 Sep 2018 07:24:00 +0000</pubDate>
<dc:creator>费弗里</dc:creator>
<og:description>一、简介 接着几个月之前的（数据科学学习手札31）基于Python的网络数据采集（初级篇），在那篇文章中，我们介绍了关于网络爬虫的基础知识（基本的请求库，基本的解析库，CSS，正则表达式等），在那篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feffery/p/9570171.html</dc:identifier>
</item>
<item>
<title>tensorflow: a Implementation of rotation ops (旋转的函数实现方法) - 修雨轩陈</title>
<link>http://www.cnblogs.com/greentomlee/p/9604806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/greentomlee/p/9604806.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;关键字: rot90, tensorflow&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在做数据增强的操作过程中, 很多情况需要对图像旋转和平移等操作, 针对一些特殊的卷积(garbo conv)操作,还需要对卷积核进行旋转操作.&lt;br/&gt;在tensorflow中似乎没有实现对4D tensor的旋转操作.&lt;br/&gt;严格的说: tensorflow对tensor的翻转操作并未实现, 仅有针对3D tensor的tf.image.rot()&lt;br/&gt;而在大多数的情况下使用的是4D形式的tensor, [B,W,H,C] 或者是3D的图像组成的batchs.&lt;/p&gt;
&lt;p&gt;通过查看这篇文章的代码可以知道 可以使用numpy的rot90()函数旋转, 但是rot90对象是ndarray, 针对tensorflow.tensor对象而言显然是无法使用的, 会抛出类似: &lt;code&gt;无法找到m.dim属性&lt;/code&gt;的异常.&lt;br/&gt;也就是说无法使用&lt;code&gt;numpy.rot90()&lt;/code&gt; 函数.&lt;/p&gt;
&lt;p&gt;又知, tensorflow中提供有对矩阵的翻转, 转置,切片操作的函数,但是没有提供旋转90°, 180°,270°的操作.&lt;br/&gt;因此可以参照&lt;code&gt;numpy.rot90(m, k=1, axes=(0,1))&lt;/code&gt;的程序片段去自己动手实现.&lt;br/&gt;rot90中的第一个参数m是操作对象, k是旋转的次数,k=1 代表逆时针旋转90度, k=2 代表逆时针旋转180度,以此类推&lt;br/&gt;axes是代表旋转的操作在哪两个维度构成的平面上.&lt;/p&gt;
&lt;p&gt;rot90的源代码如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def rot90(m, k=1, axes=(0,1)):
    '''
    ......
    '''
    # 省略检测参数的操作
    k %= 4

    if k == 0:
        return m[:]
    if k == 2:
        return flip(flip(m, axes[0]), axes[1])

    axes_list = arange(0, m.ndim)
    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],
                                                axes_list[axes[0]])

    if k == 1:
        return transpose(flip(m,axes[1]), axes_list)
    else:
        # k == 3
        return flip(transpose(m, axes_list), axes[1])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS: 通过阅读上述的代码,也可以发现在tensorflow中直接使用rot90所抛出的异常是在这里出现的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if axes[0] == axes[1] or absolute(axes[0] - axes[1]) == m.ndim&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是: 程序把&lt;code&gt;tensor&lt;/code&gt;对象当成&lt;code&gt;np.ndarray&lt;/code&gt;操作了, 而&lt;code&gt;tensor&lt;/code&gt;对象没有&lt;code&gt;m.dim&lt;/code&gt;属性&lt;/p&gt;

&lt;h2 id=&quot;梳理程序流程&quot;&gt;2.1 梳理程序流程&lt;/h2&gt;
&lt;p&gt;通过查看源代码可以梳理出程序流程图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/529380/201809/529380-20180907150736856-512907530.png&quot; alt=&quot;程序流程图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tensorflow-实现旋转操作&quot;&gt;2.2 tensorflow 实现旋转操作&lt;/h2&gt;
&lt;p&gt;根据上述的流程图, 可以实现对tensorflow的rot90操作;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def rot90(tensor,k=1,axes=[1,2],name=None):
    '''
    autor:lizh
    tensor: a tensor 4 or more dimensions
    k: integer, Number of times the array is rotated by 90 degrees.
    axes: (2,) array_like
        The array is rotated in the plane defined by the axes.
        Axes must be different.
    
    -----
    Returns
    -------
    tensor : tf.tensor
             A rotated view of `tensor`.
    See Also: https://www.tensorflow.org/api_docs/python/tf/image/rot90 
    '''
    axes = tuple(axes)
    if len(axes) != 2:
        raise ValueError(&quot;len(axes) must be 2.&quot;)
        
    tenor_shape = (tensor.get_shape().as_list())
    dim = len(tenor_shape)
    
    if axes[0] == axes[1] or np.absolute(axes[0] - axes[1]) == dim:
        raise ValueError(&quot;Axes must be different.&quot;)
        
    if (axes[0] &amp;gt;= dim or axes[0] &amp;lt; -dim 
        or axes[1] &amp;gt;= dim or axes[1] &amp;lt; -dim):
        
        raise ValueError(&quot;Axes={} out of range for tensor of ndim={}.&quot;
            .format(axes, dim))
    k%=4
    if k==0:
        return tensor
    if k==2:
        img180 = tf.reverse(tf.reverse(tensor, axis=[axes[0]]),axis=[axes[1]],name=name)
        return img180
    
    axes_list = np.arange(0, dim)
    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],axes_list[axes[0]]) # 替换
    
    print(axes_list)
    if k==1:
        img90=tf.transpose(tf.reverse(tensor,axis=[axes[1]]), perm=axes_list, name=name)
        return img90
    if k==3:
        img270=tf.reverse( tf.transpose(tensor, perm=axes_list),axis=[axes[1]],name=name)
        return img270&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码测试&quot;&gt;2.3 代码测试&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 加载库
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf

# 手写体数据集 加载
from tensorflow.examples.tutorials.mnist import input_data
mnist = input_data.read_data_sets(&quot;/home/lizhen/data/MNIST/&quot;, one_hot=True)

sess=tf.Session()
#选取数据 4D
images = mnist.train.images
img_raw = images[0,:] # [0,784]
img=tf.reshape(img_raw,[-1,28,28,1]) # img 现在是tensor
# 绘图
def fig_2D_tensor(tensor):# 绘图
    #plt.matshow(tensor, cmap=plt.get_cmap('gray'))
    plt.matshow(tensor) # 彩色图像
    # plt.colorbar() # 颜色条
    plt.show()
# 显 显示 待旋转的图片
fig_2D_tensor(sess.run(img)[0,:,:,0]) # 提取ndarray
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/529380/201809/529380-20180907151005548-35511585.png&quot; alt=&quot;待操作的图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单的测试一下代码&quot;&gt;简单的测试一下代码:&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;img11_rot=rot90(img,2) # 旋转两次90
fig_2D_tensor(sess.run(img11_rot)[0,:,:,0]) # 打印图像

img12_rot=rot90(img,1,[1,1]) # 抛出异常,  测试 Axes must be different.
img13_rot=rot90(img,1,[0,6]) # 抛出异常,  测试 Axes must be different.

img14_rot=rot90(img,axes=[1,5])# 抛出异常,测试out of range.

img14_rot=rot90(img,axes=[-1,2]) # -1的下标是倒数第二个,测试out of range.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试结果&quot;&gt;测试结果:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/529380/201809/529380-20180907150813445-615764448.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/529380/201809/529380-20180907150823741-1500658467.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/529380/201809/529380-20180907150850031-1920532632.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;okey了,现在可以用了.&lt;br/&gt;.....&lt;/p&gt;
&lt;p&gt;额,,,,,最近才发现tensorflow的最新版本,大约就在前几天发布的新版本(14天前, 1.10.1 )上已经添加了对2D,3D图像的操作,支持[B,W,H,C]格式的tensor做出旋转&lt;/p&gt;
&lt;p&gt;星期五, 07. 九月 2018 02:49下午&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 07:16:00 +0000</pubDate>
<dc:creator>修雨轩陈</dc:creator>
<og:description>tensorflow 旋转矩阵的函数实现方法 关键字: rot90, tensorflow 1. 背景 在做数据增强的操作过程中, 很多情况需要对图像旋转和平移等操作, 针对一些特殊的卷积(garbo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/greentomlee/p/9604806.html</dc:identifier>
</item>
<item>
<title>AI体验类产品竞品分析 - 冉庆之</title>
<link>http://www.cnblogs.com/zhuzq/p/9604639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuzq/p/9604639.html</guid>
<description>&lt;p class=&quot;16&quot;&gt;&lt;span&gt;人工智能&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;Artificial Intelligence&lt;span&gt;），&lt;/span&gt;&lt;span&gt;简称&lt;/span&gt;AI。上个世纪50年代就有一批年轻的科学家提出了这一概念，经历过50多年的长足发展，信息化建设的脚步不断加快，机器人战胜人类国际棋手已是常事，智能家具已经走进家庭生活，工业机器手也是屡见不鲜，无人驾驶汽车也已上路......近年来，各大信息产业都在人工智能领域摩拳擦掌，各个领域的产品争相放艳，国内其中有高达42%的企业应用计算机视觉相关技术，其次是语音和自然语言处理，两者占比总和43%。这些关键技术可运用在现实的各个等方面，比如安防、金融、硬件、营销、驾驶、医疗等领域。人工智能世界离我们生活越来越近了，业界的大厂商都开放了人工智能的体验平台，比如现在触手能及的就有百度和腾讯的两款AI体验小程序。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.1 产品功能框架层&lt;/span&gt;&lt;/h2&gt;
&lt;h3 align=&quot;justify&quot;&gt;2.1.1&lt;span&gt;百度&lt;/span&gt;&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144235367-871615292.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;2.1.2&lt;span&gt;腾讯&lt;/span&gt;&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144256000-353042221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;strong&gt;2.2. &lt;span&gt;产品功能范围层&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.2.1. &lt;span&gt;功能对比&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;功能&lt;/p&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;产品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;百度AI体验中心&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;腾讯AI体验中心&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;文字识别&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;图像识别&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;人脸识别&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;图片特效&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;语音识别&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;语音合成&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;语言分析&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;情感分析&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;机器翻译&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;198&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;知识问答&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;215&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;236&quot;&gt;
&lt;p class=&quot;15&quot; align=&quot;center&quot;&gt;√&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 align=&quot;justify&quot;&gt;2.2.2. &lt;span&gt;详细对比&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;15&quot;&gt;1&lt;span&gt;）&lt;/span&gt; 视觉功能&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;百度&lt;/span&gt;AI体验中心在视觉功能上分为了两个主题模块：“图像技术”和“人脸与人体识别”，图像技术包含文字识别和图像识别两块内容，二者都包含较多功能；人脸和人体识别目前只有人脸识别这一模块，人体识别暂未开放。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;腾讯&lt;/span&gt;AI体验中心将所有视觉功能整合成“计算机视觉”模块，集合文字识别、图片识别和人脸识别功能，还增加了图片特效的模块，包含功能类型比较丰富，涉及面偏娱乐化。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144428812-2136229917.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144436139-119363206.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144443538-1223705257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;15&quot;&gt;2） 自然语言处理&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;百度&lt;/span&gt;AI体验中心这一模块只包含了自然语言基础技术，只有词法分析和情感倾向分析两个功能，而且这个主题放在了最右边的菜单栏。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;腾讯&lt;/span&gt;AI体验中心包含的自然的语言处理功能就比较丰富了，不但包含文本分析、语义分析、情感分析几大模块，而且还有机器翻译和知识问答模块。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144545387-1130744725.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144550777-198641146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;15&quot;&gt;2）语音技术&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;在语音技术模块下，二者功能都是一致的了，不同是是百度采用的是纵向布局，分别划分了单独的模块；而腾讯是横向布局，将两块功能放在&lt;/span&gt;“语音合成”以这个主题下面。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144612960-1439510976.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144618366-1795070260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.2.3. 功能总结&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;218&quot;&gt;
&lt;p align=&quot;center&quot;&gt;产品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;533&quot;&gt;
&lt;p align=&quot;center&quot;&gt;总结&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;218&quot;&gt;
&lt;p align=&quot;center&quot;&gt;百度&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;533&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;1、体验功能较少，只覆盖基础功能&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2、主题菜单栏分类较多，布局略显紧凑&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3、Logo&lt;span&gt;添加在功能项中，主题中则没有&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;218&quot;&gt;
&lt;p align=&quot;center&quot;&gt;腾讯&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;533&quot; readability=&quot;9&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;1、体验功能丰富，偏娱乐化&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2、模块内布局层次重叠，二级分类字体偏小&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3、主题中有添加&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;，功能项中没有&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;2.3. 产品界面结构层&lt;/h2&gt;
&lt;h3&gt;2.3.1．首页截图对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144841683-1977273214.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907144847490-1262805243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;界面结构总结&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;191&quot;&gt;
&lt;p align=&quot;center&quot;&gt;产品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;539&quot;&gt;
&lt;p align=&quot;center&quot;&gt;对比&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;191&quot;&gt;
&lt;p align=&quot;center&quot;&gt;百度&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;539&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;1、顶部以蓝色调为主，没有突出“百度科技”标识&lt;/p&gt;
&lt;p&gt;2、背景文字采用的是左对齐&lt;/p&gt;
&lt;p&gt;3、功能项加入&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;，突出功能体验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、功能栏布局为模块化样式，吸引用户点击&lt;/p&gt;
&lt;p&gt;5、菜单栏选中样式变化不明显&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;191&quot;&gt;
&lt;p align=&quot;center&quot;&gt;腾讯&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;539&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;1、顶部内容丰富，色调厚重，不断强调腾讯科技&lt;/p&gt;
&lt;p&gt;2、背景文字采用居中对齐，更为醒目&lt;/p&gt;
&lt;p&gt;3、功能栏布局为列表样式，层次较为重叠&lt;/p&gt;
&lt;p&gt;4、菜单栏加入&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;，便于切换分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5、菜单选中样式为背景变蓝，突出当前页面位置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;2.4．产品功能使用体验&lt;/h2&gt;
&lt;h3 class=&quot;16&quot;&gt;2.4.1.文字识别功能&lt;/h3&gt;
&lt;p&gt;文字识别是大家比较关注的一个功能了，能够快速准确地将图片中的文字提取出来，在工作和学习上都会带来很大的便利。特地挑选了一张比较模糊的图片，来对比一下这两款产品的文字识别体验。（左图为百度产品，右图为腾讯产品）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145018015-2068481959.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145023998-82370601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能体验总结&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;238&quot;&gt;
&lt;p align=&quot;center&quot;&gt;产品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;565&quot;&gt;
&lt;p align=&quot;center&quot;&gt;对比&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;238&quot;&gt;
&lt;p align=&quot;center&quot;&gt;百度&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;565&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、识别结果会在原图中标明位置，呈现一一对应关系&lt;/p&gt;
&lt;p&gt;2、底部有提示应用场景&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;238&quot;&gt;
&lt;p align=&quot;center&quot;&gt;腾讯&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;565&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;1&lt;span&gt;、识别出的内容较少，且将明显横排字眼分开成列识别结果&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 class=&quot;15&quot;&gt;2.4.2.人脸识别功能&lt;/h3&gt;
&lt;p class=&quot;15&quot;&gt;人脸识别算是比较好玩的功能了，可以实际检测出人脸的数据，将颜值直接传达出来，爱美的人应该都不会放过这个功能体验。同样找一张比较抽象的图片来对比一下。&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145138053-1888857694.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145143576-84522769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;小结一下：同样左边百度，右边腾讯。然而这个结果就差强人意了，百度将这个肉眼可辨的黑人识别成了黄种人，腾讯直接检测不出这是张人脸。可能目前人脸识别只局限于正面检测吧，那就选一张正经一点的照片来测试对比吧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145217341-294154039.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1472552/201809/1472552-20180907145222935-1913918830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能体验总结&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;214&quot;&gt;
&lt;p align=&quot;center&quot;&gt;产品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;590&quot;&gt;
&lt;p align=&quot;center&quot;&gt;对比&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;214&quot;&gt;
&lt;p align=&quot;center&quot;&gt;百度&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;590&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、识别结果内容丰富，数据与实际较为接近，表达形式偏官方术语&lt;/p&gt;
&lt;p&gt;2、页面布局整齐紧凑、合理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;214&quot;&gt;
&lt;p align=&quot;center&quot;&gt;腾讯&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;体验中心&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;590&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;1、解读内容较少，年龄数据与实际偏低，表达形式偏娱乐性&lt;/p&gt;
&lt;p&gt;2、照片模块背景留空太多，布局显得空洞&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;根据以上的对比分析，百度&lt;/span&gt;AI体验功能实用性较强，腾讯产品的直观效果好，功能娱乐多样化。但总体上来说产品效果还远远达不到非常智能的水平，AI的发展还是有很长的路要走呢，不过改进应该会来得很快。“未来已来，只是分布不均匀而已”，让我们尽情期待吧。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 06:57:00 +0000</pubDate>
<dc:creator>冉庆之</dc:creator>
<og:description>未来已来，只是分布的不均匀而已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuzq/p/9604639.html</dc:identifier>
</item>
<item>
<title>深度学习应用系列（三）| 使用 TFLite Android构建自己的图像识别App - 可可心心</title>
<link>http://www.cnblogs.com/hutao722/p/9603113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hutao722/p/9603113.html</guid>
<description>&lt;p&gt;        深度学习要想落地实践，一个少不了的路径即是朝着智能终端、嵌入式设备等方向发展。但终端设备没有GPU服务器那样的强大性能，那如何使得终端设备应用上深度学习呢？&lt;/p&gt;
&lt;p&gt;所幸谷歌已经推出了TFMobile，去年又更进一步，推出了TFLite，其应用思路为在GPU服务器上利用迁移学习训练自己的模型，然后将定制化模型移植到TFLite上，&lt;/p&gt;
&lt;p&gt;终端设备仅利用模型做前向推理，预测结果。本文基于以下三篇文章而成：&lt;/p&gt;
&lt;p&gt;      相信大家掌握后，也能轻松定制化自己的图像识别应用。&lt;/p&gt;
&lt;h2&gt;第一步. 准备数据&lt;/h2&gt;
&lt;p&gt;　　数据下载地址为：&lt;a href=&quot;http://download.tensorflow.org/example_images/flower_photos.tgz&quot; target=&quot;_blank&quot;&gt;http://download.tensorflow.org/example_images/flower_photos.tgz&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;　　这是一个关于花分类的图片集合，下载解压后，可以看出有5个品种分类：daisy（雏菊）、dandelion（蒲公英）、rose（玫瑰）、sunflower（向日葵）、tulip（郁金香）。&lt;/p&gt;
&lt;p&gt;　　我们的目的即是通过重新训练预编译模型，得到一个花类识别的模型。&lt;/p&gt;
&lt;h2&gt;第二步. 重新训练&lt;/h2&gt;
&lt;h3&gt;　　1. 挑选预编译模型&lt;/h3&gt;
&lt;p&gt;        从上述“谷歌提供的预编译模型”列表中，我们大体可以看出分为两类模型，一种是Float Models（浮点数模型），一种是Quantized Models（量化模型），什么区别呢？&lt;/p&gt;
&lt;p&gt;　　其实Float Models表示为一种高精度值的模型，该模型意味着模型size较大，识别精度更高、识别时长更长，适合高性能终端设备；而Quantized Models则反之，是低精度值的模型，其精度采取固定的8位大小，故其模型size较小，识别精度低、识别时长较短，适合低性能终端设备，更细的说明可以参见 &lt;a href=&quot;https://www.tensorflow.org/performance/quantization&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/performance/quantization&lt;/a&gt; 　。&lt;/p&gt;
&lt;p&gt;　　我们的手机设备更新换代很快，一般可以使用Float Models。在这个模型下，有不少预编译模型可选，对于本文来说，主要集中为Inception 和Mobilenet两种架构。　　&lt;/p&gt;
&lt;p&gt;       注意Mobilenet其实也分为很多种类，如Mobilenet_V1_0.50_224，其中第三个参数为模型大小比例值（只能算是近似，不准确），分为0.25/0.50/0.75/1.0四个比例值，第四个参数为图片大小，其值有128/160/192/224四种值。&lt;/p&gt;
&lt;p&gt;　　有兴趣想观察各模型层次结构的可通过以下代码查看：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow.gfile as gfile

MODEL_PATH &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home/yourname/Documents/mobilenet_v1_1.0_224/frozen_graph.pb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(unusedArgv):
    with tf.Graph().as_default() as graph:
        with gfile.FastGFile(MODEL_PATH, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            graph_def &lt;/span&gt;=&lt;span&gt; tf.GraphDef()
            graph_def.ParseFromString(f.read())
            tf.import_graph_def(graph_def, name&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; op &lt;span&gt;in&lt;/span&gt;&lt;span&gt; graph.get_operations():
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tensor &lt;span&gt;in&lt;/span&gt;&lt;span&gt; op.values():
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tensor)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    tf.app.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　考虑到测试手机性能还不赖，我们选择mobilenet_v1_1.0_224这个版本作为我们的预编译模型。&lt;/p&gt;
&lt;h3&gt;　　2. 下载训练代码&lt;/h3&gt;
&lt;p&gt;　　需要下载训练模型代码和android相关代码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/googlecodelabs/tensorflow-for-poets-2&lt;/span&gt;
&lt;span&gt;
cd tensorflow&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;-poets-&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，scripts目录下的retrain.py是我们需要关注的，这个代码目前仅支持Inception_v3和Mobilenet两种预编译模型，默认的训练模型为Inception_v3。&lt;/p&gt;
&lt;h3&gt;　　3. 重新训练模型&lt;/h3&gt;
&lt;p&gt;　　两种模型的训练命令不同，若走默认的Inception_v3模型，可通过如下命令：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
python -&lt;span&gt;m scripts.retrain \&lt;br/&gt;--learning_rate=0.01 \
  &lt;/span&gt;--bottleneck_dir=tf_files/&lt;span&gt;bottlenecks \
  &lt;/span&gt;--how_many_training_steps=&lt;span&gt;4000&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--model_dir=tf_files/models/&lt;span&gt; \
  &lt;/span&gt;--output_graph=tf_files/&lt;span&gt;retrained_graph.pb \
  &lt;/span&gt;--output_labels=tf_files/&lt;span&gt;retrained_labels.txt \
  &lt;/span&gt;--image_dir=tf_files/flower_photos \
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若走Mobilenet模型，可通过如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
python -&lt;span&gt;m scripts.retrain \&lt;br/&gt;　--learning_rate=0.01 \ 　
  &lt;/span&gt;--bottleneck_dir=tf_files/&lt;span&gt;bottlenecks \
  &lt;/span&gt;--how_many_training_steps=&lt;span&gt;4000&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--model_dir=tf_files/models/&lt;span&gt; \
  &lt;/span&gt;--output_graph=tf_files/&lt;span&gt;retrained_graph.pb \
  &lt;/span&gt;--output_labels=tf_files/&lt;span&gt;retrained_labels.txt \
  &lt;/span&gt;--image_dir=tf_files/&lt;span&gt;flower_photos \
  &lt;/span&gt;--architecture=mobilenet_1.0_224
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模型命令解释如下：&lt;/p&gt;
&lt;p&gt;　--architecture 为架构类型，支持mobilenet和Inception_v3两种&lt;br/&gt;   --image_dir 为数据地址，假定你在tensorflow-for-poets-2目录下建立了tflite目录，把花图片集放入其中&lt;br/&gt;   --output_labels 最后训练生成模型的标签，由于花图片集合已经按照子目录进行了分类，故retrained_labels.txt最后包含了上述五种花的分类名称&lt;br/&gt;   --output_graph 最后训练生成的模型&lt;br/&gt;   --model_dir 命令启动后，预编译模型的下载地址&lt;br/&gt;   --how_many_training_steps 训练步数，不指定的话默认为4000&lt;br/&gt;   --bottleneck_dir用来把top层的训练数据缓存成文件&lt;br/&gt;   --learning_rate 学习率&lt;br/&gt;   此外，还有些参数可以根据需要进行调整：&lt;br/&gt;   --testing_percentage 把图片按多少比例划分出来当做test数据，默认为10&lt;br/&gt;   --validation_percentage 把图片按多少比例划分出来当做validation数据，默认为10，这两个值设置完后，training数据占比80%&lt;br/&gt;   --eval_step_interval 多少步训练后进行一次评估，默认为10&lt;br/&gt;   --train_batch_size 一次训练的图片数，默认为100&lt;br/&gt;   --validation_batch_size 一次验证的图片数，默认为100&lt;br/&gt;   --random_scale 给定一个比例值，然后随机扩大训练图片的大小，默认为0&lt;br/&gt;   --random_brightness 给定一个比例值，然后随机增强或减弱训练图片的明亮程度，默认为0&lt;br/&gt;   --random_crop 给定一个比例值，然后随机裁剪训练图片的边缘值，默认为0 &lt;/p&gt;
&lt;h3&gt;    4. 检验训练效果&lt;/h3&gt;
&lt;p&gt;    我们用Mobilenet_1.0_224进行训练，完成后找一张图片看看是否能正确识别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python -&lt;span&gt;m scripts.label_image \
  &lt;/span&gt;--graph=tf_files/&lt;span&gt;retrained_graph.pb  \
  &lt;/span&gt;--image=tf_files/flower_photos/daisy/3475870145_685a19116d.jpg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Evaluation &lt;span&gt;time&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;-image): &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.010s

daisy (score&lt;/span&gt;=&lt;span&gt;0.62305&lt;/span&gt;&lt;span&gt;)
tulips (score&lt;/span&gt;=&lt;span&gt;0.22490&lt;/span&gt;&lt;span&gt;)
dandelion (score&lt;/span&gt;=&lt;span&gt;0.14169&lt;/span&gt;&lt;span&gt;)
roses (score&lt;/span&gt;=&lt;span&gt;0.00966&lt;/span&gt;&lt;span&gt;)
sunflowers (score&lt;/span&gt;=&lt;span&gt;0.00071&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是准确地识别了daisy出来。&lt;/p&gt;
&lt;h3&gt;    5. 转换模型格式&lt;/h3&gt;
&lt;p&gt;      pb格式是不能运行在TFLite上的，TFLite吸收了谷歌的protobuffer优点，创造了FlatBuffer格式，具体表现就是后缀名为.tflite的文件。&lt;/p&gt;
&lt;p&gt;     上述TOCO的官网已经介绍了如何通过命令行把pb格式转成为tflite文件，或者在代码里也可以转换格式。不仅支持pb格式，也支持HDF5文件格式转换成tflite，实现了与其他框架的模型共享。&lt;/p&gt;
&lt;p&gt;     那如何转呢？本例通过命令行方式转换。若训练模型为Inception_v3，命令行方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;toco \
  &lt;/span&gt;--graph_def_file=tf_files/&lt;span&gt;retrained_graph.pb \
  &lt;/span&gt;--output_file=tf_files/&lt;span&gt;optimized_graph.lite \
  &lt;/span&gt;--input_format=&lt;span&gt;TENSORFLOW_GRAPHDEF \
  &lt;/span&gt;--output_format=&lt;span&gt;TFLITE \
  &lt;/span&gt;--input_shape=&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;299&lt;/span&gt;,&lt;span&gt;299&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--input_array=&lt;span&gt;Mul \
  &lt;/span&gt;--output_array=&lt;span&gt;final_result \
  &lt;/span&gt;--inference_type=&lt;span&gt;FLOAT \
  &lt;/span&gt;--input_data_type=FLOAT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     若训练模型为mobilenet，命令行方式则如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;toco \
  &lt;/span&gt;--graph_def_file=tf_files/&lt;span&gt;retrained_graph.pb \
  &lt;/span&gt;--output_file=tf_files/&lt;span&gt;optimized_graph.lite \
  &lt;/span&gt;--input_format=&lt;span&gt;TENSORFLOW_GRAPHDEF \
  &lt;/span&gt;--output_format=&lt;span&gt;TFLITE \
  &lt;/span&gt;--input_shape=&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;224&lt;/span&gt;,&lt;span&gt;224&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt; \
  &lt;/span&gt;--input_array=&lt;span&gt;input \
  &lt;/span&gt;--output_array=&lt;span&gt;final_result \
  &lt;/span&gt;--inference_type=&lt;span&gt;FLOAT \
  &lt;/span&gt;--input_data_type=FLOAT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要说明几点：&lt;/p&gt;
&lt;p&gt;       --input_array 参数表示模型图结构的入口tensor op名称，mobilenet的入口名称为input，Inception_v3的入口名称为Mul，为什么这样？可查看scripts/retrain.py代码里内容：&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt; architecture == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inception_v3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint: disable=line-too-long&lt;/span&gt;
    data_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://download.tensorflow.org/models/image/imagenet/inception-2015-12-05.tgz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint: enable=line-too-long&lt;/span&gt;
    bottleneck_tensor_name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool_3/_reshape:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    bottleneck_tensor_size &lt;/span&gt;= 2048&lt;span&gt;
    input_width &lt;/span&gt;= 299&lt;span&gt;
    input_height &lt;/span&gt;= 299&lt;span&gt;
    input_depth &lt;/span&gt;= 3&lt;span&gt;
    resized_input_tensor_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mul:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    model_file_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;classify_image_graph_def.pb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    input_mean &lt;/span&gt;= 128&lt;span&gt;
    input_std &lt;/span&gt;= 128
&lt;span&gt;elif&lt;/span&gt; architecture.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mobilenet_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):&lt;br/&gt;...
    data_url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://download.tensorflow.org/models/mobilenet_v1_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    data_url &lt;/span&gt;+= version_string + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + size_string + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_frozen.tgz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    bottleneck_tensor_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MobilenetV1/Predictions/Reshape:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    bottleneck_tensor_size &lt;/span&gt;= 1001&lt;span&gt;
    input_width &lt;/span&gt;=&lt;span&gt; int(size_string)
    input_height &lt;/span&gt;=&lt;span&gt; int(size_string)
    input_depth &lt;/span&gt;= 3&lt;span&gt;
    resized_input_tensor_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;input:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中的resized_input_tensor_name即是新生成模型的入口名称，大家也可以通过上面“1.挑选预编译模型”的代码可视化查看新生成的模型层次结构。所以名称必须正确写对，否则运行该命令会抛出“ValueError: Invalid tensors 'input' were found” 的异常。&lt;/p&gt;
&lt;p&gt;       --output_array则是模型的出口名称。为什么是final_result这个名称，因为在scripts/retrain.py里有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;parser.add_argument(
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--final_tensor_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      type&lt;/span&gt;=&lt;span&gt;str,
      default&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;final_result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      help&lt;/span&gt;=&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;\
      The name of the output classification layer in the retrained graph.\
      &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
  )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       即出口名称默认为final_result。&lt;/p&gt;
&lt;p&gt;       --input_shape 需要注意的是mobilenet的训练图片大小为224，而Inception_v3的训练图片大小为299。&lt;/p&gt;
&lt;p&gt;       最后optimized_graph.lite即是我们要移植到android上的模型文件啦。&lt;/p&gt;

&lt;h2&gt;第三步. Android TFLite &lt;/h2&gt;
&lt;h3&gt;       1. 下载Android Studio&lt;/h3&gt;
&lt;p&gt;         这一步骤不是本文重点，请大家自行在 https://developer.android.com/studio/ 进行下载安装，安装最新的SDK和NDK。&lt;/p&gt;
&lt;h3&gt;　　2. 引入工程&lt;/h3&gt;
&lt;p&gt;　　从android studio上引入 tensorflow-for-poets-2/android/tflite 下的代码，共有四个类，有三个类是跟布局打交道，而我们只需要关注ImageClassifier.java类。&lt;/p&gt;
&lt;h3&gt;        3. 导入模型&lt;/h3&gt;
&lt;p&gt;　　可通过命令行方式把生成的模型导入上述工程的资源目录下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp&lt;/span&gt; tf_files/optimized_graph.lite android/tflite/app/src/main/assets/&lt;span&gt;mobilenet.lite 
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; tf_files/retrained_labels.txt android/tflite/app/src/main/assets/mobilenet.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　 4. 修改ImageClassifier.java类&lt;/h3&gt;
&lt;p&gt;　　注意修改四个地方即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Name of the model file stored in Assets. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String MODEL_PATH = &quot;mobilenet.lite&quot;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Name of the label file stored in Assets. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String LABEL_PATH = &quot;mobilenet.txt&quot;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DIM_IMG_SIZE_X = 224; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是inception，改成299&lt;/span&gt;
  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DIM_IMG_SIZE_Y = 224; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是inception，改成299&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5. 运行观看效果&lt;/h3&gt;
&lt;p&gt;　　连上手机后，点击“Run”-&amp;gt;&quot;Run app&quot;即会部署app到手机上，此时任何被摄像头捕获的图片都会按照标签里的5个分类进行识别排名。&lt;/p&gt;
&lt;p&gt;       我们可以通过百度搜一些这五种类别的花进行识别，以看看其识别的正确率。&lt;/p&gt;

&lt;p&gt;后记：根据我的测试结果，在花的图片集上，mobilenet_1.0_244模型生成的新模型识别率较高，而inception_v3模型生成的新模型识别率较低或不准。&lt;/p&gt;
&lt;p&gt;       建议大家新的数据集可在两种模型间进行比较，以找到最适合自己的模型。&lt;/p&gt;





&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 07 Sep 2018 06:51:00 +0000</pubDate>
<dc:creator>可可心心</dc:creator>
<og:description>深度学习要想落地实践，一个少不了的路径即是朝着智能终端、嵌入式设备等方向发展。但终端设备没有GPU服务器那样的强大性能，那如何使得终端设备应用上深度学习呢？ 所幸谷歌已经推出了TFMobile，去年又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hutao722/p/9603113.html</dc:identifier>
</item>
<item>
<title>算法篇（前序）——Java的集合 - 阿苍老师</title>
<link>http://www.cnblogs.com/nullering/p/9600821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullering/p/9600821.html</guid>
<description>&lt;p&gt;菜鸟拙见，望请纠正：附上JDK参考文档：链接：&lt;a href=&quot;https://pan.baidu.com/s/1eLqG4eTXYSTY1-IxMQqA4Q&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1eLqG4eTXYSTY1-IxMQqA4Q&lt;/a&gt; 密码：33x0   以及算法篇全文链接  &lt;a href=&quot;https://www.cnblogs.com/nullering/p/9536339.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/nullering/p/9536339.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一：前言&lt;/h2&gt;
&lt;p&gt;　　说完了数据结构的基础认知，我想扯一个外传——Java的集合。Java的集合只是一些能够盛放对象的容器，而这些容器的实现，则是用了不同的数据结构，我们在使用Java语言时，这些集合类就是我们最好的工具。&lt;/p&gt;
&lt;p&gt;　　如图所示，这是Java的集合的抽象类和具体的实现类，抽象接口类不能实例化，必须由具体实现类进行实例化操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906205331943-217494251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906210336092-820696784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二：List接口及其实现类ArrayList&lt;/h2&gt;
&lt;p&gt; List是元素有序并且可以重复的集合，被称为序列&lt;/p&gt;
&lt;p&gt;List可以精确的控制每个元素的插入位置，或删除某个位置元素&lt;/p&gt;
&lt;h3&gt;基本操作：&lt;/h3&gt;
&lt;p&gt;（1）、添加&lt;/p&gt;
&lt;p&gt;void add(int Index , E element):在list的指定位置插入元素&lt;/p&gt;
&lt;p&gt;void addAll(int index , Collection&amp;lt;? Extends E&amp;gt; e):将指定collection中的所有元素插入到列表中的指定位置&lt;/p&gt;
&lt;p&gt;（2）、删除&lt;/p&gt;
&lt;p&gt;E  remove(int Index)：删除指定位置的元素，并返回该元素；&lt;/p&gt;
&lt;p&gt;（3）、修改&lt;/p&gt;
&lt;p&gt;E  set(int index , E element)：替换指定位置的元素，并返回被替换的元素&lt;/p&gt;
&lt;p&gt;（4）、获取&lt;/p&gt;
&lt;p&gt;Int  indexOf(Object o):返回指定元素第一次出现的索引，如果该list中不含则返回-1；&lt;/p&gt;
&lt;p&gt;E   get(int Index)：返回指定位置的元素;&lt;/p&gt;
&lt;p&gt;List&amp;lt;E&amp;gt; sublist(int fromIndex , int toIndex):返回列表指定的fromIndex(包括)和toIndex(不包括)之间的部分视图（list）;&lt;/p&gt;
&lt;h3&gt;实现类ArrayList（常用）&lt;/h3&gt;
&lt;p&gt;ArrayList——数组序列，是List的一个重要实现类&lt;/p&gt;
&lt;p&gt;ArrayList底层是由数组实现的，&lt;strong&gt;可以动态增加容量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体操作参考JDK参考文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906214810464-725606961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;实现类LinkedList&lt;/h3&gt;
&lt;p&gt;LinkedList是基于链表实现的，是一个双向循环列表。不是线程安全的。&lt;/p&gt;
&lt;p&gt;具体操作参考JDK参考文档&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906215009538-272708571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三：Set接口及其实现类&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180907135654817-1609771789.jpg&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　集合Set是Collection的子接口，Set不允许其数据元素重复出现，也就是说在Set中每一个数据元素都是唯一的。&lt;/p&gt;
&lt;p&gt;虽然集合号称存储的是 Java 对象，但实际上并不会真正将 Java 对象放入 Set 集合中，只是在 Set 集合中保留这些对象的引用而言。也就是说：Java 集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的 Java 对象。&lt;/p&gt;
&lt;h3&gt;基本操作：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906215711930-1704122832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;实现类HashSet（常用）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;HashSet通过Hash算法排布集合内的元素，所谓的Hash算法就是把任意长度的输入（又叫做预映射），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射。对于不同类型的信息，其散列值公式亦不完全相同。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当我们使用HashSet存储自定义类时，需要在自定义类中重写equals和hashCode方法，主要原因是集合内不允许有重复的数据元素，在集合校验元素的有效性时（数据元素不可重复），需要调用equals和hashCode验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体方法请参考说明文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180906221317385-1244017102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;实现类TreeSet&lt;/h3&gt;
&lt;p&gt;　　 TreeSet可以确保集合元素处于排序状态。TreeSet采用红黑树的数据结构来存储集合元素。&lt;/p&gt;
&lt;p&gt;　　TreeSet会调用集合元素的compareTo(Object o)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式是自然排序。 &lt;br/&gt;　　Java提供了一个Comparable接口，该接口定义一个compareTo(Object o)方法，该方法返回一个整数值，&lt;strong&gt;实现该接口的类必须实现该方法&lt;/strong&gt;，实现该接口的类的对象就可以比较大小。当一个对象调用该方法与另一个对象进行比较时，例如：obj1.compareTo(obj2)，如果该方法返回0，则代表这两个对象相等；如果该方法返回一个正整数，则表明obj1大于obj2；如果该方法返回一个负整数，则表明obj1小于obj2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(People o1, People o2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先按年龄比较，如果年龄相等，则按姓名&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(o1.getAge()==&lt;span&gt;o2.getAge())
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.getName().compareTo(o2.getName());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; o1.getAge()-&lt;span&gt;o2.getAge();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他方法参考JDK文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180907113419098-1828062115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四：Queue接口及其实现类&lt;/h2&gt;
&lt;p&gt;顾名思义，Queue用于模拟队列这种数据结构。队列先进先出。&lt;/p&gt;
&lt;p&gt;　　 Queue接口有一个PriorityQueue实现类。除此之外，Queue还有一个Deque接口，Deque代表一个“双端队列”，双端队列可以同时从两端删除或添加元素，因此Deque可以当作栈来使用。java为Deque提供了ArrayDeque实现类和LinkedList实现类。&lt;/p&gt;

&lt;p&gt;Queue接口中定义了如下的几个方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void add(Object e):&lt;/strong&gt;　　将指定元素插入到队列的尾部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;object element():&lt;/strong&gt;　　获取队列头部的元素，但是不删除该元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean offer(Object e):&lt;/strong&gt;　　将指定的元素插入此队列的尾部。当使用容量有限的队列时，此方法通常比add(Object e)有效。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object peek():&lt;/strong&gt;　　返回队列头部的元素，但是不删除该元素。如果队列为空，则返回null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object poll():&lt;/strong&gt;　　返回队列头部的元素，并删除该元素。如果队列为空，则返回null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object remove():&lt;/strong&gt;　　获取队列头部的元素，并删除该元素。&lt;/p&gt;
&lt;h3 id=&quot;priorityqueue实现类&quot;&gt;PriorityQueue实现类&lt;/h3&gt;
&lt;p&gt;　　PriorityQueue是一个比较标准的队列实现类。之所以是比较标准的原因是PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序。因此当调用peek()或者是poll()的方法取出队列中的元素通常都是最小的元素。&lt;/p&gt;
&lt;p&gt;PriorityQueue不允许插入null元素，还要对队列元素进行排序。具体方法参考JDK文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180907115925579-861454340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五：Map接口及其实现类&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;Map提供了一种映射关系，其中的元素是以键值对（key-value）的形式存储的，能够实现根据key快速查找value；&lt;/li&gt;
&lt;li&gt;key值不可重复，value值可以重复，一个value值可以和很多key值形成对应关系，每个建最多只能映射到一个值&lt;/li&gt;
&lt;li&gt;Map 中元素的顺序取决于迭代器迭代时的顺序，有的实现类保证了元素输入输出时的顺序，比如说 TreeMap；有的实现类则是无序的，比如 HashMap。&lt;/li&gt;
&lt;li&gt;key,value 都可以是任何引用类型的数据，包括 null&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180907140137494-162545575.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;1、添加：&lt;br/&gt;　　V put(K key, V value) （可以相同的key值，但是添加的value值会覆&lt;br/&gt;盖前面的，返回值是前一个，如果没有就返回null）&lt;br/&gt;　　putAll(Map&amp;lt;? extends K,? extends V&amp;gt; m) 从指定映射中将所有映射关&lt;br/&gt;系复制到此映射中（可选操作）。&lt;br/&gt;2、删除&lt;br/&gt;　　remove() 删除关联对象，指定key对象&lt;br/&gt;　　clear() 清空集合对象&lt;br/&gt;3、获取&lt;br/&gt;　　value get(key); 可以用于判断键是否存在的情况。当指定的键不存在的时候，返&lt;br/&gt;回的是null。&lt;/p&gt;&lt;p&gt;4、判断：&lt;br/&gt;　　boolean isEmpty() 长度为0返回true否则false&lt;br/&gt;　　boolean containsKey(Object key) 判断集合中是否包含指定的key&lt;br/&gt;　　boolean containsValue(Object value) 判断集合中是否包含指定的value&lt;br/&gt;5、长度：&lt;br/&gt;　　Int size（）&lt;/p&gt;
&lt;h3&gt; 实现类HashMap(重点)&lt;/h3&gt;
&lt;p&gt;　　HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。&lt;/p&gt;
&lt;p&gt; 　　HashMap的底层主要是基于数组，链表和红黑树来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。&lt;/p&gt;
&lt;p&gt;　　具体方法看JDK文档，建议看一下其源码实现，因为HashMap以后用到的很多，只是知道其几个简单的使用方法是远远不够的，但是这里只是简单认知，我就不再赘述，如果可以，以后会出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180907133903750-841128467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;实现类TreeMap&lt;/h3&gt;
&lt;p&gt;TreeMap是非线程安全的。 &lt;br/&gt;　　可以采用可以通过Collections类的静态方法synchronizedMap获得线程安全：Map m = Collections.synchronizedSortedMap(new TreeMap(…));&lt;/p&gt;
&lt;p&gt;TreeMap是用键来进行升序顺序来排序的。通过Comparable 或 Comparator来排序。 （实现和TreeSet基本一致）。&lt;/p&gt;
&lt;h3 id=&quot;hashmap与treemap的区别&quot;&gt;HashMap与TreeMap的区别&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;实现方式 &lt;br/&gt;HashMap:基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode（）和equals（）[可以重写hashCode（）和equals（）],为了优化HashMap空间的使用，您可以调优初始容量和负载因子。 &lt;br/&gt;（1）HashMap（）： 构建一个空的哈希映像 &lt;br/&gt;（2）HashMap（Map m）： 构建一个哈希映像，并且添加映像m的所有映射 &lt;br/&gt;（3）HashMap（int initialCapacity）： 构建一个拥有特定容量的空的哈希映像 &lt;br/&gt;（4）HashMap（int initialCapacity, float loadFactor）： 构建一个拥有特定容量和加载因子的空的哈希映像 &lt;br/&gt;TreeMap:基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。 &lt;br/&gt;（1）TreeMap（）：构建一个空的映像树 &lt;br/&gt;（2）TreeMap（Map m）： 构建一个映像树，并且添加映像m中所有元素 &lt;br/&gt;（3）TreeMap（Comparator c）： 构建一个映像树，并且使用特定的比较器对关键字进行排序 &lt;br/&gt;（4）TreeMap（SortedMap s）： 构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序&lt;/li&gt;
&lt;li&gt;用途 &lt;br/&gt;HashMap：适用于在Map中插入、删除和定位元素。 &lt;br/&gt;TreeMap：适用于按自然顺序或自定义顺序遍历键（key)。 &lt;br/&gt;HashMap通常比TreeMap快一点（树和哈希表的数据结构使然），建议多使用HashMap,在需要排序的Map时候才用TreeMap.&lt;/li&gt;
&lt;/ol&gt;





</description>
<pubDate>Fri, 07 Sep 2018 06:03:00 +0000</pubDate>
<dc:creator>阿苍老师</dc:creator>
<og:description>菜鸟拙见，望请纠正：附上JDK参考文档：链接：https://pan.baidu.com/s/1eLqG4eTXYSTY1-IxMQqA4Q 密码：33x0 以及算法篇全文链接 https://www</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullering/p/9600821.html</dc:identifier>
</item>
<item>
<title>.Net Core应用框架Util介绍（二） - 何镇汐</title>
<link>http://www.cnblogs.com/xiadao521/p/Util-Introduction-2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiadao521/p/Util-Introduction-2.html</guid>
<description>&lt;h2&gt;&lt;span&gt;Util的开源地址&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/dotnetcore/util&quot;&gt;https://github.com/dotnetcore/util&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Util的开源协议&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Util以&lt;strong&gt;MIT&lt;/strong&gt;协议开源，这是目前最宽松的开源协议，你不仅可以用于商业项目，还能把Util的代码放进你的框架，放心使用。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Util的命名&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;Util&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个名字看上去不怎么高大上，很多人劝我换个霸气点的，比如USharp。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过我还是坚持使用Util，因为他简短，也更好记忆，Util很多类名与.Net或第三方类库重名，需要使用完全限定名来调用它，比如Util.Helpers.String.Join()。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一个经常被提到的问题是Util是一个常用词汇，容易与其它类库产生冲突，不过Util的定位是为小团队提供帮助，一般情况下，这不会产生问题，另外Util会封装大量常用类库，冲突会在Util内部处理。在极端的情况下，你还能使用using创建别名来自己解决。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;Util的使用方法&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Util尚未成熟，所以我还没有发布正式版，Nuget发布的是预览版，如果你想通过Nuget引用，请勾选“&lt;strong&gt;包括预发行版&lt;/strong&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　尚未成熟并不表示Util Bug很多，还无法使用，只是还没达到我心目中理想的那个样子。对于中小项目，很多常用功能都已经封装，最新版本的Util已经在我的项目上使用，已知问题已全部修复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　被问得最多的问题是Util有&lt;strong&gt;文档&lt;/strong&gt;吗，抱歉，还真&lt;strong&gt;没有&lt;/strong&gt;。我的打算是待Util成熟后，再建立完整文档，并创建一个官网。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，我希望有更多人能参与进来一起分享技术，一个人精力和能力都是有限的，进度会非常缓慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于目前没有文档，你只能通过查看源码进行学习，这有点痛苦，不过也能让你基础打得更扎实一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你如果对Util及Util引入的相关技术还不太了解，那么不应该将它应用在一个非常紧急的项目上，这会导致风险。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util主要是我用来满足自己项目的产物，所以它可能不能完全满足你的需求，作为项目负责人，你必须有能力扩展它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学习Util的&lt;strong&gt;起点&lt;/strong&gt;是提供的Demo，我演示了CRUD的基本用法，不过这个Demo是用Angular开发的，环境上有点折腾，后续我会再提供一个Asp.Net Core Mvc基于JQuery的示例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个Angular Demo不仅演示了&lt;strong&gt;服务端CRUD&lt;/strong&gt;的封装，同时也演示了&lt;strong&gt;TagHelper&lt;/strong&gt;是如何与Angular配合起来让UI变得清晰省力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当你把这个Demo运行起来，就可以通过查看源码的方式了解它的运行机制，基本了解清楚后，再自己做几个复杂点的Demo来练手，有把握再运用到你的项目上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你在使用中发现&lt;strong&gt;Bug&lt;/strong&gt;，请不要亲自动手，你应该到Github提交&lt;strong&gt;Issue&lt;/strong&gt;，或直接到群里来找我，我会以迅雷不及掩耳之势搞定它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你希望我为你扩展某些功能，也可以提Issue，不过我会评估是否具有价值，冷门需求只能靠你自己完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你喜欢折腾，推荐你创建自己的应用框架，将Util以及其它框架的源码慢慢吸收到你的框架中，这能让你最大限度的了解框架内部实现机制，并能大幅增强你的编码和设计能力。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于完全不能或完全不想折腾的朋友，建议你关掉网页，好好享受生活，因为新的技术，特别是前端技术真的很折腾。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你有新项目，希望采用.Net Core开发，Util将是一个很好的起点，他将为你节省大把的时间，我最近几年踩过的坑都埋在了Util中。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Util的开发环境&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;.Net Core SDK&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我们在使用.Net Framework时，通常是在更换VS时升级SDK。VS换代需要好几年，所以你可能并不太关注SDK的版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过进入.Net Core，情况有所不同，一般几个月就会更新一次，Util会紧跟.Net Core最新版本，你必须关注SDK的版本问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你不知道在哪里下载SDK，在百度搜索可不是那么容易，下面介绍下载.Net Core SDK的正确姿势。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在任意项目上右键，弹出菜单中选择属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907085044202-1854594643.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在“&lt;strong&gt;目标框架&lt;/strong&gt;”选择“&lt;strong&gt;安装其它框架&lt;/strong&gt;”，进入下载页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907085100139-1231350616.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载页面选择最新的正式版本SDK，&lt;strong&gt;SDK&lt;/strong&gt;是给开发机器用的，&lt;strong&gt;Runtime&lt;/strong&gt;是在部署到服务器上用的，&lt;strong&gt;SDK已经包含了Runtime&lt;/strong&gt;，注意这个区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907085455415-1719690376.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;开发工具&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;VS 2017最新版本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;如果你还在用VS2015，但又想用最新技术，这可能让你吃尽苦头。不要担心，VS2015和VS2017可以共存，多安装一个就好了。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Resharper(R#)最新版本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　R#是一个VS上的重构插件，开发代码不一定需要R#，但你想开发出更优雅的代码，R#就是一个神兵利器。VS的代码提示功能很强，但R#能把VS的提示功能再提升几个档次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　R#的主要毛病是非常卡，如果你的电脑没有固态硬盘，内存连16G也没有，建议你不要用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;SqlServer 2012+&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　我现在主要用Sql Server来做测试，生产环境使用的是PgSql。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前提供的Demo包含一个Sql Server的建库脚本，所以你需要安装它，尚未提供EF迁移和其它数据库脚本，后续有空会增加上来。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;PostgreSql(PgSql)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;MySql&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;前端环境&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　几年前，如果需要某个Js组件，我会从网上下载并把它放进项目，然后在页面上引用它。每当有版本更新，我就到它的官网下载一个新的。为了让页面加载得更快，我会在发布时用打包工具把多个Js文件打成一个，然后再用压缩工具给它瘦身。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果只引用了少量几个Js文件，这样做没什么问题，简单易懂，是个人就能做。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　随着前端需求的增加，你慢慢引入了十几个，几十个乃至数百个Js文件，维护它们就是一场噩梦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果能让文件下载，版本更新，打包压缩全部自动化，你就能从大堆Js文件中解脱出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;NodeJs&lt;/strong&gt;与它的生态系统解决了这个难题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　NodeJs是利用Google Chrome V8引擎来执行Js的运行环境，这样Js就可以脱离浏览器运行了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先查看你的机器是否已安装NodeJs，在命令行输入node -v 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180906202000417-668611895.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;如果你跟我一样，对命令行十分反感，是时候作出一些改变了，某些场景命令行比UI操作更便利，还有一些情况必须使用命令行，比如Npm还原。&lt;/span&gt;&lt;span&gt;采用.Net Core最大的亮点是可以跨平台部署，换句话说，你可以把代码部署到Linux， 为了节省服务器资源，通常不会在Linux服务器上启动UI，你必须能通过黑屏命令行操控它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可以看到我的机器上安装的NodeJs版本是8.9.3，如果你的NodeJs版本很低，可能会让后续操作失败，另外我听到群里有同学反馈，NodeJs版本过高也会出现问题，我还没有测试过，如果你环境上出现问题，可以安装我这个版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你可以通过这个地址&lt;a href=&quot;http://nodejs.cn/download&quot;&gt;http://nodejs.cn/download&lt;/a&gt;下载安装NodeJs。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;安装完成，记得重启电脑，这是怪异问题的必杀技之一。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907043935304-1855071573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Npm(Node Package Manager)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Npm&lt;/strong&gt;是NodeJs包管理器，它类似于我们的N&lt;/span&gt;uget。&lt;span&gt;当安装完NodeJs，Npm会被默认安装。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端非常混乱，包管理器就有很多，比如Bower，VS在之前的版本默认提供了对Bower的支持，不过后面删除了它，这也从侧面说明了Npm击败了竞争对手，成为前端事实上的标准包管理器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当你需要某个Js组件时，不用再千里迢迢打开网站下载，只需打开Npm配置文件package.json，把你要下载的Js组件写上去就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907052238956-666959869.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　想知道某个Js组件有没有更新，只需在package.json移动鼠标即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907052256255-1850124068.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　或者直接在package.json的版本号位置敲代码提示快捷键，Ctrl + 空格 或 Ctrl + J。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907052311865-1705727701.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当你把需要的Js组件添加到package.json，Ctrl + S保存以后，VS就开始自动下载了，这让你心情非常愉快，VS不愧是银河系最强的IDE。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　过了一个小时，你吃完饭回来，发现它还在下载，难道是网络不好？这是由我国众所周知的原因导致的。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要想让Npm还原成功，你必须禁止VS Npm自动还原，先来设置下VS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907054052691-434599930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在国内如果没有特殊装置，Npm基本无法还原成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一种选择是使用淘宝镜像，这是我初期使用的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一种方法是使用&lt;strong&gt;Yarn&lt;/strong&gt;来还原Npm，有人给我推荐了它，使用后发现这家伙的下载速度更快，我现在也强烈推荐给你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先去这里&lt;a href=&quot;https://yarn.bootcss.com/docs/install/#windows-stable&quot;&gt;https://yarn.bootcss.com/docs/install/#windows-stable&lt;/a&gt;下载一个Yarn安装包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907055330063-2031325781.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成，命令行&lt;strong&gt;yarn –v&lt;/strong&gt;，看看是否安装成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907060101040-1668439168.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;Webpack&lt;/strong&gt;是NodeJs生态中用来进行自动化构建的工具。它非常强大，打包压缩不过是它的冰山一角。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端的混乱来自开源项目的百家争鸣和低耦合的设计理念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前端技术一片繁荣，这得益于开源项目的蓬勃发展，低耦合的设计理念让你在遇到相关问题只需寻找对应组件，集成上来就能结束战斗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这确实很好，但却苦了我们这些码农。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你必须对各种框架，各种组件，以及这些组件中的插件非常了解，否则你无法工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这大幅增加了学习成本，专业前端人员薪资高确实是有道理的，看看别人吃了多少苦头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还在怀念.Net前几年高度集成的开发方式吗？那个时代已经过去了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Webpack之前，还有Grunt，Gulp等构建工具，Webpack凭借递归查找依赖的能力打败了它们，成为前端事实上的标准自动化构建工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Webpack是一个插件体系，拥有丰富的插件，不论打包压缩，还是将Ts编译成Js，都有相应的插件支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Webpack表面上很易用，这是建立在你对它的插件很了解的基础上，如果你是个新手，想添加某个特性，但却不知道哪个插件具有这个功能，通过查看webpack官网并不一定能解决问题，因为很多插件的说明非常模糊，你只能自己多尝试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　虽然如此，你也大可不必泄气，你所使用的前端框架，会为你做好Webpack配置，基本不用操心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一旦把Webpack配置好，它就会非常易用，自动化构建的整个流程被隐藏在一行npm命令中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Webpack通过Npm安装，所以不需要单独安装它了。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Util Demo运行说明&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;开发环境确认&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　上面已经简要介绍了Util的开发环境，为了将Util Demo运行起来，我们再确认一遍。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;你安装了VS 2017最新版本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你安装了.Net Core SDK正式版最新版本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你安装了Sql Server 2012或更新版本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你安装了NodeJs。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你安装了Yarn。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你已经从Github下载了Util，并保证是最新版本。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;运行数据库脚本&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　由于我开发采用的是Db First，所以给你提供了一个Sql Server的建库脚本，这也是我平时的测试方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不要担心，你完全可以使用Code First方式，这只是我的个人习惯问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请将Sample.sql建库脚本复制到Sql Server并执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907091618373-1294056912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;下面，你需要修改Util.Samples.Webs项目数据库连接字符串，它在这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907111938154-425129924.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;还原Npm&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;strong&gt;Util.Samples.Webs&lt;/strong&gt;项目上右键，选择“在文件资源管理器中打开文件夹”，进入Util.Samples.Webs项目根目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907132033391-5904886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　按住&lt;strong&gt;Shift&lt;/strong&gt;，在Util.Samples.Webs项目根目录空白位置&lt;strong&gt;右键&lt;/strong&gt;，选择“&lt;strong&gt;在此处打开命令窗口&lt;/strong&gt;”。这样做的目的是打开一个命令行，并且路径是Util.Samples.Webs项目根目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907094338454-578500753.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：不同的操作系统，菜单提示不同，我用的是Windows 2008 R2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　输入命令&lt;strong&gt;yarn&lt;/strong&gt;，开始还原。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907094450204-2031485225.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果你人品爆发，可能没有看见任何错误就还原成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过在大部分情况下，你都会得到一个错误。这是由大名鼎鼎的巨无霸先生&lt;strong&gt;node-sass&lt;/strong&gt;导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907103121812-1478222364.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　node-sass是用来帮助将scss编译成css的编译工具，scss是一个css预处理器，给css增加了变量，控制结构等编程元素。Boostrap等现代前端框架都采用scss编写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我观察到，node-sass从npm下载后，会运行脚本，然后访问github及其它Url，毫无疑问，这将被拦截在摇篮中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　安装node-sass的解决方案是&lt;strong&gt;cnpm&lt;/strong&gt;，这是淘宝提供的npm包安装工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先来安装cnpm。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g cnpm --registry=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;registry.npm.taobao.org&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　下面用cnpm来安装node-sass。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cnpm install node-sass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907103310536-1966915819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你运气不是太差，npm包应该还原成功了。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你是第一次接触npm，在还原完成后，项目根目录会出现一个node_modules文件夹，你细数了一下文件的数目，大吃一惊，居然有10几万个文件，这就是低耦合的悲剧，习惯就好。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在cnpm还原node-sass的提示中，有一个版本警告信息，不要管它，目前我使用的是node-sass 4.7.2这个版本，更高版本有编码错误，如果在scss中存在中文注释，会编译失败。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我发现npm治愈了我的升级强迫症，你如果也有这个毛病，请小心测试后再升级。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当你发现cnpm如此强悍，连node-sass这个巨无霸都败在它的脚下，你可能会直接用cnpm还原所有npm包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：cnpm还原的包与npm并不完全相同，特别是使用VS开发前端项目，问题尤其严重，在打开解决方案时，会卡住好几分钟，&lt;strong&gt;你只应该用cnpm来还原node-sass，其它的采用yarn&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;执行Webpack构建流程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　你只需要一行npm命令就能把webpack构建流程跑起来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907112540221-1149862316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果这个过程没有报任何异常，说明构建成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果有异常，通常说明npm包尚未完全还原成功。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;运行Demo&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　终于你可以把Demo运行起来了，F5把浏览器弹起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907115135599-366019441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907115256080-1155556327.png&quot; alt=&quot;&quot;/&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是一个貌不惊人的Crud Demo，看到这个界面很多人可能大失所望，搞了半天就这么个东西？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不要急，我给你展示的只是最简单的东西，好让你快速上手，Util封装的是Angular官方提供的Material这套组件库，你可以到Material的官网https://material.angular.io/看看它包含哪些东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Material缺乏像Ng Alain这样的脚手架主界面，我项目上是前端人员自己搭建的。另外似乎国内用Material风格来开发管理后台的并不多，基于这个原因，我已经有封装Ng Alain + Ng-Zorro的计划。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;另一个Demo页面展示了树型Crud操作，将向你展示Util是如何对树型关系进行封装的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/41709/201809/41709-20180907123306263-1377955848.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;注意事项&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　如果你根据上面的介绍还是无法将npm还原成功，可能有以下原因。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;VS进程锁定了node_modules目录，你在还原时最好把VS关掉。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果你之前已经还原过，可能存在垃圾文件干扰，这需要先删除node_modules目录，你可以直接删除文件夹，不过可能需要半小时以上时间，你应该通过命令行来删除它。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install rimraf -g
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rimraf node_modules
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　删除node_modules目录也应该关掉VS，以免干扰。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;你需要特别关照node_sass，没事就cnpm搞它一下。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　本文介绍了Util的运行环境以及注意事项，初次接触现代前端环境会有点不适，不过挺过去你就能再多干几年。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　未完待续，下一篇将对Util Demo的运行机制进行介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　写文需要动力，请大家多多支持，点下推荐，Github点下星星。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Util应用框架交流一群: 24791014&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 05:29:00 +0000</pubDate>
<dc:creator>何镇汐</dc:creator>
<og:description>Util的开源地址 https://github.com/dotnetcore/util Util的开源协议 Util以MIT协议开源，这是目前最宽松的开源协议，你不仅可以用于商业项目，还能把Util</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiadao521/p/Util-Introduction-2.html</dc:identifier>
</item>
<item>
<title>【死磕 Spring】----- IOC 之 加载 Bean - chenssy</title>
<link>http://www.cnblogs.com/chenssy/p/9603928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenssy/p/9603928.html</guid>
<description>&lt;blockquote readability=&quot;2.2058823529412&quot;&gt;
&lt;p&gt;原文出自：&lt;a href=&quot;http://cmsblogs.com&quot; class=&quot;uri&quot;&gt;http://cmsblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看一段熟悉的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;);
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(resource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是 Spring 中编程式使用 IOC 容器，通过这四段简单的代码，我们可以初步判断 IOC 容器的使用过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;获取 BeanFactory&lt;/li&gt;
&lt;li&gt;根据新建的 BeanFactory 创建一个BeanDefinitionReader对象，该Reader 对象为资源的解析器&lt;/li&gt;
&lt;li&gt;装载资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个过程就分为三个步骤：资源定位、装载、注册，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cmsblogs.qiniudn.com/spring-201805281001.png&quot; alt=&quot;spring-201805281001&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;资源定位&lt;/strong&gt;。我们一般用外部资源来描述 Bean 对象，所以在初始化 IOC 容器的第一步就是需要定位这个外部资源。在上一篇博客（&lt;a href=&quot;http://cmsblogs.com/?p=2656&quot;&gt;【死磕 Spring】----- IOC 之 Spring 统一资源加载策略&lt;/a&gt;）已经详细说明了资源加载的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装载&lt;/strong&gt;。装载就是 BeanDefinition 的载入。BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IOC 容器的内部数据结构：BeanDefinition。在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，在配置文件中每一个 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt; 都对应着一个BeanDefinition对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册&lt;/strong&gt;。向IOC容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistery 接口来实现的。在 IOC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IOC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。在这里需要注意的一点是这个过程并没有完成依赖注入，依赖注册是发生在应用第一次调用 &lt;code&gt;getBean()&lt;/code&gt; 向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;资源定位在前面已经分析了，下面我们直接分析加载，上面提过 &lt;code&gt;reader.loadBeanDefinitions(resource)&lt;/code&gt; 才是加载资源的真正实现，所以我们直接从该方法入手。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
        return loadBeanDefinitions(new EncodedResource(resource));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从指定的 xml 文件加载 Bean Definition，这里会先对 Resource 资源封装成 EncodedResource。这里为什么需要将 Resource 封装成 EncodedResource呢？主要是为了对 Resource 进行编码，保证内容读取的正确性。封装成 EncodedResource 后，调用 &lt;code&gt;loadBeanDefinitions()&lt;/code&gt;，这个方法才是真正的逻辑实现。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
        if (logger.isInfoEnabled()) {
            logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
        }

        // 获取已经加载过的资源
        Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
        if (currentResources == null) {
            currentResources = new HashSet&amp;lt;&amp;gt;(4);
            this.resourcesCurrentlyBeingLoaded.set(currentResources);
        }

        // 将当前资源加入记录中
        if (!currentResources.add(encodedResource)) {
            throw new BeanDefinitionStoreException(
                    &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
        }
        try {
            // 从 EncodedResource 获取封装的 Resource 并从 Resource 中获取其中的 InputStream
            InputStream inputStream = encodedResource.getResource().getInputStream();
            try {
                InputSource inputSource = new InputSource(inputStream);
                // 设置编码
                if (encodedResource.getEncoding() != null) {
                    inputSource.setEncoding(encodedResource.getEncoding());
                }
                // 核心逻辑部分
                return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
            }
            finally {
                inputStream.close();
            }
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(
                    &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
        }
        finally {
            // 从缓存中剔除该资源
            currentResources.remove(encodedResource);
            if (currentResources.isEmpty()) {
                this.resourcesCurrentlyBeingLoaded.remove();
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过 &lt;code&gt;resourcesCurrentlyBeingLoaded.get()&lt;/code&gt; 来获取已经加载过的资源，然后将 encodedResource 加入其中，如果 resourcesCurrentlyBeingLoaded 中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。完成后从 encodedResource 获取封装的 Resource 资源并从 Resource 中获取相应的 InputStream ，最后将 InputStream 封装为 InputSource 调用 &lt;code&gt;doLoadBeanDefinitions()&lt;/code&gt;。方法 &lt;code&gt;doLoadBeanDefinitions()&lt;/code&gt; 为从 xml 文件中加载 Bean Definition 的真正逻辑，如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
        try {
            // 获取 Document 实例
            Document doc = doLoadDocument(inputSource, resource);
            // 根据 Document 实例****注册 Bean信息
            return registerBeanDefinitions(doc, resource);
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (SAXParseException ex) {
            throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                    &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
        }
        catch (SAXException ex) {
            throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                    &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
        }
        catch (ParserConfigurationException ex) {
            throw new BeanDefinitionStoreException(resource.getDescription(),
                    &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
        }
        catch (IOException ex) {
            throw new BeanDefinitionStoreException(resource.getDescription(),
                    &quot;IOException parsing XML document from &quot; + resource, ex);
        }
        catch (Throwable ex) {
            throw new BeanDefinitionStoreException(resource.getDescription(),
                    &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心部分就是 try 块的两行代码。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;doLoadDocument()&lt;/code&gt; 方法，根据 xml 文件获取 Document 实例。&lt;/li&gt;
&lt;li&gt;根据获取的 Document 实例注册 Bean 信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实在 &lt;code&gt;doLoadDocument()&lt;/code&gt;方法内部还获取了 xml 文件的验证模式。如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
        return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
                getValidationModeForResource(resource), isNamespaceAware());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;getValidationModeForResource()&lt;/code&gt; 获取指定资源（xml）的验证模式。所以 &lt;code&gt;doLoadBeanDefinitions()&lt;/code&gt;主要就是做了三件事情。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;getValidationModeForResource()&lt;/code&gt; 获取 xml 文件的验证模式&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;loadDocument()&lt;/code&gt; 根据 xml 文件获取相应的 Document 实例。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;registerBeanDefinitions()&lt;/code&gt; 注册 Bean 实例。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/chenssy/blog-home/raw/master/image/weixin-tips.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Sep 2018 04:54:00 +0000</pubDate>
<dc:creator>chenssy</dc:creator>
<og:description>原文出自：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenssy/p/9603928.html</dc:identifier>
</item>
<item>
<title>机器学习入门 一、理解机器学习+简单感知机(JAVA实现) - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/9584393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/9584393.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先先来讲讲闲话&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　如果让你现在去搞机器学习，你会去吗？不会的话是因为你对这方面不感兴趣，还是因为你觉得这东西太难了，自己肯定学不来？如果你觉的太难了，很好，相信看完这篇文章，你就会有胆量踏入机器学习这一领域。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　机器学习(Machine-Learning)，一个在才学一年编程的人看来十分高大尚的东西，不知不觉就接触了它。暑假的时候表哥给我布置了任务，在github上有一篇&lt;strong&gt;DeepLearningFlappyBird&lt;/strong&gt;，他当时要我一天之内先让这段代码跑起来，然后第二天再把这段代码翻译成C++的.......wtf？？？我当时一脸懵逼，一个才学编程一年不到的，C和C++的水平也就差不多是大学课堂教完后的那种，跑起来可能还算容易，但要翻译？！！   饶了我吧  orz。。。当时配了一天的环境，到那天晚上快12点了，终于跑起来了。然后到了第二天，我先去查了查tensorflow，opencv3在VS上使用，发现根本搞不定。。。我电脑上装的是VS2013，里面只有32位的，emmmm。。得下个VS2017，看了看电脑空间，不够了！好的，放弃，以后有空闲得慌了再来搞吧。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前几天开学了，还没什么事干，突然就想到机器学习了（其实dalao提到了感知机这东西），就试着去做了做，也就当个入门吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;再来聊聊机器学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;　机器学习说白了跟人类学习是一样的，只不过机器可以无止境的学习，并且，机器学习时完全不需要懂什么原理，只要知道怎么去实现就行。就如Alpha Go，你们觉得它懂得棋理吗？我觉得肯定不懂，但通过对无数的棋谱的学习，让人觉得它肯定掌握了围棋的真谛。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　机器学习的标准范式表达&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;对于一个Task及其Performance的度量方法，给出特定的Algorithm，能够通过利用Experience Data不断提高在该Task上的&lt;br/&gt;Performance的方法，就称为机器学习。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;其实这个定义就是“学习”的全部含义，这个事情按照机器的思路来做，就是机器学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说白了，只要算法合理，每次学习都能有提高，机器有足够的运算能力，就能将机器的能力达到极致从而超越人类。机器学习的本质就是建立（&quot;数据&quot;——&quot;认知&quot;）关系库。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;下面就来讲讲感知机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　先扯扯定义：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;感知机（perceptron）是二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。感知机的学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知机模型对新的实例进行预测的，因此属于判别模型。感知机由Rosenblatt于1957年提出的，是神经网络和支持向量机的基础。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　拿二维平面举例，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1413964/201809/1413964-20180907115259394-1713427313.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;看这张图，很明显，直线没有将红蓝点完全分开在两个区域，我们可以将其称为错误的直线，感知机要做的，就是根据各点坐标，将错误的直线纠正为正确的，这样得到的直线就是训练的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说了这么多，要怎么实现呢？&lt;span&gt;　　看下面的流程图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1413964/201809/1413964-20180907121545996-368440442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 判断所有点的位置关系,进行分类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; classify() {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;flag) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arrayList.size(); i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Anwser(arrayList.get(i)) &amp;lt;= 0&lt;span&gt;) {
                    Update(arrayList.get(i));
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i + 1 ==&lt;span&gt; arrayList.size()) {
                    flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 点乘返回sum
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Dot(&lt;span&gt;double&lt;/span&gt;[] w, &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[] x) {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; x.length; i++&lt;span&gt;) {
            sum &lt;/span&gt;+= w[i] *&lt;span&gt; x[i];
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 返回函数计算的值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Anwser(Point point) {
        System.out.println(Arrays.toString(w));
        System.out.println(b);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; point.y * (Dot(w, point.x) +&lt;span&gt; b);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果还有疑问，那可能就是w与b怎么修改了，我们会定义一个变量η（0≤η≤1）作为步长，在统计学是中成为学习速率。步长越大，梯度下降的速度越快，更能接近极小点。如果步长过大，有可能导致跨过极小点，导致函数发散；如果步长过小，有可能会耗很长时间才能达到极小点。默认为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于wi   wi+=η*y*xi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于b      b+=η*y&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(Point point) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; w.length; i++&lt;span&gt;) {
            w[i] &lt;/span&gt;+= eta * point.y *&lt;span&gt; point.x[i];
        }
        b &lt;/span&gt;+= eta *&lt;span&gt; point.y;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;这样，我们就可以完成成w、b的更新了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;将上面的步骤组合起来，就可以实现感知机了。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谈谈自己的想法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　写了这个感知机后，发现机器学习并不是想象当中那么难，其实只要知道怎么去算就可以了（目前比较浅显的理解，可能我还没接触到难的地方），而且Python中，有关机器学习的库可以说是很完善了，如果熟悉了这些库的用法，即使不懂算法，也时能用这些库来做开发的，要知道算法岗和开发岗还是不一样的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;这是我选取的测试用例及结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         Point p1 = &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { 0, 0, 0, 1 }, -1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Point p2 = &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { 1, 0, 0, 0 }, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Point p3 = &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { 2, 1, 0, 0 }, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Point p4 = &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { 2, 1, 0, 1 }, -1);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;170&quot;&gt;
&lt;pre&gt;
[0.0, 0.0, 0.0, 0.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;0.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;-1.0&lt;span&gt;
[&lt;/span&gt;0.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;-1.0&lt;span&gt;
[&lt;/span&gt;1.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;1.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;1.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;1.0, 0.0, 0.0, -1.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;-1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;-1.0&lt;span&gt;
[&lt;/span&gt;-1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;-1.0&lt;span&gt;
[&lt;/span&gt;0.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;0.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;1.0, -1.0, 0.0, -2.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;-1.0, -2.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;-1.0, -2.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;0.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -3.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -4.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -5.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;0.0, -2.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;1.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;2.0&lt;span&gt;
[&lt;/span&gt;2.0, -1.0, 0.0, -6.0&lt;span&gt;]
&lt;/span&gt;2.0
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 07 Sep 2018 04:37:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>首先先来讲讲闲话 如果让你现在去搞机器学习，你会去吗？不会的话是因为你对这方面不感兴趣，还是因为你觉得这东西太难了，自己肯定学不来？如果你觉的太难了，很好，相信看完这篇文章，你就会有胆量踏入机器学习这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/9584393.html</dc:identifier>
</item>
<item>
<title>[AI开发]将深度学习技术应用到实际项目 - 周见智</title>
<link>http://www.cnblogs.com/xiaozhi_5638/p/9600418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozhi_5638/p/9600418.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文介绍如何将基于深度学习的目标检测算法应用到具体的项目开发中，体现深度学习技术在实际生产中的价值，算是AI算法的一个落地实现。本文算法部分可以参见前面几篇博客：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaozhi_5638/p/9268715.html&quot;&gt;[AI开发]Python+Tensorflow打造自己的计算机视觉API服务&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaozhi_5638/p/9376784.html&quot;&gt;[AI开发]基于深度学习的视频多目标跟踪实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaozhi_5638/p/9519665.html&quot;&gt;[AI开发]视频多目标跟踪高级版(离自动驾驶又‘近’了一点点)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaozhi_5638/p/9553916.html&quot;&gt;[AI开发]centOS7.5上基于keras/tensorflow深度学习环境搭建&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交通领域是深度学习技术可以发挥强大作用的一个领域。道路交通的安全性要求比较高，道路监控设备比较完备，这些设备每天可以产生无数的视频数据，而这些数据非常有利于深度学习模型的训练。网上也可以下载到非常多的交通数据集，包括行人、车辆、道路两旁的基础设施比如路灯、信号灯、公交站牌等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何利用交通监控设备产生的视频数据，来进行视频的自动分析呢？显然这是一个深度学习的应用场景。下面介绍，如何利用深度学习技术自动检测车辆交通事件，比如高速路上违规停车、逆行、闯入行人、占用应急车道等等事件。下面是最终的一个效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/104032/201809/104032-20180906192015032-1202574226.png&quot; alt=&quot;&quot; width=&quot;956&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一台主机设备，可同时实时检测8路高清监控视频，若有异常事件，会实时发出警告。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个系统构成非常简单，业务流程也相对简单。下面是两个主要的业务分支：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;视频流分支&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/104032/201809/104032-20180906192208818-1250811436.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，直接将跟踪得到的轨迹叠加到视频帧中，然后编码将其推到Nginx服务器中，供web播放器播放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据流分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/104032/201809/104032-20180906192246485-1153708504.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，根据跟踪得到的轨迹，检测每辆车的交通事件，将其结果写入mysql数据库。另外一个服务模块定期统计数据，供web模块进行数据显示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务器环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）centOS 7.5 (3.10.0内核)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）Python 3.6 + tensorflow-gpu 1.9 + keras 2.2.2 + 各种python库；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）CUDA 9.0 + CUDNN 7.1 + Nvidia显卡驱动384.130；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）Tomcat + Mysql + Java；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）i7 8核 + Nvidia GTX 1080显卡；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是服务器软硬件环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统组成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图是软件系统组成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/104032/201809/104032-20180906192344332-501471871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中最上部分是核心算法在整个系统中的位置。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;模型训练&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型训练最主要的是要收集高质量、各种天气、各种视频角度、各种道路状况下的素材。下面是素材的一个简单分类，数量大约为10W+张。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按场景：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）外场&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）隧道&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按天气：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）晴天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）阴天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）雨天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）夜晚（红外）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按摄像机角度：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）正前方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）正后方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）侧前方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）侧后方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按目标类型：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）行人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）汽车&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）客车&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）货车&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（高速摄像机一般安装太远，其他目标太小，因此不考虑其他目标）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;按路况：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）流畅&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）拥堵&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）严重拥堵&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;素材标注是个体力活，找个好用的标注工具可以事半功倍。自己写了一个标注工具，体验不是特别好，但是适合本项目素材的标注。相关连接参见这里：-------link--------------&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;事件类型/功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由跟踪得到的轨迹，可以分别检测出道路面的异常事件，包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）行人闯入事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）异常停车事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）逆行/倒车事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）占用应急车道事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）货车占用超车道&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6）非机动车闯入事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7）拥堵级别告警&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8）车型计数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9）平均车速统计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/104032/201809/104032-20180906192549890-939626554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文没有源码，思路仅供参考。&lt;/p&gt;

</description>
<pubDate>Fri, 07 Sep 2018 04:34:00 +0000</pubDate>
<dc:creator>周见智</dc:creator>
<og:description>本文介绍如何将基于深度学习的目标检测算法应用到具体的项目开发中，体现深度学习技术在实际生产中的价值，算是AI算法的一个落地实现。本文算法部分可以参见前面几篇博客： [AI开发]Python+Tenso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaozhi_5638/p/9600418.html</dc:identifier>
</item>
</channel>
</rss>