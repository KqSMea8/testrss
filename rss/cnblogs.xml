<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>函数声明、函数表达式、匿名函数、立即执行函数详解 - lichunchun</title>
<link>http://www.cnblogs.com/lichunyan/p/7894867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichunyan/p/7894867.html</guid>
<description>&lt;p&gt; 定义函数的方式有三种：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;span&gt;函数声明&lt;/span&gt;：     function  函数名称  （参数：可选）   {   函数体  }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;span&gt;函数表达式&lt;/span&gt;： var express= function  函数名称：可选  （参数：可选）   {  函数体 }      &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;span&gt;构造函数&lt;/span&gt;：     var fun =new  Function(参数：可选);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最常用的是函数声明和函数表达式。&lt;/p&gt;
&lt;p&gt;一：函数声明&lt;/p&gt;
&lt;p&gt;从上面的定义可以看出，函数声明是以关键字function开头声明一个函数，然后必须具备一个函数名称。&lt;/p&gt;
&lt;p&gt;函数声明有一个非常重要的特征&lt;span&gt;：&lt;span&gt;&lt;code&gt;函数声明提升&lt;/code&gt;&lt;/span&gt;，&lt;/span&gt;javascript引擎在解析代码时，函数声明&lt;span&gt;将会被提升到当前&lt;/span&gt;作用域的顶部（跟变量提升非常类似）。正是因为这个特征，所以可以把函数声明放在调用它的语句后面。&lt;/p&gt;
&lt;p&gt; 如下例：&lt;/p&gt;
&lt;p&gt;foo(&quot;hello&quot;);   //输出  hello&lt;/p&gt;
&lt;p&gt;function foo(name){&lt;/p&gt;
&lt;p&gt;console.log(name);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;二：函数表达式&lt;/p&gt;
&lt;p&gt;从上面的定义可以看出，函数表达式是作为表达式语句的一部分存在；当它没有函数名称的时侯，则称为匿名函数；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;匿名函数&lt;/span&gt;：function ( 参数 ) { 函数体 }   匿名函数属于函数表达式。&lt;/p&gt;
&lt;p&gt;函数表达式与函数声明的区别是：函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式，所以，调用它的语句不可以放在它之前。&lt;/p&gt;
&lt;p&gt;如下例：&lt;/p&gt;
&lt;p&gt;express();  //报错，函数调用必须在函数表达式之后&lt;/p&gt;
&lt;p&gt;console.log(express);  //undefined  &lt;span&gt; &lt;span&gt;变量提升&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var express=function () {&lt;/p&gt;
&lt;p&gt;console.log(&quot;hello word!&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;三：立即执行函数&lt;/p&gt;
&lt;p&gt;先看几个例子：&lt;/p&gt;
&lt;p&gt;var express=function () {&lt;/p&gt;
&lt;p&gt;console.log(&quot;hello word!&quot;);&lt;/p&gt;
&lt;p&gt;}();    //运行，发现函数直接执行，结果输出了&quot;hello word!&quot;&lt;/p&gt;

&lt;p&gt;function () {&lt;/p&gt;
&lt;p&gt;console.log(&quot;hello word!&quot;);&lt;/p&gt;
&lt;p&gt;}();   //报错    Uncaught SyntaxError: Unexpected token )   &lt;/p&gt;
&lt;p&gt;因为以function开头，认为是函数声明，结果没有函数名，就报错了&lt;/p&gt;

&lt;p&gt;function foo() {&lt;br/&gt;console.log(&quot;hello word!&quot;);&lt;br/&gt;}();   //报错    Uncaught SyntaxError: Unexpected token )    （&lt;span&gt;注意：网上好多文章写的不报错，一看就没有自己验证过&lt;/span&gt;）   &lt;/p&gt;
&lt;p&gt;虽然，这个function在语法上没问题，但是依然只是一个语句，加上括号依然报错，是因为语句中的分组操作符要包含表达式。&lt;/p&gt;

&lt;p&gt;综上，我们可以得到，在函数表达式后面紧跟一个小括号（），函数会立即执行，两大要点是：表达式、括号（）；&lt;/p&gt;
&lt;p&gt;所以，立即执行函数的写法就是：&lt;/p&gt;
&lt;p&gt;( function(){…} )() 或  ( function (){…} () )  &lt;/p&gt;
&lt;p&gt;这里的括弧是消除歧义的，它告诉解析器，里面的内容是表达式。&lt;/p&gt;




</description>
<pubDate>Sat, 25 Nov 2017 07:44:00 +0000</pubDate>
<dc:creator>lichunchun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichunyan/p/7894867.html</dc:identifier>
</item>
<item>
<title>Sublime Text 3 修改配色方案 - kjcy8</title>
<link>http://www.cnblogs.com/kjcy8/p/7895368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kjcy8/p/7895368.html</guid>
<description>&lt;p&gt;你可能会觉得 Sublime Text 配色方案的颜色(注释、背景色)看起来不习惯，其他都满意。此时我们可以自己修改这些配色，不需要更换整个配色方案。&lt;/p&gt;
&lt;p&gt;需要安装 PackageResourceViewer：&lt;/p&gt;
&lt;p&gt;1. ctrl+shift+p 打开命令面板，搜索”ip”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/800226/201711/800226-20171125150238734-1081393482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 Package Control: Install Package&lt;/p&gt;
&lt;p&gt;2. 输入 PackageResourceViewer 点击安装&lt;/p&gt;
&lt;p&gt;3. ctrl+shift+p 打开命令面板，搜索”Package ResourceViewer:Open Resource”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/800226/201711/800226-20171125150801468-916232975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/800226/201711/800226-20171125150815921-482376675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/800226/201711/800226-20171125150830359-447271235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击打开的就是 IDLE 配色方案的配置文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/800226/201711/800226-20171125151039609-2080632446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据自己的喜好修改。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 07:14:00 +0000</pubDate>
<dc:creator>kjcy8</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kjcy8/p/7895368.html</dc:identifier>
</item>
<item>
<title>博客一年总结 - 请叫我最美女神</title>
<link>http://www.cnblogs.com/iLoveBurning/p/7895339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iLoveBurning/p/7895339.html</guid>
<description>&lt;h4&gt;&lt;span&gt;博客一年总结、、、&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;========================&lt;/p&gt;
&lt;p&gt;不想用说太多，用一句话总结：我的人生还有很多的不完整，以后仍然需要继续加油，继续坚持，保持耐心，继续善良，保持温柔，更加勇敢，努力追求自己需要的，想要的，喜欢的，让平凡的生活，增加更多的可能，给普通的人生，增加更多的趣味和意义、那加油咩、、、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1066791/201711/1066791-20171125150546515-1356839519.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;==========================&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 07:07:00 +0000</pubDate>
<dc:creator>请叫我最美女神</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iLoveBurning/p/7895339.html</dc:identifier>
</item>
<item>
<title>设计模式之普通工厂模式 - hao先生</title>
<link>http://www.cnblogs.com/MrMedici/p/7895248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrMedici/p/7895248.html</guid>
<description>&lt;p&gt;&lt;br/&gt;1. 工厂模式&lt;/p&gt;
&lt;p&gt;工厂模式分为三种&lt;/p&gt;
&lt;p&gt;（1.）普通工厂模式&lt;/p&gt;
&lt;p&gt;普通工厂模式，就是建立一个工厂类，对实现了同一个接口的一些类进行实例的创建。&lt;/p&gt;
&lt;p&gt;普通工厂模式关系图 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1276072/201711/1276072-20171125143526703-2147455338.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;以下举例：（我们举一个发送邮件和短信的例子）&lt;/p&gt;
&lt;p&gt;首先，创建二者的共同接口：&lt;/p&gt;
&lt;p&gt;[java] view plaincopy&lt;/p&gt;
&lt;p&gt;public interface Sender {&lt;br/&gt;public void Send();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;其次，创建实现类：&lt;/p&gt;
&lt;p&gt;[java] view plaincopy&lt;/p&gt;
&lt;p&gt;实现类一&lt;/p&gt;
&lt;p&gt;public class MailSender implements Sender {&lt;br/&gt;@Override&lt;br/&gt;public void Send() {&lt;br/&gt;System.out.println(&quot;this is mailsender!&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;[java] view plaincopy&lt;/p&gt;
&lt;p&gt;实现类二&lt;/p&gt;
&lt;p&gt;public class SmsSender implements Sender {&lt;/p&gt;
&lt;p&gt;@Override&lt;br/&gt;public void Send() {&lt;br/&gt;System.out.println(&quot;this is sms sender!&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;最后，建工厂类：&lt;/p&gt;
&lt;p&gt;[java] view plaincopy&lt;/p&gt;
&lt;p&gt;public class SendFactory {&lt;/p&gt;
&lt;p&gt;public Sender produce(String type) {&lt;br/&gt;if (&quot;mail&quot;.equals(type)) {&lt;br/&gt;return new MailSender();&lt;br/&gt;} else if (&quot;sms&quot;.equals(type)) {&lt;br/&gt;return new SmsSender();&lt;br/&gt;} else {&lt;br/&gt;System.out.println(&quot;请输入正确的类型!&quot;);&lt;br/&gt;return null;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;我们来测试下：&lt;/p&gt;
&lt;p&gt;public class FactoryTest {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;SendFactory factory = new SendFactory();&lt;br/&gt;Sender sender = factory.produce(&quot;sms&quot;);&lt;br/&gt;sender.Send();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;输出：this is sms sender!&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 06:38:00 +0000</pubDate>
<dc:creator>hao先生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrMedici/p/7895248.html</dc:identifier>
</item>
<item>
<title>Memcached 及 Redis 架构分析和区别比较 - 赖忠标</title>
<link>http://www.cnblogs.com/lazb/p/7895237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lazb/p/7895237.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;作为两种&lt;span lang=&quot;en-US&quot;&gt;Inmemory&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;key-value&lt;span lang=&quot;zh-CN&quot;&gt;数据库，在设计和思想方面有着很多共通的地方，功能和应用方面在很多场合下&lt;span lang=&quot;en-US&quot;&gt;(&lt;span lang=&quot;zh-CN&quot;&gt;作为分布式缓存服务器使用等&lt;span lang=&quot;en-US&quot;&gt;) &lt;span lang=&quot;zh-CN&quot;&gt;也很相似，在这里把两者放在一起做一下对比的介绍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;基本架构和思想&lt;/p&gt;

&lt;p&gt;首先简单介绍一下两者的架构和设计思路&lt;/p&gt;

&lt;p lang=&quot;en-US&quot;&gt;Memcached&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;采用客户端&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;服务器的架构，客户端和服务器端的通讯使用自定义的协议标准，只要满足协议格式要求，客户端&lt;span lang=&quot;en-US&quot;&gt;Library&lt;span lang=&quot;zh-CN&quot;&gt;可以用任何语言实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;从用户的角度来说，服务器维护了一个键&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;值关系的数据表，服务器之间相互独立，互相之间不共享数据也不做任何通讯操作。客户端需要知道所有的服务器，并自行负责管理数据在各个服务器间的分配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;在服务器端，内部的数据存储，使用基于&lt;span lang=&quot;en-US&quot;&gt;Slab&lt;span lang=&quot;zh-CN&quot;&gt;的内存管理方式，有利于减少内存碎片和频繁分配销毁内存所带来的开销。各个&lt;span lang=&quot;en-US&quot;&gt;Slab&lt;span lang=&quot;zh-CN&quot;&gt;按需动态分配一个&lt;span lang=&quot;en-US&quot;&gt;page&lt;span lang=&quot;zh-CN&quot;&gt;的内存（和&lt;span lang=&quot;en-US&quot;&gt;4Kpage&lt;span lang=&quot;zh-CN&quot;&gt;的概念不同，这里默认&lt;span lang=&quot;en-US&quot;&gt;page&lt;span lang=&quot;zh-CN&quot;&gt;为&lt;span lang=&quot;en-US&quot;&gt;1M&lt;span lang=&quot;zh-CN&quot;&gt;），&lt;span lang=&quot;en-US&quot;&gt;page&lt;span lang=&quot;zh-CN&quot;&gt;内部按照不同&lt;span lang=&quot;en-US&quot;&gt;slab class&lt;span lang=&quot;zh-CN&quot;&gt;的尺寸再划分为内存&lt;span lang=&quot;en-US&quot;&gt;chunk&lt;span lang=&quot;zh-CN&quot;&gt;供服务器存储&lt;span lang=&quot;en-US&quot;&gt;KV&lt;span lang=&quot;zh-CN&quot;&gt;键值对使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140312142443812&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的基本应用模型如下图所示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140312142458937&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p lang=&quot;en-US&quot;&gt;Redis&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的基本应用模式和上图&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;的基本相似，不难发现网上到处都是关于&lt;span lang=&quot;en-US&quot;&gt;redis&lt;span lang=&quot;zh-CN&quot;&gt;是否可以完全替代&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;使用的问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;内部的数据结构最终也会落实到&lt;span lang=&quot;en-US&quot;&gt;key-Value&lt;span lang=&quot;zh-CN&quot;&gt;对应的形式，不过从暴露给用户的数据结构来看，要比&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;丰富，除了标准的通常意义的键值对，&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;还支持&lt;span lang=&quot;en-US&quot;&gt;List&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;Set&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt; Hashes&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;Sorted Set&lt;span lang=&quot;zh-CN&quot;&gt;等数据结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;基本命令&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的命令或者说通讯协议非常简单，&lt;span lang=&quot;en-US&quot;&gt;Server&lt;span lang=&quot;zh-CN&quot;&gt;所支持的命令基本就是对特定&lt;span lang=&quot;en-US&quot;&gt;key&lt;span lang=&quot;zh-CN&quot;&gt;的添加，删除，替换，原子更新，读取等，具体包括&lt;span lang=&quot;en-US&quot;&gt; Set, Get, Add, Replace, Append, Inc/Dec &lt;span lang=&quot;zh-CN&quot;&gt;等等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如&lt;span lang=&quot;en-US&quot;&gt;telnet&lt;span lang=&quot;zh-CN&quot;&gt;）和对性能要求更高的客户端的不同需求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的命令在&lt;span lang=&quot;en-US&quot;&gt;KV&lt;span lang=&quot;zh-CN&quot;&gt;（&lt;span lang=&quot;en-US&quot;&gt;String&lt;span lang=&quot;zh-CN&quot;&gt;类型）上提供与&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;类似的基本操作，在其它数据结构上也支持基本类似的操作（当然还有这些数据结构所特有的操作，如&lt;span lang=&quot;en-US&quot;&gt;Set&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;union&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;List&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;pop&lt;span lang=&quot;zh-CN&quot;&gt;等）而支持更多的数据结构，在一定程度上也就意味着更加广泛的应用场合&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;除了多种数据结构的支持，&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;相比&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;还提供了许多额外的特性，比如&lt;span lang=&quot;en-US&quot;&gt;Subscribe/publish&lt;span lang=&quot;zh-CN&quot;&gt;命令，以支持发布&lt;span lang=&quot;en-US&quot;&gt;/&lt;span lang=&quot;zh-CN&quot;&gt;订阅模式这样的通知机制等等，这些额外的特性同样有助于拓展它的应用场景&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的客户端&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;服务器通讯协议完全采用文本格式（在将来可能的服务器间通讯会采用二进制格式）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;事务&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;redis&lt;span lang=&quot;zh-CN&quot;&gt;通过&lt;span lang=&quot;en-US&quot;&gt;Multi / Watch /Exec&lt;span lang=&quot;zh-CN&quot;&gt;等命令可以支持事务的概念，原子性的执行一批命令。在&lt;span lang=&quot;en-US&quot;&gt;2.6&lt;span lang=&quot;zh-CN&quot;&gt;以后的版本中由于添加了对&lt;span lang=&quot;en-US&quot;&gt;Script&lt;span lang=&quot;zh-CN&quot;&gt;脚本的支持，而脚本固有的是以&lt;span lang=&quot;en-US&quot;&gt;transaction&lt;span lang=&quot;zh-CN&quot;&gt;事务的方式执行的，并且更加易于使用，所以不排除将来取消&lt;span lang=&quot;en-US&quot;&gt;Multi&lt;span lang=&quot;zh-CN&quot;&gt;等命令接口的可能性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的应用模式中，除了&lt;span lang=&quot;en-US&quot;&gt;increment/decrement&lt;span lang=&quot;zh-CN&quot;&gt;这样的原子操作命令，不存在对事务的支持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;数据备份，有效性，持久化等&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;不保证存储的数据的有效性，&lt;span lang=&quot;en-US&quot;&gt;Slab&lt;span lang=&quot;zh-CN&quot;&gt;内部基于&lt;span lang=&quot;en-US&quot;&gt;LRU&lt;span lang=&quot;zh-CN&quot;&gt;也会自动淘汰旧数据，客户端不能假设数据在服务器端的当前状态，这应该说是&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;Feature&lt;span lang=&quot;zh-CN&quot;&gt;设定，用户不必太多关心或者自己管理数据的淘汰更新工作，当然是否适合你的应用，取决于具体的需求，它也可能成为你需要精确自行控制&lt;span lang=&quot;en-US&quot;&gt;Cache&lt;span lang=&quot;zh-CN&quot;&gt;生命周期的一个障碍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;也不做数据的持久化工作，但是有许多基于&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;协议的项目实现了数据的持久化，例如&lt;span lang=&quot;en-US&quot;&gt;memcacheDB&lt;span lang=&quot;zh-CN&quot;&gt;使用BerkeleyDB进行数据存储，但本质上它已经不是一个&lt;span lang=&quot;en-US&quot;&gt;Cache Server&lt;span lang=&quot;zh-CN&quot;&gt;，而只是一个兼容&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的协议&lt;span lang=&quot;en-US&quot;&gt;key-valueData Store&lt;span lang=&quot;zh-CN&quot;&gt;了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;可以以&lt;span lang=&quot;en-US&quot;&gt;master-slave&lt;span lang=&quot;zh-CN&quot;&gt;的方式配置服务器，&lt;span lang=&quot;en-US&quot;&gt;Slave&lt;span lang=&quot;zh-CN&quot;&gt;节点对数据进行&lt;span lang=&quot;en-US&quot;&gt;replica&lt;span lang=&quot;zh-CN&quot;&gt;备份，&lt;span lang=&quot;en-US&quot;&gt;Slave&lt;span lang=&quot;zh-CN&quot;&gt;节点也可以充当&lt;span lang=&quot;en-US&quot;&gt;Read only&lt;span lang=&quot;zh-CN&quot;&gt;的节点分担数据读取的工作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;内建&lt;span lang=&quot;zh-CN&quot;&gt;支持两种持久化方案，&lt;span lang=&quot;en-US&quot;&gt;snapshot&lt;span lang=&quot;zh-CN&quot;&gt;快照和&lt;span lang=&quot;en-US&quot;&gt;AOF &lt;span lang=&quot;zh-CN&quot;&gt;增量&lt;span lang=&quot;en-US&quot;&gt;Log&lt;span lang=&quot;zh-CN&quot;&gt;方式。快照顾名思义就是隔一段时间将完整的数据&lt;span lang=&quot;en-US&quot;&gt;Dump&lt;span lang=&quot;zh-CN&quot;&gt;下来存储在文件中。&lt;span lang=&quot;en-US&quot;&gt;AOF&lt;span lang=&quot;zh-CN&quot;&gt;增量&lt;span lang=&quot;en-US&quot;&gt;Log&lt;span lang=&quot;zh-CN&quot;&gt;则是记录对数据的修改操作（实际上记录的就是每个对数据产生修改的命令本身），两种方案可以并存，也各有优缺点，具体参见&lt;span lang=&quot;en-US&quot;&gt; &lt;a href=&quot;http://redis.io/topics/persistence&quot; target=&quot;_blank&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;http://redis.io/topics/persistence&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;以上&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的数据备份持久化方案等，如果不需要，为了提高性能，也完全可以&lt;span lang=&quot;en-US&quot;&gt;Disable&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;性能&lt;/p&gt;

&lt;p&gt;性能方面，两者都有一些自己考虑和实现&lt;/p&gt;

&lt;p lang=&quot;en-US&quot;&gt;Memcached&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;自身并不主动定期检查和标记哪些数据需要被淘汰，只有当再次读取相关数据时才检查时间戳，或者当内存不够使用需要主动淘汰数据时进一步检查&lt;span lang=&quot;en-US&quot;&gt;LRU&lt;span lang=&quot;zh-CN&quot;&gt;数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p lang=&quot;en-US&quot;&gt;Redis&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;为了减少大量小数据&lt;span lang=&quot;en-US&quot;&gt;CMD&lt;span lang=&quot;zh-CN&quot;&gt;操作的网络通讯时间开销 RTT (Round Trip Time)，支持&lt;span lang=&quot;en-US&quot;&gt;pipeline&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;en-US&quot;&gt;script&lt;span lang=&quot;zh-CN&quot;&gt;技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;所谓的&lt;span lang=&quot;en-US&quot;&gt;pipeline&lt;span lang=&quot;zh-CN&quot;&gt;就是支持在一次通讯中，发送多个命令给服务器批量执行，带来的代价是服务器端需要更多的内存来缓存查询结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;内嵌了&lt;span lang=&quot;en-US&quot;&gt;LUA&lt;span lang=&quot;zh-CN&quot;&gt;解析器，可以执行&lt;span lang=&quot;en-US&quot;&gt;lua &lt;span lang=&quot;zh-CN&quot;&gt;脚本，脚本可以通过&lt;span lang=&quot;en-US&quot;&gt;eval&lt;span lang=&quot;zh-CN&quot;&gt;等命令直接执行，也可以使用&lt;span lang=&quot;en-US&quot;&gt;script load&lt;span lang=&quot;zh-CN&quot;&gt;等方式上传到服务器端的&lt;span lang=&quot;en-US&quot;&gt;script cache&lt;span lang=&quot;zh-CN&quot;&gt;中重复使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方式都可以有效地减少网络通讯开销，增加数据吞吐率&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对于&lt;span lang=&quot;en-US&quot;&gt;KV&lt;span lang=&quot;zh-CN&quot;&gt;的操作，&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;都支持&lt;span lang=&quot;en-US&quot;&gt;Multiple&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;Get&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;en-US&quot;&gt;Set&lt;span lang=&quot;zh-CN&quot;&gt;命令（&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;Multiple Set&lt;span lang=&quot;zh-CN&quot;&gt;命令貌似只在二进制的协议中支持），这同样有利于性能的提升&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;实际性能方面，网上有很多测试比较，给出的结果各不相同，这无疑和各种测试的测试用例，测试环境，和测试时具体使用的客户端&lt;span lang=&quot;en-US&quot;&gt;Library&lt;span lang=&quot;zh-CN&quot;&gt;实现有关。但是总体看下来，比较靠谱的结论是在&lt;span lang=&quot;en-US&quot;&gt;kv&lt;span lang=&quot;zh-CN&quot;&gt;类操作上，两者的性能接近，&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;的结构更加简单，理论上应该会略微快一些。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;集群&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;的服务器端互相完全独立，客户端通常通过对键值应用&lt;span lang=&quot;en-US&quot;&gt;Hash&lt;span lang=&quot;zh-CN&quot;&gt;算法决定数据的分区，为了减少服务器的增减对&lt;span lang=&quot;en-US&quot;&gt;Hash&lt;span lang=&quot;zh-CN&quot;&gt;结果的影响，导致大面积的缓存失效，多数客户端实现了一致性&lt;span lang=&quot;en-US&quot;&gt;hash&lt;span lang=&quot;zh-CN&quot;&gt;算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;计划在服务器端内建对集群的支持，但是目前代码还处于&lt;span lang=&quot;en-US&quot;&gt;alpha&lt;span lang=&quot;zh-CN&quot;&gt;阶段（貌似已经&lt;span lang=&quot;en-US&quot;&gt;Design&lt;span lang=&quot;zh-CN&quot;&gt;了两三年了？）在此之前，同样可以认为每个&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;服务器实例相互之间是完全独立的，需要依靠客户端处理分区算法和可用服务器列表管理的工作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140312142525890&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;官方推荐的用于&lt;span lang=&quot;en-US&quot;&gt;Sharding&lt;span lang=&quot;zh-CN&quot;&gt;的客户端程序库是&lt;span lang=&quot;en-US&quot;&gt;Twitter&lt;span lang=&quot;zh-CN&quot;&gt;的开源项目&lt;span lang=&quot;en-US&quot;&gt; &lt;span lang=&quot;zh-CN&quot;&gt;Twemproxy，&lt;span lang=&quot;en-US&quot;&gt; Twemproxy&lt;span lang=&quot;zh-CN&quot;&gt;同时支持&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的文本通讯协议。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;需要注意的是，&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的许多命令在集群环境下是不能正确运行的，例如&lt;span lang=&quot;en-US&quot;&gt;set&lt;span lang=&quot;zh-CN&quot;&gt;的交集，以及跨节点的事务操作等等，因为目前的&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;集群设计，根本目标也就是服务器之间互相汇报一下存活状态，以及对数据做荣誉备份平衡负载等而已，本质上对数据的跨节点操作并不提供任何额外支持，所以在数据服务的层面上来说，各个服务器依旧是完全独立的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这些操作如果一定要实现，当然可以通过客户端代码来实现（效率有多高且不说），类似的问题&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;集群当然也会遇上，但是原本&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;就不支持复杂的操作和数据类型，许多运算逻辑原本就是由客户端代码或应用程序自己处理的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;MR&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;类批处理应用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;提供指定范围的遍历操作，是支持类似&lt;span lang=&quot;en-US&quot;&gt;MapReduce&lt;span lang=&quot;zh-CN&quot;&gt;这样的批处理应用逻辑的关键之一，但是要在基于&lt;span lang=&quot;en-US&quot;&gt;hash&lt;span lang=&quot;zh-CN&quot;&gt;方式存储的数据结构的基础上提供这样的支持并不容易（或者说要实现高效的范围或遍历操作并不容易）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;支持&lt;span lang=&quot;en-US&quot;&gt;Scan&lt;span lang=&quot;zh-CN&quot;&gt;操作用于遍历数据集，这一操作基于其内部数据结构及实现的限制，可以保证在&lt;span lang=&quot;en-US&quot;&gt;Scan&lt;span lang=&quot;zh-CN&quot;&gt;开始时的所有数据都能被获取到，但是不能保证不返回重复的数据，这需要由客户端来检查，或者客户端对此无所谓。&lt;span lang=&quot;en-US&quot;&gt;Scan&lt;span lang=&quot;zh-CN&quot;&gt;操作还支持&lt;span lang=&quot;en-US&quot;&gt;Match&lt;span lang=&quot;zh-CN&quot;&gt;条件用来过滤键值，虽然存在一定的局限性，例如&lt;span lang=&quot;en-US&quot;&gt;match&lt;span lang=&quot;zh-CN&quot;&gt;条件的比较是在获取数据之后再执行的，效率是一个问题，更明显的问题是不能保证每次&lt;span lang=&quot;en-US&quot;&gt;scan&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;iterate&lt;span lang=&quot;zh-CN&quot;&gt;过程都能返回同样数量的有效数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对于范围操作，&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;Ordered Set&lt;span lang=&quot;zh-CN&quot;&gt;支持在插入时指定数据的分数（&lt;span lang=&quot;en-US&quot;&gt;Score&lt;span lang=&quot;zh-CN&quot;&gt;）用于排序，而后支持在指定&lt;span lang=&quot;en-US&quot;&gt;Score&lt;span lang=&quot;zh-CN&quot;&gt;范围内的各种操作，虽然由于不支持基于字符串的或自定义的基准的&lt;span lang=&quot;en-US&quot;&gt;Range&lt;span lang=&quot;zh-CN&quot;&gt;操作，这样的范围操作应用起来有很大的局限性（或者说需要满足特定的应用模式），但是还是比没有好了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Memcached&lt;span lang=&quot;zh-CN&quot;&gt;核心协议本身不支持任何范围类的操作，也没有对遍历操作的支持，甚至不存在官方合法的列举所有&lt;span lang=&quot;en-US&quot;&gt;Key&lt;span lang=&quot;zh-CN&quot;&gt;的操作，这当然很大程度上源于其设计思想和精简的架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;不过还是有一些兼容&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;协议的服务器实现了范围类操作，具体格式可以参考&lt;span lang=&quot;en-US&quot;&gt;&lt;a href=&quot;https://code.google.com/p/memcached/wiki/RangeOps&quot; target=&quot;_blank&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;https://code.google.com/p/memcached/wiki/RangeOps&lt;/span&gt;&lt;/a&gt;&lt;span lang=&quot;en-US&quot;&gt; &lt;span lang=&quot;zh-CN&quot;&gt;所建议的标准&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;此外&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;的&lt;span lang=&quot;en-US&quot;&gt;Hashes&lt;span lang=&quot;zh-CN&quot;&gt;数据结构，在一定程度上可以满足获取特定子集数据的应用逻辑需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;综上来说，如果要实现类似&lt;span lang=&quot;en-US&quot;&gt;HBase&lt;span lang=&quot;zh-CN&quot;&gt;支持的&lt;span lang=&quot;en-US&quot;&gt;scan&lt;span lang=&quot;zh-CN&quot;&gt;操作，不论是&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;还是&lt;span lang=&quot;en-US&quot;&gt;memcached&lt;span lang=&quot;zh-CN&quot;&gt;都无法做到，但是对于&lt;span lang=&quot;en-US&quot;&gt;Redis&lt;span lang=&quot;zh-CN&quot;&gt;来说，能否用于批处理类应用，不能一概而论，取决于具体的数据的格式逻辑和使用方式。通过适当的调整应用程序使用数据的方式，还是有可能在一定程度上实现对&lt;span lang=&quot;en-US&quot;&gt;MR&lt;span lang=&quot;zh-CN&quot;&gt;类批处理，或范围查询类应用逻辑的支持的。而对于键值分布在一个较大的连续空间，数量不确定，同时又无法很好的映射为数值进而使用&lt;span lang=&quot;en-US&quot;&gt;ordered set&lt;span lang=&quot;zh-CN&quot;&gt;来处理的这样一些数据结构，应该还是很难高效的分区遍历的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 06:36:00 +0000</pubDate>
<dc:creator>赖忠标</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lazb/p/7895237.html</dc:identifier>
</item>
<item>
<title>Android Weekly Notes Issue #284 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-284.html</guid>
<description>&lt;p&gt;November 19th, 2017&lt;/p&gt;

&lt;p&gt;本期内容丰富.有趣的有如何搭建真机测试平台,Proguard里面各类keep的区别,如何运行时获得泛型类型,Android的Internal Storage到底是什么,以及Android Things的一篇文章.&lt;/p&gt;
&lt;p&gt;代码部分有介绍了一个twiiter的序列化库,还有个比较炫酷的圆形Menu可以应用到自己项目中去.&lt;/p&gt;
&lt;h2 id=&quot;articles-tutorials&quot;&gt;ARTICLES &amp;amp; TUTORIALS&lt;/h2&gt;

&lt;p&gt;文章介绍了Google Play Store分阶段发布的特性，可以帮助你去降低发布风险。&lt;br/&gt;简单来说就是可以控制用户升级到新版本的比例，遇到问题可以发新版覆盖，更好的是，HotFix版本的发布范围是取自之前已经收到更新的用户的，帮助你去观察问题是否已经修复，而尽量的不会去影响其他未收到更新的用户。&lt;/p&gt;

&lt;p&gt;文章介绍了如何更好的支持Android O最新的AutoFill功能，如添加hint为其分类，设置一些attribute标注其需要或者不需要autofill,因为默认都是开启的...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setImportantForAutofill(IMPORTANT_FOR_AUTOFILL_NO)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;文章介绍了如何通过STF(Smartphone Test Farm)与GCP(Google Cloud Platform)来搭建公网测试平台.&lt;/p&gt;
&lt;p&gt;由于没有公网静态地址,所以这里采用微服务平台来搭建.&lt;/p&gt;
&lt;p&gt;手机与Local的机器adb连接, Local与GCP通过SSH Tunnel连接,使用autossh保活,GCP上跑STF.如果有多个区域的Local实体机,可以通过nginx均衡.&lt;/p&gt;

&lt;p&gt;介绍了&lt;code&gt;Internal Storage&lt;/code&gt;的历史渊源以及他的消失.&lt;/p&gt;
&lt;p&gt;最早(1.x-2.x)实际上是分Internal跟外挂的SdCard,内部储存很小只有几十M,我记得以前得通过脚本开启app2sdcard,来将程序数据挪到sd卡,当然2.3开放了这个功能.&lt;/p&gt;
&lt;p&gt;3.x-4.4之前,内部储存越来越大,并且也可以挂载非sd卡的储存空间,我们称之为固有ROM.&lt;/p&gt;
&lt;p&gt;4.4以后把所有的内部储存分成了Internal Storage与External Storage,其实主要是读写权限的区别,并限制了挂载储存(sdcard)的读写权限.&lt;/p&gt;
&lt;p&gt;8.0以后取消了Internal Storage的叫法,内部储存统一叫Storage&lt;/p&gt;

&lt;p&gt;介绍了新版本手机支持&lt;code&gt;sRGB&lt;/code&gt;也就是Wide color的情况, 可以通过Manifect设置Activity是否开启&lt;code&gt;wideColorGamut&lt;/code&gt;模式,还可以通过&lt;code&gt;values-widecg&lt;/code&gt;文件夹指定色值,在支持Wider色的机器上使用.&lt;/p&gt;

&lt;p&gt;文章以图表的方式介绍了Proguard里面不同的keep之间的区别.&lt;/p&gt;
&lt;p&gt;总结一下就是加了&lt;code&gt;names&lt;/code&gt;就会shrink,加了&lt;code&gt;member&lt;/code&gt;就是只针对于member,加了&lt;code&gt;with&lt;/code&gt;就是必须&lt;code&gt;{}&lt;/code&gt;里面的member都有的时候才会执行.&lt;/p&gt;

&lt;p&gt;Android Things相关的分享,作者使用MIDI协议,结合Google的Nearby API,相当于手机与Things之间通过Nearby通信,然后Things将MIDI数据传给电脑上的Software.&lt;/p&gt;

&lt;p&gt;文章讲了运行时获得泛型信息,并通过这个办法,Gson的TokenType将类型信息交给反序列化使用.&lt;/p&gt;
&lt;p&gt;大致原理:&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;InnerType#Internal&amp;lt;String&amp;gt;&lt;/code&gt;,通过其&lt;code&gt;GenericSuperclass&lt;/code&gt;可以获得很多信息.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;OwnerType&lt;/code&gt;是&lt;code&gt;InnerType&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RawType&lt;/code&gt;是&lt;code&gt;InnerType$Internal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ActualTypeArguments&lt;/code&gt;是&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章介绍了一个更牛的序列化工具&lt;code&gt;Serial&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;它的特点很多,如更快的&lt;code&gt;Perfermance&lt;/code&gt;,更容易&lt;code&gt;Debug&lt;/code&gt;,更好的&lt;code&gt;backward&lt;/code&gt;兼容性,以及加入已有系统的&lt;code&gt;flexibility&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;libraries-code&quot;&gt;LIBRARIES &amp;amp; CODE&lt;/h2&gt;

&lt;p&gt;一个UI空间,可以点开一个圆圈类型的Menu.&lt;/p&gt;

&lt;p&gt;连接&lt;code&gt;Trakt.tv&lt;/code&gt;的一个App,非官方,WIP,使用了很多新框架.&lt;/p&gt;

&lt;p&gt;通过写一写注解来绑定layout与Java,生成RecyclerView的adapter.&lt;/p&gt;

&lt;p&gt;包含了android14-27的changelog的poster&lt;/p&gt;

&lt;p&gt;一个gradle的format插件,支持包括compile不同格式的切换,还有maven到gradle的转换等等.&lt;/p&gt;

&lt;p&gt;Twitter的序列化框架.&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 06:30:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengdd/p/android-weekly-notes-issue-284.html</dc:identifier>
</item>
<item>
<title>如何在一个月内改善你的生活 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7895201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7895201.html</guid>
<description>&lt;blockquote readability=&quot;2.0224719101124&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;原文作者：&lt;a href=&quot;https://journal.thriveglobal.com/@alltopstartups?source=post_header_lockup&quot;&gt;Thomas Oppong&lt;/a&gt;&lt;br/&gt;原文地址：&lt;a href=&quot;https://journal.thriveglobal.com/how-to-improve-your-life-in-just-a-month-eed6c90ee6c4&quot;&gt;How to Improve Your Life in Just a Month&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-2a85341a097babef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你不能改变你不曾准备放弃的东西。&lt;/p&gt;
&lt;p&gt;你就是你反复做的事。你的习惯性行为经常会被忽视，因为你不需要在进行例行的任务时进行自我分析。&lt;/p&gt;
&lt;p&gt;许多人仅仅正在经历着生活。&lt;/p&gt;
&lt;p&gt;就像这样。经历着。然后随时间流逝，转瞬即逝。&lt;/p&gt;
&lt;p&gt;让事情发生。让每一天都像前一天和后天一样。没什么不寻常的。&lt;/p&gt;
&lt;p&gt;在历史书中读到的知识并不会获得什么东西。没有什么独特的。只是普普通通的 。&lt;/p&gt;
&lt;p&gt;你的情况会有所不同吗? 当然可以！&lt;/p&gt;
&lt;p&gt;你现在就需要开始控制你的生活了！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;你是谁？ 你代表着什么？ 你想知道什么？你为自己设定了什么标准？ 定义你在这个世界上最重要的角色，并在此基础上开始塑造你的现实。&lt;/p&gt;
&lt;p&gt;你就是你。你在生活中所面临的挑战，实际上是你的生活的工作，就是成为你最好的那个版本。不断趋于完美的你。&lt;/p&gt;
&lt;p&gt;『你拥有的唯一的东西就是你自己。你的声音，你的思想，你的故事，你的愿景。所以，协作、绘画、构造、玩耍、跳舞和生活，只有你可以。』Neil Gaiman说。&lt;/p&gt;
&lt;p&gt;目的激发你的动力。 你期待明天，下个季度还是未来五年是什么样的？&lt;/p&gt;
&lt;p&gt;想象一下，每天醒来都会为你已经完成的目标感到兴奋。 只有这种热情才能将你推向更高的层次。&lt;/p&gt;
&lt;h3 id=&quot;提高你的目标打破你的目标并取得成功一切都不会太迟&quot;&gt;提高你的目标，打破你的目标，并取得成功。一切都不会太迟！&lt;/h3&gt;
&lt;p&gt;许多人一辈子都没有站起来，走出去。 但亲眼目睹少数敢于冒险的人，为了努力工作而努力工作，真令人兴奋。&lt;/p&gt;
&lt;p&gt;大部分的生活都和顽固的幻想有关，我们以为永远拥有明天去做今天的工作。我们一贯坚持这种信念，并不断拖延，直到工作变成沉重的负担。&lt;/p&gt;
&lt;p&gt;如果不加控制，我们总是默认走向一条更舒适的路线。 你舒适的区域提供了一种精神安全的状态。 你可以理解为什么很难把你的大脑踢出你的舒适区。&lt;/p&gt;
&lt;p&gt;在Malcom Gladwell的书中 &lt;a href=&quot;https://amzn.to/2ifhGGX&quot;&gt;《Outliers: The Story of Success》&lt;/a&gt;说到：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;异类是那些获得机会，并有能力把握住机会的一群人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出类拔萃的人抓住机遇，并与之同行。那些意识到自己的时间很少的人，被驱使着去充分利用它。那些人就是那些真正过着精彩而非凡的生活的人。&lt;/p&gt;
&lt;p&gt;做一个异类!&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;如果你在生活中没有达到任何目标，那么问题就出在你的心态（mind）。这就是你的心态为什么这么重要。你的心态是你最强大的力量。&lt;/p&gt;
&lt;p&gt;你告诉自己的故事和你相信自己的事情都可以阻止改变的发生，也可以让新的想法开花结果。&lt;/p&gt;
&lt;p&gt;Carol Dweck解释到：『20年来，我的研究表明，你对自己的看法会深刻地影响你生活的方式。它可以决定你是否成为你想成为的人，以及你是否完成了你所珍爱的事情。』&lt;/p&gt;
&lt;p&gt;当你开始掌控你的心态时，你就能做出新的健康的选择，拥抱积极的生活态度，承诺实现你的目标，并让他们完成你的目标。&lt;/p&gt;
&lt;p&gt;你很可能会完成你开始的事情，开始引领你期待和渴望的美好生活。如果你能实现你的梦想、目标和愿景，你就能实现它。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;想要成为一个更好的自己，往往感觉就像坐过山车一样。者是很困难的，而且通常是不均匀的。你甚至以失败告终。但是生活是一段旅程，而不是一场马拉松，所以你总是有机会重新开始和改进。&lt;/p&gt;
&lt;p&gt;『要对自己有耐心，温柔地自我成长；它是圣地。 除此没有更好的投资。』Stephen Covey说。&lt;/p&gt;
&lt;p&gt;当你需要改变的时候，你必须开始以小的方式接受改变。如果你想改变你的『生活』，而不是『平庸』，那么你就必须做些不同的事情。&lt;/p&gt;
&lt;p&gt;目标要小而且要持续变化，如果没有快速变化，小的改变会带来很大的改变。这是改变习惯的唯一方法。&lt;/p&gt;
&lt;p&gt;自我完善不是目的，你也不不可能完成。即使你取得了一些成功，并且你想要保持它，你必须继续做你正在做的事情，这样才能使你获得成功。&lt;/p&gt;
&lt;p&gt;我们的想法是把重点放在你生活中持续的改善上，每一天，无论你踏出一个比昨天更好的步伐有多么小。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;不要试图在短时间内做出彻底的改变，只要每天做些小的改进，就能逐渐地改变你想要的改变。每天，只要专注于你想要改善的任何东西，你就能获得更好的1%。就是这样。仅为1%。&lt;/p&gt;
&lt;p&gt;这看起来似乎没什么，但1%的改进开始相互作用。在开始的时候，你的改进会非常小，看起来几乎不存在。但慢慢地，你会开始注意到生活的改善。这可能需要几个月甚至几年的时间，但如果你只专注于持续提升1%，那么它的改进就会到来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;每天晚上花20分钟让你第二天的早晨更从容。&lt;/p&gt;
&lt;p&gt;在一天结束前计划好你要做的事情。准备咖啡。挑选你的衣服。&lt;/p&gt;
&lt;p&gt;你以前听过这一切，但你之前听过这一切都是有原因的。它是有效的！把它们付诸实践，见证奇迹的早晨。&lt;/p&gt;
&lt;p&gt;你的晚间习惯决定了你早上的成功。&lt;/p&gt;
&lt;p&gt;你睡觉前做的每一项工作都与你在没有口吃的情况下醒来的时间有很大关系。&lt;/p&gt;
&lt;p&gt;睡觉前的时间是为早晨做准备的理想时间。&lt;/p&gt;
&lt;p&gt;在他的畅销书《Miracle Morning》中写到：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;你每天早上醒来的时候，早上的习惯(或缺乏)会极大地影响你生活中每一个方面的成功程度。专注、高效、成功的早晨会产生专注、高效、成功的日子——这不可避免地会创造一个成功的生活——就像没有专注、没有效率、平庸的早晨一样，会产生不专注、没有效率的、平庸的日子，最终平庸的生活质量。只要改变你早上起床的方式，你就能改变你生活的任何方面，比你想象的要快得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个富有成效的早晨是有意识地创造出来的。你必须努力工作。要保持一致性很难，但要让它发挥作用，就需要疯狂的训练和承诺。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;减少像社交媒体这样的心理上瘾的时间。摆脱上瘾，而不是有用的工具。&lt;/p&gt;
&lt;p&gt;成功人士专注于个人发展、终身学习和建立关系，这些关系在现在和未来都为他们的生活增添了价值。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://amzn.to/2zNWeQH&quot;&gt;《Thinking, Fast and Slow》&lt;/a&gt;一书的作者Daniel Kahneman 曾说过：『乐观的人在塑造我们的生活中扮演着不成比例的角色。他们的决定会有所不同；他们是发明家、企业家、政治和军事领袖，而不是普通人。他们通过寻求挑战和冒险来达到自己的目标。』&lt;/p&gt;
&lt;p&gt;培养那些挑战你的人际关系，让你成为更好的自己。高于平均水平的人会采取行动，尽管充满恐惧和不确定性。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;泯然众人，最简单的方法就是随大流。在一个很小的圈子里是最容易做到的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你不想这样。 去你知道你会处于劣势的地方，走出去。 与优秀人竞争。 观看，阅读，聆听和分析他们所做的与你不同的事情。&lt;/p&gt;
&lt;p&gt;成功的秘诀藏在你正极力避免的一些事情的地方。这些事情似乎会让你崩溃，使你的精神变得谦卑。&lt;/p&gt;
&lt;p&gt;寻找不适。&lt;/p&gt;
&lt;p&gt;谨慎地做一些能够极大地推动你的极限的事情。&lt;/p&gt;
&lt;p&gt;困难帮助我们成长。如果你想要长期的成功，不要回避困难的事情，现在就去拥抱它。如果你真的在努力提高自己——无论如何——你会感到不舒服。&lt;/p&gt;
&lt;p&gt;Andrew Carnegie曾经说过：『普通人只有25％的精力和能力投入工作。 世界对那些投入50％以上能力的人脱帽，为百分之百投入的少数人致敬。』&lt;/p&gt;
&lt;p&gt;献身于正确的事物，是那些生活在一个完整的、有意义的人和那些对别人要求的事情作出反应的人之间的区别。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;知道你想要的是什么将使你的注意力和技能保持一致。选择一个目标，然后朝着它前进，无论遇到什么困难。旨在推过边界，打破自己的记录。&lt;/p&gt;
&lt;p&gt;解决那些让你无法过好生活的恐惧。你的思想有一种上升的方式。挑战它，它会奖励你。&lt;/p&gt;
&lt;h3 id=&quot;要善于腾出时间来做对你来说重要的事情尤其是当你不喜欢的时候&quot;&gt;要善于腾出时间来做对你来说重要的事情——尤其是当你不喜欢的时候。&lt;/h3&gt;
&lt;p&gt;要想停止平庸，最快的方法就是承认有勇气的生活，并立即采取行动，朝你的梦想前进。让自己去追求对你重要的东西。&lt;/p&gt;
&lt;p&gt;Rain完美地总结说：『最大的竞争是我自己。 我不想追随别人或把他们拉下来。 我打算测试我自己的界�&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 06:23:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7895201.html</dc:identifier>
</item>
<item>
<title>React+Redux实现追书神器网页版 - jianhuicode</title>
<link>http://www.cnblogs.com/lmf-techniques/p/7852525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lmf-techniques/p/7852525.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;blockquote readability=&quot;7.6778523489933&quot;&gt;
&lt;p&gt;由于现在做的react-native项目没有使用到redux等框架，写了一段时间想深入学习react，有个想法想做个demo练手下，那时候其实还没想好要做哪一个类型的，也看了些动漫的，小说阅读，聚合资源的开源项目。但是由于正好在学习开源的Android小说阅读器--&lt;a href=&quot;https://github.com/JustWayward/BookReader&quot;&gt;任阅&lt;/a&gt;，加上api比较全，开始边学边做，&lt;a href=&quot;https://github.com/jianhui1012/bookreader&quot;&gt;项目地址&lt;/a&gt;在这里，如果有好的意见欢迎提issue或pr。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;效果图&quot;&gt;效果图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/835108/201711/835108-20171123221311734-1372504823.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;目录结构&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;├─actions #redux的action,业务逻辑&lt;br/&gt;├─components #页面容器&lt;br/&gt;│ └─common #公共目录&lt;br/&gt;│ ├─component-module #封装的组件&lt;br/&gt;│ ├─images #项目图片&lt;br/&gt;│ │ └─icon&lt;br/&gt;│ └─style #组件样式&lt;br/&gt;├─modules #公用模块&lt;br/&gt;│ ├─api #管理api请求类&lt;br/&gt;│ └─constants #公共字段类&lt;br/&gt;├─reducers #redux中的reducers，处理action发送的数据流&lt;br/&gt;├─router #路由管理模块&lt;br/&gt;├─store #redux中的store,联结reducers&lt;br/&gt;└─template #存放html模版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目的初始结构和说明已罗列如上。&lt;/p&gt;
&lt;p&gt;下面对目录结构作以下说明&lt;/p&gt;
&lt;ul readability=&quot;2.9430379746835&quot;&gt;&lt;li readability=&quot;-0.8125&quot;&gt;
&lt;p&gt;项目最初始是参考&lt;a href=&quot;https://github.com/bailicangdu/react-pxq&quot;&gt;react-pxq&lt;/a&gt;初始化的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;中间件引人日志中间件--redux-logger，异步API调用--redux-thunk等;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;component-module和components存放的都是react组件，区别是：页面组件就放在components中，和模块组件(比如左侧菜单组件、书籍列表组件等)就放到 component-module中;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;页面状态等公共部分最好是独立起来，统一管理;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;跨域配置使用pathRewrite字段，需要注意webpack-dev-server的版本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;整体上分两个部分：&lt;br/&gt;1.整理API&lt;br/&gt;2.学习redux(搭建脚手架)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;api数据&quot;&gt;API数据&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;数据来源主要是两个地方：一个是开源的Android项目与RN版本的数据，另一个是追书神器h5移动端&lt;/li&gt;
&lt;li&gt;数据跨域：网上查了不少方法，考虑到便捷，使用反向代理的方式处理&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;学习redux&quot;&gt;学习Redux&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前面8章主要是熟悉接下来会用到的基础概念，当然每一章讲玩理论，后面都会动手实践敲代码，由浅入深。&lt;br/&gt;9，10两章开始使用上面学到的内容，进行搭建一个简单的项目；基本上每一天看个1-2章，玩的也很开心，花费了一个星期多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这部分内容是后面在搭建环境的时候看的，对于reducers，action，store的内容比较深入，加深理解。大概花了3天。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术栈&quot;&gt;技术栈&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;虽然列了众多核心库，但是自己也谈不上熟练运用，所以罗列了一些遇到的问题和后期改进的东西。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;webpack1.x&quot;&gt;Webpack(1.x)&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本项目主要用了第三方的脚手架，学习了反向代理部分，当然自己也搭建过webpack，后续会升级webpack。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这里提下反向代理部分，关于使用webpack-dev-server进行配置反向代理的时候，如果使用pathRewrite到属性需要注意webpack-dev-server版本，这个属性是在1.15.0中，不然是不起作用的。网上查到相同问题没有这个解释这里讲下，以免浪费时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;redux&quot;&gt;Redux&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;简单的讲他是一个管理单向数据流的框架，根据业务复杂度可以把控其中颗粒度。一开始学习的时候感觉反而把项目复杂化，看原理也是半懂不懂，后面不断实践理解前面看的内容，总归理论要与实践结合起来。&lt;br/&gt;模型如下：简单的数据流向可以看作View -&amp;gt; Action -&amp;gt; (Middleware) -&amp;gt; Reducer&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/835108/201711/835108-20171125133317609-765695376.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;react-router2.x&quot;&gt;React-router(2.x)&lt;/h4&gt;
&lt;p&gt;react-router(2.x)与react-router(4.x)的还是不同的，当然主要是写法上，所以没更新到4.0&lt;/p&gt;
&lt;p&gt;另外， 发布打包时使用nginx等应用服务器托管的时候需要配置下，所用路由走index.html文件，不然路由会被拦截。&lt;/p&gt;
&lt;h4 id=&quot;antd2.13&quot;&gt;Antd(2.13)&lt;/h4&gt;
&lt;ul readability=&quot;1.4100642398287&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，其中包括了移动端，Web端，Pro(最近刚出)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.77586206896552&quot;&gt;
&lt;p&gt;遇到错误可以翻看&lt;a href=&quot;https://github.com/ant-design/ant-design/issues&quot;&gt;Antd的issues&lt;/a&gt;，基本能解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;提Issues的话要符合一定规范，一开始感觉麻烦，后来看了&lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way&quot;&gt;提问的智慧&lt;/a&gt;，恍然大悟这部分的必要性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;扩展内容&quot;&gt;扩展内容&lt;/h3&gt;
&lt;h4 id=&quot;功能扩展&quot;&gt;功能扩展&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;讨论区数据统计分析，主要想知道一段时间的热点内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;测试及优化&quot;&gt;测试及优化&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;现在项目代码是没有进行单元测试，后续学习集成JEST测试&lt;/li&gt;
&lt;li&gt;优化部分页面的组件以及一些bugs&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 25 Nov 2017 06:05:00 +0000</pubDate>
<dc:creator>jianhuicode</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lmf-techniques/p/7852525.html</dc:identifier>
</item>
<item>
<title>【技术翻译】支持向量机简明教程及其在python和R下的调参 - VincentCheng</title>
<link>http://www.cnblogs.com/vincentcheng/p/7887033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vincentcheng/p/7887033.html</guid>
<description>&lt;p&gt;原文:&lt;a href=&quot;http://blog.hackerearth.com/simple-tutorial-svm-parameter-tuning-python-r&quot; target=&quot;_blank&quot;&gt; &lt;span&gt;Simple Tutorial on SVM and Parameter Tuning in Python and R &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171123205412484-1808227105.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据在机器学习中是重要的一种任务，支持向量机(SVM)在模式分类和非线性回归问题中有着广泛的应用. SVM最开始是由N. Vapnik and Alexey Ya. Chervonenkis&lt;/p&gt;
&lt;p&gt;在1963年提出。从那时候开始，各种支持向量机被成功用于解决各种现实问题，比如文本聚类，图像分类，生物信息学(蛋白质分类，癌症分类)，手写字符识别等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 什么是支持向量机(support vector machine)?&lt;/p&gt;
&lt;p&gt;2. 支持向量机如何工作?&lt;/p&gt;
&lt;p&gt;3. 支持向量机的推导&lt;/p&gt;
&lt;p&gt;4. 支持向量机的优点和缺点&lt;/p&gt;
&lt;p&gt;5. Python和R下的支持向量机实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是支持向量机?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持向量机是一种可以用来解决分类问题和回归问题的监督式机器学习算法. 它使用一种叫做核方法(kernel trick)的技术来对数据进行转换，&lt;/p&gt;
&lt;p&gt;基于这些转换，它在各种可能的解中找到最优的边界.&lt;/p&gt;
&lt;p&gt;简而言之, 为了根据数据标签将数据分开来，SVM对数据进行一些很复杂的转换. 这篇文章，我们只会讨论SVM的分类算法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171123210820546-1480747671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持向量机如何工作?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要了解SVM如何工作最主要的是了解最大化训练数据间隔的&lt;strong&gt;最优分隔超平面(optimal separating hyperplane)&lt;/strong&gt;是什么. 我们一个一个数据来接近这个目标.&lt;/p&gt;
&lt;p&gt;什么是分类超平面?&lt;/p&gt;
&lt;p&gt;对于上面那幅图，我们是能够分开那些数据的. 比如我们可以在数据中间画一条线, 线下面全是绿色数据点，线上面全是红色数据点.&lt;/p&gt;
&lt;p&gt;那么问题来了，它明明是条线，你为什么叫它超平面呢?&lt;/p&gt;
&lt;p&gt;在上面的图中, 我们仅仅考虑了最简单的情形，数据分布于2-维平面. 然而SVM在一般的n-维空间也能工作. 而在更高维空间, 超平面是平面的一般情况. &lt;/p&gt;
&lt;p&gt; 比如：&lt;/p&gt;
&lt;p&gt;1 维数据，一个点代表着超平面&lt;/p&gt;
&lt;p&gt;2 维数据，一条线代表着超平面&lt;/p&gt;
&lt;p&gt;3 维数据，一个平面代表着超平面&lt;/p&gt;
&lt;p&gt;对于更高维数据，就叫做超平面&lt;/p&gt;
&lt;p&gt;前面我们提到，SVM的目标是找到最优分隔超平面. 那么什么样的超平面才是最优的呢?事实是存在分隔超平面并不一定代表它就是最优的.&lt;/p&gt;
&lt;p&gt;下面我们通过几张图来理解这个问题.&lt;/p&gt;
&lt;p&gt;1. 很多超平面&lt;/p&gt;
&lt;p&gt;下图中有很多超平面，那个才是分隔超平面呢？很容易看出线B 是能够很好区分两个类的超平面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171124092226703-72072705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 很多分隔超平面&lt;/p&gt;
&lt;p&gt; 也可能出现有多个分隔超平面的情况. 我们如何找到最优分隔超平面呢, 直观上来说，如果我们选择了一个距离一类点很近的超平面，那么它的泛化能力肯定不是很好. 所以要找到距离各个类中的点都尽可能元的超平面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171124092835875-527848182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在上图中，最优超平面就是超平面B.&lt;/p&gt;
&lt;p&gt;因此, 最大化每一类中距离超平面最近的点和超平面之间的距离，就能得到最优分隔超平面. 这个距离被称作: 边界(margin).&lt;/p&gt;
&lt;p&gt;SVM的目标就是找到最优超平面, 因为它不仅仅可以对现有的数据分类，也能够对未知的数据进行预测. 最优超平面也就是有着最大边界(margin)的超平面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171124093841515-1734488233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数学推导&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经大概了解了算法背后的基本概念，接下来我们看看SVM的数学推导&lt;/p&gt;
&lt;p&gt;我假设你已经对基本的向量，向量代数，数学，正交投影有了基本的了解. 这些概念都可以在这篇文章中有介绍: &lt;a href=&quot;http://blog.hackerearth.com/prerequisites-linear-algebra-machine-learning&quot; target=&quot;_blank&quot;&gt;机器学习中的线性代数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超平面方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你肯定知道直线方程可以是： $y = mx + c$, m是直线的斜率, c是直线的y轴截距.&lt;/p&gt;
&lt;p&gt;更一般的超平面的方程如下：&lt;/p&gt;
&lt;p&gt;$$W^Tx = 0$$&lt;/p&gt;
&lt;p&gt;式中, $x$和$w$是向量, $W^Tx$,代表向量的点积, $W$通常被称为权向量.&lt;/p&gt;
&lt;p&gt;对于上面的直线$y - mx -c = 0$. 在这种情况下:&lt;/p&gt;
&lt;p&gt;$w = \begin{pmatrix} &lt;/p&gt;
&lt;p&gt;-c\\&lt;/p&gt;
&lt;p&gt; -m\\&lt;/p&gt;
&lt;p&gt; &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;1 &lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;\end{pmatrix}$&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;$x = \begin{p&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;matrix}&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;1\\ &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;x&lt;em id=&quot;__mceDel&quot;&gt;\\&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;y&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;\end{matrix}$ &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;$W^Tx = 0$&lt;/p&gt;
&lt;p&gt;仅仅是同一样东西的两种不同表达. 那么我们为什么使用$W^Tx = 0$. 仅仅是因为在面对高维数据的时候，这种表达更好处理. $W$代表垂直平面的向量, 这种特性在我们计算点到超平面距离的时候很有用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解限制条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我们分类问题中的训练数据是$\{(x_1,y_1), (x_2, y_2),...,(x_n,y_n)\}\in R^n * \{-1, 1\}.$ 这意味着训练数据是一些$x_i$, n 维向量， $y_i$是$x_i$的标签，$y_i$ = 1 意味着特征向量$x_i$属于类别1，反之属于类别 -1.&lt;/p&gt;
&lt;p&gt;在一个分类问题中，我们试着找出一个函数 $y = f(x):R^n\rightarrow \{-1,1\}$，这个函数是从训练数据学习得到. 然后我们用这个函数来预测未知数据的类别.&lt;/p&gt;
&lt;p&gt;f(x)有无数种可能性，我们必须给他加一个限制条件，缩小f(x)的范围. 在SVM的例子中, f(x)  必须满足$W^Tx = 0$&lt;/p&gt;
&lt;p&gt;也可以被表示为 $\vec{w}\cdot\vec{x} + b = 0; \vec{w} \in R^n and b \in R$&lt;/p&gt;
&lt;p&gt; 这将输入空间分为两个部分，一部分是-1类别，一部分是1类别&lt;/p&gt;
&lt;p&gt;接下来的文章，我们会考虑2维向量，假设$H_0$是数据的分隔超平面，满足以下条件:&lt;/p&gt;
&lt;p&gt;$\vec{w}\cdot\vec{x} + b = 0 $&lt;/p&gt;
&lt;p&gt;在有$H_0$情况下，我们可以选择两个其他的超平面$H_1$和$H_2$，他们也可以分隔数据且满足以下方程:&lt;/p&gt;
&lt;p&gt;$\vec{w}\cdot\vec{x} + b = -\ sigma $ $\vec{w}\cdot\vec{x} + b = \sigma $&lt;/p&gt;
&lt;p&gt;这使得$H_0$到$H_1$和$H_2$的距离相等&lt;/p&gt;
&lt;p&gt;变量$\sigma$的不确定的，因此我们可以令\sigma = 1来简化问题.&lt;/p&gt;
&lt;p&gt;$\vec{w}\cdot\vec{x} + b =-1 $ $\vec{w}\cdot\vec{x} + b = 1 $&lt;/p&gt;
&lt;p&gt;接下来我们要确定这二者之间没有其他点. 因此我们会选择满足以下限制条件的超平面, 对于每个向量$x_i$：&lt;/p&gt;
&lt;p&gt;要么：$对于属于-1 类的x_i 来说 \vec{w} \cdot \vec{x} \leq -1$&lt;/p&gt;
&lt;p&gt;要么&lt;em id=&quot;__mceDel&quot;&gt;：$对于属于 1类的x_i 来说 \vec{w} \cdot \vec{x} \geq 1$&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171125100229250-1575427779.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上述限制条件可以整合到一个式子中：$y_i(\vec{w}\cdot\vec{x_i}) \geq 1 i \in [1,n]$&lt;/p&gt;
&lt;p&gt;为了简洁我们略去计算margin的推导： margin用m来表示:&lt;/p&gt;
&lt;p&gt;$m = \frac{2}{||\vec{w}||}$&lt;/p&gt;
&lt;p&gt;式子中的唯一变量就是$w$，因此最大化margin我们可以转化为最小化$||\vec{w}||$, 优化目标可以转化为以下:&lt;/p&gt;
&lt;p&gt;$$Min  \frac{||\vec{w}||}{2}$$&lt;/p&gt;
&lt;p&gt;$$S.t. y_i(\vec{w} \cdot \vec{x_i}+b) \geq 1,  对于\forall i = 1,...,n$$&lt;/p&gt;
&lt;p&gt;上面的式子在我们的数据是完全线性可分的时候是有效的，但是有些时候我们的数据并不是完全线性可分的，或者说数据由于受到噪声的干扰，即使线性可分，但是噪声会使得找到的超平面并不是最优的.&lt;/p&gt;
&lt;p&gt; 对于这个问题我们引入松弛变量(slack variable), 允许一些点落到分类间隔之内，但是对于这些点我们进行一些惩罚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953691/201711/953691-20171125120901781-1992694270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，算法尽量使得松弛变量为0. 算法最小化的不是错分类的综述，而是最小化总的错分距离.&lt;/p&gt;
&lt;p&gt;限制条件现在变为：$y_i(\vec{w}\cdot\vec{x_i} + b) \geq 1- \varsigma_i, \forall 1 \geq i \leq n_i, \varsigma_i \geq 0$&lt;/p&gt;
&lt;p&gt;优化目标变为：&lt;/p&gt;
&lt;p&gt;参数$C$是正则化参数控制松弛变量大小和分类间隔大小的平衡.&lt;/p&gt;
&lt;p&gt;小$C$会使得越过边界的点更容易被忽视，从而使得边界增大.&lt;/p&gt;
&lt;p&gt;大$C$会使得越过边界的点更难被忽视，从而使得边界减小.&lt;/p&gt;
&lt;p&gt;对于$C = \inf$, 所有的限制条件都是强制的.&lt;/p&gt;
&lt;p&gt; 对于2-维平面来说，最好的分类方式就是一条直线，对于3-维空间来说，最好的分类方式就会一个平面。但是并不是每次都能使用直线或者平面达到完美的分类，有时候我们需要用非线性区域来将类别分开.SVM使用核函数来解决这种非线性分类问题，核函数能够将数据映射到一个不同的空间，在这个空间中，我们可以使用线性超平面将数据分开. 这种方法被称为核方法.&lt;/p&gt;
&lt;p&gt;假设 $\phi$是将$x_i$映射到$\phi(x)$的核函数，限制条件变为：&lt;/p&gt;
&lt;p&gt;$$y_i(\vec{w}\cdot\vec{x_I} +b) \geq 1- \varsigma_i, \forall  1 \leq i \geq n, \varsigma_i \geq 0$$&lt;/p&gt;
&lt;p&gt;优化目标变为：&lt;/p&gt;
&lt;p&gt;这里我们不深入如何去解这个优化问题，最常见解决这类问题的方法是凸优化(convex optimization)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SVM的优点和缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对特定的数据集，每个分类算法都有自己的优点和缺点. SVM的优点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优化目标的凸优化本质保证了找到最优解的可行性. 而且这个最优解是全局最优解而不是局部最优解&lt;/li&gt;
&lt;li&gt;SVM既适用于线性可分数据也适用于非线性可分数据(使用核方法就可以), 只要找到对应的惩罚参数C就可以.&lt;/li&gt;
&lt;li&gt;对于高维数据和低维数据，SVM都有效, 即使在高维数据下SVM也能很高效工作，因为SVM的特性只由支持向量数目确定，而不是整个数据的维度, 非支持向量之外的数据点对于SVM无关紧要，甚至可以去除.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SVM缺点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;他们不适合大数据集训练，因为训练时间很长，而且对计算性能要求较高&lt;/li&gt;
&lt;li&gt;对于有重叠类别的噪声数据，SVM不是很有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Python和R下的SVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;python下最常用的实现机器学习算法的库是scikit-learn, SVM在scikit-learn下的分类函数是svm.SVC()&lt;/p&gt;
&lt;p&gt;sklearn.svm.SVC(c = 1.0, kernel = 'rbf',degree=3, gamma='auto')&lt;/p&gt;
&lt;p&gt;参数如下：&lt;/p&gt;
&lt;p&gt;C：正则化参数&lt;/p&gt;
&lt;p&gt;kernel: 算法中使用的核函数, 可以是 'linear','poly','rbf','sigmoid','precomputed', 或者是用户函数. 默认值是'rbf'&lt;/p&gt;
&lt;p&gt;degree: 'poly' 多项式核函数中的维度，默认是3，其他核函数忽略这个参数&lt;/p&gt;
&lt;p&gt;gamma: 'rbf','poly','sigmoid' 中的系数, 如果gamma是'auto' 那么会默认使用1/n 个特&lt;em id=&quot;__mceDel&quot;&gt;征&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里很多参数我在这篇文章中都没有提到过，进一步了解你可以查看&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们可以通过改变参数 C, \gamma 和核函数来优化SVM, scikit-learn中参数参数优化函数是gridSearch().&lt;/p&gt;
&lt;p&gt;sklearn.model_selection.GridSearchCV(estimator, param_grid)&lt;/p&gt;
&lt;p&gt;参数如下：&lt;/p&gt;
&lt;p&gt;estimator：是我们我估计的对象，比如这里就是svm.SVC()&lt;/p&gt;
&lt;p&gt;param_grid：包含要优化的参数名字和要优化的值的字典或者列表&lt;/p&gt;
&lt;p&gt;在上述代码中，我们要考虑优化的参数是C和gamma, 这些参数的最优值在我们给定的参数中，这里我们仅仅给出了一些值，我们也可以给出一系列取值范围，但是这样程序执行的时间会变长.&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 06:05:00 +0000</pubDate>
<dc:creator>VincentCheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vincentcheng/p/7887033.html</dc:identifier>
</item>
<item>
<title>Linux笔记（固定USB摄像头硬件端口，绑定前后置摄像头） - 小清奈</title>
<link>http://www.cnblogs.com/zou107/p/7895111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zou107/p/7895111.html</guid>
<description>&lt;p&gt;在Android的系统会有前置摄像头和后置摄像头的定义，摄像头分为SOC类型的摄像头和USB这一类的摄像头，接下要分析就是USB摄像头这一类 。&lt;/p&gt;
&lt;p&gt;一般在android或者linux系统中分析一个模块，先从总体的框架上有一个认识，然后在局部细细的研究。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 一、Android 摄像头总体架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/646301/201711/646301-20171125130710218-1673293767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的框架，分析的比较粗糙，主要是一些自己看代码后总结下来的东西。以USB摄像为例，在插入的USB摄像头后，会生成/dev/video0这样的设备节点，而在硬件抽象层中，会去判断是否存在该设备节点，以提供给android系统层使用。再往上分析就是android部分的了，先暂时不分析。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Linux层中UVC摄像头注册流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/646301/201711/646301-20171125131901531-1551779121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在USB子系统判断有UVC设备接入后，会去调用uvc_probe（代码位置：/driver/media/uvc/uvc_driver.c）来完成USB摄像头的创建，通过一步一步的分析，最终会走到v4L2框架中，创建摄像头的设备节点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、固定USB摄像头硬件端口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面分析了这么多，都是为了接下来的做准备。&lt;/p&gt;
&lt;p&gt; 现在客户那么使用我们的主板机器，其中会使用两个USB摄像头，一个作为前置摄像头用于人脸识别，一个用于后置摄像头，由于在安装时并不知道那个端口的摄像头先插入，那个后插入（设备节点中先接入的就会分配video0，而在android中一般定义video0为后置摄像头，video1为前置摄像头），就导致android系统层前后置摄像头混乱。&lt;/p&gt;
&lt;p&gt;为了解决该问题，就需要在驱动中，将前后置摄像头和USB的硬件端口做一个绑定。&lt;/p&gt;
&lt;p&gt;具体改法如下：&lt;/p&gt;
&lt;p&gt;（1） 在/include/media/v4l2-dev.h的&lt;strong&gt;video_device&lt;/strong&gt;结构体中添加变量portnum&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; video_device
     &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; list_head    fh_list; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; List of struct v4l2_fh &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
     &lt;span&gt;int&lt;/span&gt; debug;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Activates debug level&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
+    &lt;span&gt;int&lt;/span&gt; portnum;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;usb hw port&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在/drivers/media/usb/uvc/uvc_driver.c的&lt;strong&gt;uvc_register_video&lt;/strong&gt;函数中添加vdev-&amp;gt;portnum = dev-&amp;gt;udev-&amp;gt;portnum;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; uvc_register_video(&lt;span&gt;struct&lt;/span&gt; uvc_device *&lt;span&gt;dev,
...
     stream&lt;/span&gt;-&amp;gt;vdev =&lt;span&gt; vdev;
     video_set_drvdata(vdev, stream);
 
&lt;/span&gt;+    vdev-&amp;gt;portnum = dev-&amp;gt;udev-&amp;gt;&lt;span&gt;portnum;
     ret &lt;/span&gt;= video_register_device(vdev, VFL_TYPE_GRABBER, -&lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里先将USB的portnum存下来，在创建设备节点的是否，就会根据该变量来区分硬件的上哪个USB是前置，哪个USB是后置了&lt;/p&gt;
&lt;p&gt; （3）在/drivers/media/v4l2-core/v4l2-dev.c的&lt;strong&gt;__video_register_device&lt;/strong&gt;函数中，修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;int&lt;/span&gt; __video_register_device(&lt;span&gt;struct&lt;/span&gt; video_device *vdev, &lt;span&gt;int&lt;/span&gt; type, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nr,
 ...
     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Pick a device node number &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;videodev_lock);&lt;/span&gt;+    &lt;span&gt;if&lt;/span&gt;(vdev-&amp;gt;vfl_type ==&lt;span&gt; VFL_TYPE_GRABBER) {
&lt;/span&gt;+        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt; == vdev-&amp;gt;&lt;span&gt;portnum) {
&lt;/span&gt;+            nr = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;+            nr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+&lt;span&gt;        }
&lt;/span&gt;+    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;+        nr = devnode_find(vdev, nr == -&lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;0&lt;/span&gt;&lt;span&gt; : nr, minor_cnt);
&lt;/span&gt;+&lt;span&gt;    }
&lt;/span&gt;+
     &lt;span&gt;if&lt;/span&gt; (nr ==&lt;span&gt; minor_cnt)
         nr &lt;/span&gt;= devnode_find(vdev, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, minor_cnt);
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nr == minor_cnt) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：这里的“4 == vdev-&amp;gt;portnum”是根据时机板子的端口上的，在调试的时候，可以先将portnum变量的值打印出来，就知道如何区分了。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 05:44:00 +0000</pubDate>
<dc:creator>小清奈</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zou107/p/7895111.html</dc:identifier>
</item>
</channel>
</rss>