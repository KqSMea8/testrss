<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>安装scrapy出错Failed building wheel for Twisted - 纳米小子</title>
<link>http://www.cnblogs.com/1991-1025/p/9069927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1991-1025/p/9069927.html</guid>
<description>&lt;p&gt;&lt;span&gt;用&lt;/span&gt;64&lt;span&gt;位&lt;/span&gt;&lt;span&gt;windows10&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt;命令安装&lt;/span&gt;&lt;span&gt;pip install scrapy&lt;/span&gt;&lt;span&gt;出错：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  Running setup.py bdist_wheel for Twisted ... error&lt;/p&gt;
&lt;p&gt;  Failed building wheel for Twisted&lt;/p&gt;
&lt;p&gt;  Running setup.py clean for Twisted&lt;/p&gt;
&lt;p&gt;Failed to build Twisted&lt;/p&gt;
&lt;p&gt;Installing collected packages: pycparser, cffi, asn1crypto, cryptography, pyOpenSSL, Twisted, pyasn1, pyasn1-modules, service-identity, queuelib, scrapy&lt;/p&gt;
&lt;p&gt;  Running setup.py install for Twisted ... error&lt;/p&gt;
&lt;p&gt;Exception:&lt;/p&gt;
&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\compat\__init__.py&quot;, line 73, in console_to_str&lt;/p&gt;
&lt;p&gt;    return s.decode(sys.__stdout__.encoding)&lt;/p&gt;
&lt;p&gt;UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb6 in position 30: invalid start byte&lt;/p&gt;

&lt;p&gt;During handling of the above exception, another exception occurred:&lt;/p&gt;

&lt;p&gt;Traceback (most recent call last):&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\basecommand.py&quot;, line 215, in main&lt;/p&gt;
&lt;p&gt;    status = self.run(options, args)&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\commands\install.py&quot;, line 342, in run&lt;/p&gt;
&lt;p&gt;    prefix=options.prefix_path,&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\req\req_set.py&quot;, line 784, in install&lt;/p&gt;
&lt;p&gt;    **kwargs&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\req\req_install.py&quot;, line 878, in install&lt;/p&gt;
&lt;p&gt;    spinner=spinner,&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\utils\__init__.py&quot;, line 676, in call_subprocess&lt;/p&gt;
&lt;p&gt;    line = console_to_str(proc.stdout.readline())&lt;/p&gt;
&lt;p&gt;  File &quot;e:\python\envs\py2scripy\lib\site-packages\pip\compat\__init__.py&quot;, line 75, in console_to_str&lt;/p&gt;
&lt;p&gt;    return s.decode('utf_8')&lt;/p&gt;
&lt;p&gt;UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb6 in position 30: invalid start byte&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/793673/201805/793673-20180521231028962-628619515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考连接方法：&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/45830222/a-error-happened-while-pip-was-installing-scrapy&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 15:12:00 +0000</pubDate>
<dc:creator>纳米小子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1991-1025/p/9069927.html</dc:identifier>
</item>
<item>
<title>Effective java-对象的创建和销毁 - 猿来茹此</title>
<link>http://www.cnblogs.com/nijunyang/p/9069885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/9069885.html</guid>
<description>&lt;p&gt;说到java对象的创建，首先应该提下java的内存机制，最主要的两块应该就是堆内存和栈内存。&lt;/p&gt;
&lt;p&gt;简单点来说栈内存主要是保存基本数据类型的值和保存引用变量，堆内存主要用来存放new产生的对象，数组。&lt;/p&gt;
&lt;p&gt;堆是被所有线程共享的一块内存区域，在虚拟机启动的时候被创建。我的理解就是堆是用来存放实实在在东西的，而栈只是用来存放一个编号的。&lt;/p&gt;
&lt;p&gt;好比你是个真实存在的人（编号9527，这个就是那些栈中引用指向的地方），你就是放在堆中，你的名字叫张三，而这个张三是放在栈中一个引用变量，你也可以有一个小名叫李二狗，这个李二狗和张三都是指向堆中9527这个对象。&lt;/p&gt;
&lt;p&gt;其次还有方法区。方法区用来存放已被加载的类的信息、常量、静态变量。常量池是在方法区中而不是堆内存中，”AAA“字符串是在常量池的 ，new String（”AAA“），会在常量创建一个”AAA“字符串，还会在堆中创建一个字符串对象。&lt;/p&gt;

&lt;p&gt;对象的创建：&lt;/p&gt;
&lt;p&gt;1.避免创建不必要的对象，避免在方法内部创建对象，因为如果在方法内部创建对象XX xxx = new XXX();不考虑线程安全的条件下如果有N个线程调用该方法，那么就会创建N个XXX对象。&lt;/p&gt;
&lt;p&gt;2.考虑使用单例模式&lt;/p&gt;
&lt;p&gt;3.一些不需要改变的工具类可以使用static静态代码块来初始化。private static final XXX xxx；static {xxx = new XXX();}，首先static 修饰的字段是属于类的，所有对象都可以使用，其次静态代码块只会在类加载的时候初始化一次也就只会创建一个XXX对象。&lt;/p&gt;
&lt;p&gt;4.尽量使用基础数据类型，避免使用包装类，一是拆箱装箱耗时，二是对象比基础数据更占内存。可以试试：Long sum = 0L;for(int i = 0;i&amp;lt;Integer.MAX_VALUE;i++){sum += i;}，将sum的生命改成基础数据类型long再试试。&lt;/p&gt;
&lt;p&gt;对象的销毁：java中如果一个栈先增长，再收缩，那么从栈中弹出来的对象不会被当作垃圾回收，即使栈中已经不再引用这些对象。因为栈中还维护对这些对象的过期引用（永远也不会再被解除的引用）&lt;/p&gt;
&lt;p&gt;1.某些情况下，可以考虑将某些引用置空告诉jvm这个对象已经没有引用了；即使后面再有使用也会抛出空异常，很快便可以发现问题。&lt;/p&gt;
&lt;p&gt;2.避免调用finalizer 方法，子类如果重写该方法清除一些资源，切记在重写方法中还要手动调用父类的该方法super.finalizer ();而且最好是在finally中调用，保证不管发生什么异常父类的finalizer 方法都会执行&lt;/p&gt;
&lt;p&gt;3.可以考虑提供一些清理资源的方法。比如io流相关类都提供close方法，数据库连接Connection也有close关闭连接&lt;/p&gt;

</description>
<pubDate>Mon, 21 May 2018 15:04:00 +0000</pubDate>
<dc:creator>猿来茹此</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nijunyang/p/9069885.html</dc:identifier>
</item>
<item>
<title>用Visual Studio Code Debug世界上最好的语言(Mac篇) - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/9069882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/9069882.html</guid>
<description>&lt;p&gt;首先,你要有台Macbook Pro,接着才继续看这个教程.&lt;/p&gt;
&lt;p&gt;PS:Windows用户看这里&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25844268&quot;&gt;用Visual Studio Code Debug世界上最好的语言&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;brew-环境准备&quot;&gt;brew 环境准备&lt;/h2&gt;
&lt;p&gt;见&lt;a href=&quot;https://brew.sh/index_zh-cn&quot;&gt;brew.sh&lt;/a&gt;,或者&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;/usr/bin/ruby&lt;/span&gt; -e &lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;php7-nginx-php-fpm-xdebug&quot;&gt;PHP7 + nginx + php-fpm + xdebug&lt;/h2&gt;
&lt;h3 id=&quot;php7&quot;&gt;PHP7&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;brew&lt;/span&gt; install php@7.1&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完了之后看下安装路径:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; php&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;##➜  ~ where php&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;##   /usr/local/opt/php@7.1/bin/php&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;##   /usr/bin/php&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般php.ini在/usr/local/etc/php/7.1&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ls&lt;/span&gt; /usr/local/etc/php/7.1
&lt;span class=&quot;co&quot;&gt;#conf.d       pear.conf    php-fpm.conf php-fpm.d    php.ini&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;待会我们配置xdebug和php-fpm的时候会用到这个这些配置文件的,先跳过&lt;/p&gt;
&lt;h2 id=&quot;xdebug安装&quot;&gt;xdebug安装&lt;/h2&gt;
&lt;p&gt;本来其实一句brew install php71-xdebug --without-homebrew-php就完事的,谁知道homebrew-php最近被移除了,所以就尴尬了...&lt;/p&gt;
&lt;p&gt;手动去下载xdebug然后配置吧.下载页面:&lt;a href=&quot;https://xdebug.org/files/&quot; class=&quot;uri&quot;&gt;https://xdebug.org/files/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择自己要安装的版本,我这里选了2.6.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 创建一个你喜欢的路径存放,我放在了~/tool/目录下;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; tool&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;wget&lt;/span&gt; https://xdebug.org/files/xdebug-2.6.0.tgz&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 解压&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; xvzf xdebug-2.6.0.tgz&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; xdebug-2.6.0&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 初始化php模块&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;phpize;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 生成对应的so文件&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# ./configure --enable-xdebug --with-php-config=PHP安装路径/bin/php-config;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;./configure&lt;/span&gt; --enable-xdebug --with-php-config=/usr/local/Cellar/php@7.1/7.1.17/bin/php-config&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 上一步正常执行完毕之后会在xdebug-2.6.0/modules/文件夹下生成xdebug.la和xdebug.so,待会我们在php.ini中配置xdebug会用到这个文件&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;安装nginx&quot;&gt;安装nginx&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;brew&lt;/span&gt; install nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;配置nginx.conf&quot;&gt;配置nginx.conf&lt;/h3&gt;
&lt;p&gt;安装完成之后开始配置nginx,首先创建一堆需要用到的文件件.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /usr/local/var/logs/nginx
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /usr/local/etc/nginx/sites-available
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /usr/local/etc/nginx/sites-enabled
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /usr/local/etc/nginx/conf.d
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /usr/local/etc/nginx/ssl
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; mkdir -p /var/www
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; chown :staff /var/www
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; chmod 777 /var/www

&lt;span class=&quot;co&quot;&gt;#作者：GQ1994&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#链接：https://www.jianshu.com/p/a642ee8eca9a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#來源：简书&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后vim /usr/local/etc/nginx/nginx.conf 输入以下内容：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;user root wheel; #默认的是nobody会导致403
worker_processes  1;

error_log   /usr/local/var/logs/nginx/error.log debug;


pid        /usr/local/var/run/nginx.pid;


events {
    worker_connections  256;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /usr/local/var/logs/access.log  main;

    sendfile        on;
    keepalive_timeout  65;
    port_in_redirect off;

    include /usr/local/etc/nginx/sites-enabled/*;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置nginx-php-fpm配置文件&quot;&gt;设置nginx php-fpm配置文件&lt;/h3&gt;
&lt;p&gt;vim /usr/local/etc/nginx/conf.d/php-fpm&lt;br/&gt;修改为(没有则创建)&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;#proxy the php scripts to php-fpm
location ~ \.php$ {
    try_files                   $uri = 404;
    fastcgi_pass                127.0.0.1:9000;
    fastcgi_index               index.php;
    fastcgi_intercept_errors    on;
    include /usr/local/etc/nginx/fastcgi.conf;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建默认虚拟主机default&quot;&gt;创建默认虚拟主机default&lt;/h3&gt;
&lt;p&gt;vim /usr/local/etc/nginx/sites-available/default输入：&lt;/p&gt;
&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;server {
listen       80;#如果80被用了可以换成别的,随你开心
server_name  www.qilipet.com admin.qilipet.com;
root   /var/www/pet/public;

access_log  /usr/local/var/logs/nginx/default.access.log  main;
index index.php index.html index.htm;

location / {
            # First attempt to serve request as file, then
            # as directory, then fall back to displaying a 404.
            try_files $uri $uri/ /index.php?$query_string;
            # Uncomment to enable naxsi on this location
            # include /etc/nginx/naxsi.rules
    }

location ~ \.php$ {
            fastcgi_pass  127.0.0.1:9000;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            include    fastcgi_params;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此部分内容基本来自&lt;a href=&quot;https://www.jianshu.com/p/a642ee8eca9a&quot;&gt;GQ1994:mac下配置php、nginx、mysql、redis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置php.ini&quot;&gt;配置php.ini&lt;/h2&gt;
&lt;p&gt;回到我们的/usr/local/etc/php/7.1文件夹&lt;/p&gt;
&lt;p&gt;在php.ini中加入xdebug配置&lt;/p&gt;
&lt;pre class=&quot;ini&quot;&gt;
&lt;code&gt;
[xdebug]
;zend_extension=&quot;刚刚的xdebug路径/modules/xdebug.so&quot;
zend_extension=&quot;~/tool/xdebug-2.6.0/modules/xdebug.so&quot;
xdebug.remote_enable = 1
xdebug.remote_autostart = 1
xdebug.remote_connect_back = 1
;默认的9000已经被php-fpm占用了,切记换一个端口
xdebug.remote_port = 9001
xdebug.scream = 0
xdebug.show_local_vars = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启一下php-fpm和nginx,看一下php是不是都正常跑起来了.&lt;/p&gt;
&lt;h2 id=&quot;vs-code配置&quot;&gt;VS Code配置&lt;/h2&gt;
&lt;h3 id=&quot;user-settings配置php目录&quot;&gt;User Settings配置PHP目录&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;  &lt;span class=&quot;er&quot;&gt;&quot;php.executablePath&quot;:&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;&quot;/usr/local/opt/php@7.1/bin/php&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;安装php-debug插件&quot;&gt;安装php debug插件&lt;/h3&gt;
&lt;p&gt;安装完成之后配置一下launch.json&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;使用&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;IntelliSense&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;了解相关属性。&lt;/span&gt; 
    &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;悬停以查看现有属性的描述。&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;欲了解更多信息，请访问&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;https://go.microsoft.com/fwlink/?linkid=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;830387&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0.2.0&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;

        &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Listen for XDebug&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;php&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;port&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9001&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;//默认是&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9000&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;已经被php-fpm占用&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;上一步我们配置远程端口是9001&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Launch currently open script&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;php&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;program&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;${file}&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;cwd&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;${fileDirname}&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;port&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9001&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;//默认是&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;9000&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;已经被php-fpm占用&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;上一步我们配置远程端口是9001&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就愉快debug最好的语言吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-21%20%E4%B8%8B%E5%8D%8810.16.58.png&quot; alt=&quot;debug&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他部分&quot;&gt;其他部分&lt;/h2&gt;
</description>
<pubDate>Mon, 21 May 2018 15:03:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/9069882.html</dc:identifier>
</item>
<item>
<title>最坏的不是面试被拒，而是没面试机会，以面试官视角分析哪些简历至少能有面试机会 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9063154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9063154.html</guid>
<description>&lt;p&gt;    本人在之前的博客里写了很多面试技巧，这是有个前提：至少候选人被面试了，在这个前提下，候选人哪怕失败了，至少也能用实战来检验和校对面试准备的结果，用句比较时髦的话来说就是试错，多试几次之后总能找到正确的方式。&lt;/p&gt;
&lt;p&gt;    本人在技术面试的实践中，对简历会做初步的筛选，在这过程中，会发现有些简历是一定通不过的，也就是说不会有面试机会，甚至如果该候选人用这份简历，在其它公司也未必能得到面试机会，那么这类候选人就比较悲催了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180520135422344-2101948642.png&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    为什么这么说呢？第一，这些候选人往往甚至不会意识到这些，往往继续用这份简历投，这样大把时间就这样浪费了。第二，如果真的是瞎猫碰上死耗子，得到技术面试的机会，那么面试官在阅读这份简历时，对该候选人的印象不会很好，也就是说，这类候选人得在面试中表现非常出色才能应聘成功。&lt;/p&gt;
&lt;p&gt;     如果这类候选人能力差倒也算了，但如果能力尚可（或比较优秀），那么这就非常可惜了。&lt;/p&gt;
&lt;p&gt;     在这博客的主要内容有如下四点。&lt;/p&gt;
&lt;p&gt;     第一，哪类简历一定没面试机会。 &lt;/p&gt;
&lt;p&gt;     第二，如何让简历为你争取更多的面试机会。 &lt;/p&gt;
&lt;p&gt;     第三，如何在简历中高效地叙述项目经验。&lt;/p&gt;
&lt;p&gt;     第四，在项目经验比较少的情况下（比如毕业生或实习生或初级开发），如何挖掘项目经验。&lt;/p&gt;
&lt;p&gt;     其它内容，比如如何在面试中叙述项目经验，以及如何表现，本文不管。&lt;/p&gt;
&lt;p&gt;     好了，正文开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180520140537937-1990099290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;1  别用万能简历来投递不同的工作&lt;/h4&gt;
&lt;p&gt;     用最简单的言辞说简历的筛选标准：不满足条件的简历会过滤掉。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521070223140-1113373248.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    虽然这看似废话，但我还真得说，因为在投简历时，不少候选人还真会往枪口上撞。此话怎讲？&lt;/p&gt;
&lt;p&gt;    一般在职位描述里，会写清楚本职位的具体要求，这里其实是非常仔细的，就相当于考纲，人事或技术面试官就按这个筛选简历，乃至做后面的面试。   &lt;/p&gt;
&lt;p&gt;    比如在某个职位介绍上有如下四点要求。&lt;em&gt;第一，计算机相关专业，本科以上学历，&lt;/em&gt;&lt;em&gt;4&lt;/em&gt;&lt;em&gt;年以上java&lt;/em&gt;&lt;em&gt;项目开发经验。第二，熟练Spring mvc&lt;/em&gt;&lt;em&gt;，Mybatis/Hibernate&lt;/em&gt;&lt;em&gt;等常用java&lt;/em&gt;&lt;em&gt;开发框架。第三，熟练使用Mysql&lt;/em&gt;&lt;em&gt;、Oracle&lt;/em&gt;&lt;em&gt;等数据库，具有查询优化的能力。第四，有银行相关的业务经验者优先。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    其中第一点是关于学历和工作年限的硬指标，如果这方面没达标，基本不会给面试机会。第二和第三点是关于具体技能要求的，在筛选时会着重看简历中的项目描述，以“Spring MVC“和“调优“等的关键字来确认候选人之前的工作经验是否和本岗位相匹配，而最后一点是加分项。&lt;/p&gt;
&lt;p&gt;     哪怕是针对同一个项目，哪怕是在其中做相同的事情（比如Java后端开发）， 不同的候选人写的简历，侧重点绝对不会相同。比如张同学会侧重Spring MVC框架，李同学会侧重SQL调优，虽然他们两者都做过。&lt;/p&gt;
&lt;p&gt;    但如果他们就拿这份只侧重一点的简历来投上述工作，也可能会被过滤掉。为什么？因为在职位介绍上写的明明白白，需要两个侧重点，但两位同学都只写了一个，虽然都做过。这谈不上可惜，谁让他们不仔细看职位描述？&lt;/p&gt;
&lt;p&gt;    我在帮别人做简历辅导时，这类问题普遍存在，针对性的建议是：&lt;strong&gt;别用万能简历投，仔细阅读各职位的介绍，然后投之前针对性地做微调。&lt;/strong&gt;    &lt;/p&gt;

&lt;h4&gt;2  别在简历中让面试官看到如下的情况&lt;/h4&gt;
&lt;p&gt;    在筛选简历时，除了上述学历等硬指标和项目技能因素之外，如果在简历中看到如下的情况，一般会慎重考虑甚至不给面试机会。&lt;/p&gt;
&lt;p&gt;    1 简历上，最近的项目经验和本岗位的无关。&lt;/p&gt;
&lt;p&gt;    比如本岗位要Spring cloud或spring boot，但候选人最近在做spring mvc，这或许还能给面试机会，但如果候选人最近做的是.NET，甚至做的不是开发而是测试等非相关的工作，那么可能就得不到面试机会了。&lt;/p&gt;
&lt;p&gt;    因为最近没在做，所以有可能该技能就被荒废掉了。毕竟需要拳不离手,曲不离口。&lt;/p&gt;

&lt;p&gt;    2 最近处于不在职状态，而且这持续时间长于3个月。&lt;/p&gt;
&lt;p&gt;    对此，如果简历上没给出诸如换城市或复习考研等合理的解释，那么公司可能就认为该候选人能力不行导致一直无法面试成功，所以一般不会给面试机会。&lt;/p&gt;

&lt;p&gt;    3 最近频繁跳槽，而且每份工作持续时间都不长。&lt;/p&gt;
&lt;p&gt;    出现这类情况，而且简历上没额外解释，公司会认为该候选人能力不行从而导致每份工作都做不长，或者稳定性不好，总之，出现这类情况，一般不会给面试机会。&lt;/p&gt;

&lt;p&gt;    4 虽然工作年限达标，但符合要求的项目年限不达标。&lt;/p&gt;
&lt;p&gt;    比如某工作需要5年以上java后端经验，小王工作虽然也有5年了，但简历上写的工作经验，其中1年是做测试，1年是做销售，java后端才3年经验，这类简历一般也会过滤掉。&lt;/p&gt;
&lt;p&gt;     请注意，职位介绍里要求5年以上经验，指的是商业项目经验，再说通俗点就是能挣到钱的项目经验。&lt;/p&gt;
&lt;p&gt;     在排查简历时，人事或技术面试官会去掉毕业设计，学习经验和一些培训学校给出的实训经验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521072858405-169291800.png&quot; alt=&quot;&quot; width=&quot;233&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    不是说这些项目经验对候选人没帮助，这里的意思是，因为客户需要为商业项目经验付钱，所以这类项目要求高，相比之下，上文中描述的其它经验含金量就低了。&lt;/p&gt;

&lt;h4&gt;3  在简历中，如何吸引面试官的注意？&lt;/h4&gt;
&lt;p&gt;    这个问题其实也很好回答：面试官只关心简历中和招聘要求相关的内容，包括技能描述和项目经验。&lt;/p&gt;
&lt;p&gt;    这个很好理解，比如某项目组需要招一个有5年经验的java后端开发，需要spring cloud,redis，oracle等技能，那么在挑选简历时，一定是根据这些关键字来看。&lt;/p&gt;
&lt;p&gt;    为了让面试官更高效地关注到你的简历，比较通用的做法是：&lt;/p&gt;
&lt;p&gt;    1 首先自然是写个人信息，比如手机号邮箱等。&lt;/p&gt;
&lt;p&gt;    2 其次，在首页的靠前位置，罗列出你的技术特长，比如擅长spring cloud，有Redis经验等。一般来说，这部分的总结需要和职位介绍相匹配，比如职位介绍列了5点，而且你全都满足时，你至少写上这5点，然后再写些其它你的特长。&lt;/p&gt;
&lt;p&gt;    如果你自己感觉有点没达标，那么尽量写上能弥补的技术擅长点，比如要求是要会用大数据经验，你实在没这方面的经验，那么至少些些SQL调优。 但至少在罗列自己技术擅长点时，得切题。&lt;/p&gt;
&lt;p&gt;    3 通过项目经验证明你熟悉刚才罗列出的技能，比如你刚才写，熟悉spring cloud，那么你就可以在项目介绍时，大致说下你项目背景，以及在其中你用到过哪些Spring cloud的组件。&lt;/p&gt;

&lt;h4&gt;4 如何介绍项目经验&lt;/h4&gt;
&lt;p&gt;    在简历中，其实最关键的是项目经验描述，在这部分里，你得让面试官感觉你有尽可能多的相关技术经验。 &lt;/p&gt;
&lt;p&gt;    假设有如下的职位描述。&lt;em&gt;1&lt;/em&gt;&lt;em&gt;、计算机及相关专业毕业，3&lt;/em&gt;&lt;em&gt;年以上Java Web&lt;/em&gt;&lt;em&gt;项目开发经验；熟悉Linux&lt;/em&gt;&lt;em&gt;平台。 2&lt;/em&gt;&lt;em&gt;、精通JAVA&lt;/em&gt; &lt;em&gt;编程，熟悉Spring&lt;/em&gt;&lt;em&gt;、Spring MVC&lt;/em&gt;&lt;em&gt;、Mybatis/Hibernate&lt;/em&gt;&lt;em&gt;等开源框架，熟悉常用cache&lt;/em&gt;&lt;em&gt;机制,Jsp/Servlet&lt;/em&gt;&lt;em&gt;等技术。 3&lt;/em&gt;&lt;em&gt;、熟悉Tomcat&lt;/em&gt;&lt;em&gt;、Nginx&lt;/em&gt;&lt;em&gt;等应用服务器的配置和优化。4&lt;/em&gt;&lt;em&gt;、熟悉数据结构和算法，熟悉Java&lt;/em&gt;&lt;em&gt;多线程开发。熟悉MySQL&lt;/em&gt;&lt;em&gt;、Redis&lt;/em&gt;&lt;em&gt;，熟悉数据库索引。5&lt;/em&gt;&lt;em&gt;、了解Web&lt;/em&gt;&lt;em&gt;前端技术，包括HTML5/CSS/Javascript&lt;/em&gt;&lt;em&gt;等。6&lt;/em&gt;&lt;em&gt;、拥有良好的沟通能力和文档能力。7&lt;/em&gt;&lt;em&gt;、勤奋而善于思考，愿意不断挑战和提升自己。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    那么我们就可以根据职位需求，从如下几个方面来描述项目经验。&lt;/p&gt;
&lt;p&gt;    第一，简要描述项目的背景，比如时间范围，客户是谁，项目规模有多大。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    从x&lt;/em&gt;&lt;em&gt;年x&lt;/em&gt;&lt;em&gt;月到现在（这个时间范围至少是最近半年），我参与某外汇交易系统，客户是xx&lt;/em&gt;&lt;em&gt;银行，这个项目组的构成是，1&lt;/em&gt;&lt;em&gt;位项目经理外加10&lt;/em&gt;&lt;em&gt;位开发，总共的规模大概在80&lt;/em&gt;&lt;em&gt;个人月左右。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    第二，大致描述项目的需求和包含哪些模块，然后简要说下你做了哪些模块，同时说下在这个项目用到的开发工具和主要技术点，这部分的描述如下所述。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    这个外汇交易系统包括挂盘撮合成交、实盘成交、反洗钱和数据批处理等模块，我主要负责了挂盘撮合成交模块，其中用到了Spring MVC&lt;/em&gt;&lt;em&gt;架构，数据库是Oracle&lt;/em&gt;&lt;em&gt;，用Mybatis&lt;/em&gt;&lt;em&gt;实现的ORM&lt;/em&gt;&lt;em&gt;，该系统是运行发布在Weblogic&lt;/em&gt;&lt;em&gt;服务器上，我们还用了Nginx&lt;/em&gt;&lt;em&gt;来实现负载均衡，用Redis&lt;/em&gt;&lt;em&gt;来缓存数据。在这个项目里，我还用到了JS&lt;/em&gt;&lt;em&gt;实现了一些前台页面。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    这里请大家注意如下的要点。&lt;/p&gt;
&lt;p&gt;    1 招聘方在看简历时，更关注的是用的技术，所以这里无需过度展开该项目里的业务细节，比如无需用大篇幅来写挂盘撮合成交模块里干了什么事情。&lt;/p&gt;
&lt;p&gt;    2 如果在这个项目里用到了职位介绍里给出的技术，应尽量写在项目描述里，但也要不能不顾事实地一股脑全写上。&lt;/p&gt;
&lt;p&gt;    第三，这里可以在刚才的基础上展开写这些技术在项目里是如何用的，以此来进一步证明你和所应聘职务的匹配度。同样这里也应围绕技术，而别多写业务细节，大家可以参考如下的范例。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    具体而言，在这项目的挂盘撮合成交模块里，我们用到Spring MVC&lt;/em&gt;&lt;em&gt;框架，用到了其中的拦截器来拦截非法的挂盘订单请求，在数据库层面，我们还把一些常用数据放入Redis&lt;/em&gt;&lt;em&gt;里，在Redis&lt;/em&gt;&lt;em&gt;里我们用到了list&lt;/em&gt;&lt;em&gt;和set&lt;/em&gt;&lt;em&gt;这两种数据类型，而且还用到了master-slave&lt;/em&gt;&lt;em&gt;模式。在使用Nginx&lt;/em&gt;&lt;em&gt;时，我们是通过配置来避免出现Session&lt;/em&gt;&lt;em&gt;粘滞的问题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    如果大家只写用到过Spring MVC和Nginx，那么筛选简历的人看一眼就过了，最多认为大家用过。但如果大家再写一些只有用过才能知道的细节点，比如Nginx的master-slave模式，那么就会给招聘方留下比较深刻的印象，大家给他们的感觉就会是“不仅用过，而且熟悉（或精通）”。&lt;/p&gt;

&lt;h4&gt;5  别让你的项目看上去像学习或培训项目&lt;/h4&gt;
&lt;p&gt;    我们在平时学习中，一般会自己搭建一个项目，这可以叫学习项目，比如一般的毕业设计也能叫学习项目。&lt;/p&gt;
&lt;p&gt;    在培训学校里，一般会通过案例来讲述，这个案例一般是根据实际商业项目改编的，但这也只能叫培训项目。&lt;/p&gt;
&lt;p&gt;    这里无意贬低学习项目经验，更无意贬低培训项目经验，但之前也说过，商业项目的价值最大，另外两种虽然也能帮助大家提升，但在面试中（或者在筛选简历时） ，一般的面试官会排除非商业项目，这是个普遍的事实。&lt;/p&gt;
&lt;p&gt;    比如我之前见过一份简历，有5年相关经验，这足以满足高级开发的年限要求，但经过排查，有2年是培训或学习经验，那么有效的商业项目年限只能是3年了，这顶多只能算初级的高级开发了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521215731515-1839048843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这里透露下甄别非商业项目经验的方法：&lt;/p&gt;
&lt;p&gt;    1 简历中，这部分项目的时间段正好和培训时间段重合。&lt;/p&gt;
&lt;p&gt;    2 明着写，这是毕业设计项目。&lt;/p&gt;
&lt;p&gt;    3 从名字上看比较简单，比如某某客户管理系统，或某图书管理系统，而且用的技术比较简单，比如存粹就spring mvc等，或者项目人月数明显和商业项目有差别。总之，这类项目比较简陋，简陋到一般的公司都不会（或没必要）用，那么这些就有可能是学习项目了。&lt;/p&gt;
&lt;p&gt;    4 培训学校里的学生一般是批量出来的，如果在某段时间内，看到不少简历中的项目描述很相似，而且时间点很重合，那么就有可能是培训项目了。&lt;/p&gt;
&lt;p&gt;    这里只讲如何甄别非商业项目经验，至于如何把非商业项目写成商业项目，这个明显属于造假，本文不提。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521221451624-991594401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;6  刚毕业的人（以及年限少的人）该如何挖掘项目经验&lt;/h4&gt;
&lt;p&gt;    请注意这里的用词是挖掘，也就是说是基于事实，在叙述时有所侧重，但绝非造假。来看两个例子。&lt;/p&gt;
&lt;p&gt;    比如小张在大三时帮计算机系的王老师所在的ABC软件公司干了半年的活，如果小张在简历上写：&lt;em&gt;“在校期间，从&lt;/em&gt;&lt;em&gt;x&lt;/em&gt;&lt;em&gt;年x&lt;/em&gt;&lt;em&gt;月到x&lt;/em&gt;&lt;em&gt;年x&lt;/em&gt;&lt;em&gt;月完成了xx&lt;/em&gt;&lt;em&gt;系统，用到了xx&lt;/em&gt;&lt;em&gt;技术”&lt;/em&gt;，那么这多半会被当成类似于课程设计的学习经验，但如果再加上如下关键性的描述：&lt;em&gt;“这个系统是属于&lt;/em&gt;&lt;em&gt;xx&lt;/em&gt;&lt;em&gt;公司的xx&lt;/em&gt;&lt;em&gt;商业项目里的一部分，我和另外三位开发人员做了半年，最终这个系统成功上线并在客户xx&lt;/em&gt;&lt;em&gt;公司的环境里投入运营”&lt;/em&gt;，那这样小张的商业项目总年限里就能加上这半年时间了。&lt;/p&gt;
&lt;p&gt;    又如小李在做毕业设计时，花了7个月的时间参与了导师的一个电商商业项目，他主要的工作是设计一个调度算法，但也参与了一些诸如订单管理模块的工作。如果他就平淡地写一句，&lt;em&gt;毕业设计是&lt;/em&gt;&lt;em&gt;xx&lt;/em&gt;&lt;em&gt;，毕业论文是xx&lt;/em&gt;，那么招聘方看过就算了，也不会认为小李在做毕业设计时还有过商业项目经验，这样小李未免有些吃亏。&lt;/p&gt;
&lt;p&gt;    但如果这样写：&lt;em&gt;“在&lt;/em&gt;&lt;em&gt;x年x月到x年x月的7个月里，在毕业设计中，我参与了xx公司的xx电商项目，客户方是x，我参与了订单管理和xx模块，并设计了其中的调度算法，在我的毕业论文里，详细介绍了这种做法”&lt;/em&gt;。文字没修改太多，但足以让小李增加7个月的商业项目经验。     &lt;/p&gt;
&lt;p&gt;    再列份我看到过一份印象比较深刻的简历，某候选人小丁在某三个月的时间内，一边参加培训，一边还在朋友的公司里兼职做着xx信息管理系统的项目（这不违背常理）。那么如果小丁能很好地在简历中很好地说明这个情况，而且还能在面试中很好地回答相应的问题，那么我们不得不相信小丁在这个三个月里确实做的是商业项目。   &lt;/p&gt;

&lt;h4&gt;7  商业项目未必是全职项目，如果你在某项目中有多个角色，那么挑和职位描述匹配的写&lt;/h4&gt;
&lt;p&gt;     不少人认为，商业项目一定是全职项目，而且一定得和我的职责相匹配，其实这是个思维误区，大多数情况下是这样，但也有例外。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521223349130-1607862305.png&quot; alt=&quot;&quot; width=&quot;149&quot; height=&quot;153&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     我见过不少毕业生，明明在读书阶段的大三大四出去干了不少兼职，但在简历中就不体现这点，这种属于不写白不写的。&lt;/p&gt;
&lt;p&gt;     我也见过不少候选人，在某个时间段里又做java后端开发，又客串测试，又做了前端的事，又做运维。大家别以为这不可能，在小公司里，一般真是一个人顶几个人用。&lt;/p&gt;
&lt;p&gt;    如果他在应聘java后端开发的简历中，大写特写运维的工作经验，那么通过筛选的可能性很低，但如果侧重于写java后端开发的经验，比如写用了后端开发的相关技术，那么至少有可能得到技术面试的机会。&lt;/p&gt;

&lt;h4&gt;8  归纳本文的侧重点&lt;/h4&gt;
&lt;p&gt;    本文的侧重点在于如何让你的简历帮你争取到更多的面试技术，从正反两方面围绕这个主题写了不少内幕和技巧。&lt;/p&gt;
&lt;p&gt;    本文虽然比较长，但自认为都是干货，不是一些看上去都对但用处很小的文字，所以自认为对大家也有一定的帮助。&lt;/p&gt;
&lt;p&gt;    正因如此，所以在最后本人尚敢推荐我的书：&lt;span&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521224349811-1639533607.png&quot; alt=&quot;&quot; width=&quot;106&quot; height=&quot;93&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    其实本文不少内容是根据这本书改编的。&lt;/p&gt;
&lt;p&gt;    请大家看在我将近半夜11点尚在辛苦码字的份上，多帮忙推荐这篇文章，如果能帮忙推荐我的书，那就更感激不尽了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180521224608098-1686805197.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;174&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;9  版权声明&lt;/h4&gt;
&lt;p&gt;    如果要在非商业用途下引用本文，请注明本文的原始url地址，同时请保留推荐书的部分内容。&lt;/p&gt;


</description>
<pubDate>Mon, 21 May 2018 14:49:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9063154.html</dc:identifier>
</item>
<item>
<title>存储基础知识 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9069823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9069823.html</guid>
<description>&lt;h2 id=&quot;几种常见存储设备的接口&quot;&gt;1.1 几种常见存储设备的接口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.IDE接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IDE的英文全称为&quot;Integrated Drive Electronics&quot;，即&quot;电子集成驱动器&quot;，是曾经主流的硬盘接口。IDE接口也称之为ATA接口。ATA的英文拼写为&quot;Advanced Technology Attachment&quot;。2003年推出SATA（Serial ATA）后，原有的ATA改名为PATA（并行高技术配置，Parallel ATA）。&lt;/p&gt;
&lt;p&gt;IDE是曾经普遍使用的外部接口，主要接硬盘和光驱。采用数据并行传送方式，一个IDE接口只能接两个外部设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521132548169-403889830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDE的工作方式需要CPU的全程参与，消耗的这部分资源会在一定程度上降低操作系统性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.SATA接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SATA（Serial ATA）是目前个人电脑上采用最多的接口。它采用串行连接方式。现在的SATAⅢ能达到的理论传输速度是6Gbps即750MB/s的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521102123491-1470976309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.SCSI接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SCSI(Small Computer System Interface)小型计算机系统接口。它是各种计算机与外部设备之间的接口标准。&lt;/p&gt;
&lt;p&gt;SCSI其内有控制芯片，可以代替cpu完成90%多的IO工作（如计算、控制、转换等），CPU不必浪费时间进行等待，可提高整体性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521102235841-1219654943.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521102243360-82431287.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SCSI采用链式连接，SCSI总线是SCSI设备之间传输数据的通路，又被称作SCSI通道。它通过SCSI控制器来和硬盘之类的SCSI设备进行通信。&lt;/p&gt;
&lt;p&gt;SCSI可以连接7—15个设备，由SCSI总线是宽总线(支持16个设备)还是窄总线(支持8个设备)决定。&lt;strong&gt;这些设备在SCSI体系结构中称为target，可能是一块硬盘、一个RAID阵列、一个cdrom等可能的设备。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个target都必须有自己唯一的ID，在8-bit总线上，这个号码是0~7，在16-bit总线上，这个号码是0~15。&lt;/p&gt;
&lt;p&gt;ID实际上就是这些设备地址。ID优先权由高到低的顺序为&lt;code&gt;7-6-5-4-3-2-1-0-15-14-13-12-11-10-9-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;SCSI链的最后一个SCSI设备要用作终结器(terminator)，终结器是由电阻组成的，位于SCSI总线的末端，用来减小相互影响的信号，维持SCSI链上的电压恒定。中间设备不需要终结器。一旦中间设备使用了终结器，那么就无法找到终结器后的SCSI设备了。而如果最后一个设备没用终结器，SCSI也会无法正常工作。&lt;/p&gt;
&lt;p&gt;在每个target上还可以继续进行扩展(注意每个target对应一个ID)，每个ID可以继续向下扩展最多32个逻辑设备，也称为逻辑单元(LU,logical unit)。每个逻辑单元对应一个设备，使用逻辑单元号LUN(Logical Unit Numbers)标识，LUN的范围是0-31。也就是说，SCSI可以扩展出很多很多存储设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521102306524-20844955.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521134230906-307271637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SCSI的数据传输是以块的方式进行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SCSI体系结构中，首先由initiator向target发起会话，此会话不像web服务那样休闲时就断开，而是像ssh服务那样，保持长久连接。在此会话中，initiator会发出scsi命令进行读写数据。&lt;/p&gt;
&lt;p&gt;可以将initiator认为是scsi的客户端，它是数据操作的需求方，target是scsi的服务端，它是数据的来源，也就是一堆堆的存储设备。当initiator与target关联后，target上的每一个lu在initiator上会单独显示为一块硬盘格式，即/dev/sd{b,c,d,e...}，显示的先后顺序根据lun号码来决定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521102321343-1203397648.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.SAS接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SAS是Serial Attached SCSI的缩写，即串行连接SCSI。也就是说SAS是新一代的SCSI技术，它和SATA一样都采用串行技术。&lt;/p&gt;
&lt;p&gt;SAS技术引入SAS扩展器，使SAS系统可以连接更多的设备，其中每个扩展器允许连接多个端口，每个端口可以连接SAS设备、主机或其他SAS扩展器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521103042520-482432460.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;存储方案存储技术&quot;&gt;1.2 存储方案(存储技术)&lt;/h2&gt;
&lt;p&gt;所谓的存储方案，就是用单独的软硬件将磁盘或磁盘组管理起来供主机使用。也就是说，存储方案和存储设备是在不同层面的，存储方案是设计如何组织和利用存储设备的。&lt;/p&gt;
&lt;p&gt;根据服务器类型分为&lt;strong&gt;封闭系统的存储和开放系统的存储&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;封闭系统主要指大型机，AS400等服务器。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;开放系统指基于包括Windows、UNIX、Linux等操作系统的服务器。而&lt;strong&gt;开放系统的存储又分为内置存储和外挂存&lt;/strong&gt;储：
&lt;ul&gt;&lt;li&gt;开放系统的外挂存储根据连接的方式又分为：直连式附加存储DAS(Direct Attached Storage)和网络化存储FAS(Fabric-Attached Storage)；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;开放系统的网络化存储根据传输协议又分为：网络附加存储NAS(Network Attached Storage)和存储区域网络SAN(Storage Area Network)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前绝大部分用户采用的是开放系统，其中外挂存储占有目前磁盘存储市场的70%以上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521103704651-2027052137.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前的外挂存储解决方案主要分为三种：DAS、NAS和SAN。下图虽简单，却描述了这直连式存储和网络存储的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521103732882-2113629722.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存储方案内部使用的硬盘多为SATA/SAS，追求高性能也用SSD，经过串联或者RAID之后，对主机提供访问接口。&lt;/p&gt;

&lt;h3 id=&quot;das存储&quot;&gt;1.2.1 DAS存储&lt;/h3&gt;
&lt;p&gt;直接式存储(DAS:Direct Attached Storage)，是指将存储设备通过SCSI接口或FC接口直接连接到一台计算机上。DAS不算是网络存储，&lt;strong&gt;在存储设备和主机之间没有任何网络设备的参与，只有挂载它的主机才可访问它。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最典型的DAS存储类型就是个人电脑中的硬盘，它和电脑直连，没有经过任何网络设备，也只有这台电脑可以访问它上面的数据。&lt;/p&gt;
&lt;p&gt;也就是说，服务器发生故障时，连接在服务器上的DAS存储设备中的数据暂时不能被存取。&lt;/p&gt;
&lt;p&gt;DAS是最原始最基本的存储方式，缺点在于容量有限、难于共享，从而造成信息孤岛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521103914644-1221910055.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DAS缺陷有二：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).DAS存储只能通过与之相连的主机进行访问，不能实现数据与其他主机的共享。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2).直连式存储与服务器主机之间的连接通道通常采用SCSI或者SAS连接，随着服务器CPU的处理能力越来越强，存储硬盘空间越来越大，阵列的硬盘数量越来越多，SCSI或SAS通道将会成为IO瓶颈；且SCSI ID或SAS ID资源有限，能够建立的SCSI或SAS通道连接有限。也就是容量有限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;nas存储&quot;&gt;1.2.2 NAS存储&lt;/h3&gt;
&lt;p&gt;是指将存储设备通过标准的网络连接到一台或一群计算机上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAS有文件系统和IP地址，可以类似的理解为网上邻居的共享磁盘，或者NFS的服务端，即导出目录的一端。NAS是文件级的存储方法，它有自己的文件系统，如NFS，SMB的CIFS。所以它是真正即插即用的产品。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521104601773-1742274145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NAS和SAN本质上的不同点在于NAS有自己的文件系统，而SAN的文件系统在应用程序服务器上而非存储服务器上。这样的不同点导致NAS是文件级别的数据传输，而SAN是基于块级别的传输。&lt;/p&gt;
&lt;p&gt;对于大量小文件来说，由于每个文件都要查找文件索引号，所在块号等等，这些都会消耗资源和时间，所以导致文件级别的传输要慢的多得多，而块级别的传输则不管某个块属于哪个文件，只要需要就会把块传输出去。&lt;/p&gt;
&lt;p&gt;NAS性能比SAN要差很多，但相对成本也低很多。&lt;/p&gt;

&lt;h3 id=&quot;san存储&quot;&gt;1.2.3 SAN存储&lt;/h3&gt;
&lt;p&gt;SAN即存储区域网络(Storage Area Network，SAN)。目前有两种类型的SAN，一种是FC SAN(光纤通道的SAN)，一种是IP SAN(以太网的SAN，即现在的iSCSI)。&lt;/p&gt;
&lt;p&gt;一般都采用光纤通道(Fibre Channel)技术，通过光纤通道交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络。FC SAN已经相当成熟，成为业界的实施标准。如果是IP SAN，则下图中的FC部分换为以太网，对交换机而言也没有光纤交换机那么严格的要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105135865-1180326757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SAN是基于块级别的数据传输。在应用程序服务器本地有本地文件系统，这是和NAS根本上的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SAN解决方案从基本功能剥离出存储这部分功能，在理论上比其他存储方案要先进一些。&lt;/p&gt;
&lt;p&gt;相比于FC SAN，IP SAN的弱点除了在硬件设备上，还在于它要对数据进行TCP/IP的封装，这需要消耗资源(硬件iSCSI使用HBA卡控制芯片来封装不会消耗操作系统资源，但挺贵的)。同时它还要使用以太网，所以网络的情况对其也有很大影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105451327-242868998.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105456724-1723475125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SAN是目前业界中高端存储的主流标准。&lt;/p&gt;

&lt;h3 id=&quot;san和nas的区别&quot;&gt;1.2.4 SAN和NAS的区别&lt;/h3&gt;
&lt;p&gt;为什么提到NAS就不得不提到SAN呢?原因之一是它们的名称有69关系，容易混淆；之二是NAS和SAN既竞争又合作，很多高端NAS的后端存储就是SAN。NAS和SAN的整合也是存储设备的发展趋势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105558310-2014158284.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的构中可以看到，SAN文件系统分别在每一个应用服务器上；而NAS则是每个应用服务器通过网络共享协议(如：NFS、CIFS)使用同一个文件系统。换句话说，NAS和SAN存储系统的区别是NAS自己管理自己的文件系统。&lt;/p&gt;
&lt;p&gt;现在高端存储已经很多都使用SAN+NAS了。如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105657419-269227512.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图的双虚线框表示一台NAS。它通过Fibre Channel从后端SAN获得存储空间，创建文件系统后，再通过以太网共享给服务器。SAN提供的存储单位是LUN，属于block级别的。经过NAS创建成文件系统后，就变成文件级别的了。&lt;/p&gt;
&lt;p&gt;如果上图描述的不够清楚，下图就容易理解多了。NAS通过FC Switch连到SAN上，应用服务器再通过Ethernet Switch连到NAS上。同时SAN也直接提供block级别的存储给应用服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180521105749463-1630950616.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于NAS和SAN的区别，可以列出很多来。比如带宽大小，距离长短，共享优劣等等。几乎所有区别都是由两个因素衍生出来的。一个是FC与Ethernet，另一个是block与file system。简而言之，如果用户需要通过FC访问block，就用SAN；如果需要通过Ethernet访问file system，就用NAS。&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 14:46:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9069823.html</dc:identifier>
</item>
<item>
<title>SpringCloud实战7-Config分布式配置管理 - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9069749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9069749.html</guid>
<description>&lt;p&gt;分布式环境下的统一配置框架，已经有不少了，比如百度的disconf,阿里的diamand&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;官方文档对spring Cloud Config的描述如下：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持，使用Config Server,您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-为什么要配置中心？&quot;&gt;1.为什么要配置中心？&lt;/h3&gt;
&lt;p&gt;一个应用中不只是代码,还需要连接资源和其它应用,经常有很多需要外部设置的项去调整应用行为,如切换不同的数据库，设置功能开关等。&lt;/p&gt;
&lt;p&gt;随着系统微服务的不断增加，首要考虑的是系统的可伸缩、可扩展性好，随之就是一个配置管理的问题。各自管各自的开发时没什么问题，到了线上之后管理就会很头疼，到了要大规模更新就更烦了。&lt;/p&gt;
&lt;p&gt;而且你不可能停止你的服务集群去更新的你配置，这是不现实的做法，因此springcloud配置中心就是一个比较好的解决方案，下图就是一个springcloud配置中心的解决方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521203126866-1299643942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的配置中心的实现方法有:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　&lt;span&gt;　1.硬编码(缺点:需要修改代码,风险大)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　2.放在xml等配置文件中,和应用一起打包(缺点:需要重新打包和重启)&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　3.文件系统中(缺点:依赖操作系统等)&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;　　&lt;/code&gt;&lt;code&gt;4.环境变量(缺点:有大量的配置需要人工设置到环境变量中,不便于管理,且依赖平台) 5.云端存储(缺点:与其他应用耦合)&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring Cloud Config就是云端存储配置信息的,它具有中心化,版本控制,支持动态更新,平台独立,语言独立等特性。其特点是：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　1.提供服务端和客户端支持(spring cloud config server和spring cloud config client)
　　2.集中式管理分布式环境下的应用配置
　　3.基于Spring环境，无缝与Spring应用集成
　　4.可用于任何语言开发的程序
　　5.默认实现基于git仓库，可以进行版本管理
　　6.可替换自定义实现&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;spring cloud config包括两部分：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.spring cloud config server 作为配置中心的服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.拉取配置时更新git仓库副本，保证是最新结果&lt;/p&gt;
&lt;p&gt;　　　　2.支持数据结构丰富，yml, json, properties 等&lt;/p&gt;
&lt;p&gt;　　　　3.配合 eureke 可实现服务发现，配合 cloud bus 可实现配置推送更新&lt;/p&gt;
&lt;p&gt;　　　　4.配置存储基于 git 仓库，可进行版本管理&lt;/p&gt;
&lt;p&gt;　　　　5.简单可靠，有丰富的配套方案&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2.Spring Cloud Config Client 客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.Spring Boot项目不需要改动任何代码，加入一个启动配置文件指明使用ConfigServer上哪个配置文件即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SpringCloud Config与百度的disconf之类的有很大不同，主要区别在于下面三点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.配置的存储方式不同：disconf是把配置信息保存在mysql、zookeeper中，而spring cloud config是将配置保存在git/svn上 （即：配置当成源代码一样管理）&lt;/p&gt;
&lt;p&gt;　　2.配置的管理方式不同：spring cloud config没有类似disconf的统一管理界面，既然把配置都当成git之类的源码来看待了，git的管理界面，就是配置的管理界面&lt;/p&gt;
&lt;p&gt;　　3.配置变化的通知机制不同：disconf中配置变化后，依赖zk的事件watcher来通知应用，而spring cloud config则是依赖git每次push后，触发webhook回调，最终触发spring cloud bus(消息总线），然后由消息总线通知相关的应用。&lt;/p&gt;
&lt;p&gt;从配置变化的通知机制上看，如果有100个应用节点，都依赖于统一配置，如果修改了配置，只想让某几个节点&quot;灰度&quot;更新配置，spring cloud config server更容易做到，这一点相对disconf更灵活&lt;/p&gt;

&lt;p&gt;首先SpringCloud Config 是分为Server端和Client端的，Server端负责管理配置，Client端用来加载配置。我们每一个为服务都要集成一个Client端的。上面也提到过。因此，我们现在看一下Config的Server端的Demo实现。&lt;/p&gt;
&lt;p&gt;首先在原来的项目中新建一个springcloud-config-server模块，并且引入相关依赖，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到引入了Eureka，为什么呢？很明显是为了高可用。&lt;/p&gt;
&lt;p&gt;接着在启动类上面加入@EnableConfigServer注解，表示这里是配置中心服务。还有Eureka的客户端的注解代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableConfigServer
@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.yml配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;7000&lt;/span&gt;&lt;span&gt;
#服务名字
spring:
  application:
    name: config&lt;/span&gt;-&lt;span&gt;server
  cloud:
    config:
      server:
        git:
#git 仓库的地址
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/xxxx/springcloud-config.git&lt;/span&gt;
&lt;span&gt;#git 仓库的账号密码
          username: xxx
          password: xxx
#加入注册中心，实现高可用
eureka:
  client:
    service&lt;/span&gt;-&lt;span&gt;url:
       defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8889/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意了，前提是你必须要在git仓库中先建立一个仓库，然后配置两个配置，一个开发dev,一个测试test  如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521212815143-1468183698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dev的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521212838118-1644099583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;test的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521212909174-2043314773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了,让我们把springcloud-config模块启动起来，启动启动类，运行，访问git仓库中的cloud-config-dev.properties,如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521214233241-810253095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们进行springcloud Config的Client端的Demo,如下：&lt;/p&gt;
&lt;p&gt;首先引入Client端的相关依赖，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里提一下，为什么需要引入前面的actuctor依赖，因为，我们Client端需要在不重启的情况下，及时更新拉取加载配置中心的改变，然后修改内存中的配置的值。 &lt;/p&gt;
&lt;p&gt;接着在Client启动类的打上@EnableDiscoveryClient的注解，来注册到注册中心去，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigClientApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigClientApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来这步骤很关键，就是要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。就好比如，你应用程序都跑起来了，你配置还没加载，这不是扯淡吗？&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521215731597-1796153846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;7005&lt;/span&gt;&lt;span&gt;
spring:
  application:
    name: cloud&lt;/span&gt;-&lt;span&gt;config
  cloud:
    config:
#启动什么环境下的配置，dev 表示开发环境，这跟你仓库的文件的后缀有关，比如，仓库配置文件命名格式是cloud&lt;/span&gt;-config-&lt;span&gt;dev.properties,所以profile 就要写dev
      profile: dev&lt;br/&gt;#面向服务，允许被发现
      discovery:
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#这个名字是Config Server端的服务名字，不能瞎写。
        service&lt;/span&gt;-id: config-&lt;span&gt;server
#注册中心
eureka:
  client:
    service&lt;/span&gt;-&lt;span&gt;url:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8889/eureka/&lt;/span&gt;
&lt;span&gt;#是否需要权限拉去，默认是true,如果不false就不允许你去拉取配置中心Server更新的内容
management:
  security:
    enabled: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 接着写一段测试代码，如下，建立一个测试Controller，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里面的属性有可能会更新的，git中的配置中心变化的话就要刷新，没有这个注解内，配置就不能及时更新&lt;/span&gt;
&lt;span&gt;@RefreshScope
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController {

    @Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    @Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${age}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着启动启动该工程，运行结果如下：&lt;/p&gt;
&lt;p&gt;首先我们我们先看没更新配置之前的值，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521221853100-605710927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们去git仓库中修改age的值为24，再用postman来发送post请求localhost:7005/refresh,如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521222121063-1074761431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521222147996-1550859478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到postman返回config.client.version信息，表示告知Client，远程的仓库中的配置中心已经更新了的配置版本信息，改变的值为age。&lt;/p&gt;
&lt;p&gt;接着我们继续刷新浏览器，localhost:7005/test,看一下年龄是否更新了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180521222413164-803338218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到年龄跟新到24了。&lt;/p&gt;

&lt;p&gt;但是这样就好了吗？虽然服务没有重启，但是我们要一个服务一个服务的发送post请求，我们能受的了吗？这比之前的没配置中心好多了，那么我们如何继续避免挨个挨个的向服务发送Post请求来告知服务，你的配置信息改变了，需要及时修改内存中的配置信息。&lt;/p&gt;
&lt;p&gt;这时候我们就不要忘记消息队列的发布订阅模型。让所有为服务来订阅这个事件，当这个事件发生改变了，就可以通知所有微服务去更新它们的内存中的配置信息。这时Bus消息总线就能解决，这留到下一篇随笔讲解。&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 14:32:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9069749.html</dc:identifier>
</item>
<item>
<title>DX11 Without DirectX SDK--01 DirectX11初始化 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9069608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9069608.html</guid>
<description>&lt;p&gt;回到 DirectX11--使用Windows SDK来进行开发：&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/X-Jun/p/9028764.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于个人觉得龙书里面第4章提供的Direct3D 初始化项目封装得比较好，而且DirectX SDK Samples里面的初始化程序过于精简，不适合后续使用，故选择了以Init Direct3D项目作为框架，然后还使用了微软提供的示例项目，两者结合到一起。建议下载项目配合阅读。&lt;/p&gt;
&lt;p&gt;项目源码点此：&lt;a href=&quot;https://github.com/MKXJun/DX11-Without-DirectX-SDK&quot; class=&quot;uri&quot;&gt;https://github.com/MKXJun/DX11-Without-DirectX-SDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该项目包含了下面这些文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/res/2123/WEBRESOURCE163c9a1fb714f6da98d18ea6e1f7c2b6&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中头文件的具体功能&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;d3dApp.h&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Direct3D应用程序框架类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;dxerr.h&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;DirectX错误库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;GameApp.h&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;游戏应用程序扩展类，游戏逻辑在这里实现，继承自D3DApp类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;GameTimer.h&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;游戏计时器类&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;code&gt;d3dApp.h&lt;/code&gt;, &lt;code&gt;d3dApp.cpp&lt;/code&gt;, &lt;code&gt;GameTimer.h&lt;/code&gt;, &lt;code&gt;GameTimer.cpp&lt;/code&gt;是龙书源码提供的，我们可以搬运过来，但是对&lt;code&gt;d3dApp&lt;/code&gt;框架类我们还需要进行大幅度修改，毕竟我们的最终目的就是要完全脱离旧的DirectX SDK，使用Windows SDK来实现DX11.&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;dxerr.h&lt;/code&gt;在Windows SDK是没有提供的，我们需要寻找新的&lt;code&gt;dxerr&lt;/code&gt;进行替代，在后续会提到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GameApp.h&lt;/code&gt;则是我们编写游戏逻辑的地方，这里需要进行逐帧的更新及绘制。&lt;/p&gt;

&lt;h2 id=&quot;链接静态库&quot;&gt;链接静态库&lt;/h2&gt;
&lt;p&gt;这里的每一个项目都需要包含静态库：&lt;code&gt;d3d11.lib&lt;/code&gt;,&lt;code&gt;dxgi.lib&lt;/code&gt;,&lt;code&gt;dxguid.lib&lt;/code&gt;,&lt;code&gt;D3DCompiler.lib&lt;/code&gt;和&lt;code&gt;winmm.lib&lt;/code&gt;。可以在&lt;code&gt;d3dApp.h&lt;/code&gt;添加下面的语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#pragma comment(lib, &quot;d3d11.lib&quot;)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma comment(lib, &quot;dxgi.lib&quot;)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma comment(lib, &quot;dxguid.lib&quot;)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma comment(lib, &quot;D3DCompiler.lib&quot;)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma comment(lib, &quot;winmm.lib&quot;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以在项目属性-链接器-输入-附加依赖项 添加上面的库。&lt;/p&gt;
&lt;h2 id=&quot;移植新的dxerr.h和dxerr.cpp&quot;&gt;移植新的dxerr.h和dxerr.cpp&lt;/h2&gt;
&lt;p&gt;directx-sdk-samples-master的GitHub地址：&lt;a href=&quot;https://github.com/walbourn/directx-sdk-samples&quot; class=&quot;uri&quot;&gt;https://github.com/walbourn/directx-sdk-samples&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在directx-sdk-samples-master\DXUT\Core中可以找到&lt;code&gt;dxerr.h&lt;/code&gt;和&lt;code&gt;dxerr.cpp&lt;/code&gt;，把它们拉进我们的项目中。然后使用下面的宏来进行检查（加在&lt;code&gt;d3dApp.h&lt;/code&gt;）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#if defined(DEBUG) | defined(_DEBUG)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#ifndef HR&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define HR(x)                                              &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;{                                                          &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    HRESULT hr = (x);                                      &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(FAILED(hr))                                         &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {                                                      &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        DXTrace(__FILEW__, (DWORD)__LINE__, hr, L#x, true);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }                                                      &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#else&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#ifndef HR&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define HR(x) (x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#endif &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于新的&lt;code&gt;dxerr.h&lt;/code&gt;仅提供了&lt;code&gt;DXTrace&lt;/code&gt;的Unicode字符集版本，需要将原来的&lt;code&gt;__FILE__&lt;/code&gt;替换为&lt;code&gt;__FILEW__&lt;/code&gt;，并在项目属性页中将字符集设置为Unicode。&lt;/p&gt;

&lt;p&gt;考虑到DirectX11的API是由一系列的COM组件来管理的，我们可以使用智能指针来管理这些对象，而无需过多担心内存的泄漏。所以该项目并不会用到接口类&lt;code&gt;ID3D11Debug&lt;/code&gt;来协助检查内存泄漏。&lt;/p&gt;
&lt;p&gt;使用该智能指针需要包含头文件&lt;code&gt;wrl/client.h&lt;/code&gt;，并且智能指针类模板&lt;code&gt;ComPtr&lt;/code&gt;位于名称空间&lt;code&gt;Microsoft::WRL&lt;/code&gt;内。我们主要关注下面这几个方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ComPtr&amp;lt;T&amp;gt;::Get&lt;/code&gt;方法返回&lt;code&gt;T*&lt;/code&gt;，若需要赋值操作也可以使用重载的=运算符进行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ComPtr&amp;lt;T&amp;gt;::GetAddressOf&lt;/code&gt;方法返回&lt;code&gt;T**&lt;/code&gt;，也可以用重载的&amp;amp;运算符来获取&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ComPtr&amp;lt;T&amp;gt;::Reset&lt;/code&gt;方法将对里面的对象调用Release方法，并将指针置为&lt;code&gt;nullptr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GameTimer&lt;/code&gt;类是一个基于高精度时钟频率的计时器，主要用于获取游戏时间和每一帧的间隔时间，并进行一些特殊的操作。下面给出了&lt;code&gt;GameTimer&lt;/code&gt;类的声明部分：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GameTimer
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    GameTimer();

    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; TotalTime()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;     &lt;span class=&quot;co&quot;&gt;// 总游戏时间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; DeltaTime()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;     &lt;span class=&quot;co&quot;&gt;// 帧间隔时间&lt;/span&gt;

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Reset(); &lt;span class=&quot;co&quot;&gt;// 在消息循环之前调用&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Start(); &lt;span class=&quot;co&quot;&gt;// 在取消暂停的时候调用&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Stop();  &lt;span class=&quot;co&quot;&gt;// 在暂停的时候调用&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Tick();  &lt;span class=&quot;co&quot;&gt;// 在每一帧的时候调用&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;:
    &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; mSecondsPerCount;    &lt;span class=&quot;co&quot;&gt;// 一个时钟周期经过的秒数&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; mDeltaTime;          &lt;span class=&quot;co&quot;&gt;// 帧间隔时间&lt;/span&gt;

    __int64 mBaseTime;          &lt;span class=&quot;co&quot;&gt;// 基准时间&lt;/span&gt;
    __int64 mPausedTime;        &lt;span class=&quot;co&quot;&gt;// 暂停的时间&lt;/span&gt;
    __int64 mStopTime;          &lt;span class=&quot;co&quot;&gt;// 停止的时间&lt;/span&gt;
    __int64 mPrevTime;          &lt;span class=&quot;co&quot;&gt;// 上一帧的时间&lt;/span&gt;
    __int64 mCurrTime;          &lt;span class=&quot;co&quot;&gt;// 当前时间&lt;/span&gt;

    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; mStopped;              &lt;span class=&quot;co&quot;&gt;// 是否停止计时&lt;/span&gt;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Windows.h&lt;/code&gt;中，提供了&lt;code&gt;QueryPerformanceFrequency&lt;/code&gt;函数用于获取当前处理器的时钟频率(1秒经过的时钟周期数)，然后我们就可以求出1个时钟周期经过的时间数目了。此时计时器为开启状态。观看构造函数的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;GameTimer::GameTimer()
: mSecondsPerCount(&lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;), mDeltaTime(&lt;span class=&quot;fl&quot;&gt;-1.0&lt;/span&gt;), mBaseTime(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;), 
  mPausedTime(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;), mPrevTime(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;), mCurrTime(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;), mStopped(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)
{
    __int64 countsPerSec;
    QueryPerformanceFrequency((LARGE_INTEGER*)&amp;amp;countsPerSec);
    mSecondsPerCount = &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt; / (&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;)countsPerSec;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;gametimerreset方法&quot;&gt;GameTimer::Reset方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::Reset&lt;/code&gt;方法用于重置当前游戏用时为0，并开启计时器，具体的做法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GameTimer::Reset()
{
    __int64 currTime;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;amp;currTime);

    mBaseTime = currTime;
    mPrevTime = currTime;
    mStopTime = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    mStopped  = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;QueryPerformanceCounter&lt;/code&gt;函数用于获取当前经过的时钟周期数。当前我们是用它获取的值作为基准时间，然后将暂停的总计时间设置为0，并将暂停状态设置为否。&lt;/p&gt;
&lt;h2 id=&quot;gametimerstart方法&quot;&gt;GameTimer::Start方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::Start&lt;/code&gt;方法用于开启计时器计时（设置开始时间），并统计上次暂停的总时间：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GameTimer::Start()
{
    __int64 startTime;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;amp;startTime);


    &lt;span class=&quot;co&quot;&gt;// Accumulate the time elapsed between stop and start pairs.&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//                     |&amp;lt;-------d-------&amp;gt;|&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// ----*---------------*-----------------*------------&amp;gt; time&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//  mBaseTime       mStopTime        startTime     &lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( mStopped )
    {
        mPausedTime += (startTime - mStopTime); 

        mPrevTime = startTime;
        mStopTime = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        mStopped  = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若之前曾经暂停过，则需要统计当前暂停经过的时间，并加进总的暂停用时。然后这时停止时间也要归零，并将暂停状态设置为否。&lt;/p&gt;
&lt;h2 id=&quot;gametimerstop方法&quot;&gt;GameTimer::Stop方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::Stop&lt;/code&gt;方法用于暂停计时器计时，设置暂停时间点：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GameTimer::Stop()
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( !mStopped )
    {
        __int64 currTime;
        QueryPerformanceCounter((LARGE_INTEGER*)&amp;amp;currTime);

        mStopTime = currTime;
        mStopped  = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;gametimertick方法&quot;&gt;GameTimer::Tick方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::Tick&lt;/code&gt;方法在计时器开启的时候返回距离上次&lt;code&gt;Tick&lt;/code&gt;的间隔时间，若计时器没有开启或者间隔时间为负值，则设间隔时间为0：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GameTimer::Tick()
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( mStopped )
    {
        mDeltaTime = &lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }

    __int64 currTime;
    QueryPerformanceCounter((LARGE_INTEGER*)&amp;amp;currTime);
    mCurrTime = currTime;

    &lt;span class=&quot;co&quot;&gt;// Time difference between this frame and the previous.&lt;/span&gt;
    mDeltaTime = (mCurrTime - mPrevTime)*mSecondsPerCount;

    &lt;span class=&quot;co&quot;&gt;// Prepare for next frame.&lt;/span&gt;
    mPrevTime = mCurrTime;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(mDeltaTime &amp;lt; &lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;)
    {
        mDeltaTime = &lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;gametimertotaltime方法&quot;&gt;GameTimer::TotalTime方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::TotalTime&lt;/code&gt;方法返回的是距离上次&lt;code&gt;Reset&lt;/code&gt;方法调用到现在，游戏运行的总时间(不包括所有暂停过的时间，单位为秒)：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; GameTimer::TotalTime()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;
{
    &lt;span class=&quot;co&quot;&gt;// If we are stopped, do not count the time that has passed since we stopped.&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Moreover, if we previously already had a pause, the distance &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// mStopTime - mBaseTime includes paused time, which we do not want to count.&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// To correct this, we can subtract the paused time from mStopTime:  &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//                     |&amp;lt;--paused time--&amp;gt;|&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// ----*---------------*-----------------*------------*------------*------&amp;gt; time&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//  mBaseTime       mStopTime        startTime     mStopTime    mCurrTime&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( mStopped )
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)(((mStopTime - mPausedTime)-mBaseTime)*mSecondsPerCount);
    }

    &lt;span class=&quot;co&quot;&gt;// The distance mCurrTime - mBaseTime includes paused time,&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// which we do not want to count.  To correct this, we can subtract &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// the paused time from mCurrTime:  &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//  (mCurrTime - mPausedTime) - mBaseTime &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//                     |&amp;lt;--paused time--&amp;gt;|&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// ----*---------------*-----------------*------------*------&amp;gt; time&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//  mBaseTime       mStopTime        startTime     mCurrTime&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)(((mCurrTime-mPausedTime)-mBaseTime)*mSecondsPerCount);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;gametimerdeltatime方法&quot;&gt;GameTimer::DeltaTime方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameTimer::TotalTime&lt;/code&gt;方法返回当前&lt;code&gt;Tick&lt;/code&gt;和上次&lt;code&gt;Tick&lt;/code&gt;之间的时间间隔，单位为秒：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; GameTimer::DeltaTime()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)mDeltaTime;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;D3DApp.h&lt;/code&gt;展示了框架类的声明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; D3DApp
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    D3DApp(HINSTANCE hInstance);    &lt;span class=&quot;co&quot;&gt;// 在构造函数的初始化列表应当设置好初始参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; ~D3DApp();
    
    HINSTANCE AppInst()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;       &lt;span class=&quot;co&quot;&gt;// 获取应用实例的句柄&lt;/span&gt;
    HWND      MainWnd()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;       &lt;span class=&quot;co&quot;&gt;// 获取主窗口句柄&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;     AspectRatio()&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;;   &lt;span class=&quot;co&quot;&gt;// 获取屏幕宽高比&lt;/span&gt;
    
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; Run();                      &lt;span class=&quot;co&quot;&gt;// 运行程序，进行游戏主循环&lt;/span&gt;
 
    &lt;span class=&quot;co&quot;&gt;// 框架方法。客户派生类需要重载这些方法以实现特定的应用需求&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; Init();            &lt;span class=&quot;co&quot;&gt;// 该父类方法需要初始化窗口和Direct3D部分&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnResize();        &lt;span class=&quot;co&quot;&gt;// 该父类方法需要在窗口大小变动的时候调用&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; UpdateScene(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; dt)=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;   &lt;span class=&quot;co&quot;&gt;// 子类需要实现该方法，完成每一帧的更新&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; DrawScene()=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;             &lt;span class=&quot;co&quot;&gt;// 子类需要实现该方法，完成每一帧的绘制&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;virtual&lt;/span&gt; LRESULT MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    &lt;span class=&quot;co&quot;&gt;// 窗口的消息回调函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt;:
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; InitMainWindow();      &lt;span class=&quot;co&quot;&gt;// 窗口初始化&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; InitDirect3D();        &lt;span class=&quot;co&quot;&gt;// Direct3D初始化&lt;/span&gt;

    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CalculateFrameStats(); &lt;span class=&quot;co&quot;&gt;// 计算每秒帧数并在窗口显示&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt;:

    HINSTANCE mhAppInst;        &lt;span class=&quot;co&quot;&gt;// 应用实例句柄&lt;/span&gt;
    HWND      mhMainWnd;        &lt;span class=&quot;co&quot;&gt;// 主窗口句柄&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;      mAppPaused;       &lt;span class=&quot;co&quot;&gt;// 应用是否暂停&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;      mMinimized;       &lt;span class=&quot;co&quot;&gt;// 应用是否最小化&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;      mMaximized;       &lt;span class=&quot;co&quot;&gt;// 应用是否最大化&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;      mResizing;        &lt;span class=&quot;co&quot;&gt;// 窗口大小是否变化&lt;/span&gt;
    UINT      m4xMsaaQuality;   &lt;span class=&quot;co&quot;&gt;// MSAA支持的质量等级&lt;/span&gt;

    GameTimer mTimer;           &lt;span class=&quot;co&quot;&gt;// 计时器&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// DX11&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11Device&amp;gt; md3dDevice;                    &lt;span class=&quot;co&quot;&gt;// D3D11设备&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; md3dImmediateContext;   &lt;span class=&quot;co&quot;&gt;// D3D11设备上下文&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;IDXGISwapChain&amp;gt; mSwapChain;                  &lt;span class=&quot;co&quot;&gt;// D3D11交换链&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// DX11.1&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11Device1&amp;gt; md3dDevice1;                  &lt;span class=&quot;co&quot;&gt;// D3D11.1设备&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11DeviceContext1&amp;gt; md3dImmediateContext1; &lt;span class=&quot;co&quot;&gt;// D3D11.1设备上下文&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;IDXGISwapChain1&amp;gt; mSwapChain1;                &lt;span class=&quot;co&quot;&gt;// D3D11.1交换链&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 常用资源&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11Texture2D&amp;gt; mDepthStencilBuffer;        &lt;span class=&quot;co&quot;&gt;// 深度模板缓冲区&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11RenderTargetView&amp;gt; mRenderTargetView;   &lt;span class=&quot;co&quot;&gt;// 渲染目标视图&lt;/span&gt;
    Microsoft::WRL::ComPtr&amp;lt;ID3D11DepthStencilView&amp;gt; mDepthStencilView;   &lt;span class=&quot;co&quot;&gt;// 深度模板视图&lt;/span&gt;
    D3D11_VIEWPORT mScreenViewport;                                     &lt;span class=&quot;co&quot;&gt;// 视口&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 派生类应该在构造函数设置好这些自定义的初始参数&lt;/span&gt;
    std::wstring mMainWndCaption;                                       &lt;span class=&quot;co&quot;&gt;// 主窗口标题&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mClientWidth;                                                   &lt;span class=&quot;co&quot;&gt;// 视口宽度&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mClientHeight;                                                  &lt;span class=&quot;co&quot;&gt;// 视口高度&lt;/span&gt;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在&lt;code&gt;d3dApp.cpp&lt;/code&gt;中，可以看到有一个全局变量&lt;code&gt;gd3dApp&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt;
{
    &lt;span class=&quot;co&quot;&gt;// This is just used to forward Windows messages from a global window&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// procedure to our member function window procedure because we cannot&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// assign a member function to WNDCLASS::lpfnWndProc.&lt;/span&gt;
    D3DApp* gd3dApp = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置该全局变量是因为在窗口创建的时候需要绑定一个回调函数，但是我们不可以绑定&lt;code&gt;d3dApp::MainWndProc&lt;/code&gt;的成员方法，所以还需要实现一个全局函数用于回调函数的绑定：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    &lt;span class=&quot;co&quot;&gt;// Forward hwnd on because we can get messages (e.g., WM_CREATE)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// before CreateWindow returns, and thus before mhMainWnd is valid.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; gd3dApp-&amp;gt;MsgProc(hwnd, msg, wParam, lParam);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;构造函数-1&quot;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;在构造函数中，这些参数通常只会设置一次，所以需要在初始化列表中进行修改：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;D3DApp::D3DApp(HINSTANCE hInstance)
    : mhAppInst(hInstance),
    mMainWndCaption(&lt;span class=&quot;st&quot;&gt;L&quot;DirectX11 Initialization&quot;&lt;/span&gt;),
    mClientWidth(&lt;span class=&quot;dv&quot;&gt;800&lt;/span&gt;),
    mClientHeight(&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;),
    mhMainWnd(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    mAppPaused(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;),
    mMinimized(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;),
    mMaximized(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;),
    mResizing(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;),
    m4xMsaaQuality(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;),

    md3dDevice(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    md3dImmediateContext(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    mSwapChain(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    mDepthStencilBuffer(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    mRenderTargetView(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;),
    mDepthStencilView(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;)
{
    ZeroMemory(&amp;amp;mScreenViewport, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(D3D11_VIEWPORT));


    &lt;span class=&quot;co&quot;&gt;// 让一个全局指针获取这个类，这样我们就可以在Windows消息处理的回调函数&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 让这个类调用内部的回调函数了&lt;/span&gt;
    gd3dApp = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;d3dappinit方法--初始化&quot;&gt;D3DApp::Init方法--初始化&lt;/h2&gt;
&lt;p&gt;初始化主要完成窗口的创建和Direct3D 11的初始化：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; D3DApp::Init()
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!InitMainWindow())
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!InitDirect3D())
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;d3dappinitmainwindow方法--完成窗口的创建&quot;&gt;D3DApp::InitMainWindow方法--完成窗口的创建&lt;/h2&gt;
&lt;p&gt;该方法的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; D3DApp::InitMainWindow()
{
    WNDCLASS wc;
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    wc.cbWndExtra = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    wc.hInstance = mhAppInst;
    wc.hIcon = LoadIcon(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, IDI_APPLICATION);
    wc.hCursor = LoadCursor(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wc.lpszMenuName = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    wc.lpszClassName = &lt;span class=&quot;st&quot;&gt;L&quot;D3DWndClassName&quot;&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!RegisterClass(&amp;amp;wc))
    {
        MessageBox(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;L&quot;RegisterClass Failed.&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;co&quot;&gt;// Compute window rectangle dimensions based on requested client area dimensions.&lt;/span&gt;
    RECT R = { &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, mClientWidth, mClientHeight };
    AdjustWindowRect(&amp;amp;R, WS_OVERLAPPEDWINDOW, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; width = R.right - R.left;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; height = R.bottom - R.top;

    mhMainWnd = CreateWindow(&lt;span class=&quot;st&quot;&gt;L&quot;D3DWndClassName&quot;&lt;/span&gt;, mMainWndCaption.c_str(),
        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, width, height, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, mhAppInst, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!mhMainWnd)
    {
        MessageBox(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;L&quot;CreateWindow Failed.&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    ShowWindow(mhMainWnd, SW_SHOW);
    UpdateWindow(mhMainWnd);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;窗口的创建这里不做过多描述，因为这不是教程的重点部分。有兴趣的可以去MSDN查阅这些函数和结构体的信息。&lt;/p&gt;
&lt;h2 id=&quot;d3dappmsgproc方法--回调函数&quot;&gt;D3DApp::MsgProc方法--回调函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;D3DApp::MsgProc&lt;/code&gt;回调方法的定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;LRESULT D3DApp::MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (msg)
    {
        &lt;span class=&quot;co&quot;&gt;// WM_ACTIVATE is sent when the window is activated or deactivated.  &lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// We pause the game when the window is deactivated and unpause it &lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// when it becomes active.  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_ACTIVATE:
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (LOWORD(wParam) == WA_INACTIVE)
        {
            mAppPaused = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            mTimer.Stop();
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            mAppPaused = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            mTimer.Start();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// WM_SIZE is sent when the user resizes the window.  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_SIZE:
        &lt;span class=&quot;co&quot;&gt;// Save the new client area dimensions.&lt;/span&gt;
        mClientWidth = LOWORD(lParam);
        mClientHeight = HIWORD(lParam);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (md3dDevice)
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wParam == SIZE_MINIMIZED)
            {
                mAppPaused = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                mMinimized = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                mMaximized = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wParam == SIZE_MAXIMIZED)
            {
                mAppPaused = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                mMinimized = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                mMaximized = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                OnResize();
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wParam == SIZE_RESTORED)
            {

                &lt;span class=&quot;co&quot;&gt;// Restoring from minimized state?&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mMinimized)
                {
                    mAppPaused = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    mMinimized = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    OnResize();
                }

                &lt;span class=&quot;co&quot;&gt;// Restoring from maximized state?&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mMaximized)
                {
                    mAppPaused = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    mMaximized = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    OnResize();
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mResizing)
                {
                    &lt;span class=&quot;co&quot;&gt;// If user is dragging the resize bars, we do not resize &lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// the buffers here because as the user continuously &lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// drags the resize bars, a stream of WM_SIZE messages are&lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// sent to the window, and it would be pointless (and slow)&lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// to resize for each WM_SIZE message received from dragging&lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// the resize bars.  So instead, we reset after the user is &lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// done resizing the window and releases the resize bars, which &lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;// sends a WM_EXITSIZEMOVE message.&lt;/span&gt;
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// API call such as SetWindowPos or mSwapChain-&amp;gt;SetFullscreenState.&lt;/span&gt;
                {
                    OnResize();
                }
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// WM_EXITSIZEMOVE is sent when the user grabs the resize bars.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_ENTERSIZEMOVE:
        mAppPaused = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        mResizing = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        mTimer.Stop();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// WM_EXITSIZEMOVE is sent when the user releases the resize bars.&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// Here we reset everything based on the new window dimensions.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_EXITSIZEMOVE:
        mAppPaused = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        mResizing = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        mTimer.Start();
        OnResize();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// WM_DESTROY is sent when the window is being destroyed.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_DESTROY:
        PostQuitMessage(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;// The WM_MENUCHAR message is sent when a menu is active and the user presses &lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// a key that does not correspond to any mnemonic or accelerator key. &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_MENUCHAR:
        &lt;span class=&quot;co&quot;&gt;// Don't beep when we alt-enter.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; MAKELRESULT(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, MNC_CLOSE);

        &lt;span class=&quot;co&quot;&gt;// Catch this message so to prevent the window from becoming too small.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_GETMINMAXINFO:
        ((MINMAXINFO*)lParam)-&amp;gt;ptMinTrackSize.x = &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;;
        ((MINMAXINFO*)lParam)-&amp;gt;ptMinTrackSize.y = &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_LBUTTONDOWN:
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_MBUTTONDOWN:
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_RBUTTONDOWN:
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_LBUTTONUP:
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_MBUTTONUP:
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_RBUTTONUP:
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; WM_MOUSEMOVE:
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; DefWindowProc(hwnd, msg, wParam, lParam);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;WM_ACTIVATE&lt;/code&gt;事件处理窗口激活或无效的情况，若窗口激活，则启动计时器；否则停止计时器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WM_SIZE&lt;/code&gt; 事件处理窗口大小变化的情况。若窗口最小化，进行标记。若窗口已经发生变化，需要调用&lt;code&gt;d3dApp::OnReSize&lt;/code&gt;方法处理窗口变化的情况。在窗口大小正在改变的过程中，我们不需要调用刚才的方法(此时窗口边缘可能正在被拖动)，否则太影响运行效率。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WM_ENTERSIZEMOVE&lt;/code&gt;事件处理窗口正在移动或大小正在变化的情况。这个时候需要暂停计时器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WM_EXITSIZEMOVE&lt;/code&gt;事件处理窗口移动完成或大小变化结束的情况。这个时候需要启动计时器。&lt;/p&gt;
&lt;p&gt;其余事件这里不做具体描述，有些事件当前没有处理，但是后续的内容会对这里进行修改。&lt;/p&gt;
&lt;h2 id=&quot;d3dappinitdirect3d方法--初始化direct3d&quot;&gt;D3DApp::InitDirect3D方法--初始化Direct3D&lt;/h2&gt;
&lt;p&gt;现在假定你的电脑已经支持DirectX 11，但同时也有可能支持DirectX 11.1。因此在该项目中使用的头文件是&lt;code&gt;d3d11_1.h&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要初始化DirectX11，我们需要创建这三样东西：D3D设备、D3D设备上下文和DXGI交换链。&lt;/p&gt;
&lt;p&gt;D3D设备包含了创建各种所需资源的方法。&lt;/p&gt;
&lt;p&gt;D3D设备上下文负责对缓冲区进行渲染，绑定D3D设备创建的各种资源到不同的渲染管线。&lt;/p&gt;
&lt;p&gt;DXGI交换链可以包含两个或多个缓冲区，通常一个用于前端显示，其余的用于后端渲染。前台缓冲区通常是只读的，而后备缓冲区则是我们主要进行渲染的场所。当后备缓冲区渲染完成后，通过呈现方式将前后台缓冲区交换，在屏幕上显示出原来刚绘制好的画面。&lt;/p&gt;
&lt;p&gt;这三样东西对应的接口类为：&lt;code&gt;ID3D11Device&lt;/code&gt;、&lt;code&gt;ID3D11DeviceContext&lt;/code&gt;、&lt;code&gt;IDXGISwapChain&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而如果支持DirectX11.1的话，则对应的接口类为：&lt;code&gt;ID3D11Device1&lt;/code&gt;、&lt;code&gt;ID3D11DeviceContext1&lt;/code&gt;、&lt;code&gt;IDXGISwapChain1&lt;/code&gt;，它们分别继承自上面的三个接口类，区别在于额外提供了少数新的接口，并且接口方法的实现可能会有所区别。&lt;/p&gt;
&lt;h3 id=&quot;d3d11createdevice函数-创建d3d设备与d3d设备上下文&quot;&gt;D3D11CreateDevice函数 创建D3D设备与D3D设备上下文&lt;/h3&gt;
&lt;p&gt;创建D3D设备、D3D设备上下文使用如下函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT WINAPI D3D11CreateDevice(
    IDXGIAdapter* pAdapter,         &lt;span class=&quot;co&quot;&gt;// [In_Opt]适配器&lt;/span&gt;
    D3D_DRIVER_TYPE DriverType,     &lt;span class=&quot;co&quot;&gt;// [In]驱动类型&lt;/span&gt;
    HMODULE Software,               &lt;span class=&quot;co&quot;&gt;// [In_Opt]若上面为D3D_DRIVER_TYPE_SOFTWARE则这里需要提供程序模块&lt;/span&gt;
    UINT Flags,                     &lt;span class=&quot;co&quot;&gt;// [In]使用D3D11_CREATE_DEVICE_FLAG枚举类型&lt;/span&gt;
    D3D_FEATURE_LEVEL* pFeatureLevels,  &lt;span class=&quot;co&quot;&gt;// [In_Opt]若为nullptr则为默认特性等级，否则需要提供特性等级数组&lt;/span&gt;
    UINT FeatureLevels,             &lt;span class=&quot;co&quot;&gt;// [In]特性等级数组的元素数目&lt;/span&gt;
    UINT SDKVersion,                &lt;span class=&quot;co&quot;&gt;// [In]SDK版本，默认D3D11_SDK_VERSION&lt;/span&gt;
    ID3D11Device** ppDevice,        &lt;span class=&quot;co&quot;&gt;// [Out_Opt]输出D3D设备&lt;/span&gt;
    D3D_FEATURE_LEVEL* pFeatureLevel,   &lt;span class=&quot;co&quot;&gt;// [Out_Opt]输出当前应用D3D特性等级&lt;/span&gt;
    ID3D11DeviceContext** ppImmediateContext ); &lt;span class=&quot;co&quot;&gt;//[Out_Opt]输出D3D设备上下文&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数可以创建DirectX11.1或者DirectX11.0的设备与设备上下文，取决于最终应用的D3D特性等级。&lt;/p&gt;
&lt;p&gt;首先需要创建驱动类型数组进行轮询，不过通常大多数情况都会支持&lt;code&gt;D3D_DRIVER_TYPE_HARDWARE&lt;/code&gt;，以享受硬件加速带来的效益：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 驱动类型数组&lt;/span&gt;
D3D_DRIVER_TYPE driverTypes[] =
{
    D3D_DRIVER_TYPE_HARDWARE,       &lt;span class=&quot;co&quot;&gt;// 硬件驱动&lt;/span&gt;
    D3D_DRIVER_TYPE_WARP,           &lt;span class=&quot;co&quot;&gt;// WARP驱动&lt;/span&gt;
    D3D_DRIVER_TYPE_REFERENCE,      &lt;span class=&quot;co&quot;&gt;// 软件驱动&lt;/span&gt;
};
UINT numDriverTypes = ARRAYSIZE(driverTypes);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是提供特性等级数组，这里只考虑DirectX11：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 特性等级数组&lt;/span&gt;
D3D_FEATURE_LEVEL featureLevels[] =
{
    D3D_FEATURE_LEVEL_11_1,
    D3D_FEATURE_LEVEL_11_0,
};
UINT numFeatureLevels = ARRAYSIZE(featureLevels);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后就会可以创建D3D设备和设备上下文了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT hr = S_OK;

&lt;span class=&quot;co&quot;&gt;// 创建D3D设备 和 D3D设备上下文&lt;/span&gt;
UINT createDeviceFlags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;ot&quot;&gt;#if defined(DEBUG) || defined(_DEBUG)  &lt;/span&gt;
createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 驱动类型数组&lt;/span&gt;
D3D_DRIVER_TYPE driverTypes[] =
{
    D3D_DRIVER_TYPE_HARDWARE,
    D3D_DRIVER_TYPE_WARP,
    D3D_DRIVER_TYPE_REFERENCE,
};
UINT numDriverTypes = ARRAYSIZE(driverTypes);

&lt;span class=&quot;co&quot;&gt;// 特性等级数组&lt;/span&gt;
D3D_FEATURE_LEVEL featureLevels[] =
{
    D3D_FEATURE_LEVEL_11_1,
    D3D_FEATURE_LEVEL_11_0,
};
UINT numFeatureLevels = ARRAYSIZE(featureLevels);

D3D_FEATURE_LEVEL featureLevel;
D3D_DRIVER_TYPE d3dDriverType;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (UINT driverTypeIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; driverTypeIndex &amp;lt; numDriverTypes; driverTypeIndex++)
{
    d3dDriverType = driverTypes[driverTypeIndex];
    hr = D3D11CreateDevice(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, d3dDriverType, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, createDeviceFlags, featureLevels, numFeatureLevels,
        D3D11_SDK_VERSION, md3dDevice.GetAddressOf(), &amp;amp;featureLevel, md3dImmediateContext.GetAddressOf());
    
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hr == E_INVALIDARG)
    {
        &lt;span class=&quot;co&quot;&gt;// DirectX 11.0 平台不承认D3D_FEATURE_LEVEL_11_1所以我们需要尝试特性等级11.0&lt;/span&gt;
        hr = D3D11CreateDevice(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, d3dDriverType, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, createDeviceFlags, &amp;amp;featureLevels[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], numFeatureLevels - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
            D3D11_SDK_VERSION, md3dDevice.GetAddressOf(), &amp;amp;featureLevel, md3dImmediateContext.GetAddressOf());
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (SUCCEEDED(hr))
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
}

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (FAILED(hr))
{
    MessageBox(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;L&quot;D3D11CreateDevice Failed.&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果支持DirectX11.1的话，&lt;code&gt;featureLevel&lt;/code&gt;的结果应该为&lt;code&gt;D3D_FEATURE_LEVEL_11_1&lt;/code&gt;，并且&lt;code&gt;md3dDevice&lt;/code&gt;指向的是一个包含&lt;code&gt;ID3D11Device1&lt;/code&gt;接口的对象，以及&lt;code&gt;md3dImmediateContext&lt;/code&gt;指向的是一个包含&lt;code&gt;ID3D11DeviceContext1&lt;/code&gt;接口的对象；而如果只支持DirectX11.0的话则为&lt;code&gt;D3D_FEATURE_LEVEL_11_0&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;idxgifactory2createswapchainforhwnd方法--directx11.1创建交换链&quot;&gt;IDXGIFactory2::CreateSwapChainForHwnd方法--DirectX11.1创建交换链&lt;/h3&gt;
&lt;p&gt;如果是DirectX11.1的话，需要先填充&lt;code&gt;DXGI_SWAP_CHAIN_DESC1&lt;/code&gt;和&lt;code&gt;DXGI_SWAP_CHAIN_FULLSCREEN_DESC&lt;/code&gt;这两个结构体：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_SWAP_CHAIN_DESC1
{
    UINT Width;                     &lt;span class=&quot;co&quot;&gt;// 缓冲区宽度&lt;/span&gt;
    UINT Height;                    &lt;span class=&quot;co&quot;&gt;// 缓冲区高度&lt;/span&gt;
    DXGI_FORMAT Format;             &lt;span class=&quot;co&quot;&gt;// 缓冲区数据格式&lt;/span&gt;
    BOOL Stereo;                    &lt;span class=&quot;co&quot;&gt;// 忽略   &lt;/span&gt;
    DXGI_SAMPLE_DESC SampleDesc;    &lt;span class=&quot;co&quot;&gt;// 采样描述&lt;/span&gt;
    DXGI_USAGE BufferUsage;         &lt;span class=&quot;co&quot;&gt;// 缓冲区用途&lt;/span&gt;
    UINT BufferCount;               &lt;span class=&quot;co&quot;&gt;// 缓冲区数目&lt;/span&gt;
    DXGI_SCALING Scaling;           &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    DXGI_SWAP_EFFECT SwapEffect;    &lt;span class=&quot;co&quot;&gt;// 交换效果&lt;/span&gt;
    DXGI_ALPHA_MODE AlphaMode;      &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    UINT Flags;                     &lt;span class=&quot;co&quot;&gt;// 使用DXGI_SWAP_CHAIN_FLAG枚举类型&lt;/span&gt;
} DXGI_SWAP_CHAIN_DESC1;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_SAMPLE_DESC
{
    UINT Count;                     &lt;span class=&quot;co&quot;&gt;// MSAA采样数&lt;/span&gt;
    UINT Quality;                   &lt;span class=&quot;co&quot;&gt;// MSAA质量等级&lt;/span&gt;
} DXGI_SAMPLE_DESC;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_SWAP_CHAIN_FULLSCREEN_DESC
{
    DXGI_RATIONAL RefreshRate;                  &lt;span class=&quot;co&quot;&gt;// 刷新率&lt;/span&gt;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;  &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    DXGI_MODE_SCALING Scaling;                  &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    BOOL Windowed;                              &lt;span class=&quot;co&quot;&gt;// 是否窗口化&lt;/span&gt;
} DXGI_SWAP_CHAIN_FULLSCREEN_DESC;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_RATIONAL
{
    UINT Numerator;                 &lt;span class=&quot;co&quot;&gt;// 刷新率分子&lt;/span&gt;
    UINT Denominator;               &lt;span class=&quot;co&quot;&gt;// 刷新率分母&lt;/span&gt;
} DXGI_RATIONAL;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;填充好后，DirectX11.1使用的创建方法为&lt;code&gt;IDXGIFactory2::CreateSwapChainForHwnd&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT IDXGIFactory2::CreateSwapChainForHwnd(
    IUnknown *pDevice,                      &lt;span class=&quot;co&quot;&gt;// [In]D3D设备&lt;/span&gt;
    HWND hWnd,                              &lt;span class=&quot;co&quot;&gt;// [In]窗口句柄&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; DXGI_SWAP_CHAIN_DESC1 *pDesc,     &lt;span class=&quot;co&quot;&gt;// [In]交换链描述1&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pFullscreenDesc, &lt;span class=&quot;co&quot;&gt;// [In]交换链全屏描述，可选&lt;/span&gt;
    IDXGIOutput *pRestrictToOutput,         &lt;span class=&quot;co&quot;&gt;// [In]忽略&lt;/span&gt;
    IDXGISwapChain1 **ppSwapChain);         &lt;span class=&quot;co&quot;&gt;// [Out]输出交换链对象&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体操作在后面一并演示&lt;/p&gt;
&lt;h3 id=&quot;idxgifactorycreateswapchain方法--directx11创建交换链&quot;&gt;IDXGIFactory::CreateSwapChain方法--DirectX11创建交换链&lt;/h3&gt;
&lt;p&gt;如果是DirectX11.0的话，需要先填充&lt;code&gt;DXGI_SWAP_CHAIN_DESC&lt;/code&gt;结构体：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_SWAP_CHAIN_DESC
{
    DXGI_MODE_DESC BufferDesc;      &lt;span class=&quot;co&quot;&gt;// 缓冲区描述&lt;/span&gt;
    DXGI_SAMPLE_DESC SampleDesc;    &lt;span class=&quot;co&quot;&gt;// 采样描述&lt;/span&gt;
    DXGI_USAGE BufferUsage;         &lt;span class=&quot;co&quot;&gt;// 缓冲区用途&lt;/span&gt;
    UINT BufferCount;               &lt;span class=&quot;co&quot;&gt;// 后备缓冲区数目&lt;/span&gt;
    HWND OutputWindow;              &lt;span class=&quot;co&quot;&gt;// 输出窗口句柄&lt;/span&gt;
    BOOL Windowed;                  &lt;span class=&quot;co&quot;&gt;// 窗口化？&lt;/span&gt;
    DXGI_SWAP_EFFECT SwapEffect;    &lt;span class=&quot;co&quot;&gt;// 交换效果&lt;/span&gt;
    UINT Flags;                     &lt;span class=&quot;co&quot;&gt;// 使用DXGI_SWAP_CHAIN_FLAG枚举类型&lt;/span&gt;
}   DXGI_SWAP_CHAIN_DESC;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_SAMPLE_DESC
{
    UINT Count;                     &lt;span class=&quot;co&quot;&gt;// MSAA采样数&lt;/span&gt;
    UINT Quality;                   &lt;span class=&quot;co&quot;&gt;// MSAA质量等级&lt;/span&gt;
} DXGI_SAMPLE_DESC;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_MODE_DESC
{
    UINT Width;                     &lt;span class=&quot;co&quot;&gt;// 缓冲区宽度&lt;/span&gt;
    UINT Height;                    &lt;span class=&quot;co&quot;&gt;// 缓冲区高度&lt;/span&gt;
    DXGI_RATIONAL RefreshRate;      &lt;span class=&quot;co&quot;&gt;// 刷新率分数表示法&lt;/span&gt;
    DXGI_FORMAT Format;             &lt;span class=&quot;co&quot;&gt;// 缓冲区数据格式&lt;/span&gt;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;  &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    DXGI_MODE_SCALING Scaling;      &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
} DXGI_MODE_DESC;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; DXGI_RATIONAL
{
    UINT Numerator;                 &lt;span class=&quot;co&quot;&gt;// 刷新率分子&lt;/span&gt;
    UINT Denominator;               &lt;span class=&quot;co&quot;&gt;// 刷新率分母&lt;/span&gt;
} DXGI_RATIONAL;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DirectX11.0下使用的创建方法为&lt;code&gt;IDXGIFactory::CreateSwapChain&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT IDXGIFactory::CreateSwapChain(
    IUnknown *pDevice,                  &lt;span class=&quot;co&quot;&gt;// [In]D3D设备&lt;/span&gt;
    DXGI_SWAP_CHAIN_DESC *pDesc,        &lt;span class=&quot;co&quot;&gt;// [In]交换链描述&lt;/span&gt;
    IDXGISwapChain **ppSwapChain);      &lt;span class=&quot;co&quot;&gt;// [Out]输出交换链对象&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;根据已有设备类型来创建合适的交换链&quot;&gt;根据已有设备类型来创建合适的交换链&lt;/h3&gt;
&lt;p&gt;了解了前面的操作后，现在我们需要先拿到包含&lt;code&gt;IDXGIFactory&lt;/code&gt;或者&lt;code&gt;IDXGIFactory2&lt;/code&gt;接口的对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;ComPtr&amp;lt;IDXGIDevice&amp;gt; dxgiDevice = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
ComPtr&amp;lt;IDXGIAdapter&amp;gt; dxgiAdapter = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
ComPtr&amp;lt;IDXGIFactory1&amp;gt; dxgiFactory1 = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;

ComPtr&amp;lt;IDXGIDevice1&amp;gt; dxgiDevice1 = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
ComPtr&amp;lt;IDXGIAdapter1&amp;gt; dxgiAdapter1 = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
ComPtr&amp;lt;IDXGIFactory2&amp;gt; dxgiFactory2 = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;// 为了正确创建 DXGI交换链，首先我们需要获取创建 D3D设备 的 DXGI工厂，否则会引发报错：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// &quot;IDXGIFactory::CreateSwapChain: This function is being called with a device from a different IDXGIFactory.&quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 从属关系为 DXGI工厂-&amp;gt; DXGI适配器 -&amp;gt; DXGI设备 {D3D11设备}&lt;/span&gt;
HR(md3dDevice-&amp;gt;QueryInterface(__uuidof(IDXGIDevice), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(dxgiDevice.GetAddressOf())));
HR(dxgiDevice-&amp;gt;GetAdapter(dxgiAdapter.GetAddressOf()));
HR(dxgiAdapter-&amp;gt;GetParent(__uuidof(IDXGIFactory1), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(dxgiFactory1.GetAddressOf())));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候可以确定&lt;code&gt;dxgiFactory1&lt;/code&gt;包含接口&lt;code&gt;IDXGIFactory1&lt;/code&gt;，然后检查它是否包含接口&lt;code&gt;IDXGIFactory2&lt;/code&gt;，包含的话就说明支持DirectX11.1，然后获取&lt;code&gt;ID3D11Device1&lt;/code&gt;和&lt;code&gt;ID3D11DeviceContext1&lt;/code&gt;接口对象并创建包含&lt;code&gt;IDXGISwapChain1&lt;/code&gt;接口的对象，否则就创建&lt;code&gt;IDXGISwapChain&lt;/code&gt;接口的对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 如果包含，则说明支持DX11.1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (dxgiFactory2 != &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;)
{
    HR(md3dDevice-&amp;gt;QueryInterface(__uuidof(ID3D11Device1), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(md3dDevice1.GetAddressOf())));
    HR(md3dImmediateContext-&amp;gt;QueryInterface(__uuidof(ID3D11DeviceContext1), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(md3dImmediateContext1.GetAddressOf())));
    &lt;span class=&quot;co&quot;&gt;// 填充各种结构体用以描述交换链&lt;/span&gt;
    DXGI_SWAP_CHAIN_DESC1 sd;
    ZeroMemory(&amp;amp;sd, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(sd));
    sd.Width = mClientWidth;
    sd.Height = mClientHeight;
    sd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.SampleDesc.Count = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sd.SampleDesc.Quality = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.BufferCount = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
    sd.Flags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    DXGI_SWAP_CHAIN_FULLSCREEN_DESC fd;
    fd.RefreshRate.Numerator = &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;;
    fd.RefreshRate.Denominator = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    fd.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
    fd.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
    fd.Windowed = TRUE;
    &lt;span class=&quot;co&quot;&gt;// 为当前窗口创建交换链&lt;/span&gt;
    HR(dxgiFactory2-&amp;gt;CreateSwapChainForHwnd(md3dDevice.Get(), mhMainWnd, &amp;amp;sd, &amp;amp;fd, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, mSwapChain1.GetAddressOf()));
    mSwapChain1-&amp;gt;QueryInterface(__uuidof(IDXGISwapChain), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(mSwapChain.GetAddressOf()));
}
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
{
    &lt;span class=&quot;co&quot;&gt;// 填充DXGI_SWAP_CHAIN_DESC用以描述交换链&lt;/span&gt;
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&amp;amp;sd, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(sd));
    sd.BufferDesc.Width = mClientWidth;
    sd.BufferDesc.Height = mClientHeight;
    sd.BufferDesc.RefreshRate.Numerator = &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;;
    sd.BufferDesc.RefreshRate.Denominator = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
    sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
    sd.SampleDesc.Count = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sd.SampleDesc.Quality = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.BufferCount = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sd.OutputWindow = mhMainWnd;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
    sd.Flags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    HR(dxgiFactory1-&amp;gt;CreateSwapChain(md3dDevice.Get(), &amp;amp;sd, mSwapChain.GetAddressOf()));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候，如果支持DirectX11.1的话，&lt;code&gt;md3dDevice&lt;/code&gt;和&lt;code&gt;md3dDevice1&lt;/code&gt;其实都指向同一个对象，&lt;code&gt;md3dImmediateContext&lt;/code&gt;和&lt;code&gt;md3dImmediateContext1&lt;/code&gt;，&lt;code&gt;mSwapChain&lt;/code&gt;和&lt;code&gt;mSwapChain1&lt;/code&gt;也是一样的，区别仅仅在于后者实现了额外的一些接口，问题不大。因此不管是DirectX11.1还是DirectX11.0，后续都主要使用&lt;code&gt;md3dDevice&lt;/code&gt;，&lt;code&gt;md3dImmediateContext&lt;/code&gt;和&lt;code&gt;mSwapChain&lt;/code&gt;来进行操作。&lt;/p&gt;
&lt;h3 id=&quot;设置全屏&quot;&gt;设置全屏&lt;/h3&gt;
&lt;p&gt;默认情况下按ALT+ENTER可以切换成全屏，如果不想要这种操作，可以使用刚才创建的&lt;code&gt;dxgiFactory1&lt;/code&gt;，按照下面的方式来调用即可：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;dxgiFactory1-&amp;gt;MakeWindowAssociation(mhMainWnd, DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_WINDOW_CHANGES);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样DXGI就不会监听Windows消息队列，并且屏蔽掉了对接收到ALT+ENTER消息的处理。&lt;/p&gt;
&lt;p&gt;在上述操作完成后，最后还调用了&lt;code&gt;D3DApp::OnReSize&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;d3dapponresize方法--窗口调整后的操作&quot;&gt;D3DApp::OnReSize方法--窗口调整后的操作&lt;/h2&gt;
&lt;p&gt;无论是初始化操作，还是窗口大小变化后的操作，参与绘制的后备缓冲区和深度模板缓冲区大小都需要重新设置，因此需要重新创建。&lt;/p&gt;
&lt;h3 id=&quot;id3d11resource资源类型&quot;&gt;ID3D11Resource资源类型&lt;/h3&gt;
&lt;p&gt;Direct3D 11的资源可以主要分为四个大类，它们都派生自&lt;code&gt;ID3D11Resource&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11Buffer&lt;/code&gt;通常用于顶点缓冲区、索引缓冲区等&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11Texture1D&lt;/code&gt;通常用于创建1维纹理资源&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11Texture2D&lt;/code&gt;通常用于创建2维纹理资源，可用于后备缓冲区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11Texture2D&lt;/code&gt;通常用于创建3维纹理资源&lt;/p&gt;
&lt;h3 id=&quot;id3d11view资源视图类型&quot;&gt;ID3D11View资源视图类型&lt;/h3&gt;
&lt;p&gt;Direct3D 11的资源视图也可以分为四个大类，它们都派生自&lt;code&gt;ID3D11View&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11RenderTargetView&lt;/code&gt; 渲染目标视图通常会绑定一个&lt;code&gt;ID3D11Texture2D&lt;/code&gt;的资源，而且通常绑定的是交换链指向的一个后备缓冲区。该视图还需要绑定到渲染管线的输出合并阶段，输出的结果将会写入到所绑定的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11DepthStencilView&lt;/code&gt; 深度模板视图通常会绑定一个&lt;code&gt;ID3D11Texture2D&lt;/code&gt;的资源，该资源用于存储深度和模板信息。该视图还需要绑定到渲染管线的输出合并阶段，输出的结果将会写入到所绑定的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11ShaderResourceView&lt;/code&gt; 着色资源视图可以绑定资源，然后将该视图绑定到渲染管线的着色器阶段，使得着色器代码可以访问绑定的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ID3D11UnorderedAccessView&lt;/code&gt; 目前还不了解该视图的作用，可能会在后续进行更新补充说明。&lt;/p&gt;
&lt;h3 id=&quot;idxgiswapchaingetbuffer方法--获取后备缓冲区&quot;&gt;IDXGISwapChain::GetBuffer方法--获取后备缓冲区&lt;/h3&gt;
&lt;p&gt;由于此前我们创建好的交换链已经包含1个后备缓冲区了，在创建渲染目标视图之前我们还需要获取该后备缓冲区：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT IDXGISwapChain::GetBuffer( 
    UINT Buffer,        &lt;span class=&quot;co&quot;&gt;// [In]缓冲区索引号，从0到BufferCount - 1&lt;/span&gt;
    REFIID riid,        &lt;span class=&quot;co&quot;&gt;// [In]缓冲区的接口类型ID&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; **ppSurface);  &lt;span class=&quot;co&quot;&gt;// [Out]获取到的缓冲区&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id3d11devicecreaterendertargetview方法--创建渲染目标视图&quot;&gt;ID3D11Device::CreateRenderTargetView方法--创建渲染目标视图&lt;/h3&gt;
&lt;p&gt;使用下面的方法来获取渲染目标视图：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT ID3D11Device::CreateRenderTargetView( 
    ID3D11Resource *pResource,                      &lt;span class=&quot;co&quot;&gt;// [In]缓冲区资源&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; D3D11_RENDER_TARGET_VIEW_DESC *pDesc,     &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    ID3D11RenderTargetView **ppRTView);             &lt;span class=&quot;co&quot;&gt;// [Out]获取渲染目标视图&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此&lt;code&gt;D3DApp::OnReSize&lt;/code&gt;方法前面可以这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;assert(md3dImmediateContext);
assert(md3dDevice);
assert(mSwapChain);

&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (md3dDevice1 != &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;)
{
    assert(md3dImmediateContext1);
    assert(md3dDevice1);
    assert(mSwapChain1);
}

&lt;span class=&quot;co&quot;&gt;// 释放交换链的相关资源&lt;/span&gt;
mRenderTargetView.Reset();
mDepthStencilView.Reset();
mDepthStencilBuffer.Reset();

&lt;span class=&quot;co&quot;&gt;// 重设交换链并且重新创建渲染目标视图&lt;/span&gt;
ComPtr&amp;lt;ID3D11Texture2D&amp;gt; backBuffer;
HR(mSwapChain-&amp;gt;ResizeBuffers(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, mClientWidth, mClientHeight, DXGI_FORMAT_R8G8B8A8_UNORM, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
HR(mSwapChain-&amp;gt;GetBuffer(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, __uuidof(ID3D11Texture2D), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**&amp;gt;(backBuffer.GetAddressOf())));
HR(md3dDevice-&amp;gt;CreateRenderTargetView(backBuffer.Get(), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, mRenderTargetView.GetAddressOf()));
    
    
backBuffer.Reset();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id3d11devicecreatetexture2d--创建一个2d纹理&quot;&gt;ID3D11Device::CreateTexture2D--创建一个2D纹理&lt;/h3&gt;
&lt;p&gt;除了渲染目标视图外，我们还需要创建深度模板缓冲区用于深度测试。通过D3D设备可以新建一个缓冲区，但在此之前我们需要先描述该缓冲区的信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; D3D11_TEXTURE2D_DESC
{
    UINT Width;         &lt;span class=&quot;co&quot;&gt;// 缓冲区宽度&lt;/span&gt;
    UINT Height;        &lt;span class=&quot;co&quot;&gt;// 缓冲区高度&lt;/span&gt;
    UINT MipLevels;     &lt;span class=&quot;co&quot;&gt;// Mip等级&lt;/span&gt;
    UINT ArraySize;     &lt;span class=&quot;co&quot;&gt;// 纹理数组中的纹理数量，默认1&lt;/span&gt;
    DXGI_FORMAT Format; &lt;span class=&quot;co&quot;&gt;// 缓冲区数据格式&lt;/span&gt;
    DXGI_SAMPLE_DESC SampleDesc;    &lt;span class=&quot;co&quot;&gt;// 忽略&lt;/span&gt;
    D3D11_USAGE Usage;  &lt;span class=&quot;co&quot;&gt;// 数据的CPU/GPU访问权限&lt;/span&gt;
    UINT BindFlags;     &lt;span class=&quot;co&quot;&gt;// 使用D3D11_BIND_FLAG枚举来决定该数据的使用类型&lt;/span&gt;
    UINT CPUAccessFlags;    &lt;span class=&quot;co&quot;&gt;// 使用D3D11_CPU_ACCESS_FLAG枚举来决定CPU访问权限&lt;/span&gt;
    UINT MiscFlags;     &lt;span class=&quot;co&quot;&gt;// 使用D3D11_RESOURCE_MISC_FLAG枚举，这里默认0&lt;/span&gt;
}   D3D11_TEXTURE2D_DESC;   &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;填充好后，这时我们就可以用方法&lt;code&gt;ID3D11Device::CreateTexture2D&lt;/code&gt;来创建2D纹理：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT ID3D11Device::CreateTexture2D( 
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; D3D11_TEXTURE2D_DESC *pDesc,          &lt;span class=&quot;co&quot;&gt;// [In] 2D纹理描述信息&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; D3D11_SUBRESOURCE_DATA *pInitialData, &lt;span class=&quot;co&quot;&gt;// [In] 用于初始化的资源&lt;/span&gt;
    ID3D11Texture2D **ppTexture2D);             &lt;span class=&quot;co&quot;&gt;// [Out] 获取到的2D纹理&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id3d11devicecreatedepthstencilview方法--创建深度模板视图&quot;&gt;ID3D11Device::CreateDepthStencilView方法--创建深度模板视图&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT ID3D11Device::CreateDepthStencilView( 
    ID3D11Resource *pResource,                      &lt;span class=&quot;co&quot;&gt;// [In] 需要绑定的资源&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; D3D11_DEPTH_STENCIL_VIEW_DESC *pDesc,     &lt;span class=&quot;co&quot;&gt;// [In] 深度缓冲区描述&lt;/span&gt;
    ID3D11DepthStencilView **ppDepthStencilView);   &lt;span class=&quot;co&quot;&gt;// [Out] 获取到的深度模板视图&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id3d11devicecontextomsetrendertargets方法--输出合并阶段绑定渲染目标视图和深度模板视图&quot;&gt;ID3D11DeviceContext::OMSetRenderTargets方法--输出合并阶段绑定渲染目标视图和深度模板视图&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ID3D11DeviceContext::OMSetRenderTargets( 
    UINT NumViews,                                      &lt;span class=&quot;co&quot;&gt;// [In] 视图数目&lt;/span&gt;
    ID3D11RenderTargetView *&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; *ppRenderTargetViews, &lt;span class=&quot;co&quot;&gt;// [In] 渲染目标视图数组&lt;/span&gt;
    ID3D11DepthStencilView *pDepthStencilView) = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;     &lt;span class=&quot;co&quot;&gt;// [In] 深度模板视图&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面演示了如何创建深度模板视图，并将渲染目标视图和深度模板视图绑定到渲染管线的输出合并阶段：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;D3D11_TEXTURE2D_DESC depthStencilDesc;

depthStencilDesc.Width = mClientWidth;
depthStencilDesc.Height = mClientHeight;
depthStencilDesc.MipLevels = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
depthStencilDesc.ArraySize = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;

&lt;span class=&quot;co&quot;&gt;// 要使用 4X MSAA? --需要给交换链设置MASS参数&lt;/span&gt;

depthStencilDesc.SampleDesc.Count = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
depthStencilDesc.SampleDesc.Quality = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
depthStencilDesc.CPUAccessFlags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
depthStencilDesc.MiscFlags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;// 创建深度缓冲区以及深度模板视图&lt;/span&gt;
HR(md3dDevice-&amp;gt;CreateTexture2D(&amp;amp;depthStencilDesc, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, mDepthStencilBuffer.GetAddressOf()));
HR(md3dDevice-&amp;gt;CreateDepthStencilView(mDepthStencilBuffer.Get(), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, mDepthStencilView.GetAddressOf()));


&lt;span class=&quot;co&quot;&gt;// 将渲染目标视图和深度/模板缓冲区结合到管线&lt;/span&gt;
md3dImmediateContext-&amp;gt;OMSetRenderTargets(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, mRenderTargetView.GetAddressOf(), mDepthStencilView.Get());&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终我们还需要决定将整个视图输出到窗口特定的范围。因此我们需要使用&lt;code&gt;D3D11_VIEWPORT&lt;/code&gt;来设置视口&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; D3D11_VIEWPORT
{
    FLOAT TopLeftX;     &lt;span class=&quot;co&quot;&gt;// 屏幕左上角起始位置X&lt;/span&gt;
    FLOAT TopLeftY;     &lt;span class=&quot;co&quot;&gt;// 屏幕左上角起始位置Y&lt;/span&gt;
    FLOAT Width;        &lt;span class=&quot;co&quot;&gt;// 宽度&lt;/span&gt;
    FLOAT Height;       &lt;span class=&quot;co&quot;&gt;// 高度&lt;/span&gt;
    FLOAT MinDepth;     &lt;span class=&quot;co&quot;&gt;// 最小深度，必须为0.0f&lt;/span&gt;
    FLOAT MaxDepth;     &lt;span class=&quot;co&quot;&gt;// 最大深度，必须为1.0f&lt;/span&gt;
}   D3D11_VIEWPORT;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ID3D11DeviceContext::RSSetViewports&lt;/code&gt;方法将设置1个或多个视口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ID3D11DeviceContext::RSSetViewports(
    UINT  NumViewports,                     &lt;span class=&quot;co&quot;&gt;// 视口数目&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; D3D11_VIEWPORT *pViewports);      &lt;span class=&quot;co&quot;&gt;// 视口数组&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将视图输出到整个屏幕需要进行下面的操作：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;mScreenViewport.TopLeftX = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
mScreenViewport.TopLeftY = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
mScreenViewport.Width    = &lt;span class=&quot;kw&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;&amp;gt;(mClientWidth);
mScreenViewport.Height   = &lt;span class=&quot;kw&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;&amp;gt;(mClientHeight);
mScreenViewport.MinDepth = &lt;span class=&quot;fl&quot;&gt;0.0f&lt;/span&gt;;
mScreenViewport.MaxDepth = &lt;span class=&quot;fl&quot;&gt;1.0f&lt;/span&gt;;

md3dImmediateContext-&amp;gt;RSSetViewports(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;mScreenViewport);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些就是&lt;code&gt;D3DApp&lt;/code&gt;框架类最主要的部分了，在后续的部分，该框架的代码基本上不会有什么太大的变动。因此后续代码的添加主要在&lt;code&gt;GameApp&lt;/code&gt;类实现。&lt;/p&gt;

&lt;p&gt;对于一个初始化应用程序来说，目前GameApp类的非常简单：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GameApp : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; D3DApp
{
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    GameApp(HINSTANCE hInstance);
    ~GameApp();

    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; Init();
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; OnResize();
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; UpdateScene(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; dt);
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; DrawScene();
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;gameappdrawscene方法--每帧画面的绘制&quot;&gt;GameApp::DrawScene方法--每帧画面的绘制&lt;/h2&gt;
&lt;h3 id=&quot;id3d11devicecontextclearrendertargetview方法--清空需要绘制的缓冲区&quot;&gt;ID3D11DeviceContext::ClearRenderTargetView方法--清空需要绘制的缓冲区&lt;/h3&gt;
&lt;p&gt;在每一帧画面绘制的操作中，我们需要清理一遍渲染目标视图绑定的缓冲区&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ID3D11DeviceContext::ClearRenderTargetView(
    ID3D11RenderTargetView *pRenderTargetView,  &lt;span class=&quot;co&quot;&gt;// [In]渲染目标视图&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FLOAT  ColorRGBA[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]);                 &lt;span class=&quot;co&quot;&gt;// [In]指定覆盖颜色&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;id3d11devicecontextcleardepthstencilview方法--清空深度模板缓冲区&quot;&gt;ID3D11DeviceContext::ClearDepthStencilView方法--清空深度模板缓冲区&lt;/h3&gt;
&lt;p&gt;同样在进行渲染之前，我们也要清理一遍深度模板缓冲区&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ID3D11DeviceContext::ClearDepthStencilView(
    ID3D11DepthStencilView *pDepthStencilView,  &lt;span class=&quot;co&quot;&gt;// [In]深度模板视图&lt;/span&gt;
    UINT ClearFlags,    &lt;span class=&quot;co&quot;&gt;// [In]D3D11_CLEAR_FLAG枚举&lt;/span&gt;
    FLOAT Depth,        &lt;span class=&quot;co&quot;&gt;// [In]深度&lt;/span&gt;
    UINT8 Stencil);     &lt;span class=&quot;co&quot;&gt;// [In]模板初始值&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;idxgiswapchainpresent方法--前后台缓冲区交换并呈现&quot;&gt;IDXGISwapChain::Present方法--前后台缓冲区交换并呈现&lt;/h3&gt;
&lt;p&gt;完成一切绘制操作后就可以调用该方法了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;HRESULT ID3D11DeviceContext::STDMETHODCALLTYPE Present( 
    UINT SyncInterval,  &lt;span class=&quot;co&quot;&gt;// [In]通常为0&lt;/span&gt;
    UINT Flags);        &lt;span class=&quot;co&quot;&gt;// [In]通常为0&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;GameApp::DrawScene&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GameApp::DrawScene()
{
    assert(md3dImmediateContext);
    assert(mSwapChain);
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; blue[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;] = { &lt;span class=&quot;fl&quot;&gt;0.0f&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.0f&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.0f&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.0f&lt;/span&gt; };  &lt;span class=&quot;co&quot;&gt;// RGBA = (0,0,255,255)&lt;/span&gt;
    md3dImmediateContext-&amp;gt;ClearRenderTargetView(mRenderTargetView.Get(), &lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;*&amp;gt;(&amp;amp;blue));
    md3dImmediateContext-&amp;gt;ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, &lt;span class=&quot;fl&quot;&gt;1.0f&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    HR(mSwapChain-&amp;gt;Present(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终绘制的效果应该如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/424/WEBRESOURCEbe164a92197c3f4036ff7483175bf3cd&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该文章后续视情况可能还会有所修改。&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 14:07:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9069608.html</dc:identifier>
</item>
<item>
<title>rabbit入门教程 - {-）大傻逼</title>
<link>http://www.cnblogs.com/s-b-b/p/9069505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/s-b-b/p/9069505.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;rabbitmq是一个消息代理系统，为应用提供一个通用得消息发布，接受平台，为应用提供非阻塞的消息系统，方便进行异步处理。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;消息的可靠性。持久化消息，消息接受确认，消息重传等可靠机制。&lt;/li&gt;
&lt;li&gt;灵活的路由。交换机可以根据广播，或者根据路由键或匹配符匹配到不同的队列。&lt;/li&gt;
&lt;li&gt;高可用的集群。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;h4 id=&quot;异步处理&quot;&gt;1.异步处理&lt;/h4&gt;
&lt;p&gt;减少用户对不必要的耗时操作的等待，处理结果以异步方式（邮件，消息推送）进行提醒。&lt;/p&gt;
&lt;h4 id=&quot;应用解耦&quot;&gt;2.应用解耦&lt;/h4&gt;
&lt;p&gt;当某个应用发展到一定规模的时候，需要把里面的模块分别拆出来进行解耦，而模块之间的通讯方式是多样的，常见的有rpc，消息队列，http请求。其中消息队列在内部模块通信是更为稳定。&lt;/p&gt;
&lt;h4 id=&quot;流量削峰&quot;&gt;3.流量削峰&lt;/h4&gt;
&lt;p&gt;如果突发遇到大量的数据请求的时候，服务器如果不做队列处理，一下子处理全部的请求，会很容易造成宕机，如果把请求的数据都放入队列里，之后再逐个逐个地进行处理，可以平缓地渡过流量高峰期。&lt;/p&gt;
&lt;h3 id=&quot;工作方式&quot;&gt;工作方式&lt;/h3&gt;
&lt;p&gt;rabbitmq的工作方式如下，生产者（publisher）发送消息到交换机，交换机（exchange）根据自己的类型以及消息的路由键，路由到对应的队列里，队列分发消息到消费者（consumer）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/799055/201805/799055-20180521214105956-1138606548.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;初尝rabbitmq&quot;&gt;初尝rabbitmq&lt;/h2&gt;
&lt;p&gt;现在我们假设有这个场景，客服A需要发送客户的下单信息给库存人员B，客服A有一个订单信息发送器，库存人员B拥有消息接收器。&lt;br/&gt;首先库存人员B建立连接并接受消息，伪代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 建立连接
conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)
ch, _ := conn.Channel()
// 声明队列，不存在则创建，存在则不会进行任何操作
queue, _ := ch.QueueDeclare(&quot;order&quot;)
// 从队列里面获取消息
deliver, _ := ch.Consume(q.Name)
for d:= range deliver {
    // 输出消息主体
    log.Printf(&quot;B Received a message: %s&quot;, d.Body)
    // 返回获取成功标识给队列
    d.Ack(true)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后客服A也建立连接并发送消息，伪代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 建立连接
conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)
ch, _ := conn.Chanenel()
// 声明队列，不存在则创建，存在则不会进行任何操作
queue, _ := ch.QueueDeclare(&quot;order&quot;)
// 发布消息
ch.Publish(
    q.Name, // 队列名字
    amqp.Publishing{
        Body:[]byte(&quot;new order&quot; + product.String()),
    })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是一种简单的直接通过队列进行连接的方法，可能会有人看出来，为什么没有交换机的参与，其实上面的操作其实是通过默认交换机进行消息传递，可以不指定交换机名字直接指定队列名字进行交互。&lt;/p&gt;
&lt;h2 id=&quot;模块介绍&quot;&gt;模块介绍&lt;/h2&gt;
&lt;p&gt;通过上面的简单例子，我们可以更进一步地了解到rabbitmq的工作方式，下面我会更详细地讲解各个模块。&lt;/p&gt;
&lt;h3 id=&quot;消息&quot;&gt;消息&lt;/h3&gt;
&lt;p&gt;消息是通信内容的主体，消息对象有点像http的request，除了可以携带消息内容，还可以带有各种属性，如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ContentType（内容类型）&lt;/li&gt;
&lt;li&gt;ContentEncoding（内容编码）&lt;/li&gt;
&lt;li&gt;RemoteKey（路由键）&lt;/li&gt;
&lt;li&gt;DeliveryMode（ 投递模式，消息是否持久化）&lt;/li&gt;
&lt;li&gt;等等...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有些属性只是约定规范，如ContentType，ContentEncoding，需要程序自己做处理，有些属性rabbitmq会根据值来进行处理，如RemoteKey，交换机会根据消息的RemoteKey和自身的类型来决定投递到哪些队列，DeliveryMode可以决定是否持久化消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#消息投递
ch.Publish(
    &quot;&quot;,     # exchange名字，空为默认交换机
    key,    # routingkey 路由键
    false,  
    false,
    # 消息
    amqp.Publishing{
        DeliveryMode:amqp.Persistent,
        ContentType:&quot;text/plain&quot;,
        Body:[]byte(&quot;hello world&quot;),
    }) &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;队列&quot;&gt;队列&lt;/h3&gt;
&lt;p&gt;队列是存储消息的主体，队列本身所拥有的一些属性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Name 队列名字，不同的队列名字应该保持唯一性&lt;/li&gt;
&lt;li&gt;Durable rabbitmq重启后，队列是否依旧存在，需要注意消息要持久化的要另外设置消息&lt;/li&gt;
&lt;li&gt;exclusive 当前队列只能被一个消费者连接使用，关闭连接后删除队列。&lt;/li&gt;
&lt;li&gt;auto-delete 最后一个消费者退订后删除队列。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在代码里面队列声明，如果队列不存在则新建队列，如果已存在相同名字的队列且属性不同的话则会报错。可以选择让系统自动生成队列，然后返回队列名字。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 队列声明，参数依次为name，Durable，auto-delete，exclusive，no-wait.args
amqp.QueueDeclare(&quot;queuename&quot;, true, false, flase, false, nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费者consumer&quot;&gt;消费者（consumer）&lt;/h3&gt;
&lt;p&gt;消费者用以消费队列里的消息的自定义程序片段，消费者获取队列里的消息有两种方式，一种是拉取（pull）的方式，通过channel.basicget方法，一种是订阅方式，队列推送消息到rabbitmq，这种方式用的最多。&lt;/p&gt;
&lt;h3 id=&quot;消息处理&quot;&gt;消息处理&lt;/h3&gt;
&lt;p&gt;消息处理，消费者端连接队列后，可以得到一个类似于句柄的东西，如果没有消息就会一直阻塞。&lt;br/&gt;消费者在收到消息之后处理的情况可能是成功的，也有可能是失败的，为了确保消息已经成功处理然后队列删除消息，如果失败则进行其他机制，以免消息一直重复在队列里面，或消息因消费者宕机而丢失。&lt;/p&gt;
&lt;h4 id=&quot;消息确认ack&quot;&gt;消息确认（ack）&lt;/h4&gt;
&lt;p&gt;如果消息成功地被消费者处理的话，需要有一个消息确认的机制。&lt;br/&gt;rabbitmq提供两种确认机制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动确认模式，队列将消息发送给消费者之后立即删除消息（basic.deliver或basic.get-ok）&lt;/li&gt;
&lt;li&gt;显式确认模式，待消费者发送接受成功之后删除（basic.ack）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一般而言我们用的更多的是显式确认模式，如果消费者接收到消息没有进行确认之后就宕机了，队列里面的该消息还是会存在的，然后会把消息转发到其他消费者。&lt;/p&gt;
&lt;h4 id=&quot;消息拒绝basic.reject&quot;&gt;消息拒绝（basic.reject）&lt;/h4&gt;
&lt;p&gt;如果消费者对消息的处理出现了一些问题，可以调用rabbitmq的basic.reject来拒绝消息，拒绝消息之后，可以做的是把消息放回到队列里面，或者直接删除消息。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其实如果出现问题的消息，即便是交给其他的消费者，很会很大概率继续出现问题，这时候我们可以把消息放到其他专门处理记录问题的队列里面，交由另外的消费者处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;交换机&quot;&gt;交换机&lt;/h3&gt;
&lt;p&gt;交换机更像是消息的路由层，队列绑定到交换机，然后发布者可以发送的消息都是经过交换机的，然后经由消息的remote key（路由键）路由到交换机所绑定的队列里。&lt;br/&gt;交换机分为4种类型：&lt;/p&gt;
&lt;h4 id=&quot;直连交换机direct&quot;&gt;1.直连交换机（direct）&lt;/h4&gt;
&lt;p&gt;直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）&lt;/li&gt;
&lt;li&gt;当一个携带着路由键为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实初尝rabbitmq的例子里面，看上去没有绑定交换机，实际上也是绑定了直连交换机，只是是一个特殊的预先声明好的，名字为空字符串的交换机，叫默认交换机，每个队列都会自动绑定到默认交换机上。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/799055/201805/799055-20180521213558941-926277519.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;扇形交换机funout&quot;&gt;2.扇形交换机（funout）&lt;/h4&gt;
&lt;p&gt;扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列，而不理会绑定的路由键。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的拷贝分别发送给这所有的N个队列。扇型用来交换机处理消息的&lt;span&gt;广播路由&lt;/span&gt;（broadcast routing）。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/799055/201805/799055-20180521213619439-2063292249.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;主题交换机topic&quot;&gt;3.主题交换机（topic）&lt;/h4&gt;
&lt;p&gt;主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。&lt;br/&gt;主题交换机在我看来就像添加了简单的&lt;span&gt;通配符+字符串&lt;/span&gt;来达到一个路由的规则。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/799055/201805/799055-20180521213637300-42948176.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;头交换机用的不是很多，有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机（headers exchange）就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。&lt;/p&gt;
&lt;h2 id=&quot;扇形路由器实现广播&quot;&gt;扇形路由器实现广播&lt;/h2&gt;
&lt;p&gt;生产者代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)

ch, _ := conn.Channel()

ch.ExchangeDeclare(
    &quot;hello&quot;,
    &quot;fanout&quot;,
    true,
    false,
    false,
    false,
    nil,
    )


ch.Publish(
    &quot;hello&quot;,
    &quot;&quot;,     // 由于是广播，所以可以不填写路由键
    false,
    false,
    amqp.Publishing{
        DeliveryMode:amqp.Persistent,
        Body:[]byte(&quot;hello&quot;+time.Now().String()),
    })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)

ch, _ := conn.Channel()
    
ch.ExchangeDeclare(
        &quot;hello&quot;,  // 交换机名字
        &quot;fanout&quot;, // 交换机类型
        true,     // durable
        false,    // autoDelete
        false,    // internal
        false,    // noWait
        nil,      // args
    )

q, _ := ch.QueueDeclare(
        &quot;&quot;, 
        false,  // durable
        false,  // autoDelete
        true,   // exclusive
        false,  // noWait
        nil,    //
        )

ch.QueueBind(
    q.Name,     // queuename 
    &quot;&quot;,         // remote key，由于是广播，可以不填写路由键
    &quot;hello&quot;,    // exchange name
    false,      // nowait
    nil,
    )

msgs, _ := ch.Consume(q.Name,&quot;&quot;, true, false, false,false,nil)

for msg := range msgs {
    log.Printf(&quot;%s&quot;, msg.Body)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;主题交换机实现路由匹配&quot;&gt;主题交换机实现路由匹配&lt;/h2&gt;
&lt;p&gt;设有如下场景：设计一个日志收集系统，日志有不同的级别，debug，info，warn，error，日志格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;级别.模块名字 如：info.login&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有不同的队列负责收集不同级别的日志，其中有个队列专门收集收集warn和error的数据，设计如下：&lt;br/&gt;生产者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)

    ch, _ := conn.Channel()


    ch.ExchangeDeclare(
        &quot;logs&quot;,
        &quot;topic&quot;,
        true,
        false,
        false,
        false,
        nil,
    )

    ch.Publish(
        &quot;logs&quot;,
        &quot;debug.123&quot;,
        false,
        false,
        amqp.Publishing{
            DeliveryMode:amqp.Persistent,
            Body:[]byte(&quot;hello&quot;),
        },
    )
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    conn, _ := amqp.Dial(&quot;amqp://localhost&quot;)
    ch, _ := conn.Channel()

    ch.ExchangeDeclare(
        &quot;logs&quot;,
        &quot;topic&quot;,
        true,
        false,
        false,
        false,
        nil,
    )

    q, _ := ch.QueueDeclare(
        &quot;log1&quot;,
        true,
        false,
        false,
        false,
        nil,
    )
    
    // 队列绑定的remote key
    keys := []string{&quot;error.*&quot;, &quot;warn.*&quot;}

    for _, key := range keys{
        ch.QueueBind(
            q.Name,
            key,
            &quot;logs&quot;,
            false,
            nil,
        )
    }

    deliver, _ := ch.Consume(
        q.Name,
        &quot;&quot;,
        false,
        false,
        false,
        false,
        nil,
    )

    for d:= range deliver {
        fmt.Println(string(d.Body))
        d.Ack(true)
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 21 May 2018 13:51:00 +0000</pubDate>
<dc:creator>{-）大傻逼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/s-b-b/p/9069505.html</dc:identifier>
</item>
<item>
<title>Tomcat9使用免费的Https证书加密网站 - letcafe</title>
<link>http://www.cnblogs.com/gdyblog/p/tomcatAddHttps.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdyblog/p/tomcatAddHttps.html</guid>
<description>&lt;p&gt;Apache Tomcat是一款优秀的Java Web容器，对于各个站长来说，可以很方便的使用Tomcat将自己的网站博客放在公网的服务器上，分享自己的心得以及个人博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521191147646-320664046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么在公网中的访问，没有被第三方公认可信的机构加密时，会默认使用Http协议，以明文将自己的网站在公网上传输。这对于大部分领域都没关系，但是对于某些敏感的数据，甚至机密需要保护的数据，例如：银行卡号、银行密码、手机验证码之类的信息，一旦被别有用心的人在中途使用抓包工具拦截，那么将会导致不可设想的后果。&lt;/p&gt;
&lt;p&gt;那么网站需要使用SSL（Secure Sockets Layer）,顾名思义，安全的套接字层。通过这层提供的保障，在SSL上面运行的应用都可以安全传输。&lt;/p&gt;
&lt;p&gt;本文第二部分介绍如果获取免费的证书，第三部分介绍如何用已有的证书在Tomcat中配置，使得Https能够运作，最后一部分介绍，如何在浏览器中输入地址，自动由Http转发到Https上，有需要的读者可以根据需要跳过相应部分。&lt;/p&gt;

&lt;p&gt;对于Https的证书，相当于是在传输过程中加入了第三方的验证机制，简称CA（Certificate Authority），确保传输的安全性。对于大部分证书，签发是需要一定的费用的，本段落主要介绍免费的证书提供方：FreeSSL&lt;/p&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;https://freessl.org/&quot; target=&quot;_blank&quot;&gt;https://freessl.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具备SSL免费证书申请的前提是，先得有一个域名，没有域名的用户可以先移步&lt;a href=&quot;https://wanwang.aliyun.com/&quot; target=&quot;_blank&quot;&gt;阿里云&lt;/a&gt;或者&lt;a href=&quot;https://dnspod.cloud.tencent.com/&quot; target=&quot;_blank&quot;&gt;腾讯云&lt;/a&gt;等域名交易网站购买域名，本例中，我使用自己的已有域名:&lt;strong&gt;letcafe.cn&lt;/strong&gt;作为样例&lt;/p&gt;
&lt;p&gt;下面介绍如何获取免费域名Https证书&lt;/p&gt;
&lt;p&gt;步骤1、输入你所购买的域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521192957482-787049442.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤2、选项默认，如果没特殊需求按步骤填入邮箱后创建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521193254921-2013825558.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤3、创建完成后，等待几秒后，将会生成一个域名解析DNS的验证环节。对此，需要您去域名供应商网站添加解析，例如，我是用的是阿里云，我在：阿里云-&amp;gt;控制台-&amp;gt;域名与网站，找到对应的域名添加解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521193847728-1103477745.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521194029103-767781521.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析添加完成后，等待将近一分钟，可以回到FreeSSL验证DNS，单击“点击验证”按钮后，将会返回你的CA证书以及公钥&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521194249496-537983741.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击证书下载，即可获得带有full_chain.pem的文件以及叫private.key的私钥，到此，免费的证书已经申请完毕，下一步将Tomcat的对应内容加入HTTPS&lt;/p&gt;

&lt;h2&gt;3.1 生成jks文件&lt;/h2&gt;
&lt;p&gt;由于Tomcat证书不支持直接使用pem + 私钥的方式，因此，需要多一步使用Openssl将full_chain.pem+private.key转换为jks的步骤，首先将full_chain.pem和private.key上传至服务器的任何目录，我存放的目录是：/root/apache-tomcat-ssl，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521195425979-1992580599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后使用如下命令，在当前目录下生成一个名为freeSSL.jks的文件，如果使用不了如下命令，尝试考虑升级Openssl到最新版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
openssl pkcs12 -export -out /root/apache-tomcat-ssl/freeSSL.jks -in ./full_chain.pem -inkey ./private.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521200017569-2054362790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令过程中会要求输入keystore密码，两次确保一致，并记住该密码，为了演示，我输入的密码为：123456（产品环境下，&lt;span&gt;&lt;strong&gt;请确保安全换成其他复杂密码&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;h2&gt;3.2 配置server.xml&lt;/h2&gt;
&lt;p&gt;编辑Tomcat目录下的server.xml文件，文件路径位于：$CATALINA_HOME/conf/server.xml，取决于你的Tomcat安装在何处。&lt;/p&gt;
&lt;p&gt;在Connector中，添加如下Connector：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521201017482-1433315847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码附上：&lt;/p&gt;
&lt;p&gt;这一步中的&lt;span&gt;keystoreFile&lt;span&gt;填写之前使用Openssl生成的jks文件，&lt;span&gt;keystorePass&lt;/span&gt;使用之前输入的密码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;Connector&lt;br/&gt;protocol&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.apache.coyote.http11.Http11NioProtocol&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  port&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; maxThreads=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  scheme&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; secure=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; SSLEnabled=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  keystoreFile&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/root/apache-tomcat-ssl/freeSSL.jks&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; keystorePass=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  clientAuth&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sslProtocol=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TLS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，为了将Tomcat监听80端口，并将HTTPS请求转发到443端口（443为SSL默认端口），还需要将server.xml文件中原有的Connector修改为如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521201246757-1707553539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将port=&quot;8080&quot;改为port=&quot;80&quot;,redirectPort=&quot;8443&quot;改为redirectPort=&quot;443&quot;&lt;/p&gt;
&lt;p&gt;修改好，保存退出，重启Tomcat,在公网上访问输入地址:letcafe.cn，发现虽然：&lt;/p&gt;
&lt;p&gt;通过输入https://letcafe.cn。实现了网站上的小锁显示了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521202244172-1524874589.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是输入letcafe.cn后，却失去了Https的加密：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521202451001-45350122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，不能用户每次都去手敲HTTPS对不对，此时的Tomcat是会对默认继续使用HTTP，所以如果需要将该域名下的所有访问都走HTTPS加密的话，需要将所有对Tomcat的THHP访问都默认转发给HTTPS的访问，实现不管输入letcafe.cn还是https://letcafe.cn都访问的是HTTPS（如果没有此需求，可不需要下一步）&lt;/p&gt;

&lt;p&gt;这一步非常简单，编辑$CATALINA_HOME/conf/web.xml文件，在其中添加如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521202924136-1600428065.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;!-- 增加所有网址自动跳转https --&amp;gt;
  &amp;lt;security-constraint&amp;gt;
    &amp;lt;web-resource-collection&amp;gt;
       &amp;lt;web-resource-name &amp;gt;SSL&amp;lt;/web-resource-name&amp;gt;
         &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
       &amp;lt;/web-resource-collection&amp;gt;
     &amp;lt;user-data-constraint&amp;gt;
       &amp;lt;transport-guarantee&amp;gt;CONFIDENTIAL&amp;lt;/transport-guarantee&amp;gt;
     &amp;lt;/user-data-constraint&amp;gt;
  &amp;lt;/security-constraint&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存后重启Tomcat，即可完成目标&lt;/p&gt;

&lt;p&gt;在浏览器中输入：letcafe.cn或者https://letcafe.cn或者http://letcafe.cn都可以实现访问定向到https://letcafe.cn中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521203516512-453788369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果访问不了确认如下问题是否解决：&lt;/p&gt;
&lt;p&gt;1.防火墙是否开放端口，CentOS中是firewalld，是否添加了443和80端口&lt;/p&gt;
&lt;p&gt;解决方案：添加端口并重载防火墙规则命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; firewall-cmd --zone=public --add-port=&lt;span&gt;80&lt;/span&gt;/tcp --&lt;span&gt;permanent
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; firewall-cmd --zone=public --add-port=&lt;span&gt;443&lt;/span&gt;/tcp --permanent&lt;br/&gt;3 firewall-cmd --reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看服务器已对外开放端口命令，确认是否已放通80与443端口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
firewall-cmd --zone=public --list-ports
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.云服务提供商的拦截规则时候设置开放端口，例如：&lt;/p&gt;
&lt;p&gt;阿里云-&amp;gt;控制台-&amp;gt;云服务器ECS-&amp;gt;你的服务器-&amp;gt;更多-&amp;gt;安全组配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201805/946524-20180521204037164-1979163811.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置规则中，加入80和443端口的开放，具体配置参照阿里云文档，腾讯云等其他服务商也类似，需要在服务器端先开放云服务商的拦截配置。&lt;/p&gt;
&lt;p&gt;配置HTTPS踩了一些坑，希望能分享帮到他人，如有疑问，欢迎留言！&lt;/p&gt;

</description>
<pubDate>Mon, 21 May 2018 12:50:00 +0000</pubDate>
<dc:creator>letcafe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdyblog/p/tomcatAddHttps.html</dc:identifier>
</item>
<item>
<title>C++雾中风景9:emplace_back与可变长模板 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/9068980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/9068980.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;C++11的版本在vector容器添加了&lt;strong&gt;emplace_back方法&lt;/strong&gt;，相对于原先的push_back方法能够在一定程度上提升vector容器的表现性能。所以我们从STL源码角度来切入，看看这两种方法有什么样的区别，新引进的方法又有什么可学习参考之处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;emplace_back的用法&quot;&gt;1.emplace_back的用法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;emplace_back方法&lt;/strong&gt;最大的改进就在与可以利用类本身的构造函数直接在内存之中构建对象，而不需要调用类的&lt;strong&gt;拷贝构造函数&lt;/strong&gt;与&lt;strong&gt;移动构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个栗子，假设如下定义了一个时间类&lt;strong&gt;time&lt;/strong&gt;，该类同时定义了&lt;strong&gt;拷贝构造函数&lt;/strong&gt;与&lt;strong&gt;移动构造函数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class time {
private:
    int hour;
    int minute;
    int second;

public:
    time(int h, int m, int s) :hour(h), minute(m), second(s) {
    }

    time(const time&amp;amp; t) :hour(t.hour), minute(t.minute), second(t.second) {
        cout &amp;lt;&amp;lt; &quot;copy&quot; &amp;lt;&amp;lt; endl;
    }

    time(const time&amp;amp;&amp;amp; t) noexcept:hour(t.hour),minute(t.minute),second(t.second) {
        cout &amp;lt;&amp;lt; &quot;move&quot; &amp;lt;&amp;lt; endl;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;main&lt;/strong&gt;方法之中执行下面的代码逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{
    vector&amp;lt;time&amp;gt; tlist;
    time t(1, 2, 3);
    tlist.emplace_back(t);
    tlist.emplace_back(2, 3, 4);  //直接调用了time的构造函数在vector的内存之中建立起新的对象

    getchar();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  copy                    
  move （这次拷贝构造函数的调用是因为vector本身的扩容，也就是移动之前的已经容纳的time对象）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述代码我们看到time对象可以直接利用&lt;strong&gt;emplace_back&lt;/strong&gt;方法在&lt;strong&gt;vector&lt;/strong&gt;上构造对象，通过这样的方式来减少不必要的内存操作。（&lt;strong&gt;省去了拷贝构造的环节&lt;/strong&gt;）。同样的在&lt;strong&gt;main&lt;/strong&gt;之中执行下面的代码逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{
    vector&amp;lt;time&amp;gt; tlist;
    time t(1, 2, 3);
    tlist.emplace_back(move(t)); //调用move函数使time对象成为右值，可以利用移动构造函数来拷贝对象
    tlist.emplace_back(2, 3, 4);  //直接调用了time的构造函数在vector的内存之中建立起新的对象

    getchar();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  move                   
  move （这次拷贝构造函数的调用是因为vector本身的扩容，也就是移动之前的已经容纳的time对象）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这样的方式也减少不必要的内存操作。（&lt;strong&gt;省去了移动构造的环节&lt;/strong&gt;）。所以这就是为什么在C++11之后提倡大家&lt;strong&gt;使用emplace_back来代替旧代码之中的push_back函数。&lt;/strong&gt;如下面的代码所示，在push_back底层也是调用了emplace_back来实现对应的操作流程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void push_back(const _Ty&amp;amp; _Val) {   
       emplace_back(_Val);
}

void push_back(_Ty&amp;amp;&amp;amp; _Val) {    
       emplace_back(_STD move(_Val));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;emplace_back的实现&quot;&gt;2.emplace_back的实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;源码面前，了无秘密&lt;/strong&gt;，接下来跟随笔者直接来看看emplace_back的源代码，来引出我们今天的主题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public:
    template&amp;lt;class... _Valty&amp;gt;
        decltype(auto) emplace_back(_Valty&amp;amp;&amp;amp;... _Val)
        {   // insert by perfectly forwarding into element at end, provide strong guarantee
        if (_Has_unused_capacity())
            {
            _Emplace_back_with_unused_capacity(_STD forward&amp;lt;_Valty&amp;gt;(_Val)...);
            }
        else
            {   // reallocate
            const size_type _Oldsize = size();

            if (_Oldsize == max_size())
                {
                _Xlength();
                }

            const size_type _Newsize = _Oldsize + 1;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);
            bool _Emplaced = false;
            const pointer _Newvec = this-&amp;gt;_Getal().allocate(_Newcapacity);
            _Alty&amp;amp; _Al = this-&amp;gt;_Getal();

            _TRY_BEGIN
            _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Oldsize), _STD forward&amp;lt;_Valty&amp;gt;(_Val)...);
            _Emplaced = true;
            _Umove_if_noexcept(this-&amp;gt;_Myfirst(), this-&amp;gt;_Mylast(), _Newvec);
            _CATCH_ALL
            if (_Emplaced)
                {
                _Alty_traits::destroy(_Al, _Unfancy(_Newvec + _Oldsize));
                }

            _Al.deallocate(_Newvec, _Newcapacity);
            _RERAISE;
            _CATCH_END

            _Change_array(_Newvec, _Newsize, _Newcapacity);
            }

#if _HAS_CXX17
        return (this-&amp;gt;_Mylast()[-1]);
#endif /* _HAS_CXX17 */
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述代码可以看到，emplace_back的流程逻辑很简单。先检查vector的容量，不够的话就扩容，之后便通过**_Alty_traits::construct&lt;strong&gt;来创建对象。而最终利用强制类似装换的指针来指向容器类之中对应类的构造函数，并且利用&lt;/strong&gt;可变长模板**将构造函数所需要的内容传递过去构造新的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;class _Objty,
        class... _Types&amp;gt;
        static void construct(_Alloc&amp;amp;, _Objty * const _Ptr, _Types&amp;amp;&amp;amp;... _Args)
        {   // construct _Objty(_Types...) at _Ptr
        ::new (const_cast&amp;lt;void *&amp;gt;(static_cast&amp;lt;const volatile void *&amp;gt;(_Ptr)))
            _Objty(_STD forward&amp;lt;_Types&amp;gt;(_Args)...);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emplace_back这里最为巧妙的部分就是利用&lt;strong&gt;可变长模板&lt;/strong&gt;实现了，任意传参的对象构造。可变长模板是C++11新引进的特性，接下来我们来详细看看可变长模板是如何来使用，来实现任意长度的参数呢?&lt;/p&gt;
&lt;h4 id=&quot;可变长模板与函数式编程&quot;&gt;3.可变长模板与函数式编程&lt;/h4&gt;
&lt;p&gt;首先，我们先看看，可变长模板的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    template &amp;lt;class... T&amp;gt;
    void f(T... args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过template来声明参数包args，这个参数包中可以包含0到任意个参数，并且作为函数参数调用。之后我们便可以在函数之中将参数包展开成一个一个独立的参数。&lt;/p&gt;
&lt;p&gt;假设我们有如下需求，需要定义一个&lt;strong&gt;max_num函数&lt;/strong&gt;来求出一组任意参数数字的最大值，在C++11之前的版本或许需要这样去定义这个函数，也就是说我们需要一个参数来指定对应参数的个数，并且这个过程之中存在参数的类型不一致的潜在风险，并不能在编译期进行反馈（&lt;strong&gt;不能在编译期进行对于动态语言来说根本不是什么大不了的问题，囧rz&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int max_num(int count, ...)
{
    va_list ap;
    va_start(ap, count);

    int ans = va_arg(ap, int);
    for (int i = 1; i &amp;lt; count; ++i)
    {
        int num = va_arg(ap, int);
        ans = max(ans, num);
    }

    va_end(ap);

    return ans;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而利用可变长模板，我们可以很优雅地通过以下的代码来实现一个这样的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template&amp;lt;typename t1,typename ...t2&amp;gt; t1 max_num(t1 num, t2 ...args) {
    auto n = max_num(args...);
    return n &amp;gt; num ? n : num;
}
template&amp;lt;typename t1&amp;gt; t1 max_num(t1 num) {
    return num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过不断递归的方式，提取可变长模板参数之中的首个元素，并且设置递归的终止点的方式来依次处理各个元素。&lt;/strong&gt;这种处理函数的方式本质上就是在通过递归的方式处理列表，这种编程思路在函数式编程语言之中十分常见,在C++之中看到这样的用法，也让笔者作为C++的入门选手感到很新奇。笔者曾经接触过Scala与Erlang语言之中大量利用了这种写法，但是多层递归导致的必然是栈调用的开销变大，&lt;strong&gt;利用尾递归的方式来优化这样的写法，才能减少非必要的函数调用开销。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;4.小结&lt;/h4&gt;
&lt;p&gt;由emplace_back引申出来不少对C++11新特性的探索，笔者也仅仅做一些抛砖引玉的工作。&lt;strong&gt;作为程序员，希望大家能够坚持不断动态更新对语言的学习与探索来凝练与高效率的Coding，这也是笔者坚持更新该系列文章的初衷。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 May 2018 11:49:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/9068980.html</dc:identifier>
</item>
</channel>
</rss>