<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>caffe源码 卷积层 - ERKE</title>
<link>http://www.cnblogs.com/ERKE/p/7630295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ERKE/p/7630295.html</guid>
<description>&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;input：&lt;span class=&quot;Apple-converted-space&quot;&gt; 1 * ( c * k * k ) * ( H * W )&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;weight：&lt;span class=&quot;Apple-converted-space&quot;&gt; m * (c * k * k) *** bias：** m * 1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output：&lt;span class=&quot;Apple-converted-space&quot;&gt; 1 * m * H * W&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;则公式（即前向传播）为：output = input * weight + bias * 全1矩阵 ( 1 * H * W )&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;反向传播和全连接层一样（详细参考全连接层的推导）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;梯度传递：bottom_diff = top_diff * weight&lt;/li&gt;
&lt;li&gt;对w求导：weight_diff = top_diff * bottom + weight_diff(累积梯度)&lt;/li&gt;
&lt;li&gt;对b求导：bias_diff = top_diff + bias_diff(累积梯度)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
</description>
<pubDate>Thu, 05 Oct 2017 15:58:00 +0000</pubDate>
<dc:creator>ERKE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ERKE/p/7630295.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法总结-冒泡排序、选择排序、插入排序算法分析 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/7615347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/7615347.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;前言：&lt;/strong&gt;排序在算法中的地位自然不必多说，在许多工作中都用到了排序，就像学生成绩统计名次、商城商品销量排名、新闻的搜索热度排名等等。也正因为排序的应用范围如此之广，引起了许多人深入研究它的兴趣，直至今天，排序算法已经出现了很多种。本篇博文主要介绍常见的八种排序算法，总得来说，不同的排序算法在不同的场景下都有着自己独特的优点，例如一下简单的冒泡排序、选择排序、插入排序不仅思路简单，有利于我们理解，而且在小规模的数据量的处理中并不逊色。接下来我们就一一分析一下各算法的优缺点以及时间复杂度。&lt;/p&gt;&lt;p&gt;　　本篇博文的所有代码已上传 github ，对应工程的 exercise 模块下的 cn.codingblock.sort 包，下载地址：&lt;a href=&quot;https://github.com/lgliuwei/DataStructureStudy&quot; target=&quot;_blank&quot;&gt;https://github.com/lgliuwei/DataStructureStudy&lt;/a&gt;，项目工程为 IntelliJ IDEA 环境，童鞋不妨下载下来，参照着代码看博文岂不是效果更好~（额~由于本工程为练习工程，结构比较随意而且还有重复代码，参考时还请多找找:D）&lt;/p&gt;&lt;p&gt;　　冒泡排序非常简单，也很易于理解，其逻辑思路就像水里面冒气泡一样，越往上气泡越大，也因此而得名冒泡排序，其具体规则如下：&lt;/p&gt;&lt;p&gt;　　1、从一组的数据的起始位置开始依次向后比较相邻两个数，&lt;/p&gt;&lt;p&gt;　　此时，这组数的最后一个数一定是最大的了，然后进行下一轮如此比较到倒数第二个数，再下一轮比较到倒数第三个，如此循环，直到有一轮比较到第二个数结束，最终这一组数就是有序的了。&lt;/p&gt;&lt;div readability=&quot;369&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
排序前:23, 52, 81, 69, 78, 32, 67, 70, 36, 73, 
比较 23 , 52: 不交换
比较 52 , 81: 不交换
比较 81 , 69: 交换: 
23, 52, [69], [81], 78, 32, 67, 70, 36, 73, 
比较 81 , 78: 交换: 
23, 52, 69, [78], [81], 32, 67, 70, 36, 73, 
比较 81 , 32: 交换: 
23, 52, 69, 78, [32], [81], 67, 70, 36, 73, 
比较 81 , 67: 交换: 
23, 52, 69, 78, 32, [67], [81], 70, 36, 73, 
比较 81 , 70: 交换: 
23, 52, 69, 78, 32, 67, [70], [81], 36, 73, 
比较 81 , 36: 交换: 
23, 52, 69, 78, 32, 67, 70, [36], [81], 73, 
比较 81 , 73: 交换: 
23, 52, 69, 78, 32, 67, 70, 36, [73], [81], 
&amp;gt;&amp;gt;第1趟冒泡:23, 52, 69, 78, 32, 67, 70, 36, 73, 81, 
比较 23 , 52: 不交换
比较 52 , 69: 不交换
比较 69 , 78: 不交换
比较 78 , 32: 交换: 
23, 52, 69, [32], [78], 67, 70, 36, 73, 81, 
比较 78 , 67: 交换: 
23, 52, 69, 32, [67], [78], 70, 36, 73, 81, 
比较 78 , 70: 交换: 
23, 52, 69, 32, 67, [70], [78], 36, 73, 81, 
比较 78 , 36: 交换: 
23, 52, 69, 32, 67, 70, [36], [78], 73, 81, 
比较 78 , 73: 交换: 
23, 52, 69, 32, 67, 70, 36, [73], [78], 81, 
&amp;gt;&amp;gt;第2趟冒泡:23, 52, 69, 32, 67, 70, 36, 73, 78, 81, 
比较 23 , 52: 不交换
比较 52 , 69: 不交换
比较 69 , 32: 交换: 
23, 52, [32], [69], 67, 70, 36, 73, 78, 81, 
比较 69 , 67: 交换: 
23, 52, 32, [67], [69], 70, 36, 73, 78, 81, 
比较 69 , 70: 不交换
比较 70 , 36: 交换: 
23, 52, 32, 67, 69, [36], [70], 73, 78, 81, 
比较 70 , 73: 不交换
&amp;gt;&amp;gt;第3趟冒泡:23, 52, 32, 67, 69, 36, 70, 73, 78, 81, 
比较 23 , 52: 不交换
比较 52 , 32: 交换: 
23, [32], [52], 67, 69, 36, 70, 73, 78, 81, 
比较 52 , 67: 不交换
比较 67 , 69: 不交换
比较 69 , 36: 交换: 
23, 32, 52, 67, [36], [69], 70, 73, 78, 81, 
比较 69 , 70: 不交换
&amp;gt;&amp;gt;第4趟冒泡:23, 32, 52, 67, 36, 69, 70, 73, 78, 81, 
比较 23 , 32: 不交换
比较 32 , 52: 不交换
比较 52 , 67: 不交换
比较 67 , 36: 交换: 
23, 32, 52, [36], [67], 69, 70, 73, 78, 81, 
比较 67 , 69: 不交换
&amp;gt;&amp;gt;第5趟冒泡:23, 32, 52, 36, 67, 69, 70, 73, 78, 81, 
比较 23 , 32: 不交换
比较 32 , 52: 不交换
比较 52 , 36: 交换: 
23, 32, [36], [52], 67, 69, 70, 73, 78, 81, 
比较 52 , 67: 不交换
&amp;gt;&amp;gt;第6趟冒泡:23, 32, 36, 52, 67, 69, 70, 73, 78, 81, 
比较 23 , 32: 不交换
比较 32 , 36: 不交换
比较 36 , 52: 不交换
&amp;gt;&amp;gt;第7趟冒泡:23, 32, 36, 52, 67, 69, 70, 73, 78, 81, 
比较 23 , 32: 不交换
比较 32 , 36: 不交换
&amp;gt;&amp;gt;第8趟冒泡:23, 32, 36, 52, 67, 69, 70, 73, 78, 81, 
排序后:23, 32, 36, 52, 67, 69, 70, 73, 78, 81,  　　
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;　　通过分析我们可以得出，如果对 N 个数据项进行排序，一般情况下第一趟排序比较了 N-1 次，第二趟排序比较了 N-2 次，依次类推。所以冒泡排序对N个数据项排序时需要比较的次数为：&lt;/p&gt;&lt;p&gt;　　(N-1)+(N-2)+(N-3)+....+ = N*(N-1)/2 方便起见，近似看做比较了 (N^2)/2 次数。&lt;/p&gt;&lt;p&gt;　　选择排序是在冒泡排序的基础上做了一些改进，虽然比较次数仍然是O(n^2)，但它将必要的交换次数从O(n^2)将到了O(n)次，其排序规则如下：&lt;/p&gt;&lt;p&gt;　　2、从1下标开始与标记下标的值比较，如果小于标记下标的值则更新将标记赋值为1下标，依次往后类推直到最后遍历完数组，最后将0下标与最小标记下标的值交换位置。&lt;/p&gt;&lt;p&gt;　　3、然后再从数组1小标开始比较为最小，类比第二步最终交换1下标与最小标记下标的位置。依次类推。。。&lt;/p&gt;&lt;p&gt;　　相比冒泡而言，选择排序虽然大大减少了交换次数，但是也比较了和冒泡相同的次数，所以其时间复杂度也为：O(N^2)。&lt;/p&gt;&lt;p&gt;　　插入排序是根据有序插入的思想来的，可以对照上篇博文中的有序插入来理解插入排序，其大概规则如下：&lt;/p&gt;&lt;p&gt;　　1、最数组的1下标开始赋值给临时变量，看成待插入元素，&lt;/p&gt;&lt;p&gt;　　2、从数组的1下标向前遍历，凡是大于临时变量的元素均后移一位，直到遇到不大于临时变量的值时将临时变量插入到它后一位。&lt;/p&gt;&lt;p&gt;　　3、然后在从数组的2下标开始赋值给临时变量，并从2下标向前遍历依照第二步遇到不大于临时变量时将临时变量插入到它后一位，依次类推...&lt;/p&gt;&lt;p&gt;　　对于随机数据，插入排序速度是冒泡排序的二倍，比选择排序也要快一点，而对于基本有序的数据来说插入排序表现则要出色的多，因为基本有序的数据排序时，while 循环的条件大部分情况下都不成立，这样基本就相当于只执行了外层的一层循环，某些理想情况下插入排序的时间复杂度可以达到 O(N)，但通常情况下，插入平均时间复杂度为：O(N^2)。&lt;/p&gt;&lt;p&gt;　　除了上面介绍的三种简单排序之外，还有归并排序、希尔排序、快速排序、基数排序、堆排序等等，后面这几种都是高级排序，稍微复杂一些，而且用到了递归、树等知识，所以这些排序将会在以后的博文中介绍，本篇中的三种排序对比如下：&lt;/p&gt;</description>
<pubDate>Thu, 05 Oct 2017 15:37:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/7615347.html</dc:identifier>
</item>
<item>
<title>简单并查集归纳 - sword_magic</title>
<link>http://www.cnblogs.com/sword-magical-blog/p/7630263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sword-magical-blog/p/7630263.html</guid>
<description>&lt;p&gt;并查集就是一种一边查找一边并集的数据结构，简单的并查集经常应用于朋友圈等题目，即：x和y是朋友，y和z是朋友，则x和z是朋友，下面给出一组数据表示xx和yy是朋友，最后问一共有多少个朋友圈。这类问题一般用并查集解决比较快。&lt;br/&gt;下面明确并查集做的事情：&lt;br/&gt;1.查集，即查找某个元素是否包含在一个集合里面&lt;br/&gt;2.并集，即将两个集合合并到一块&lt;br/&gt;知道并查集要做的事后，实现它就比较简单了，数据结构书上教我们的是用树的方法来实现并查集，即用一个数组来模拟树，然后利用树的特性来实现，但是那个一下子会有点难以理解，所以我们一开始可以用java自带的集合类来模拟实现，帮助理解。&lt;br/&gt;下面是用java集合来实现并查集的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; javaSet_union_find_set {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Scanner in = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(System.in));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         n =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化，为每个人单独建立一个集合&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Set&amp;lt;Integer&amp;gt;set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Integer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            set.add(i);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            list.add(set);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;m;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; y =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            union(x,y);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;list.size();i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             System.out.println(&quot;集合&quot;+i+&quot;:&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             System.out.print(&quot;( &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number:list.get(i)){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 System.out.print(number+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             System.out.print(&quot;)\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        System.out.println(list.size());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查集操作，返回一个集合，即元素所在的集合&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Set&amp;lt;Integer&amp;gt; find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Set set:list){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(set.contains(x)){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; set;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并集操作，将两个元素所在的集合合并&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; union(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         Set&amp;lt;Integer&amp;gt;set1 =&lt;span&gt; find(a);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         Set&amp;lt;Integer&amp;gt;set2 =&lt;span&gt; find(b);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当两个集合不相等的时候，合并他们&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(set1!=&lt;span&gt;set2){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            list.remove(set1);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            list.remove(set2);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            set1.addAll(set2);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            list.add(set1);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所用到的思想就是简单并查集的思想，下面我们假设一组数据来具体说明，&lt;br/&gt;测试数据：&lt;br/&gt;6 4&lt;br/&gt;1 2&lt;br/&gt;1 3&lt;br/&gt;1 4&lt;br/&gt;5 6&lt;br/&gt;第一行第一个数为n，即一共有多少个人，第二个数为m，即以下给出m对关系，接着m行，每行两个数，表示第x个人和第y个人是朋友关系&lt;br/&gt;答案：&lt;br/&gt;2&lt;br/&gt;最后应该是，1,2,3,4是一组朋友关系，5,6是一组朋友关系，故一共有两个朋友圈&lt;br/&gt;用并查集来解决这个问题，就是要运用集合的特性，即两个集合有并集操作。&lt;br/&gt;故，我们一开始给每一个人创建一个集合，即每个人都是单独的一个集合，下面给出初始关系，用（）表示一个集合。&lt;br/&gt;初始关系为：(1),(2),(3),(4),(5),(6)&lt;br/&gt;对m行数据进行处理：&lt;br/&gt;1和2是朋友，那么包含1的集合和包含2的集合合并，则现在关系为：&lt;br/&gt;(1,2),(3),(4),(5),(6)&lt;br/&gt;1和3是朋友，并集后：&lt;br/&gt;(1,2,3),(4),(5),(6)&lt;br/&gt;1和4是朋友,并集后：&lt;br/&gt;(1,2,3,4),(5),(6)&lt;br/&gt;5和6是朋友，并集后:&lt;br/&gt;(1,2,3,4),(5,6)&lt;br/&gt;这就是完整的一次集合操作，最后数组list的长度即为朋友圈的个数&lt;/p&gt;
&lt;p&gt;上面用java的集合类Set模拟了一下并查集的具体操作，每次查集的时间复杂度为数组的长度即O(N)，每次并集的复杂度为原本java集合类并集的复杂度，有m次查询，粗略计算时间复杂度为O(mn),即O(N),也算是线性复杂度吧。&lt;br/&gt;接下来是传统做法，用数组模拟树来实现，用数组模拟树实现并查集如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;一开始每个人都是独立的集合
(&lt;/span&gt;1),(2),(3),(4),(5),(6&lt;span&gt;)
1和2是朋友，并集后:
(&lt;/span&gt;1),(3),(4),(5),(6&lt;span&gt;)
 &lt;/span&gt;|&lt;span&gt;
(&lt;/span&gt;2&lt;span&gt;)
1和3是朋友，并集后：
(&lt;/span&gt;1)  ,(4),(5),(6&lt;span&gt;)
 &lt;/span&gt;|&lt;span&gt; \
(&lt;/span&gt;2) (3&lt;span&gt;)
1和4是朋友，并集后：
  (&lt;/span&gt;1) ,(5),(6&lt;span&gt;)
 &lt;/span&gt;/ |&lt;span&gt; \
(&lt;/span&gt;4)(2)(3&lt;span&gt;)
5和6是朋友，并集后：
  (&lt;/span&gt;1) ,    (5&lt;span&gt;)
 &lt;/span&gt;/ | \      |&lt;span&gt;
(&lt;/span&gt;4)(2)(3)  (6)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;上面只是模拟了并查集操作，具体的指向为具体的程序的启发函数决定。&lt;br/&gt;使用数组模拟树的并查集有以下几点需要注意：&lt;br/&gt;1.路径压缩操作，在并集操作中很可能出现下面这个情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    (1)       (5&lt;span&gt;)
     &lt;/span&gt;|         |&lt;span&gt;
    (&lt;/span&gt;2)       (6&lt;span&gt;)
     &lt;/span&gt;|&lt;span&gt;
    (&lt;/span&gt;3&lt;span&gt;)
     &lt;/span&gt;|&lt;span&gt;
    (&lt;/span&gt;4)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;当出现这种树的时候，进行查集操作的时候会额外消耗更多的查询时间。&lt;br/&gt;所以这时要运用路径压缩的方法，即每次进行查询操作的时候都进行路径压缩，即查询子节点的时候，都将子节点指向根节点&lt;br/&gt;2.并集操作中怎么合并两个集合，应该根据什么来进行合并&lt;br/&gt;这里有两个启发函数可以选择：&lt;br/&gt;1.根据节点数量进行合并，即将节点少的树结合到节点数量多的树中&lt;br/&gt;2.根据树的高度进行合并，即将高度小的树合并到高度高的树&lt;br/&gt;下面两个启发函数分别举例，先是使用启发函数1+路径压缩的做法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; union_find_set {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点数组，father[x]=y表示x的父节点为y
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果father[x]小于0，则说明x是一个根节点，此时father[x]的绝对值是
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这颗树的节点数量&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] father;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Scanner in = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(System.in));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         n =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         father = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化父节点数组&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             father[i] = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;m;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; y =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            union(x,y);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             System.out.println(&quot;find(&quot;+i+&quot;):&quot;+&lt;span&gt;find(i));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查集操作，查找x元素所属的集合的根节点，同时进行路径压缩操作&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; root =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(root&amp;gt;=0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             root =&lt;span&gt; father[root];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时已找到根节点为root
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径压缩&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(x!=&lt;span&gt;root){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             x = father[x];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x继续往上一个父节点追溯，直到根节点&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             father[temp] = root;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径压缩，把所有子节点都直接指向根节点&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并集操作，将两个集合合并,将x元素所属的集合和y元素所属的集合合并&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; union(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; fx =&lt;span&gt; find(x);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; fy =&lt;span&gt; find(y);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;temp的绝对值为两棵树的节点数量总和&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; temp = fx +&lt;span&gt; fy;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明x元素所属的集合节点比y元素所属的集合少
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么将节点少的集合合并到节点多的集合上&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(fx&amp;gt;&lt;span&gt;fy){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             father[x] =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             father[y] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             father[x] =&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             father[y] =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用启发函数1的做法，那么模拟树的数组有一点要注意的就是，为负数的时候表示这是一个根节点，并且此负数的相反数为该棵树的节点总数&lt;br/&gt;一下是使用启发函数2的做法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用启发函数2的做法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; union_find_set_another {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] father;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录每个节点的父节点，father[x]=y表示为x元素的父节点为y元素&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] rank;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录每棵树的高度，rank[x]=h表示为x元素所含集合的深度为h&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Scanner in = &lt;span&gt;new&lt;/span&gt; Scanner(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(System.in));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         n =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         father = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         rank = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化father数组
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;令每个节点一开始都指向自己&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             father[i] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化rank数组&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             rank[i] = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;m;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; y =&lt;span&gt; in.nextInt();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            union(x,y);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             System.out.println(&quot;find(&quot;+i+&quot;):&quot;+&lt;span&gt;find(i));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(x!=&lt;span&gt;father[x]){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; find(father[x]);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; union(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; fx =&lt;span&gt; find(x);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; fy =&lt;span&gt; find(y);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(fx==&lt;span&gt;fy){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明两个元素同属一个集合，这种情况直接返回&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处应用启发函数2，根据树的高度来进行合并
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我们将高度小的合并到高度大的树上&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(rank[fx]&amp;gt;&lt;span&gt;rank[fy]){
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             father[fy] =&lt;span&gt; fx;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(rank[fx]==&lt;span&gt;rank[fy]){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当两棵树一样高的时候，则增加其中一棵的高度&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 rank[fy]++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             father[fx] =&lt;span&gt; fy;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启发函数2中额外使用了一个rank数组来记录树的高度，并让father数组严格遵守father[x]=y表示x的父节点为y这一个规定，使用find函数查找根节点会返回根节点的值，而不是节点数量，这一点比启发函数1来的好用，再加上代码短，思路清晰这一点，我是建议都用启发函数2来实现的&amp;gt;.&amp;lt;&lt;br/&gt;简单并查集的归纳就到这里了，如果想验证代码的正确性的话，下面有几个题目可以选择：&lt;br/&gt;https://leetcode.com/problems/friend-circles/description/   leetcode的朋友圈问题，经典的并查集应用&lt;br/&gt;http://codevs.cn/problem/2597/   团伙问题，敌人的敌人是朋友是需要注意的一点&lt;/p&gt;
&lt;p&gt;最后说几句，这篇文章是我从《算法竞赛宝典》数据结构一章归纳总结而来，如果有什么问题或纰漏，请您指出，本人感激不尽~~~&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 15:25:00 +0000</pubDate>
<dc:creator>sword_magic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sword-magical-blog/p/7630263.html</dc:identifier>
</item>
<item>
<title>再起航，我的学习笔记之JavaScript设计模式28(委托模式) - 东城慕水</title>
<link>http://www.cnblogs.com/chen-jie/p/JavaScript-Entrust.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-jie/p/JavaScript-Entrust.html</guid>
<description>## 委托模式 ### 概念介绍 **委托模式(Entrust): **多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。 ### 利用委托优化循环 如果我们有一个需求需要让用户点击过的列表改变颜色，我们该怎么处理？我想肯定有很多人，和我之前的想法一样 首先我们想要让用户点击过的列表改变颜色，首先我们肯定要获取需要添加点击事件的li标签,然后再去用for循环给每个li添加点击事件让其变颜色，就像下面这样 ``` var li=document.getElementsByTagName('li'); for(var i=li.length-1;i&amp;gt;=0;i--){ li[i].onclick=function(){ this.style.backgroundColor='red'; } } ``` 我们看看效果 ![](http://images2017.cnblogs.com/blog/774226/201710/774226-20171005224114115-1909998938.gif) 首先我们这样做，想法肯定没错，但是我们这样做无形之中增加了很多点击事件，万一我们这个列表很多，那么内存消耗就会变得很大。那么这个时候我们就可以通过委托模式来简化绑定事件来达到我们的目的 我们知道一个完整的事件流要经过事件捕获、触发事件、事件冒泡三个阶段，那么这个时候我们就可以通过把子元素的事件委托给 父元素去绑定执行，那么我们可以把代码做如下修改 ``` var ul=document.getElementById('demo'); ul.onclick=function(e){ var e=e||window.event, tar=e.target||e.srcElement; if(tar.nodeName.toLowerCase()==='li'){ tar.style.backgroundColor='yellow'; } } ``` 我们依然可以实现效果 ![](http://images2017.cnblogs.com/blog/774226/201710/774226-20171005224124630-2076542924.gif) 我们现在做的就是通过监听ul的点击事件判断目标元素是否是我们需要寻找的元素，如果是则执行相应的操作。这样我们为父元素绑定一个事件，通过委托模式就实现了所有子元素的点击事件需求。达到了我们优化的目的。 ### 渲染js生成的元素 通过上面委托模式我们还能针对js中后生成的元素进行渲染添加点击事件 我们想在页面中创建一个DIV然后里面添加一个P标签然后通过js再在这个P标签下增加一个P标签，然后同时为这两个P标签添加点击事件，以前我们如果想要为这种不存在的元素添加点击事件可能是件很麻烦的事情但是有了委托模式之后，我们再实现这个功能我们发现会变得很轻松，我们来看看具体实现 html页面内容 ```
&lt;div id=&quot;test&quot;&gt;
&lt;p&gt;我是html里的P标签&lt;/p&gt;
&lt;/div&gt;
``` 接着我们再通过js添加一个新的P标签并且给父元素添加点击事件 ``` var test=document.getElementById('test'); test.onclick=function(){ var e=e||window.event, tar=e.target||e.srcElement; if (tar.nodeName.toLowerCase()==='p') { tar.innerHTML='我能修改这段文字'; } } var p=document.createElement('p'); p.innerHTML='我是js里后来添加的P标签'; test.appendChild(p); ``` 我们来看看效果 ![](http://images2017.cnblogs.com/blog/774226/201710/774226-20171005224134693-1750199422.gif) ### 优化请求 当然使用委托模式还能优化我们的请求，比如下面我们模拟接收后台的请求去给页面元素赋值 html代码 ```


``` 如果我们要同时赋值，那么我们通常的做法是请求两次请求不同的方法，达到我们的目的 ``` $.get(&quot;/Home/Insert&quot;, function(res) { console.log(res); var json = JSON.parse(res); $(&quot;#test&quot;).html(json.Message) ; }); $.get(&quot;/Home/Update&quot;, function(res) { console.log(res); var json = JSON.parse(res); $(&quot;#test2&quot;).html(json.Message); }); ``` ![](http://images2017.cnblogs.com/blog/774226/201710/774226-20171005224147786-2083282690.png) 如果模块数量过多，我们这种请求方式，既会造成我们资源的浪费，如果用户网络不好，还会造成漫长的等待，这个时候我们就可以使用委托模式把这些请求打包，委托以另一个对象发送，当得到相应数据时在通过委托对象拆包数据分发给各个方法。 ``` var Entrust= { Insert:function(res) { console.log(res); var json = JSON.parse(res); $(&quot;#test&quot;).html(json.Message) ; }, Update:function(res) { console.log(res); var json = JSON.parse(res); $(&quot;#test2&quot;).html(json.Message) ; } } $.get(&quot;/Home/Entrust&quot;, function(res) {; var json = JSON.parse(res); console.log(json); Entrust[&quot;Insert&quot;] &amp;amp;&amp;amp; Entrust[&quot;Insert&quot;](json.Insert); Entrust[&quot;Update&quot;] &amp;amp;&amp;amp; Entrust[&quot;Update&quot;](json.Update); }); ``` 好了现在我们就可以通过一个请求完成之前多个请求所要完成的事情，既节省了流量又节省了时间上的开销。 ![](http://images2017.cnblogs.com/blog/774226/201710/774226-20171005224157880-705077797.png) ### 总结 委托模式是通过委托者将请求委托给被委托者去处理实现的。因此委托模式解决了请求与委托者之间的耦合。通过被委托者对接收到的请求的处理后，分发给相应的委托者去处理。 **也谢谢大家看到这里：）如果你觉得我的分享还可以请点击推荐，分享给你的朋友让我们一起进步~** **好了以上就是本次分享的全部内容，本次示例参考自JavaScript设计模式一书，让我们一点点积累一点点成长，希望对大家有所帮助。** **欢迎转载，转载请注明作者，原文出处。**</description>
<pubDate>Thu, 05 Oct 2017 14:43:00 +0000</pubDate>
<dc:creator>东城慕水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-jie/p/JavaScript-Entrust.html</dc:identifier>
</item>
<item>
<title>Clojure——学习迷宫生成 - 雨中尘埃</title>
<link>http://www.cnblogs.com/rainmote/p/7629958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainmote/p/7629958.html</guid>
<description>&lt;p&gt;初学clojure，想着看一些算法来熟悉clojure语法及相关算法实现。&lt;br/&gt;找到一个各种语言生成迷宫的网站：&lt;a href=&quot;http://rosettacode.org/wiki/Maze_generation&quot; class=&quot;uri&quot;&gt;http://rosettacode.org/wiki/Maze_generation&lt;/a&gt;&lt;br/&gt;在上述网站可以看到clojure的实现版，本文就是以初学者的视角解读改程序。&lt;/p&gt;

&lt;p&gt;先看一些简单的示例，以帮助我们理解迷宫生成程序。&lt;/p&gt;
&lt;h3 id=&quot;绑定符号x&quot;&gt;绑定符号x++&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;(defn f [x]
  (let [x++ (+ x 5)]
    #{[x x++]}))
(println (f 1))
=&amp;gt; #'sinlov.clojure.base-learn/f
#{[1 6]}
=&amp;gt; nil&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Tips: 上述程序将&lt;code&gt;x++&lt;/code&gt;绑定为&lt;code&gt;x+5&lt;/code&gt;，不同于c语言中的自增运算符。&lt;/p&gt;
&lt;h3 id=&quot;集合过滤&quot;&gt;集合过滤&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;(select odd? (set [1 2 3 4 5]))
=&amp;gt; #{1 3 5}
(select (partial odd?) (set [1 2 3 4 5]))
=&amp;gt; #{1 3 5}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt;语法参考文档：&lt;a href=&quot;http://clojuredocs.org/clojure.set/select&quot; class=&quot;uri&quot;&gt;http://clojuredocs.org/clojure.set/select&lt;/a&gt;&lt;br/&gt;&lt;code&gt;partial&lt;/code&gt;解释见下文&lt;/p&gt;
&lt;h3 id=&quot;vec交叉合并&quot;&gt;vec交叉合并&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;(interleave [0 1 2] ['a 'b 'c])
=&amp;gt; (0 a 1 b 2 c)
(interleave [0 1 2] ['a 'b 'c] ['b])
=&amp;gt; (0 a b)
(interleave [0 1 2] ['a 'b 'c] (repeat 'z))
=&amp;gt; (0 a z 1 b z 2 c z)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文档：&lt;a href=&quot;http://clojuredocs.org/clojure.core/interleave&quot; class=&quot;uri&quot;&gt;http://clojuredocs.org/clojure.core/interleave&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;transduce&quot;&gt;transduce&lt;/h3&gt;
&lt;p&gt;transducer是clojure里面的一种编程思想，使用transducer可以简化很多语法。&lt;br/&gt;可以参考这篇文章&lt;a href=&quot;https://blog.oyanglul.us/javascript/clojure-essence-in-javascript-transducer.html&quot;&gt;链接&lt;/a&gt;，帮助理解&lt;br/&gt;文档：&lt;a href=&quot;http://clojuredocs.org/clojure.core/transduce&quot; class=&quot;uri&quot;&gt;http://clojuredocs.org/clojure.core/transduce&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;笔者阅读了迷宫生成算法，将思路整理如下&lt;/p&gt;
&lt;h2 id=&quot;坐标点与符号映射关系&quot;&gt;坐标点与符号映射关系&lt;/h2&gt;
&lt;p&gt;比如迷宫的左上角&lt;code&gt;┌&lt;/code&gt;是如何生成的，不同大小的迷宫如何确定？&lt;br/&gt;经过阅读源码发现，一个坐标点的符号与其周围4个临接点相关，如果按照坐标点表示，5个点排序顺序是一致的。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/572260/201710/572260-20171005213901786-889139088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如，上述坐标点(5,5)，和其4个临界点。可以看到在该坐标系内，一个点与其临界点做成的集合排序一定是下面的顺序：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/572260/201710/572260-20171005214032240-2119867942.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如迷宫左上角坐标是(0, 0)，该点五元组应该是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不在迷宫，不在迷宫，(0, 0), (0, 1), (1, 0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设不在迷宫或者该位置为空，记为&lt;code&gt;0&lt;/code&gt;；如果是墙记为&lt;code&gt;1&lt;/code&gt;&lt;br/&gt;那么上述五元组可以换算为&lt;code&gt;11100&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再比如迷宫右上角，五元组为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(n-1, 0), 不在迷宫, (n, 0), (n, 1), 不在迷宫&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可换算为&lt;code&gt;10110&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;按照如上规则可以生成如下表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;· &quot; &quot;╵ &quot; &quot;╴ &quot; &quot;┘ &quot;
&quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;╶─&quot; &quot;└─&quot; &quot;──&quot; &quot;┴─&quot;
&quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;╷ &quot; &quot;│ &quot; &quot;┐ &quot; &quot;┤ &quot;
&quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;┌─&quot; &quot;├─&quot; &quot;┬─&quot; &quot;┼─&quot;]&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;(ns maze.core
  (:require [clojure.set :refer [intersection
                                 select]]
            [clojure.string :as str]))

;; 得到周围临界点
(defn neighborhood
  ([] (neighborhood [0 0]))
  ([coord] (neighborhood coord 1))
  ([[y x] r]
   (let [y-- (- y r) y++ (+ y r)
         x-- (- x r) x++ (+ x r)]
     #{[y++ x] [y-- x] [y x--] [y x++]})))

;; 判断位置是否为空
(defn cell-empty? [maze coords]
  (= :empty (get-in maze coords)))

;; 判断位置是否为墙
(defn wall? [maze coords]
  (= :wall (get-in maze coords)))

;; 过滤迷宫中指定类型的点的集合
(defn filter-maze
  ([pred maze coords]
   (select (partial pred maze) (set coords)))
  ([pred maze]
   (filter-maze
     pred
     maze
     (for [y (range (count maze))
           x (range (count (nth maze y)))]
       [y x]))))

;; 创建新迷宫
(defn create-empty-maze [width height]
  (let [width (inc (* 2 width))
        height (inc (* 2 height))]
    (vec (take height
               (interleave
                 (repeat (vec (take width (repeat :wall))))
                 (repeat (vec (take width (cycle [:wall :empty])))))))))

(defn next-step [possible-steps]
  (rand-nth (vec possible-steps)))

;; 核心算法，深度优先递归
(defn create-random-maze [width height]
  (loop [maze (create-empty-maze width height)
         stack []
         nonvisited (filter-maze cell-empty? maze)
         visited #{}
         coords (next-step nonvisited)]
    (if (empty? nonvisited)
      maze
      (let [nonvisited-neighbors (intersection (neighborhood coords 2) nonvisited)]
        (cond
          (seq nonvisited-neighbors)
          (let [next-coords (next-step nonvisited-neighbors)
                wall-coords (map #(+ %1 (/ (- %2 %1) 2)) coords next-coords)]
            (recur (assoc-in maze wall-coords :empty)
                   (conj stack coords)
                   (disj nonvisited next-coords)
                   (conj visited next-coords)
                   next-coords))

          (seq stack)
          (recur maze (pop stack) nonvisited visited (last stack)))))))

;; 迷宫坐标与字符映射
(def cell-code-&amp;gt;str
  [&quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;· &quot; &quot;╵ &quot; &quot;╴ &quot; &quot;┘ &quot;
   &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;╶─&quot; &quot;└─&quot; &quot;──&quot; &quot;┴─&quot;
   &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;╷ &quot; &quot;│ &quot; &quot;┐ &quot; &quot;┤ &quot;
   &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;  &quot; &quot;┌─&quot; &quot;├─&quot; &quot;┬─&quot; &quot;┼─&quot;])

;; 获取迷宫坐标的类型
;; 使用5 bit表示一个点对应的字符映射
;; 例如：00111对应┘ 
(defn cell-code [maze coord]
  (transduce
    (comp
      (map (partial wall? maze))
      (keep-indexed (fn [idx el] (when el idx)))
      (map (partial bit-shift-left 1)))
    (completing bit-or)
    0
    (sort (cons coord (neighborhood coord)))))

(defn cell-&amp;gt;str [maze coord]
  (get cell-code-&amp;gt;str (cell-code maze coord)))

;; 将迷宫坐标转换为字符
(defn maze-&amp;gt;str [maze]
  (-&amp;gt;&amp;gt; (for [y (range (count maze))]
         (for [x (range (count (nth maze y)))]
           (cell-&amp;gt;str maze [y x])))
       (map str/join)
       (str/join \newline)))

;; 生成迷宫
(println (maze-&amp;gt;str (create-random-maze 10 10)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述程序输出：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/572260/201710/572260-20171005222842708-1916801388.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 14:28:00 +0000</pubDate>
<dc:creator>雨中尘埃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rainmote/p/7629958.html</dc:identifier>
</item>
<item>
<title>Springboot - 学习笔记 ② - ~阿坨坨</title>
<link>http://www.cnblogs.com/atuotuo/p/7625751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atuotuo/p/7625751.html</guid>
<description>&lt;p&gt;&lt;span&gt;这一篇是关于spring boot中的配置（configuration）的介绍，我们接下来要说的男主就是 “application.properties”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“男神”默认是生成在“/src/main/resources”下，结构如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171004160934396-1390905123.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是spring boot的核心配置文件，几乎囊括了spring boot 所有的配置。所以首先，我们先列出来它所涉及到的所有的配置项：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#########COMMON SPRING BOOT PROPERTIES


######========CORE PROPERTIES===========

#SPRING CONFIG (ConfigFileApplicationListener)


spring.config.name= # config file name (default to 'application')
spring.config.location= # location of config file

#PROFILES
spring.profiles= # comma list of active profiles


#APPLICATION SETTINGS (SpringApplication)
spring.main.sources=
spring.main.web-environment= # detect by default
spring.main.show-banner=true
spring.main....= # see class for all properties


#LOGGING
logging.path=/var/logs
logging.file=myapp.log
logging.config=


#IDENTITY (ContextIdApplicationContextInitializer)
spring.application.name=
spring.application.index=


#EMBEDDED SERVER CONFIGURATION (ServerProperties)
server.port=8080
server.address= # bind to a specific NIC
server.session-timeout= # session timeout in seconds
server.context-path= # the context path, defaults to '/'
server.servlet-path= # the servlet path, defaults to '/'
server.tomcat.access-log-pattern= # log pattern of the access log
server.tomcat.access-log-enabled=false # is access logging enabled
server.tomcat.protocol-header=x-forwarded-proto # ssl forward headers
server.tomcat.remote-ip-header=x-forwarded-for
server.tomcat.basedir=/tmp # base dir (usually not needed, defaults to tmp)
server.tomcat.background-processor-delay=30; # in seconds
server.tomcat.max-threads = 0 # number of threads in protocol handler
server.tomcat.uri-encoding = UTF-8 # character encoding to use for URL decoding


#SPRING MVC (HttpMapperProperties)
http.mappers.json-pretty-print=false # pretty print JSON
http.mappers.json-sort-keys=false # sort keys
spring.mvc.locale= # set fixed locale, e.g. enUK
spring.mvc.date-format= # set fixed date format, e.g. dd/MM/yyyy
spring.mvc.message-codes-resolver-format= # PREFIXERRORCODE / POSTFIXERROR_CODE
spring.view.prefix= # MVC view prefix
spring.view.suffix= # ... and suffix
spring.resources.cache-period= # cache timeouts in headers sent to browser
spring.resources.add-mappings=true # if default mappings should be added


#THYMELEAF (ThymeleafAutoConfiguration)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML5
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.content-type=text/html # ;charset=&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; is added
spring.thymeleaf.cache=true # set to false for hot refresh


#FREEMARKER (FreeMarkerAutoConfiguration)
spring.freemarker.allowRequestOverride=false
spring.freemarker.allowSessionOverride=false
spring.freemarker.cache=true
spring.freemarker.checkTemplateLocation=true
spring.freemarker.contentType=text/html
spring.freemarker.exposeRequestAttributes=false
spring.freemarker.exposeSessionAttributes=false
spring.freemarker.exposeSpringMacroHelpers=false
spring.freemarker.prefix=
spring.freemarker.requestContextAttribute=
spring.freemarker.settings.*=
spring.freemarker.suffix=.ftl
spring.freemarker.templateEncoding=UTF-8
spring.freemarker.templateLoaderPath=classpath:/templates/
spring.freemarker.viewNames= # whitelist of view names that can be resolved


#GROOVY TEMPLATES (GroovyTemplateAutoConfiguration)
spring.groovy.template.allowRequestOverride=false
spring.groovy.template.allowSessionOverride=false
spring.groovy.template.cache=true
spring.groovy.template.configuration.*= # See Groovy's TemplateConfiguration
spring.groovy.template.contentType=text/html
spring.groovy.template.prefix=classpath:/templates/
spring.groovy.template.suffix=.tpl
spring.groovy.template.templateEncoding=UTF-8
spring.groovy.template.viewNames= # whitelist of view names that can be resolved


#VELOCITY TEMPLATES (VelocityAutoConfiguration)
spring.velocity.allowRequestOverride=false
spring.velocity.allowSessionOverride=false
spring.velocity.cache=true
spring.velocity.checkTemplateLocation=true
spring.velocity.contentType=text/html
spring.velocity.dateToolAttribute=
spring.velocity.exposeRequestAttributes=false
spring.velocity.exposeSessionAttributes=false
spring.velocity.exposeSpringMacroHelpers=false
spring.velocity.numberToolAttribute=
spring.velocity.prefix=
spring.velocity.properties.*=
spring.velocity.requestContextAttribute=
spring.velocity.resourceLoaderPath=classpath:/templates/
spring.velocity.suffix=.vm
spring.velocity.templateEncoding=UTF-8
spring.velocity.viewNames= # whitelist of view names that can be resolved


#INTERNATIONALIZATION (MessageSourceAutoConfiguration)
spring.messages.basename=messages
spring.messages.cacheSeconds=-1
spring.messages.encoding=UTF-8


#SECURITY (SecurityProperties)
security.user.name=user # login username
security.user.password= # login password
security.user.role=USER # role assigned to the user
security.require-ssl=false # advanced settings ...
security.enable-csrf=false
security.basic.enabled=true
security.basic.realm=Spring
security.basic.path= # /**
security.headers.xss=false
security.headers.cache=false
security.headers.frame=false
security.headers.contentType=false
security.headers.hsts=all # none / domain / all
security.sessions=stateless # always / never / if_required / stateless
security.ignored=false


#DATASOURCE (DataSourceAutoConfiguration &amp;amp; DataSourceProperties)
spring.datasource.name= # name of the data source
spring.datasource.initialize=true # populate using data.sql
spring.datasource.schema= # a schema (DDL) script resource reference
spring.datasource.data= # a data (DML) script resource reference
spring.datasource.platform= # the platform to use in the schema resource (schema-${platform}.sql)
spring.datasource.continueOnError=false # continue even if can't be initialized
spring.datasource.separator=; # statement separator in SQL initialization scripts
spring.datasource.driverClassName= # JDBC Settings...
spring.datasource.url=
spring.datasource.username=
spring.datasource.password=
spring.datasource.max-active=100 # Advanced configuration...
spring.datasource.max-idle=8
spring.datasource.min-idle=8
spring.datasource.initial-size=10
spring.datasource.validation-query=
spring.datasource.test-on-borrow=false
spring.datasource.test-on-return=false
spring.datasource.test-while-idle=
spring.datasource.time-between-eviction-runs-millis=
spring.datasource.min-evictable-idle-time-millis=
spring.datasource.max-wait-millis=


#MONGODB (MongoProperties)
spring.data.mongodb.host= # the db host
spring.data.mongodb.port=27017 # the connection port (defaults to 27107)
spring.data.mongodb.uri=mongodb://localhost/test # connection URL
spring.data.mongo.repositories.enabled=true # if spring data repository support is enabled


#JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)
spring.jpa.properties.*= # properties to set on the JPA connection
spring.jpa.openInView=true
spring.jpa.show-sql=true
spring.jpa.database-platform=
spring.jpa.database=
spring.jpa.generate-ddl=false # ignored by Hibernate, might be useful for other vendors
spring.jpa.hibernate.naming-strategy= # naming classname
spring.jpa.hibernate.ddl-auto= # defaults to create-drop for embedded dbs
spring.data.jpa.repositories.enabled=true # if spring data repository support is enabled


#SOLR (SolrProperties})
spring.data.solr.host=http://127.0.0.1:8983/solr
spring.data.solr.zkHost=
spring.data.solr.repositories.enabled=true # if spring data repository support is enabled


#ELASTICSEARCH (ElasticsearchProperties})
spring.data.elasticsearch.cluster-name= # The cluster name (defaults to elasticsearch)
spring.data.elasticsearch.cluster-nodes= # The address(es) of the server node (comma-separated; if not specified starts a client node)
spring.data.elasticsearch.local=true # if local mode should be used with client nodes
spring.data.elasticsearch.repositories.enabled=true # if spring data repository support is enabled


#FLYWAY (FlywayProperties)
flyway.locations=classpath:db/migrations # locations of migrations scripts
flyway.schemas= # schemas to update
flyway.initVersion= 1 # version to start migration
flyway.prefix=V
flyway.suffix=.sql
flyway.enabled=true
flyway.url= # JDBC url if you want Flyway to create its own DataSource
flyway.user= # JDBC username if you want Flyway to create its own DataSource
flyway.password= # JDBC password if you want Flyway to create its own DataSource


#LIQUIBASE (LiquibaseProperties)
liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml
liquibase.contexts= # runtime contexts to use
liquibase.default-schema= # default database schema to use
liquibase.drop-first=false
liquibase.enabled=true


#JMX
spring.jmx.enabled=true # Expose MBeans from Spring


#ABBIT (RabbitProperties)
spring.rabbitmq.host= # connection host
spring.rabbitmq.port= # connection port
spring.rabbitmq.addresses= # connection addresses (e.g. myhost:9999,otherhost:1111)
spring.rabbitmq.username= # login user
spring.rabbitmq.password= # login password
spring.rabbitmq.virtualhost=
spring.rabbitmq.dynamic=


#REDIS (RedisProperties)
spring.redis.host=localhost # server host
spring.redis.password= # server password
spring.redis.port=6379 # connection port
spring.redis.pool.max-idle=8 # pool settings ...
spring.redis.pool.min-idle=0
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1


#ACTIVEMQ (ActiveMQProperties)
spring.activemq.broker-url=tcp://localhost:61616 # connection URL
spring.activemq.user=
spring.activemq.password=
spring.activemq.in-memory=true # broker kind to create if no broker-url is specified
spring.activemq.pooled=false


#HornetQ (HornetQProperties)
spring.hornetq.mode= # connection mode (native, embedded)
spring.hornetq.host=localhost # hornetQ host (native mode)
spring.hornetq.port=5445 # hornetQ port (native mode)
spring.hornetq.embedded.enabled=true # if the embedded server is enabled (needs hornetq-jms-server.jar)
spring.hornetq.embedded.serverId= # auto-generated id of the embedded server (integer)
spring.hornetq.embedded.persistent=false # message persistence
spring.hornetq.embedded.data-directory= # location of data content (when persistence is enabled)
spring.hornetq.embedded.queues= # comma separate queues to create on startup
spring.hornetq.embedded.topics= # comma separate topics to create on startup
spring.hornetq.embedded.cluster-password= # customer password (randomly generated by default)


#JMS (JmsProperties)
spring.jms.pub-sub-domain= # false for queue (default), true for topic


#SPRING BATCH (BatchDatabaseInitializer)
spring.batch.job.names=job1,job2
spring.batch.job.enabled=true
spring.batch.initializer.enabled=true
spring.batch.schema= # batch schema to load


#AOP
spring.aop.auto=
spring.aop.proxy-target-class=


#FILE ENCODING (FileEncodingApplicationListener)
spring.mandatory-file-encoding=false


#SPRING SOCIAL (SocialWebAutoConfiguration)
spring.social.auto-connection-views=true # Set to true for default connection views or false if you provide your own


#SPRING SOCIAL FACEBOOK (FacebookAutoConfiguration)
spring.social.facebook.app-id= # your application's Facebook App ID
spring.social.facebook.app-secret= # your application's Facebook App Secret


#SPRING SOCIAL LINKEDIN (LinkedInAutoConfiguration)
spring.social.linkedin.app-id= # your application's LinkedIn App ID
spring.social.linkedin.app-secret= # your application's LinkedIn App Secret


#SPRING SOCIAL TWITTER (TwitterAutoConfiguration)
spring.social.twitter.app-id= # your application's Twitter App ID
spring.social.twitter.app-secret= # your application's Twitter App Secret


#SPRING MOBILE SITE PREFERENCE (SitePreferenceAutoConfiguration)
spring.mobile.sitepreference.enabled=true # enabled by default


#SPRING MOBILE DEVICE VIEWS (DeviceDelegatingViewResolverAutoConfiguration)
spring.mobile.devicedelegatingviewresolver.enabled=true # disabled by default
spring.mobile.devicedelegatingviewresolver.normalPrefix=
spring.mobile.devicedelegatingviewresolver.normalSuffix=
spring.mobile.devicedelegatingviewresolver.mobilePrefix=mobile/
spring.mobile.devicedelegatingviewresolver.mobileSuffix=
spring.mobile.devicedelegatingviewresolver.tabletPrefix=tablet/
spring.mobile.devicedelegatingviewresolver.tabletSuffix=





######========ACTUATOR PROPERTIES===========

#MANAGEMENT HTTP SERVER (ManagementServerProperties)
management.port= # defaults to 'server.port'
management.address= # bind to a specific NIC
management.contextPath= # default to '/'


#ENDPOINTS (AbstractEndpoint subclasses)
endpoints.autoconfig.id=autoconfig
endpoints.autoconfig.sensitive=true
endpoints.autoconfig.enabled=true
endpoints.beans.id=beans
endpoints.beans.sensitive=true
endpoints.beans.enabled=true
endpoints.configprops.id=configprops
endpoints.configprops.sensitive=true
endpoints.configprops.enabled=true
endpoints.configprops.keys-to-sanitize=password,secret
endpoints.dump.id=dump
endpoints.dump.sensitive=true
endpoints.dump.enabled=true
endpoints.env.id=env
endpoints.env.sensitive=true
endpoints.env.enabled=true
endpoints.health.id=health
endpoints.health.sensitive=false
endpoints.health.enabled=true
endpoints.info.id=info
endpoints.info.sensitive=false
endpoints.info.enabled=true
endpoints.metrics.id=metrics
endpoints.metrics.sensitive=true
endpoints.metrics.enabled=true
endpoints.shutdown.id=shutdown
endpoints.shutdown.sensitive=true
endpoints.shutdown.enabled=false
endpoints.trace.id=trace
endpoints.trace.sensitive=true
endpoints.trace.enabled=true


#MVC ONLY ENDPOINTS
endpoints.jolokia.path=jolokia
endpoints.jolokia.sensitive=true
endpoints.jolokia.enabled=true # when using Jolokia
endpoints.error.path=/error


#JMX ENDPOINT (EndpointMBeanExportProperties)
endpoints.jmx.enabled=true
endpoints.jmx.domain= # the JMX domain, defaults to 'org.springboot'
endpoints.jmx.unique-names=false
endpoints.jmx.enabled=true
endpoints.jmx.staticNames=


#JOLOKIA (JolokiaProperties)
jolokia.config.*= # See Jolokia manual


#REMOTE SHELL
shell.auth=simple # jaas, key, simple, spring
shell.command-refresh-interval=-1
shell.command-path-pattern= # classpath:/commands/, classpath:/crash/commands/
shell.config-path-patterns= # classpath:/crash/
shell.disabled-plugins=false # don't expose plugins
shell.ssh.enabled= # ssh settings ...
shell.ssh.keyPath=
shell.ssh.port=
shell.telnet.enabled= # telnet settings ...
shell.telnet.port=
shell.auth.jaas.domain= # authentication settings ...
shell.auth.key.path=
shell.auth.simple.user.name=
shell.auth.simple.user.password=
shell.auth.spring.roles=


#GIT INFO
spring.git.properties= # resource ref to generated git info properties file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 啰嗦了一大堆，无非就是想说明这个配置文件很强大！很强大！ 接下来，我们通过3个栗子来说明配置文件的用法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;首先，我们先来试试如何修改系统的配置并且应用到我们的webservice上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们尝试修改两项内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. service port: 将默认的端口号t改为“8099”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. context path: 将service的默认路径“\”修改为“\config”&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server.port=8099
server.context-path=/config&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在，编写创建一个新的Spring boot 项目，并且编写一个新的controller;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.tuo.HelloSpringBoot.Controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringConfigController {

    @RequestMapping(&lt;/span&gt;&quot;/default&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String fetchDefaultConfig(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Get default config done!&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;之后，我们启动spring boot 程序，在浏览器中输入URL = &lt;span&gt;http://localhost:8099/config/default&lt;/span&gt;，之后就可以看到如下结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171005145821021-1597220156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Spring boot 为我们提供了更为简单的方式来获取配置项的值. 首先在application.properties文件里面加入我们自定义的配置项，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
myName=Tony
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在controller类中，重新添加一个path,用来返回MyName的值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Value(&quot;${myName}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String myNameStr;
    
@RequestMapping(&lt;/span&gt;&quot;/name&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMyName(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; myNameStr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们现在来使用浏览器验证新的接口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171005150952974-2028009936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;在这里，我们要将一组配置项封装成为一个类（确切的说是JavaBean），并且使用“Component”注解来注入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们在配置文件（application.properties）里面加入一组关于MySQL连接的配置项，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql.jdbcName=com.mysql.jdbc.Driver
mysql.dbUrl=jdbc:mysql://localhost:3306/springboot
mysql.userName=root
mysql.password=root&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后，我们封装出一个类“MysqlProperties.java”,用来标识出对应的配置项，内容为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.tuo.HelloSpringBoot.Controller;
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; @Component&lt;br/&gt; @ConfigurationProperties(prefix=&quot;mysql&quot;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MySqlPropertyies {&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;    private&lt;/span&gt;&lt;span&gt; String jdbcName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String dbUrl;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getJdbcName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jdbcName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setJdbcName(String jdbcName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jdbcName =&lt;span&gt; jdbcName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDbUrl() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dbUrl;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDbUrl(String dbUrl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dbUrl =&lt;span&gt; dbUrl;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }    
    
}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;@ConfigurationProperties(prefix=&quot;mysql&quot;) 用来指定配置项的前缀；注意，类的字段名称需要和配置项的名称匹配！！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来，我们在controller里面使用注解来读取配置项：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MySqlPropertyies mysqlProperties;
    
    @RequestMapping(&lt;/span&gt;&quot;/mysqlproperty&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getMySqlProperty(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;mysql.jdbcName:&quot;+mysqlProperties.getJdbcName()+&quot;&amp;lt;br/&amp;gt;&quot;
                  +&quot;mysql.dbUrl:&quot;+mysqlProperties.getDbUrl()+&quot;&amp;lt;br/&amp;gt;&quot;
                  +&quot;mysql.userName:&quot;+mysqlProperties.getUserName()+&quot;&amp;lt;br/&amp;gt;&quot;
                  +&quot;mysql.password:&quot;+mysqlProperties.getPassword()+&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;最后，我们来验证一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201710/396477-20171005215911021-639185062.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Well，我们能够顺利的获取配置项的内容啦！！这一次就到这里啦，感谢大家的观看，bye~~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 05 Oct 2017 14:01:00 +0000</pubDate>
<dc:creator>~阿坨坨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atuotuo/p/7625751.html</dc:identifier>
</item>
<item>
<title>Python数据分析(二): Numpy技巧 (1/4) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7630065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7630065.html</guid>
<description>&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# seed for reproducibility&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;x3 ndim: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ndim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;x3 shape:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;x3 size: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;x3 dtype: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;itemsize: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itemsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bytes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nbytes: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bytes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 05 Oct 2017 13:41:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7630065.html</dc:identifier>
</item>
<item>
<title>使用Xshell+Xmanager远程监控jvisualvm - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/7630081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/7630081.html</guid>
<description>&lt;p&gt;   使用jvisualvm的remote方式监控服务器端jvisualvm时，不是很方便，因此通过local方式，应该是正路。&lt;/p&gt;
&lt;p&gt;一、服务器端（Linux，最小安装模式，没有图形界面）&lt;/p&gt;
&lt;p&gt;1.安装xauth&lt;/p&gt;
&lt;p&gt; 如果在Xshell中配置了X11转发后，出现如下提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;WARNING!&lt;/span&gt; The remote SSH server rejected X11 forwarding request.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 则需要查看/etc/ssh/sshd_config中以下选项是否为yes，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;X11Forwarding yes&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果设置没问题，连接时仍报上述提示，则需要安装xauth（&lt;span&gt;使用微软Azure时，最小化安装Linux，默认没有xauth&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install xorg-x11-xauth
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.安装xhost&lt;/p&gt;
&lt;p&gt; 如果执行xhost +命令，提示xhost命令找不到，则还需要安装xhost，否则略过此步：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01 ~&lt;/span&gt;]$ xhost +
-bash: xhost: command not found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查看谁提供了xhost:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;[teld@T-SHA1-FLK-01 ~]$ yum provides xhost&lt;br/&gt;Loaded plugins: fastestmirror, langpacks&lt;br/&gt;Determining fastest mirrors&lt;br/&gt;&lt;span&gt;xorg-x11-server-utils-7.7-20.el7.x86_64&lt;/span&gt; : X.Org X11 X server utilities&lt;br/&gt;Repo : base&lt;br/&gt;Matched from:&lt;br/&gt;Provides : xhost = 1.0.7&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 从列表中选择安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01 ~&lt;/span&gt;]$ yum install xorg-x11-server-utils-&lt;span&gt;7.7&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;.el7.x86_64
[teld@T&lt;/span&gt;-SHA1-FLK-&lt;span&gt;01 ~&lt;/span&gt;]$ xhost +&lt;span&gt;
access control disabled, clients can connect &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; any host
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.检查$DISPLAY是否有值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01 ~&lt;/span&gt;&lt;span&gt;]$ echo $DISPLAY
localhost:&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 二、客户端（Windows）&lt;/p&gt;
&lt;p&gt;1.安装Xshell&lt;/p&gt;
&lt;p&gt;2.安装Xmanager&lt;/p&gt;
&lt;p&gt;  Xmanager会把X DISPLAY选项自动查找为&lt;a href=&quot;http://www.xshellcn.com/&quot; target=&quot;_blank&quot;&gt;Xshell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.配置Xshell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/380081/201710/380081-20171005205920396-1347405502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、使用步骤&lt;/p&gt;
&lt;p&gt;1.Xshell连接远程服务器&lt;/p&gt;
&lt;p&gt;2.在Xshell中启动xhost +，以便在客户端开启xserver&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01&lt;/span&gt; ~]$ xhost +&lt;span&gt;
access control disabled, clients can connect &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; any host
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果客户端的xmanager没开的话，这时会发现客户端的xmanager会被拉起来了&lt;/p&gt;
&lt;p&gt;3.在Xshell中启动jvisualvm &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[teld@T&lt;/span&gt;-SHA1-FLK-&lt;span&gt;01&lt;/span&gt; ~]$ jvisualvm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这时会发现jvisualvm在xmanager里出现了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/380081/201710/380081-20171005210337318-2109586734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 13:41:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/7630081.html</dc:identifier>
</item>
<item>
<title>Django内置的用户认证 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/7629997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/7629997.html</guid>
<description>&lt;p&gt;&lt;strong&gt;认证登陆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在进行用户登陆验证的时候，如果是自己写代码，就必须要先查询数据库，看用户输入的用户名是否存在于数据库中；&lt;/p&gt;
&lt;p&gt;如果用户存在于数据库中，然后再验证用户输入的密码，这样一来就要自己编写大量的代码。&lt;/p&gt;
&lt;p&gt;事实上，Django已经提供了内置的用户认证功能。&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;&quot;python manage.py makemigrationss&quot;&lt;/code&gt;和&lt;code&gt;&quot;python manage.py migrate&quot;&lt;/code&gt;迁移完成数据库之后&lt;/p&gt;
&lt;p&gt;根据配置文件&lt;code&gt;settings.py&lt;/code&gt;中的数据库段生成的数据表中已经包含了6张进行认证的数据表，分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auth_user&lt;/li&gt;
&lt;li&gt;auth_group&lt;/li&gt;
&lt;li&gt;auth_group_permissions&lt;/li&gt;
&lt;li&gt;auth_permission&lt;/li&gt;
&lt;li&gt;auth_user_groups&lt;/li&gt;
&lt;li&gt;auth_user_user_permissions&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进行用户认证的数据表为&lt;code&gt;auth_user&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要使用Django自带的认证功能，首先要导入&lt;code&gt;auth&lt;/code&gt;模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib import auth         #导入auth模块&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;django.contrib.auth&lt;/code&gt;中提供了很多方法，我们常用的有三个方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;authenticate()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供了用户认证，即验证用户名以及密码是否正确，一般需要username和password两个关键字参数&lt;/p&gt;
&lt;p&gt;如果通过认证，&lt;code&gt;authenticate()&lt;/code&gt;函数会返回一个User对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;authenticate()&lt;/code&gt;函数会在User对象上设置一个属性标识，这个属性标识经过数据库验证用户名及密码。&lt;/p&gt;
&lt;p&gt;当我们试图登陆一个从数据库中直接取出来不经过&lt;code&gt;authenticate()&lt;/code&gt;的User对象时会报错。&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    user=authenticate(username=&quot;uaername&quot;,password=&quot;password&quot;)
    
    login(HttpResponse,user)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数接受一个&lt;code&gt;HttpRequest&lt;/code&gt;对象，以及一个通过&lt;code&gt;authenticate()&lt;/code&gt;函数认证的User对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;login(request)登陆用户&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个函数使用&lt;code&gt;Django&lt;/code&gt;的&lt;code&gt;session&lt;/code&gt;框架给某个已认证的用户附加上&lt;code&gt;session_id&lt;/code&gt;信息。&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.shortcuts import render,redirect,HttpResponse
    
    from django.contrib.auth import authenticate,login
    
    def auth_view(request):
        username=request.POST.GET(&quot;usernmae&quot;)       # 获取用户名
        password=request.POST.GET(&quot;password&quot;)       # 获取用户的密码
    
        user=authenticate(username=username,password=password)  # 验证用户名和密码，返回用户对象
    
        if user:                        # 如果用户对象存在
            login(request,user)         # 用户登陆
            return redirect(&quot;/index/&quot;)
    
        else:
            return HttpResponse(&quot;用户名或密码错误&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;logout(request)注销用户&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个函数接受一个&lt;code&gt;HttpResponse&lt;/code&gt;对象，无返回值。&lt;/p&gt;
&lt;p&gt;当调用该函数时，当前请求的session信息全部被清除。&lt;/p&gt;
&lt;p&gt;即使当前用户没有登陆，调用该函数也不会报错。&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.shortcuts import render,redirect,HttpResponse
    
    from django.contrib.auth import authenticate,login,logout
    
    def logout_view(request):
        
        logout(request)     # 注销用户
        
        return redirect(&quot;/index/&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;user对象的is_authenticated()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登陆后才能访问某些页面&lt;/li&gt;
&lt;li&gt;如果用户没有登陆就访问本应登陆才能访问的页面时会直接跳转到登陆页面&lt;/li&gt;
&lt;li&gt;用户在登陆页面登陆后，又会自动跳转到之前访问的页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    def view1(request):
        
        if not request.user.is_authenticated():
            return redirect(&quot;/login/&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;使用Django的&lt;code&gt;login_requierd()&lt;/code&gt;装饰器&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.contrib.auth.decorators import login_required
    
    @login_required
    def views(request):
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用户没有登陆，则会跳转到Django默认的登陆URL的&lt;code&gt;&quot;/accountss/login/&quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;login视图函数可以在settings.py文件中通过LOGIN_URL修改默认值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户登陆成功后，会重定向到原来的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;user对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;User对象属性：username,password为必填项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;password用哈希算法保存到数据库中&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;is_staff：判断用户是否拥有网站的管理权限&lt;/li&gt;
&lt;li&gt;is_active：判断是否允许用户登陆，设置为“False”时可以不用删除用户来禁止用户登陆&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;User对象的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;is_authenticated()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是通过&lt;code&gt;auth&lt;/code&gt;函数返回的真实的User对象，返回值则为True。这个方法检查用户是否已经通过了认证。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;is_authenticated()&lt;/code&gt;函数的返回值为True时，表明用户成功的通过了认证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;创建用户&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;create_user&lt;/code&gt;辅助函数创建用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.contrib.auth.models import User
user=User.objects.create_user(username=&quot;username&quot;,password=&quot;password&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;set_password(password)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这个方法来修改密码&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.contrib.auth.models import User
    
    user=User.objects.get(username=&quot;username&quot;)      # 获取用户对象
    user.set_password(password=&quot;password&quot;)          # 设置对象的密码
    
    user.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;check_password(password)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户想修改密码的时候，首先要让用户输入原来的密码。&lt;/p&gt;
&lt;p&gt;如果用户输入的旧密码通过密码验证，返回True。&lt;/p&gt;
&lt;p&gt;例子一,使用&lt;code&gt;set_password()&lt;/code&gt;方法来修改密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.shortcuts import render,redirect,HttpResponse
    from django.contrib.auth.models import User
    
    def create_user(request):
    
        msg=None
    
        if request.method==&quot;POST&quot;:
            username=request.POST.get(&quot;username&quot;,&quot; &quot;)           # 获取用户名，默认为空字符串
            password=request.POST.get(&quot;password&quot;,&quot; &quot;)           # 获取密码，默认为空字符串
            confirm=request.POST.get(&quot;confirm_password&quot;,&quot; &quot;)    # 获取确认密码，默认为空字符串
    
            if password == &quot;&quot; or confirm==&quot;&quot; or username==&quot;&quot;:   # 如果用户名，密码或确认密码为空
                msg=&quot;用户名或密码不能为空&quot;
            elif password !=confirm:                            # 如果密码与确认密码不一致
                msg=&quot;两次输入的密码不一致&quot;
            elif User.objects.filter(username=username):        # 如果数据库中已经存在这个用户名
                msg=&quot;该用户名已存在&quot;
            else:
                new_user=User.objects.create_user(username=username,password=password)  #创建新用户 
                new_user.save()
            
                return redirect(&quot;/index/&quot;)
        
        return render(request,&quot;login.html&quot;,{&quot;msg&quot;:msg})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子二,使用&lt;code&gt;login_required装饰器&lt;/code&gt;来修改密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from django.shortcuts import render,redirect,HttpResponse
    from django.contrib.auth import authenticate,login,logout
    from django.contrib.auth.decorators import login_required
    from django.contrib.auth.models import User
    
    @login_required
    def change_passwd(request):
        user=request.user       # 获取用户名
        msg=None
    
        if request.method=='POST':
            old_password=request.POST.get(&quot;old_password&quot;,&quot;&quot;)    # 获取原来的密码，默认为空字符串
            new_password=request.POST.get(&quot;new_password&quot;,&quot;&quot;)    # 获取新密码，默认为空字符串
            confirm=request.POST.get(&quot;confirm_password&quot;,&quot;&quot;)     # 获取确认密码，默认为空字符串
    
            if user.check_password(old_password):               # 到数据库中验证旧密码通过
                if new_password or confirm:                     # 新密码或确认密码为空
                    msg=&quot;新密码不能为空&quot;   
                elif new_password != confirm:                   # 新密码与确认密码不一样
                    msg=&quot;两次密码不一致&quot;
    
                else:
                    user.set_password(new_password)             # 修改密码
                    user.save()
    
                    return redirect(&quot;/index/&quot;)
            else:
                msg=&quot;旧密码输入错误&quot;
    
        return render(request,&quot;change_passwd.html&quot;,{&quot;msg&quot;:msg})&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 05 Oct 2017 13:01:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/7629997.html</dc:identifier>
</item>
<item>
<title>最接近原生APP体验的高性能前端框架-MUI - 炫彩小zyy</title>
<link>http://www.cnblogs.com/zzzzyy/p/7629815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzzyy/p/7629815.html</guid>
<description>&lt;p&gt;&lt;span&gt;下载已打包好的Hello mui 手机app，直接在手机上体验mui的控件UI及能力展示  http://dcloud.io/hellomui/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;可从&lt;a href=&quot;http://www.dcloud.io/&quot;&gt;https://www.dcloud.io&lt;/a&gt;下载Hbuilder，选择新建“移动APP”，并选择“Hello MUI”工程模板，创建工程；然后通过数据线将手机连接上电脑，点击运行，就可以在手机上体验MUI的各项能力。&lt;/p&gt;&lt;p&gt;在Hbuilder中，新建HTML文件，选择”含mui的HTML“模板，可以快速生成mui页面模板，该模板默认处理了mui的js、css资源引用。&lt;/p&gt;&lt;p&gt;顶部标题栏是每个页面都必需的内容，在Hbuilder中输入mheader，可以快速生成顶部导航栏。&lt;/p&gt;&lt;p&gt;除顶部导航、底部选项卡两个控件之外，其它控件都建议放在&lt;code&gt;.mui-content&lt;/code&gt;控件内，在Hbuilder中输入mbody，可快速生成包含&lt;code&gt;.mui-content&lt;/code&gt;的代码块。&lt;/p&gt;&lt;p&gt;折叠面板从二级列表中演化而来，dom结构和二级列表类似，如下：&lt;/p&gt;&lt;div readability=&quot;89.367963863794&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;ul class=&quot;mui-table-view&quot;&amp;gt; 
        &amp;lt;li class=&quot;mui-table-view-cell mui-collapse&quot;&amp;gt;
            &amp;lt;a class=&quot;mui-navigate-right&quot; href=&quot;#&quot;&amp;gt;面板1&amp;lt;/a&amp;gt;
            &amp;lt;div class=&quot;mui-collapse-content&quot;&amp;gt;
                &amp;lt;p&amp;gt;面板1子内容&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;可以在折叠面板中放置任何内容；折叠面板默认收缩，若希望某个面板默认展开，只需要在包含&lt;code&gt;.mui-collapse&lt;/code&gt;类的&lt;code&gt;li&lt;/code&gt;节点上，增加&lt;code&gt;.mui-active&lt;/code&gt;类即可；mui官网中的方法说明，使用的就是折叠面板控件&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h3 class=&quot;component-title&quot;&gt;list（列表）&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;1、普通列表&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;component-description&quot;&gt;&lt;span&gt;列表是常用的UI控件，mui封装的列表组件比较简单，只需要在&lt;code&gt;ul&lt;/code&gt;节点上添加&lt;code&gt;.mui-table-view&lt;/code&gt;类、在&lt;code&gt;li&lt;/code&gt;节点上添加&lt;code&gt;.mui-table-view-cell&lt;/code&gt;类即可，如下为示例代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;ul class=&quot;mui-table-view&quot;&amp;gt;
    &amp;lt;li class=&quot;mui-table-view-cell&quot;&amp;gt;Item 1&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;mui-table-view-cell&quot;&amp;gt;Item 2&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;mui-table-view-cell&quot;&amp;gt;Item 3&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;component-title&quot;&gt;图片轮播&lt;/h3&gt;
&lt;p class=&quot;component-description&quot;&gt;&lt;span&gt;图片轮播继承自slide插件，因此其DOM结构、事件均和slide插件相同&lt;/span&gt;；&lt;/p&gt;
&lt;h4&gt;DOM结构&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;默认不支持循环播放，DOM结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;mui-slider&quot;&amp;gt;
  &amp;lt;div class=&quot;mui-slider-group&quot;&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;1.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;2.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;3.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;4.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;&lt;span&gt;假设当前图片轮播中有1、2、3、4四张图片，从第1张图片起，依次向左滑动切换图片，当切换到第4张图片时，继续向左滑动，接下来会有两种效果：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持循环：左滑，直接切换到第1张图片；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不支持循环：左滑，无反应，继续显示第4张图片，用户若要显示第1张图片，必须连续向右滑动切换到第1张图片；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;当显示第1张图片时，继续右滑是否显示第4张图片，是同样问题；这个问题的实现需要通过&lt;code&gt;.mui-slider-loop&lt;/code&gt;类及DOM节点来控制；&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;component-description&quot;&gt;&lt;span&gt;若要支持循环，则需要在&lt;code&gt;.mui-slider-group&lt;/code&gt;节点上增加&lt;code&gt;.mui-slider-loop&lt;/code&gt;类，同时需要重复增加2张图片，图片顺序变为：4、1、2、3、4、1，代码示例如下&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;mui-slider&quot;&amp;gt;
  &amp;lt;div class=&quot;mui-slider-group mui-slider-loop&quot;&amp;gt;
    &amp;lt;!--支持循环，需要重复图片节点--&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;4.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;1.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;2.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;3.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;4.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;!--支持循环，需要重复图片节点--&amp;gt;
    &amp;lt;div class=&quot;mui-slider-item mui-slider-item-duplicate&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;img src=&quot;1.jpg&quot; /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为实现下拉刷新功能，大多数 H5 框架都是通过 DIV 模拟下拉回弹动画，在低端 android 手机上，DIV 动画经常出现卡顿现象（特别是图文列表的情况); mui 通过使用原生 webview 下拉刷新解决这个 DIV 动画的卡顿问题，并且拖动效果更加流畅；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里提供两种模式的下拉刷新，以适用不同场景：&lt;/p&gt;
&lt;h3 id=&quot;singleWVpull&quot; class=&quot;component-title&quot;&gt;&lt;span&gt;单 webview 模式&lt;/span&gt;&lt;/h3&gt;
&lt;ul readability=&quot;0.94423791821561&quot;&gt;&lt;li readability=&quot;1.9090909090909&quot;&gt;
&lt;h5&gt;&lt;span&gt;&lt;a&gt;动画原理：&lt;/a&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;component-description&quot;&gt;下拉刷新时，触发的是原生下拉刷新控件，而整个&lt;code&gt;webview&lt;/code&gt;位置不会发生变化，所以不会在拖动过程中发生DOM重绘，当控件拖动到一定位置触发动态加载数据以及刷新操作。此模式下拉刷新，相比双webview 模式，不创建额外 webview，性能更优。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;h5&gt;&lt;span&gt;&lt;a&gt;使用方法：&lt;/a&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;mui 初始化时设置&lt;code&gt;pullRefresh&lt;/code&gt;各项参数，与双 webview 模式的子页面设置是一样的。&lt;/p&gt;
&lt;div&gt;说明：
&lt;ol&gt;&lt;li&gt;DOM结构无特殊要求，只需要指定一个下拉刷新容器标识即可&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
mui.init({
  pullRefresh : {
    container:&quot;#refreshContainer&quot;,//下拉刷新容器标识，querySelector能定位的css选择器均可，比如：id、.class等
    down : {
      style:'circle',//必选，下拉刷新样式，目前支持原生5+ ‘circle’ 样式
      color:'#2BD009', //可选，默认“#2BD009” 下拉刷新控件颜色
      height:'50px',//可选,默认50px.下拉刷新控件的高度,
      range:'100px', //可选 默认100px,控件可下拉拖拽的范围
      offset:'0px', //可选 默认0px,下拉刷新控件的起始位置
      auto: true,//可选,默认false.首次加载自动上拉刷新一次
      callback :pullfresh-function //必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
    }
  }
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;&lt;span&gt;&lt;a&gt;模式说明：&lt;/a&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;disc&quot;&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;优点：&lt;br/&gt;&lt;/span&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;性能更优，体现在两点：
&lt;ol&gt;&lt;li&gt;相比双webview，不创建额外子 webview 性能消耗更少&lt;/li&gt;
&lt;li&gt;下拉拖动过程中不会发生重绘，也减少了性能消耗&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;缺点：&lt;/span&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;目前仅支持‘cricle’样式以及该样式的颜色自&lt;/span&gt;定义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3 id=&quot;doubleWVpull&quot; class=&quot;component-title&quot;&gt;&lt;span&gt;双 webview 模式&lt;/span&gt;&lt;/h3&gt;
&lt;ul readability=&quot;0.4814585908529&quot;&gt;&lt;li readability=&quot;1.9266503667482&quot;&gt;
&lt;h5&gt;&lt;a&gt;&lt;span&gt;动画原理&lt;/span&gt;：&lt;/a&gt;&lt;/h5&gt;
&lt;p class=&quot;component-description&quot;&gt;&lt;span&gt;使用双 webview 模式的下拉刷新，创建一个子 webview 添加列表；拖动时，拖动的是一个完整的 webview，避免了类似 DIV 拖动流畅度不好的问题，回弹动画使用原生动画；在 iOS 平台，H5 的动画已经比较流畅，故依然使用 H5 方案。两个平台实现虽有差异，但 mui 经过封装，可使用一套代码实现下拉刷新。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.81012658227848&quot;&gt;
&lt;h5&gt;&lt;span&gt;&lt;a&gt;&lt;span&gt;使用方法&lt;/span&gt;：&lt;/a&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;主页面内容比较简单，只需要创建子页面即可：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
mui.init({
    subpages:[{
      url:pullrefresh-subpage-url,//下拉刷新内容页面地址
      id:pullrefresh-subpage-id,//内容页面标志
      styles:{
        top:subpage-top-position,//内容页面顶部位置,需根据实际页面布局计算，若使用标准mui导航，顶部默认为48px；
        .....//其它参数定义
      }
    }]
});
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&lt;span&gt;iOS平台的下拉刷新，使用的是 mui 封装的区域滚动组件， 为保证两个平台的 DOM 结构一致，内容页面需统一按照如下 DOM 结构构建：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;div id=&quot;refreshContainer&quot; class=&quot;mui-content mui-scroll-wrapper&quot;&amp;gt;
  &amp;lt;div class=&quot;mui-scroll&quot;&amp;gt;
    &amp;lt;!--数据列表--&amp;gt;
    &amp;lt;ul class=&quot;mui-table-view mui-table-view-chevron&quot;&amp;gt;
      
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&lt;span&gt;其次，通过 mui.init 方法中 pullRefresh 参数配置下拉刷新各项参数，如下：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
mui.init({
  pullRefresh : {
    container:&quot;#refreshContainer&quot;,//下拉刷新容器标识，querySelector能定位的css选择器均可，比如：id、.class等
    down : {
      height:50,//可选,默认50.触发下拉刷新拖动距离,
      auto: true,//可选,默认false.首次加载自动下拉刷新一次
      contentdown : &quot;下拉可以刷新&quot;,//可选，在下拉可刷新状态时，下拉刷新控件上显示的标题内容
      contentover : &quot;释放立即刷新&quot;,//可选，在释放可刷新状态时，下拉刷新控件上显示的标题内容
      contentrefresh : &quot;正在刷新...&quot;,//可选，正在刷新状态时，下拉刷新控件上显示的标题内容
      callback :pullfresh-function //必选，刷新函数，根据具体业务来编写，比如通过ajax从服务器获取新数据；
    }
  }
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;&lt;span&gt;&lt;a&gt;模式说明：&lt;/a&gt;&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;disc&quot;&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;可&lt;span&gt;自定义下拉刷新样式，更改文字等等.参考关于自定义下拉刷新样式问答&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;缺点：&lt;/span&gt;
&lt;ul class=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;相比单 webview，性能消耗更大，不过都比 div 模式的要好用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DOM结构需要统一配置&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;本文只写了一部分常用控件，所以不是很全面，大家可以参考官方文档去详细了解细节。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 05 Oct 2017 11:07:00 +0000</pubDate>
<dc:creator>炫彩小zyy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzzyy/p/7629815.html</dc:identifier>
</item>
</channel>
</rss>