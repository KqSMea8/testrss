<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用 ConfigMap 管理配置 - 每天5分钟玩转 Docker 容器技术（159） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8925374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8925374.html</guid>
<description>&lt;p&gt;&lt;span&gt;Secret 可以为 Pod 提供密码、Token、私钥等敏感数据；对于一些非敏感数据，比如应用的配置信息，则可以用 ConfigMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConfigMap 的创建和使用方式与 Secret 非常类似，主要的不同是数据以明文的形式存放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 Secret 一样，ConfigMap 也支持四种创建方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-literal&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl create configmap myconfigmap --from-literal=config1=xxx --from-literal=config2=yyy&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-literal&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对应一个信息条目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;echo -n xxx &amp;gt; ./config1&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;echo -n yyy &amp;gt; ./config2&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;kubectl create configmap myconfigmap --from-file=./config1 --from-file=./config2&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;每个文件内容对应一个信息条目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-env-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; env.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;config1=xxx&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;config2=yyy&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;EOF&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;kubectl create configmap myconfigmap --from-env-file=env.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;env.txt&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中每行 Key=Value 对应一个信息条目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4. 通过 YAML 配置文件：&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424063948548-472005622.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;文件中的数据直接以明文输入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 Secret 一样，Pod 也可以通过 Volume 或者环境变量的方式使用 Secret。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Volume 方式：&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064007523-1945598930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;环境变量方式：&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064018712-665243110.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大多数情况下，配置信息都以文件形式提供，所以在创建 ConfigMap 时通常采用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 YAML 方式，读取 ConfigMap 时通常采用 Volume 方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如给 Pod 传递如何记录日志的配置信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064029052-687881626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以采用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 形式，则将其保存在文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;logging.conf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，然后执行命令：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl create configmap myconfigmap --from-file=./logging.conf&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;如果采用 YAML 配置文件，其内容则为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064038267-1117540705.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意别漏写了 Key &lt;/span&gt;&lt;code&gt;&lt;span&gt;logging.conf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 后面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;|&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 符号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建并查看 ConfigMap：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064047912-194935074.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Pod 中使用此 ConfigMap，配置文件为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064102889-2041225693.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① 在 volume 中指定存放配置信息的文件相对路径为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;myapp/logging.conf&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② 将 volume mount 到容器的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建 Pod 并读取配置信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180424064114513-1575281569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;配置信息已经保存到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc/myapp/logging.conf&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中。与 Secret 一样，Volume 形式的 ConfigMap 也支持动态更新，留给大家自己实践。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本章我们学习了如何向 Pod 传递配置信息。如果信息需要加密，可使用 Secret；如果是一般的配置信息，则可使用 ConfigMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Secret 和 ConfigMap 支持四种定义方法。Pod 在使用它们时，可以选择 Volume 方式或环境变量方式，不过只有 Volume 方式支持动态更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们将开始学习 Helm -- Kubernetes 的包管理器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://image.ipaiban.com/upload-ueditor-image-20171205-1512465642434079417.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 21:08:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8925374.html</dc:identifier>
</item>
<item>
<title>Optaplanner逐步学习(0) ： 基本概念 - Optaplanner,规划问题， 约束，方案 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/8800725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/8800725.html</guid>
<description>&lt;p&gt;　　之前的文章中，分别从APS，排产到规划引擎叙述了一些理论基础；并介绍了一些Optaplanner大概的情况；并一步步将Optaplanner的示例运行起来，将示例源码导进Eclipse分析了一下它的Hello world入门示例，从本篇开始，我们将分步学习它的一些概念及用法。&lt;/p&gt;

&lt;h2&gt;什么是Optaplanner&lt;/h2&gt;
&lt;p&gt;　　其实这个名称是作者将这个引擎贡献给了Jboss社区后，才使用的名，之前叫做Drools planner。没错，它就是结合Drools（一个开源规则引擎）一起应用的(也可以单独使用)，Drools在这里的作用主要是用来作编写计分脚本，事实上完全可以抛开Drools，直接使用Optaplanner自己的API，通过Java代码自己来计分，但这个难度就大得多。详细情况计到相应的章节再细说。&lt;/p&gt;
&lt;p&gt;　　名称的前缀应该是Optimize的词根，或取近音吧，因为Optaplanner其实就是一个对待规划的方案组合进行优化的引擎。好了，关于它的名称就不花费太多的口水去深究，我们看看官方是怎么定义Optaplanner的。&quot;OptaPlanner is a constraint solver. It optimizes business resource planning use cases, such as Vehicle Routing, Employee Rostering, Cloud Optimization, Task Assignment, Job Scheduling, Bin Packing and many more. &quot; - Optaplanner 是一个约束解决器，它可以优化业务资源，规划各种案例，例如车间调度，职员排班，云优化，任务分配，工作排程，装箱等相关的问题，例如下图。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201804/148283-20180419002608880-1961087093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而我对Optaplanner的理解，它是一个Planning Engine - 规划引擎，针对各行各业的业务需求，开发人员需要将一些业务规则翻译成约束，并对业务场景中的实体进行抽象建模，规划引擎根据上述约束和模型对象进行规划，找出一个相对最优化的方案出来返回给用户。其实如果需要规划的业务对象不多（种类和数量都不多），规则不太复杂，人类是可以通过自己的经验、推算和规则运行，得到一个可行方案的，甚至当问题规模足够小的时候，是可以找到一个最优方案的。关于规划问题，大家可以参考这个系统文章中的一篇入门介绍&lt;a href=&quot;http://www.cnblogs.com/kentzhang/p/8423405.html&quot; target=&quot;_blank&quot;&gt;《Optaplanner - 入门介绍》&lt;/a&gt;，里面讲到，规划问题其实就是数学上的NP问题或NPC问题，目前数据世界对于这种问题，是没有可用算法直接实现的，当问题足够大的时候，只能够通过一些寻优算法（例如爬山算法，模拟退火及遗传算法等）提高找到问题相对优解的机率。而Optaplanner正是一个集成了这类算法，实现快速赶寻找相对最优方案的引擎。它是一个轻量级的，可嵌入的规划引擎，也就是说你可以在自己的程序中通过Jar包直接和相关的配置项来直接使用Optapalnner. 当然，当你需要一个独立的，具有良好扩展性的规划服务组件时，可以直接使用Optaplanner建立自己的规划服务器，通过Spring等框架，对外提供规划服务。&lt;/p&gt;
&lt;p&gt;　　Optaplanner是基于&lt;a href=&quot;http://www.optaplanner.org/code/license.html&quot;&gt;Apache Software License&lt;/a&gt;.协议的，你可以直接使用它作为商业用途。并且它是使用纯Java编写的，最低功能要求下，只需安装一个JVM即可以使用Optapalnner了。并且它所有的包都可以从&lt;a href=&quot;http://www.optaplanner.org/download/download.html&quot; target=&quot;_blank&quot;&gt;Maven中央库&lt;/a&gt;中获得，即只需要建立一个Maven项目，简单配置好依赖项，就可以开始基于Optaplanner的开发了。&lt;/p&gt;
&lt;p&gt;下面，就开始对Optaplanner中概念进行逐一讲解.&lt;/p&gt;
&lt;h2&gt;什么是规划问题(Planning Problem)&lt;/h2&gt;
&lt;p&gt;　　规划问题是 - 基于有限资源，及指定约束条件下达到优化目标（包括资源、排程安排等优化）.，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大化利润&lt;/li&gt;
&lt;li&gt;最小化对生态环境的影响&lt;/li&gt;
&lt;li&gt;提高员工及客户的满意度&lt;/li&gt;
&lt;li&gt;........&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　要实现这些目标，需要以下条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;人员&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;li&gt;预算（资金)&lt;/li&gt;
&lt;li&gt;物理资产（例如机台、汽车，电脑，建筑等等）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图是Optaplanner官网对规划问题的定义：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201804/148283-20180419224451521-1720008415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　上面是对官网的一些翻译。通俗地讲,规划问题就是：&lt;/p&gt;
&lt;p&gt;1. 存在一堆对象，例如：任务、人员、资源等，以后称作规划实体 - 官方称planning entity；&lt;/p&gt;
&lt;p&gt;2. 还存在一些条件规则，例如：任务最迟需要什么时候完成，人员每天最多只能上班8小时，在指定的时间段内资源是有限的。以后称约束 - 官方称Constraint&lt;/p&gt;
&lt;p&gt;3. 根据上述第2点的条件，对第1点所述的规划实体进行资源分配和时间安排，例如,哪个任务应该安排在哪个机台上，在什么时候开始作业；哪个人员安排在哪个车间的哪个班次；哪种资源（例如：机台、原料等）需要确保在哪个时间送到哪个车间等。&lt;/p&gt;
&lt;p&gt;　　上述第3点所做的工作就是一个规划的过程，也就是引擎会根据约束的限制和规划实体的特性，对这些规划实体进行时间或/和空间上的规划；这个就是规划过程。而我们面对的这些规划实体和这些约束的结合体，就称作规划问题。例如：排定下个学期每个年级的课程表，令每个课程的老师不会出现同一时候分配到不同的班级上课。现有一堆外卖，规划好各个骑手的取餐、送餐路线，令每个骑手都以尽量小的路程和时间成本送最多的单。这些都可以被视作规划问题。&lt;/p&gt;
&lt;h2&gt;规划实体与规划变量（Planning Entity &amp;amp; Planning Variable）&lt;/h2&gt;
&lt;p&gt;　　我们知道，规划问题，就是对一些规划实体进规划预计分配。例如编造排班表，是一个规划问题，那么抽象出来，一个工人就是一个规划实体(Planning Entity)了，它是被规划的对象。而工人在指定的时间在哪个车间上班，就是这个规划实体的规划变量(Planning vaiable)了。所以，其实解决这个规划问题的过程，就是针对每一个规划实体，根据约束及每个规划实体的情况，来给它的规划变量设置适当的值，令到所有规划实体的所有规划变量的组合达到整体最优。即是设定每个工人（规划实体），在哪个时间，去哪个车间上班（上班时间和车间就是规划变量）。&lt;/p&gt;
&lt;h2&gt;问题事实(Problem Fact)&lt;/h2&gt;
&lt;p&gt;　　问题事实是相对规则实体而言的，它也是一个业务实体，与规划实体不同的是，它只反映出业务情况，而在规划的过程中，不会被规划引擎进行修改。也就是说，问题事实只是用于提供资料，辅助规划引擎进行规划运算的。在整个规划过程，问题事实是只读的。例如规则班次计划的时间，其中的班次是在开始规则之前已经确定的，所以“班次”这个业务实体只会在规划过程中，提供每个班次具体的时间等信息，而不会改变的。那么“班次”这个业务实体，就是一个问题事实。&lt;/p&gt;
&lt;h2&gt;约束（硬约束与软约束）&lt;/h2&gt;
&lt;p&gt;　　上而我们把业务规则定义为约束，其实目前针对排程方面的规划问题，主要是通过约束进行评分机制的寻优方法。约束就是根据业务规则抽象出来，针对规划变量，在求解规划问题时候的一种限制，或惩罚机制。也就是说，约束是用来制约引擎对规划变量的赋值行为的。例如一个人不可能有超过24个小时的可用时间。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;硬约束&lt;/strong&gt;：硬约束是指那些不能违反的约束，违反了就会出现不符合常理，即业务可能出现绝不允许的情况出现。例如上面提高，一个人不可能有超过24小时的可用时间（常理）；机台运行过程中，机修工不能进行维修工作（涉及安全生产问题，法律及业务有硬性要求。）。因此，硬约束可以被人视为是用于对规则行为进行定义的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;软约束&lt;/strong&gt;：软约束是相对硬约束而言的，它是可违反的。设立软约束之目的并不是不允许它违反，而是定量地制约规划结果（结果，即是下面讲到的解或方案）的发展方向，起到对规划结果的偏向作用，即让规则结果尽量向指定的一个方向偏衙。也就是说在满足了硬约束的前提下，再对软约束进行判断，如果软约束能不违反就最好，要是必须违反，违反得越少，所得的方案就越好。例如成本高低就是一种软约束，生产运营中不可能不产生成本，那么如果成本越低，那么方案肯定越好，当然是在满足了硬约束的前提下。&lt;/p&gt;

&lt;h2&gt;规划问题其实是NP问题或NP-Hard问题&lt;/h2&gt;
&lt;p&gt;　　其实在&lt;a href=&quot;http://www.cnblogs.com/kentzhang/p/8423405.html&quot; target=&quot;_blank&quot;&gt;《Optaplanner - 入门介绍》&lt;/a&gt;中已经有讲解过关于NP或NP-Hard（那讲到NPC问题），大家可以去参考一下那篇文章。这时概括地重述一下，NP或NP-Hard问题是问题以下条件的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于一个给定的规划的结果（官网中称作solution, 即是解），很容易在合理的时间内对其进行验证是否可行。例如：课程表编排得正不正确，可以根据约束来核对一下就可以确定了，例如有没有出现同一个时间内，一个老师被分配到不同的班级上课。&lt;/li&gt;
&lt;li&gt;不存在一个可确定的方法，在合理的时间内找到一个最优解（这里指的是绝对最优解）。这个也不难理解，对于这种没有任何快捷方法找最优解的规划问题，我们唯一的办法就是把所有不同的组合情况全部排列出来，一个一个比较（即逐一枚举），那必然是可以找到最优解的。但是，因为这种方法其实是一种暴力穷举法，当问题非常复杂、且需要规划的实体数量非常多时，它的时间复杂度是随着组合情况的增加，逞指数式上升的，暴力穷举的方法是不可取的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;规划问题布在巨量搜索空间&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;搜索空间：&lt;/strong&gt;&lt;/span&gt;因为目前针对规划问题，只能通过搜索的方式去寻找相对最优解，因为相对一些直接通过算法操作得到的办法而言，规划问题只能将它的解一个一个地对比，逐步收敛逼近的办法来得到相对最优解。所以，你可以认为规划问题的相对最优解是搜索出来的，而且每一步搜索都需要对约束进行运算；从所有经历过的解中，找到相对最优一个。所以规划问题存在一个搜索空间的问题，即有多少种可能的解，就表示搜索空间有多大。例如将3个任务分配到两个机台上，存在多少种可能？大家可以自己去算，其实就是排列组合问题。&lt;/p&gt;
&lt;p&gt;　　而对实际问题时，稍复杂的约束，稍多一点的规划实体，最后得出的可能解的数量都是非常巨大的，很多问题其搜索空间轻易就是一个天文数字。所以，如果对于所有规则问题，都是使用这些暴力枚举的办法，以现有世界上的计算机的算力，很多问题是没办法找到最优解的。&lt;/p&gt;
&lt;p&gt;　　规划问题的规模，即是规划实体及每个实体的规划变量的组合，例如时间、空间，及影响因素，及这些因素的所有情况组合。例如，如果上述所有实体，规划的变量和所有因素，展开后的数量是M，而一个解是对其中的N个变量进行规划，那么有多少个解呢？其实就是M到N的排列P(M-&amp;gt;N).当遇到实际问题的，这些组合的数量就是天文数字了。&lt;/p&gt;
&lt;h2&gt;可能解，可行解，相对最优解与绝对最优解&lt;/h2&gt;
&lt;p&gt;　　在规则问题中，需要清楚解的概念，在Optaplanner里称作solution, 即方案。在本系列文章中，解与方案是相同的意义，请注意。本猿只是根据中文表达的习惯，在不同的场合以最顺口的方式，视情况确定到底应用用“解”，还是“方案”来表述。&lt;/p&gt;
&lt;p&gt;　　在接下来的一系列文章中，我在讲解这些方案的过程中，会用到以下概念：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;可能解：&lt;/strong&gt;&lt;/span&gt;一个规划问题的任意一个解都称为可能解，也就是所有规则实体的所有规则变量，任意一个组合，都称作一个可能解。例如分配工人A，在1月20日晚班，到1号车间；分配工人A在1月20日晚班到2号车间；分别是两个不同的可能解，尽管它们的差别只是分配到不同的车间.而每个工人的每个班次的工作车间，正好是规划变量。所以任意一个规划变量的不同，都会产生不同的可能解。现在知道为什么规划问题存在巨量搜索空间了吧？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;可行解：&lt;/strong&gt;&lt;/span&gt;可行解就是那些完全符合硬约束的解。即若存在一个解，它对任何一个硬约束都是符合的，则称这个解为可行解。可行解是可能解的一个子集。可行解是可验证的，只要根据目前所有的硬约束，对解中的每一个规划实体中的每个规划变量，逐一核对，看是否符合所有硬约束，如果符合，那就表示这个解是可行解。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;相对最优解：&lt;/span&gt;&lt;/strong&gt;上面已经提，规划问题的搜索空间非常巨量，大多数情况下是不可能计算并比较所有解的值，再取得最佳方案（这个解就是绝对最优解）的。那以在我们固定的时间内，Optaplanner引擎帮我们找到的最优方案，就是称作相对最优解了。大家来思考一下，相对最优解必然是可行解吗？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;绝对最优解：&lt;/strong&gt;&lt;/span&gt;同样的上面提到，就是所有可能解中最优的那个解，目前是没有直接确定的算法，通过运算在合理的时间内去找到一个问题的绝对最优解的，所以要得到绝对最优解，只有一个办法，就是将所有可能解都遍历一次才能找到。当问题规模不算大的时候，以目前的CPU速度还是能实现的。但如果问题稍复杂一点，规划实体和规划变量稍多一点，那么可能解的数量就是一个天文数字了，这种情况下是没办法完全遍历的。所以，在我们现实中，我们是无法得到绝对最优解的。其实更贴切地说，我们所得到的相对最优解，我们不知道它是不是绝对最优解。因为现在数学上还没有办法（除了遍历）证明一个相对最优解是否绝对最优。&lt;/p&gt;

&lt;p&gt;本篇先介绍一下上述两个概念，下一篇将我们再具体介绍其它概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创不易，如果觉得文章对你有帮助，欢迎点赞、评论。&lt;/strong&gt;文章有疏漏之处，欢迎批评指正。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明原文链接：http://www.cnblogs.com/kentzhang/p/8800725.html&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 16:52:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/8800725.html</dc:identifier>
</item>
<item>
<title>实验：利用ASMLib创建ASM磁盘 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8934777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8934777.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;RHEL 6.5 + Oracle 11.2.0.4 RAC（2 nodes）&lt;br/&gt;&lt;strong&gt;目的：&lt;/strong&gt;在实验环境使用ASMLib配置共享ASM磁盘，虽然我们已经不建议使用ASMLib进行绑盘，但是无奈有客户是这样做的，而作为一名合格的乙方技术人员，我们是需要熟悉不同技术（包括这种已经不再推荐使用的技术）从而更好的为甲方服务。&lt;/p&gt;

&lt;p&gt;安装ASMLib一共需要3个rpm包，分别是kmod-oracleasm，oracleasmlib和oracleasm-support，注意选择合适的版本安装，比如我这里环境：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac1 tmp]# rpm -ivh oracleasm-support-2.1.8-1.el6.x86_64.rpm 
warning: oracleasm-support-2.1.8-1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID ec551f03: NOKEY
Preparing...                ########################################### [100%]
   1:oracleasm-support      ########################################### [100%]
[root@jystdrac1 tmp]# rpm -ivh kmod-oracleasm-2.0.6.rh1-3.el6_5.x86_64.rpm 
warning: kmod-oracleasm-2.0.6.rh1-3.el6_5.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY
Preparing...                ########################################### [100%]
   1:kmod-oracleasm         ########################################### [100%]
[root@jystdrac1 tmp]# rpm -ivh oracleasmlib-2.0.4-1.el6.x86_64.rpm 
warning: oracleasmlib-2.0.4-1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID ec551f03: NOKEY
Preparing...                ########################################### [100%]
   1:oracleasmlib           ########################################### [100%]
[root@jystdrac1 tmp]# &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节点2用同样的步骤安装这三个rpm软件包，不再赘述。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 ASMLib的配置如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac1 ~]# /etc/init.d/oracleasm configure
Configuring the Oracle ASM library driver.

This will configure the on-boot properties of the Oracle ASM library
driver.  The following questions will determine whether the driver is
loaded on boot and what permissions it will have.  The current values
will be shown in brackets ('[]').  Hitting &amp;lt;ENTER&amp;gt; without typing an
answer will keep that current value.  Ctrl-C will abort.

Default user to own the driver interface [grid]: 
Default group to own the driver interface [asmadmin]: 
Start Oracle ASM library driver on boot (y/n) [y]: 
Scan for Oracle ASM disks on boot (y/n) [y]: 
Writing Oracle ASM library driver configuration: done
Initializing the Oracle ASMLib driver: [  OK  ]
Scanning the system for Oracle ASMLib disks: 
[  OK  ]

--节点2同样：
[root@jystdrac2 ~]# /etc/init.d/oracleasm configure
Configuring the Oracle ASM library driver.

This will configure the on-boot properties of the Oracle ASM library
driver.  The following questions will determine whether the driver is
loaded on boot and what permissions it will have.  The current values
will be shown in brackets ('[]').  Hitting &amp;lt;ENTER&amp;gt; without typing an
answer will keep that current value.  Ctrl-C will abort.

Default user to own the driver interface []: grid
Default group to own the driver interface []: asmadmin
Start Oracle ASM library driver on boot (y/n) [y]: y
Scan for Oracle ASM disks on boot (y/n) [y]: y
Writing Oracle ASM library driver configuration: done
Initializing the Oracle ASMLib driver: [  OK  ]
Scanning the system for Oracle ASMLib disks: [  OK  ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2 使用oracleasm createdisk创建ASM磁盘：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac1 ~]# /etc/init.d/oracleasm createdisk VOL1 /dev/sdb1
Marking disk &quot;VOL1&quot; as an ASM disk: [  OK  ]
[root@jystdrac1 ~]# /etc/init.d/oracleasm deletedisk VOL1
Removing ASM disk &quot;VOL1&quot;: [  OK  ]

--我这里环境有7块盘，ASMLib使用的盘需要分区，每块盘整个分一个区即可：
/etc/init.d/oracleasm createdisk OCR1 /dev/sdb1
/etc/init.d/oracleasm createdisk OCR2 /dev/sdc1
/etc/init.d/oracleasm createdisk OCR3 /dev/sdd1
/etc/init.d/oracleasm createdisk DATA1 /dev/sde1
/etc/init.d/oracleasm createdisk DATA2 /dev/sdf1
/etc/init.d/oracleasm createdisk DATA3 /dev/sdg1
/etc/init.d/oracleasm createdisk FRA1 /dev/sdh1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.3 使用oracleasm scandisks扫盘然后listdisks列出&lt;/strong&gt;&lt;br/&gt;/etc/init.d/oracleasm scandisks&lt;br/&gt;/etc/init.d/oracleasm listdisks&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac2 ~]# /etc/init.d/oracleasm scandisks
Scanning the system for Oracle ASMLib disks: [  OK  ]
[root@jystdrac2 ~]# /etc/init.d/oracleasm listdisks
DATA1
DATA2
DATA3
FRA1
OCR1
OCR2
OCR3
[root@jystdrac2 ~]# &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.4 使用oracleasm querydisk查询磁盘是否有效&lt;/strong&gt;&lt;br/&gt;/etc/init.d/oracleasm querydisk&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac2 rules.d]# /etc/init.d/oracleasm querydisk DATA1
Disk &quot;DATA1&quot; is a valid ASM disk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.5 parted分区的示例&lt;/strong&gt;&lt;br/&gt;既然ASMLib需要使用分区过的，那就使用parted对每块LUN进行分区，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac1 ~]# parted /dev/sdh
GNU Parted 2.1
Using /dev/sdh
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) mklabel gpt                                                      
(parted) p                                                                
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sdh: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number  Start  End  Size  File system  Name  Flags

(parted) mkpart primary 0-1                                               
End? 5369M                                                                
Warning: The resulting partition is not properly aligned for best performance.
Ignore/Cancel? I                                                          
(parted) p                                                                
Model: ATA VBOX HARDDISK (scsi)
Disk /dev/sdh: 5369MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt

Number  Start   End     Size    File system  Name     Flags
 1      17.4kB  5369MB  5369MB               primary

(parted) q                                                                
Information: You may need to update /etc/fstab.    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.6 oracleasm命令&lt;/strong&gt;&lt;br/&gt;/etc/init.d/oracleasm {start|stop|restart|enable|disable|configure|createdisk|deletedisk|querydisk|listdisks|scandisks|status}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@jystdrac2 ~]# /etc/init.d/oracleasm
Usage: /etc/init.d/oracleasm {start|stop|restart|enable|disable|configure|createdisk|deletedisk|querydisk|listdisks|scandisks|status}
[root@jystdrac2 ~]# /etc/init.d/oracleasm status
Checking if ASM is loaded: yes
Checking if /dev/oracleasm is mounted: yes
[root@jystdrac2 ~]# &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;diskstrings设置为ORCL:*，正常就可以看到类似下面这样的ASM盘：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_OCR.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 16:39:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8934777.html</dc:identifier>
</item>
<item>
<title>Android.mk 详解 - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/8934735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/8934735.html</guid>
<description>&lt;p&gt;Android中增加本地程序或者库，这些程序与其所在路径没有关系，只和它们的Android.mk有关系。&lt;br/&gt;Android.mk与普通的makefile略有不同，Android.mk具有统一的写法，主要包含一些系统的公共的宏：&lt;br/&gt;Android.mk中选项参考以下文件路径：&lt;br/&gt;build/core/config.mk&lt;br/&gt;各个选项的默认值在以下文件中定义：&lt;br/&gt;build/core/base_config.mk&lt;br/&gt;在一个android.mk中也可以生成多个可执行程序，动态库，静态库。&lt;/p&gt;
&lt;h2 id=&quot;编译程序&quot;&gt;1.编译程序：&lt;/h2&gt;
&lt;h3 id=&quot;可执行程序模板&quot;&gt;1.1 可执行程序模板：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_PATH)
LOCAL_SRC_FILES := \
                    main.c
LOCAL_MODULE := test_exe
#LOCAL_C_INCLUDES := 
#LOCAL_STATIC_LIBRARIES := 
#LOCAL_SHARED_LIBRARISE := 
include $(BUILD_STATIC_LIBRAR)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;LOCAL_PATH:= $(call my-dir)&lt;/p&gt;
&lt;p&gt;此行代码在Android.mk的开头，用于给出当前文件的路径:&lt;br/&gt;LOCAL_PATH：&lt;br/&gt;用于在开发树中查找源文件；&lt;br/&gt;宏函数’my-dir’:&lt;br/&gt;由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）&lt;br/&gt;---&lt;br/&gt;LOCAL_C_INCLUDES：&lt;br/&gt;表示要加入所需要的包含头文件的路径&lt;br/&gt;---&lt;br/&gt;LOCAL_MODULE：&lt;br/&gt;表示模块最后最终名称&lt;br/&gt;---&lt;br/&gt;LOCAL_STATIC_LIBRARIES：&lt;br/&gt;加入所需要的连接的静态库&lt;br/&gt;---&lt;br/&gt;LOCAL_SHARED_LIBRARISE：&lt;br/&gt;加入所需要的动态库&lt;br/&gt;最后使用include $(BUILD_EXECUTABLE)表示以一个可执行程序的方式进行编译；最终生成的静态库为libtest_static.a；&lt;/p&gt;
&lt;h3 id=&quot;编译一个静态库&quot;&gt;1.2 编译一个静态库&lt;/h3&gt;
&lt;p&gt;在Android.mk中编译一个静态库的模板如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_PATH)
LOCAL_SRC_FILES := \
                    main.c
LOCAL_MODULE := libtest_static
#LOCAL_C_INCLUDES := 
#LOCAL_STATIC_LIBRARIES := 
#LOCAL_SHARED_LIBRARISE := 
include $(BUILD_STATIC_LIBRARY)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译一个动态库&quot;&gt;1.3 编译一个动态库&lt;/h3&gt;
&lt;p&gt;在Android.mk中编译一个动态库的模板如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_PATH)
LOCAL_SRC_FILES := \
                    helloworld.c
LOCAL_MODULE := libtest_shared
TARGET_PRELINK_MODULE := false
#LOCAL_C_INCLUDES := 
#LOCAL_STATIC_LIBRARIES := 
#LOCAL_SHARED_LIBRARISE := 
include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，最终生成的动态库的名称是libtest_shared.so；&lt;/p&gt;
&lt;h3 id=&quot;编译结果&quot;&gt;1.4 编译结果&lt;/h3&gt;
&lt;p&gt;可执行程序、静态库、动态库生成的编译结果分别为以下目录：&lt;br/&gt;out/target/product/xxxx/obj/EXECUTABLE&lt;br/&gt;out/target/product/xxxx/obj/STATIC_LIBRARY&lt;br/&gt;out/target/product/xxxx/obj/SHARED_LIBRARY&lt;/p&gt;
&lt;p&gt;每一个模块的目标文件夹分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可执行文件：{XXX}_intermediates&lt;/li&gt;
&lt;li&gt;静态库： {XXX}_static_intermediates&lt;/li&gt;
&lt;li&gt;动态库：{XXX}_shared__intermediates&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在编译过程中，可以编译目标机的内容，也可以编译主机的内容，可执行文件、动态库、静态库使用宏分别如下所示 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;include $(BUILD_EXECUTABLE)
include $(BUILD_STATIC_LIBRARY)
include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译主机的内容，可执行文件、动态库、静态库使用宏分别如下所示 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;include $(BUILD_HOST_EXECUTABLE)
include $(BUILD_HOST_STATIC_LIBRARY)
include $(BUILD_HOST_SHARED_LIBRARY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在android.mk中，可以指定最后目标安装路径，使用以下两个宏来指定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)  
LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同文件系统使用以下宏来进行选择：&lt;/p&gt;
&lt;h2 id=&quot;安装程序&quot;&gt;2.安装程序：&lt;/h2&gt;
&lt;p&gt;除了编译各种内容外，有时还需要向目标文件系统复制一些文件，例如配置脚本、资源文件、预置的程序和库等，也有时需要在目标文件系统中创建目录；&lt;br/&gt;在Android.mk，进行目录创建和安装的实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOCAL_PATH := $(call my-dir)
include $(CLEAR_PATH)
xxx（这里使用正常makefile语法来编写copy动作或者创建动作）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情看：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/linhaostudy/p/7218515.html&quot;&gt;一个通用的makefile（一）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/linhaostudy/p/7760413.html&quot;&gt;一个通用的Makefile（二）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 16:23:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/8934735.html</dc:identifier>
</item>
<item>
<title>移动端引入的字体文件过大处理方法 - wolfSoul</title>
<link>http://www.cnblogs.com/yuqing6/p/8934531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuqing6/p/8934531.html</guid>
<description>&lt;h2&gt;一.背景&lt;/h2&gt;
&lt;p&gt;前端开发的同学,我们经常会碰到需要还原设计稿中的特殊字体.这时,我们可能会采用两种方案&lt;br/&gt;1.使用photoshop将文本图层单独导出成图片;　　2.直接引入改字体的字体库.ttf文件&lt;/p&gt;
&lt;p&gt;　　首先第一种方案的缺点,使用图片代替文字,制作和维护的成本很高,前期切图,合并雪碧图比较繁琐,后期修改和维护更是麻烦.同时使用图片,会带来更多的宽带消耗.用户体验方面,用户无法进行文字的选择,复制等操作,体验也不好.&lt;br/&gt;　　第二种方案,解决了上述的一些问题,但是由于汉字数量太大,导致中文字体文件也较大,通常都会有几M大小,不适合在项目中使用.尤其是移动端项目,由于字体加载速度很慢,体验会十分不好.本篇博客将介绍两种自动化工具,来实现在移动端愉快的使用特殊字体.分别是Font-Spider(字蛛)和fontmin.&lt;/p&gt;
&lt;h2&gt;二.浏览器对字体的支持&lt;/h2&gt;
&lt;p&gt;不同浏览器对字体的支持不同,所以我们要对不同的浏览器制作不同的字体.下图是浏览器对字体的支持情况.其中N为不支持,P为部分支持,Y为支持.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1055753/201804/1055753-20180424234156130-313207874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.Font-Spider(字蛛)&lt;/h2&gt;
&lt;p&gt;字蛛通过分析本地 CSS 与 HTML 文件获取 WebFont 中没有使用的字符，并将这些字符数据从字体中删除以实现压缩，同时生成跨浏览器使用的格式。Font-Spider的使用方法很简单,官网介绍的也很详细,下面简单介绍,也可直接去&lt;a title=&quot;字蛛官网&quot; href=&quot;http://font-spider.org/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;查看.&lt;/p&gt;
&lt;h4&gt;1.首先,全局安装font-slider&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install font-spider -g
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.在css中使用&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;声明 WebFont&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@font&lt;/span&gt;-&lt;span&gt;face {
  font&lt;/span&gt;-family: 'pinghei'&lt;span&gt;;
  src: url(&lt;/span&gt;'../font/pinghei.eot'&lt;span&gt;);
  src:
    url(&lt;/span&gt;'../font/pinghei.eot?#font-spider') format('embedded-opentype'&lt;span&gt;),
    url(&lt;/span&gt;'../font/pinghei.woff') format('woff'&lt;span&gt;),
    url(&lt;/span&gt;'../font/pinghei.ttf') format('truetype'&lt;span&gt;),
    url(&lt;/span&gt;'../font/pinghei.svg') format('svg'&lt;span&gt;);
  font&lt;/span&gt;-&lt;span&gt;weight: normal;
  font&lt;/span&gt;-&lt;span&gt;style: normal;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用选择器指定字体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
.home h1, .demo &lt;/span&gt;&amp;gt;&lt;span&gt; .test {
    font&lt;/span&gt;-family: 'pinghei'&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;提示: @font-face 中的 src 定义的 .ttf 文件必须存在，其余的格式将由工具自动生成&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.运行font-slider命令&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
font-spider ./demo/*.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面依赖的字体将会自动压缩好，原来几M的字体文件现在只剩下几k了, 是不是很爽呢. &lt;/p&gt;
&lt;h4&gt;4.使用gulp,grunt插件&lt;/h4&gt;
&lt;p&gt;　　除了直接进行编译,font-slider还提供了gulp和grunt的插件,可以更方便的在项目中使用,具体使用可直接到github查看&lt;/p&gt;
&lt;p&gt;字蛛 grunt 插件: &lt;a title=&quot;https://github.com/aui/grunt-font-spider&quot; href=&quot;https://github.com/aui/grunt-font-spider&quot; target=&quot;_blank&quot;&gt;https://github.com/aui/grunt-font-spider&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;字蛛 gulp 插件:&lt;a title=&quot;https://github.com/aui/gulp-font-spider&quot; href=&quot;https://github.com/aui/gulp-font-spider&quot; target=&quot;_blank&quot;&gt;https://github.com/aui/gulp-font-spider&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;5.使用的局限&lt;/h4&gt;
&lt;p&gt;　　font-slider虽然好用,但是由于其原理是直接分析&lt;strong&gt;本地&lt;/strong&gt; CSS 与 HTML 文件获取没有WebFont中没有使用过的字符,这样一来,对于动态生成的文字,就没有办法使用font-slider了.这是个坏消息!尤其在当下,很多框架都是数据驱动的,更是很多文字都不会直接出现html文件中.对于这种情况, 下面介绍的fontmin或许能解决.&lt;/p&gt;
&lt;h2&gt;四.使用Fontmin&lt;/h2&gt;
&lt;p&gt;　　Fontmin 是由百度推出的一个字体子集化方案。使用fontmin可以按需提取字体中的部分字型，最小化打包字体，自动生成 WebFont 字体文件（ttf/woff/eot/svg）和 CSS 文件, 并可利用 @font-face 将自定义字体呈现到网页中，提升网页文字体验。Fontmin 提供了 Node.js 模块和客户端 2 种使用方法,下面主要介绍Node.js模块的使用,更多使用请移步到&lt;a href=&quot;http://efe.baidu.com/blog/fontmin-getting-started/&quot; target=&quot;_blank&quot;&gt;Fontmin快速指南&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;1.安装fontmin&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i -g fontmin
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.配置&lt;/h4&gt;
&lt;p&gt;在项目中创建fontmin.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Fontmin = require('fontmin'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; srcPath = 'font/*.ttf'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体源文件路径&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; destPath = 'font';    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体输出路径&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; text = '我你今天中大奖了快来领红包';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有哪些文字可能需要用到这个字体的,都可以在这里进行配置&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fontmin = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fontmin()
    .src(srcPath)               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入配置&lt;/span&gt;
    .use(Fontmin.glyph({        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字型提取插件&lt;/span&gt;
        text: text              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所需文字&lt;/span&gt;
&lt;span&gt;    }))
    .use(Fontmin.ttf2eot())     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; eot 转换插件&lt;/span&gt;
    .use(Fontmin.ttf2woff())    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; woff 转换插件     &lt;/span&gt;
    .use(Fontmin.ttf2svg())     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; svg 转换插件&lt;/span&gt;
    .use(Fontmin.css())         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; css 生成插件&lt;/span&gt;
    .dest(destPath);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出配置&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
fontmin.run(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, files, stream) {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) {                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异常捕捉&lt;/span&gt;
&lt;span&gt;        console.error(err);
    }

    console.log(&lt;/span&gt;'done');        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.输出&lt;/h4&gt;
&lt;p&gt;执行fontmin.js文件就可以配置好的目录下输出对应的字体及css文件,字体文件也会由原来的即M变成几k了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
node fontmin.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fontmin还提供了客户端, 直接把 &lt;code&gt;TTF&lt;/code&gt; 拖进去，左侧输入需要文字，右侧实时看效果。点击生成，一步搞定. 建议还是使用node模块的方式, 只要在项目中配置好, 以后再有任何文字需要使用字体, 直接添加到fontmin.js中的text中,执行node fontmin.js命令就搞定了.&lt;/p&gt;
&lt;h4&gt;4.缺点&lt;/h4&gt;
&lt;p&gt;Fontmin适用于文字不经常变动, 或者在一定范围内变动的情况, 如果文字经常变，而且没有固定的范围，那么也是没有办法的。 &lt;/p&gt;


&lt;p&gt;更多性能优化文章,欢迎移步到:&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/yuqing6/p/8605870.html&quot; target=&quot;_blank&quot;&gt;性能优化之reflow和repaint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/yuqing6/p/8463113.html&quot; target=&quot;_blank&quot;&gt;使用performance进行网页性能监控&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 24 Apr 2018 15:46:00 +0000</pubDate>
<dc:creator>wolfSoul</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuqing6/p/8934531.html</dc:identifier>
</item>
<item>
<title>JSON概述 - zhengyeye</title>
<link>http://www.cnblogs.com/zhengyeye/p/8934528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengyeye/p/8934528.html</guid>
<description>&lt;p&gt;错误理解：&lt;/p&gt;
&lt;h6&gt;&lt;strong&gt;一直以为JSON就是对象，拥有跟js对象类似的特征：{key:value}的形式，&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;以至于在自己的思维定式中就出现了一种很可怕的情景：居然不知道怎么去解释习以为常的json是个什么？各种混淆，结果---&amp;gt;后果很严重。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;概念区分：&lt;/h2&gt;
&lt;p&gt;1.JSON：（JavaScript Object Notation，js对象表示法）；&lt;/p&gt;
&lt;p&gt;2.JSON是一种数据格式，而不是一种编程语言；&lt;/p&gt;
&lt;p&gt;3.JSON与js具有相同的语法格式，但是JSON并不从属于js；&lt;/p&gt;
&lt;p&gt;4.并非只有js才使用JSON，很多编程语言都有针对JSON的解析器和序列化器。&lt;/p&gt;
&lt;p&gt;JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 &quot;&quot; 包裹，使用冒号 : 分隔，然后紧接着值。&lt;/p&gt;
&lt;h2&gt;语法：&lt;/h2&gt;
&lt;p&gt;JSON的语法可以表示以下三种类型的值：&lt;/p&gt;
&lt;p&gt;1.简单值；&lt;/p&gt;
&lt;p&gt;2.对象；&lt;/p&gt;
&lt;p&gt;3.数组。&lt;/p&gt;
&lt;h6&gt;错误理解：墨守成规的以为JSON只是个对象或者数组，然后以数组或者对象的标准来衡量它，&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;但却没有考虑它们之间的差异性，最后“一失足成千古恨”。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;举例说明：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.简单值：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 5&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是JSON表示数值5的方式；&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &quot;Hello world&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JSON表示字符串的过程 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;1）js字符串与JSON字符串的最大区别：&lt;strong&gt;&lt;span&gt;JSON字符串必须使用双引号&lt;/span&gt;&lt;/strong&gt;（单引号会导致语法错误）；&lt;/p&gt;
&lt;p&gt;2）布尔值与null也是有效的JSON形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①js中的对象字面量（&lt;strong&gt;&lt;span&gt;是不是自己内心想象的JSON对象？key:value形式，error！&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;{&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; name:&quot;王五&quot;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; age:22 &lt;span&gt;4&lt;/span&gt; }&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;②JSON中的对象要求给属性加引号：&lt;/p&gt;
&lt;p&gt;所以上面的的对象字面量又可以这样表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &quot;name&quot;:&quot;王五&quot;&lt;span&gt;,  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &quot;age&quot;:22};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSON表示上述对象的方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &quot;name&quot;:&quot;王五&quot;&lt;span&gt;,  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;      &quot;age&quot;:22
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比一下，有区别吗？&lt;/p&gt;
&lt;p&gt;1.JSON中没有变量的概念，故并没有声明变量；&lt;/p&gt;
&lt;p&gt;2.末尾没有分号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;谨记：对象的属性必须加双引号。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.数组：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSON数组采用JS中的数组字面量形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; values = [25,&quot;hello&quot;,&lt;span&gt;true&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js中的数组字面量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [25,&quot;hello&quot;,&lt;span&gt;true&lt;/span&gt;]    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JSON中的数组表示&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;果然，JSON数组中既没有变量也没有分号。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; 解析与序列化&lt;/h2&gt;
&lt;p&gt;1.JSON.stringify();&lt;/p&gt;
&lt;p&gt;2.JSON.parse();&lt;/p&gt;
&lt;p&gt;3.toJSON.&lt;/p&gt;
&lt;p&gt;是不是耳熟能详的方法？还好有机会重温一下，也好改正自己的短处：&lt;/p&gt;
&lt;p&gt;        1.JSON对象有两个方法：stringify()以及parse(),其实就是把js对象序列化为JSON字符串和把JSON字符串解析为原生js值。默认情况下，&lt;strong&gt;&lt;span&gt;JSON.stringify()输出的JSON字符串不包含任何的空格字符串或缩进；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        2.当JSON.stringify()&lt;/p&gt;
&lt;p&gt;接受&lt;span&gt;一个&lt;/span&gt;参数的时候（上述情景），JSON就是把js对象序列化为JSON字符串；&lt;/p&gt;
&lt;p&gt;当JSON.stringify()接受&lt;span&gt;两个&lt;/span&gt;参数，且第二个参数为数组的时候，代表结果中只包含数组中列出的属性；而当第二个参数为函数时，情况稍微有点不一样，函数返回的值就是相应键的值。不过，当函数返回undefined，那么相应的属性会被忽略即被删除；&lt;/p&gt;
&lt;p&gt;当其接受&lt;span&gt;三个&lt;/span&gt;参数的时候，第三个参数用于控制结果中的缩进和空白符。&lt;/p&gt;
&lt;h2&gt;小结：&lt;/h2&gt;
&lt;p&gt;JSON是一个轻量级的数据格式，可以简化表示复杂数据结构的工具量。&lt;/p&gt;
&lt;p&gt;JSON vs js：JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。&lt;/p&gt;
&lt;p&gt;在 JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。&lt;/p&gt;

&lt;p&gt;但是对象和数组是比较特殊且常用的两种类型。&lt;/p&gt;

&lt;p&gt;对象：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, ...} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。&lt;/p&gt;

&lt;p&gt;数组：数组在 JS 中是方括号 [] 包裹起来的内容，数据结构为 [&quot;java&quot;, &quot;javascript&quot;, &quot;vb&quot;, ...] 的索引结构。在 JS 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型。&lt;/p&gt;
&lt;p&gt;《JavaScript高级程序设计》：563-570页。&lt;/p&gt;

</description>
<pubDate>Tue, 24 Apr 2018 15:45:00 +0000</pubDate>
<dc:creator>zhengyeye</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhengyeye/p/8934528.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览 - zhisheng_tian</title>
<link>http://www.cnblogs.com/zhisheng/p/8934501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhisheng/p/8934501.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhraflay7j31hc0zk0z1.jpg&quot; alt=&quot;fireworks-2585843_1920&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关注我&quot;&gt;关注我&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转载请务必注明原创地址为：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/&quot;&gt;http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目结构&quot;&gt;项目结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhsa07r59j30ps104gpd.jpg&quot; alt=&quot;springboot2001&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-project 核心代码，代码量很多（197508 行）&lt;/li&gt;
&lt;li&gt;Spring-boot-samples 一些样例 demo，代码量不多（9685 行），蛮有用的&lt;/li&gt;
&lt;li&gt;Spring-boot-samples-invoker 里面无代码&lt;/li&gt;
&lt;li&gt;Spring-boot-tests 测试代码（1640 行）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;spring-boot-project&quot;&gt;spring-boot-project&lt;/h3&gt;
&lt;p&gt;Spring-boot-project 下面有很多模块，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs874239j30p00n2dip.jpg&quot; alt=&quot;springboot2002&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;spirng-boot&quot;&gt;Spirng-boot&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs885a4zj30xk1ea78a.jpg&quot; alt=&quot;springboot&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 47760 行代码（含测试代码），Spring boot 主要的库，提供了支持 Spring Boot 其他部分的功能，其中包括了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;SpringApplication&lt;/code&gt;类，提供静态便捷方法，可以很容易写一个独立的 Spring 应用程序。它唯一的工作就是创造并更新一个合适的 Spring&lt;code&gt;ApplicationContext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带有可选容器的嵌入式 Web 应用程序（Tomcat，Jetty 或 Undertow）&lt;/li&gt;
&lt;li&gt;一流的外部配置支持&lt;/li&gt;
&lt;li&gt;便捷&lt;code&gt;ApplicationContext&lt;/code&gt;初始化程序，包括对敏感日志记录默认值的支持&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;spring-boot-actuator&quot;&gt;spring-boot-actuator&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs8ibzjzj30xk15mjv8.jpg&quot; alt=&quot;springboot-actuator&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 18398 行代码（含测试代码），spring-boot-actuator 模块它完全是一个用于暴露自身信息的模块，提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等管理和监控应用。审计（Auditing）、 健康（health）、数据采集（metrics gathering）会自动加入到应用里面。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-actuator-autoconfigure&quot;&gt;spring-boot-actuator-autoconfigure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8hfazpj30wi1dy0xb.jpg&quot; alt=&quot;springboot-actoator-autoconfig&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 16721 行代码（含测试代码），Spring Boot Actuator 提供了额外的自动配置功能，可以在生产环境中实现可即时部署和支持的功能，从而装饰你的应用。例如，如果您正在编写 JSON Web 服务，那么它将提供服务器，安全性，日志记录，外部配置，管理端点，审计抽象等等功能。如果您想关闭内置功能，或者扩展或替换它们，它也会变得非常简单。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-autoconfigure&quot;&gt;spring-boot-autoconfigure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs89img2j30xs0og0uz.jpg&quot; alt=&quot;springboot-autoconfig&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 51100 行代码（含测试代码）， Spring Boot 可以根据类路径的内容配置大部分常用应用程序。单个&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注释会触发 Spring上下文的自动配置。&lt;/p&gt;
&lt;p&gt;自动配置尝试推断用户可能需要哪些 bean。例如，如果 &lt;code&gt;HSQLDB&lt;/code&gt;在类路径中，并且用户尚未配置任何数据库连接，则他们可能需要定义内存数据库。当用户开始定义他们自己的 bean 时，自动配置将永远远离。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-cli&quot;&gt;spring-boot-cli&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqhsa2hmasj30x21aqq6j.jpg&quot; alt=&quot;springboot-cli&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 9346 行代码（含测试代码），Spring 命令行应用程序编译并运行 Groovy 源代码，使得可以编写少量代码就能运行应用程序。Spring CLI 也可以监视文件，当它们改变时自动重新编译并重新启动。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-dependencies&quot;&gt;spring-boot-dependencies&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs9xrj6qj31kw16be31.jpg&quot; alt=&quot;springboot-dependencies&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块里面没有源码，只有所有依赖和插件的版本号信息。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-devtools&quot;&gt;spring-boot-devtools&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs9z88hrj30v41bw785.jpg&quot; alt=&quot;springboot-devtools&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 9418 行代码（含测试代码），spring-boot-devtools 模块来使 Spring Boot 应用支持热部署，提高开发者的开发效率，无需手动重启 Spring Boot 应用。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-docs&quot;&gt;spring-boot-docs&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs8affekj30xo1ecdkr.jpg&quot; alt=&quot;springboot-docs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块 671 行代码，springboot 参考文件。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-parent&quot;&gt;spring-boot-parent&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8dxfnij31kw0zrqkw.jpg&quot; alt=&quot;springboot-parent&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块是其他项目的 parent，该模块的父模块是 spring-boot-dependencies。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-properties-migrator&quot;&gt;spring-boot-properties-migrator&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqhs9wkyvsj30um18678o.jpg&quot; alt=&quot;springboot-properties-migrator&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模块有 495 行代码，在 Spring Boot 2.0 中，许多配置属性被重新命名/删除，开发人员需要更新&lt;code&gt;application.properties&lt;/code&gt;/ &lt;code&gt;application.yml&lt;/code&gt;相应的配置。为了帮助你解决这一问题，Spring Boot 发布了一个新&lt;code&gt;spring-boot-properties-migrator&lt;/code&gt;模块。一旦作为该模块作为依赖被添加到你的项目中，它不仅会分析应用程序的环境，而且还会在启动时打印诊断信息，而且还会在运行时为您暂时迁移属性。在您的应用程序迁移期间，这个模块是必备的，完成迁移后，请确保从项目的依赖关系中删除此模块。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-starters&quot;&gt;spring-boot-starters&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs8foqadj31he1hwh5l.jpg&quot; alt=&quot;springboot-starter&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Starter POMs 是由很多方便的依赖集合组成，如果你需要使用某种技术，通过添加少量的jar就可以把相关的依赖加入到项目中去。&lt;/p&gt;
&lt;p&gt;虽然你看得到有这么多 starter，但是却没有一行 Java 代码，意不意外？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1fqhs84zby0j31kw0xdkb0.jpg&quot; alt=&quot;springboot-starter-activemq&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这确实是 Spring Boot 自动配置的关键之处，后面我可以讲讲。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-test&quot;&gt;spring-boot-test&lt;/h4&gt;
&lt;p&gt;测试代码！有 10980 行代码。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-test-autoconfigure&quot;&gt;spring-boot-test-autoconfigure&lt;/h4&gt;
&lt;p&gt;自动配置的测试代码，有 6063 行代码。&lt;/p&gt;
&lt;h4 id=&quot;spring-boot-tools&quot;&gt;spring-boot-tools&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fqhs8kcu5ej30ri0lqwh5.jpg&quot; alt=&quot;springboot-tools&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-antlib&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Boot AntLib 模块为 Apache Ant 提供了基本的 Spring Boot 支持。 您可以使用该模块创建可执行文件夹。 要使用该模块，您需要在 build.xml 中声明一个额外的 spring-boot 命名空间，如以下示例所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xml &amp;lt;project xmlns:ivy=&quot;antlib:org.apache.ivy.ant&quot; xmlns:spring-boot=&quot;antlib:org.springframework.boot.ant&quot; name=&quot;myapp&quot; default=&quot;build&quot;&amp;gt; ... &amp;lt;/project&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;您需要记住使用 -lib 选项启动 Ant，如以下示例所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ant -lib &amp;lt;folder containing spring-boot-antlib-2.1.0.BUILD-SNAPSHOT.jar&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-autoconfigure-processor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring boot 自动配置的核心类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-configuration-metadata&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring boot 配置元数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-configuration-processor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring boot 配置的核心&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-gradle-plugin&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Boot Gradle 插件在 Gradle 中提供了 Spring Boot 支持，可以打包成可执行 jar 或 war ，运行 Spring Boot 应用程序，并使用 spring-boot-dependencies 提供的依赖关系管理。 它需要 Gradle 4.0 或更高版本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-maven-plugin&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Boot Maven Plugin 在 Maven 中提供了 Spring Boot 支持，让您可以打包成可执行 jar 或 war 应用，并“就地”运行应用程序。 要使用它，你必须使用 Maven 3.2（或更高版本）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-loader&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-boot-load 模块通过自定义 jar 包结构，自定义类加载器，优雅的实现了嵌套 jar 资源的加载，通过打包时候重新设置启动类和组织 jar 结构，通过运行时设置自定义加载器来实现嵌套 jar 资源加载。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-loader-tools&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;spring-boot-load 模块的工具模块&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring-boot-test-support&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;h3 id=&quot;spring-boot-samples&quot;&gt;spring-boot-samples&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqhsa4qklcj31kw11y7ud.jpg&quot; alt=&quot;springboot-samples&quot;/&gt;&lt;/p&gt;
&lt;p&gt;样例 demo 比较多，大家看源码的时候可以拿这些现成 demo 测试。&lt;/p&gt;
&lt;h3 id=&quot;spring-boot-tests&quot;&gt;spring-boot-tests&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fqhs8cezdbj30ui1dqagt.jpg&quot; alt=&quot;springboot-tests&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关文章&quot;&gt;相关文章&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/&quot;&gt;Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/&quot;&gt;Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/13/Spring_Boot_2.0_Configuration_Changelog/&quot;&gt;Spring Boot 2.0系列文章(三)：Spring Boot 2.0 配置改变&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/15/springboot2_code/&quot;&gt;Spring Boot 2.0系列文章(四)：Spring Boot 2.0 源码阅读环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/18/spring_boot2_project/&quot;&gt;Spring Boot 2.0系列文章(五)：Spring Boot 2.0 项目源码结构预览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/19/SpringBootApplication-annotation/&quot;&gt;Spring Boot 2.0系列文章(六)：Spring boot 2.0 中 SpringBootApplication 注解详解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文主要分析了下 Spring boot 项目源码结构。包含 Spring boot 核心源码、样例 demo、测试。分析了项目的整体结构后，后面才能够有的放矢的去读源码。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;虽然源码很难，但随着不断的探索，源码在你面前将会一览无遗，享受这种探索后的成就感！加油！骚年！&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 15:40:00 +0000</pubDate>
<dc:creator>zhisheng_tian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhisheng/p/8934501.html</dc:identifier>
</item>
<item>
<title>深入以太坊智能合约 ABI - 以太坊开发</title>
<link>http://www.cnblogs.com/helloworld2018/p/8934425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworld2018/p/8934425.html</guid>
<description>&lt;p&gt;开发 DApp 时要调用在区块链上的以太坊智能合约，就需要智能合约的 ABI。本文希望更多了解 ABI，如为什么需要 ABI？如何解读 Ethereum 的智能合约 ABI？以及如何取得合约的 ABI？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11831773-f937422962fc1f94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;p&gt;数字猫合约 ABI&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ABI（Application Binary Interface）&lt;/p&gt;
&lt;p&gt;如果理解 API 就很容易了解 ABI。简单来说，API 是程序与程序间互动的接口。这个接口包含程序提供外界存取所需的 functions、variables 等。ABI 也是程序间互动的接口，但程序是被编译后的 binary code。所以同样的接口，但传递的是 binary 格式的信息。所以 ABI 就要描述如何 decode/encode 程序间传递的 binary 信息。下图以 Linux 为例，描述 Linux 中 API、ABI 和程序的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11831773-d07312035b86a7df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;p&gt;Linux API and ABI&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;编译和部署智能合约&lt;/h3&gt;
&lt;p&gt;在 Ethereum 智能合约可以被大家使用前，必须先被部署到区块链上。&lt;/p&gt;
&lt;p&gt;从智能合约的代码到使用智能合约，大概包含几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编写智能合约的代码（一般是用 Solidity 写）&lt;/li&gt;
&lt;li&gt;编译智能合约的代码变成可在 EVM 上执行的 bytecode（binary code）。同时可以通过编译取得智能合约的 ABI&lt;/li&gt;
&lt;li&gt;部署智能合约，实际上是把 bytecode 存储在链上（通过一个transaction），并取得一个专属于这个合约的地址&lt;/li&gt;
&lt;li&gt;如果要写个程序调用这个智能合约，就要把信息发送到这个合约的地址（一样的也是通过一个 transaction）。Ethereum 节点会根据输入的信息，选择要执行合约中的哪一个 function 和要输入的参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而要如何知道這这个智能合约提供哪些 function 以及应该要传入什么样的参数呢？这些信息就是记录在智能合约的 ABI！&lt;/p&gt;
&lt;h3&gt;Ethereum 智能合约 ABI&lt;/h3&gt;
&lt;p&gt;Ethereum 智能合约 ABI 用一个 array 表示，其中会包含数个用 JSON 格式表示的 Function 或 Event。根据最新的 Solidity 文件：&lt;/p&gt;
&lt;h4&gt;Function&lt;/h4&gt;
&lt;p&gt;共有 7 个参数：&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;：a string，function 名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：a string，&quot;function&quot;, &quot;constructor&quot;, or &quot;fallback&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;inputs&lt;/code&gt;：an array，function 输入的参数，包含：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;：a string，参数名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：a string，参数的 data type(e.g. uint256)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;components&lt;/code&gt;：an array，如果输入的参数是 tuple(struct) type 才会有这个参数。描述 struct 中包含的参数类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;outputs&lt;/code&gt;：an array，function 的返回值，和 &lt;code&gt;inputs&lt;/code&gt; 使用相同表示方式。如果沒有返回值可忽略，值为 &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;payable&lt;/code&gt;：&lt;code&gt;true&lt;/code&gt;，function 是否可收 Ether，预设为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt;：&lt;code&gt;true&lt;/code&gt;，function 是否会改写区块链状态，反之为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;stateMutability&lt;/code&gt;：a string，其值可能为以下其中之一：&quot;pure&quot;（不会读写区块链状态）、&quot;view&quot;（只读不写区块链状态）、&quot;payable&quot; and &quot;nonpayable&quot;（会改区块链状态，且如可收 Ether 为 &quot;payable&quot;，反之为 &quot;nonpayable&quot;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;仔细看会发现 &lt;code&gt;payable&lt;/code&gt; 和 &lt;code&gt;constant&lt;/code&gt; 这两个参数所描述的內容，似乎已包含在 &lt;code&gt;stateMutability&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;事实也确实是这样的，在 &lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fethereum%2Fsolidity%2Freleases&quot;&gt;Solidity v0.4.16&lt;/a&gt; 中把 &lt;code&gt;constant&lt;/code&gt; 这个修饰function 的 key words 分成： &lt;code&gt;view&lt;/code&gt;（neither reads from nor writes to the state）和 &lt;code&gt;pure&lt;/code&gt;（does not modify the state），并从 v0.4.17 开始 Type Checker 会强制检查。&lt;code&gt;constant&lt;/code&gt; 改为只用来修饰不能被修改的 variable。并在 ABI 中加入 &lt;code&gt;stateMutability&lt;/code&gt; 这个参数统一表示，&lt;code&gt;payable&lt;/code&gt; 和 &lt;code&gt;constant&lt;/code&gt; 目前保留是为了向后兼容。这个改动详细的內容和讨论可参考：&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fethereum%2Fsolidity%2Fissues%2F992&quot;&gt;https://github.com/ethereum/solidity/issues/992&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Event&lt;/h4&gt;
&lt;p&gt;共有 4 个参数：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;: a string，event 的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;: a string，always &quot;event&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;inputs&lt;/code&gt;: an array，输入参数，包含：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;: a string，参数名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt;: a string，参数的 data type(e.g. uint256)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;components&lt;/code&gt;: an array，如果输入参数是 tuple(struct) type 才会有这个参数。描述 struct 中包含的信息类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;indexed&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt;，如果这个参数被定义为 indexed ，反之为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;anonymous&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt;，如果 event 被定义为 anonymous&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;更新智能合约状态需要发送 transaction，transaction 需要等待验证，所以更新合约状态是非同步的，无法马上取得返回值。使用 Event 可以在状态更新成功后，将相关信息记录到 Log，并让监听这个 Event 的 DApp 或任何应用这个接口的程序收到通知。每笔 transaction 都有对应的 Log。&lt;/p&gt;
&lt;p&gt;所以简单来说，Event 可用來：1. 取得 function 更新合约状态的返回值 2. 也可作为合约另外的存储空间。&lt;/p&gt;
&lt;p&gt;Event 的参数分为：有 &lt;code&gt;indexed&lt;/code&gt;，和其他没有 &lt;code&gt;indexed&lt;/code&gt; 的。有 &lt;code&gt;indexed&lt;/code&gt; 的参数可以使用 filter，例如同一个 Event，我可以选择只监听从特定 address 发出来的交易。每笔 Log 的信息同样分为两个部分：Topics（长度最多为 4 的 array） 和 Data。有 &lt;code&gt;indexed&lt;/code&gt; 的参数会存储存在 Log 的 Topics，其他的存在 Data。如果定义为 &lt;code&gt;anonymous&lt;/code&gt;，就不会产生以下示例中的 Topics[0]，其值为 Event signature 的 hash，作为這個 Event 的 ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11831773-fb419508dfc0d2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Event&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;event&lt;/span&gt; Set(address indexed _from, &lt;span&gt;uint&lt;/span&gt; value)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;用一个简单的智能合约举个例子&lt;/h3&gt;
&lt;p&gt;这个智能合约包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：一个可修改的 state variable，会自动产生一个只能读取的 &lt;code&gt;data()&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set()&lt;/code&gt;：一个修改 &lt;code&gt;data&lt;/code&gt; 值的 function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set()&lt;/code&gt;：一个在每次修写 &lt;code&gt;data&lt;/code&gt; 时记录 Log 的 event&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;智能合约 Source Code：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
pragma solidity ^&lt;span&gt;0.4&lt;/span&gt;.&lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
contract SimpleStorage {
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;event&lt;/span&gt; Set(address indexed _from, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; value);
    function &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; x) &lt;span&gt;public&lt;/span&gt;&lt;span&gt; {
        data &lt;/span&gt;=&lt;span&gt; x;
        Set(msg.sender, x);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;智能合约 ABI：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[{
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;constant&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uint256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;payable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stateMutabㄒility&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;anonymous&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;indexed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_from&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;indexed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uint256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;constant&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uint256&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outputs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;payable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stateMutability&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonpayable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;取得 Ethereum 智能合约 ABI&lt;/h3&gt;
&lt;h4&gt;Solidity Compiler&lt;/h4&gt;
&lt;p&gt;可以用 Solidity Compiler 取得合约 ABI，我使用 JavaScript 版本的 Compiler 为例。&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install solc -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取得合约 ABI：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
solcjs simpleStorage.sol --abi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成一个 simpleStorage_sol_SimpleStorage.abi 文件，里面就是合约ABI 內容。&lt;/p&gt;
&lt;p&gt;也可以取得合约的 binary code：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
solcjs your_contract.sol --bin
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Remix&lt;/h4&gt;
&lt;p&gt;同样的使用 Solidity Compiler，也可以用 Remix。在合约的 Details 可以看到完整的 ABI。可以在 Settings 中指定 Compiler 版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11831773-4f94ee9fce3e3906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Remix&lt;/p&gt;
&lt;h4&gt;Etherscan&lt;/h4&gt;
&lt;p&gt;许多知名合约会把合约 source code 放上 Etherscan 做验证，可以同时看到h 合约ABI。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11831773-6cd385bc69aca28c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Etherscan&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;另外 Etherscan 提供 &lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fetherscan.io%2Fapis%23contracts&quot;&gt;API&lt;/a&gt;，可用来取得经过验证的合约 ABI。&lt;/p&gt;
&lt;p&gt;分享一个区块链教程：&lt;a href=&quot;http://t.cn/RmeEwxJ&quot; target=&quot;_blank&quot;&gt;以太坊DApp开发实战&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 24 Apr 2018 15:22:00 +0000</pubDate>
<dc:creator>以太坊开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworld2018/p/8934425.html</dc:identifier>
</item>
<item>
<title>【linux】---常用命令整理 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8921654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8921654.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、ls命令&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    就是list的缩写，通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等&lt;/p&gt;
&lt;p&gt;         常用参数搭配：&lt;/p&gt;
&lt;p&gt;         ls -a 列出目录所有文件，包含以.开始的隐藏文件&lt;/p&gt;
&lt;p&gt;         ls -A 列出除.及..的其它文件&lt;/p&gt;
&lt;p&gt;         ls -r 反序排列&lt;/p&gt;
&lt;p&gt;         ls -t 以文件修改时间排序&lt;/p&gt;
&lt;p&gt;         ls -S 以文件大小排序&lt;/p&gt;
&lt;p&gt;         ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来(可以直接写成 ll)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ll name*      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出当前目录中所有以“name”开头的目录的详细内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;二、cd命令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cd /root/Docements      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切换到目录/root/Docements  &lt;/span&gt;
cd ./path               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切换到当前目录下的path目录中，“.”表示当前目录    &lt;/span&gt;
cd ../path              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切换到上层目录中的path目录中，“..”表示上一层目录  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;三、rm命令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-f ： &lt;span&gt;#&lt;/span&gt;&lt;span&gt;就是force的意思，忽略不存在的文件，不会出现警告消息  &lt;/span&gt;
-i ： &lt;span&gt;#&lt;/span&gt;&lt;span&gt;互动模式，在删除前会询问用户是否操作  &lt;/span&gt;
-r ： &lt;span&gt;#&lt;/span&gt;&lt;span&gt;递归删除，最常用于目录删除，它是一个非常危险的参数  &lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;举例&lt;/span&gt;
rm -i file &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除文件file，在删除之前会询问是否进行该操作  &lt;/span&gt;
rm -fr dir &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 强制删除目录dir中的所有文件  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;四、cp命令&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;dp-xml&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;-a ：将文件的特性一起复制  &lt;/li&gt;
&lt;li&gt;-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  &lt;/li&gt;
&lt;li&gt;-r ：递归持续复制，用于目录的复制行为   &lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cp /home/Test.java             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将home路径下的Test.java文件复制到当前目录下&lt;/span&gt;
cp -r dir1 dir2                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-r表示递归，将dir1代表的文件夹及里面的文件复制到dir2路径那里&lt;/span&gt;
cp -r mysql /usr/local/mysql   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把mysql文件夹所有文件复制到/usr/local/mysql目录下，没有会自动创建目录 &lt;br/&gt;&lt;span&gt;cp file1 file2 file3 dir&lt;/span&gt;       #把文件file1、file2、file3复制到目录dir中 &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;五、mv命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt; 移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;dp-xml&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  &lt;/li&gt;
&lt;li&gt;-i ：若目标文件已经存在，就会询问是否覆盖  &lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;-u ：若目标文件已经存在，且比目标文件新，才会更新  &lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mv file1 file2 file3 dir  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把文件file1、file2、file3移动到目录dir中  &lt;/span&gt;
mv file1 file2            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把文件file1重命名为file2  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;六、mkdir命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      -m --mode=模式，设定权限&amp;lt;模式&amp;gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask&lt;/p&gt;
&lt;p&gt;　　-p --parents 递归创建目录&lt;/p&gt;
&lt;p&gt;　　-v, --verbose 每次创建新目录都显示信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir abc              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个空目录&lt;/span&gt;
mkdir -p test/test1    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;递归创建多个目录&lt;/span&gt;
mkdir -v hao           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建新目录都显示信息&lt;/span&gt;
mkdir -m 777 pc        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建权限为777的目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;7、pwd命令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pwd        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看当前路径&lt;/span&gt;
pwd -P    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看软链接的实际路径&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;8、find命令&lt;/span&gt;    &lt;/h2&gt;
&lt;pre&gt;
 -&lt;span&gt;name 按照文件名查找文件

 -&lt;span&gt;perm 按文件权限查找文件

 -&lt;span&gt;user 按文件属主查找文件

 -&lt;span&gt;group  按照文件所属的组来查找文件。

 -&lt;span&gt;amin n   查找系统中最后N分钟访问的文件

 -atime n  查找系统中最后n*&lt;span&gt;24小时访问的文件

 -&lt;span&gt;mmin n   查找系统中最后N分钟被改变文件数据的文件

 -mtime n  查找系统中最后n*24小时被改变文件数据的文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 find ./ -name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*.log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在当前目录查找 以.log结尾的文件。 &quot;. &quot;代表当前目录&lt;/span&gt;
&lt;span&gt;
 find &lt;/span&gt;/opt -perm 777      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找/opt目录下 权限为 777的文件&lt;/span&gt;

 -xargs                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。&lt;/span&gt;
&lt;span&gt;
find &lt;/span&gt;/ -name mysql|xargs rm -rf   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找到所有文件名为mysql文件，并全部删除。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;9、tar命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;只能使用下面的某一个选项来指定tar要执行的动作。可以通过在选项后面跟一个或多个修饰符来改变该选项的行为&lt;/p&gt;
&lt;p&gt;    -c            创建归档文件&lt;/p&gt;
&lt;p&gt;    -u            将file-list中的文件添加到归档文件&lt;/p&gt;
&lt;p&gt;    -x            从归档文件中提取file-list并把它写入磁盘&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修饰符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-f filename              使用filename来指出要创建或从中提取的归档文件的文件名&lt;/p&gt;
&lt;p&gt;-j                             在创建归档文件或从归档文件中提取文件时，使用bzip2方式来进行压缩和解压缩&lt;/p&gt;
&lt;p&gt;-z                            在创建归档文件或从归档文件中提取文件时，使用gzip方式来进行压缩和解压缩&lt;/p&gt;
&lt;p&gt;-v                            显示所有过程&lt;/p&gt;
&lt;p&gt;-t                             列出归档文件中的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
tar -cvf demo.tar a b c       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将a b c打包成一个名为demo.tar的归档文件，并显示打包的文件&lt;/span&gt;
tar -xvf demo.tar             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;解压名为demo.tar的归档文件到本目录，并显示解压的文件&lt;/span&gt;
tar -zcvf demo.tar.gz a b c   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将a b c 三文件用gzip的方式打包并压缩成demo.tar.gz&lt;/span&gt;
tar -zxvf demo.tar.gz         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用gunzip的的方式解压demo.tar.gz文件&lt;/span&gt;
tar -jcvf demo.tar.bz2 a b c  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将a b c三文件用bzip2的方式压缩并打包为demo.tar.bz2&lt;/span&gt;
tar -jxvf demo.tar.bz2        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将demo.tar.bz2用bunzip2的方式解压缩到当前目录&lt;br/&gt;&lt;span&gt;tar -cvf jpg.tar *.jpg&lt;/span&gt;        #将目录里所有jpg文件打包成tar.jpg&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;10、ps命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top&lt;/p&gt;
&lt;p&gt;         linux上进程有5种状态:&lt;/p&gt;
&lt;p&gt;         1. 运行(正在运行或在运行队列中等待)&lt;/p&gt;
&lt;p&gt;         2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)&lt;/p&gt;
&lt;p&gt;         3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)&lt;/p&gt;
&lt;p&gt;         4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)&lt;/p&gt;
&lt;p&gt;         5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)&lt;/p&gt;
&lt;p&gt;         命令参数：&lt;/p&gt;
&lt;p&gt;         -A 显示所有进程&lt;/p&gt;
&lt;p&gt;         a 显示所有进程&lt;/p&gt;
&lt;p&gt;        - e 显示环境变量&lt;/p&gt;
&lt;p&gt;        - f 显示进程间的关系&lt;/p&gt;
&lt;p&gt;         r 显示当前终端运行的进程&lt;/p&gt;
&lt;p&gt;         -aux 显示所有包含其它使用的进程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ps -A                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示所有进程信息&lt;/span&gt;
ps -u root           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示指定用户信息&lt;/span&gt;
ps -ef               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示所有进程信息，连同命令行&lt;/span&gt;
ps -ef |grep java    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示java 进程是否存在&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;grep命令是查找，中间的|是管道命令 是指ps命令与grep同时执行&lt;/span&gt;
ps -aux |grep java   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示java 进程是否存在&lt;/span&gt;
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;上面两个其实没有多大区别只是：aux可以查看进程的CPU占用率和内存占用率。ef可以查看进程的父进程ID和完整的COMMAND命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;11、top命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;       top显示系统当前的进程和其他状况,是一个动态显示过程，显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等&lt;/p&gt;
&lt;p&gt;  常用参数：&lt;/p&gt;
&lt;p&gt;         -c 显示完整的进程命令&lt;/p&gt;
&lt;p&gt;         -s 保密模式&lt;/p&gt;
&lt;p&gt;         -p &amp;lt;进程号&amp;gt; 指定进程显示&lt;/p&gt;
&lt;p&gt;         -n &amp;lt;次数&amp;gt;循环显示次数&lt;/p&gt;
&lt;pre&gt;
   -d 指定每两次屏幕信息刷新之间的时间间隔。 
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
top       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每隔5秒显式所有进程的资源占用情况（默认是5秒）&lt;/span&gt;
top -d 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每隔2秒显式所有进程的资源占用情况&lt;/span&gt;
top -c    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)&lt;/span&gt;
top -p 12345 -p 6789   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况&lt;/span&gt;
top -d 2 -c -p 123456  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;12、kill命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      发送指定的信号到相应进程。&lt;/p&gt;
&lt;p&gt;   常见参数&lt;/p&gt;
&lt;p&gt;        HUP    1    终端断线&lt;/p&gt;
&lt;p&gt;        INT     2    中断（同 Ctrl + C）&lt;/p&gt;
&lt;p&gt;      QUIT    3    退出（同 Ctrl + \）&lt;/p&gt;
&lt;p&gt;    TERM   15    终止&lt;/p&gt;
&lt;p&gt;       KILL    9    强制终止&lt;/p&gt;
&lt;p&gt;    CONT   18    继续（与STOP相反， fg/bg命令）&lt;/p&gt;
&lt;p&gt;    STOP    19    暂停（同 Ctrl + Z）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 kill -15 pid    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;让进程正常退出 。 既然信号 15 是退出进程的正确方式，那它也应该是最常用的方式，因而我们可以省略参数 -15。&lt;/span&gt;
 kill -9 pid     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当进程出现了异常状况，不能通过信号15正常退出时，我们就需要通过非常的手段直接终结掉进程。所谓的非常手段就是传递信号 9 给目标进程！&lt;/span&gt;
 kill -15 $(ps -ef | grep peidalinux)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;杀死指定进程&lt;br/&gt;#不是特殊情况，建议有15就可以了，慎用9哦&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;13、chmod命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   &lt;strong&gt;常用参数：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         -c 当发生改变时，报告处理信息&lt;/p&gt;
&lt;p&gt;         -R 处理指定目录以及其子目录下所有文件&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;权限范围&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;         u ：目录或者文件的当前的用户&lt;/p&gt;
&lt;p&gt;         g ：目录或者文件的当前的群组&lt;/p&gt;
&lt;p&gt;         o ：除了目录或者文件的当前用户或群组之外的用户或者群组&lt;/p&gt;
&lt;p&gt;         a ：所有的用户及群组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 三种基本权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   R           读          数值表示为4&lt;/p&gt;
&lt;p&gt;   W          写          数值表示为2&lt;/p&gt;
&lt;p&gt;   X           可执行   数值表示为1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180424211421410-875565897.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 如图所示，dump.rdb文件的权限为-rw-r--r--&lt;/p&gt;
&lt;p&gt;  -rw-r--r--一共十个字符，分成四段。&lt;/p&gt;
&lt;p&gt;  第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录&lt;/p&gt;
&lt;p&gt;  第二三四个字符“rw-”表示当前所属用户的权限。   所以用数值表示为4+2=6&lt;/p&gt;
&lt;p&gt;  第五六七个字符“r--”表示当前所属组的权限。       所以用数值表示为4&lt;/p&gt;
&lt;p&gt;  第八九十个字符“r--”表示其他用户权限。              所以用数值表示为4&lt;/p&gt;
&lt;p&gt;  所以操作此文件的权限用数值表示为644 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 更改权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 &lt;/p&gt;
&lt;p&gt;例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sudo chmod u+x g+w o+r  filename&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的例子可以用数值表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;sudo chmod 765 filename&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;14、grep命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   强大的文本搜索命令，grep(Global Regular Expression Print)全局正则表达式搜索&lt;/p&gt;
&lt;p&gt;   grep太强大了，我这里就举几个常见的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ps -ef|grep svn                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找指定进程&lt;/span&gt;
grep -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; nginx.conf          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在nginx.conf查找包含&quot;li&quot;的行，同时显示行号&lt;/span&gt;
grep &lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; test.txt test2.txt  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从多个文件中查找关键词&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180424215251182-790732063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 15、&lt;strong&gt;vim命令&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。&lt;/p&gt;
&lt;p&gt;  命令模式下：&lt;/p&gt;
&lt;p&gt;               :q                      退出&lt;/p&gt;
&lt;p&gt;              :q!                     强制退出&lt;/p&gt;
&lt;p&gt;             :wq                   保存并退出&lt;/p&gt;
&lt;p&gt;             :set number     显示行号&lt;/p&gt;
&lt;p&gt;             :set nonumber  隐藏行号&lt;/p&gt;
&lt;p&gt;              /apache            在文档中查找apache 按n跳到下一个，shift+n上一个&lt;/p&gt;
&lt;p&gt;               yyp                   复制光标所在行，并粘贴&lt;/p&gt;
&lt;p&gt;              h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;16、cat命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    cat主要有三大功能：&lt;/p&gt;
&lt;p&gt;           1.一次显示整个文件:cat filename&lt;/p&gt;
&lt;p&gt;           2.从键盘创建一个文件:cat &amp;gt; filename 只能创建新文件,不能编辑已有文件.&lt;/p&gt;
&lt;p&gt;           3.将几个文件合并为一个文件:cat file1 file2 &amp;gt; file&lt;/p&gt;
&lt;p&gt;          -b对非空输出行号&lt;/p&gt;
&lt;p&gt;          -n输出所有行号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cat -n nginx.conf                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看文件并显示行号&lt;/span&gt;
cat -n log2012.log log2013.log           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里&lt;/span&gt;
 cat -b log2012.log log2013.log log.log  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180424220711964-531259559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;17、more命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  功能类似于cat, more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;命令参数&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;         +n      从笫n行开始显示&lt;/p&gt;
&lt;p&gt;         -n       定义屏幕大小为n行&lt;/p&gt;
&lt;p&gt;         +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 &lt;/p&gt;
&lt;p&gt;         -c       从顶部清屏，然后显示&lt;/p&gt;
&lt;p&gt;         -d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能&lt;/p&gt;
&lt;p&gt;         -l        忽略Ctrl+l（换页）字符&lt;/p&gt;
&lt;p&gt;         -s       把连续的多个空行显示为一行&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;常用操作命令&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;         Enter    向下n行，需要定义。默认为1行&lt;/p&gt;
&lt;p&gt;         空格键  向下滚动一屏&lt;/p&gt;
&lt;p&gt;         Ctrl+B  返回上一屏&lt;/p&gt;
&lt;p&gt;         =       输出当前行的行号&lt;/p&gt;
&lt;p&gt;         V      调用vi编辑器&lt;/p&gt;
&lt;p&gt;         !命令   调用Shell，并执行命令&lt;/p&gt;
&lt;p&gt;         q       退出more&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ls -l | more -5   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在所列出文件目录详细信息，借助管道使每次显示5行 按空格键显示下五行，enter向下1行。具体看上面参数。&lt;br/&gt;&lt;span&gt;more +3 text.txt&lt;/span&gt;  #显示文件中从第3行起的内容&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;18、less命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;19、tail命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。&lt;/p&gt;
&lt;p&gt;         常用参数：&lt;/p&gt;
&lt;p&gt;         -f 循环读取（常用于查看递增的日志文件）&lt;/p&gt;
&lt;p&gt;         -n&amp;lt;行数&amp;gt; 显示行数（从后向前）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  tail -f ping.log  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环读取逐渐增加的文件内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        这个可以用来看正式服报错日志&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;20、chown命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符&lt;/p&gt;
&lt;p&gt;         -c 显示更改的部分的信息&lt;/p&gt;
&lt;p&gt;         -R 处理指定目录及子目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　chown mail:mail log2012.log   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;改变拥有者和群组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201804/1090617-20180424224222173-1163522295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
chown root: log2012.log      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;改变文件拥有者和群组&lt;/span&gt;
chown :mail log2012.log      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;改变文件群组&lt;/span&gt;
chown -R -v root:mail test6  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;改变指定目录以及其子目录下的所有文件的拥有者和群组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; &lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/gaojun/p/3359355.html&quot; target=&quot;_blank&quot;&gt;1.linux常用命令&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;https://www.cnblogs.com/ITtangtang/p/3950497.html&quot; target=&quot;_blank&quot;&gt;2.grep命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/peida/archive/2012/12/04/2800684.html&quot; target=&quot;_blank&quot;&gt;3.chown命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html&quot; target=&quot;_blank&quot;&gt;4.top命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/qzqdy/p/8203212.html&quot; target=&quot;_blank&quot;&gt;5.tar命令详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html&quot; target=&quot;_blank&quot;&gt;6.ps命令详解&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;strong&gt;中尉【12】&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Tue, 24 Apr 2018 14:52:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8921654.html</dc:identifier>
</item>
<item>
<title>基于移动端的问答系统--需求分析与原型设计 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8934229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8934229.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、结对者&lt;/strong&gt;：2015034643032 孔潭活、2015034643023 周宏杰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、需求分析模型：&lt;/strong&gt;NABCD 模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、原型设计工具：&lt;/strong&gt;Axure RP 8、墨刀、FSCapture&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180421201235175-326335113.jpg&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;569&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180421201151907-723540317.jpg&quot; alt=&quot;&quot; width=&quot;757&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;nneed需求&quot;&gt;1、N（Need，需求）：&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;大学生作为社会新技术、新思想的前沿群体，在大学期间能否将自己锻造成特色鲜明的应用型人才尤为重要，而这款基于移动端的问答系统可以帮他们保持前沿的思维与认知&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;这个问答系统在大学生离开课堂后，在课外遇到自己无法解决的问题时，自学和求学的能力稍显疲软是的时候，在线的互动可以提升他们的求知欲&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在网络上百度、360等搜索引擎和各种平台涉及领域广，提供的信息良莠不齐、有些信息不具时效性甚至还出现信息出错等情况时，这款基于移动端的问答系统可以帮他们获得精确的第一手信息，并配备健全的在线自学与咨询体系&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于高校学生来讲，这个问答系统能够使得新生得到老生和教师的指导，了解企业的就业实习信息、学习大量的经验，因此可以使得他们成长的高度会远远高于原先的成长高度&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;aapproach做法&quot;&gt;2、A（Approach，做法）：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这个基于移动端的问答平台在校园中能有一个针对大学生高质量垂直交流的知识共享平台，将学生、教师以及企业统一联系起来，让学生能在课堂以外，能够得到老生和教师的指导，了解企业的就业实习信息、学习大量的经验，成长的高度会远远高于原先的成长高度。当这群新生成长起来，他们又会去给新一届的新生解惑，新的新生得指导会比之前的新生得到的还要好，新的新生成长起来的高度再一次提高，如此良性循环下去，该校会形成自己内部的专属学习交流圈，帮助新生快速适应大学的学习生活，同时也为企业输送人才铺下技术基础和提供了招聘渠道，可以说是开辟了大学课堂以外的学习辅导途径。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       学生注册登录平台，即可发布校园日常问题和学术问题，查看校园最新资讯。日常问题可以查问校园学习攻略、周边攻略、比赛详情、心理调节、人生规划、就业实习、社团活动等；学术问题可以让学生探讨专业问题，解决学习上的困惑，我们会与校方合作，邀请老师和优秀的师兄师姐进行解答；校园资讯包括最新的比赛通知、校内企业实训课、校内举办的活动等，比赛资源来自于网络上的网站搜寻和校内官网的发布，涵盖各专业。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;bbenefit好处&quot;&gt;3、B（Benefit，好处）：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       当在读的高校学生会遇到各种问题，仅仅向网上的百度求助和向身边的人请教是远远不够的。而这样一个专门针对高校师生面对的各种问题的问答平台，供高校师生使用，在这个平台上在读的高校学生可以发表一些日常遇到的问题或者难以独自解决的问题，平台回答者都是有经验的师兄或者是老师，能够及时给提问者带来优秀的答案。在“校答人”平台上，学生可以掌握一手校园资讯。“校答人”平台上涉及学习、竞赛、社团、心理、职业方向与人生规划以及就业实习等方面，用户可以通过提问获取答复，自己也可以依据自己的能力，充当回答者为他人排忧解难。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;ccompetitors竞争&quot;&gt;4、C（Competitors，竞争）：&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;      &lt;span&gt; 现在的问答平台正逐渐打破以往免费分享知识的惯性思维，正在转向提供高质量回答的知识付费，向共享经济领域进发，知识付费问答平台越来越受人们关注，目前比较有影响力的付费平台有大弓、知乎、分答等等。016年，有知识付费意愿的用户暴涨了3倍，知识付费用户达到近5000万人，截止到2017年3月，用户知识付费可估算的总体经济规模为100-150亿左右。由于各行各业的人数增多，自身身份和职业常见问题的知识需求增加，当前问答平台正在向专业化与行业化过渡发展，比如有餐饮版的“餐答”，职场版的“业问”，医疗版的“来问医生”，体育版的“映答”，知识分享平台的内容生态还在不断丰富创新，但目前却没有针对大学生高质量垂直交流的知识共享平台。众所周知，如今大学生是一个非常庞大的群体。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     如下图所示，截止2016年，大学生数量已由15年前的114万人狂飙至765万人，该群体之大，让我们不得不思考着为这个群体定制一些属于他们青春活力的产品，因此这款基于移动端的问答平台就是在免费与付费的梯度上展开竞争，当然，也可以使用先免费，积累到一定用户后再考虑收费问题，关键在于有付费必定存在免费。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424215028795-1770955696.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2 id=&quot;ddelivery推广&quot;&gt;5、D（Delivery，推广）：&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;原型设计完成后，即可进行开发，并通过相应的广告平台做相应宣传与推广，当然，起步阶段为了推广，可做相应的优惠政策。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;注册页面原型 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424215359333-228998381.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;登录页面原型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424215558483-2083503890.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;首页原型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424215811812-1885704995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;校园页面原型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424215942402-1926574522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;提问页面原型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424220113119-1433705296.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息页面原型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424220242019-1030441378.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的页面原型&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424220359854-350770007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　兵马未动，粮草先行，或许开发中也可以应用这个道理吧，在时间充足的情况下，多写这种需求分析与原型设计是很有必要的，然而现实骨感，很多事情是不会以一个人的意志为转移的，我们现在的目标也不是成为全栈工程师，而是先往一个方向深入学习，而不是这样所谓的走一个完整项目流程，一个完整的开发流程应该走，但不是这样走，言尽于此，毕竟已经写完了......&lt;/span&gt;&lt;span&gt;我不是个麻瓜，但在所有的事情过程中，我最大的感受只有合作，我也一直坚信我们应该学会合作，但我们最缺乏的就是合作......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一言难尽，说来话长，想听的关注微信公众号 compassblog ，直接后台联系我吧。&lt;/span&gt;&lt;/p&gt;



&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;预计耗时（分钟）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;实际耗时（分钟）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Planning&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;计划&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Estimate&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;估计这个任务需要多少时间&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;60&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;60&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Development&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;开发&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;120&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;120&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Analysis&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;需求分析&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Design Spec&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;生成设计文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0 &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Design Review&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设计复审（和同事审核设计文档）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Coding Standerd&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;代码规范（为目前的开发制定合适的规范）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0 &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Design&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;具体设计&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;50&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Coding&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;具体编码&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Code Review&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;代码复审&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Text&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;测试（自测，修改代码，提交修改）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Reporting&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;报告&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;50&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Text Report&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;测试报告&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Size Measurement&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;计算工作量&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt; 1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Postmortem &amp;amp; Process Improvement Plan&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;事后总结，并提出过程改进计划&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt; 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;Sum&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;合计&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;312&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;361&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201804/1322792-20180424222250345-247681575.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 24 Apr 2018 14:37:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8934229.html</dc:identifier>
</item>
</channel>
</rss>