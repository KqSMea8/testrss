<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Web SCADA 电力接线图工控组态编辑器 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8759227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8759227.html</guid>
<description>&lt;p&gt;SVG并非仅仅是一种图像格式， 由于它是一种基于XML的语言，也就意味着它继承了XML的跨平台性和可扩展性，从而在图形可重用性上迈出了一大步。如SVG可以内嵌于其他的XML文档中，而SVG文档中也可以嵌入其他的XML内容，各个不同的SVG图形可以方便地组合， 构成新的SVG图形。这个 Demo 运用的技术基于 HTML5 的技术适应了只能电网调度、配电网运行监控与配电网运维管控，通过移动终端实现 Web SCADA 账上运维的时代需求。由于传统电力行业 CS 桌面监控系统一直到新一代 Web 和移动终端进化中，HT 是实施成本最低，开发和运行效率最高的前端图形技术解决方案。SVG 矢量图形大家都不会陌生了，尤其是在工控电信等领域，但是这篇文章并不是要制作一个新的绘制 SVG 图的编辑器，而是一个可绘制矢量图形并且对这个图形进行数据绑定的更高阶。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410154112635-2044537485.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;整体框架&lt;/h2&gt;
&lt;p&gt;根据上图看得出来，整个界面被分为五个部分，分别为 palette 组件面板，toolbar 工具条，graphView 拓扑组件，propertyPane 属性面板以及 treeView 树组件，这五个部分中的组件需要先创建出来，然后才放到对应的位置上去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
palette = &lt;span&gt;new&lt;/span&gt; ht.widget.Palette();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件面板&lt;/span&gt;
toolbar = &lt;span&gt;new&lt;/span&gt; ht.widget.Toolbar(toolbar_config);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条&lt;/span&gt;
g2d = &lt;span&gt;new&lt;/span&gt; ht.graph.GraphView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拓扑组件  &lt;/span&gt;
treeView = &lt;span&gt;new&lt;/span&gt; ht.widget.TreeView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;树组件&lt;/span&gt;
propertyPane = &lt;span&gt;new&lt;/span&gt; ht.widget.PropertyPane(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性面板&lt;/span&gt;
propertyView = propertyPane.getPropertyView();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性组件&lt;/span&gt;
rulerFrame = &lt;span&gt;new&lt;/span&gt; ht.widget.RulerFrame(g2d);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刻度尺&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180408191242375-1043688896.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些布局，只需要结合 splitView 和 borderPane 进行布局即可轻松完成~其中 splitView 为 HT 中的 分割组件，参数1为放置在前面的 view 组件（可为左边的，或者上面的）；参数2为放置在后面的 view 组件（可为右边的，或者下面的）；参数3为可选值，默认为 h，表示左右分割，若设置为 v 则为上下分割；参数4即为分割的比例。borderPane 跟 splitView 的作用有些相似，但是在这个 Demo 中布局，结合这两种组件，代码看起来会更加清爽。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
borderPane = &lt;span&gt;new&lt;/span&gt; ht.widget.BorderPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边框面板&lt;/span&gt;
leftSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(palette, borderPane, 'h', 260);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割组件，h表示左右分割，v表示上下分割&lt;/span&gt;
rightSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(propertyPane, treeView, 'v', 0.4&lt;span&gt;);
mainSplit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(leftSplit, rightSplit, 'h', -260&lt;span&gt;);                                              

borderPane.setTopView(toolbar);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置边框面板的顶部组件为 toolbar&lt;/span&gt;
borderPane.setTopHeight(30&lt;span&gt;);
borderPane.setCenterView(rulerFrame);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置边框面板的中间组件为 rulerframe&lt;/span&gt;
mainSplit.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 mainSplit 的底层 div 添加进 body 体中&lt;/span&gt;&lt;span&gt;

dataModel.deserialize(datamodel_config);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反序列化 datamodel_config 的内容，将json内容转为拓扑图场景内容&lt;/span&gt;
g2d.fitContent(true);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布局结束后，就要考虑每一个容器中应该放置哪些内容，我将这些内容分别封装到不同的函数中，通过调用这些函数来进行数据的显示。&lt;/p&gt;
&lt;h2&gt;Palette 组件面板&lt;/h2&gt;
&lt;p&gt;左侧的 Palette 组件面板需要向其内部添加 group 作为分组，然后再向组内添加节点。但是我们使用这个组件的最重要的一个原因是它能够拖拽节点，但是因为我们拖拽后需要在 graphView 拓扑组件中生成一个新的节点显示在拓扑图上，所以我将拖拽部分的逻辑写在了 graphView 拓扑组件的初始化函数中，这一小节就不做解释。&lt;/p&gt;
&lt;p&gt;虽然说最重要的因素是拖拽，但是不可否认，这个组件在分类上也是非常直观：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180409105005776-840759334.png&quot; alt=&quot;&quot; width=&quot;168&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，我在 Palette 中做了三个分组：电力、食品加工厂以及污水处理。并在这些分组下面填充了很多属于该组类型的节点。我将这些分组的信息存储在 palette_config.js 文件中，由于三组中的信息量太大，这里只将一小部分的信息展示出来，看看是如何通过 json 对象来对分组进行数据显示的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
palette_config =&lt;span&gt; {
    scene: {
        name: &lt;/span&gt;'电力'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'文字', image: '__text__'&lt;span&gt;, type: ht.Text },
            { name: &lt;/span&gt;'箭头', image: 'symbols/arrow.json'&lt;span&gt; },
            { name: &lt;/span&gt;'地线', image: 'symbols/earthwire.json'&lt;span&gt; }
        ]
    },
    food: {
        name: &lt;/span&gt;'食品加工厂'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'间歇式流化床处理器', image: 'symbols/food/Batch fluid bed processor.json'&lt;span&gt;},
            { name: &lt;/span&gt;'啤酒瓶', image: 'symbols/food/Beer bottle.json'&lt;span&gt;},
            { name: &lt;/span&gt;'台式均质机', image: 'symbols/food/Batch fluid bed processor.json'&lt;span&gt;}
        ]
    },
    pumps: {
        name: &lt;/span&gt;'污水处理'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'3维泵', image: 'symbols/pumps/3-D Pump.json'&lt;span&gt;},
            { name: &lt;/span&gt;'18-惠勒卡车', image: 'symbols/pumps/18-wheeler truck 1.json'&lt;span&gt;}
        ]
    }     
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过遍历这个对象获取内部数据，显示不同的数据信息。当然，在获取对象的信息的时候，我们需要创建 ht.Group 类的对象，以及分组内部的 ht.Node 类的元素（这些元素都为组的孩子），然后将这些获取来的数据赋值到这两种类型的节点上，并且将这些节点添加到 Palette 的数据容器中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; initPalette(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化组件面板中的内容&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; palette_config){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从 palette_config.js 文件中获取数据&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; info =&lt;span&gt; palette_config[name];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; group = &lt;span&gt;new&lt;/span&gt; ht.Group();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组件面板用ht.Group展示分组，ht.Node展示按钮元素&lt;/span&gt;
&lt;span&gt;        group.setName(info.name);
        group.setExpanded(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置group默认关闭&lt;/span&gt;
        palette.dm().add(group);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点添加到 palette 的数据容器中&lt;/span&gt;
&lt;span&gt;        
        info.items.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; ht.Node();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建 ht.Node 类型节点&lt;/span&gt;
            node.setName(item.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置名称 用于显示在 palette 面板中节点下方说明文字&lt;/span&gt;
            node.setImage(item.image);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点在 palette 面板中的显示图片&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本类型&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (item.type === ht.Text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 json 对象中设置的 type 信息来获取当前信息为何种类型的节点，不同类型的节点有些属性设置不同&lt;/span&gt;
&lt;span&gt;                node.s({
                    &lt;/span&gt;'text': 'Text',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本类型的节点需要设置这个属性显示文本的内容&lt;/span&gt;
                    'text.align': 'center',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本对齐方式&lt;/span&gt;
                    'text.vAlign': 'middle',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本垂直对齐方式&lt;/span&gt;
                    'text.font': '32px Arial'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本字体&lt;/span&gt;
&lt;span&gt;                });
            }

            node.item &lt;/span&gt;=&lt;span&gt; item;
            node.s({
                &lt;/span&gt;'image.stretch': item.stretch || 'centerUniform',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点显示图片为填充的方式，这样不同比例的图片也不会因为拉伸而导致变形&lt;/span&gt;
                'draggable': item.draggable === undefined ? &lt;span&gt;true&lt;/span&gt; : item.draggable,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点是否可被拖拽&lt;/span&gt;
&lt;span&gt;
            });                          
            group.addChild(node);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点设置为 group 组的孩子&lt;/span&gt;
            palette.dm().add(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点同样也得添加到 palette 的数据容器中进行存储&lt;/span&gt;
&lt;span&gt;        });
    }             
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;graphView 拓扑组件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180409124531515-2020865665.gif&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面说到了 Palette 组件中节点拖拽到 graphView 拓扑图形中，来看看这个部分是如何实现的。graphView 拓扑组件是 &lt;a href=&quot;http://hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT&lt;/a&gt; 非常重要的一个组件，了解它非常有必要。如果 Palette 中的 Node 的 draggable 属性设置为  true ，那么 Palette 可以自动处理 dragstart ，但是 dragover 和 dragdrop 事件需要我们处理，我们知道 IOS 和 Android 设备上并不支持 dragover 和 dragdrop 这类事件，所以 Palette 插件还提供了模拟的拖拽事件 handleDragAndDrop，可以完美兼容 PC 和手持终端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initGraphView(){       
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ht.Default.isTouchable){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为触屏可Touch方式交互&lt;/span&gt;
        palette.handleDragAndDrop = &lt;span&gt;function&lt;/span&gt;(e, state) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写此方法可以禁用HTML5原生的Drag和Drop事件并启用模拟的拖拽事件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(ht.Default.containedInView(e, g2d)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断交互事件所处位置是否在View组件之上&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(state === 'between'&lt;span&gt;){
                    e.preventDefault();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消事件的默认动作。&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(state === 'end'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当state为end时，判断e是否在graphView的范围内，如果是，则创建Node&lt;/span&gt;
&lt;span&gt;                    handleDrop(e);
                }
            }
        };
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        g2d.getView().addEventListener(&lt;/span&gt;&quot;dragover&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            e.dataTransfer.dropEffect &lt;/span&gt;= &quot;copy&quot;&lt;span&gt;;
            e.preventDefault();
        });
        g2d.getView().addEventListener(&lt;/span&gt;&quot;drop&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            handleDrop(e);
        });
    }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; handleDrop(e){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被拖拽的元素在目标元素上同时鼠标放开触发的事件&lt;/span&gt;
&lt;span&gt;    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; paletteNode = palette.dm().sm().ld();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 palette 面板上最后选中的节点                 &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (paletteNode) {   
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; paletteNode.item,
            image &lt;/span&gt;=&lt;span&gt; item.image;
            data &lt;/span&gt;= g2d.getDataAt(e, &lt;span&gt;null&lt;/span&gt;, 5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件下的节点&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; (item.type ||&lt;span&gt; ht.Node)();
        node.setImage(image); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点图片&lt;/span&gt;
        node.setName(item.name);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点名称&lt;/span&gt;
        node.p(g2d.lp(e));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的坐标为拓扑中的逻辑坐标 lp函数为将事件坐标转换为拓扑中的逻辑坐标&lt;/span&gt;
        node.s('label', '');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点在 graphView 中底部不显示 setName 中的说明。因为 label 的优先级大于 name &lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Group){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拖拽到“组类型”的节点上，那么直接设置父亲孩子关系&lt;/span&gt;
            node.setParent(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的父亲&lt;/span&gt;
            data.setExpanded(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展开分组&lt;/span&gt;
        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            node.setParent(g2d.getCurrentSubGraph());
        }       
        g2d.dm().add(node);
        g2d.sm().ss(node);                                                     
    }                    
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在 graphView 拓扑图的场景中央添加了一个 json 场景，通过 dm.deserialize(datamodel_config) 反序列化 json 场景内容导出的一个电信行业的图纸。HT 独特的矢量引擎功能满足电力行业设备种类繁多、设备图元和线路网络需无极缩放、绑定量测数据实时刷新等需求；三维呈现技术使得电力厂站和变压器等设备 3D 可视化监控成为可能。&lt;/p&gt;
&lt;h2&gt;treeView 树组件 &lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410150808298-1753912310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于树组件，树组件和 graphView  拓扑组件共用同一个 dataModl 数据容器，本来只需要创建出一个树组件对象，然后将其添加进布局容器中即可显示当前拓扑图形中的所有的数据节点，一般 HT 会将树组件上的节点分为几种类型进行显示，ht.Edge、ht.Group、ht.Node、ht.SubGraph、ht.Shape 等类型进行显示，但是这样做有一个问题，如果创建的节点非常多的话，那么无法分辨出那个节点是哪一个，也就无法快速地定位和修改该节点，会给绘图人员带来很大的困扰，所以我在 treeView 的 label 和 icon 的显示上做了一些处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化树组件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initTreeView() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重载树组件上的文本显示&lt;/span&gt;
    treeView.getLabel = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Text) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.s('text'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Shape) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.getName() || '不规则图形'&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.getName() || '节点'&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重载树组件上的图标显示&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oldGetIconFunc =&lt;span&gt; treeView.getIcon;
    treeView.getIcon &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Text) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'symbols/text.json'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img =&lt;span&gt; data.getImage();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img ? img : oldGetIconFunc.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; propertyPane 属性面板&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410164620695-1217052817.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性面板，即为显示属性的一个容器，不同的类型的节点可能在属性的显示上有所不同，所以我在 properties_config.js 文件中将几个比较常见的类型的属性存储到数组中，主要有几种属性： text_properties 用于显示文本类型的节点的属性、data_properties 所有的 data 节点均显示的属性、node_properties 用于显示 ht.Node 类型的节点的属性、group_properties 用于显示 ht.Group 类型的节点的属性以及 edge_properties 用于显示 ht.Edge 类型的节点的属性。通过将这些属性分类，我们可以对在 graphView 中选中的不同的节点类型来对属性进行过滤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; initPropertyView(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化属性组件               &lt;/span&gt;
    dataModel.sm().ms(&lt;span&gt;function&lt;/span&gt;(e){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听选中变化事件&lt;/span&gt;
        propertyView.setProperties(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; dataModel.sm().ld();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对不同类型的节点设置不同的属性内容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; ht.Text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(text_properties);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Data){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; data 类型，所有的节点都基于这个类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(data_properties);
        }                                        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Node){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node 类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(node_properties);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Group){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(group_properties);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Edge){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(edge_properties);
        }     &lt;/span&gt;
&lt;span&gt;    });                
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据绑定在属性栏中也有体现，拿 data_properties 中的“标签”和“可编辑”作为演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    name: &lt;/span&gt;'name',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置了 name 属性，如果没有设置 accessType 则默认通过 get/setName 来获取和设置 name 值&lt;/span&gt;
    displayName: '名称',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存取属性名的显示文本值，若为空则显示name属性值&lt;/span&gt;
    editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该属性是否可编辑                       &lt;/span&gt;
&lt;span&gt;}, 
{
    name: &lt;/span&gt;'2d.editable',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结合 accessType，则通过 node.s('2d.editable') 获取和设置该属性&lt;/span&gt;
    accessType: 'style',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作存取属性类型&lt;/span&gt;
    displayName: '可编辑',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于存取属性名的显示文本值，若为空则显示name属性值&lt;/span&gt;
    valueType: 'boolean',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;布尔类型，显示为勾选框&lt;/span&gt;
    editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该属性是否可编辑  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个属性比较有代表性，一个是直接通过 get/set 来设置 name 属性值，一个是通过结合属性的类型来控制 name 的属性值。只要在属性栏中操作“名称”和“可编辑”两个属性，就可以直接在拓扑图中看到对应的节点的显示情况，这就是数据绑定。当然，还可以对矢量图形进行局部的数据绑定，但是不是本文的重点，有兴趣的可以参考我的这篇文章 &lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/xhload3d/p/8620358.html&quot;&gt;WebGL 3D 电信机架实战之数据绑定&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;toolbar 工具栏&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410154352600-946308204.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;差点忘记说这个部分了，toolbar 上总共有 8 种功能，分别是选中编辑、连线、直角连线、不规则图形、刻度尺显示、场景放大、场景缩小以及场景内容导出 json。这 8 种功能都是存储在 toolbar_config.js 文件中的，通过绘制 toolbar 中的元素给每一个元素都添加上了对应的点击触发的内容，主要讲讲 CreateEdgeInteractor.js 创建连线的内容。&lt;/p&gt;
&lt;p&gt;我们通过 ht.Default.def 自定义了 CreateEdgeInteractor 类，然后通过 graphView.setInteractors([ new CreateEdgeInteractor(graphView, 'points')]) 这种方式来添加 graphView 拓扑图中的交互器，可以实现创建连线的交互功能。&lt;/p&gt;
&lt;p&gt;在 CreateEdgeInteractor 类中通过监听 touchend 放手后事件向 graphView 拓扑图中添加一个 edge 连线，可以通过在 CreateEdgeInteractor 函数中传参来绘制不同的连线类型，比如 “ortho” 则为折线类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.604501607717&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CreateEdgeInteractor = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (graphView, type) {
    CreateEdgeInteractor.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, graphView);   
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._type =&lt;span&gt; type;
};
ht.Default.def(CreateEdgeInteractor, DNDInteractor, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义类，继承 DNDInteractor，此交互器有一些基本的交互功能&lt;/span&gt;
    handleWindowTouchEnd: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redraw();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isPoints = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._target){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; edge = &lt;span&gt;new&lt;/span&gt; ht.Edge(&lt;span&gt;this&lt;/span&gt;._source, &lt;span&gt;this&lt;/span&gt;._target);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一条连线，传入起始点和终点&lt;/span&gt;
&lt;span&gt;            edge.s({
                &lt;/span&gt;'edge.type': &lt;span&gt;this&lt;/span&gt;._type&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置连线类型 为传入的参数 type 类型 参考 HT for Web &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/edgetype/ht-edgetype-guide.html#ref_edgetype&quot; target=&quot;_blank&quot;&gt;连线类型&lt;/a&gt;&lt;/span&gt;
&lt;span&gt;            });
            isPoints &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;._type === 'points';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有设置则默认为 points 连线方式&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isPoints){
                edge.s({
                    &lt;/span&gt;'edge.points': [{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置连线的点&lt;/span&gt;
                         x: (&lt;span&gt;this&lt;/span&gt;._source.p().x + &lt;span&gt;this&lt;/span&gt;._target.p().x)/2,
                         y: (&lt;span&gt;this&lt;/span&gt;._source.p().y + &lt;span&gt;this&lt;/span&gt;._target.p().y)/2
&lt;span&gt;                    }]
                });                
            }
            edge.setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.getCurrentSubGraph());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置连线的父亲节点为当前子网&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;._graphView.getDataModel().add(edge); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将连线添加到拓扑图的数据容器中&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;._graphView.getSelectionModel().setSelection(edge);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置选中该节点                        &lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.removeTopPainter(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除顶层Painter&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isPoints){
            resetDefault();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重置toolbar导航栏的状态&lt;/span&gt;
&lt;span&gt;        }        
    }            
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 一开始想说要做这个编辑器还有点怕怕的，就是感觉任务重，但是不上不行，所以总是在拖，但是后来整体分析下来，发现其实一步一步来就好，不要把步骤想得太复杂，什么事情都是从小堆到大的，以前我们用 svg 绘制的图形都可以在这上面绘制，当然，如果有需要拓展也完全 ok，毕竟别人写的编辑器不一定能够完全满足你的要求。这个编辑器虽说在画图上面跟别家无异，但是最重要的是它能够绘制出矢量图形，结合 HT 的数据绑定和动画，我们就可以对这些矢量图形中的每一个部分进行操作，比如灯的闪烁啊，比如人眨眼睛等等操作，至于这些都是后话了。有了这个编辑器我也能够更加快速地进行开发了~&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 23:28:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8759227.html</dc:identifier>
</item>
<item>
<title>MyBatis(1)——快速入门 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/8853461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/8853461.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-d2f3f8fbccb13196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mybatis-简介&quot;&gt;MyBatis 简介&lt;/h2&gt;
&lt;p&gt;MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;持久层：&lt;/strong&gt; 可以将业务数据&lt;strong&gt;存储到磁盘，具备长期存储能力&lt;/strong&gt;，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 可以&lt;strong&gt;使用巨大的磁盘空间&lt;/strong&gt;存储相当量的数据，并且很&lt;strong&gt;廉价&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：慢&lt;/strong&gt;（相对于内存而言）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;为什么使用-mybatis&quot;&gt;为什么使用 MyBatis&lt;/h4&gt;
&lt;p&gt;在我们&lt;strong&gt;传统的 JDBC 中&lt;/strong&gt;，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的&lt;strong&gt;繁琐又枯燥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而我们在使用了 &lt;strong&gt;MyBatis&lt;/strong&gt; 之后，&lt;strong&gt;只需要提供 SQL 语句就好了&lt;/strong&gt;，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的&lt;strong&gt;关注点于是可以就此集中在 SQL 语句上&lt;/strong&gt;，关注在增删改查这些操作层面上。&lt;/p&gt;
&lt;p&gt;并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;搭建-mybatis-环境&quot;&gt;搭建 MyBatis 环境&lt;/h2&gt;
&lt;p&gt;首先，我们需要先下载和搭建 MyBatis 的开发环境。&lt;/p&gt;
&lt;h4 id=&quot;下载-mybatis-工程包&quot;&gt;下载 MyBatis 工程包&lt;/h4&gt;
&lt;p&gt;打开链接 &lt;a href=&quot;http://github.com/mybatis/mybatis-3/releases&quot; class=&quot;uri&quot;&gt;http://github.com/mybatis/mybatis-3/releases&lt;/a&gt; 下载 MyBatis 所需要的包和源码，当前最新版本为 3.4.6，官方还提供了文档： &lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot;&gt;戳这里&lt;/a&gt;，虽然感觉写得一般，但还是有一些参考价值...唉，别当教程看，当字典看！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ee64e4e10d1417c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载好 MyBatis 的包解压后，可以得到以下的文件目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-4e53628814f8a285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 mybatis-3.4.6.jar 包就是 MyBatis 的项目工程包，【lib】文件夹下就是 MyBatis 项目需要依赖的第三方包，pdf 文件是它英文版的说明，不要英文也可以戳上面的链接。&lt;/p&gt;
&lt;h4 id=&quot;为-idea-配置-mybatis-环境&quot;&gt;为 IDEA 配置 MyBatis 环境&lt;/h4&gt;
&lt;p&gt;IDEA 默认是不支持 MyBatis 开发的，需要自己下载第三方插件来支持，可惜的是功能强大的【MyBatis Plugin】是收费的，需要我们自己破解！&lt;/p&gt;
&lt;h4 id=&quot;第一步在-idea-中下载-mybatis-plugin&quot;&gt;第一步：在 IDEA 中下载 MyBatis Plugin&lt;/h4&gt;
&lt;p&gt;在【File】菜单下找到【Settings】，然后再【Plugins】下点击【Browse repositories..】：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ef2c926134056cc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在搜索栏中输入【MyBatis Plugin】，然后点击【Install】（我这里是安装好了所以没有这个按钮）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-893e957096a5219b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二步破解&quot;&gt;第二步：破解&lt;/h4&gt;
&lt;p&gt;有幸找到最新的&lt;a href=&quot;https://shawnho.me/2017/12/20/ideaagent/&quot;&gt;破解方法&lt;/a&gt;，最新支持破解的版本号为：v3.58 crack，下载链接：&lt;a href=&quot;https://github.com/mrshawnho/ideaagent/releases&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-307aedb0c5f98f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把它下载到 【D:\Download】目录下，打开 idea.vmoptions （【Help】&lt;code&gt;-&amp;gt;&lt;/code&gt; 【Eidt Custom VM Options...】）：&lt;br/&gt;在下方插入 &lt;code&gt;-javaagent:D:/Download/ideaagent-1.2.jar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2b61569cdd41ed6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启 IDEA，首次启动需要信任本地服务器 ssl 证书，点击接受后如未激活，再次重启即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-b03ccfdd09445118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们就为 IDEA 配置好了 MyBatis 的开发环境，可以检验一下是否安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-9be9d1f19a7428b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;第一个-mybatis-程序&quot;&gt;第一个 MyBatis 程序&lt;/h2&gt;
&lt;p&gt;我们来实际开发一个 MyBatis 程序，感受一下。&lt;/p&gt;
&lt;h4 id=&quot;第一步准备数据库&quot;&gt;第一步：准备数据库&lt;/h4&gt;
&lt;p&gt;首先我们创建一个数据库【mybatis】，编码方式设置为 UTF-8，然后再创建一个名为【student】的表，插入几行数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP DATABASE IF EXISTS mybatis;
CREATE DATABASE mybatis DEFAULT CHARACTER SET utf8;

use mybatis;
CREATE TABLE student(
  id int(11) NOT NULL AUTO_INCREMENT,
  studentID int(11) NOT NULL UNIQUE,
  name varchar(255) NOT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO student VALUES(1,1,'我没有三颗心脏');
INSERT INTO student VALUES(2,2,'我没有三颗心脏');
INSERT INTO student VALUES(3,3,'我没有三颗心脏');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步创建工程&quot;&gt;第二步：创建工程&lt;/h4&gt;
&lt;p&gt;在 IDEA 中新建一个 Java 工程，并命名为【HelloMybatis】，然后导入必要的 jar 包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mybatis-3.4.6.jar&lt;/li&gt;
&lt;li&gt;mysql-connector-java-5.1.21-bin.jar&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-d84c564a30836343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第三步创建实体类&quot;&gt;第三步：创建实体类&lt;/h4&gt;
&lt;p&gt;在 Package【pojo】下新建实体类【Student】，用于映射表 student：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pojo;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Student {

    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; studentID;
    String name;

    &lt;span class=&quot;co&quot;&gt;/* getter and setter */&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;第四步配置文件-mybatis-config.xml&quot;&gt;第四步：配置文件 mybatis-config.xml&lt;/h4&gt;
&lt;p&gt;在【src】目录下创建 MyBaits 的主配置文件 &lt;code&gt;mybatis-config.xml&lt;/code&gt; ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等，我们在后面说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!-- 别名 --&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&quot;pojo&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
    &amp;lt;!-- 数据库环境 --&amp;gt;
    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!-- 映射文件 --&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;pojo/Student.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;

&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第五步配置文件-student.xml&quot;&gt;第五步：配置文件 Student.xml&lt;/h4&gt;
&lt;p&gt;在 Package【pojo】下新建一个【Student.xml】文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;

&amp;lt;mapper namespace=&quot;pojo&quot;&amp;gt;
    &amp;lt;select id=&quot;listStudent&quot; resultType=&quot;Student&quot;&amp;gt;
        select * from  student
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;由于上面配置了 &lt;code&gt;&amp;lt;typeAliases&amp;gt;&lt;/code&gt; 别名，所以在这里的 &lt;code&gt;resultType&lt;/code&gt; 可以直接写 Student，而不用写类的全限定名 pojo.Student&lt;/li&gt;
&lt;li&gt;&lt;code&gt;namespace&lt;/code&gt; 属性其实就是对 SQL 进行分类管理，实现不同业务的 SQL 隔离&lt;/li&gt;
&lt;li&gt;SQL 语句的增删改查对应的标签有：&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第六步编写测试类&quot;&gt;第六步：编写测试类&lt;/h4&gt;
&lt;p&gt;在 Package【test】小创建测试类【TestMyBatis】：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package test;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.io.Resources;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSession;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactoryBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import pojo.Student;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.InputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestMyBatis {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;co&quot;&gt;// 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory&lt;/span&gt;
        String resource = &lt;span class=&quot;st&quot;&gt;&quot;mybatis-config.xml&quot;&lt;/span&gt;;
        InputStream inputStream = Resources.&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(resource);
        SqlSessionFactory sqlSessionFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SqlSessionFactoryBuilder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(inputStream);
        &lt;span class=&quot;co&quot;&gt;// 然后根据 sqlSessionFactory 得到 session&lt;/span&gt;
        SqlSession session = sqlSessionFactory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent&lt;/span&gt;
        List&amp;lt;Student&amp;gt; listStudent = session.&lt;span class=&quot;fu&quot;&gt;selectList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;listStudent&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Student student : listStudent) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ID:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;,NAME:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行测试类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c2c66782d5df0c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;基本原理&quot;&gt;基本原理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;应用程序找 MyBatis 要数据&lt;/li&gt;
&lt;li&gt;MyBatis 从数据库中找来数据&lt;br/&gt;1.通过 mybatis-config.xml 定位哪个数据库&lt;br/&gt;2.通过 Student.xml 执行对应的 sql 语句&lt;br/&gt;3.基于 Student.xml 把返回的数据库封装在 Student 对象中&lt;br/&gt;4.把多个 Student 对象装载一个 Student 集合中&lt;/li&gt;
&lt;li&gt;返回一个 Student 集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-805df95a65b023e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.7045454545455&quot;&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html#nowhere&quot;&gt;How2j.cn-MyBatis 相关教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;crud-操作&quot;&gt;CRUD 操作&lt;/h2&gt;
&lt;p&gt;我们来看看常规的一套增删改查应该怎么实现：&lt;/p&gt;
&lt;h4 id=&quot;第一步配置-student.xml&quot;&gt;第一步：配置 Student.xml&lt;/h4&gt;
&lt;p&gt;首先，我们在 SQL 映射文件中新增语句，用来支撑 CRUD 的系列操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;

&amp;lt;mapper namespace=&quot;pojo&quot;&amp;gt;
    &amp;lt;select id=&quot;listStudent&quot; resultType=&quot;Student&quot;&amp;gt;
        select * from  student
    &amp;lt;/select&amp;gt;

    &amp;lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&amp;gt;
        insert into student (id, studentID, name) values (#{id},#{studentID},#{name})
    &amp;lt;/insert&amp;gt;

    &amp;lt;delete id=&quot;deleteStudent&quot; parameterType=&quot;Student&quot;&amp;gt;
        delete from student where id = #{id}
    &amp;lt;/delete&amp;gt;

    &amp;lt;select id=&quot;getStudent&quot; parameterType=&quot;_int&quot; resultType=&quot;Student&quot;&amp;gt;
        select * from student where id= #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&amp;gt;
        update student set name=#{name} where id=#{id}
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;parameterType：要求输入参数的类型&lt;/li&gt;
&lt;li&gt;resultType：输出的类型&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第二步实现增删改查&quot;&gt;第二步：实现增删改查&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package test;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.io.Resources;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSession;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactoryBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import pojo.Student;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.io.InputStream;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestMyBatis {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;co&quot;&gt;// 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory&lt;/span&gt;
        String resource = &lt;span class=&quot;st&quot;&gt;&quot;mybatis-config.xml&quot;&lt;/span&gt;;
        InputStream inputStream = Resources.&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(resource);
        SqlSessionFactory sqlSessionFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SqlSessionFactoryBuilder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(inputStream);
        &lt;span class=&quot;co&quot;&gt;// 然后根据 sqlSessionFactory 得到 session&lt;/span&gt;
        SqlSession session = sqlSessionFactory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// 增加学生&lt;/span&gt;
        Student student1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Student&lt;/span&gt;();
        student1.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        student1.&lt;span class=&quot;fu&quot;&gt;setStudentID&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        student1.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;新增加的学生&quot;&lt;/span&gt;);
        session.&lt;span class=&quot;fu&quot;&gt;insert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;addStudent&quot;&lt;/span&gt;, student1);

        &lt;span class=&quot;co&quot;&gt;// 删除学生&lt;/span&gt;
        Student student2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Student&lt;/span&gt;();
        student2.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        session.&lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;deleteStudent&quot;&lt;/span&gt;, student2);

        &lt;span class=&quot;co&quot;&gt;// 获取学生&lt;/span&gt;
        Student student3 = session.&lt;span class=&quot;fu&quot;&gt;selectOne&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;getStudent&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;// 修改学生&lt;/span&gt;
        student3.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;修改的学生&quot;&lt;/span&gt;);
        session.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;updateStudent&quot;&lt;/span&gt;, student3);

        &lt;span class=&quot;co&quot;&gt;// 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent&lt;/span&gt;
        List&amp;lt;Student&amp;gt; listStudent = session.&lt;span class=&quot;fu&quot;&gt;selectList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;listStudent&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Student student : listStudent) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ID:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;,NAME:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
        }

        &lt;span class=&quot;co&quot;&gt;// 提交修改&lt;/span&gt;
        session.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 关闭 session&lt;/span&gt;
        session.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述的程序中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;code&gt;session.insert(&quot;addStudent&quot;, student1);&lt;/code&gt; 增加了一个 ID 和 studentID 都为 4，名字为“新增加的学生” 的学生&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;session.delete(&quot;deleteStudent&quot;, student2);&lt;/code&gt; 删除了 ID = 1 的学生&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Student student3 = session.selectOne(&quot;getStudent&quot;, 2);&lt;/code&gt; 获取了 ID = 2的学生&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;session.update(&quot;updateStudent&quot;, student3);&lt;/code&gt; 将 ID = 2 的学生的名字修改为 “修改的学生”&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;session.commit()&lt;/code&gt; 来提交事务，也可以简单理解为更新到数据库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行获得正确结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-255365369cb37257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;模糊查询&quot;&gt;模糊查询&lt;/h4&gt;
&lt;p&gt;如果要对数据库中的 student 表进行模糊查询，需要通过匹配名字中的某个字来查询该用户。&lt;/p&gt;
&lt;p&gt;我们首先在 Student.xml 配置文件中配置 SQL 映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;select id=&quot;findStudentByName&quot; parameterMap=&quot;java.lang.String&quot; resultType=&quot;Student&quot;&amp;gt;
    SELECT * FROM student WHERE name LIKE '%${value}%' 
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 标签对中 SQL 语句的 “${}” 符号，表示拼接 SQL 串，将接受的参数内容&lt;strong&gt;不加任何修饰地拼接在 SQL 中，在 “${}” 中只能使用 &lt;code&gt;value&lt;/code&gt; 来代表其中的参数。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为是模糊查询，所以得到的查询结果可能不止一个，所以我们使用 SqlSession 的 selectList() 方法，写一个测试方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {

    &lt;span class=&quot;co&quot;&gt;// 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory&lt;/span&gt;
    String resource = &lt;span class=&quot;st&quot;&gt;&quot;mybatis-config.xml&quot;&lt;/span&gt;;
    InputStream inputStream = Resources.&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(resource);
    SqlSessionFactory sqlSessionFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SqlSessionFactoryBuilder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(inputStream);
    &lt;span class=&quot;co&quot;&gt;// 然后根据 sqlSessionFactory 得到 session&lt;/span&gt;
    SqlSession session = sqlSessionFactory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();

    &lt;span class=&quot;co&quot;&gt;// 模糊查询&lt;/span&gt;
    List&amp;lt;Student&amp;gt; students = session.&lt;span class=&quot;fu&quot;&gt;selectList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;findStudentByName&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;三颗心脏&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Student student : students) {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ID:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;,NAME:&quot;&lt;/span&gt; + student.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-82018fbe86b9da7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结一下&quot;&gt;总结一下&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关于 parameterType：&lt;/strong&gt; 就是用来在 SQL 映射文件中指定输入参数类型的，可以指定为基本数据类型（如 int、float 等）、包装数据类型（如 String、Interger 等）以及用户自己编写的 JavaBean 封装类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于 resultType：&lt;/strong&gt; 在加载 SQL 配置，并绑定指定输入参数和运行 SQL 之后，会得到数据库返回的响应结果，此时使用 resultType 就是用来指定数据库返回的信息对应的 Java 的数据类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于 “#{}” ：&lt;/strong&gt; 在传统的 JDBC 的编程中，占位符用 “?” 来表示，然后再加载 SQL 之前按照 “?” 的位置设置参数。而 “#{}” 在 MyBatis 中也代表一种占位符，该符号接受输入参数，在大括号中编写参数名称来接受对应参数。当 “#{}” 接受简单类型时可以用 &lt;code&gt;value&lt;/code&gt; 或者其他任意名称来获取。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于 “${}” ：&lt;/strong&gt; 在 SQL 配置中，有时候需要拼接 SQL 语句（例如模糊查询时），用 “#{}” 是无法达到目的的。在 MyBatis 中，“${}” 代表一个 “拼接符号” ，可以在原有 SQL 语句上拼接新的符合 SQL 语法的语句。使用 “${}” 拼接符号拼接 SQL ，会引起 SQL 注入，所以一般不建议使用 “${}”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MyBatis 使用场景：&lt;/strong&gt; 通过上面的入门程序，不难看出在进行 MyBatis 开发时，我们的大部分精力都放在了 SQL 映射文件上。 &lt;strong&gt;MyBatis 的特点就是以 SQL 语句为核心的不完全的 ORM（关系型映射）框架。&lt;/strong&gt;与 Hibernate 相比，Hibernate 的学习成本比较高，而 SQL 语句并不需要开发人员完成，只需要调用相关 API 即可。这对于开发效率是一个优势，但是缺点是没办法对 SQL 语句进行优化和修改。而 MyBatis 虽然需要开发人员自己配置 SQL 语句，MyBatis 来实现映射关系，但是这样的项目可以适应经常变化的项目需求。&lt;strong&gt;所以使用 MyBatis 的场景是：对 SQL 优化要求比较高，或是项目需求或业务经常变动。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;《Java EE 互联网轻量级框架整合开发》&lt;/li&gt;
&lt;li&gt;《Spring MVC + MyBatis开发从入门到项目实战》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://how2j.cn/k/mybatis/mybatis-tutorial/1087.html&quot;&gt;How2j-MyBatis 系列教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;全能的百度和万能的大脑&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 15 Apr 2018 23:01:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/8853461.html</dc:identifier>
</item>
<item>
<title>用 k8s 管理机密信息 - 每天5分钟玩转 Docker 容器技术（155） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8848295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8848295.html</guid>
<description>&lt;p&gt;&lt;span&gt;应用启动过程中可能需要一些敏感信息，比如访问数据库的用户名密码或者秘钥。将这些信息直接保存在容器镜像中显然不妥，Kubernetes 提供的解决方案是 Secret。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Secret 会以密文的方式存储数据，避免了直接在配置文件中保存敏感信息。Secret 会以 Volume 的形式被 mount 到 Pod，容器可通过文件的方式使用 Secret 中的敏感数据；此外，容器也可以环境变量的方式使用这些数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Secret 可通过命令行或 YAML 创建。比如希望 Secret 中包含如下信息：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用户名 &lt;/span&gt;&lt;code&gt;&lt;span&gt;admin&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;密码 &lt;/span&gt;&lt;code&gt;&lt;span&gt;123456&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;创建 Secret&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有四种方法创建 Secret：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-literal&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;kubectl create secret generic mysecret --from-literal=username=admin --from-literal=password=123456&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-literal&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对应一个信息条目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;echo -n admin &amp;gt; ./username
echo -n 123456 &amp;gt; ./password
kubectl create secret generic mysecret --from-file=./username --from-file=./password&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;每个文件内容对应一个信息条目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3. 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--from-env-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; env.txt
username=admin
password=123456
EOF
kubectl create secret generic mysecret --from-env-file=env.txt&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;env.txt&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中每行 Key=Value 对应一个信息条目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 通过 YAML 配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180415171356791-141178508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件中的敏感数据必须是通过 base64 编码后的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180415171407353-1783447577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建 Secret：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180415171421036-845608010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们学习如何使用这些创建好的 Secret。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 22:30:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8848295.html</dc:identifier>
</item>
<item>
<title>我是如何在公司项目中使用ESLint来提升代码质量的 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8853439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8853439.html</guid>
<description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;ESLint：你认识我吗&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033458080-1488109832.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;ESLint是一个语法规则和代码风格的检查工具。&lt;/p&gt;
&lt;p&gt;和学习所有编程语言一样，想要入门ESLint，首先要去它的官网看看：https://eslint.org/。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;ESLint的版本问题&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033519348-1826438361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前ESLint的稳定版本是v4.19.1，如果你看过ESLint的官方文档，就会知道官网推出了ESLint v5.0.0-alpha.1，这是ESLint的一个主要版本升级。&lt;/p&gt;
&lt;p&gt;由于这是预发布版本，ESLint尚未准备好用于生产，因此我们不会通过npm自动升级。next安装时必须指定标签： &lt;code&gt;$ npm i eslint@next --save-dev&lt;/code&gt; ，这句命令从 npm 仓库安装了 ESLint CLI，如果想尝试下新功能的童鞋可以安装捣鼓一番。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;为什么我们要在项目中使用ESLint&lt;/h2&gt;
&lt;p&gt;ESLint可以校验我们写的代码，给代码定义一个规范，项目里的代码必须按照这个规范写。&lt;/p&gt;
&lt;p&gt;加入ESLint有非常多的好处，比如说可以帮助我们避免一些非常低级的错误，一些格式上的问题导致我们在运行生产环境的时候出现一些不明所以的报错。还有就是在跟团队协作的时候，每个人都保持同一个风格进行代码书写，这样团队内部相互去看别人的代码的时候，就可以更容易的看懂。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;ESLint实战小技巧全揭秘&lt;/h2&gt;
&lt;p&gt;那么ESLint如何去使用呢？首先我们要去安装它：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;$ npm install eslint
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于是本地安装还是全局安装，你们可以看项目需求。在这里，我们就不用官方提供的 &lt;code&gt;eslint --init&lt;/code&gt; 来生成我们的配置文件了，后面我们会手动配置。规则也不用我们自己去指定，想看更多规则可以前往官网了解，这里只提供在公司项目中快速上手ESLint的技巧，以及在实战项目中碰到的问题的解决方案。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;用别人的轮子开发自己的项目，省时省力&lt;/h3&gt;
&lt;p&gt;第一个小技巧来了，现在网上有个叫eslint-config-standard的标准的ESLint规则，我们继承这个规则就可以了。这样的话我们项目里按照这个标准规则去开发代码就OK了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033548097-859130018.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;首先我们要去安装ESLint所要用到的一大堆东西：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033602775-1319795161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;$ npm i eslint eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都是eslint-config-standard这个npm包里推荐我们去安装的，因为它的校验规则要依赖于这些plugins进行去验证。&lt;/p&gt;
&lt;p&gt;然后，我们要去项目的根目录里面手动创建一个.eslintrc文件，然后在里面敲入以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;extends&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;standard&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完以上步骤，我们就可以使用ESLint这个工具来校验项目里的代码。&lt;/p&gt;
&lt;p&gt;在Vue项目里，.vue文件写的是类似于html的格式，不是标准的JavaScript文件，ESLint无法直接识别.vue文件里的JavaScript代码，那么这个时候我们需要去安装一个工具，&lt;code&gt;$ npm i eslint-plugin-html -D&lt;/code&gt;，因为在vue文件里面写JavaScript代码也是写在script标签里面的，这个插件的作用就是识别一个文件里面script标签里面的JS代码，官方也是这么推荐的。所以我们要在.eslintrc文件里面新增这么一段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;extends&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;standard&quot;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;plugins&quot;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;html&quot;
  ]
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完以上步骤后，我们跳转到package.json文件里面的scripts里面新增一条命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;lint&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;eslint --ext .js --ext .jsx --ext .vue src/&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;--ext后面需要写上指定检测文件的后缀，如.js、.jsx、 .vue等，紧接着后面要写上一个参数，这个参数就是我们要检测哪个目录下面的文件，一般项目文件都在src下面，所以在后面写上src/就好。&lt;/p&gt;
&lt;p&gt;现在我们就可以到terminal里面输入 &lt;code&gt;$ npm run lint&lt;/code&gt;，来检验项目里的代码是否符合ESLint的规则。&lt;/p&gt;
&lt;p&gt;一般来说，我们项目在前期没有加入ESLint的时候，后期我们加入了之后跑一下，基本上都会出现非常的多报错，一执行检查就是满屏的error和warning，简直是丧心病狂不堪入目~&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;如何让ESLint自动修复报错，提高开发效率&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033633500-1983076604.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;在报这么多的错误之后，如果我们一条一条地去修复，就会变的非常的麻烦，相信刚接触ESLint的童鞋都深有体会。其实这些错误都可以让ESLint帮助我们自动地修复。&lt;/p&gt;
&lt;p&gt;那么我们该怎么做呢？继续在package.json文件里面的scripts里面新增一条命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;lint-fix&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;eslint --fix --ext .js --ext .jsx --ext .vue src/&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在ESLint后面加上一个参数--fix，它就会自动修复Lint出来的问题。当我们再去terminal里面跑一下：&lt;code&gt;$ npm run lint-fix&lt;/code&gt; ，你会发现，世界一下安静了许多，没有那么多飘红的报错，没有满屏的error和warning。&lt;/p&gt;
&lt;p&gt;当然，还有一种万能方法，就是在报错的JS文件中第一行写上&lt;code&gt;/* eslint-disable */&lt;/code&gt; ，详情可见官网的User guide（用户指南）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033659185-801189056.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;至此，曾经令人抓狂的ESLint报错此刻却温柔的像只小绵羊。&lt;/p&gt;
&lt;p&gt;不过，你以为事情到这儿就结束了？NO，NO，NO，我们希望ESLint能够做的更多。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;怎么在项目中预处理错误，eslint-loader来帮忙&lt;/h3&gt;
&lt;p&gt;我希望在项目开发的过程当中，每次修改代码，它都能够自动进行ESLint的检查。因为在我们改代码的过程中去做一次检查，如果有错误，我们就能够很快地去定位到这个问题，由于是我们刚刚改过的，因此立马把它修复掉就OK了。这就避免了我们每次改了一大堆代码之后，要去提交的时候，再去跑一次ESLint，有可能有很多地方要去改，浪费我们的时间，因为你一下子就定位不到这个问题在哪里了。同时我们每次改代码的时候去检测，也能改善我们写代码的规范性，让我们慢慢养成规范写代码的习惯。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033726748-851033522.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这个时候我们又要在terminal里面安装东西了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;$ npm i eslint-loader babel-eslint -D
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上述操作后，我们需要跳转到.eslintrc文件里面配置一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;extends&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;standard&quot;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;plugins&quot;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;html&quot;
  ],
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;parser&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;babel-eslint&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么我们要配置parser呢？因为我们的项目是基于webpack的，项目里的代码都是需要经过babel去处理的。babel处理的这种语法可能对ESLint不是特别的支持，然后我们使用loader处理ESLint的时候就会出现一些问题。所以一般来说，我们用webpack和babel来进行开发的项目，都会指定它的parser使用babel-eslint。&lt;/p&gt;
&lt;p&gt;执行完以上步骤之后，在build目录下找到我前几篇文章里讲到的webpack.config.base.js，然后在module下面的rules里面添加一个对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;rules: [
  {
    &lt;span class=&quot;hljs-built_in&quot;&gt;test: /\.(vue|js|jsx)$/,
    loader: &lt;span class=&quot;hljs-string&quot;&gt;'eslint-loader',
    exclude: /node_modules/,
    enforce: &lt;span class=&quot;hljs-string&quot;&gt;'pre'
  },
  ......
]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时大家可能心里纳闷了，闰土啊你写的前面三个我们都能看懂，最后一个 &lt;code&gt;enforece: 'pre'&lt;/code&gt;这是什么鬼？&lt;/p&gt;
&lt;p&gt;别急，且听我慢慢道来。因为.vue文件已经被vue-loader处理过了，而eslint-loader只是做代码检测，肯定不能让它去默认处理.vue文件。所以我们希望vue-loader在处理.vue文件之前，让eslint-loader先进行一次代码检测。如果代码检测都通过不了的话，那么vue-loader就不需要处理了，直接报错就OK了。所以需要加上 &lt;code&gt;enforece: 'pre'&lt;/code&gt;，这叫预处理。&lt;/p&gt;
&lt;p&gt;执行完上述步骤之后，我们就可以去terminal里面尽情地跑一下 &lt;code&gt;$ npm run dev&lt;/code&gt; ，等运行成功后，我们可以在项目里找一个js文件，故意报个错保存一下，比如说多加个空格之类的，然后我们的terminal里面就会马上报错，此刻我猜想terminal的内心活动应该是：“TMD，写的什么烂代码，天天写bug气得我每次脸都涨的通红”~~~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033743355-1643985862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;幸运的是，机器是没有感情的，我们却可以嗨皮地立马定位到错误，然后把它改掉就可以了。至此，ESLint无师自通，真正做到了内心无惧。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;这就是ESLint，辅助编码规范的执行，有效控制项目代码的质量。更多操作指南可以前往官网了解，这里只提供在公司项目中快速上手ESLint的技巧，以及在实战项目中碰到的问题的解决方案。&lt;/p&gt;
&lt;p&gt;不积跬步无以至千里，不积小流无以成江海。希望每一位童鞋都可以在平凡的岗位上积累经验，沉淀技术，早日成为公司团队里的技术骨干！Good luck！&lt;/p&gt;

&lt;hr/&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;预告：更多关于前端工程工作流构建的文章，都会第一时间更新在我的公众号：闰土大叔，欢迎关注！&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201804/701424-20180416033419363-282306795.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 19:42:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8853439.html</dc:identifier>
</item>
<item>
<title>lvs 负载均衡  NAT模式 - 渣码农</title>
<link>http://www.cnblogs.com/yangang92/p/8851568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangang92/p/8851568.html</guid>
<description>&lt;p&gt;1.原理&lt;/p&gt;
&lt;p&gt;基于NAT机制实现。当用户请求到达director之后，director将请求报文的目标地址（即VIP）改成选定的realserver地址，同时将报文的目标端口也改成选定的realserver的相应端口，最后将报文请求发送到指定的realserver。在服务器端得到数据后，realserver将数据返给director，而director将报文的源地址和源端口改成VIP和相应端口，然后把数据发送给用户，完成整个负载调度过程。&lt;/p&gt;
&lt;p&gt;2 环境及组网搭建&lt;/p&gt;
&lt;p&gt;所有的虚拟机均是在vmware中搭建的Ubuntu系统，IP分别为192.168.1.106 192.168.1.109 192.168.1.110，作为负载均衡调度的虚拟机上应该有两块网卡，一个用于提供外部访问的VIP，一个作为跟后端RS建立连接的RIP（两个IP可以不在同一个网段，需要保证RIP和后端的RS在同一网段），因此给106机器增加一块虚拟网卡&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ifconfig eth0:0 192.168.1.10 netmask 255.255.255.255 broadcast 192.168.1.100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于这里我所有的IP都是你能够互相ping通的，因此无需设置默认网关&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/920272/201804/920272-20180416000939231-34675851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这样通过ifconfig命令查看的网卡信息为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/920272/201804/920272-20180416001745110-975084790.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;355&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给109 110两台rs上安装nginx服务，修改nginx访问nginx主页的信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/920272/201804/920272-20180416002011722-171196069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;106机器作为负载均衡器，开启消息转发：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3 通过ipvsadm配置NAT负载均衡&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
ipvsadm -A -t 192.168.1.10:9999 -s rr

ipvsadm -a -t 192.168.1.10:9999 -r 192.168.1.109:80 -m

ipvsadm -a -t 192.168.1.10:9999 -r 192.168.1.110:80 -m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看配置的ipvs信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/920272/201804/920272-20180416002338942-557764051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过curl命令访问虚拟服务，可以看到lvs按照轮训的方式依次将消息转发给109和110处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/920272/201804/920272-20180416002542430-424868041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 16:26:00 +0000</pubDate>
<dc:creator>渣码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangang92/p/8851568.html</dc:identifier>
</item>
<item>
<title>R语言-ggplot初级 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8850239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8850239.html</guid>
<description>&lt;p&gt;ggplot2简介:&lt;/p&gt;
&lt;p&gt;　　　在2005年开始出现,吸取了基础绘图系统和lattice绘图系统的优点,并利用一个强大的模型来对其进行改进,这一模型基于之前所述的一系列准则,&lt;/p&gt;
&lt;p&gt;　　　能够创建任意类型的统计图形&lt;/p&gt;
&lt;p&gt;1.导入包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(maps)
library(maptools)
library(rgdal)
library(plyr)
library(MASS) 
library(dplyr)
library(ggplot2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;案例1:钻石数据集&lt;/p&gt;
&lt;p&gt;　　采用ggplot2自带的钻石数据集.&lt;/p&gt;
&lt;p&gt;　　数据集变量简介&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 主要变量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# price 价格&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# color 颜色&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# carat 重量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# cut 切工&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.1 使用qplot进行简单的快速作图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
set.seed(123&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从整个数据集取出100行进行分析&lt;/span&gt;
dsmall &amp;lt;- diamonds[sample(nrow(diamonds), 100&lt;span&gt;), ]
dim(dsmall)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1根据x和y和数据集自动作图&lt;/span&gt;
qplot(carat, price, data =&lt;span&gt; diamonds)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.2根据log x和log y和数据集,自动作图&lt;/span&gt;
qplot(log(carat), log(price), data =&lt;span&gt; diamonds)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.3根据x和y和数据集按照color进行分类,自动作图&lt;/span&gt;
qplot(carat, price, data = dsmall, colour =&lt;span&gt; color)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.4根据x和y和数据集按照shape进行分类,自动作图&lt;/span&gt;
qplot(carat, price, data = dsmall, shape =&lt;span&gt; cut)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.5根据x和y和数据集,指定作图的类型,自动作图&lt;/span&gt;
qplot(carat, price, data = dsmall, geom = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smooth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.6根据x和y和数据集,做箱线图&lt;/span&gt;
qplot(cut, price / carat, data = diamonds, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boxplot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.7根据x和y和数据集,做条形图&lt;/span&gt;
qplot(color, data = diamonds, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.8根据x和y和数据集,做直方图&lt;/span&gt;
qplot(carat, data = diamonds, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;histogram&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.9根据x和y和数据集,做核密度图&lt;/span&gt;
qplot(carat, data = diamonds, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;density&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415215830550-1913019927.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;236&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415215916869-1778753306.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;236&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220027990-1683696267.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　               图  1.1.1　　　　　　　　　　　　　　　　　　　　　　图  1.1.2                                                                        图  1.1.3&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220136458-842236683.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;238&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220246697-406858541.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;235&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220350849-836126552.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　　　  图 1.1.4　　　　　　　　　　　　　　　　　　　　　　　　　　图 1.1.5　　　　　　　　　　　　　　　　　　图 1.1.6&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220508286-1848137288.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;257&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220604981-1767405532.png&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;258&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415220649075-51627333.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　  图  1.1.7　　　　　　　　　　　　　　　　　　　　　　　　　　图 1.1.8　　　　　　　　　　　　　　　　　　　　图1.1.9&lt;/p&gt;
&lt;p&gt;　　1.2使用qplot进行分组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.10 使用facets对需要分组的字段进行分组&lt;/span&gt;
qplot(carat, data = diamonds, facets = color ~&lt;span&gt; .,
      geom &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;histogram&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, binwidth = 0.1, xlim = c(0, 3&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.11 给图形添加信息&lt;/span&gt;
&lt;span&gt;qplot(
  carat, price, data &lt;/span&gt;=&lt;span&gt; dsmall,
  xlab &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Price ($)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ylab = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weight (carats)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  main &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Price-weight relationship&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415221124010-1265536843.png&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;279&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415221227725-1495108346.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　图 1.1.10 按照不同的颜色对重量进行统计　　　　　　　　　　　　　　　　　　　　　　图 1.1.11 添加和标题,X轴,Y轴解释&lt;/p&gt;
&lt;p&gt;案例2:地图(不包含中国)&lt;/p&gt;
&lt;p&gt;　　ggplot是基于图层进行作图的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
df &amp;lt;- data.frame(x = rnorm(2000), y = rnorm(2000&lt;span&gt;))
norm &lt;/span&gt;&amp;lt;-&lt;span&gt; ggplot(df, aes(x, y))
norm  &lt;span&gt;#&lt;span&gt; 图层1&lt;/span&gt;&lt;/span&gt;
norm &lt;/span&gt;+&lt;span&gt; geom_point() &lt;span&gt; &lt;span&gt;#&lt;span&gt; 图层2&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 改变点的大小和形状&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
norm &lt;/span&gt;+ geom_point(shape = 1&lt;span&gt;) 
norm &lt;/span&gt;+ geom_point(shape = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415224357313-1911965609.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;217&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415224443395-2069187919.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;220&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415224520946-1134239711.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　　　　　　　 图层 1　　　　　　　　　　　　　　　　　　　　　　    图层 2　　　　　　　　　　　　　　　　　　　　　　　　图层3&lt;/p&gt;
&lt;p&gt;　　采用ggplot2自带的美国城市数据集us.city&lt;/p&gt;
&lt;p&gt;　　数据集变量简介&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# name 城市名称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# country.etc 简称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# pop 人口数量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# lat 纬度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# lon 经度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# capital 是否是首府&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.1找出美国人口大于500000的城市&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
big_cities &amp;lt;- subset(us.cities, pop &amp;gt; 500000&lt;span&gt;)
qplot(long, lat, data &lt;/span&gt;= big_cities) + borders(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, size = 0.5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415222031363-544313532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　图 2.1&lt;/p&gt;
&lt;p&gt;　　2.2 做出德州地图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
tx_cities &amp;lt;- subset(us.cities, country.etc == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在使用map做地图的时候,记住x和y一定指的是经纬度&lt;/span&gt;
ggplot(tx_cities, aes(long, lat)) +&lt;span&gt;
  borders(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;county&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;texas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey70&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  geom_point(colour &lt;/span&gt;= alpha(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 0.5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415222235594-374293830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　图 2.2 德州地图&lt;/p&gt;
&lt;p&gt;　　2.3结合USAssert来做出美国各个州的犯罪率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从map中获取洲数据&lt;/span&gt;
states &amp;lt;- map_data(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取犯罪数据&lt;/span&gt;
arrests &amp;lt;-&lt;span&gt; USArrests
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将犯罪的数据列名转换为小写&lt;/span&gt;
names(arrests) &amp;lt;-&lt;span&gt; tolower(names(arrests))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取根据行名获取区域数据&lt;/span&gt;
arrests$region &amp;lt;-&lt;span&gt; tolower(rownames(USArrests))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将两个数据集进行合并&lt;/span&gt;
choro &amp;lt;- merge(states, arrests, by = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;region&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按犯罪率升序排列&lt;/span&gt;
choro &amp;lt;-&lt;span&gt; choro[order(choro$order), ]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.3.1 犯罪率的分布&lt;/span&gt;
qplot(long, lat, data = choro, group = group,fill = assault, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polygon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.3.2 谋杀率的分布&lt;/span&gt;
qplot(long, lat, data = choro, group =&lt;span&gt; group,
      fill &lt;/span&gt;= assault / murder, geom = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polygon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415223030665-805761605.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;409&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415223137288-1724288320.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　图 2.3.1   结论:越往东北犯罪率越低                                                                      图 2.3.2   结论:越往西北谋杀率越低&lt;/p&gt;
&lt;p&gt;案例3:中国地图&lt;/p&gt;
&lt;p&gt;　　3.1 做出各个省份人口的数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;126&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;span&gt; 载入中国地图数据集&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;china=readShapePoly(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\Udacity\\Data Analysis High\\R\\R_Study\\第一天数据\\bou2_4p.shp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;&lt;span&gt;#&lt;span&gt; 获取数据&lt;/span&gt;&lt;/span&gt;      
x&lt;/span&gt;&amp;lt;-&lt;span&gt;china@data&lt;br/&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 转换为datafarme&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
xs&lt;/span&gt;&amp;lt;-data.frame(x,id=seq(0:924)-1&lt;span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 将china转换为datafarme&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
shapefile_df &lt;/span&gt;&amp;lt;-&lt;span&gt; fortify(china)&lt;br/&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 组合成完整的dataframe&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;china_mapdata&lt;/span&gt;&amp;lt;-join(shapefile_df, xs, type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;full&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 省份名称&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;NAME&amp;lt;-c(&quot;北京市&quot;,&quot;天津市&quot;,&quot;河北省&quot;,&quot;山西省&quot;,&quot;内蒙古自治区&quot;,&quot;辽宁省&quot;,&quot;吉林省&quot;,&lt;br/&gt;&quot;黑龙江省&quot;,&quot;上海市&quot;,&quot;江苏省&quot;,&quot;浙江省&quot;,&quot;安徽省&quot;,&quot;福建省&quot;, &quot;江西省&quot;,&quot;山东省&quot;,&quot;河南省&quot;,&lt;br/&gt;&quot;湖北省&quot;, &quot;湖南省&quot;,&quot;广东省&quot;, &quot;广西壮族自治区&quot;,&quot;海南省&quot;, &quot;重庆市&quot;,&quot;四川省&quot;, &quot;贵州省&quot;,&lt;br/&gt;&quot;云南省&quot;,&quot;西藏自治区&quot;,&quot;陕西省&quot;,&quot;甘肃省&quot;,&quot;青海省&quot;,&quot;宁夏回族自治区&quot;,&quot;新疆维吾尔自治区&quot;, &lt;br/&gt;&quot;台湾省&quot;,&quot;香港特别行政区&quot;)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 各个省份的人口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;pop&amp;lt;-c(7355291,3963604,20813492,10654162,8470472,15334912,9162183,13192935,8893483,25635291,20060115,19322432,11971873,11847841,30794664,26404973,&lt;br/&gt;17253385,19029894,32222752,13467663,2451819,10272559,26383458,10745630,&lt;br/&gt;12695396,689521,11084516,7113833,1586635,1945064,6902850,23193638,7026400)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 组合成完整的d人口-省份的dataframe&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;pop&amp;lt;-data.frame(NAME,pop)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;span readability=&quot;7&quot;&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 和中国的地图信息相结合,组合成datdaframe&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;china_pop&amp;lt;-join(china_mapdata, pop, type = &quot;full&quot;)&lt;p&gt;ggplot(china_pop, aes(x = long, y = lat, group = group,fill=pop))+&lt;br/&gt;geom_polygon( )+&lt;br/&gt;geom_path(colour = &quot;grey40&quot;)&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415230056265-1832454061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　图3.1 结论颜色越浅的的省份人口越多&lt;/p&gt;
&lt;p&gt; 　　3.2 做出上海市的地图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 使用subset来取出上海市的信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;SH&amp;lt;-subset(china_mapdata,NAME==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上海市&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

ggplot(SH, aes(x &lt;/span&gt;= long, y = lat, group = group,fill=NAME))+&lt;span&gt;
  geom_polygon(fill&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lightblue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; )+&lt;span&gt;
  geom_path(colour &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey40&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;
  ggtitle(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中华人民共和国上海市&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+&lt;span&gt;
  annotate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,x=121.4,y=31.15,label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上海市&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415230414215-1314353068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　图 3.2&lt;/p&gt;
&lt;p&gt;案例4:时间数据&lt;/p&gt;
&lt;p&gt;　　采用ggplot2自带的economics数据集&lt;/p&gt;
&lt;p&gt;　　数据集变量简介&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# date 时间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# pop 人口&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# uempmed 失业率&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# unemploy 失业人数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.1 通过时间查看失业率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ggplot(aes(x=date,y=uempmed),data=economics)+&lt;span&gt;
  geom_line()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415231045285-1824037520.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　图4.1   图层1&lt;/p&gt;
&lt;p&gt;　　4.2查看不同政党执政时期的失业率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取失业率的折线图 图层1&lt;/span&gt;
(unemp &amp;lt;- qplot(date, unemploy, data=economics, geom=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,xlab = &lt;span&gt;&quot;&quot;&lt;/span&gt;, ylab = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No. unemployed (1000s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于是1970年开始,所以去掉前三行,从尼克松开始统计&lt;/span&gt;
presidential1 &amp;lt;- presidential[-(1:3&lt;span&gt;), ]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;确定x和y的边界&lt;/span&gt;
yrng &amp;lt;-&lt;span&gt; range(economics$unemploy)
xrng &lt;/span&gt;&amp;lt;-&lt;span&gt; range(economics$date)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图层2&lt;/span&gt;
unemp + geom_vline(aes(xintercept = start), data =&lt;span&gt; presidential)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图层3&lt;/span&gt;
unemp + geom_rect(aes(NULL, NULL, xmin = start, xmax =&lt;span&gt; end,
                      fill &lt;/span&gt;= party), ymin = yrng[1], ymax = yrng[2&lt;span&gt;],
                  data &lt;/span&gt;= presidential1) + scale_fill_manual(values =&lt;span&gt;
                                                              alpha(c(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), 0.2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415232232405-856830429.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;296&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415232316623-131731734.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　4.2     图层2　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图层 3&lt;/p&gt;
&lt;p&gt;5.作图其他设置&lt;/p&gt;
&lt;p&gt;　　5.1 叠加多个图形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;span&gt; 美国5大湖之一的休伦湖数据集&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;huron &amp;lt;- data.frame(year = 1875:1972, level =&lt;span&gt; LakeHuron)
ggplot(huron, aes(year)) &lt;/span&gt;+&lt;span&gt;
  geom_line(aes(y &lt;/span&gt;= level - 5), colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  geom_line(aes(y &lt;/span&gt;= level ), colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  geom_line(aes(y &lt;/span&gt;= level + 5), colour = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415232651714-2129590891.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　  图5.1&lt;/p&gt;
&lt;p&gt;　　5.2 颜色设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 使用mtcars数据集&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; 制定乐填充色red和边框色black&lt;/span&gt;
ggplot(birthwt, aes(x=bwt)) + geom_histogram(fill=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, colour=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将cyl转变为因子&lt;/span&gt;
mtcars$cyl &amp;lt;-&lt;span&gt; factor(mtcars$cyl) 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对不同的ctl进行绘图&lt;/span&gt;
ggplot(mtcars, aes(x=wt, y=mpg, colour=cyl)) + geom_point()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233046149-790203397.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;427&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233136641-1432340278.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;446&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　     图   5.2.1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图   5.2.2&lt;/p&gt;
&lt;p&gt;　　5.3 图例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用的是植物数据集&lt;/span&gt;
p &amp;lt;- ggplot(PlantGrowth, aes(x=group, y=weight, fill=group)) +&lt;span&gt; geom_boxplot()
&lt;span&gt;#&lt;span&gt; 5.3.1 默认的图例放在右边&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;p
&lt;span&gt;#&lt;span&gt; 5.3.2 不使用图例&lt;/span&gt;&lt;/span&gt;
p &lt;/span&gt;+ guides(fill=&lt;span&gt;FALSE)
&lt;br/&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 5.3.3 将图例放在顶部&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
p &lt;/span&gt;+ theme(legend.position=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt; 5.3.4 指定图例的位置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
p &lt;/span&gt;+ theme(legend.position=c(1,0), legend.justification=c(1,0))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233349931-1164974868.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;320&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233606965-811954631.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　                    图 5.3.1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图    5.3.2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233636372-1573628920.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;304&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180415233725245-2101168576.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　图 5.3.3　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　图 5.4.4&lt;/p&gt;
&lt;p&gt;github:https://github.com/Mounment/R-Project&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 15:38:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8850239.html</dc:identifier>
</item>
<item>
<title>二 创建路线 - 沙漠骆驼whlkx</title>
<link>http://www.cnblogs.com/whlkx/p/8850213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whlkx/p/8850213.html</guid>
<description>&lt;p&gt;这一节中将给大家介绍一下有关路线创建及编辑的内容。&lt;/p&gt;
&lt;p&gt;路线在civil3d中叫做 Alignment，路线是后续要讲的纵断面图、道路、采样线等对象的基础元素，也就是说先要创建路线对象，然后才能创建纵断面图及其他对象，也就是说纵断面图、采样线、道路等这些对象是依附于路线的。 civil的路线相当于ZDM软件（网上可以搜一下，国产的CAD二次开发软件，还是比较牛逼的）中的剖切多段线，但是civil中的路线要强大多，比如调整路线后，其下的纵断面图、道路、采样线以及填挖方量都会动态变化，关联性相当强大。&lt;/p&gt;
&lt;p&gt;路线的创建一般有两种方法：&lt;/p&gt;
&lt;p&gt;1 利用civil的 路线创建工具进行创建&lt;/p&gt;
&lt;p&gt;2 将已有的多段线对象转换为路线&lt;/p&gt;

&lt;p&gt;1 利用civil的路线创建工具进行创建&lt;/p&gt;
&lt;p&gt;首先点击[创建设计]面板中的[路线]下的[路线创建工具]，然后会弹出一个对话框，需要设置一些基本的属性信息，点击确定之后，就会弹出 [路线布局工具条]，大家需要注意工具条的标题内容，对喽，它就是前面创建的路线的名称，然后点击工具条上的最左侧的那个命令，就可以在模型空间中绘制路线了（如同绘制pline线一样简单）。这时左侧工具空间的树形目录中也会发生相应的变化，会将刚才创建的路线对象显示出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415224758197-1435170911.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;477&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415225333788-456145783.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;492&quot;/&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230429638-1057241660.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;345&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230604367-1175532852.png&quot; alt=&quot;&quot; width=&quot;321&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2 将已有的多段线对象转换为路线&lt;/p&gt;
&lt;p&gt; 这个方法稍微方便一些，按下图操作即可。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415230912041-1970886362.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415231109356-183766460.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;479&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 需要注意的一点是，拾取多段线后，命令行会提示当前的路线方向要不要更改。这里有个技巧，就是在拾取多段线时（对下图），如果拾取的位置距离左侧较近，那么路线的起始方向就是左侧，如果拾取的位置距离右侧较近，那么路线的起始方向就是右侧。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415231355196-482096914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当不小心把[路线布局工具条]关闭了，这时路线对象已经创建好了，名字也起好了，只是没有在模型空间进行绘制，怎么再把[路线工具条]调出来呢，方法很简单，就是在[工具空间]的树形目录中找到刚才创建的路线对象，然后右键[选择]，这时ribbon中就会显示和路线有关的操作，然后点击下图显示的[几何图形编辑器]命令，这时[路线工具条]又会重新出现，此时就可以接着在模型空间中绘制路线了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/708913/201804/708913-20180415232944252-1362792023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 15:32:00 +0000</pubDate>
<dc:creator>沙漠骆驼whlkx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whlkx/p/8850213.html</dc:identifier>
</item>
<item>
<title>ABP框架 - N层架构 - lcyhjx</title>
<link>http://www.cnblogs.com/lcyhjx/p/8850172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcyhjx/p/8850172.html</guid>
<description>&lt;p&gt;在应用程序设计中，分层架构是一种被广泛使用的技术，它助于降低复杂度和提高代码的可重用性。在ABP框架中，使用了DDD（领域驱动设计）的原则来实现分层架构.&lt;/p&gt;

&lt;p&gt;在DDD(领域驱动设计)架构模型中，有四个基础层。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;表现层&lt;/strong&gt;: 用户访问接口。使用应用层来实现与用户交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;: 应用层是表现层和领域层之间的媒介，它负责组织和编排业务对象来执行特定的应用任务。，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;领域层&lt;/strong&gt;：定义业务对象、逻辑和规则，它是整个应用的核心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施层&lt;/strong&gt;：为上层提供通用的技术支持，大多数情况会使用第三方库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个现代化的架构应用中，除了DDD模型的4个基础层（表现层、应用层、领域层、基础设施层）以外， 通常还有其他的一些逻辑层和物理层。下面的架构模型图是ABP建议使用并且已经实现的结构模型。ABP框架不仅提供了基类和服务来非常容易的实现此架构模型，并且已经提供了模板程序（参见&lt;a href=&quot;http://www.cnblogs.com/lcyhjx/p/8698507.html&quot;&gt;ABP框架 - 我的第一个WEB API&lt;/a&gt;）来让我们直接在此架构模型上开始开发。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/60140/201804/60140-20180415222601715-857334693.png&quot; alt=&quot;images&quot;/&gt;&lt;/p&gt;

&lt;p&gt;远程客户端是应用服务的消费者，通过HTTP API的方式来调用应用服务。客户端可以是一个单页应用程序（SPA），一个移动APP，也可以是一个第三方的消费者。本地化和导航可以在客户端中实现。&lt;/p&gt;

&lt;p&gt;ASP.NET (Core) MVC可以被认为是展现层。展现层可以是物理层（通过HTTP API来调用应用服务），也可以是一个逻辑层（直接注入并使用应用服务）。展现层一般提供本地化、导航、对象映射、缓存、配置管理、审计日志等这些功能。也可以处理授权、会话和异常。&lt;/p&gt;

&lt;p&gt;分布式服务层通过API（例如REST、OData、GraphQL）来为远程客户端提供应用服务功能。它不包含任务业务逻辑，仅仅是接收HTTP请求，然后调用相应的应用/领域服务来完成特定功能。分布式服务层一般包括授权、缓存、审计日志、对象映射、异常处理和会话等。&lt;/p&gt;

&lt;p&gt;应用层主要包含应用服务，应用服务从展示层/分布式服务层接收输入DTO对象，然后调用领域层的特定操作，组合编排领域对象，并根据需要返回输出DTO给展示层/分布式服务层。应用层通常也会包括授权、缓存、审计日志、对象映射、会话等。&lt;/p&gt;

&lt;p&gt;领域层主要用来实现业务逻辑，它包括领域实体、值对象、领域服务并执行业务逻辑。它也规约和领域事件。领域层定义了数据仓储接口来读取和持久化实体到数据源，但是领域层并不实现数据仓储。&lt;/p&gt;

&lt;p&gt;领域层定义了数据仓储接口，基础设施层则通过Entity Framework(Core)/NHibernate与实际数据库交互来实现数据仓储接口。基础设施层并没有严格的定义，它里面实现的功能通常是提供给其他层使用的公共功能，比如发送邮件功能，就可以定义在基础设施层。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 15:23:00 +0000</pubDate>
<dc:creator>lcyhjx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcyhjx/p/8850172.html</dc:identifier>
</item>
<item>
<title>SpringMVC之数据传递二 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8849429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8849429.html</guid>
<description>&lt;p&gt;上一篇学习了从url或view中传数据到Controller中，今天学习下数据从Controller传到view中,主要有4种。&lt;/p&gt;
&lt;p&gt;一、ModelAndView&lt;/p&gt;
&lt;p&gt;处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModelAndView&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView testModelAndView(HttpServletRequest request, HttpServletResponse response){
        
        String viewName &lt;/span&gt;= &quot;Hello&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;视图名&lt;/span&gt;
        ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView(viewName);
        User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
        user.setPwd(&lt;/span&gt;&quot;testModelAndView&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        modelAndView.addObject(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
        modelAndView.addObject(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、Model／Map／ModelMap&lt;/p&gt;
&lt;p&gt;入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 Java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModel.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testModel(Model model){
          User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testModel&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          model.addAttribute(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
          model.addAttribute(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }

    @RequestMapping(value &lt;/span&gt;= &quot;/testMap.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testMap(Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map){
          User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testMap&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
          map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面两个我们都可以使用下面的html访问变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、@SessionAttributes&lt;/p&gt;
&lt;p&gt; 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性，比如我们登录之后可能会存登录信息，就可以使用它。@SessionAttributes这个注解只能放到类的上面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@SessionAttributes({&quot;user&quot;&lt;span&gt;})
@Controller
@RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloController {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们将上面的user存到HttpSession中，我们可以在jsp中验证一下。&lt;/p&gt;
&lt;p&gt;这里我们在html中加入SessionAttributes:${sessionScope.user.name}。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b74cf22-b829-4487-81c4-5378212757bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
SessionAttributes:${sessionScope.user.name}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;当我们访问http://localhost:8080/WebMVC/hello/testModelAndView时，jsp输出结果如下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415205213478-486148766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面定义了一个testSessionAttributes，它里面什么都没有，只有返回Hello。当我们再访问它时http://localhost:8080/WebMVC/hello/testSessionAttributes.do，会有下图的结果。可以看到jsp中名字部分是没有值得，因为@SessionAttributes({&quot;user&quot;&lt;span data-mce-=&quot;&quot;&gt;})，这只设置了user,对name没设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testSessionAttributes.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testSessionAttributes(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415211755020-824712085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 四、@ModelAttribute&lt;/p&gt;
&lt;p&gt;SpringMVC在每次调用请求处理方法时，都会创建Model类型的一个实例。如果准备使用此实例，则可以在方法中添加一个Model类型的参数,在上面的testModel方法就是这样使用的。它可以用@ModelAttribute来注释方法参数：带有@ModelAttribute注解的方法会将其输入或创建的参数对象添加到Model对象中(若方法中没有显式添加)。也可以用@ModelAttribute标注一个非请求的处理方法（有返回值，无返回值）：被@ModelAttribute注释的方法会在此controller每个方法执行前被执行。&lt;/p&gt;
&lt;p&gt;1.@ModelAttribute注释方法参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testModelAttribute.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testModelAttribute(HttpServletRequest request, HttpServletResponse response,@ModelAttribute(&quot;user&quot;)User user,@ModelAttribute(&quot;name&quot;&lt;span&gt;)String name,Model model){
          user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
          user.setPwd(&lt;/span&gt;&quot;testModelAttribute&quot;&lt;span&gt;);
          user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
          name&lt;/span&gt;=&quot;testModelAttribute&quot;&lt;span&gt;;
          model.addAttribute(&lt;/span&gt;&quot;name&quot;&lt;span&gt;, name);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个奇怪的地方，假如不传name的话，model也可以不用写在参数中，在函数中设置user的值在页面就能获取到，但是如果传入String类型的参数，那它就需要加入model这个参数，并要显示的设置才能在jsp中获取，这个暂时还不知道为什么。&lt;/p&gt;
&lt;p&gt;2.@ModelAttribute标注一个非请求的处理方法&lt;/p&gt;
&lt;p&gt;由于被@ModelAttribute注释的方法会在此controller每个方法执行前被执行。我们可以做个测试。&lt;/p&gt;
&lt;p&gt;1)、有返回值&lt;/p&gt;
&lt;p&gt;这里定义了一个map方法，并被标注为 @ModelAttribute(value = &quot;mymap&quot;)，返回值是Map&amp;lt;String,Object&amp;gt;，在函数里面我们设置了user和name.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testSessionAttributes.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testSessionAttributes(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }
    
    @ModelAttribute(value &lt;/span&gt;= &quot;mymap&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String,Object&amp;gt;&lt;span&gt; map() {
      User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
      user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
      user.setPwd(&lt;/span&gt;&quot;ModelAttribute&quot;&lt;span&gt;);
      user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
      HashMap&lt;/span&gt;&amp;lt;String, Object&amp;gt; map=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
      map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw&quot;&lt;span&gt;);
      map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }
    
    
    @RequestMapping(value &lt;/span&gt;= &quot;/testMethodModelAttribute.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String testModelAttribute(HttpServletRequest request, HttpServletResponse response){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在页面获取值，这里要注意，其实在 map()方法中是省略了一句，model.addAttribute(&quot;mymap&quot;, map);它对应的是mymap,所以在jsp中不能直接访问user和name。需要通过mymap来访问，我们之前设置的@SessionAttributes({&quot;user&quot;})这里也就不会有值了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${mymap.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
密码:${mymap.user.pwd}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
出生日期:${mymap.user.birthday}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${mymap.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
名字:${requestScope.mymap.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
姓名:${requestScope.mymap.user.name}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
SessionAttributes:${sessionScope.user.name}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415221102606-717496950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415221114592-2016867147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们想将里面的user设置为sessionAttribute，我们可以@SessionAttributes({&quot;user&quot;,&quot;mymap&quot;}),SessionAttributes:${sessionScope.mymap.user.name}来获取。&lt;/p&gt;
&lt;p&gt;2)、无返回值&lt;/p&gt;
&lt;p&gt; 若方法返回一个void类型，则还必须自行将实例添加到Model中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @ModelAttribute
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; voidmap(Model model) {
      User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
      user.setName(&lt;/span&gt;&quot;cuiyw3&quot;&lt;span&gt;);
      user.setPwd(&lt;/span&gt;&quot;ModelAttribute3&quot;&lt;span&gt;);
      user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
      HashMap&lt;/span&gt;&amp;lt;String, Object&amp;gt; map=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
      map.put(&lt;/span&gt;&quot;name&quot;,&quot;cyw3&quot;&lt;span&gt;);
      map.put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
      model.addAttribute(&lt;/span&gt;&quot;mymap&quot;&lt;span&gt;,map);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180415222822888-979632642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Apr 2018 15:21:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8849429.html</dc:identifier>
</item>
<item>
<title>java集合框架 - 博客新手123</title>
<link>http://www.cnblogs.com/lyz-999/p/8850159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyz-999/p/8850159.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;集合框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;用来表示和操作集合的统一架构
包含三个方面：
1、接口：定义了集合操作的规范
2、实现类：集合接口的具体实现，本质上，是可重复使用的数据结构
3、算法： 实现集合操作的常用算法&lt;/span&gt;&lt;span/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;&lt;span&gt;Collection&lt;/span&gt;&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;List&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Set&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot;&gt;&lt;span&gt;实现类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ArrayList,   Vector&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HashSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HashMap, HashTable&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;LInkedArrayList&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;LinkedHashSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;LinkedHashMap&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;TreeSet&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;TreeMap&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[四个接口区别]
&lt;/span&gt;&lt;span&gt;1、collection： 存储不唯一、无序的数据 
2、list： 存储不唯一、有序的数据
3、set： 存储唯一、无序的数据
4、Map： 以键值的形式存储数据，以键取值，键不能重复，值可以重复 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[list&lt;/strong&gt;&lt;strong&gt;接口]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、常用方法：
  ① add();在列表最后添加元素
  ② add(index,obj);在列表指定位置添加元素
  ③ size();返回列表元素个数
  ④ get(int index);返回下标为index的元素。
                   如果没有泛型约束，返回object类型，需要强转；
                   如果有泛型约束，直接返回返回类型，无需强转。
  ⑤ clear();清除列表中所有数据
     isEmpty();检测列表是否为空
  ⑥ contains();传入一个对象，检测列表中是否包含该对象
               如果传入的是String 和基本数据类型，可以直接比对
               如果传入的是实体对象，则默认值比对两个对象的地址，因此需要在实体类中重写equals()方法
  ⑦ indexOf()传入一个对象，返回该对象在列表中是第一次出现的位置,如果没有则返回-1
     lastIndexOf();返回最后一次出现的位置
  ⑧ remove();传入一个下标，或者一个对象，删除指定元素；
              如果传入下标，返回被删除的元素对象，如果下标大于size(),会报下标越界
              如果传入对象，则要求重写equals()方法，返回true或false表示是否删除成功
  ⑨ set(index,obj):用新传入的对象，将指定位置的元素替换掉，返回被替换的元素
  ⑩ list.subList(1,3);截取一个子列表，返回List类型
     toArray();将列表转为数组，返回一个Object[]类型的数组

2、常用实现类
  ① ArrayList
      实现了一个长度可变的数组，在内存空间中开辟一串连续的空间。
      这种存储结构，在循环遍历和随机访问元素的速度比较快
  ② LinkedList
      使用链表结构存储数据，在(中间)插入和删除元素时比较快
  &lt;/span&gt;&lt;span&gt;LinkedList特有的方法：&lt;/span&gt;&lt;span&gt;
   ① addFirst():在该列表开头插入指定的元素。
       addLast():在该列表最后插入指定的元素。
   ② removeFirst();从此列表中删除并返回第一个元素。
       removeLast();从此列表中删除并返回最后一个元素。
   ③ getFirst();返回第一个元素。
       getLast();返回最后一个元素。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Set&lt;/strong&gt;&lt;strong&gt;接口] &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、常用方法：与List接口基本相同 但是，由于Set接口中的元素是无序的，因此没有与下标相关的方法
   例如：get(index) remove(index) add(index,obj)
2、Set接口特点：无序、唯一
3、HashSet 底层是调用HashMap的相关方法，传入数据后，根据数据的hashcode进行散列运算，得到一个散列值后再进行运算，确定元素在序列中存储的位置
  HashSet如何确定两个对象是否相等
&lt;/span&gt;&lt;span&gt;&lt;span&gt;  ① 先判断对象的HashCode(),如果hashcode不同，那肯定不相同
    如果hashcode相等，那继续判断equals()方法
  ②重写equals()方法
  &amp;gt;&amp;gt;&amp;gt;所以，使用HashSet存储实体对象时，必须重写HashCode()和equals()两个方法
4、LinkHashSet：在HashSet的基础上，新增了一个链表。
   用链表来记录HashSet存放的元素顺序，因此使用迭代器遍历时，可以按照放入的顺序依次读取元素
5、TreeSet：将存入的元素，进行排序，然后再输出
   如果存入的是实体对象，那么实体类必须实现Comparable接口，重写CompareTo()方法
   或者，也可以在实例化TreeSet的同时，通过构造函数传入一个比较器
   比较器：一个实现了Comparator接口，并重写了compare()方法的实现类的对象。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p align=&quot;left&quot;&gt;  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用匿名内部类，拿到一个比较器对象&lt;/span&gt;
&lt;span&gt;
   Set&lt;/span&gt;&amp;lt;Person&amp;gt; set=&lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;Person&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Comparator(){

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person p1,Person p2){

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p1.getId()-&lt;span&gt;p2.getId();

          }

     }

  );

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义一个比较类，实现Comparator接口 &lt;/span&gt;

  &amp;lt;Person&amp;gt; set=&lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;Person&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Compare());

   &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Compare &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Comparator{

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写compare方法。&lt;/span&gt;

   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person p1,Person p2){

      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p1.getId()-&lt;span&gt;p2.getId();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;[Comparable接口 和 Comparator接口的区别]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;span&gt;1、Comparable由实体类实现，重写compareTo()方法；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   实体类实现Comparable接口以后，TreeSet使用空参构造即可。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2、Comparator需要单独一个比较类进行实现，重写Compare()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;   实例化TreeSet的时候，需要传入这个比较类的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Map&lt;/strong&gt;&lt;strong&gt;接口]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1、特点：以键值对的形式存储数据，以键取值。 键不能重复，只可以重复
2、Map常用的方法
  ① put(key,value):向map的在最后追加一个键值对； 
  ② get(key); 通过建，取值
  ③ clear(); 清除所有键值对；
  ④ containsValue(obj);检测是否包含指定的值
     containsKey(obj);检测是否包含指定的键  
3、LinkedHashMap
   可以使用链表，记录数据放入的顺序，使让读出的数据次序与存入的次序一致，与LinkedHashSet一样
4、TreeMap
   根据键的顺序，进行排序后，输出。如果传入的是实体对象，必须重写比较函数，详见TreeSet

&lt;strong&gt;[HashMap与HashTable的区别]&lt;/strong&gt;
1、HashTable是线程安全(线程同步)的，HashMap是线程不安全(线程不同步)的
2、HashTable的键不能为null,HashMap的键可以为null
3、HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口。
4、HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。
5、HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。
6、两者计算hash的方法不同： 
   Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模：
   HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸：
7、判断是否含有某个键 
  在HashMap 中，null 可以作为键，这样的键只有一个；可以有一个或多个键所对 应的值为null。当get()方法返回null 值时，&lt;br/&gt;既可以表示HashMap 中没有该键，也可以表示该键所对应的值为null。因此，在HashMap 中不能用get()方法来判断HashMap中是否存在某个键，、&lt;br/&gt;而应该用containsKey()方法来判断。Hashtable 的键值都不能&lt;/span&gt;&lt;span&gt;为null，所以可以用get()方法来判断是否含有某个键。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式一
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;String&amp;gt; keys =&lt;span&gt; map1.keySet();
        Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iter1 =&lt;span&gt; keys.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter1.hasNext()) {
            String key &lt;/span&gt;=&lt;span&gt; iter1.next();
            System.out.println(key &lt;/span&gt;+ &quot;------&quot; +&lt;span&gt; map1.get(key));
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式二
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Collection&lt;/span&gt;&amp;lt;String&amp;gt; values =&lt;span&gt; map1.values();
        Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iter2 =&lt;span&gt; values.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iter2.hasNext()) {
            System.out.println(iter2.next());
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 遍历Map方式三
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; set3 =&lt;span&gt; map1.entrySet();
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Iterator&amp;lt;Entry&amp;lt;String,String&amp;gt;&amp;gt; iter3 = set3.iterator();
        while (iter3.hasNext()) {
            Entry&amp;lt;String,String&amp;gt; entry=iter3.next();
            Entry是java给我们提供的一种特殊的数据类型，其实就是一个键值对
             * 键就是当前这条记录的键，使用getKey()取到；
             * 值就是当前这条记录的值，使用getValue()取到
            
//            System.out.println(entry);
            System.out.println(entry.getKey()+&quot;---&quot;+entry.getValue());
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(Entry&amp;lt;String,String&amp;gt;&lt;span&gt;entry:set3){
            System.out.println(entry.getKey()&lt;/span&gt;+&quot;-----&quot;+&lt;span&gt;entry.getValue());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;[Collections&lt;/strong&gt;&lt;strong&gt;类]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Collections是Java中专门用来操作集合的工具类
Collection是一个接口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[方法]
1&lt;/span&gt;&lt;span&gt;&lt;span&gt;、addAll()方法：向集合中添加多个数据&lt;/span&gt;
  Collections.addAll(list, &lt;/span&gt;&quot;Test1&quot;,&quot;Test2&quot;,&quot;Test3&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;2、sort()方法：对集合中的数据进行排序 如果集合中的数据是实体对象那么 
  ① 实体类实现Comparable接口，重写compareTo方法
  ②在sort的第二个参数传入一个实现了Comparator接口的比较器对象，重写compare方法&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    Collections.sort(list1, new Comparator&amp;lt;Person1&amp;gt;() {&lt;br/&gt;     @Override&lt;br/&gt;      public int compare(Person1 o1, Person1 o2) {&lt;br/&gt;      return o1.getId() - o2.getId();&lt;br/&gt;      }&lt;br/&gt;    });&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&lt;span&gt;、binarySearch()：查找元素，返回下标
  使用binarySearch()要先排序 如果集合中的数据是实体对象那么 
  ①实体类实现Comparable接口，重写compareTo方法 (推荐使用)
  ②在sort的第二个参数和binarySearch的第三个参数传入一个实现了Comparator接口的比较器对象，重写compare方法&lt;/span&gt;
  System.out.println(Collections.binarySearch(list, &lt;/span&gt;&quot;list2&quot;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;、找出最大、最小元素，如果实体对象，同上需要实现比较器接口&lt;/span&gt;
  Collections.max(list);
  System.out.println(Collections.min(list1));

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&lt;span&gt;、repalceAll(): 将列表的指定值，替换新值. 如果是对象，重写equals方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;     Collections.replaceAll(list1, new Person1(1, &quot;张三&quot;, 12),&lt;br/&gt;     new Person1(1, &quot;111张三&quot;, 12));&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&lt;span&gt;、翻转列表中的所有元素&lt;/span&gt;
  Collections.reverse(list1);

&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&lt;span&gt;、对集合的元素，随机排序&lt;/span&gt;
  Collections.shuffle(list1);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&lt;span&gt;、 将集合中的元素位置，进行交换&lt;/span&gt;
  Collections.swap(list1, &lt;/span&gt;0, 1&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;&lt;span&gt;、将集合中的所有元素替换为同一个元素&lt;/span&gt;
  Collections.fill(list, &lt;/span&gt;&quot;姜皓真帅&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 15 Apr 2018 15:20:00 +0000</pubDate>
<dc:creator>博客新手123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyz-999/p/8850159.html</dc:identifier>
</item>
</channel>
</rss>