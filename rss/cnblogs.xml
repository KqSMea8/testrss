<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go实现海量日志收集系统(四) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8948516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8948516.html</guid>
<description>&lt;p&gt;到这一步，我的收集系统就已经完成很大一部分工作，我们重新看一下我们之前画的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180426003723779-1828710277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们已经完成前面的部分，剩下是要完成后半部分，将kafka中的数据扔到ElasticSearch，并且最终通过kibana展现出来&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;ElasticSearch&lt;/h2&gt;
&lt;p&gt;官网地址这里介绍了非常详细的安装方法：&lt;br/&gt;&lt;a href=&quot;https://www.elastic.co/downloads/elasticsearch&quot;&gt;https://www.elastic.co/downloads/elasticsearch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是其实这里是需要配置一些东西的，要不然直接启动是会悲剧的，在网上找了一个地址，如果出现类似的错误直接处理就行，我自己已经验证了：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/liangzhao_jay/article/details/56840941&quot;&gt;https://blog.csdn.net/liangzhao_jay/article/details/56840941&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下图所示就表示已经安装完成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180426003809142-1508196426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180426003823758-1429178644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt; 通过go写一个简单的调用ElasticSearch的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;fmt&quot;&lt;span&gt;
    elastic &lt;/span&gt;&quot;gopkg.in/olivere/elastic.v2&quot;&lt;span&gt;
)

type Tweet struct{
    User string
    Message string
}

func main(){
    client,err :&lt;/span&gt;= elastic.NewClient(elastic.SetSniff(&lt;span&gt;false&lt;/span&gt;),elastic.SetURL(&quot;http://192.168.0.118:9200/&quot;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(&lt;/span&gt;&quot;connect es error&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;conn es succ&quot;&lt;span&gt;)
    tweet :&lt;/span&gt;= Tweet{User:&quot;olivere name&quot;,Message:&quot;Take Five&quot;&lt;span&gt;}
    _, err &lt;/span&gt;= client.Index().Index(&quot;twitter&quot;).Type(&quot;tweet&quot;).Id(&quot;1&quot;&lt;span&gt;).BodyJson(tweet).Do()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        panic(err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;insert succ&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;logtransfer&lt;/h2&gt;
&lt;p&gt;logtransfer主要负责从 kafka队列中读取日志信息，并且添加到ElasticSearch中&lt;/p&gt;
&lt;p&gt;看那一下logtransfer 目录结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── conf
│   └── app.conf
├── es.go
├── etcd.go
├── ip.go
├── kafka.go
├── logs
│   └── transfer.log
└── main.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;conf:存放配置文件&lt;br/&gt;es.go:主要是连接ElasticSearch的部分以及用于将消息放到ElasticSearch中&lt;br/&gt;etcd.go:主要用于做动态的配置更改，当我们需要将kafka中的哪些topic日志内容扔到ElasticSearch中&lt;br/&gt;ip.go: 用于获取当前服务器的ip地址&lt;br/&gt;kafka.go: 主要是kafka的处理逻辑，包括连接kafka以及从kafka中读日志内容&lt;br/&gt;main.go:代码的入口函数&lt;/p&gt;
&lt;p&gt;整体大代码框架，通过如图展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180426003940816-871905261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和之前的logagent中的代码有很多启示是可以复用的或者稍作更改，就可以了，其中es之心的，主要是连接ElasticSearch并将日志内容放进去&lt;/p&gt;
&lt;p&gt;es.go的代码内容为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;gopkg.in/olivere/elastic.v2&quot;
    &quot;github.com/astaxie/beego/logs&quot;
    &quot;sync&quot;
    &quot;encoding/json&quot;&lt;span&gt;
)

var waitGroup sync.WaitGroup

var client &lt;/span&gt;*&lt;span&gt;elastic.Client

func initEs(addr string,) (err error){
    client,err &lt;/span&gt;= elastic.NewClient(elastic.SetSniff(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;),elastic.SetURL(addr))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        logs.Error(&lt;/span&gt;&quot;connect to es error:%v&quot;&lt;span&gt;,err)
        return
    }
    logs.Debug(&lt;/span&gt;&quot;conn to es success&quot;&lt;span&gt;)
    return
}

func reloadKafka(topicArray []string) {
    for _, topic :&lt;/span&gt;=&lt;span&gt; range topicArray{
        kafkaMgr.AddTopic(topic)
    }
}

func reload(){
    &lt;/span&gt;//&lt;span&gt;GetLogConf() 从channel中获topic信息，而这部分信息是从etcd放进去的
    for conf :&lt;/span&gt;=&lt;span&gt; range GetLogConf(){
        var topicArray []string
        err :&lt;/span&gt;= json.Unmarshal([]&lt;span&gt;byte&lt;/span&gt;(conf),&amp;amp;&lt;span&gt;topicArray)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            logs.Error(&lt;/span&gt;&quot;unmarshal failed,err:%v conf:%v&quot;&lt;span&gt;,err,conf)
            continue
        }
        reloadKafka(topicArray)
    }
}

func Run(esThreadNum &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) (err error) {
    go reload()
    for i:&lt;/span&gt;=0;i&amp;lt;esThreadNum;i++&lt;span&gt;{
        waitGroup.Add(&lt;/span&gt;1&lt;span&gt;)
        go sendToEs()
    }
    waitGroup.Wait()
    return
}

type EsMessage struct {
    Message string
}

func sendToEs(){
    &lt;/span&gt;//&lt;span&gt; 从msgChan中读取日志内容并扔到elasticsearch中
    for msg:&lt;/span&gt;=&lt;span&gt; range GetMessage() {
        var esMsg EsMessage
        esMsg.Message &lt;/span&gt;=&lt;span&gt; msg.line
        _,err :&lt;/span&gt;=&lt;span&gt; client.Index().Index(msg.topic).Type(msg.topic).BodyJson(esMsg).Do()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            logs.Error(&lt;/span&gt;&quot;send to es failed,err:%v&quot;&lt;span&gt;,err)
            continue
        }
        logs.Debug(&lt;/span&gt;&quot;send to es success&quot;&lt;span&gt;)
    }
    waitGroup.Done()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我将logagnet以及logtransfer部署到虚拟机上进行测试的效果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180426004030148-143445848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这样当我再次查日志的时候就可以不用登陆每台服务器去查日志，只需要通过页面根据关键字迅速看到相关日志，当然目前实现的功能还是有点粗糙，etcd的更改程序，是自己写的发送程序，其实更好的解决方法是通过页面，让用户点来点去，来控制自己要收集哪些日志，以及自己要将哪些topic的日志从kafka中放到ElasticSearch (本人是做后端开发，不擅长前端的开发，不过后面可以试着写个页面试试，估计会很丑哈哈)&lt;/p&gt;
&lt;p&gt;同时这里关于各个部分的安装并没有做过多的介绍，以及维护，当然我们的目标是是通过这些开源的软件以及包来实现我们想要的功能，后期的维护，肯定需要对各个组件部分都进行深入了解&lt;/p&gt;
&lt;p&gt;这里附赠一下那个etcd客户端代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package main

import (
    &lt;/span&gt;&quot;github.com/coreos/etcd/clientv3&quot;
    &quot;time&quot;
    &quot;fmt&quot;
    &quot;golang.org/x/net/context&quot;&lt;span&gt;
)

var logconf &lt;/span&gt;=&lt;span&gt; `
[
    {
        &lt;/span&gt;&quot;topic&quot;:&quot;eslservice_log&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;log_path&quot;:&quot;/opt/pbx/log/eslservice.log&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;service&quot;:&quot;eslservice&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;send_rate&quot;:50000&lt;span&gt;
    }
]
`

var test111 &lt;/span&gt;=&lt;span&gt; `
[
    {
        &lt;/span&gt;&quot;topic&quot;:&quot;test_log&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;log_path&quot;:&quot;D:/a.log&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;service&quot;:&quot;test&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;send_rate&quot;:50000&lt;span&gt;
    }
]
`


var transconf &lt;/span&gt;=&lt;span&gt; `
[
    &lt;/span&gt;&quot;eslservice_log&quot;&lt;span&gt;
]
`

func main() {
    cli, err :&lt;/span&gt;=&lt;span&gt; clientv3.New(clientv3.Config{
        Endpoints:[]string{&lt;/span&gt;&quot;192.168.90.78:2371&quot;&lt;span&gt;},
        DialTimeout:&lt;/span&gt;5*&lt;span&gt;time.Second,
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;connect failed,err:&quot;&lt;span&gt;,err)
        return
    }
    fmt.Println(&lt;/span&gt;&quot;connect success&quot;&lt;span&gt;)
    defer cli.Close()
    ctx,cancel :&lt;/span&gt;=&lt;span&gt; context.WithTimeout(context.Background(),time.Second)
    &lt;/span&gt;//_,err = cli.Put(ctx,&quot;/logagent/192.168.90.11/log_config&quot;&lt;span&gt;,logconf)
    &lt;/span&gt;//_,err = cli.Put(ctx,&quot;/logagent/192.168.90.61/log_config&quot;&lt;span&gt;,test111)
    _, err &lt;/span&gt;= cli.Put(ctx,&quot;/logtransfer/192.168.90.11/log_config&quot;&lt;span&gt;,transconf)
    cancel()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;put failed ,err:&quot;&lt;span&gt;,err)
        return
    }
    ctx,cancel &lt;/span&gt;=&lt;span&gt; context.WithTimeout(context.Background(),time.Second)
    resp,err :&lt;/span&gt;= cli.Get(ctx,&quot;/logtransfer/&quot;&lt;span&gt;,clientv3.WithPrefix())
    cancel()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        fmt.Println(&lt;/span&gt;&quot;get failed,err:&quot;&lt;span&gt;,err)
        return
    }
    for _,ev:&lt;/span&gt;=&lt;span&gt;range resp.Kvs{
        fmt.Printf(&lt;/span&gt;&quot;%s:%s\n&quot;&lt;span&gt;,ev.Key,ev.Value)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到目前为止基本的功能都已经实现了，当然了现在的代码结构还有的糙，后面会进行优化！&lt;br/&gt;整个项目中的代码：&lt;br/&gt;logagent代码地址：&lt;a href=&quot;https://github.com/pythonsite/logagent&quot;&gt;https://github.com/pythonsite/logagent&lt;/a&gt;&lt;br/&gt;logtransfer代码地址：&lt;a href=&quot;https://github.com/pythonsite/logtransfer&quot;&gt;https://github.com/pythonsite/logtransfer&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Apr 2018 16:44:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8948516.html</dc:identifier>
</item>
<item>
<title>数组的遍历你都会用了，那Promise版本的呢 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/8948513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/8948513.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里指的遍历方法包括：&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;reduce&lt;/code&gt;、&lt;code&gt;reduceRight&lt;/code&gt;、&lt;code&gt;forEach&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;some&lt;/code&gt;、&lt;code&gt;every&lt;/code&gt;&lt;br/&gt;因为最近要进行了一些数据汇总，&lt;code&gt;node&lt;/code&gt;版本已经是8.11.1了，所以直接写了个&lt;code&gt;async/await&lt;/code&gt;的脚本。&lt;br/&gt;但是在对数组进行一些遍历操作时，发现有些遍历方法对&lt;code&gt;Promise&lt;/code&gt;的反馈并不是我们想要的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，有些严格来讲并不能算是遍历，比如说&lt;code&gt;some&lt;/code&gt;，&lt;code&gt;every&lt;/code&gt;这些的。&lt;br/&gt;但确实，这些都会根据我们数组的元素来进行多次的调用传入的回调。&lt;/p&gt;
&lt;p&gt;这些方法都是比较常见的，但是当你的回调函数是一个&lt;code&gt;Promise&lt;/code&gt;时，一切都变了。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;为&lt;code&gt;Promise&lt;/code&gt;的语法糖&lt;br/&gt;文中会直接使用&lt;code&gt;async/await&lt;/code&gt;替换&lt;code&gt;Promise&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let result =&lt;span&gt; await func()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 等价于&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; func().then(result =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; code here&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ======&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; func () {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; 1  
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; 等价与&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; func () {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt; resolve(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;map&quot;&gt;map&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;可以说是对&lt;code&gt;Promise&lt;/code&gt;最友好的一个函数了。&lt;br/&gt;我们都知道，&lt;code&gt;map&lt;/code&gt;接收两个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对每项元素执行的回调，回调结果的返回值将作为该数组中相应下标的元素&lt;/li&gt;
&lt;li&gt;一个可选的回调函数&lt;code&gt;this&lt;/code&gt;指向的参数&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].map(item =&amp;gt; item ** 2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对数组元素进行求平方&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [1, 4, 9]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上边是一个普通的&lt;code&gt;map&lt;/code&gt;执行，但是当我们的一些计算操作变为异步的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].map(async item =&amp;gt; item ** 2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对数组元素进行求平方&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [Promise, Promise, Promise]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这时候，我们获取到的返回值其实就是一个由&lt;code&gt;Promise&lt;/code&gt;函数组成的数组了。&lt;/p&gt;
&lt;p&gt;所以为什么上边说&lt;code&gt;map&lt;/code&gt;函数为最友好的，因为我们知道，&lt;code&gt;Promise&lt;/code&gt;有一个函数为&lt;code&gt;Promise.all&lt;/code&gt;&lt;br/&gt;会将一个由&lt;code&gt;Promise&lt;/code&gt;组成的数组依次执行，并返回一个&lt;code&gt;Promise&lt;/code&gt;对象，该对象的结果为数组产生的结果集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; await Promise.all([1, 2, 3].map(async item =&amp;gt; item ** 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [1, 4, 9]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;首先使用&lt;code&gt;Promise.all&lt;/code&gt;对数组进行包装，然后用&lt;code&gt;await&lt;/code&gt;获取结果。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;reduce-reduceRight&quot;&gt;reduce/reduceRight&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt;的函数签名想必大家也很熟悉了，接收两个参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对每一项元素执行的回调函数，返回值将被累加到下次函数调用中，回调函数的签名：
&lt;ol&gt;&lt;li&gt;&lt;code&gt;accumulator&lt;/code&gt;累加的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentValue&lt;/code&gt;当前正在的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt;调用&lt;code&gt;reduce&lt;/code&gt;的数组&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;可选的初始化的值，将作为&lt;code&gt;accumulator&lt;/code&gt;的初始值&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].reduce((accumulator, item) =&amp;gt; accumulator + item, 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行加和&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个代码也是没毛病的，同样如果我们加和的操作也是个异步的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].reduce(async (accumulator, item) =&amp;gt; accumulator + item, 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行加和&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; Promise {&amp;lt;resolved&amp;gt;: &quot;[object Promise]3&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个结果返回的就会很诡异了，我们在回看上边的&lt;code&gt;reduce&lt;/code&gt;的函数签名&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对每一项元素执行的回调函数，返回值将被累加到下次函数调用中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们再来看代码，&lt;code&gt;async (accumulator, item) =&amp;gt; accumulator += item&lt;/code&gt;&lt;br/&gt;这个在最开始也提到了，是&lt;code&gt;Pormise&lt;/code&gt;的语法糖，为了看得更清晰，我们可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; (accumulator, item) =&amp;gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;
&lt;span&gt;2&lt;/span&gt;   resolve(accumulator +=&lt;span&gt; item)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也就是说，我们&lt;code&gt;reduce&lt;/code&gt;的回调函数返回值其实就是一个&lt;code&gt;Promise&lt;/code&gt;对象&lt;br/&gt;然后我们对&lt;code&gt;Promise&lt;/code&gt;对象进行&lt;code&gt;+=&lt;/code&gt;操作，得到那样怪异的返回值也就很合情合理了。&lt;/p&gt;
&lt;p&gt;当然，&lt;code&gt;reduce&lt;/code&gt;的调整也是很轻松的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; await [1, 2, 3].reduce(async (accumulator, item) =&amp;gt; await accumulator + item, 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们对&lt;code&gt;accumulator&lt;/code&gt;调用&lt;code&gt;await&lt;/code&gt;，然后再与当前&lt;code&gt;item&lt;/code&gt;进行加和，在最后我们的&lt;code&gt;reduce&lt;/code&gt;返回值也一定是一个&lt;code&gt;Promise&lt;/code&gt;，所以我们在最外边也添加&lt;code&gt;await&lt;/code&gt;的字样&lt;br/&gt;也就是说我们每次&lt;code&gt;reduce&lt;/code&gt;都会返回一个新的&lt;code&gt;Promise&lt;/code&gt;对象，在对象内部都会获取上次&lt;code&gt;Promise&lt;/code&gt;的结果。&lt;br/&gt;我们调用&lt;code&gt;reduce&lt;/code&gt;实际上得到的是类似这样的一个&lt;code&gt;Promise&lt;/code&gt;对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   let item = 3
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       let item = 2
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         let item = 1
&lt;span&gt; 7&lt;/span&gt;         Promise.resolve(0).then(result =&amp;gt; resolve(item +&lt;span&gt; result))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       }).then(result =&amp;gt; resolve(item +&lt;span&gt; result))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   }).then(result =&amp;gt; resolve(item +&lt;span&gt; result))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;reduceRight&quot;&gt;reduceRight&lt;/h3&gt;
&lt;p&gt;这个就没什么好说的了。。跟&lt;code&gt;reduce&lt;/code&gt;只是执行顺序相反而已&lt;/p&gt;
&lt;h2 id=&quot;forEach&quot;&gt;forEach&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;forEach&lt;/code&gt;，这个应该是用得最多的遍历方法了，对应的函数签名：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;callback&lt;/code&gt;，对每一个元素进行调用的函数
&lt;ol&gt;&lt;li&gt;&lt;code&gt;currentValue&lt;/code&gt;，当前元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;，当前元素下标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt;，调用&lt;code&gt;forEach&lt;/code&gt;的数组引用&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thisArg&lt;/code&gt;，一个可选的回调函数&lt;code&gt;this&lt;/code&gt;指向&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们有如下的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数组元素求平方后的值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; [1, 2, 3].forEach(item =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   console.log(item ** 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 1&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 4&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;普通版本我们是可以直接这么输出的，但是如果遇到了&lt;code&gt;Promise&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数组元素求平方后的值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; [1, 2, 3].forEach(async item =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   console.log(item ** 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;forEach&lt;/code&gt;并不关心回调函数的返回值，所以&lt;code&gt;forEach&lt;/code&gt;只是执行了三个会返回&lt;code&gt;Promise&lt;/code&gt;的函数&lt;br/&gt;所以如果我们想要得到想要的效果，只能够自己进行增强对象属性了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Array.prototype.forEachSync = async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback, thisArg) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (let [index, item] of Object.entries(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     await callback(item, index, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; await [1, 2, 3].forEachSync(async item =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   console.log(item ** 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 4&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; 9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;await&lt;/code&gt;会忽略非&lt;code&gt;Promise&lt;/code&gt;值，&lt;code&gt;await 0&lt;/code&gt;、&lt;code&gt;await undefined&lt;/code&gt;与普通代码无异&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;filter&quot;&gt;filter&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;作为一个筛选数组用的函数，同样具有遍历的功能：&lt;br/&gt;函数签名同&lt;code&gt;forEach&lt;/code&gt;，但是&lt;code&gt;callback&lt;/code&gt;返回值为&lt;code&gt;true&lt;/code&gt;的元素将被放到&lt;code&gt;filter&lt;/code&gt;函数返回值中去。&lt;/p&gt;
&lt;p&gt;我们要进行一个奇数的筛选，所以我们这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].filter(item =&amp;gt; item % 2 !== 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [1, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们改为&lt;code&gt;Promise&lt;/code&gt;版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].filter(async item =&amp;gt; item % 2 !== 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这会导致我们的筛选功能失效，因为&lt;code&gt;filter&lt;/code&gt;的返回值匹配不是完全相等的匹配，只要是返回值能转换为&lt;code&gt;true&lt;/code&gt;，就会被认定为通过筛选。&lt;br/&gt;&lt;code&gt;Promise&lt;/code&gt;对象必然是&lt;code&gt;true&lt;/code&gt;的，所以筛选失效。&lt;br/&gt;所以我们的处理方式与上边的&lt;code&gt;forEach&lt;/code&gt;类似，同样需要自己进行对象增强&lt;br/&gt;但我们这里直接选择一个取巧的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Array.prototype.filterSync = async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback, thisArg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   let filterResult = await Promise.all(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map(callback))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; [true, false, true]&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.filter((_, index) =&amp;gt;&lt;span&gt; filterResult[index])
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; await [1, 2, 3].filterSync(item =&amp;gt; item % 2 !== 0)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以直接在内部调用&lt;code&gt;map&lt;/code&gt;方法，因为我们知道&lt;code&gt;map&lt;/code&gt;会将所有的返回值返回为一个新的数组。&lt;br/&gt;这也就意味着，我们&lt;code&gt;map&lt;/code&gt;可以拿到我们对所有&lt;code&gt;item&lt;/code&gt;进行筛选的结果，&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;。&lt;br/&gt;接下来对原数组每一项进行返回对应下标的结果即可。&lt;/p&gt;
&lt;h2 id=&quot;some&quot;&gt;some&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;some&lt;/code&gt;作为一个用来检测数组是否满足一些条件的函数存在，同样是可以用作遍历的&lt;br/&gt;函数签名同&lt;code&gt;forEach&lt;/code&gt;，有区别的是当任一&lt;code&gt;callback&lt;/code&gt;返回值匹配为&lt;code&gt;true&lt;/code&gt;则会直接返回&lt;code&gt;true&lt;/code&gt;，如果所有的&lt;code&gt;callback&lt;/code&gt;匹配均为&lt;code&gt;false&lt;/code&gt;，则返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们要判断数组中是否有元素等于&lt;code&gt;2&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].some(item =&amp;gt; item === 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们将它改为&lt;code&gt;Promise&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].some(async item =&amp;gt; item === 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个函数依然会返回&lt;code&gt;true&lt;/code&gt;，但是却不是我们想要的，因为这个是&lt;code&gt;async&lt;/code&gt;返回的&lt;code&gt;Promise&lt;/code&gt;对象被认定为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以，我们要进行如下处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Array.prototype.someSync = async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback, thisArg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (let [index, item] of Object.entries(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (await callback(item, index, &lt;span&gt;this&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; await [1, 2, 3].someSync(async item =&amp;gt; item === 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为&lt;code&gt;some&lt;/code&gt;在匹配到第一个&lt;code&gt;true&lt;/code&gt;之后就会终止遍历，所以我们在这里边使用&lt;code&gt;forEach&lt;/code&gt;的话是在性能上的一种浪费。&lt;br/&gt;同样是利用了&lt;code&gt;await&lt;/code&gt;会忽略普通表达式的优势，在内部使用&lt;code&gt;for-of&lt;/code&gt;来实现我们的需求&lt;/p&gt;
&lt;h2 id=&quot;every&quot;&gt;every&lt;/h2&gt;
&lt;p&gt;以及我们最后的一个&lt;code&gt;every&lt;/code&gt;&lt;br/&gt;函数签名同样与&lt;code&gt;forEach&lt;/code&gt;一样，&lt;br/&gt;但是&lt;code&gt;callback&lt;/code&gt;的处理还是有一些区别的：&lt;br/&gt;其实换一种角度考虑，&lt;code&gt;every&lt;/code&gt;就是一个反向的&lt;code&gt;some&lt;/code&gt;&lt;br/&gt;&lt;code&gt;some&lt;/code&gt;会在获取到第一个&lt;code&gt;true&lt;/code&gt;时终止&lt;br/&gt;而&lt;code&gt;every&lt;/code&gt;会在获取到第一个&lt;code&gt;false&lt;/code&gt;时终止，如果所有元素均为&lt;code&gt;true&lt;/code&gt;，则返回&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们要判定数组中元素是否全部大于3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].every(item =&amp;gt; item &amp;gt; 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;很显然，一个都没有匹配到的，而且回调函数在执行到第一次时就已经终止了，不会继续执行下去。&lt;br/&gt;我们改为&lt;code&gt;Promise&lt;/code&gt;版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [1, 2, 3].every(async =&amp;gt; item &amp;gt; 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个必然是&lt;code&gt;true&lt;/code&gt;，因为我们判断的是&lt;code&gt;Promise&lt;/code&gt;对象&lt;br/&gt;所以我们拿上边的&lt;code&gt;someSync&lt;/code&gt;实现稍微修改一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Array.prototype.everySync = async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback, thisArg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (let [index, item] of Object.entries(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!await callback(item, index, &lt;span&gt;this&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; await [1, 2, 3].everySync(async item =&amp;gt; item === 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当匹配到任意一个&lt;code&gt;false&lt;/code&gt;时，直接返回&lt;code&gt;false&lt;/code&gt;，终止遍历。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;关于数组的这几个遍历方法。&lt;br/&gt;因为&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;reduce&lt;/code&gt;的特性，所以是在使用&lt;code&gt;async&lt;/code&gt;时改动最小的函数。&lt;br/&gt;&lt;em&gt;&lt;code&gt;reduce&lt;/code&gt;的结果很像一个洋葱模型&lt;/em&gt;&lt;br/&gt;但对于其他的遍历函数来说，目前来看就需要自己来实现了。&lt;/p&gt;
&lt;p&gt;四个&lt;code&gt;*Sync&lt;/code&gt;函数的实现：&lt;a href=&quot;https://github.com/Jiasm/notebook/tree/master/array-sync&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Jiasm/notebook/tree/master/array-sync&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Array - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Apr 2018 16:42:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/8948513.html</dc:identifier>
</item>
<item>
<title>[Java] 设计模式：代码形状 - lambda表达式的一个应用 - SNYang</title>
<link>http://www.cnblogs.com/steven-yang/p/8948465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/steven-yang/p/8948465.html</guid>
<description>&lt;h2 id=&quot;code-shape-模式&quot;&gt;Code Shape 模式&lt;/h2&gt;
&lt;p&gt;这里介绍一个模式：Code Shape。没听过，不要紧，我刚刚才起的名字。&lt;/p&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;在应用程序的开发中，我们一般会使用多层架构。&lt;br/&gt;在这种情况下，每一层的方法往往会呈现相同的代码结构。这里称之为&lt;strong&gt;层的代码形状&lt;/strong&gt;。&lt;br/&gt;比如：在数据访问层，每个写数据方法都会有以下的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取数据库连接&lt;/li&gt;
&lt;li&gt;建立事务&lt;/li&gt;
&lt;li&gt;写入数据&lt;/li&gt;
&lt;li&gt;提交事务&lt;/li&gt;
&lt;li&gt;如果发生异常，回滚数据。&lt;br/&gt;除此以外，我们有时也会希望增加一些架构功能，比如：&lt;/li&gt;
&lt;li&gt;统一处理权限认证&lt;/li&gt;
&lt;li&gt;统一处理异常&lt;/li&gt;
&lt;li&gt;记录日志&lt;/li&gt;
&lt;li&gt;对性能做profiling&lt;/li&gt;
&lt;li&gt;记录方法的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，Code Shape模式通过使用Java lambda表达式，达到这样的作用：&lt;br/&gt;&lt;strong&gt;提供了一种灵活的方式，管理一个层中，每个方法的形状。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;这里提供了一个代码示例，完成了以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调用一个层方法前，记录日志&lt;/li&gt;
&lt;li&gt;记录方法参数&lt;/li&gt;
&lt;li&gt;在调用一个层方法后，记录日志&lt;/li&gt;
&lt;li&gt;如果有，记录方法的返回值&lt;/li&gt;
&lt;li&gt;当调用一个层方法，发生异常时，记录日志&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;预备知识&quot;&gt;预备知识&lt;/h2&gt;
&lt;p&gt;关于Java 8的&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html&quot;&gt;Lambda Expressions&lt;/a&gt;。请参考。&lt;/p&gt;
&lt;p&gt;Java提供&lt;code&gt;java.util.function.Consumer&lt;/code&gt;和&lt;code&gt;java.util.function.Function&lt;/code&gt;。方便我们使用Lambda表达式。&lt;br/&gt;Consumer是给没有返回值的方法用的。Function是给有返回值的方法用的。&lt;br/&gt;遗憾的是它们只支持一个输入参数。&lt;br/&gt;因此，如果需要可以写支持多个参数的接口。比如，在我们的例子中用到了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConsumerTwo&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; ConsumerTwo&amp;lt;One, Two&amp;gt; {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(One one, Two two);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;FunctionTwo&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; FunctionTwo&amp;lt;One, Two, R&amp;gt; {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; R &lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;(One one, Two two);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Annotation FunctionalInterface说明这是一个方法接口(function interface)，接口中只定义了一个方法。&lt;/p&gt;
&lt;h2 id=&quot;入口代码&quot;&gt;入口代码&lt;/h2&gt;
&lt;p&gt;入口代码调用了三个示例，说明了各种情况。&lt;br/&gt;第一种情况：调用一个没有返回值的方法。&lt;br/&gt;第二种情况：调用一个没有返回值的方法，实际运行中会发生异常。&lt;br/&gt;第三种情况：调用一个有返回值的方法。&lt;br/&gt;&lt;strong&gt;代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Main {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        
        pattern.&lt;span class=&quot;fu&quot;&gt;CodeShapeSample&lt;/span&gt; br = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; pattern.&lt;span class=&quot;fu&quot;&gt;CodeShapeSample&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// call business rule one&lt;/span&gt;
        br.&lt;span class=&quot;fu&quot;&gt;businessRuleOne&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Jack&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;is man&quot;&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;// call business rule two, will get an exception&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            br.&lt;span class=&quot;fu&quot;&gt;businessRuleTwoThrowException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Tom&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;is woman&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {}

        &lt;span class=&quot;co&quot;&gt;// call business rule three which has a return.&lt;/span&gt;
        String value = br.&lt;span class=&quot;fu&quot;&gt;businessRuleThree&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Mary&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;is woman&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;code-shape-设计模式代码&quot;&gt;Code Shape 设计模式代码&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;CodeShapeSample&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pattern;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.text.MessageFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.function.Consumer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.function.Function;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CodeShapeSample {
    
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * This is a consumer sample&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;businessRuleOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String value) {
        
        CodeShapePattern.&lt;span class=&quot;fu&quot;&gt;consumerShape&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;((o) -&amp;gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(name + &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt; + value);
        }, Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(name, value));
    }
    
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * This is a consumer with exception sample&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;businessRuleTwoThrowException&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String value) {
        
        CodeShapePattern.&lt;span class=&quot;fu&quot;&gt;consumerShape&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;((o) -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;st&quot;&gt;&quot;failure!&quot;&lt;/span&gt;);
        }, Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(name, value));
    }
    
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * This is a function sample&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;businessRuleThree&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String value) {
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; CodeShapePattern.&amp;lt;String&amp;gt;&lt;span class=&quot;fu&quot;&gt;getFunctionShape&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;((o) -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; name + &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt; + value;
        }, Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(name, value));
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;CodeShapePattern&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pattern;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.text.MessageFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.function.Consumer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.function.Function;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CodeShapePattern {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ConsumerTwo&amp;lt;Consumer&amp;lt;Object&amp;gt;, List&amp;lt;Object&amp;gt;&amp;gt; consumerShape = (body, params) -&amp;gt; 
    {
        StackTraceElement caller = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception().&lt;span class=&quot;fu&quot;&gt;getStackTrace&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;];
        String method = caller.&lt;span class=&quot;fu&quot;&gt;getClassName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt; + caller.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;========&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;start method ''{0}''&quot;&lt;/span&gt;, method));
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (params != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Object param : params) {
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;parameter : ''{0}''&quot;&lt;/span&gt;, param.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
                }
            }
            
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- start body ----&quot;&lt;/span&gt;);
            body.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- end body ----&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;end method ''{0}''&quot;&lt;/span&gt;, method));
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error method ''{0}'': {1}&quot;&lt;/span&gt;, method, e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;()));
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
        }
    };
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;R&amp;gt; FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; &lt;span class=&quot;fu&quot;&gt;getFunctionShape&lt;/span&gt;() {
        FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; function = (body, params) -&amp;gt; 
        {
            R ret = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            StackTraceElement caller = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception().&lt;span class=&quot;fu&quot;&gt;getStackTrace&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;];
            String method = caller.&lt;span class=&quot;fu&quot;&gt;getClassName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt; + caller.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;========&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;start method ''{0}''&quot;&lt;/span&gt;, method));
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (params != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Object param : params) {
                        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;parameter : ''{0}''&quot;&lt;/span&gt;, param.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
                    }
                }
                
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- start body ----&quot;&lt;/span&gt;);
                ret = body.&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- end body ----&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;end method ''{0}'', return ''{1}''&quot;&lt;/span&gt;, method, ret.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
            }
            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error method ''{0}'': {1}&quot;&lt;/span&gt;, method, e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;()));
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ret;
        };
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; function;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;代码说明1使用consumer&quot;&gt;代码说明1：使用Consumer&lt;/h2&gt;
&lt;p&gt;现在，所有的代码已经呈上了。我们逐一解释。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;业务层代码&lt;br/&gt;由于这个业务层方法是一个没有返回值的方法，所以使用了&lt;code&gt;CodeShapePattern.consumerShape&lt;/code&gt;。&lt;br/&gt;传入参数有两个。&lt;br/&gt;第一个是：业务层逻辑。&lt;br/&gt;第二个是：方法的参数，用于统一管理。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * This is a consumer sample&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;businessRuleOne&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String value) {
        
        CodeShapePattern.&lt;span class=&quot;fu&quot;&gt;consumerShape&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;((o) -&amp;gt; {
            &lt;span class=&quot;co&quot;&gt;// business rule code&lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(name + &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt; + value);
        }, Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(name, value));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Code Shape 模式代码 - Consumer&lt;br/&gt;实际上consumerShape是一个静态变量，实现了统一管理的功能。&lt;br/&gt;可以看出这个Consumer里面套用了一个Consumer。&lt;br/&gt;&lt;strong&gt;里面的Consumer就是业务逻辑。&lt;/strong&gt;，在业务层方法中，想怎么写，就怎么写。&lt;br/&gt;顺便说一句，这个Consumer的输入参数是没有意义的。我们可以定义一个ConsumerZero来简化这部分。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ConsumerTwo&amp;lt;Consumer&amp;lt;Object&amp;gt;, List&amp;lt;Object&amp;gt;&amp;gt; consumerShape = (body, params) -&amp;gt; 
    {
        StackTraceElement caller = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception().&lt;span class=&quot;fu&quot;&gt;getStackTrace&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;];
        String method = caller.&lt;span class=&quot;fu&quot;&gt;getClassName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt; + caller.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;========&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;start method ''{0}''&quot;&lt;/span&gt;, method));
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (params != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Object param : params) {
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;parameter : ''{0}''&quot;&lt;/span&gt;, param.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
                }
            }
            
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- start body ----&quot;&lt;/span&gt;);
            body.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- end body ----&quot;&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;end method ''{0}''&quot;&lt;/span&gt;, method));
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error method ''{0}'': {1}&quot;&lt;/span&gt;, method, e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;()));
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
        }
    };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;简化版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ConsumerTwo&amp;lt;Consumer&amp;lt;Object&amp;gt;, List&amp;lt;Object&amp;gt;&amp;gt; consumerShape = (body, params) -&amp;gt; 
    {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            body.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
        }
    };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;代码说明2使用function&quot;&gt;代码说明2：使用Function&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;业务层代码&lt;br/&gt;由于这个业务层方法是一个有返回值的方法，所以使用了&lt;code&gt;CodeShapePattern.&amp;lt;R&amp;gt;getFunctionShape()&lt;/code&gt;。&lt;br/&gt;getFunctionShape()是一个泛型方法，泛型类是返回值的类型。&lt;br/&gt;输入参数有两个。&lt;br/&gt;第一个是：业务层逻辑，有返回。&lt;br/&gt;第二个是：方法的参数，用于统一管理。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * This is a function sample&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;businessRuleThree&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String name, &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String value) {
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; CodeShapePattern.&amp;lt;String&amp;gt;&lt;span class=&quot;fu&quot;&gt;getFunctionShape&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;((o) -&amp;gt; {
            &lt;span class=&quot;co&quot;&gt;// business rule code&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; name + &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt; + value;
        }, Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(name, value));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Code Shape 模式代码 - Function&lt;br/&gt;实际上getFunctionShape是一个静态泛型方法，实现了统一管理的功能。&lt;br/&gt;可以看出这个方法的返回Function里面套用了一个Function。&lt;br/&gt;&lt;strong&gt;里面的Function就是业务逻辑。&lt;/strong&gt;，在业务层方法中，想怎么写，就怎么写。&lt;br/&gt;顺便说一句，里面这个Function的输入参数是没有意义的。我们可以定义一个FunctionZero来简化这部分。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;R&amp;gt; FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; &lt;span class=&quot;fu&quot;&gt;getFunctionShape&lt;/span&gt;() {
        FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; function = (body, params) -&amp;gt; 
        {
            R ret = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            StackTraceElement caller = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception().&lt;span class=&quot;fu&quot;&gt;getStackTrace&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;];
            String method = caller.&lt;span class=&quot;fu&quot;&gt;getClassName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt; + caller.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;========&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;start method ''{0}''&quot;&lt;/span&gt;, method));
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (params != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Object param : params) {
                        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;parameter : ''{0}''&quot;&lt;/span&gt;, param.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
                    }
                }
                
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- start body ----&quot;&lt;/span&gt;);
                ret = body.&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---- end body ----&quot;&lt;/span&gt;);
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;end method ''{0}'', return ''{1}''&quot;&lt;/span&gt;, method, ret.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));
            }
            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(MessageFormat&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error method ''{0}'': {1}&quot;&lt;/span&gt;, method, e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;()));
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ret;
        };
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; function;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;简化版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;R&amp;gt; FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; &lt;span class=&quot;fu&quot;&gt;getFunctionShape&lt;/span&gt;() {
        FunctionTwo&amp;lt;Function&amp;lt;Object, R&amp;gt;, List&amp;lt;Object&amp;gt;, R&amp;gt; function = (body, params) -&amp;gt; 
        {
            R ret = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                ret = body.&lt;span class=&quot;fu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            }
            &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ret;
        };
        
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; function;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;输入结果&quot;&gt;输入结果&lt;/h2&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;
========
start method 'pattern.CodeShapeSample#businessRuleOne'
parameter : 'Jack'
parameter : 'is man'
---- start body ----
Jack is man
---- end body ----
end method 'pattern.CodeShapeSample#businessRuleOne'

========
start method 'pattern.CodeShapeSample#businessRuleTwoThrowException'
parameter : 'Tom'
parameter : 'is woman'
---- start body ----
error method 'pattern.CodeShapeSample#businessRuleTwoThrowException': failure!

========
start method 'pattern.CodeShapeSample#businessRuleThree'
parameter : 'Mary'
parameter : 'is woman'
---- start body ----
---- end body ----
end method 'pattern.CodeShapeSample#businessRuleThree', return 'Mary is woman'&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 25 Apr 2018 16:35:00 +0000</pubDate>
<dc:creator>SNYang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/steven-yang/p/8948465.html</dc:identifier>
</item>
<item>
<title>MySQL Innodb如何找出阻塞事务源头SQL - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/8948335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/8948335.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在MySQL数据库中出现了阻塞问题，如何快速查找定位问题根源？在实验开始前，我们先梳理一下有什么工具或命令查看MySQL的阻塞，另外，我们也要一一对比其优劣，因为有些命令可能在实际环境下可能并不适用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1：&lt;span&gt; &lt;/span&gt; show engine innodb status&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2：&lt;span&gt; &lt;/span&gt; Innotop工具&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3：&lt;span&gt; &lt;/span&gt; INNODB_TRX 等系统表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面我们理论联系实际，通过实验来测试总结一下这个问题。首先构造测试环境，数据库测试环境为（ 5.7.21 MySQL Community Server 和5.6.20-enterprise-commercial，这两个测试环境我都测试验证过）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;25&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;use&lt;/span&gt; MyDB;
&lt;/pre&gt;
&lt;pre&gt;
Reading &lt;span&gt;table&lt;/span&gt; information &lt;span&gt;for&lt;/span&gt; &lt;span&gt;completion&lt;/span&gt; &lt;span&gt;of&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; &lt;span&gt;names&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
You can turn &lt;span&gt;off&lt;/span&gt; this feature &lt;span&gt;to&lt;/span&gt; &lt;span&gt;get&lt;/span&gt; a quicker startup &lt;span&gt;with&lt;/span&gt; -A
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Database&lt;/span&gt; changed
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; test_blocking(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;, name &lt;span&gt;varchar&lt;/span&gt;(12));
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.05 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; insert &lt;span&gt;into&lt;/span&gt; test_blocking
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;select&lt;/span&gt; 1, &lt;span&gt;'kerry'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
Records: 1  Duplicates: 0  Warnings: 0
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; insert &lt;span&gt;into&lt;/span&gt; test_blocking
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;select&lt;/span&gt; 2, &lt;span&gt;'jimmy'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
Records: 1  Duplicates: 0  Warnings: 0
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; insert &lt;span&gt;into&lt;/span&gt; test_blocking
&lt;/pre&gt;
&lt;pre&gt;
    -&amp;gt; &lt;span&gt;select&lt;/span&gt; 3, &lt;span&gt;'kkk'&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
Records: 1  Duplicates: 0  Warnings: 0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;准备好测试环境数据后，那么我们接下来开始实验，为了实验效果，我们先将参数innodb_lock_wait_timeout设置为100。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;18&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;31&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show variables &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'innodb_lock_wait_timeout'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+--------------------------+-------+
&lt;/pre&gt;
&lt;pre&gt;
| Variable_name            | &lt;span&gt;Value&lt;/span&gt; |
&lt;/pre&gt;
&lt;pre&gt;
+--------------------------+-------+
&lt;/pre&gt;
&lt;pre&gt;
| innodb_lock_wait_timeout | 50    |
&lt;/pre&gt;
&lt;pre&gt;
+--------------------------+-------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; innodb_lock_wait_timeout=100 ;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|               8 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;session&lt;/span&gt; autocommit=0;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; test_blocking &lt;span&gt;where&lt;/span&gt; id=1 &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
| id | name  |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
|  1 | kerry |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后在第二个连接会话中执行更新脚本，构造被阻塞的案例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|               9 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;update&lt;/span&gt; test_blocking &lt;span&gt;set&lt;/span&gt; name=&lt;span&gt;'kk'&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id=1;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在第三个连接会话执行下面命令，查看TRANSACTIONS相关信息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;mysql&amp;gt; show engine innodb status\G;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000415718-760963199.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; border=&quot;0&quot; alt=&quot;clip_image001&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000416069-1502240913.png&quot; width=&quot;800&quot; height=&quot;404&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用show engine innodb status命令后，可以查看其输出的TRANSACTIONS部分信息，如上截图所示，找到类似TRX HAS BEEN WATING ...部分的信息，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过那部分信息，我们可以看到update test_blocking set name='kk' where id=1这个SQL语句被阻塞了14秒，一直在等待获取X Lock。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;TRANSACTIONS&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;------------&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;Trx id counter 148281&lt;span&gt; &lt;/span&gt; #下一个事务ID&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;Purge done for trx's n:o &amp;lt; 148273 undo n:o &amp;lt; 0 state: running but idle&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;History list length 552&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;LIST OF TRANSACTIONS FOR EACH SESSION:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;---TRANSACTION 0, not started&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;MySQL thread id 15, OS thread handle 0x4cc64940, query id 261 localhost root cleaning up&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;---TRANSACTION 0, not started&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;MySQL thread id 14, OS thread handle 0x4cbe2940, query id 278 localhost root init&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;show engine innodb status&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;---TRANSACTION 148280, ACTIVE 24 sec&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;2 lock struct(s), heap size 360, 1 row lock(s)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;MySQL thread id 8, OS thread handle 0x4cba1940, query id 276 localhost root cleaning up&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;---TRANSACTION 148279, ACTIVE 313 sec starting index read&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;mysql tables in use 1, locked 1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MySQL thread id 9, OS thread handle 0x4cc23940, query id 277 localhost root updating&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; #线程ID为9， 操作系统线程句柄为0x4cc23940， 查询ID为277，账号为root的UPDATE操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;update test_blocking set name='kk' where id=1&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;#具体SQL语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;------- TRX HAS BEEN WAITING 14 SEC FOR THIS LOCK TO BE GRANTED:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; #TRX等待授予锁已经有14秒了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;RECORD LOCKS space id 337 page no 3 n bits 72 index `PRIMARY` of table `MyDB`.`test_blocking` trx id 148279 lock_mode X locks rec but not gap waiting&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;#在space id=337（test_blocking表的表空间），page no=3的页上，表test_blocking上的主键索引在等待X锁&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;0: len 4; hex 80000001; asc&lt;span&gt;    &lt;/span&gt; ;;&lt;span&gt;           &lt;/span&gt; &lt;span&gt;#第一个字段是主键，制度按长为4，值为1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;1: len 6; hex 000000024322; asc&lt;span&gt;    &lt;/span&gt; C&quot;;;&lt;span&gt;     &lt;/span&gt; &lt;span&gt;#该字段为6个字节的事务id，这个id表示最近一次被更新的事务id（对应十进制为148258）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;2: len 7; hex 9a000001f20110; asc&lt;span&gt;     &lt;/span&gt; &lt;span&gt; &lt;/span&gt; ;;&lt;span&gt;  &lt;/span&gt; &lt;span&gt;#该字段为7个字节的回滚指针，用于mvcc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;3: len 5; hex 6b65727279; asc kerry;;&lt;span&gt;        &lt;/span&gt; &lt;span&gt;#该字段表示的是此记录的第二个字段，长度为5，值为kerry（如果表有多个字段，那么此处后面还有记录）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000416294-1994566331.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; border=&quot;0&quot; alt=&quot;clip_image002&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000416578-1000197424.png&quot; width=&quot;651&quot; height=&quot;264&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; information_schema.INNODB_SYS_DATAFILES &lt;span&gt;where&lt;/span&gt; &lt;span&gt;space&lt;/span&gt;=337;
&lt;/pre&gt;
&lt;pre&gt;
+-------+--------------------------+
&lt;/pre&gt;
&lt;pre&gt;
| &lt;span&gt;SPACE&lt;/span&gt; | &lt;span&gt;PATH&lt;/span&gt;                     |
&lt;/pre&gt;
&lt;pre&gt;
+-------+--------------------------+
&lt;/pre&gt;
&lt;pre&gt;
|   337 | ./MyDB/test_blocking.ibd |
&lt;/pre&gt;
&lt;pre&gt;
+-------+--------------------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000416817-1469974130.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; border=&quot;0&quot; alt=&quot;clip_image003&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000417052-1708068990.png&quot; width=&quot;650&quot; height=&quot;155&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是这种方式也有一些弊端，例如生产环境很复杂，尤其是有大量事务的情况下。诸多信息根本无法清晰判断知道谁阻塞了谁；其次一点也不直观； 另外，这个也无法定位blocker 的SQL语句。这种方式只能作为辅助分析用途，通过查看取锁的详细信息，帮助进一步诊断问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2: Innotop工具&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下所示，Innotop工具很多情况下也不能定位到阻塞的语句（Blocking Query）， 也仅仅能获取一些锁相关信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000417336-1790760099.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; border=&quot;0&quot; alt=&quot;clip_image004&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000417720-1394819366.png&quot; width=&quot;701&quot; height=&quot;186&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000417944-587543556.png&quot;&gt;&lt;img title=&quot;clip_image005&quot; border=&quot;0&quot; alt=&quot;clip_image005&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000418223-794716571.png&quot; width=&quot;706&quot; height=&quot;178&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000418480-1586429502.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; border=&quot;0&quot; alt=&quot;clip_image006&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000418920-1440514191.png&quot; width=&quot;700&quot; height=&quot;186&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3：通过查询information_schema数据库下与事务相关的几个系统表&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;还是构造之前的测试案例，在第一个会话中使用SELECT FOR UPDATE锁定其中一行记录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;use&lt;/span&gt; MyDB;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Database&lt;/span&gt; changed
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt;  &lt;span&gt;set&lt;/span&gt; &lt;span&gt;session&lt;/span&gt; autocommit=0;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 0 &lt;span&gt;rows&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              17 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; test_blocking &lt;span&gt;where&lt;/span&gt; id=1 &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
| id | name  |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
|  1 | kerry |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后在第二个连接会话中执行更新脚本，构造被阻塞的案例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;use&lt;/span&gt; MyDB;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Database&lt;/span&gt; changed
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; connection_id() &lt;span&gt;from&lt;/span&gt; dual;
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
| connection_id() |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
|              19 |
&lt;/pre&gt;
&lt;pre&gt;
+-----------------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;update&lt;/span&gt; test_blocking &lt;span&gt;set&lt;/span&gt; name=&lt;span&gt;'kk'&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id=1;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此时阻我们在第三个连接会话查找谁被阻塞了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;26&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; b.trx_mysql_thread_id             &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_thread_id'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
      ,b.trx_query                      &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_sql_text'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
      ,c.trx_mysql_thread_id             &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocker_thread_id'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
      ,c.trx_query                       &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocker_sql_text'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
      ,( Unix_timestamp() - Unix_timestamp(c.trx_started) ) 
&lt;/pre&gt;
&lt;pre&gt;
                              &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'blocked_time'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;   information_schema.innodb_lock_waits a 
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; information_schema.innodb_trx b 
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;ON&lt;/span&gt; a.requesting_trx_id = b.trx_id 
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;INNER&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; information_schema.innodb_trx c 
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;ON&lt;/span&gt; a.blocking_trx_id = c.trx_id 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt;  ( Unix_timestamp() - Unix_timestamp(c.trx_started) ) &amp;gt; 4; 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; a.sql_text, 
&lt;/pre&gt;
&lt;pre&gt;
       c.id, 
&lt;/pre&gt;
&lt;pre&gt;
       d.trx_started 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;   performance_schema.events_statements_current a 
&lt;/pre&gt;
&lt;pre&gt;
       &lt;span&gt;join&lt;/span&gt; performance_schema.threads b 
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;ON&lt;/span&gt; a.thread_id = b.thread_id 
&lt;/pre&gt;
&lt;pre&gt;
       &lt;span&gt;join&lt;/span&gt; information_schema.processlist c 
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;ON&lt;/span&gt; b.processlist_id = c.id 
&lt;/pre&gt;
&lt;pre&gt;
       &lt;span&gt;join&lt;/span&gt; information_schema.innodb_trx d 
&lt;/pre&gt;
&lt;pre&gt;
         &lt;span&gt;ON&lt;/span&gt; c.id = d.trx_mysql_thread_id 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;where&lt;/span&gt; c.id=17
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt;  &lt;span&gt;BY&lt;/span&gt; d.trx_started\G;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下截图所示，第一个SQL语句能够查到线程19 被线程 17阻塞了， 被阻塞的SQL语句为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;update test_blocking set name='kk' where id=1;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;, 能够查到被阻塞了多长时间，但是无法查到源头SQL语句。此时就需要第二个SQL语句登场，找到源头语句。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000419304-453637806.png&quot;&gt;&lt;img title=&quot;clip_image007&quot; border=&quot;0&quot; alt=&quot;clip_image007&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000419679-864185221.png&quot; width=&quot;801&quot; height=&quot;634&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是不要太天真的认为第二个SQL语句能够获取所有场景下的阻塞源头SQL语句，实际业务场景，会话可能在执行一个存储过程或复杂的业务，有可能它执行完阻塞源头SQL后，继续在执行其它SQL语句，此时，你抓取的是这个连接会话最后执行的SQL语句，如下所示，我简单构造了一个例子。就能构造这样的一个场景。这个我曾经写过一篇博客&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;a href=&quot;http://www.cnblogs.com/kerrycode/p/5821413.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;为什么数据库有时候不能定位阻塞（Blocker）源头的SQL语句&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，分析SQL Server和ORACLE 定位查找阻塞源头SQL语句，现在看来真是大道同源，殊途同归。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;8.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; test_blocking &lt;span&gt;where&lt;/span&gt; id=1 &lt;span&gt;for&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
| id | name  |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
|  1 | kerry |
&lt;/pre&gt;
&lt;pre&gt;
+----+-------+
&lt;/pre&gt;
&lt;pre&gt;
1 &lt;span&gt;row&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; student &lt;span&gt;where&lt;/span&gt; stu_id=1001;
&lt;/pre&gt;
&lt;pre&gt;
Query OK, 1 &lt;span&gt;row&lt;/span&gt; affected (0.00 sec)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
mysql&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000420065-211533208.png&quot;&gt;&lt;img title=&quot;clip_image008&quot; border=&quot;0&quot; alt=&quot;clip_image008&quot; src=&quot;https://images2018.cnblogs.com/blog/73542/201804/73542-20180426000420408-109415813.png&quot; width=&quot;800&quot; height=&quot;623&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总结： 最简单、方便的还是上面两个SQL查询定位blocker的SQL语句，但是需要注意：有时候它也查不到真正阻塞的源头SQL语句。所以还需结合应用程序代码与上下文环境进行整体分析、判断！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Apr 2018 16:04:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kerrycode/p/8948335.html</dc:identifier>
</item>
<item>
<title>一切都很奇妙 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/8948092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/8948092.html</guid>
<description>&lt;p&gt;写在公号运营一周年之际&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/life/rose.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像我上面说的，一切都很奇妙。2016年的时候我开始写博客，在博客园积累了一点小人气，在朋友的鼓励下2017年4月25日开通了微信公众号，26号发了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/D9MOZ6mFz-0HPQ0gZx_L1Q&quot;&gt;我开通了微信公众号&lt;/a&gt;，转眼就一年过去了。&lt;/p&gt;
&lt;p&gt;2016年我刚开始写博客的时候我在想，博客园排名 Top 100 的人都是什么样的大拿，今天我在去看博客园的时候，我已经排在博客园推荐博客的第27位；2017年我刚开始发公众号的时候，每天的阅读量才几十个，我再看同行内的技术公号阅读量动不动就上千很羡慕，不知道大家都是怎么运营的，到现在我的公号阅读量也能差不多4000左右的阅读量。&lt;/p&gt;
&lt;p&gt;2016年的时候我在百度搜索纯洁的微笑，还是一堆各种表情，现在排在第一页的信息几乎都与我有关，2016年的时候我在想 github Top 100 的用户都是什么样的人，到了现在我在 github 中国区的排名也到了130。&lt;/p&gt;
&lt;p&gt;2016年的时候我还没有博客，一直希望自己写的文章能排到博客园的头条，常常被博客园的编辑给 pass 掉，让我很不爽但只能努力写出更好的文章。后来我搭建了个人独立博客：&lt;a href=&quot;http://www.ityouknow.com/&quot;&gt;www.ityouknow.com&lt;/a&gt;，每天没有几个人访问我的博客，到现在我的博客园博客和个人博客均访问量过百万，个人独立博客每天 pv 1.5w。&lt;/p&gt;
&lt;p&gt;在这个过程中我认识了很多做技术的同行，认识了很多的出版社的编辑，各大技术论坛的运营，在线上做了几次技术分享，这一切都让我感到很新奇，很多很多的第一次让我去探索，很激动又很诚恐，因为我知道我只是一个普通的程序员。&lt;/p&gt;
&lt;p&gt;我不是什么大佬，在我们公司也有比我技术牛很多的人，只是他们不太善于写作，没有碰到机会，其实不只我们公司，很多大牛也是一样，他们技术非常的好，但总结和写作能力稍弱一些，我只是一个喜欢分享的程序员。&lt;/p&gt;
&lt;p&gt;写博客最初的目的是，我想打开一扇窗子和广大的技术人去交流、沟通、学习。在2016年写博客之初，我已经工作了6年多，在互联网公司里面也做了一些技术，但这些技术在整个互联网技术圈里面是一个什么样的层次我不知道，毕竟我们在一个小公司。于是我将我们工作中使用的技术做了分享，渴望同行看完可以给我留言，一起交流。&lt;/p&gt;
&lt;p&gt;当然了，刚开始也不顺利，博客写了也没几个人看，后来慢慢的给我留言的用户越来越多，并且很多的朋友指出了我文章中的错误，给了很多他们的建议，让我学习到了很多的东西。针对这些反馈的信息，我又继续写了下去，工作中使用的技术，排查问题的思路，生产救火的故事，架构发展的历程。&lt;/p&gt;
&lt;p&gt;慢慢的我发现什么都可以写了，写写生活中的故事，做技术的感悟，总之：you can do whatever you do.&lt;/p&gt;
&lt;p&gt;上面都说的是收获，但有得就有失，在写文章之前我每月都会去爬山，隔两周就会去打打球、游泳或者骑个共享单车去逛北京的巷子，和朋友出去侃侃大山，喝喝啤酒，一年出去旅游两次。现在我已经有一年多没有好好出去玩一次了，写文章之后，我的生活改变很大，朋友在聚合的时候我在写文章，下班后我在写文章，好不容易周末了我还在写文章，身体大不如从前，生活感觉有点失衡。&lt;/p&gt;
&lt;p&gt;现在我的公号不但分享我自己的文章，也会分享一些我看到的非常优秀的技术内容，有空闲时间了就多写一些原创文章推送给大家，工作忙了就分享一些写的比我还好的文章，不时的也会接一些小广告，挣个零花钱，所以大家看到我发软文的时候不要太反感，毕竟这也是让我持续下去的动力之一。&lt;/p&gt;
&lt;p&gt;写文章还可以赚钱是我一开始没有想到的，这是我做公号半年之后有人找上门来我才发现有这个价值，其实也是对我写作的一个认可，毕竟用钱给予的鼓励是真的认可。在我的博客关于页面放了一个赞赏码，不时的也会有朋友打赏一些小钱，钱不多但给予的鼓励价值非常大，有的朋友在赞赏的同时给我留言：你的文章对我帮助很大，这就是我坚持的最大动力，我的输出是有价值的。&lt;/p&gt;
&lt;p&gt;我一直相信一个道理，就是很多东西其实是不用去坚持的，听到坚持这个词，感觉是很累很痛苦的过程，但如果你真的热爱某一件事情的时候，就无所谓坚持，就是不断的受到鼓舞、激励，自然的就走了下来，当你回过头来的时候才发现已经走了这么远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2018/life/zuizhong.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;摘录于平凡的世界：&lt;/p&gt;
&lt;p&gt;生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世界上活了一场。有了这样的认识，你就会珍重生活，而不会玩世不恭；同时，也会给人自身注入一种强大的内在力量。&lt;/p&gt;
&lt;p&gt;愿每一个技术人都得到尊重！&lt;/p&gt;
</description>
<pubDate>Wed, 25 Apr 2018 15:15:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/8948092.html</dc:identifier>
</item>
<item>
<title>从Openvswitch代码看网络包的旅程 - popsuper1982</title>
<link>http://www.cnblogs.com/popsuper1982/p/8948016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/popsuper1982/p/8948016.html</guid>
<description>&lt;p&gt;&lt;span&gt;我们知道，Openvwitch可以创建虚拟交换机，而网络包可以通过虚拟交换机进行转发，并通过流表进行处理，具体的过程如何呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、内核模块Openvswitch.ko的加载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OVS是内核态和用户态配合工作的，所以首先要加载内核态模块Openvswitch.ko。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在datapath/datapath.c中会调用module_init(dp_init);来初始化内核模块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中比较重要的是调用了dp_register_genl()，这个就是注册netlink函数，从而用户态进程ovs-vswitchd可以通过netlink调用内核。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里dp_genl_families由四个netlink的family组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;static struct genl_family *dp_genl_families[] = {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp;dp_datapath_genl_family,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp;dp_vport_genl_family,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp;dp_flow_genl_family,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;   &amp;amp;dp_packet_genl_family,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;可以看出，在内核中，包含对datapath的操作，例如OVS_DP_CMD_NEW，对虚拟端口vport的操作，例如OVS_VPORT_CMD_NEW，对flow流表的操作，例如OVS_FLOW_CMD_NEW&lt;span&gt;，对packet包的操作，例如OVS_PACKET_CMD_EXECUTE。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、用户态进程ovs-vswitchd的启动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ovs-vswitchd.c的main函数最终会进入一个while循环，在这个无限循环中，里面最重要的两个函数是bridge_run()和netdev_run()。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Openvswitch主要管理两种类型的设备，一个是创建的虚拟网桥，一个是连接到虚拟网桥上的设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中bridge_run就是初始化数据库中已经创建的虚拟网桥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bridge_run会调用static void bridge_reconfigure(const struct ovsrec_open_vswitch *ovs_cfg)，其中ovs_cfg是从ovsdb-server里面读取出来的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个函数里面，对于每一个网桥，将网卡添加进去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;HMAP_FOR_EACH (br, node, &amp;amp;all_bridges) {&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    bridge_add_ports(br, &amp;amp;br-&amp;gt;wanted_ports);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    shash_destroy(&amp;amp;br-&amp;gt;wanted_ports);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终会调用dpif_netlink_port_add__在这个函数里面，会调用netlink的API，命令为OVS_VPORT_CMD_NEW。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、内核模块监听网卡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ovs-vswitchd启动的时候，将虚拟网卡添加到虚拟交换机上的时候，会调用netlink的OVS_VPORT_CMD_NEW命令，因而会调用函数ovs_vport_cmd_new。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它最终会调用ovs_netdev_link，其中有下面的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;err = netdev_rx_handler_register(vport-&amp;gt;dev, netdev_frame_hook,&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;                vport);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;注册一个方法叫做netdev_frame_hook，每当网卡收到包的时候，就调用这个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、内核态网络包处理&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Openvswitch的内核模块openvswitch.ko会在网卡上注册一个函数netdev_frame_hook，每当有网络包到达网卡的时候，这个函数就会被调用。&lt;/span&gt;&lt;/p&gt;

&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;static struct sk_buff *netdev_frame_hook(struct sk_buff *skb)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;   if (unlikely(skb-&amp;gt;pkt_type == PACKET_LOOPBACK))&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;      return skb;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;   port_receive(skb);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;   return NULL;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用port_receive即是调用netdev_port_receive&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个函数里面，首先声明了变量struct sw_flow_key key;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们看这个key的定义，可见这个key里面是一个大杂烩，数据包里面的几乎任何部分都可以作为key来查找flow表&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;tunnel可以作为key&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在物理层，in_port即包进入的网口的ID&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在MAC层，源和目的MAC地址&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在IP层，源和目的IP地址&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;在传输层，源和目的端口号&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;IPV6&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以，要在内核态匹配流表，首先需要调用ovs_flow_key_extract，从包的正文中提取key的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就是要调用ovs_dp_process_packet了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个函数首先在内核里面的流表中查找符合key的flow，也即ovs_flow_tbl_lookup_stats，如果找到了，很好说明用户态的流表已经放入内核，则走fast path就可了。于是直接调用ovs_execute_actions，执行这个key对应的action。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不能找到，则只好调用ovs_dp_upcall，让用户态去查找流表。会调用static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb, const struct sw_flow_key *key, const struct dp_upcall_info *upcall_info)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它会调用err = genlmsg_unicast(ovs_dp_get_net(dp), user_skb, upcall_info-&amp;gt;portid);通过netlink将消息发送给用户态。在用户态，有线程监听消息，一旦有消息，则触发udpif_upcall_handler。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Slow Path &amp;amp; Fast Path&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201804/635909-20180425225800050-1293753570.jpg&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Slow Path:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当Datapath找不到flow rule对packet进行处理时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Vswitchd使用flow rule对packet进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Fast Path:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将slow path的flow rule放在内核态，对packet进行处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unknown Packet Processing&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Datapath使用flow rule对packet进行处理，如果没有，则有vswitchd使用flow rule进行处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201804/635909-20180425225821890-1962012445.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;从Device接收Packet交给事先注册的event handler进行处理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;接收Packet后识别是否是unknown packet，是则交由upcall处理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;vswitchd对unknown packet找到flow rule进行处理&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;将Flow rule发送给datapath&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、用户态处理包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当内核无法查找到流表项的时候，则会通过upcall来调用用户态ovs-vswtichd中的flow table。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会调用ofproto-dpif-upcall.c中的udpif_upcall_handler函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1) 首先读取upcall调用static int upcall_receive(struct upcall *upcall, const struct dpif_backer *backer, const struct dp_packet *packet, enum dpif_upcall_type type, const struct nlattr *userdata, const struct flow *flow, const unsigned int mru, const ovs_u128 *ufid, const unsigned pmd_id)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 其次提取包头调用void flow_extract(struct dp_packet *packet, struct flow *flow)，提取出的flow如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;26.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;/* L2, Order the same as in the Ethernet header! (64-bit aligned) */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct eth_addr dl_dst; &lt;span&gt;/* Ethernet destination address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct eth_addr dl_src; &lt;span&gt;/* Ethernet source address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 dl_type; &lt;span&gt;/* Ethernet frame type. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 vlan_tci; &lt;span&gt;/* If 802.1Q, TCI | VLAN_CFI; otherwise 0. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be32 mpls_lse[ROUND_UP(FLOW_MAX_MPLS_LABELS, 2)]; &lt;span&gt;/* MPLS label stack&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                                                             (with padding). */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;/* L3 (64-bit aligned) */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be32 nw_src; &lt;span&gt;/* IPv4 source address. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be32 nw_dst; &lt;span&gt;/* IPv4 destination address. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct &lt;span&gt;in6_addr ipv6_src; &lt;span&gt;/* IPv6 source address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct &lt;span&gt;in6_addr ipv6_dst; &lt;span&gt;/* IPv6 destination address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be32 ipv6_label; &lt;span&gt;/* IPv6 flow label. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;uint8_t nw_frag; &lt;span&gt;/* FLOW_FRAG_* flags. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;uint8_t nw_tos; &lt;span&gt;/* IP ToS (including DSCP and ECN). */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;uint8_t nw_ttl; &lt;span&gt;/* IP TTL/Hop Limit. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;uint8_t nw_proto; &lt;span&gt;/* IP protocol or low 8 bits of ARP opcode. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct &lt;span&gt;in6_addr nd_target; &lt;span&gt;/* IPv6 neighbor discovery (ND) target. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct eth_addr arp_sha; &lt;span&gt;/* ARP/ND source hardware address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;struct eth_addr arp_tha; &lt;span&gt;/* ARP/ND target hardware address. */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 tcp_flags; &lt;span&gt;/* TCP flags. With L3 to avoid matching L4. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 pad3; &lt;span&gt;/* Pad to 64 bits. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;/* L4 (64-bit aligned) */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 tp_src; &lt;span&gt;/* TCP/UDP/SCTP source port/ICMP type. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be16 tp_dst; &lt;span&gt;/* TCP/UDP/SCTP destination port/ICMP code. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    ovs_be32 igmp_group_ip4; &lt;span&gt;/* IGMP group IPv4 address.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                                 * Keep last for BUILD_ASSERT_DECL below. */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 然后调用static int process_upcall(struct udpif *udpif, struct upcall *upcall, struct ofpbuf *odp_actions, struct flow_wildcards *wc)来处理upcall。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于MISS_UPCALL，调用static void upcall_xlate(struct udpif *udpif, struct upcall *upcall, struct ofpbuf *odp_actions, struct flow_wildcards *wc)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会调用enum xlate_error xlate_actions(struct xlate_in *xin, struct xlate_out *xout)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个函数里面，会在flow table里面查找rule&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ctx.rule = rule_dpif_lookup_from_table( ctx.xbridge-&amp;gt;ofproto, ctx.tables_version, flow, xin-&amp;gt;wc, ctx.xin-&amp;gt;resubmit_stats, &amp;amp;ctx.table_id, flow-&amp;gt;in_port.ofp_port, true, true);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到rule之后，调用static void do_xlate_actions(const struct ofpact *ofpacts, size_t ofpacts_len, struct xlate_ctx *ctx)在这个函数里面，根据action的不同，修改flow的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 最后调用static void handle_upcalls(struct udpif *udpif, struct upcall *upcalls, size_t n_upcalls)将flow rule添加到内核中的datapath&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他会调用void dpif_operate(struct dpif *dpif, struct dpif_op **ops, size_t n_ops)，他会调用dpif-&amp;gt;dpif_class-&amp;gt;operate(dpif, ops, chunk);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会调用dpif_netlink_operate()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会调用netlink修改内核中datapath的规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;list-paddingleft-2&quot;&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;case DPIF_OP_FLOW_PUT:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    put = &amp;amp;op-&amp;gt;u.flow_put;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    dpif_netlink_init_flow_put(dpif, put, &amp;amp;flow);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;if (put-&amp;gt;stats) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        flow.nlmsg_flags |= NLM_F_ECHO;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        aux-&amp;gt;txn.reply = &amp;amp;aux-&amp;gt;reply;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    dpif_netlink_flow_to_ofpbuf(&amp;amp;flow, &amp;amp;aux-&amp;gt;request);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;break;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;欢迎关注个人公众号&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/635909/201804/635909-20180425230020718-1408797469.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Apr 2018 15:01:00 +0000</pubDate>
<dc:creator>popsuper1982</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/popsuper1982/p/8948016.html</dc:identifier>
</item>
<item>
<title>分布式锁看这篇就够了 - zhisheng_tian</title>
<link>http://www.cnblogs.com/zhisheng/p/8947996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhisheng/p/8947996.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fqp2lqscrwj31hc0zk46a.jpg&quot; alt=&quot;meadow-811339_1920&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关注我&quot;&gt;关注我&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转载请务必注明原创地址为：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/&quot; class=&quot;uri&quot;&gt;http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是锁&quot;&gt;什么是锁？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。&lt;/li&gt;
&lt;li&gt;而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。&lt;/li&gt;
&lt;li&gt;不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如 Java 中 synchronize 是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改，linux 内核中也是利用互斥量或信号量等内存数据做标记。&lt;/li&gt;
&lt;li&gt;除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是分布式&quot;&gt;什么是分布式？&lt;/h3&gt;
&lt;p&gt;分布式的 CAP 理论告诉我们:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。&lt;/p&gt;
&lt;h4 id=&quot;分布式场景&quot;&gt;分布式场景&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处主要指集群模式下，多个相同服务同时开启.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如&lt;strong&gt;分布式事务&lt;/strong&gt;、&lt;strong&gt;分布式锁&lt;/strong&gt;等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过 Java 提供的并发 API 我们可以解决，但是在分布式环境下，就没有那么简单啦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式与单机情况下最大的不同在于其不是多线程而是&lt;strong&gt;多进程&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;什么是分布式锁&quot;&gt;什么是分布式锁？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。&lt;/li&gt;
&lt;li&gt;与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到&lt;strong&gt;网络的延时和不可靠&lt;/strong&gt;。。。一个大坑）&lt;/li&gt;
&lt;li&gt;分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;我们需要怎样的分布式锁&quot;&gt;我们需要怎样的分布式锁？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。&lt;/li&gt;
&lt;li&gt;这把锁要是一把可重入锁（避免死锁）&lt;/li&gt;
&lt;li&gt;这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）&lt;/li&gt;
&lt;li&gt;这把锁最好是一把公平锁（根据业务需求考虑要不要这条）&lt;/li&gt;
&lt;li&gt;有高可用的获取锁和释放锁功能&lt;/li&gt;
&lt;li&gt;获取锁和释放锁的性能要好&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基于数据库做分布式锁&quot;&gt;基于数据库做分布式锁&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;基于乐观锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于表主键唯一做分布式锁&quot;&gt;基于表主键唯一做分布式锁&lt;/h4&gt;
&lt;p&gt;利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。&lt;/p&gt;
&lt;p&gt;上面这种简单的实现有以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。&lt;/li&gt;
&lt;li&gt;这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。&lt;/li&gt;
&lt;li&gt;这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。&lt;/li&gt;
&lt;li&gt;这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。&lt;/li&gt;
&lt;li&gt;这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁。&lt;/li&gt;
&lt;li&gt;在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，我们也可以有其他方式解决上面的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上。&lt;/li&gt;
&lt;li&gt;没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。&lt;/li&gt;
&lt;li&gt;非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功。&lt;/li&gt;
&lt;li&gt;非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。&lt;/li&gt;
&lt;li&gt;非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁。&lt;/li&gt;
&lt;li&gt;比较好的办法是在程序中生产主键进行防重。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基于表字段版本号做分布式锁&quot;&gt;基于表字段版本号做分布式锁&lt;/h4&gt;
&lt;p&gt;这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基于悲观锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基于数据库排他锁做分布式锁&quot;&gt;基于数据库排他锁做分布式锁&lt;/h4&gt;
&lt;p&gt;在查询语句后面增加&lt;code&gt;for update&lt;/code&gt;，数据库会在查询过程中给数据库表增加排他锁 (注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。)。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。&lt;/p&gt;
&lt;p&gt;我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过&lt;code&gt;connection.commit()&lt;/code&gt;操作来释放锁。&lt;/p&gt;
&lt;p&gt;这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阻塞锁？ &lt;code&gt;for update&lt;/code&gt;语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。&lt;/li&gt;
&lt;li&gt;锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是还是无法直接解决数据库单点和可重入问题。&lt;/p&gt;
&lt;p&gt;这里还可能存在另外一个问题，虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。&lt;/p&gt;
&lt;p&gt;还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。&lt;/p&gt;
&lt;h4 id=&quot;优缺点&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：简单，易于理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：会有各种各样的问题（操作数据库需要一定的开销，使用数据库的行级锁并不一定靠谱，性能不靠谱）&lt;/p&gt;
&lt;h3 id=&quot;基于-redis-做分布式锁&quot;&gt;基于 Redis 做分布式锁&lt;/h3&gt;
&lt;h4 id=&quot;基于-redis-的-setnxexpire-方法做分布式锁&quot;&gt;基于 redis 的 setnx()、expire() 方法做分布式锁&lt;/h4&gt;
&lt;h5 id=&quot;setnx&quot;&gt;setnx()&lt;/h5&gt;
&lt;p&gt;setnx 的含义就是 SET if Not Exists，其主要有两个参数 setnx(key, value)。该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。&lt;/p&gt;
&lt;h5 id=&quot;expire&quot;&gt;expire()&lt;/h5&gt;
&lt;p&gt;expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置。&lt;/p&gt;
&lt;h5 id=&quot;使用步骤&quot;&gt;使用步骤&lt;/h5&gt;
&lt;p&gt;1、setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功&lt;/p&gt;
&lt;p&gt;2、expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。&lt;/p&gt;
&lt;p&gt;3、执行完业务代码后，可以通过 delete 命令删除 key。&lt;/p&gt;
&lt;p&gt;这个方案其实是可以解决日常工作中的需求的，但从技术方案的探讨上来说，可能还有一些可以完善的地方。&lt;strong&gt;比如，如果在第一步 setnx 执行成功后，在 expire() 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题，所以如果要对其进行完善的话，可以使用 redis 的 setnx()、get() 和 getset() 方法来实现分布式锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;基于-redis-的-setnxgetgetset方法做分布式锁&quot;&gt;基于 redis 的 setnx()、get()、getset()方法做分布式锁&lt;/h4&gt;
&lt;p&gt;这个方案的背景主要是在 setnx() 和 expire() 的方案上针对可能存在的死锁问题，做了一些优化。&lt;/p&gt;
&lt;h5 id=&quot;getset&quot;&gt;getset()&lt;/h5&gt;
&lt;p&gt;这个命令主要有两个参数 getset(key，newValue)。该方法是原子的，对 key 设置 newValue 这个值，并且返回 key 原来的旧值。假设 key 原来是不存在的，那么多次执行这个命令，会出现下边的效果：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;getset(key, &quot;value1&quot;) 返回 null 此时 key 的值会被设置为 value1&lt;/li&gt;
&lt;li&gt;getset(key, &quot;value2&quot;) 返回 value1 此时 key 的值会被设置为 value2&lt;/li&gt;
&lt;li&gt;依次类推！&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;使用步骤-1&quot;&gt;使用步骤&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向 2。&lt;/li&gt;
&lt;li&gt;get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。&lt;/li&gt;
&lt;li&gt;计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime。&lt;/li&gt;
&lt;li&gt;判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。&lt;/li&gt;
&lt;li&gt;在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import cn.com.tpig.cache.redis.RedisService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import cn.com.tpig.utils.SpringUtils;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//redis分布式锁&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RedisLockUtil {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; defaultExpire = &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RedisLockUtil&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 加锁&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param key &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;redis key&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param expire &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;过期时间，单位秒&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;true:加锁成功，false，加锁失败&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;(String key, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expire) {

        RedisService redisService = SpringUtils.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(RedisService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; status = redisService.&lt;span class=&quot;fu&quot;&gt;setnx&lt;/span&gt;(key, &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(status == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            redisService.&lt;span class=&quot;fu&quot;&gt;expire&lt;/span&gt;(key, expire);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;(String key) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock2&lt;/span&gt;(key, defaultExpire);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 加锁&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param key &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;redis key&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param expire &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;过期时间，单位秒&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;true:加锁成功，false，加锁失败&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock2&lt;/span&gt;(String key, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expire) {

        RedisService redisService = SpringUtils.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(RedisService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);

        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; value = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() + expire;
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; status = redisService.&lt;span class=&quot;fu&quot;&gt;setnx&lt;/span&gt;(key, String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(value));

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(status == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; oldExpireTime = Long.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(redisService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key, &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;));
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(oldExpireTime &amp;lt; System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;()) {
            &lt;span class=&quot;co&quot;&gt;//超时&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; newExpireTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() + expire;
            &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; currentExpireTime = Long.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(redisService.&lt;span class=&quot;fu&quot;&gt;getSet&lt;/span&gt;(key, String.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(newExpireTime)));
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(currentExpireTime == oldExpireTime) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unLock1&lt;/span&gt;(String key) {
        RedisService redisService = SpringUtils.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(RedisService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        redisService.&lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(key);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unLock2&lt;/span&gt;(String key) {    
        RedisService redisService = SpringUtils.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(RedisService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);    
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; oldExpireTime = Long.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(redisService.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key, &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;));   
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(oldExpireTime &amp;gt; System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;()) {        
            redisService.&lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(key);    
        }
   }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;drawRedPacket&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; userId) {
    String key = &lt;span class=&quot;st&quot;&gt;&quot;draw.redpacket.userid:&quot;&lt;/span&gt; + userId;

    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; lock = RedisLockUtil.&lt;span class=&quot;fu&quot;&gt;lock2&lt;/span&gt;(key, &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(lock) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//领取操作&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//释放锁&lt;/span&gt;
            RedisLockUtil.&lt;span class=&quot;fu&quot;&gt;unLock&lt;/span&gt;(key);
        }
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;st&quot;&gt;&quot;重复领取奖励&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;基于-redlock-做分布式锁&quot;&gt;基于 Redlock 做分布式锁&lt;/h4&gt;
&lt;p&gt;Redlock 是 Redis 的作者 antirez 给出的集群模式的 Redis 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。&lt;/p&gt;
&lt;p&gt;算法的步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、客户端获取当前时间，以毫秒为单位。&lt;/li&gt;
&lt;li&gt;2、客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用。&lt;/li&gt;
&lt;li&gt;3、客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁。&lt;/li&gt;
&lt;li&gt;4、客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间。&lt;/li&gt;
&lt;li&gt;5、如果客户端获取锁失败了，客户端会依次删除所有的锁。&lt;br/&gt;使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，有一位分布式的专家写了一篇文章《How to do distributed locking》，质疑 Redlock 的正确性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;https://blog.csdn.net/jek123456/article/details/72954106&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#### 优缺点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;失效时间设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。&lt;/p&gt;
&lt;h4 id=&quot;基于-redisson-做分布式锁&quot;&gt;基于 redisson 做分布式锁&lt;/h4&gt;
&lt;p&gt;redisson 是 redis 官方的分布式锁组件。GitHub 地址：&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;https://github.com/redisson/redisson&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的这个问题 ——&amp;gt; 失效时间设置多长时间为好？这个问题在 redisson 的做法是：每获得一个锁时，只设置一个很短的超时时间，同时起一个线程在每次快要到超时时间时去刷新锁的超时时间。在释放锁的同时结束这个线程。&lt;/p&gt;
&lt;h3 id=&quot;基于-zookeeper-做分布式锁&quot;&gt;基于 ZooKeeper 做分布式锁&lt;/h3&gt;
&lt;h4 id=&quot;zookeeper-锁相关基础知识&quot;&gt;zookeeper 锁相关基础知识&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;zk 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。&lt;/li&gt;
&lt;li&gt;zk 的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。&lt;/li&gt;
&lt;li&gt;子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。&lt;/li&gt;
&lt;li&gt;Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;zk-基本锁&quot;&gt;zk 基本锁&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;原理：利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。&lt;/li&gt;
&lt;li&gt;缺点：所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;zk-锁优化&quot;&gt;zk 锁优化&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;原理：上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。&lt;/li&gt;
&lt;li&gt;步骤：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。&lt;/li&gt;
&lt;li&gt;判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。&lt;/li&gt;
&lt;li&gt;当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。&lt;/li&gt;
&lt;li&gt;取锁成功则执行代码，最后释放锁（删除该节点）。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Collections;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.CountDownLatch;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Condition;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Lock;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.CreateMode;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.KeeperException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.WatchedEvent;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.Watcher;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.ZooDefs;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.ZooKeeper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.zookeeper.data.Stat;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DistributedLock &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Lock, Watcher{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ZooKeeper zk;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String root = &lt;span class=&quot;st&quot;&gt;&quot;/locks&quot;&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//根&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String lockName;&lt;span class=&quot;co&quot;&gt;//竞争资源的标志&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String waitNode;&lt;span class=&quot;co&quot;&gt;//等待前一个锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String myZnode;&lt;span class=&quot;co&quot;&gt;//当前锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; CountDownLatch latch;&lt;span class=&quot;co&quot;&gt;//计数器&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sessionTimeout = &lt;span class=&quot;dv&quot;&gt;30000&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;Exception&amp;gt; exception = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Exception&amp;gt;();

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param config &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;127.0.0.1:2181&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param lockName &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;竞争资源标志,lockName中不能包含单词lock&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DistributedLock&lt;/span&gt;(String config, String lockName){
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lockName&lt;/span&gt; = lockName;
        &lt;span class=&quot;co&quot;&gt;// 创建一个与服务器的连接&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            zk = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ZooKeeper&lt;/span&gt;(config, sessionTimeout, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
            Stat stat = zk.&lt;span class=&quot;fu&quot;&gt;exists&lt;/span&gt;(root, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(stat == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
                &lt;span class=&quot;co&quot;&gt;// 创建根节点&lt;/span&gt;
                zk.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(root, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], ZooDefs.&lt;span class=&quot;fu&quot;&gt;Ids&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;OPEN_ACL_UNSAFE&lt;/span&gt;,CreateMode.&lt;span class=&quot;fu&quot;&gt;PERSISTENT&lt;/span&gt;);
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            exception.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (KeeperException e) {
            exception.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            exception.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e);
        }
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * zookeeper节点的监视器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;process&lt;/span&gt;(WatchedEvent event) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latch&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latch&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;countDown&lt;/span&gt;();
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(exception.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;){
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(exception.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
        }
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;()){
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Thread &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt; +myZnode + &lt;span class=&quot;st&quot;&gt;&quot; get lock true&quot;&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
                &lt;span class=&quot;fu&quot;&gt;waitForLock&lt;/span&gt;(waitNode, sessionTimeout);&lt;span class=&quot;co&quot;&gt;//等待锁&lt;/span&gt;
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (KeeperException e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(e);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(e);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String splitStr = &lt;span class=&quot;st&quot;&gt;&quot;_lock_&quot;&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(lockName.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(splitStr))
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;lockName can not contains &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;u000B&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;//创建临时子节点&lt;/span&gt;
            myZnode = zk.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(root + &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; + lockName + splitStr, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;], ZooDefs.&lt;span class=&quot;fu&quot;&gt;Ids&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;OPEN_ACL_UNSAFE&lt;/span&gt;,CreateMode.&lt;span class=&quot;fu&quot;&gt;EPHEMERAL_SEQUENTIAL&lt;/span&gt;);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myZnode + &lt;span class=&quot;st&quot;&gt;&quot; is created &quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;//取出所有子节点&lt;/span&gt;
            List&amp;lt;String&amp;gt; subNodes = zk.&lt;span class=&quot;fu&quot;&gt;getChildren&lt;/span&gt;(root, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;//取出所有lockName的锁&lt;/span&gt;
            List&amp;lt;String&amp;gt; lockObjNodes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (String node : subNodes) {
                String _node = node.&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(splitStr)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(_node.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(lockName)){
                    lockObjNodes.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
                }
            }
            Collections.&lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(lockObjNodes);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myZnode + &lt;span class=&quot;st&quot;&gt;&quot;==&quot;&lt;/span&gt; + lockObjNodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(myZnode.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(root+&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;+lockObjNodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;))){
                &lt;span class=&quot;co&quot;&gt;//如果是最小的节点,则表示取得锁&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;//如果不是最小的节点，找到比自己小1的节点&lt;/span&gt;
            String subMyZnode = myZnode.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(myZnode.&lt;span class=&quot;fu&quot;&gt;lastIndexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            waitNode = lockObjNodes.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Collections.&lt;span class=&quot;fu&quot;&gt;binarySearch&lt;/span&gt;(lockObjNodes, subMyZnode) - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (KeeperException e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(e);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(e);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; time, TimeUnit unit) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;()){
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;waitForLock&lt;/span&gt;(waitNode,time);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;waitForLock&lt;/span&gt;(String lower, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; waitTime) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException, KeeperException {
        Stat stat = zk.&lt;span class=&quot;fu&quot;&gt;exists&lt;/span&gt;(root + &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; + lower,&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(stat != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Thread &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; waiting for &quot;&lt;/span&gt; + root + &lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt; + lower);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latch&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; CountDownLatch(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latch&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;(waitTime, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;latch&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unlock &quot;&lt;/span&gt; + myZnode);
            zk.&lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(myZnode,-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            myZnode = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            zk.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (KeeperException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lockInterruptibly&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Condition &lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LockException &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; RuntimeException {
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = 1L;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(String e){
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(e);
        }
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LockException&lt;/span&gt;(Exception e){
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;优缺点-1&quot;&gt;优缺点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。还需要对 ZK的原理有所了解。&lt;/p&gt;
&lt;h3 id=&quot;基于-consul-做分布式锁&quot;&gt;基于 Consul 做分布式锁&lt;/h3&gt;
&lt;p&gt;DD 写过类似文章，其实主要利用 Consul 的 Key / Value 存储 API 中的 acquire 和 release 操作来实现。&lt;/p&gt;
&lt;p&gt;文章地址：&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;http://blog.didispace.com/spring-cloud-consul-lock-and-semphore/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用分布式锁的注意事项&quot;&gt;使用分布式锁的注意事项&lt;/h3&gt;
&lt;p&gt;1、注意分布式锁的开销&lt;/p&gt;
&lt;p&gt;2、注意加锁的粒度&lt;/p&gt;
&lt;p&gt;3、加锁的方式&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;无论你身处一个什么样的公司，最开始的工作可能都需要从最简单的做起。不要提阿里和腾讯的业务场景 qps 如何大，因为在这样的大场景中你未必能亲自参与项目，亲自参与项目未必能是核心的设计者，是核心的设计者未必能独自设计。希望大家能根据自己公司业务场景，选择适合自己项目的方案。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;http://www.hollischuang.com/archives/1716&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;http://www.spring4all.com/question/158&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;https://www.cnblogs.com/PurpleDream/p/5559352.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;http://www.cnblogs.com/PurpleDream/p/5573040.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/8947996.html&quot;&gt;https://www.cnblogs.com/suolu/p/6588902.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Apr 2018 14:59:00 +0000</pubDate>
<dc:creator>zhisheng_tian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhisheng/p/8947996.html</dc:identifier>
</item>
<item>
<title>Redis从入门到精通：初级篇 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/8890896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/8890896.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原文链接：http://www.cnblogs.com/xrq730/p/8890896.html，转载请注明出处，谢谢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis从入门到精通：初级篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平时陆陆续续看了不少Redis的文章了，工作中也一直在用Redis，感觉是时候对过往Redis的所学进行一次系统性的总结。《Redis从入门到精通》系列会分为初级、中级、高级三篇，从浅入深讲解Redis相关知识点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在本文中，我们将看到以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis简介&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis安装、启动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis登录授权&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis配置文件redis.conf中参数详细的一个解读&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis性能测试&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这些内容无关具体用法，作为一些初级的知识，系统地先认识一下Redis。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis是一款开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存也可持久化的日志型、Key-Value高性能数据库。Redis与其他Key-Value缓存产品相比有以下三个特点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持数据持久化，可以将内存中的数据保存在磁盘中，重启可再次加载使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持简单的Key-Value类型的数据，同时还提供List、Set、Zset、Hash等数据结构的存储&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持数据的备份，即Master-Slave模式的数据备份&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;同时，我们再看下Redis有什么优势：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;读速度为110000次/s，写速度为81000次/s，性能极高&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;具有丰富的数据类型，这个上面已经提过了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis所有操作都是原子的，意思是要么成功执行要么失败完全不执行，多个操作也支持事务&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;丰富的特性，比如Redis支持publish/subscribe、notify、key过期等&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis安装、启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这次写Redis系列的文章，LZ特意去阿里云上买了一个月的服务器，操作系统是Linux，因为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Redis项目本身不正式支持Windows系统&lt;/strong&gt;&lt;/span&gt;。不过微软开放技术小组开发和维护了Windows版本的Redis，下载地址为&lt;a href=&quot;https://github.com/MicrosoftArchive/redis/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/MicrosoftArchive/redis/releases&lt;/a&gt;，感兴趣的可以自己去试下，LZ在自己笔记本上安装启动过，没有问题，但就不细说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面说一下在Linux系统上安装并启动Redis的步骤（我的Redis安装在/data/component/redis目录下，每一步使用的命令标红加粗）：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;进入目录，&lt;span&gt;&lt;strong&gt;cd /data/component/redis&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;下载Redis，&lt;span&gt;&lt;strong&gt;wget http://download.redis.io/releases/redis-3.2.11.tar.gz&lt;/strong&gt;&lt;/span&gt;，可以看到LZ使用的Redis版本是3.2.11，在LZ写这篇文章的时候，Redis最新版本为4.0.9，地址为http://download.redis.io/releases/redis-4.0.9.tar.gz，感兴趣的朋友也可以用这个版本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解压下载下来的tar包，&lt;strong&gt;&lt;span&gt;tar -zxvf redis-3.2.11.tar.gz&lt;/span&gt;&lt;/strong&gt;，解压完毕的文件夹名称为redis-3.2.11&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进入redis-3.2.11，&lt;span&gt;&lt;strong&gt;cd redis-3.2.11&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于我们下载下来的是源文件，因此使用&lt;strong&gt;&lt;span&gt;make&lt;/span&gt;&lt;/strong&gt;命令对源文件进行一个构建，构建完毕我们会发现src目录下多出了redis-benchmark、redis-check-aof、redis-check-rdb、redis-cli、redis-sentinel、redis-server几个可执行文件，这几个可执行文件后面会说到&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于上述几个命令在/data/component/redis/redis-3.2.11/src目录下，为了更方便地使用这几个命令而不需要指定全路径，配置一下环境变量。这里我是以非root用户进行登录的，因此配置用户变量，先执行&lt;span&gt;&lt;strong&gt;cd&lt;/strong&gt;&lt;/span&gt;命令回到初始目录，再&lt;span&gt;&lt;strong&gt;vi ./.bash_profile&lt;/strong&gt;&lt;/span&gt;，在path这一行加入&lt;span&gt;&lt;strong&gt;PATH=$PATH:$HOME/.local/bin:$HOME/bin:/data/component/redis/redis-3.2.11/src&lt;/strong&gt;&lt;/span&gt;，使用&lt;span&gt;&lt;strong&gt;:wq&lt;/strong&gt;&lt;/span&gt;保存并退出&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使环境变量生效，执行&lt;span&gt;&lt;strong&gt;source ./.bash_profile&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用redis-server即可启动redis，&lt;strong&gt;&lt;span&gt;redis-server /data/component/redis/redis-3.2.11/redis.conf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;不过这个时候我们的启动稍微有点问题，不是后台启动的，即ctrl+c之后Redis就停了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180421154727734-2115827873.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;246&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这个问题，我们需要修改一下redis.conf，将Redis设置为以守护进程的方式进行启动，打开redis.conf，找到daemonize，将其设置为yes即可：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180421155129738-94768766.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;70&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候先关闭一下再启动，Redis就在后台自动运行了，关闭Redis有两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;redis-cli shutdown，这是种安全关闭redis的方式，&lt;span&gt;&lt;strong&gt;但这种写法只适用于没有配置密码的场景&lt;/strong&gt;&lt;/span&gt;，比较不安全，配置密码下一部分会讲&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;kill -9 pid，这种方式就是强制关闭，可能会造成数据未保存&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;重启后，我们可以使用&lt;span&gt;&lt;strong&gt;ps -ef | grep redis&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;netstat -ant | grep 6379&lt;/strong&gt;&lt;/span&gt;命令来验证Redis已经启动。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis登录授权&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面我们安装了Redis，但这种方式是非常不安全的，因为没有密码，这样任何连接上Redis服务器的用户都可以对Redis执行操作，所以这一部分我们来讲一下给Redis设置密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开redis.conf，找到&quot;requirepass&quot;部分，打开原本关闭的注释，替换一下自己想要的密码即可：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180421170345220-103534152.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;178&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重启Redis，授权登录有两种做法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;连接的时候直接指定密码，&lt;span&gt;&lt;strong&gt;redis-cli -h 127.0.0.1 -p 6379 -a 123456&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;连接后授权，&lt;strong&gt;&lt;span&gt;redis-cli -h 127.0.0.1 -p 6379&lt;/span&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;auth 123456&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在配置了密码的情况下，没有进行授权，那么对Redis发送的命令，将返回&quot;(error) NOAUTH Authentication required.&quot;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis配置文件redis.conf&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面两小节，设置使用守护线程启动、设置密码，都需要修改redis.conf，说明redis.conf是Redis核心的配置文件，本小节我们来看一下redis.conf中一些常用配置：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;75.083448275862&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;作用&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;默认&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;bind&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当配置了bind之后：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;只有bind指定的ip可以直接访问Redis,这样可以避免将Redis服务暴露于危险的网络环境中，防止一些不安全的人随随便便通过远程访问Redis&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果bind选项为空或0.0.0.0的话，那会接受所有来自于可用网络接口的连接&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;protected-mode&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;protected-mode是Redis3.2之后的新特性，用于加强Redis的安全管理，当满足以下两种情况时，protected-mode起作用：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;bind未设置，即接收所有来自网络的连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;密码未设置&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当满足以上两种情况且protected-mode=yes的时候，访问Redis将报错，即密码未设置的情况下，无密码访问Redis只能通过安装Redis的本机进行访问&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;port&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Redis访问端口，由于Redis是单线程模型，因此单机开多个Redis进程的时候会修改端口，不然一般使用大家比较熟悉的6379端口就可以了&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;6379&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.9530201342282&quot;&gt;&lt;td&gt;&lt;span&gt;tcp-backlog&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;半连接队列的大小，对半连接队列不熟的可以看我以前的文章&lt;a href=&quot;http://www.cnblogs.com/xrq730/p/6910719.html&quot; target=&quot;_blank&quot;&gt;TCP：三次握手、四次握手、backlog及其他&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;511&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;timeout&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;指定在一个client空闲多少秒之后就关闭它，0表示不管&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;tcp-keepalive&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;设置tcp协议的keepalive，从Redis的注释来看，这个参数有两个作用：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;发现死的连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从中间网络设备的角度看连接是否存活&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;300&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;daemonize&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;这个前面说过了，指定Redis是否以守护进程的方式启动&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;no&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;supervised&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;这个参数表示可以通过upstart和systemd管理Redis守护进程，这个具体和操作系统相关，资料也不是很多，就暂时不管了&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;no&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;pidfile&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当Redis以守护进程的方式运行的时候,Redis默认会把pid写到pidfile指定的文件中&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;/var/run/redis_6379.pid&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;loglevel&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;指定Redis的日志级别，Redis本身的日志级别有notice、verbose、notice、warning四种，按照文档的说法，这四种日志级别的区别是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;debug，非常多信息，适合开发/测试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;verbose，很多很少有用的信息（直译，读着拗口，从上下文理解应该是有用信息不多的意思），但并不像debug级别这么混乱&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;notice，适度的verbose级别的输出，很可能是生产环境中想要的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;warning，只记录非常重要/致命的信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;notice&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;logfile&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;配置log文件地址,默认打印在命令行终端的窗口上&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;databases&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;设置Redis数据库的数量，默认使用0号DB&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt; save&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;把Redis数据保存到磁盘上，这个是在RDB的时候用的，介绍RDB的时候专门说这个 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;save 900 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;save 300 10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;save 60 10000 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;&lt;span&gt; stop-writes-on-bgsave-error&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果Redis重启了，那么又可以重新开始接收数据了&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;rdbcompression &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是否在RBD的时候使用LZF压缩字符串，如果希望省点CPU，那就设为no，不过no的话数据集可能就比较大 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;yes &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; rdbchecksum&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是否校验RDB文件，在RDB文件中有一个checksum专门用于校验&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;yes &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt; dbfilename&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;dump的文件位置&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;dump.rdb &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt; dir&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Redis工作目录&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;./ &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt; slaveof&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;主从复制，使用slaveof让一个节点称为某个节点的副本，这个只需要在副本上配置&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 关闭&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;masterauth&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;如果主机使用了requirepass配置进行密码保护，使用这个配置告诉副本连接的时候需要鉴权&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;slave-serve-stale-data&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当一个Slave与Master失去联系或者复制正在进行中，Slave可能会有两种表现：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果为yes，Slave仍然会应答客户端请求，但返回的数据可能是过时的或者数据可能是空的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果为no，在执行除了INFO、SLAVEOF两个命令之外，都会应答&quot;SYNC with master in progres&quot;错误&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; slave-read-only&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt; slave-priority&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;从站优先级是可以从redis的INFO命令输出中查到的一个整数。当主站不能正常工作时，redis sentinel使用它来选择一个从站并将它提升为主站。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;低优先级的从站被认为更适合于提升，因此如果有三个从站优先级分别是10， 100， 25，sentinel会选择优先级为10的从站，因为它的优先级最低。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;然而优先级值为0的从站不能执行主站的角色，因此优先级为0的从站永远不会被redis sentinel提升。 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;100 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; requirepass&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;设置客户端认证密码&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt; rename-command&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;命令重命名，对于一些危险命令例如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;flushdb（清空数据库）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flushall（清空所有记录）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;config（客户端连接后可配置服务器）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;keys（客户端连接后可查看所有存在的键）                   &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;rename-command FLUSHALL &quot;&quot;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;也可以保留命令但是不能轻易使用，重命名这个命令即可：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;rename-command FLUSHALL abcdefg&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;maxclients &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;设置同时连接的最大客户端数量，一旦达到了限制，Redis会关闭所有的新连接并发送一个&quot;max number of clients reached&quot;的错误&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，默认10000 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt; maxmemory&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;不要使用超过指定数量的内存，一旦达到了，Redis会尝试使用驱逐策略来移除键 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt; maxmemory-policy&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;当达到了maxmemory之后Redis如何移除数据，有以下的一些策略：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;volatile-lru，使用LRU算法，移除范围为设置了失效时间的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;allkeys-lru，根据LRU算法，移除范围为所有的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;volatile-random，使用随机算法，移除范围为设置了失效时间的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;allkeys-random，使用随机算法，移除范围为所有的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;volatile-ttl，移除最近过期的数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;noeviction，不过期，当写操作的时候返回错误&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意，当写操作且Redis发现没有合适的数据可以移除的时候，将会报错&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，noeviction&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;appendonly &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是否开启AOF，关于AOF后面再说 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; no&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;appendfilename&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AOF文件名称&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;span&gt;appendfsync &lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;操作系统实际写数据到磁盘的频率，有以下几个选项：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;always，每次有写操作都进行同步，慢，但是最安全&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;everysec，对写操作进行累积，每秒同步一次，是一种折衷方案&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;no，当操作系统flush缓存的时候同步，性能更好但是会有数据丢失的风险&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当不确定是使用哪种的时候，官方推荐使用everysec，它是速度与数据安全之间的一种折衷方案&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;everysec &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt;&lt;span&gt; no-appendfsync-on-rewrite&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;aof持久化机制有一个致命的问题，随着时间推移，aof文件会膨胀，当server重启时严重影响数据库还原时间，因此系统需要定期重写aof文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重写aof的机制为bgrewriteaof（另外一种被废弃了，就不说了），即在一个子进程中重写从而不阻塞主进程对其他命令的处理，但是这依然有个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bgrewriteaof和主进程写aof，都会操作磁盘，而bgrewriteaof往往涉及大量磁盘操作，这样就会让主进程写aof文件阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对上述问题，可以使用此时可以使用no-appendfsync-on-rewrite参数做一个选择：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;no，最安全，不丢失数据，但是需要忍受阻塞&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;yes，数据写入缓冲区，不造成阻塞，但是如果此时redis挂掉就会丢失数据，在Linux操作系统默认设置下，最坏场景下会丢失30秒数据&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; no&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; auto-aof-rewrite-percentage&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;本次aof文件超过上次aof文件该值的百分比时，才会触发rewrite &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;100 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt; auto-aof-rewrite-min-size&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;aof文件最小值，只有到达这个值才会触发rewrite，即rewrite由auto-aof-rewrite-percentage+auto-aof-rewrite-min-size共同保证&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 64mb&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; aof-load-truncated&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;redis在以aof方式恢复数据时，对最后一条可能出问题的指令的处理方式： &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;yes，log并继续&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;no，直接恢复失败&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; slowlog-log-slower-than&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Redis慢查询的最低条件，单位微妙，即查询时间&amp;gt;这个值的会被记录 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 10000&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; slowlog-max-len&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Redis存储的慢查询最大条数，超过该值之后会将最早的slowlog剔除&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;128 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;lua-time-limit&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;一个lua脚本执行的最大时间，单位为ms&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;5000&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;cluster-enabled&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;正常来说Redis实例是无法称为集群的一部分的，只有以集群方式启动的节点才可以。为了让Redis以集群方式启动，就需要此参数。&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;cluster-config-file&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;每个集群节点应该有自己的配置文件，这个文件是不应该手动修改的，它只能被Redis节点创建且更新，每个Redis集群节点需要不同的集群配置文件&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，nodes-6379.conf &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; cluster-node-timeout&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;集群中一个节点向其他节点发送ping命令时，必须收到回执的毫秒数&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 关闭，15000&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;&lt;span&gt;cluster-slave-validity-factor&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;如果该项设置为0，不管Slave节点和Master节点间失联多久都会一直尝试failover。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如timeout为5，该值为10，那么Master与Slave之间失联50秒，Slave不会去failover它的Master&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，10 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;span&gt;cluster-migration-barrier&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;当一个Master拥有多少个好的Slave时就要割让一个Slave出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如设置为2，表示当一个Master拥有2个可用的Slave时，它的一个Slave会尝试迁移&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，1&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;&lt;span&gt;cluster-require-full-coverage &lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;有节点宕机导致16384个Slot全部被覆盖，整个集群是否停止服务，这个值一定要改为no&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;关闭，yes&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;以上把redis.conf里面几乎所有的配置都写了一遍（除了ADVANCED CONFIG部分），感觉其他博客很少有看到比我这个还全的了^_^，给大家作为参考吧。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis性能测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前说过Redis在make之后有一个redis-benchmark，这个就是Redis提供用于做性能测试的，它可以用来模拟N个客户端同时发出M个请求。首先看一下redis-benchmark自带的一些参数：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;默认值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;服务器名称&lt;/td&gt;
&lt;td&gt;127.0.0.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;服务器端口&lt;/td&gt;
&lt;td&gt;6379&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;服务器Socket&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;并行连接数&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;请求书&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;SET/GET值的字节大小&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;1表示keep alive，0表示重连&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;-r&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;SET/GET/INC使用随机Key而不是常量，在形式上key样子为mykey_ran:000000012456&lt;/p&gt;
&lt;p&gt;-r的值决定了value的最大值&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;使用管道请求&lt;/td&gt;
&lt;td&gt;1，即不使用管道&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-q&lt;/td&gt;
&lt;td&gt;安静模式，只显示query/sec值&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;--csv&lt;/td&gt;
&lt;td&gt;使用csv格式输出&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;循环，无限运行测试&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;只运行使用逗号分割的命令的测试&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-I&lt;/td&gt;
&lt;td&gt;空闲模式，只打开N个空闲线程并且等待&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;抛开配置只谈性能的都是耍流氓，说一下我买的阿里云服务器的配置：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单核CPU，CPU类型为Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内存4G&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;带宽1M&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;操作系统为Centos7&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;首先我们运行最简单的&lt;span&gt;&lt;strong&gt;redis-benchmark -q&lt;/strong&gt;&lt;/span&gt;，运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180425003135018-1232173694.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;283&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印了每个命令的QPS，看到基本都在读写速度基本都在100000次/s以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着换一个命令进行测试，因为实际场景中我们的Key和Value一定是非常丰富的，不可能是单一的Key和单一的Value，因此接着去的测试使用-r模拟value到100000且将运行次数提高到1000000次，具体命令为&lt;span&gt;&lt;strong&gt;redis-benchmark -q -r 100000 -n 1000000&lt;/strong&gt;&lt;/span&gt;，运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180425004201057-1783973661.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;265&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到整个读写效率基本都在110000次/s以上，证明了读写的高效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单对于Redis的性能测试就到这儿，这个测试结果看起来很美，但是实际应用却完全不是，主要体现在以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网络与带宽，这是现实中最主要的影响因素，上面的测试还是太过于低级，现实使用中Redis里面存一个用户信息、订单信息，几KB的大小，100000qps根本不可能大家可以算算需要多大的带宽，粗粗算一下超过1个G吧，很多线上服务的带宽根本达不到1G/s，所以Redis的吞吐量最先会被网络带宽限制住&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis由于是单线程模型，因此CPU性能非常重要，尤其是大缓存的快速CPU，我这里的CPU上面写过了，Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz总体还是可以的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端连接数，上面使用了默认的连接数50，实际上10W、20W甚至100W+呢？不过得益于epoll模型，整个下降的可以接受，下面有一张连接数和qps的关系，我也是网上找来的&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201804/801753-20180425010240281-1666145256.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;256&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RDB和AOF可能会对Redis造成的阻塞并未考虑进去&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;尽可能使用大内存，避免SWAP&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;无论如何，总而言之，Redis整个性能是非常不错的，个人认为如果要选一款存储系统，那么Redis应当是首选。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Apr 2018 14:23:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/8890896.html</dc:identifier>
</item>
<item>
<title>mybatis源码解读(一)——初始化环境 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8947553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8947553.html</guid>
<description>&lt;p&gt;　　本系列博客将对mybatis的源码进行解读，关于mybatis的使用教程，可以查看我前面写的博客——&lt;a href=&quot;http://www.cnblogs.com/ysocean/tag/MyBatis%E8%AF%A6%E8%A7%A3%E7%B3%BB%E5%88%97/&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　为了便于后面的讲解，我们这里首先构造一个统一环境。也可以参考&lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot; target=&quot;_blank&quot;&gt;mybatis官网&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;1、数据库建表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(32) NOT NULL COMMENT '用户id'&lt;span&gt;,
  `user_name` varchar(&lt;/span&gt;64) &lt;span&gt;default&lt;/span&gt; NULL COMMENT '用户姓名'&lt;span&gt;,
  `user_age` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(3) &lt;span&gt;default&lt;/span&gt; NULL COMMENT '用户年龄'&lt;span&gt;,
  PRIMARY KEY  (`user_id`)
) ENGINE&lt;/span&gt;=InnoDB DEFAULT CHARSET=utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、项目的目录结构&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201804/1120165-20180425215420360-148957837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相关配置的版本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
　　JDK:1.8

　　maven:3.3.9

　　mybatis:3.4.3
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、pom文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b44c5929-80ae-4f73-b677-b73cc6279ad2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b44c5929-80ae-4f73-b677-b73cc6279ad2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b44c5929-80ae-4f73-b677-b73cc6279ad2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b44c5929-80ae-4f73-b677-b73cc6279ad2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b44c5929-80ae-4f73-b677-b73cc6279ad2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.ys&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;MybatisDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.4.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;**/*.properties&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;**/*.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filtering&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filtering&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/resources&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;**/*.properties&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;**/*.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;includes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filtering&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filtering&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　分别在pom文件中添加mybatis包，mysql数据库连接包，Junit测试包。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意：由于我使用的编译器是 IDEA，这里必须在pom文件中配置对resource资源目录下的xml 文件的访问，否则，IEDA会读取不到resource目录下的配置文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4、资源文件配置&lt;/h3&gt;
&lt;p&gt;　　①、&lt;strong&gt;jdbc.properties&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bf80ebb5-5fa7-4cb9-9cb6-e25b5bdf40fb')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_bf80ebb5-5fa7-4cb9-9cb6-e25b5bdf40fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bf80ebb5-5fa7-4cb9-9cb6-e25b5bdf40fb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bf80ebb5-5fa7-4cb9-9cb6-e25b5bdf40fb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bf80ebb5-5fa7-4cb9-9cb6-e25b5bdf40fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;jdbc.driver=com.mysql.jdbc.Driver
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; jdbc.url=jdbc:mysql://localhost:3306/mybatisTest?useUnicode=true&lt;span&gt;&amp;amp;characterEncoding&lt;/span&gt;&lt;span&gt;=utf-8
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;jdbc.username=root
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; jdbc.password=root
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;②、mybatsi-configuration.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ce76a734-41f3-43b9-87d3-7f1770d85e73')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce76a734-41f3-43b9-87d3-7f1770d85e73&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce76a734-41f3-43b9-87d3-7f1770d85e73&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ce76a734-41f3-43b9-87d3-7f1770d85e73',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce76a734-41f3-43b9-87d3-7f1770d85e73&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 加载数据库属性文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;jdbc.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 可以配置多个运行环境，但是每个 SqlSessionFactory 实例只能选择一个运行环境 一、development:开发模式 二、work：工作模式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;id属性必须和上面的default一样 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.driver}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.url}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;com/ys/mapper/userMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;5、pojo 类&lt;/h3&gt;
&lt;p&gt;　　前面我们创建了 user 表，这里创建其实体类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('556a36d2-dd0b-4dad-ba1b-7af902235220')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_556a36d2-dd0b-4dad-ba1b-7af902235220&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_556a36d2-dd0b-4dad-ba1b-7af902235220&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('556a36d2-dd0b-4dad-ba1b-7af902235220',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_556a36d2-dd0b-4dad-ba1b-7af902235220&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(Integer id, String name, Integer age) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     
&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;注意：根据阿里巴巴的最新编码规范，实体类中的属性不要写基本数据类型，必须使用包装类型。比如 int 类型的 id，我们应该写成其包装类 Integer 类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　原因：比如显示成交总额涨跌情况，即正负 x %， x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6、mapper 文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b4aa8311-a2cb-4c49-bced-dc6adae3d2eb')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_b4aa8311-a2cb-4c49-bced-dc6adae3d2eb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b4aa8311-a2cb-4c49-bced-dc6adae3d2eb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b4aa8311-a2cb-4c49-bced-dc6adae3d2eb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b4aa8311-a2cb-4c49-bced-dc6adae3d2eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!&lt;span&gt;DOCTYPE mapper
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&lt;span&gt; 4&lt;/span&gt;   &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;mapper namespace=&quot;com.ys.po.userMapper&quot;&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ys.po.User&quot;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;id column=&quot;user_id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;&amp;gt;&amp;lt;/id&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;result column=&quot;user_name&quot; property=&quot;name&quot; jdbcType=&quot;VARCHAR&quot; /&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;result column=&quot;user_age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/resultMap&amp;gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &amp;lt;sql id=&quot;Base_Column_List&quot;&amp;gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        user_id, user_name, user_age
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &amp;lt;/sql&amp;gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &amp;lt;!-- 根据id查询 user 表数据 --&amp;gt;
&lt;span&gt;17&lt;/span&gt;     &amp;lt;select id=&quot;selectUserById&quot;  resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot;&amp;gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        select 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;
&lt;span&gt;20&lt;/span&gt;             from user where user_id = #{id,jdbcType=&lt;span&gt;INTEGER}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &amp;lt;/select&amp;gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &amp;lt;!-- 查询 user 表的所有数据 --&amp;gt;
&lt;span&gt;25&lt;/span&gt;     &amp;lt;select id=&quot;selectUserAll&quot;  resultMap=&quot;BaseResultMap&quot;&amp;gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        select 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            from user
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &amp;lt;/select&amp;gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &amp;lt;!-- 向 user 表插入一条数据 --&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.ys.po.User&quot; &amp;gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        insert into
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         user(&amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         value(#{id,jdbcType=INTEGER},#{name,jdbcType=VARCHAR},#{age,jdbcType=&lt;span&gt;INTEGER})
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &amp;lt;/insert&amp;gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &amp;lt;!-- 根据 id 更新 user 表的数据 --&amp;gt;
&lt;span&gt;40&lt;/span&gt;     &amp;lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&amp;gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        update user set
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             user_name=#{name,jdbcType=VARCHAR} where user_id=#{id,jdbcType=&lt;span&gt;INTEGER}
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &amp;lt;/update&amp;gt;
&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &amp;lt;!-- 根据 id 删除 user 表的数据 --&amp;gt;
&lt;span&gt;46&lt;/span&gt;     &amp;lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;java.lang.Integer&quot;&amp;gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        delete from 
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             user where user_id=#{id,jdbcType=&lt;span&gt;INTEGER}
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &amp;lt;/delete&amp;gt;
&lt;span&gt;50&lt;/span&gt; &amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;7、测试类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cfbe3d10-9af4-4810-8320-0775cb651e00')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_cfbe3d10-9af4-4810-8320-0775cb651e00&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cfbe3d10-9af4-4810-8320-0775cb651e00&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cfbe3d10-9af4-4810-8320-0775cb651e00',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cfbe3d10-9af4-4810-8320-0775cb651e00&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ys.po.User;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MybatisTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NAME_SPACE = &quot;com.ys.po.userMapper&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SqlSessionFactory sqlSessionFactory;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         InputStream inputStream = MybatisTest.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResourceAsStream(&quot;mybatis-configuration.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         sqlSessionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * 查询单个记录
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectOne(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         User user = session.selectOne(NAME_SPACE+&quot;.selectUserById&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        session.close();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 查询多个记录
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectList(){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         List&amp;lt;User&amp;gt; listUser = session.selectList(NAME_SPACE+&quot;.selectUserAll&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(listUser != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            System.out.println(listUser.size());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        session.close();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;     * 插入一条记录
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsert(){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt; User(2,&quot;zhangsan&quot;,22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         session.insert(NAME_SPACE+&quot;.insertUser&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        session.close();        
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;     * 更新一条记录
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdate(){
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt; User(2,&quot;lisi&quot;,22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         session.update(NAME_SPACE+&quot;.updateUserById&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        session.close();        
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     
&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;     * 删除一条记录
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDelete(){
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         session.delete(NAME_SPACE+&quot;.deleteUserById&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        session.close();        
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;8、测试结果&lt;/h3&gt;
&lt;p&gt;　　出现5条绿色的横杆，然后去数据库查看相应的结果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201804/1120165-20180425221011561-797219500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;9、总结&lt;/h3&gt;
&lt;p&gt;　　这个demo没什么好说的，不懂的看我前面的新手使用教程即可，这是最原始的mybatis开发方式。后面会通过这个例子深入源码分析。&lt;/p&gt;

</description>
<pubDate>Wed, 25 Apr 2018 14:16:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8947553.html</dc:identifier>
</item>
<item>
<title>利用Runtime实现简单的字典转模型 - Scott_Mr</title>
<link>http://www.cnblogs.com/scott-mr/p/8947613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scott-mr/p/8947613.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们都知道，开发中会有这么一个过程，就是将服务器返回的数据转换成我们自己定义的模型对象。当然服务器返回的数据结构有&lt;code&gt;xml&lt;/code&gt;类型的，也有&lt;code&gt;json&lt;/code&gt;类型的。本文只讨论&lt;code&gt;json&lt;/code&gt;格式的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家在项目中一般是怎么样将服务器返回的&lt;code&gt;json&lt;/code&gt;转化成自己定义的模型类呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我在项目中一般都是使用的&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot;&gt;MJExtension&lt;/a&gt;。&lt;br/&gt;本文讲解的也基本就是解读&lt;code&gt;MJExtension&lt;/code&gt;中的部分源码。&lt;br/&gt;好了，废话不多说，直接上代码，let's go&lt;/p&gt;
&lt;h2 id=&quot;简单字典转模型&quot;&gt;简单字典转模型&lt;/h2&gt;
&lt;p&gt;首先，从最简单的字典开始，例如我们需要将如下的字典转化成自定义的模型。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;     NSDictionary *dict = @{@&quot;name&quot;:@&quot;Scott&quot;,
                            @&quot;icon&quot; : @&quot;lufy.png&quot;,
                            @&quot;age&quot; : @&quot;20&quot;,
                            @&quot;height&quot; : @1.75,
                            @&quot;money&quot; : @&quot;100.9&quot;,
                            @&quot;sex&quot; : @(SexMale),
                            @&quot;gay&quot; : @&quot;ture&quot;,
                            };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义一个&lt;code&gt;ScottUser&lt;/code&gt;类，并且定义好属性名如下：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &amp;lt;Foundation/Foundation.h&amp;gt;
    typedef NS_ENUM(NSInteger, Sex) {
        SexMale,    // 男
        SexFemale   // 女
    };
    @interface ScottUser : NSObject
    /**  姓名 */
    @property (nonatomic, copy) NSString *name;
    /**  头像 */
    @property (nonatomic, copy) NSString *icon;
    /**  年龄 */
    @property (nonatomic, assign) unsigned int age;
    /**  身高 */
    @property (nonatomic, strong) NSNumber *height;
    /**  财富 */
    @property (nonatomic, copy) NSString *money;
    /**  性别 */
    @property (nonatomic, assign) Sex sex;
    /**  是否同性 */
    @property (nonatomic, assign, getter=isGay) BOOL gay;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，我们下一步的目标就是拿到字典里面的值(&lt;code&gt;value&lt;/code&gt;)对&lt;code&gt;ScottUser&lt;/code&gt;模型属性进行赋值，模型的属性名对应着字典里面的&lt;code&gt;key&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最直接的方法就是：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    ScottUser *user = [[ScottUser alloc] init];
    user.name = dict[@&quot;name&quot;];
    user.icon = dict[@&quot;icon&quot;];
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，对于每一次的数据转模型，你都要这样去写大量的重复代码，毫无意义。&lt;br/&gt;当然我们利用&lt;code&gt;setValuesForKeysWithDictionary:(NSDictionary *)dict&lt;/code&gt;进行&lt;code&gt;kvc&lt;/code&gt;赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVC赋值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;不需要去手动一个一个属性赋值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;当自定义的属性和字典中的key不一样的时候，会报错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;重写&lt;code&gt;- (void)setValue:(id)value forUndefinedKey:(NSString *)key&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以通过写一个框架自动帮我们实现字典转模型，大致思路就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;遍历模型中的&lt;code&gt;属性&lt;/code&gt;，然后拿到&lt;code&gt;属性名&lt;/code&gt;作为&lt;code&gt;键值&lt;/code&gt;去字典中寻找&lt;code&gt;值&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;值&lt;/code&gt;后，根据模型的&lt;code&gt;属性类型&lt;/code&gt;将&lt;code&gt;值&lt;/code&gt;转化成正确的&lt;code&gt;类型&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;给&lt;code&gt;属性名&lt;/code&gt;赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;遍历模型中的属性拿到属性名作为键值去字典中寻找值&quot;&gt;遍历模型中的&lt;code&gt;属性&lt;/code&gt;，拿到&lt;code&gt;属性名&lt;/code&gt;作为&lt;code&gt;键值&lt;/code&gt;去字典中寻找&lt;code&gt;值&lt;/code&gt;。&lt;/h3&gt;
&lt;p&gt;方法伪代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[模型类 遍历属性的方法];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便使用，创建一个叫&lt;code&gt;NSObject+ScottProperty&lt;/code&gt;的分类，写一个获取所有属性的方法。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &amp;lt;Foundation/Foundation.h&amp;gt;
    @interface NSObject (ScottProperty)
    + (NSArray *)properties;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们在看不到一个类的&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;文件的前提下，有什么办法可以获取它所有的实例变量呢？&lt;/p&gt;
&lt;p&gt;答案是通过&lt;code&gt;Runtime&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &quot;NSObject+ScottProperty.h&quot;
    #import &amp;lt;objc/runtime.h&amp;gt;
    @implementation NSObject (ScottProperty)
    + (NSArray *)properties {
        NSMutableArray *propertiesArr = [NSMutableArray array];
        unsigned int outCount = 0;
        objc_property_t *properties = class_copyPropertyList(self, &amp;amp;outCount);
        for (int i=0; i&amp;lt;outCount; i++) {
            objc_property_t property = properties[i];
            [propertiesArr addObject:propertyObj];
            char *name = property_getName(property);
            char *att = property_getAttributes(property);
            NSLog(@&quot;name:%s-----att:%s&quot;,name,att);
        }
        return propertiesArr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在外部调用&lt;code&gt;+ (NSArray *)properties&lt;/code&gt;方法能够打印出一个类的所有属性，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NSArray *arr = [ScottUser properties];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，能够看到控制台的输出：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension1.png&quot; alt=&quot;图1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从输出中可以看到通过&lt;code&gt;property_getName()&lt;/code&gt;获取每一个&lt;code&gt;objc_property_t&lt;/code&gt;的&lt;code&gt;name&lt;/code&gt;表示成员属性的名字，通过&lt;code&gt;property_getAttributes()&lt;/code&gt;获取每一个&lt;code&gt;objc_property_t&lt;/code&gt;的&lt;code&gt;attributes&lt;/code&gt;表示成员属性中的一些特性(如是什么类，原子性还是非原子性，是strong还是weak还是copy,生成的成员变量名等信息...)&lt;/p&gt;
&lt;p&gt;从苹果的&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html&quot;&gt;官方文档(Objective-C Runtime Programming Guide)&lt;/a&gt;可以得知，&lt;code&gt;attributes&lt;/code&gt;是一个类型编码字符串，这个字符串以&lt;code&gt;T&lt;/code&gt;作为开始，接上&lt;code&gt;@encode&lt;/code&gt;类型编码和一个逗号，以&lt;code&gt;V&lt;/code&gt;接上实例变量名作为结尾，在他们之间是一些其他信息，以逗号分隔，具体内容可以查看官方文档中详细的表格。&lt;/p&gt;
&lt;p&gt;在实际赋值过程中，我们并不关心该属性的内存管理、生成的成员变量名、或者其他什么信息，在&lt;code&gt;attributes&lt;/code&gt;中，只需要知道它所属的&lt;code&gt;类&lt;/code&gt;或者知道什么&lt;code&gt;基本数据类型&lt;/code&gt;,即&lt;code&gt;T&lt;/code&gt;至&lt;code&gt;第一个逗号之前&lt;/code&gt;中间的内容，如果是&lt;code&gt;类&lt;/code&gt;的话还需要将&lt;code&gt;@&lt;/code&gt;和&lt;code&gt;&quot;&quot;&lt;/code&gt;去掉。&lt;/p&gt;
&lt;p&gt;实际上，&lt;code&gt;Runtime&lt;/code&gt;已经给我们提供获取属性名和属性特性的函数了，也就是通过&lt;code&gt;property_getName()&lt;/code&gt;和&lt;code&gt;property_getAttributes()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这时候我们就可以获取到属性名和属性对应的属性特性了。&lt;/p&gt;
&lt;h3 id=&quot;找到值后根据属性类型将值转化成正确的类型&quot;&gt;找到&lt;code&gt;值&lt;/code&gt;后，根据&lt;code&gt;属性类型&lt;/code&gt;将&lt;code&gt;值&lt;/code&gt;转化成正确的&lt;code&gt;类型&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;现在已经完成了第一步，并且拿到了&lt;code&gt;属性名&lt;/code&gt;,但是数据类型还需要我们进一步截取，截取方法如下：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    for (int i=0; i&amp;lt;outCount; i++) {
        objc_property_t property = properties[i];
        // 为了以后方便使用，将C字符串转化成OC对象
    //    char *name = property_getName(property);
        NSString *name = @(property_getName(property));
    //    char *att = property_getAttributes(property);
        NSString *att = @(property_getAttributes(property));
        NSUInteger loc = 1;
        NSUInteger len = [att rangeOfString:@&quot;,&quot;].location - loc;
        NSString *type = [att substringWithRange:NSMakeRange(loc, len)];
        NSLog(@&quot;%@&quot;,type);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台结果显示，我们能够截取到其中的类型了：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension2.png&quot; alt=&quot;图2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回归到我们拿到这些&lt;code&gt;属性类型&lt;/code&gt;的初衷，是为了用字典中的&lt;code&gt;值的类型&lt;/code&gt;与模型中&lt;code&gt;属性的类型&lt;/code&gt;进行对比，想要对比，需要拿到&lt;code&gt;属性的类型&lt;/code&gt;,因此需要将这些编码转换成一个&lt;strong&gt;表示类的类&lt;/strong&gt;，创建一个类用来包装类型。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &amp;lt;Foundation/Foundation.h&amp;gt;
    @interface ScottPropertyType : NSObject
    /**  是否为id类型 */
    @property (nonatomic, readonly, getter=isIdType) BOOL idType;
    /**  是否为基本数据类型(int、float等) */
    @property (nonatomic, readonly, getter=isNumberType) BOOL numberType;
    /**  是否为bool类型 */
    @property (nonatomic, readonly, getter=isBoolType) BOOL boolType;
    /**  对象类型(如果是基本数据类型，此值为nil) */
    @property (nonatomic, readonly) Class typeClass;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OC对象可以通过&lt;code&gt;Class&lt;/code&gt;来表示类型，而基本数据类型只能用布尔来标识。&lt;/p&gt;
&lt;p&gt;把这些名字和类型遍历出来，肯定是为了以后有用，所以需要把它们存起来，由于它们是一个&quot;整体&quot;,所以还是设计一个类将他们包装起来比较好，创建一个包装成员属性的类--&lt;code&gt;ScottProperty&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &amp;lt;Foundation/Foundation.h&amp;gt;
    @class ScottPropertyType;
    @interface ScottProperty : NSObject
    /**  属性名 */
    @property (nonatomic, readonly) NSString *name;
    /**  成员属性的类型 */
    @property (nonatomic, readonly) ScottPropertyType *type;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，代码就可以进行重构了，将属于不同类的功能封装到对应的类上，让&lt;code&gt;ScottProperty&lt;/code&gt;提供一个类方法用于返回一个将&lt;code&gt;objc_property_t&lt;/code&gt;进行包装的类。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;     for (int i=0; i&amp;lt;outCount; i++) {
            objc_property_t property = properties[i];
            ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];
            [propertiesArr addObject:propertyObj];
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;propertyWithProperty:&lt;/code&gt;方法实现如下：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    @implementation ScottProperty
    + (instancetype)propertyWithProperty:(objc_property_t)property {
        return [[ScottProperty alloc] initWithProperty:property];
    }
    - (instancetype)initWithProperty:(objc_property_t)property {
        if (self = [super init]) {
            _name = @(property_getName(property));
            _type = [ScottPropertyType propertiesWithAttributeString:@(property_getAttributes(property))];
        }
        return self;
    }
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ScottPropertyType&lt;/code&gt;也提供类方法用于包装类型：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &quot;ScottPropertyType.h&quot;
    @implementation ScottPropertyType
    + (instancetype)propertiesWithAttributeString:(NSString *)att {
        return [[ScottPropertyType alloc] initWithTypeString:att];
    }
    - (instancetype)initWithTypeString:(NSString *)typeString {   
        if (self = [super init]) {
            NSUInteger loc = 1;
            NSUInteger len = [typeString rangeOfString:@&quot;,&quot;].location - loc;
            NSString *typeCode = [typeString substringWithRange:NSMakeRange(loc, len)];
            NSLog(@&quot;%@&quot;,typeCode);
        }
        return self;
    }
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重构完成之后，结构显得更加清晰，更加有利于接下来的工作，下面继续完成&lt;code&gt;typeCode&lt;/code&gt;的提取。&lt;br/&gt;运行重构之后的代码，可以看到和重构之前是一样的：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension3.png&quot; alt=&quot;图3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面提到的这些类型，是类型编码，在苹果文档中告诉我们编码对应的类型：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension4.png&quot; alt=&quot;图4&quot;/&gt;&lt;br/&gt;根据这个对应关系的图表，我们将常用的几个编码定义成常量字符串或者宏表示它所对应的类型，利于编码和阅读：&lt;br/&gt;在&lt;code&gt;ScottPropertyType&lt;/code&gt;类定义以下属性类型：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    /**
     *  成员变量类型（属性类型）
     */
    NSString *const ScottPropertyTypeInt = @&quot;i&quot;;
    NSString *const ScottPropertyTypeShort = @&quot;s&quot;;
    NSString *const ScottPropertyTypeFloat = @&quot;f&quot;;
    NSString *const ScottPropertyTypeDouble = @&quot;d&quot;;
    NSString *const ScottPropertyTypeLong = @&quot;q&quot;;
    NSString *const ScottPropertyTypeChar = @&quot;c&quot;;
    NSString *const ScottPropertyTypeBOOL1 = @&quot;c&quot;;
    NSString *const ScottPropertyTypeBOOL2 = @&quot;b&quot;;
    NSString *const ScottPropertyTypePointer = @&quot;*&quot;;
    NSString *const ScottPropertyTypeIvar = @&quot;^{objc_ivar=}&quot;;
    NSString *const ScottPropertyTypeMethod = @&quot;^{objc_method=}&quot;;
    NSString *const ScottPropertyTypeBlock = @&quot;@?&quot;;
    NSString *const ScottPropertyTypeClass = @&quot;#&quot;;
    NSString *const ScottPropertyTypeSEL = @&quot;:&quot;;
    NSString *const ScottPropertyTypeId = @&quot;@&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并写一个方法用于提取每个属性的类型：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    - (instancetype)initWithTypeString:(NSString *)typeString {
        if (self = [super init]) {
            NSUInteger loc = 1;
            NSUInteger len = [typeString rangeOfString:@&quot;,&quot;].location - loc;
            NSString *typeCode = [typeString substringWithRange:NSMakeRange(loc, len)];
            [self getTypeCode:typeCode];
        }
        return self;
    }
    - (void)getTypeCode:(NSString *)code {
        if ([code isEqualToString:ScottPropertyTypeId]) {
            _idType = YES;
        }else if (code.length &amp;gt; 3 &amp;amp;&amp;amp; [code hasPrefix:@&quot;@\&quot;&quot;]){
            // 去掉@&quot;和&quot;，截取中间的类型名称
            code = [code substringWithRange:NSMakeRange(2, code.length - 3)];
            _typeClass = NSClassFromString(code);
            _numberType = (_typeClass == [NSNumber class] || [_typeClass isSubclassOfClass:[NSNumber class]]);
        }
        // 是否为数字类型
        NSString *lowerCode = code.lowercaseString;
        NSArray *numberTypes = @[ScottPropertyTypeInt,
                                 ScottPropertyTypeShort,
                                 ScottPropertyTypeFloat,
                                 ScottPropertyTypeDouble,
                                 ScottPropertyTypeLong,
                                 ScottPropertyTypeChar,
                                 ScottPropertyTypeBOOL1,
                                 ScottPropertyTypeBOOL2];
        if ([numberTypes containsObject:lowerCode]) {
            _numberType = YES;
            if ([lowerCode isEqualToString:ScottPropertyTypeBOOL1] || [lowerCode isEqualToString:ScottPropertyTypeBOOL2]) {
                _boolType = YES;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们一个&lt;code&gt;ScottProperty&lt;/code&gt;的骨架大致就搭好了。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;NSObject+ScottProperty&lt;/code&gt;分类中遍历属性的时候，打印属性名和属性类型看看：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    for (int i=0; i&amp;lt;outCount; i++) {
            objc_property_t property = properties[i];
            ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];
            [propertiesArr addObject:propertyObj];
            NSLog(@&quot;name:%@--type:%@&quot;,propertyObj.name,propertyObj.type.typeClass);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension5.png&quot; alt=&quot;图5&quot;/&gt;&lt;br/&gt;从图中可以看出，属于基本类型的属性打印出来的类型是&lt;code&gt;null&lt;/code&gt;，其他的都能正确打印出对应类型。&lt;/p&gt;
&lt;p&gt;当我们想要使用字典转模型功能的时候，提供一个类方法方便转换，该方法放在&lt;code&gt;NSObject+ScottKeyValue&lt;/code&gt;分类中，该分类负责字典转模型的方法实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (instancetype)objectWithKeyValues:(id)keyValues {
        if (!keyValues) return nil;
        return [[[self alloc] init] setKeyValues:keyValues];
    }
    - (instancetype)setKeyValues:(id)keyValues {
        NSArray *propertiesArray = [self.class properties];
        for (ScottProperty *property in propertiesArray) {
            ScottPropertyType *type = property.type;
            Class typeClass = type.typeClass;
            if (type.isBoolType) {
                NSLog(@&quot;Bool&quot;);
            }else if (type.isIdType){
                NSLog(@&quot;ID&quot;);
            }else if (type.isNumberType){
                NSLog(@&quot;Number&quot;);
            }else{
                NSLog(@&quot;%@&quot;,typeClass);
            }
        }
        return self;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们想要字典转模型的时候，直接如下使用：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    NSDictionary *dict = @{@&quot;name&quot;:@&quot;Scott&quot;,
                           @&quot;icon&quot; : @&quot;lufy.png&quot;,
                           @&quot;age&quot; : @&quot;20&quot;,
                           @&quot;height&quot; : @1.75,
                           @&quot;money&quot; : @&quot;100.9&quot;,
                           @&quot;sex&quot; : @(SexMale),
                           @&quot;gay&quot; : @&quot;ture&quot;,
                           };
    ScottUser *userModel = [ScottUser objectWithKeyValues:dict];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok,运行程序，可以看到控制台输出&lt;code&gt;ScottUser&lt;/code&gt;类中各属性对应的类型：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension6.png&quot; alt=&quot;图6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们进行下一步：&lt;strong&gt;用该属性名作为键去字典中寻找对应的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伪代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[字典 valueForKey:属性名];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的属性名会有点问题，例如我们定义属性名的时候不能是关键字，而如果字典中的&lt;code&gt;key&lt;/code&gt;是涉及到关键字的，那么我们需要转换，但是也并非所有的都有这种情况，因此我们可以想到使用代理。我们在&lt;code&gt;NSObject+ScottKeyValue&lt;/code&gt;分类中写一个&lt;code&gt;ScottKeyValue&lt;/code&gt;协议，并且让它遵守该协议:&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    @protocol ScottKeyValue &amp;lt;NSObject&amp;gt;
    @optional
    + (NSDictionary *)replacedKeyFromPropertyName;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们提供一个类方法，用于处理将属性名与字典中的&lt;code&gt;key&lt;/code&gt;达到一致。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (NSString *)propertyKey:(NSString *)propertyName {
        NSString *key;
        if ([self respondsToSelector:@selector(replacedKeyFromPropertyName)]) {
            key = [self replacedKeyFromPropertyName][propertyName];
        }
        return key ? key : propertyName;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    // 属性名作为键去寻找对应的值
    id value = [keyValues valueForKey:[self.class propertyKey:property.name]];
    if (!value) continue;
    NSLog(@&quot;%@&quot;,value);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行，我们可以看到已经能够拿到值了：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension7.png&quot; alt=&quot;图7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们拿到值后将值的类型转换为属性对应的数据类型。&lt;/p&gt;
&lt;p&gt;首先需要处理数字类型，如果模型的属性是数字类型，即&lt;code&gt;type.isNumberType == YES&lt;/code&gt;,如果字典中的值是字符串类型，需要将其转成NSNumber类型，如果本来就是基本数据类型，则不用进行任何转换。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    if (type.isNumberType == YES) {
       // 字符串--&amp;gt;数字
       if ([value isKindOfClass:[NSString class]]) {
           value = [[[NSNumberFormatter alloc] init] numberFromString:value];
       }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中有一种情况，是需要进行特殊处理的，当模型的属性是&lt;code&gt;char&lt;/code&gt;类型或者&lt;code&gt;bool&lt;/code&gt;类型时，获取到的编码都是&lt;code&gt;c&lt;/code&gt;,并且&lt;code&gt;bool&lt;/code&gt;还有可能是&lt;code&gt;B&lt;/code&gt;编码，它们都对应&lt;code&gt;_boolType&lt;/code&gt;，因为数字类型包含布尔类型，所以&lt;code&gt;bool&lt;/code&gt;类型要在数字类型的条件下进行额外判断。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    if (type.isNumberType == YES) {
        NSString *oldValue = value;
        // 字符串--&amp;gt;数字
        if ([value isKindOfClass:[NSString class]]) {
            value = [[[NSNumberFormatter alloc] init] numberFromString:value];
            if (type.isBoolType) {
                NSString *lower = [oldValue lowercaseString];
                if ([lower isEqualToString:@&quot;yes&quot;] || [lower isEqualToString:@&quot;ture&quot;]) {
                    value = @YES;
                }else if ([lower isEqualToString:@&quot;no&quot;] || [lower isEqualToString:@&quot;false&quot;]){
                    value = @NO;
                }
            }
        }
    } else { //  然后处理其他类型转化成字符串类型的情况：
          if (typeClass == [NSString class]) {
              if ([value isKindOfClass:[NSNumber class]]) {
                  if (type.isNumberType)
                      // NSNumber -&amp;gt; NSString
                      value = [value description];
              }else if ([value isKindOfClass:[NSURL class]]){
                  // NSURL -&amp;gt; NSString
                  value = [value absoluteString];
              }
          }
      }
      // 最后赋值      
      [self setValue:value forKey:property.name];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们调用并打印&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScottUser *userModel = [ScottUser objectWithKeyValues:dict];
    NSLog(@&quot;name:%@,icon:%@,age:%d,height:%@,money:%@,sex:%ld,gay:%d&quot;,userModel.name,userModel.icon,userModel.age,userModel.height,userModel.money,(long)userModel.sex,userModel.gay);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension8.png&quot; alt=&quot;图8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里最简单的字典转模型大致完成了，当然还有很多的细节没有完善，后面再做处理。&lt;/p&gt;
&lt;h2 id=&quot;json字符串转模型&quot;&gt;JSON字符串转模型&lt;/h2&gt;
&lt;p&gt;定义一个&lt;code&gt;json&lt;/code&gt;字符串转成模型：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #pragma mark - JSON字符串转模型
    void keyValues2object1(){
        // 1.定义一个json字符串
        NSString *jsonString = @&quot;{\&quot;name\&quot;:\&quot;scott\&quot;,\&quot;icon\&quot;:\&quot;lufy.png\&quot;,\&quot;age\&quot;:20}&quot;;
        // 2.将json字符串转为LZUser模型
        ScottUser *user = [ScottUser objectWithKeyValues:jsonString];
        // 3.打印模型属性
        NSLog(@&quot;name=%@, icon=%@, age=%d&quot;,user.name,user.icon,user.age);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，这时程序会华丽丽的崩溃，因为程序原来只对字典类型作了处理：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;       // 我们可以定位到程序崩溃在这里
       id value = [keyValues valueForKey:[self.class propertyKey:property.name]];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在这之前需要将&lt;code&gt;JSON&lt;/code&gt;转成&lt;code&gt;Foundation&lt;/code&gt;框架中的对象，苹果提供了强大的&lt;code&gt;NSJSONSerialization&lt;/code&gt;，利用它，在刚开始传入字典/&lt;code&gt;JSON&lt;/code&gt;字符串的时候将其进行转换。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    - (instancetype)setKeyValues:(id)keyValues { 
        keyValues = [keyValues JSONObject]; 
        NSArray *propertiesArray = [self.class properties];
        ......
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的实现如下，如果当前是字符串，则转换成&lt;code&gt;NSData&lt;/code&gt;再进行序列化。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    - (id)JSONObject {
        id foundationObj;
        if ([self isKindOfClass:[NSString class]]) {
            NSString *str = (NSString *)self;
            foundationObj = [NSJSONSerialization  JSONObjectWithData:[str dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:nil];
        }else if ([self isKindOfClass:[NSData class]]){
            foundationObj = [NSJSONSerialization JSONObjectWithData:(NSData *)self options:kNilOptions error:nil];
        }
        // 如果foundationObj有值，则返回foundationObj，否则返回self
        return foundationObj ? : self;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，运行程序，OK，能够看到控制台能正确输入结果：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension9.png&quot; alt=&quot;图9&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;复杂字典转模型&quot;&gt;复杂字典转模型&lt;/h2&gt;
&lt;p&gt;定义一个模型中包含模型的复杂字典：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    NSDictionary *dict = @{@&quot;text&quot;:@&quot;是啊，今天天气确实不错！&quot;,
                           @&quot;user&quot;:@{
                                   @&quot;name&quot;:@&quot;scott&quot;,
                                   @&quot;icon&quot;:@&quot;lufy.png&quot;
                                   },
                           @&quot;retweetedStatus&quot;:@{
                                   @&quot;text&quot;:@&quot;是啊，今天天气确实不错&quot;,
                                   @&quot;user&quot;:@{
                                           @&quot;name&quot;:@&quot;scott_status&quot;,
                                           @&quot;icon&quot;:@&quot;lufy_status.png&quot;
                                           }
                                   }
                           };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对待这种字典的思路，应该想到递归，当碰到模型中的属性类型是一个模型类时，将字典中的&lt;code&gt;value&lt;/code&gt;作为字典处理，然后再调用字典转模型的方法返回一个模型类，所以在包装类型时还要有个属性表示它是否是自定义的模型类，才能作为依据继续递归，判断的方法是看它是否来自于&lt;code&gt;Foundation框架&lt;/code&gt;的类。&lt;br/&gt;在&lt;code&gt;ScottPropertyType&lt;/code&gt;中添加一个属性:&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    /**  是否来源于Foundation框架，比如NSString,NSArray等 */
    @property (nonatomic, readonly, getter=isFromFoundation) BOOL fromFoundation;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;- (void)getTypeCode:(NSString *)code&lt;/code&gt;方法中添加这样一条:&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    else if (code.length &amp;gt; 3 &amp;amp;&amp;amp; [code hasPrefix:@&quot;@\&quot;&quot;]){
        // 去掉@&quot;和&quot;，截取中间的类型名称
        code = [code substringWithRange:NSMakeRange(2, code.length - 3)];
        _typeClass = NSClassFromString(code);
        _numberType = (_typeClass == [NSNumber class] || [_typeClass isSubclassOfClass:[NSNumber class]]);
        // 判断是否来自于foundation框架
        _fromFoundation = [NSObject isClassFromFoundation:_typeClass];
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;NSObject+ScottProperty&lt;/code&gt;分类中添加一个类方法：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    // 用于判断当前类是否来自于foundation框架
    + (BOOL)isClassFromFoundation:(Class)c;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了，如果判断是否来自于&lt;code&gt;Foundation框架&lt;/code&gt;呢？ 下图展示了&lt;code&gt;Foundation框架(NSObject部分)&lt;/code&gt;下的类结构:&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension10.png&quot; alt=&quot;图10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用一个&lt;code&gt;NSSet&lt;/code&gt;(比用&lt;code&gt;NSArray&lt;/code&gt;检索效率更高)，返回一些常用基本的&lt;code&gt;Foundation框架&lt;/code&gt;下继承自&lt;code&gt;NSObject&lt;/code&gt;的类。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    static NSSet *foundationClasses_;
    + (NSSet *)foundationClass {
        if (foundationClasses_ == nil) {
            foundationClasses_ = [NSSet setWithObjects:[NSURL class],
                                  [NSDate class],
                                  [NSValue class],
                                  [NSData class],
                                  [NSArray class],
                                  [NSDictionary class],
                                  [NSString class],
                                  [NSMutableString class], nil];
        }
        return foundationClasses_;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以判断是否是&lt;code&gt;foundation框架&lt;/code&gt;的类方法具体实现：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (BOOL)isClassFromFoundation:(Class)c {
        // 因为foundationClasses_里面的类都是继承NSObject，因此NSObject不能放到上面的集合，需要额外做判断
        if (c == [NSObject class]) return YES;
        __block BOOL result = NO;
        [[self foundationClass] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {
            if ([c isSubclassOfClass:foundationClass]) {
                result = YES;
                *stop = YES;
            }
        }];
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到结果后，需要在&lt;code&gt;NSObject+ScottKeyValue&lt;/code&gt;分类中的&lt;code&gt;setKeyValues:&lt;/code&gt;方法中添加如下&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    // 如果不是来自foundation框架的类并且不是基本数据类型 ,则递归,如果是基本数据类型，typeClass为nil
    if (!type.isFromFoundation &amp;amp;&amp;amp; typeClass) {
        value = [typeClass objectWithKeyValues:value];
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，复杂字典转模型就算是完成了，具体调用的过程看源码&lt;strong&gt;文章结尾会给地址&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;字典数组转模型&quot;&gt;字典数组转模型&lt;/h2&gt;
&lt;p&gt;稍微复杂的一种情况是一个字典里面带有数组：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    NSDictionary *dict = @{
                           @&quot;statuses&quot; : @[
                                   @{
                                       @&quot;text&quot; : @&quot;今天天气真不错！&quot;,
                                       @&quot;user&quot; : @{
                                               @&quot;name&quot; : @&quot;Rose&quot;,
                                               @&quot;icon&quot; : @&quot;nami.png&quot;
                                               }
                                       },
                                   @{
                                       @&quot;text&quot; : @&quot;明天去旅游了&quot;,
                                       @&quot;user&quot; : @{
                                               @&quot;name&quot; : @&quot;Jack&quot;,
                                               @&quot;icon&quot; : @&quot;lufy.png&quot;
                                               }
                                       }
                                   ],
                           @&quot;ads&quot; : @[
                                   @{
                                       @&quot;image&quot; : @&quot;ad01.png&quot;,
                                       @&quot;url&quot; : @&quot;http://www.baidu.com&quot;
                                       },
                                   @{
                                       @&quot;image&quot; : @&quot;ad02.png&quot;,
                                       @&quot;url&quot; : @&quot;http://www.sina.com&quot;
                                       }
                                   ],
                           @&quot;totalNumber&quot; : @&quot;2014&quot;,
                           @&quot;previousCursor&quot; : @&quot;13476589&quot;,
                           @&quot;nextCursor&quot; : @&quot;13476599&quot;
                           };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个字典，创建一个&lt;code&gt;ScottStatusResult&lt;/code&gt;模型，里面有两个数组，另外还有其他3个键：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    #import &amp;lt;Foundation/Foundation.h&amp;gt;
    @interface ScottStatusResult : NSObject
    /** 存放着某一页微博数据（里面都是Status模型） */
    @property (nonatomic, strong) NSMutableArray *statuses;
    /** 存放着一堆的广告数据（里面都是Ad模型） */
    @property (nonatomic, strong) NSArray *ads;
    /** 总数 */
    @property (nonatomic, strong) NSNumber *totalNumber;
    /** 上一页的游标 */
    @property (nonatomic, assign) long long previousCursor;
    /** 下一页的游标 */
    @property (nonatomic, assign) long long nextCursor;
    @end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于一个数组来说，你必须要告诉方法里面装的是什么模型，才能将字典中值为数组的成员转成模型。&lt;br/&gt;在&lt;code&gt;MJExtension&lt;/code&gt;中，提供了两种方式进行处理。&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;方式一：调用&lt;code&gt;NSObject&lt;/code&gt;分类中的类方法：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    [ScottStatusResult setupObjectClassInArray:^NSDictionary *{
     return @{ @&quot;statuses&quot; : @&quot;ScottStatus&quot;,
      // 或者 @&quot;statuses&quot; : [ScottStatus class],
               @&quot;ads&quot; : @&quot;ScottAd&quot;
      // 或者 @&quot;ads&quot; : [ScottAd class]
             };
        }];&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;方式二：在模型的.m文件中实现方法供回调：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (NSDictionary *)objectClassInArray
    {
        return @{
                 @&quot;statuses&quot; : @&quot;ScottStatus&quot;,
                  // 或者 @&quot;statuses&quot; : [ScottStatus class],
                 @&quot;ads&quot; : @&quot;ScottAd&quot;
                 // 或者 @&quot;ads&quot; : [ScottAd class]
                 };
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;原理上都差不多，都是通过代码进行回调，这个主要实现方式二。&lt;br/&gt;在&lt;code&gt;NSObject+ScottKeyValue&lt;/code&gt;分类中的&lt;code&gt;ScottKeyValue&lt;/code&gt;协议中添加一个方法&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (NSDictionary *)objectClassInArray;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;NSObject+ScottKeyValue&lt;/code&gt;分类中的&lt;code&gt;setKeyValues:&lt;/code&gt;方法中添加一种类型判断&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    // 如果不是来自foundation框架的类并且不是基本数据类型 ,则递归,如果是基本数据类型，typeClass为nil
       if (!type.isFromFoundation &amp;amp;&amp;amp; typeClass) {
           value = [typeClass objectWithKeyValues:value];
       }else if ([self.class respondsToSelector:@selector(objectClassInArray)]){ // 看该类是否实现了objectClassInArray方法
           id objectClass;
           objectClass = [self.class objectClassInArray][property.name];
          // 如果是NSString类型
          if ([objectClass isKindOfClass:[NSString class]]) {
              objectClass = NSClassFromString(objectClass);
          }
          if (objectClass) {
              // 返回一个装了模型的数组
              value = [objectClass objectArrayWithKeyValuesArray:value];
          }
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回一个装了模型的数组方法实现：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    /**
     *  根据字典/JSON返回模型数组
     *
     *  @param keyValuesArray 字典/JSON数组
     *
     *  @return 模型数组
     */
    + (NSMutableArray *)objectArrayWithKeyValuesArray:(id)keyValuesArray
    {
        if ([self isClassFromFoundation:self])
            return keyValuesArray;
        keyValuesArray = [keyValuesArray JSONObject];
        NSMutableArray *modelArray = [NSMutableArray array];
        // 遍历
        for (NSDictionary *keyValues in keyValuesArray) {
            id model;
            model = [self objectWithKeyValues:keyValues];
            if (model) {
                [modelArray addObject:model];
            }
        }    
        return modelArray;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，字典数组转模型就算是完成了，具体调用的过程看源码&lt;strong&gt;文章结尾会给地址&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;key的替换&quot;&gt;key的替换&lt;/h2&gt;
&lt;p&gt;在实际开发中，服务器通常返回一个字段名&lt;code&gt;id&lt;/code&gt;,或者&lt;code&gt;description&lt;/code&gt;的&lt;code&gt;JSON&lt;/code&gt;数据,而这两个名字在&lt;code&gt;OC&lt;/code&gt;中有特殊含义,在定义属性的时候并不能使用这类名称.这时属性名与字典&lt;code&gt;key&lt;/code&gt;不再是直接对应的关系,需要加入一层转换。&lt;br/&gt;这个在前面&lt;strong&gt;用该属性名作为键去字典中寻找对应的值&lt;/strong&gt;讲到过，在次就不再重复讲解。&lt;/p&gt;
&lt;h2 id=&quot;性能优化&quot;&gt;性能优化&lt;/h2&gt;
&lt;p&gt;将5个字典转模型的例子同时运行，在&lt;code&gt;NSObject+ScottProperty&lt;/code&gt;分类中的&lt;code&gt;+ (NSArray *)properties&lt;/code&gt;方法中添加一句打印&lt;code&gt;NSLog(@&quot;%@调用了properties方法&quot;,[self class]);&lt;/code&gt;。另外，之前的例子都是有内存泄露的，这里添加了&lt;code&gt;free(properties);&lt;/code&gt;修复了这个问题。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (NSArray *)properties {
        NSLog(@&quot;%@调用了properties方法&quot;,[self class]);
        NSMutableArray *propertiesArr = [NSMutableArray array];
        unsigned int outCount = 0;
        objc_property_t *properties = class_copyPropertyList(self, &amp;amp;outCount);
        for (int i=0; i&amp;lt;outCount; i++) {
            objc_property_t property = properties[i];
            ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];
            [propertiesArr addObject:propertyObj];
        }
        free(properties);
        return propertiesArr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，可以看到控制台输出：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension11.png&quot; alt=&quot;图11&quot;/&gt;&lt;br/&gt;可以看到,很多的类都不止一次调用了获取属性的方法,对于一个类来说,要获取它的全部属性,只要获取一次就够了.获取到后将结果缓存起来,下次就不必进行不必要的计算。&lt;br/&gt;下面进行优化：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    // 设置一个全局字典用来将类的属性都缓存起来
    static NSMutableDictionary *cachedProperties_;
    + (void)load
    {
        cachedProperties_ = [NSMutableDictionary dictionary];
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将方法改写为:&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    + (NSArray *)properties {
        NSMutableArray *propertiesArr = cachedProperties_[NSStringFromClass(self)];
        if (!propertiesArr) {
            NSLog(@&quot;%@调用了properties方法&quot;,[self class]);
            propertiesArr = [NSMutableArray array];
            unsigned int outCount = 0;
            objc_property_t *properties = class_copyPropertyList(self, &amp;amp;outCount);
            for (int i=0; i&amp;lt;outCount; i++) {
                objc_property_t property = properties[i];
                ScottProperty *propertyObj = [ScottProperty propertyWithProperty:property];
                [propertiesArr addObject:propertyObj];
                //        NSLog(@&quot;name:%@--type:%@&quot;,propertyObj.name,propertyObj.type.typeClass);
                // 为了以后方便使用，将C字符串转化成OC对象
                //        char *name = property_getName(property);
                //        NSString *name = @(property_getName(property));
                //        char *att = property_getAttributes(property);
                //        NSString *att = @(property_getAttributes(property));
                //        NSUInteger loc = 1;
                //        NSUInteger len = [att rangeOfString:@&quot;,&quot;].location - loc;
                //        NSString *type = [att substringWithRange:NSMakeRange(loc, len)];
                //        NSLog(@&quot;%@&quot;,type);
            }
            free(properties);
            cachedProperties_[NSStringFromClass(self)] = propertiesArr;
        }
        return propertiesArr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，控制台输出：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension12.png&quot; alt=&quot;图12&quot;/&gt;&lt;br/&gt;可以看出每一个类只经过一次就可以获取所有属性。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;除了缓存属性外，提取类型编码的过程也可以进一步缓存优化性能。&lt;br/&gt;在下面的方法中加上一句打印：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    - (void)getTypeCode:(NSString *)code {
        NSLog(@&quot;%@&quot;,code);
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到控制台输出：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension13.png&quot; alt=&quot;图13&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到一些常用的类型例如&lt;code&gt;NSString&lt;/code&gt;多次调用了该方法。提取类型时,只要知道类名(在这里也就是&lt;code&gt;typeCode&lt;/code&gt;),一个&lt;code&gt;ScottPropertyType&lt;/code&gt;就已经可以确定了。&lt;/p&gt;
&lt;p&gt;重写了&lt;code&gt;- initWithTypeString:&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;    static NSMutableDictionary *cacheTypes_;
    + (void)load {
        cacheTypes_ = [NSMutableDictionary dictionary];
    }
    + (instancetype)propertiesWithAttributeString:(NSString *)att {
        return [[ScottPropertyType alloc] initWithTypeString:att];
    }
    - (instancetype)initWithTypeString:(NSString *)typeString {   
        if (self = [super init]) {
            NSUInteger loc = 1;
            NSUInteger len = [typeString rangeOfString:@&quot;,&quot;].location - loc;
            NSString *typeCode = [typeString substringWithRange:NSMakeRange(loc, len)];
            if (!cacheTypes_[typeCode]) {
                [self getTypeCode:typeCode];
                cacheTypes_[typeCode] = self;
            }
        }
        return self;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;&lt;img src=&quot;http://7xv28v.com1.z0.glb.clouddn.com/ScottExtension14.png&quot; alt=&quot;图14&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;OK,到这里，我们的解读也算是完成了，由于是下班之后写的，所以花费了4天的时间，终于把此篇文章写完了，欢迎大家点评并讨论。&lt;br/&gt;最后代码地址：---&amp;gt;&lt;a href=&quot;https://github.com/LZAscott/ScottExtension&quot;&gt;戳这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://www.jianshu.com/p/d2ecef03f19e&quot;&gt;跟着MJExtension实现简单的字典转模型&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Apr 2018 14:07:00 +0000</pubDate>
<dc:creator>Scott_Mr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scott-mr/p/8947613.html</dc:identifier>
</item>
</channel>
</rss>