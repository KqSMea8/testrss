<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>salesforce lightning零基础学习(三)  表达式的！(绑定表达式)与 #(非绑定表达式) - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/8947726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/8947726.html</guid>
<description>&lt;p&gt;在salesforce的classic中，我们使用{!expresion}在前台页面展示信息，在lightning中，上一篇我们也提及了，如果展示attribute的值，可以使用{!v.expresion}展示信息。&lt;/p&gt;
&lt;p&gt;lightning在component中解析动态值的时候，会将{!} 这个里面的变量进行动态的解析以及展示。当然这个变量可以是基础类型，自定义类型，数组集合等等，当然如果表达式为空字符串或者是空格则不会解析。偶尔特殊的要求为需要输出‘{!}’这个字符串，官方文档说可以使用&amp;lt;aura:text/&amp;gt;进行展示，因为这个标签不会将‘{!’作为头进行解析。当然，不要被这句话所欺骗，正常的理解应该为当value的值非tag或者attribute值的情况下，才会被解析成平滑的字符串。这里做个demo看一下渲染效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;testValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {!v.test}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.test}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {!}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.test2}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!test2}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;demo中分了几种情况：输出正常的attribute值、通过aura:text输出attribute值、输出{!}值、输出一个不存在的属性的值、输出一个不存在的变量的值。结果展示如下图所示。&lt;/p&gt;
&lt;p&gt;通过结果我们可以看出来，aura:text并不是不解析{!开头的内容，而是如果{!}不包含任何表达式情况下，会默认作为文本进行输出，其实不是用aura:text 直接输出{!}也可以作为文本进行输出。如果解析的内容不存在情况下，则默认返回null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180425221403681-2092725380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用{!}方式标签仅能用于在.cmp 以及.app文件中，即只能用在lightning component以及lightning application中。&lt;/p&gt;
&lt;p&gt;表达式除了简单的通过{!v.attribute} 展示attribute的内容或者{!123}等展示字面内容的内容外，还可以使用条件表达式这种方式展示内容，通常有两种常用的方式：三目运算和使用&amp;lt;aura:if&amp;gt;。&lt;/p&gt;
&lt;p&gt;三目运算：下面的代码为当attribute xxx的值为xxx的情况下，这个classs设置为'xxx'，否则，class为空。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;{!v.xxx == 'xxx' ? 'xxx' : ''}&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;test &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &amp;lt;aura:if&amp;gt;：此标签通常和aura:set一起用。当aura:if判断部分为true，显示aura:if为true的逻辑，否则使用aura:set设置attribute为else，走false的逻辑。下面的例子为如果有edit权限则展示Edit的Button，否则展示'You can't edit this'的文字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;edit&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Boolean&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:if &lt;/span&gt;&lt;span&gt;isTrue&lt;/span&gt;&lt;span&gt;=&quot;{!v.edit}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ui:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Edit&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:set &lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;=&quot;else&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;       You can’t edit this.
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们在项目中会经常用到lightning component中嵌套其他的子的lightning component情况，比如列表中包含&amp;lt;aura:iterator&amp;gt; 标签嵌套item的lightning component从而实现一个自定义列表展示。&lt;/p&gt;
&lt;p&gt;嵌套lightning component就会涉及到attribute 赋值的部分，针对attribute赋值，可以赋值一个写死的值，比如赋值‘123’等。lightning也提供了两种动态方式赋值：{!attributeValue}以及{#attributeValue}。两者赋值区别还是很大的，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.   !方式：&lt;/strong&gt;此种方式又可以理解为绑定的表达式，即对attribute的赋值非一次性的，改变会贯穿着始终。子项如果修改了这个attribute的赋值，也会影响到父中此attribute的值；同样的，如果父中对此attribute有更改，也会作用到子component中的引用上。&lt;/p&gt;
&lt;p&gt;这里做一个例子：&lt;/p&gt;
&lt;p&gt;1.boundSonComponent.cmp：声明一个attribute名称为sonAttribute，使用一个aura:text展示这个值，点击按钮后更新这个sonAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;sonAttribute&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    son attribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.sonAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleSonClick}&quot;&lt;/span&gt;&lt;span&gt; label&lt;/span&gt;&lt;span&gt;=&quot;son button&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.boundSonComponentController.js : 更新sonAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handleSonClick : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sonAttributeValue = 'Updated Son Attribute'&lt;span&gt;;
        component.set(&lt;/span&gt;'v.sonAttribute'&lt;span&gt;, sonAttributeValue);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.boundParentComponent.cmp ：声明一个attribute名称为parentAttribute,展示此attribute的值并且提供按钮可以修改值，在这个基础上引入了一个boundSonComponent，并且将parentAttribute的值传给了sonAttribute。注意，这里通过‘！’方式进行传递值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parentAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;parentAttributeValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    parentAttribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.parentAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;parent button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleParentClick}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundSonComponent &lt;/span&gt;&lt;span&gt;sonAttribute &lt;/span&gt;&lt;span&gt;= '{!v.parentAttribute}'&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.boundParentComponentController.js ：更新parentAttribute的value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handleParentClick : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        component.set(&lt;/span&gt;'v.parentAttribute', 'updated parent attribute'&lt;span&gt;);
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 因为lightning无法直接运行lightning:component，所以需要将lightning:component放在 lightning app builder视图中或者放在Lightning application中，lightning app builder 可以重新定义 page layout，分为App Page, Home Page 和Record Page。这个和page layout 很像，需要注意的一点为显示在不同类型的页面需要实现不同的接口，具体可以查看上一篇内容，感兴趣的可以自己玩一玩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427214430357-929209396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;demo以创建Lightning application为主。&lt;/p&gt;
&lt;p&gt;5.创建boundApplication.app 用来包含boundParentComponent从而展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundParentComponent&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行lightning application可以通过developer console -&amp;gt; File -&amp;gt; Opening Lighting Resource 找到此bundle，然后Open Selected，打开后点击Preview便可以看到显示方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427221352979-1295092137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.默认进来情况：&lt;/strong&gt;因为parentAttribute的值作为了sonAttribute的值，所以二者显示相同的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224547544-1652821582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 2.点击 parent button：&lt;/strong&gt;点击parent button后，后台会更新parentAttribute的value。由于sonAttribute传递的值通过parentAttribute值传递，并且是通过！（bound）方式，所以当更改了parentAttribute后，sonAttribute也同样的改变成了parentAttribute的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224638807-181477913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;3. 点击son button：&lt;/strong&gt;点击son button后，后台会更新sonAttribute的值。由于sonAttribute是通过parentAttribute值传递，并且是通过！（bound）方式，所以当更改了sonAttribute后，parentAttribute也同样的受到了改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427224716781-1390897220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这种操作结果可能让人感到意外，因为我们有的时候只是想将attribute的值作为一个一次性初始化的值传递给子的component 的attribute，针对父或者针对子的改动并不希望后期在影响当前component外的其他的父或者子的component attribute。接下来的方式即可以做到非绑定表达式，即使用 # 方式进行值的传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.   # 方式：&lt;/strong&gt;可以理解成非绑定的表达式，即有嵌套的lightning component,父对子传值仅初始化有效，后期父对这个attribute value的变化不会影响到子，同样子对这个attribute value的变化同样不会影响到父。&lt;/p&gt;
&lt;p&gt; 在这里重用boundSonComponent,新建unboundParentComponent,使用#方式传递值。&lt;/p&gt;
&lt;p&gt;1.unboundParentComponent:和boundParentComponent唯一的区别为在对boundSonComponent传值的时候，将! 修改成了 # . &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;parentAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;parentAttributeValue&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    parentAttribute : &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:text &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!v.parentAttribute}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;parent button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleParentClick}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:boundSonComponent &lt;/span&gt;&lt;span&gt;sonAttribute &lt;/span&gt;&lt;span&gt;= '{#v.parentAttribute}'&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果展示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.当点击parent button时&lt;/strong&gt;，仅更改了parentAttribute的值，sonAttribute值不会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427233028026-2022116234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.当点击son button时&lt;/strong&gt;，金更改了sonAttribute的值，parentAttribute的值同样不会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180427233151729-1880459600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; 通过上述的两个例子的展示结果可以看出来：对子component的attribute进行动态赋值时， ！(绑定表达式) 与 #(非绑定表达式)差距还是很大的。使用！方式关系贯穿始终，无论父还是子对attribute改动都会对其关联的受到影响。使用#方式仅在初始化时有效，后期针对引用的attribute的值进行任何修改，都不会同步修改引用的地方。具体使用哪种方式看项目中用到的场景，同步操作则使用！方式传值；仅需要其传值作为初始化，后期改动无关则选择#方式传值。篇中有错误地方欢迎指出，有问题欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:50:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/8947726.html</dc:identifier>
</item>
<item>
<title>Java不走弯路教程（1.环境搭建） - java123.vip</title>
<link>http://www.cnblogs.com/java123vip/p/8965182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java123vip/p/8965182.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.环境搭建&lt;/strong&gt;&lt;br/&gt;在开始写第一个Java程序之前，我们需要做一些简单的准备工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 还记得DOS吗&lt;/strong&gt;&lt;br/&gt;我们可以通过图形界面来操作我们的电脑。但作为程序员，你首先需要学会用命令行的方式来操作电脑，因为不是所有的电脑都提供图形界面的。&lt;br/&gt;Windows环境下可以通过DOS来执行命令。&lt;br/&gt;你只需要记住大概5个命令，即可完成电脑的基本操作。&lt;/p&gt;
&lt;p&gt;我们首先启动DOS环境：在文件浏览器的地址栏中输入cmd，回车，如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232520433-1179899161.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;&lt;p&gt;光标左边显示的是当前所在目录。&lt;br/&gt;本教程实例均在C盘下操作，所以如果不是C盘，输入c:回车，切换到C盘下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232634248-1175003207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我们要学习5个命令：&lt;br/&gt;目录创建&lt;br/&gt;目录切换&lt;br/&gt;查看当前目录下文件/文件夹列表&lt;br/&gt;打开指定文件&lt;br/&gt;帮助&lt;/p&gt;&lt;p&gt;注：目录和文件夹是一个概念，后续将不再说明&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1.目录创建&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：md 目录名&lt;br/&gt;(Make Directory的缩写)&lt;br/&gt;注：命令之间用空格分隔，后续将不再说明。&lt;br/&gt;我们要创建的目录结构如下：&lt;br/&gt;c:&lt;br/&gt;-work&lt;br/&gt;-001&lt;br/&gt;-002&lt;br/&gt;在DOS窗口输入如下命令来创建上述目录&lt;br/&gt;md c:\work&lt;br/&gt;md c:\work\001&lt;br/&gt;md c:\work\002&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232720694-483980708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2.目录切换&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：cd 目录名&lt;br/&gt;(Change Directory的缩写)&lt;br/&gt;我们输入如下命令进入刚才创建的目录下&lt;br/&gt;cd c:\work&lt;br/&gt;可以看到当前目录变成了c:\work&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232739346-1341479782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;3.查看当前目录下文件/文件夹列表&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：dir&lt;br/&gt;(Directory的缩写)&lt;br/&gt;输入dir显示如下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232801132-1192125792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有四个文件夹分别是.,..,001,002&lt;br/&gt;其中001,002为我们刚才创建的文件夹&lt;br/&gt;.为当前目录&lt;br/&gt;..为上一级目录&lt;/p&gt;&lt;p&gt;我们输入cd .&lt;br/&gt;可以看到还是在当前目录下，&lt;br/&gt;输入cd ..&lt;br/&gt;可以看到转到了上一级目录&lt;br/&gt;输入cd work\001&lt;br/&gt;可以看到转到了c:\work\001下&lt;br/&gt;输入cd ..\..\&lt;br/&gt;可以看到转到了上上级目录下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232833511-1054585301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;4.打开指定文件&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;命令：more&lt;br/&gt;我们在Window下创建文件a.txt，内容为abc，放到c:\work目录下。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232853057-1713954000.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DOS环境下进入work目录输入后输入如下命令&lt;br/&gt;more a.txt&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427232915753-1613339020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到显示了文件内容&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;5.help&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;输入help,则显示DOS环境下所有支持的命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233352754-1634278352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不知道命令的使用方法，则输入命令名称 /? 即显示该命令的使用方法。&lt;br/&gt;比如 dir /?&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233404110-1366952357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动某个程序&lt;br/&gt;在Window下我们双击a.txt可以启动记事本来显示文件内容。&lt;br/&gt;在DOS下我们也可以实现上述操作：&lt;br/&gt;输入notepad.exe a.txt&lt;br/&gt;为了简单，我们通常省略.exe&lt;br/&gt;notepad a.txt&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233421625-1491586522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们在DOS下启动了记事本来打开a.txt文件&lt;br/&gt;其中notepad为程序名，a.txt为给程序传入的参数，如果不传任何参数，则默认打开程序&lt;br/&gt;notepad&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233442189-1688392160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;WHY&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;现在我们基本上掌握了DOS的操作。&lt;br/&gt;开动脑筋想一想，为什么输入notepad后，DOS可以启动记事本程序？&lt;br/&gt;是的，DOS需要知道notepad.exe的位置，然后启动它。&lt;/p&gt;&lt;p&gt;我们看一下DOS是否知道记事本程序在哪里，输入where notepad回车，如下图&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233508980-27516028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，也就是DOS知道notepad记事本程序位于如下路径下：&lt;br/&gt;C:\Windows\System32\notepad.exe&lt;/p&gt;&lt;p&gt;那么这种程序坐在的路径是在哪里设置的呢？&lt;/p&gt;&lt;p&gt;在DOS环境下，有个变量名叫PATH，它存储了程序的路径信息。&lt;br/&gt;我们输入如下命令来查看变量PATH的值：（echo命令可以输出指定变量的内容，其中变量名用%括起来）&lt;br/&gt;echo %PATH%&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233532987-1894796092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到C:\Windows\system32在其中。&lt;br/&gt;也就是说在DOS启动一个程序时，依次查找变量PATH下面的相应文件，如果找到则执行该文件，因为是启动环境相关，所以我们可以称这个为环境变量。&lt;/p&gt;&lt;p&gt;那么，如何增加或修改环境变量PATH的值？&lt;br/&gt;在Windows中可以右键单击我的电脑-〉系统属性-〉高级系统设置-&amp;gt;环境变量，点击新建或双击已有的环境变量来修改或增加新的环境变量。&lt;br/&gt;环境变量之间用分号来分隔。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233553039-1416338205.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233600393-1583874310.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们掌握了写Java程序所必备的DOS基础，请大家熟记于心。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.2 Java环境搭建&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在上一节我们学习了在DOS环境下启动指定程序的方法，在本节中我们将在DOS环境下启动Java程序。&lt;/p&gt;&lt;p&gt;首先，和其他Windos程序一样，我们要安装Java程序，在Oracle的官方网站上下载Java程序到本地，和其他程序一样双击完成安装，注意记下程序安装的路径。&lt;br/&gt;我安装在C:\Program Files\Java\jdk1.8.0_161下&lt;/p&gt;&lt;p&gt;验证安装是否成功：&lt;br/&gt;在DOS下输入如下命令（请自行替换为自己的安装目录，以后略）&lt;br/&gt;C:\Program Files\Java\jdk1.8.0_161\bin\java -version&lt;br/&gt;C:\Program Files\Java\jdk1.8.0_161\bin\javac -version&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233655636-1047024382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如能正确地显示版本号，则表示安装成功。&lt;br/&gt;上述java,javac命令存在于安装目录的bin目录下，其中javac为编译java程序命令，java为运行java程序命令。&lt;br/&gt;但如果每次运行都要输入全路径的话，很不方便，我们可以向上节中运行记事本程序一样，在任意目录下，直接输入java或javac即可。&lt;br/&gt;是的，我们需要把安装路径加入到环境变量PATH中。&lt;/p&gt;&lt;p&gt;新版本的JDK会自动配置上述PATH变量，如果你用的是旧版本的JDK，在配置PATH的同时，还需要配置CLASSPATH环境变量。&lt;br/&gt;在java的编译过程中，会查找一个名为CLASSPATH的环境变量来完成Java的编译，该环境变量中应该包含Java编译所需要的类文件。&lt;br/&gt;所以我们还需要添加如下环境变量：&lt;br/&gt;变量名：CLASSPATH&lt;br/&gt;变量值：.;C:\Program Files\Java\jdk1.8.0_161\lib\tools.jar&lt;br/&gt;其中.表示记载程序执行的当前目录下的类文件，tools.jar表示加载java的系统类文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233727025-757110381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233737497-1434518022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233718460-1224843150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新启动DOS环境，输入java -version和javac -version正确的显示版本号，则完成Java的环境搭建。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201804/1302871-20180427233816750-1883212177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：虽然新版本不需要上述配置，但建议读者还是按上述方法自己做一遍，千万不要省略这个步骤，这是启动Java程序的第一步。&lt;br/&gt;因为在实际环境中你会遇到各种版本的JDK，好多启动加载问题都是环境变量的不正确造成的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;版权声明：本教程版权归java123.vip所有，禁止任何形式的转载与引用。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:42:00 +0000</pubDate>
<dc:creator>java123.vip</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java123vip/p/8965182.html</dc:identifier>
</item>
<item>
<title>设计模式之中介者模式（Mediator ） - chencarl</title>
<link>http://www.cnblogs.com/chencarl/p/8965150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chencarl/p/8965150.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;中介者模式是关于数据交互的设计模式，该模式的核心是一个中介者对象，负责协调一系列对象之间的不同的数据请求，这一系列对象成为同事类。如房产中介（简直不想提它），买房的卖房的，租房的放租的都到房产中介那里去登记。如果有卖房的就会通知买房的去买房，如果有放租的就会通知租房的去租房。所有的事物都是通过中介进行通知转换，这样就形成了一个典型的星型结构，说道星型结构，网络中的交换机路由器不就是个大大的中介者么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。&lt;/p&gt;
&lt;h2 id=&quot;类视图&quot;&gt;类视图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1183944/201804/1183944-20180427232402716-1594274406.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;中介者模式为拍卖行角色，负责买家、卖家和货币转换的协调工作，其中印度买家和法国买家想拍卖美国卖家的东西，印度使用的是卢比，法国使用的是美元，而美国使用的是美元，所有的出价都要以美元进行结算；这样就需要拍卖行来协调进行价格换算，拍卖竞价等工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//头文件mediator.h
#include &amp;lt;string&amp;gt;

class  Mediator;
 
class Colleage //同事类
{
public:
    Colleage(Mediator* md);
protected:
    Mediator *m_mediator;
};

class IndianBuyer: public Colleage
{
public:
    IndianBuyer(Mediator* md);
    void setTotalMoney(float fall);
    int Purchase(float bid);
private:
    float m_total_money; //买家的心理价位
};

class FrenchBuyer: public Colleage
{
public:
    FrenchBuyer(Mediator* md);
    void setTotalMoney(float fall);
    int Purchase(float bid);
private:
    float m_total_money;
};

class AmericanSeller: public Colleage
{
public:
    AmericanSeller(Mediator* md);
    void SetWantPrice(float price);
    bool IsBidAccept(float bidInDollars);
private:
    float m_priceInDollars; //卖家的心理价位
};

class DollorConver: public Colleage
{
public:
    DollorConver(Mediator* md);
    float ConverToDollars(float bid, std::string strName);
private:
    float ConverRupeetoDollar(float bid);
    float ConverEurotoDollar(float bid);
private:
    float dollor_unit; //美元换算比例
    float euro_unit;  //欧元换算比例
    float rupee_unit;//卢比换算比例
};

class Mediator
{
public:
    Mediator();
    void RegisterIndianBuyer(IndianBuyer* buyer);
    void RegisterFrenchBuyer(FrenchBuyer* buyer);
    void RegisterAmericanSeller(AmericanSeller* seller);
    void RegisterDollorConver(DollorConver* conver);
    bool placeBid(float bid,std::string strName);
private:
    IndianBuyer* m_pIndian;
    FrenchBuyer* m_pFrench;
    AmericanSeller* m_pAmerican;
    DollorConver* m_pConver;

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mediator.cpp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;mediator.h&quot;
using namespace std;

Colleage::Colleage(Mediator* md):m_mediator(md)
{
}
IndianBuyer::IndianBuyer(Mediator* md):Colleage(md),m_total_money(-1){
    m_mediator-&amp;gt;RegisterIndianBuyer(this);
}
void IndianBuyer::setTotalMoney(float fall)
{
    m_total_money = fall;
}
int IndianBuyer::Purchase(float bid)
{
    //价格合适就出价一次
    if (m_total_money&amp;lt;0 || bid&amp;lt;= m_total_money)
    {
       return (int)m_mediator-&amp;gt;placeBid(bid,&quot;RUPEE&quot;); 
    }
    else
    {
        return 2;//价格太高了  不要啦
    }
    
}

FrenchBuyer::FrenchBuyer(Mediator* md):Colleage(md),m_total_money(-1){
    m_mediator-&amp;gt;RegisterFrenchBuyer(this);
}
void FrenchBuyer::setTotalMoney(float fall)
{
    m_total_money = fall;
}
int FrenchBuyer::Purchase(float bid)
{
    if (m_total_money&amp;lt;0 || bid&amp;lt;= m_total_money)
    {
       return (int)m_mediator-&amp;gt;placeBid(bid,&quot;EURO&quot;); 
    }
    else
    {
        return 2;
    }
    
}

AmericanSeller::AmericanSeller(Mediator* md):Colleage(md),m_priceInDollars(0){
    m_mediator-&amp;gt;RegisterAmericanSeller(this);
}
void AmericanSeller::SetWantPrice(float price)
{
    m_priceInDollars = price;
}
bool AmericanSeller::IsBidAccept(float bidInDollars)
{
    if (bidInDollars&amp;gt;=m_priceInDollars)
    {
       //当遇到价格增长时记录最高的价格，没有人超过这个价格就按照这个价格出售
        m_priceInDollars = bidInDollars;
        return true;
    }
    return false;
}

DollorConver::DollorConver(Mediator* md):Colleage(md)
,dollor_unit(1.0),euro_unit(0.7),rupee_unit(45.0){
    m_mediator-&amp;gt;RegisterDollorConver(this);
}
float DollorConver::ConverToDollars(float bid, std::string strName)
{
    if (strName.compare(&quot;RUPEE&quot;)==0)
    {
        return ConverRupeetoDollar(bid);
    }
    else
    {
        return ConverEurotoDollar(bid);
    }
}
float DollorConver::ConverRupeetoDollar(float bid)
{
    return bid*(dollor_unit/rupee_unit);
}
float DollorConver::ConverEurotoDollar(float bid)
{
    return bid*(dollor_unit/euro_unit);
}


Mediator::Mediator():m_pIndian(NULL),m_pFrench(NULL)
,m_pAmerican(NULL),m_pConver(NULL){

}
void Mediator::RegisterIndianBuyer(IndianBuyer* buyer)
{
    m_pIndian = buyer;
}
void Mediator::RegisterFrenchBuyer(FrenchBuyer* buyer)
{
    m_pFrench = buyer;
}
void Mediator::RegisterAmericanSeller(AmericanSeller* seller)
{
    m_pAmerican = seller;
}
void Mediator::RegisterDollorConver(DollorConver* conver)
{
    m_pConver = conver;
}
bool Mediator::placeBid(float bid,std::string strName)
{
    float dollars =  m_pConver-&amp;gt;ConverToDollars(bid,strName);
    return m_pAmerican-&amp;gt;IsBidAccept(dollars);
}


int main(int argc,char *argv[])
{
    Mediator mediatior;

    IndianBuyer indian(&amp;amp;mediatior);
    FrenchBuyer french(&amp;amp;mediatior);
    AmericanSeller american(&amp;amp;mediatior);
    DollorConver conver(&amp;amp;mediatior);
    
    indian.setTotalMoney(6000);
    french.setTotalMoney(100);

    american.SetWantPrice(50);
    
    int  nIndian = 0;
    int  nFrench = 0;
    float IndianBid = 2000;
    float FrenchBid = 30;
    //一轮一轮进行出价，当有一个出不起的时候，就结束竞价。
    while(nIndian+nFrench&amp;lt;=2)
    {
        do{
            nIndian = indian.Purchase(IndianBid);
            IndianBid+=100;
            if (nIndian == 1)
            {
                cout&amp;lt;&amp;lt;&quot;indian purchase : &quot;&amp;lt;&amp;lt; IndianBid &amp;lt;&amp;lt;endl;
            }
            
        }
        while(nIndian==0);

        do{
            nFrench = french.Purchase(FrenchBid);
            FrenchBid+=1.5;
            if (nFrench == 1)
            {
                cout&amp;lt;&amp;lt;&quot;french purchase : &quot;&amp;lt;&amp;lt; FrenchBid &amp;lt;&amp;lt;endl;
            }
        }
        while(nFrench==0);

    }

    return 0;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们开始任何产品研发的时候总会有一些类，这些类会使用到之前产品的研发成果，随着功能的增加，逻辑会变得更加复杂，我们会添加更多的类和之前的类互相作用，知道难以维护所有的代码。中介者模式关心的就是这个问题，它会使代码更容易维护。它能够实现类之间的松散耦合。只有中介者这一个类知道所有的类，其他类只需要与中介者进行交互即可，当然更加集中的控制也会带来中枢的庞大，还是需要避免过度的集成。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;一组对象使用了标准的通信方式，但整体通信的连接都非常复杂，由此产生的相互依赖的结构导致系统难以结构化，也很难理解；&lt;/li&gt;
&lt;li&gt;由于对象之间的通信和相互引用，导致对象难以重用。&lt;/li&gt;
&lt;li&gt;分布于对个类中间的行为能够统一定制化，而无需创建过多的子类。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 27 Apr 2018 15:25:00 +0000</pubDate>
<dc:creator>chencarl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chencarl/p/8965150.html</dc:identifier>
</item>
<item>
<title>Microsoft Visual Studio 2017 编译最新版 libuv 1.x - 9571</title>
<link>http://www.cnblogs.com/e9571/p/8965118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/e9571/p/8965118.html</guid>
<description>

&lt;p&gt;步骤很简单&lt;/p&gt;
&lt;p&gt;1 下载最新版的 libuv （地址：https://github.com/libuv/libuv）&lt;/p&gt;
&lt;p&gt;2 安装Git，Python 2.7 ，cmake（这里使用的是 3.11.0-win64-x64 版本）并且添加到环境变量，也就是直接敲命令，git，python，cmake，系统提示让需要输入参数&lt;/p&gt;
&lt;p&gt;3 使用 Microsoft Visual Studio 2017 （15.4.4 版本）命令行工具进入到文件的解压目录&lt;/p&gt;
&lt;p&gt;4 打开科学上网工具，在浏览器中输入 Google，确保能正确访问 Google（因为要从 Google Source 下载 GYP）&lt;/p&gt;
&lt;p&gt;5 切换到目录下执行 &lt;code class=&quot;language-cmd&quot;&gt;vcbuild.bat x64 &lt;span class=&quot;hljs-keyword&quot;&gt;static，（生成过程中会提示变量转换警告，但是不影响使用）&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-cmd&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;执行完成后使用 Microsoft Visual Studio 2017 打开目录下的工程文件即可&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;最后有图有真相&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;如果不是为了能够调试 XMR 挖矿程序 需要 libuv.pdb 文件，好市民是不是去 从源码编译的，为什么？因为可以直接从官方下载编译好的文件......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;文件名：libuv-x64-v1.18.0.build20&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/365739/201804/365739-20180427231313491-1518253320.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;使用  Microsoft Visual Studio 2015 的编译参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;https://my.oschina.net/fenying/blog/751299&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;2018年4月27日 23:15:15&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 27 Apr 2018 15:16:00 +0000</pubDate>
<dc:creator>9571</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/e9571/p/8965118.html</dc:identifier>
</item>
<item>
<title>linux系统运维面试题简答 - 青竹博客</title>
<link>http://www.cnblogs.com/hystj/p/8965106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hystj/p/8965106.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.     &lt;/strong&gt;&lt;strong&gt;简述常用高可用技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Keepalived：Keepalived是一个保证集群高可用的服务软件，用来防止单点故障，使用VRRP协议实现。在master和backup之间通过master主动降低自己的权值或者backup检测到master出现故障时，backup将会接管master的工作，继续服务。&lt;/p&gt;
&lt;p&gt;HAproxy：HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。&lt;/p&gt;
&lt;p&gt;heartbeat+ DRBD：&lt;/p&gt;
&lt;p&gt;heartbeat （Linux-HA）的工作原理：heartbeat最核心的包括两个部分，心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗 余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运行在对方主机上的资源或者服务。&lt;/p&gt;
&lt;p&gt;Distributed Replicated Block Device(DRBD)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。&lt;/p&gt;
&lt;p&gt;数据镜像：实时、透明、同步（所有服务器都成功后返回）、异步（本地服务器成功后返回）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.     &lt;/strong&gt;&lt;strong&gt;简述一下DNS的解析过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。&lt;/p&gt;
&lt;p&gt;2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。&lt;/p&gt;
&lt;p&gt;3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。&lt;/p&gt;
&lt;p&gt;4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。&lt;/p&gt;
&lt;p&gt;5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。&lt;/p&gt;
&lt;p&gt;6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。&lt;/p&gt;
&lt;p&gt;从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.     &lt;/strong&gt;&lt;strong&gt;简单介绍下你使用过的服务器监控软件，并简要说明下它们各自的特点，介绍下常用的监控指标。查看当前Linux系统的状态，如CPU使用，内存使用，负载情况等，查看占用内存最大的5个进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nagios，&lt;/p&gt;
&lt;p&gt;Nagios 可以监控的功能有：&lt;/p&gt;
&lt;p&gt;1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）；&lt;/p&gt;
&lt;p&gt;2、监控主机资源（处理器负荷、磁盘利用率等）；&lt;/p&gt;
&lt;p&gt;3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法；&lt;/p&gt;
&lt;p&gt;4、并行服务检查机制；&lt;/p&gt;
&lt;p&gt;5、具备定义网络分层结构的能力，用&quot;parent&quot;主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态；&lt;/p&gt;
&lt;p&gt;6、当服务或主机问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）；&lt;/p&gt;
&lt;p&gt;7、可以定义一些处理程序，使之能够在服务或者主机发生故障时起到预防作用；&lt;/p&gt;
&lt;p&gt;8、自动的日志滚动功能；&lt;/p&gt;
&lt;p&gt;9、可以支持并实现对主机的冗余监控；&lt;/p&gt;
&lt;p&gt;10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等；&lt;/p&gt;
&lt;p&gt;11、可以通过手机查看系统监控信息；&lt;/p&gt;
&lt;p&gt;12、可指定自定义的事件处理控制器；&lt;/p&gt;
&lt;p&gt;查看当前系统的状态：top&lt;/p&gt;
&lt;p&gt;查看占用内存最大的5个进程：top，然后按M（大写）键。方法二：ps -aux | sort -k4nr | head -5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.     &lt;/strong&gt;&lt;strong&gt;使用Windows服务管理命令开启BEASD的服务，并查看当前建立的连接数，默认端口为80&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动服务：net start BEASD&lt;/p&gt;
&lt;p&gt;如果服务被禁止启动，使用该命令：sc config BEASD=demand(手动)|auto(自动)|disabled（禁用）；sc start BEASD&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.     &lt;/strong&gt;&lt;strong&gt;简述Linux系统的开机启动顺序，查询程序运行级别和修改运行级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;POST加电自检--》MBR引导--》GRUB--》加载内核--》启动init进程--》读取/etc/inittab文件，/etc/init/*.conf文件--》使用/etc/rc.d/rc.sysinit初始化脚本--》执行/etc/rc.d/rc脚本（加载/etc/rc3.d/下所有脚本）--》执行/etc/rc.d/rc.local--》执行/bin/login登录程序&lt;/p&gt;
&lt;p&gt;查询程序运行级别：runlevel&lt;/p&gt;
&lt;p&gt;修改运行级别：init [0123456]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.     &lt;/strong&gt;&lt;strong&gt;简述软链接和硬链接的区别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软链接是指创建一个新的文件，block里存放的是被链接文件的文件名指向，软链接的inode与源文件的inode不同，将源文件删除，然后重建，改变了inode，软链接文件仍然有效。&lt;/p&gt;
&lt;p&gt;硬链接是创建一个新的文件名，将它的inode指向源文件的inode，所以硬链接的inode和源文件是相同的，源文件被删除后，硬链接仍然可以有效，。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.     &lt;/strong&gt;&lt;strong&gt;主机A需要给主机B传输一份100G的数据，可以做哪些传输优化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;数据打包压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据分片，同步传输&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增大传输带宽，网络端口聚合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;8.     &lt;/strong&gt;&lt;strong&gt;简述LVS的工作模式和调度算法，大并发环境推荐架构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作模式：NAT，TUNNEL，DR，FULLNAT&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;rr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;轮询调度（Round-Robin），它将请求依次分配不同的RS节点，也就是在RS节点中均摊请求。这种算法简答，但是只适合于RS节点处理性能相差不大的情况&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;wrr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;加权轮询调度（Weighted  Round-Robin）它将依据不同RS节点的权值分配任务。权值较高的RS将优先获得任务，并且分配到的连接数将比权值较低的RS节点更多。相同权值的RS得到相同数目的连接数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;dh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;目的地址哈希调度（Destination  Hashing）以目的地址为关键字查找一个静态hash表来获得需要的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;sh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;源地址哈希调度（Source  Hashing）以源地址为关键字查找一个静态hash表来获得需要的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;最小连接数调度（Least-Connection），IPVS表存储了所有的活动的连接。把新的连接请求发送到当前连接数最小的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;wlc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;加权最小连接数调度（Weighted  Least-Connection）假设各台RS的权值依次为Wi(I=1..n),当前的TCP连接数依次为Ti(I=1..n),依次选取Ti/Wi为最小的RS作为下一个分配的RS&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lblc&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;基于地址的最小连接数调度（Locality-Based Least-Connection），将来自同一目的地址的请求分配给同一台RS节点，如果这台服务器已满负荷，分配给连接数最小的RS，并以它为下一次分配的首先考虑&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;lblcr&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;基于地址带重复最小连接数调度（Locality-Based Least-Connection with Replication），对于某一目的地址，对应的一个RS子集。对此地址请求，为它分配子集中连接数最小RS；如果子集中所有服务器均已满负荷，则从集群中选择一个连接数较小服务器，将它加入到此子集并分配连接；若一定时间内，未被做任何修改，则将子集中负载最大的节点从子集删除&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;SED&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;最短的期望的延迟（Shortest  Expected Delay Scheduling SED）&lt;/p&gt;
&lt;p&gt;基于wlc算法。举例：&lt;/p&gt;
&lt;p&gt;ABC三台机器分别权重123，连接数也分别是123.那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行这样的运算：&lt;/p&gt;
&lt;p&gt;A(1+1)/1&lt;/p&gt;
&lt;p&gt;B(1+2)/2&lt;/p&gt;
&lt;p&gt;C(1+3)/3&lt;/p&gt;
&lt;p&gt;根据运算结果，把连接交给C&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;NQ&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;506&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;最少队列调度（Never  Queue Scheduling NQ）&lt;/p&gt;
&lt;p&gt;无需队列。如果RS的连接数=0就直接分配过去，不需要再进行SED运算&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;大并发环境推荐：DR模式，rr调度算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.     &lt;/strong&gt;&lt;strong&gt;简述TCP三次握手的过程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://s5.51cto.com/wyfs02/M02/8D/9A/wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_500x0-wm_3-wmp_4-s_1158167094.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;111.jpg&quot; src=&quot;https://s5.51cto.com/wyfs02/M02/8D/9A/wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_500x0-wm_3-wmp_4-s_1158167094.jpg&quot; alt=&quot;wKiom1ii9qjCscn2AAEEMO9NDeg316.jpg-wh_50&quot;/&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. &lt;/strong&gt;&lt;strong&gt;sed将文件test.txt中的所有”/opt/tmp”改为”/root/tmp”,并删除所有空行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sed -i ‘s#/opt/tmp #/root/tmp #g’test.txt|sed -i ‘/^\s*$/d’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. &lt;/strong&gt;&lt;strong&gt;将192.168.16.3这台Windows的server文件夹挂载到linux本地/mnt/server目录，Windows的账户为：administrator，密码为：123456&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、先在windows下面共享需要挂载的目录server。&lt;/p&gt;
&lt;p&gt;2、确保linux与windows是在同一个局域网当中。&lt;/p&gt;
&lt;p&gt;3、在linux下面创建一个需要挂载到的目录/mnt/server。&lt;/p&gt;
&lt;p&gt;4、利用mount命令进行挂载。&lt;/p&gt;
&lt;p&gt;挂载命令：mount -t cifs -o username=administrator,password=123456//192.168.16.3/server /mnt/server&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. &lt;/strong&gt;&lt;strong&gt;写一个防火墙配置脚本，只允许远程主机访问本机的80端口。（linux iptables）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a server firewall

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

IPT&lt;/span&gt;=/sbin/&lt;span&gt;iptables

 

#Remove any existing rules

$IPT &lt;/span&gt;-&lt;span&gt;F

$IPT &lt;/span&gt;-&lt;span&gt;X

$IPT &lt;/span&gt;-&lt;span&gt;Z

#setting &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; firewallpolicy

$IPT &lt;/span&gt;--&lt;span&gt;policy OUTPUT ACCEPT

$IPT &lt;/span&gt;--&lt;span&gt;policy FORWARD DROP

$IPT &lt;/span&gt;-&lt;span&gt;P INPUT DROP

 

#setting &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; loopback &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;

$IPT &lt;/span&gt;-A INPUT -i lo -&lt;span&gt;j ACCEPT

$IPT &lt;/span&gt;-A OUTPUT -o lo -&lt;span&gt;j ACCEPT

 

#accept &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt; port only

$IPT &lt;/span&gt;-A INPUT   -p tcp --dport &lt;span&gt;80&lt;/span&gt; -&lt;span&gt;j ACCEPT

 

#save iptables

&lt;/span&gt;/etc/init.d/iptables save
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;13. &lt;/strong&gt;&lt;strong&gt;编写个shell脚本将/logs目录下3天前的文件转移到/tmp目录下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; to move file &lt;span&gt;3&lt;/span&gt; yearago &lt;span&gt;from&lt;/span&gt; /logs to /&lt;span&gt;tmp

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

FILE_FROM&lt;/span&gt;=/&lt;span&gt;logs

FILE_TO&lt;/span&gt;=/&lt;span&gt;tmp

DAY_AGO&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;

 

cd $FILE_FROM

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; `find $FILE_FROM-type f -mtime +&lt;span&gt;3&lt;/span&gt;&lt;span&gt;`

   &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;

              /bin/mv $FILE_FROM/$file $FILE_TO/&lt;span&gt;$file

   done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;14. &lt;/strong&gt;&lt;strong&gt;每天1:00备份/var/log目录下前一天的日志文件并存放到当前目录的btslog目录中，并删除15天前的log备份文件，请使用shell脚本完成。（日志格式为：btsvr.log.2016-01-01,打包备份文件格式为：btsvr.log.2016-01-01.tar.gz）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat bak_logs.sh

#&lt;/span&gt;!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; to backup logs

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

YESTERDAY&lt;/span&gt;=`date +%F -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1 day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`

LOG_DIR&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;log

BAK_DIR&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;btslog

LOG_FILE&lt;/span&gt;=&lt;span&gt;btsvr.log

 

cd $LOG_DIR&lt;/span&gt;/

&lt;span&gt;if&lt;/span&gt; [ -f $LOG_DIR/&lt;span&gt;$LOG_FILE.$YESTERDAY] ;then{

tar zcf $LOG_DIR&lt;/span&gt;/$LOG_FILE.$YESTERDAY.tar.gz$LOG_DIR/&lt;span&gt;$LOG_FILE.$YESTERDAY

&lt;/span&gt;/bin/mv $LOG_DIR/$LOG_FILE.$YESTERDAY.tar.gz/BAK_DIR/&lt;span&gt;

}

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

       echo “the file &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; not exist.”

fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用定时任务每天1点执行该脚本：0001 * * * /bin/bash bak_logs.sh&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15. &lt;/strong&gt;&lt;strong&gt;写一个脚本进行nginx日志统计，得到访问ip最多的前10个（nginx日志路径：/nginx/default/access.log）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat bak_logs.sh

#&lt;/span&gt;!/bin/&lt;span&gt;bash

#&lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt;&lt;span&gt; to backup logs

#updated by yehaifeng

#qq:&lt;/span&gt;&lt;span&gt;769358362&lt;/span&gt;

 

&lt;span&gt;#define&lt;/span&gt; var&lt;span&gt;

LOG_FILE&lt;/span&gt;=/nginx/&lt;span&gt;default&lt;/span&gt;/&lt;span&gt;access.log

awk &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;/application/nginx/logs/access.log |sort|uniq -c|sort -r|head -&lt;span&gt;10&lt;/span&gt;&amp;gt;/tmp/&lt;span&gt;ip_max.txt

echo &lt;/span&gt;/tmp/ip_max.txt
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 27 Apr 2018 15:14:00 +0000</pubDate>
<dc:creator>青竹博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hystj/p/8965106.html</dc:identifier>
</item>
<item>
<title>Zookeeper和Chubby【分布式协调系统】 - py小杰</title>
<link>http://www.cnblogs.com/52mm/p/p7.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52mm/p/p7.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大规模分布式系统需要解决各种类型的协调需求：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当集群中有新的进程或服务器加入时，如何探测到它的加入？如何能够自动获取配置参数？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当配置信息被某个进程或服务器改变时，如何实时通知整个集群中的其他机器？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何判断集群中的某台机器是否还存活 ？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如何选举主服务器，主服务器宕机，如何从备选服务器中选出新的主服务器？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上问题的本质都是分布式系统下协调管理的问题，目前比较有名的协调系统有Google的Chubby，Yahoo的Zookeeper（对于协调系统来说其客户端往往是分布式集群）。&lt;/p&gt;
&lt;h2 id=&quot;chubby&quot;&gt;Chubby&lt;/h2&gt;
&lt;p&gt;Chubby提供粗粒度锁服务。一个Chubby服务单元大约能为1万台4核CPU机器提供资源的协同管理服务。其主要功能为实现集群之间的同步，以及对整个系统的环境和资源达成一致认知。&lt;/p&gt;
&lt;p&gt;Chubby是一种锁服务，分布式集群中的机器通过竞争数据的锁来成为leader，获得锁的服务器将自己的信息写入数据，让其他竞争者可见。其提供的粗粒度服务是指锁的持有时间比较长,Chubby会允许抢到锁的服务器，几小时甚至数天内都充当leader角色。Chubby强调系统的可靠性以及高可用性等，而不追求处理高吞吐量以及在协调系统内存储大量数据。其理论基础是Paxos，通过相互通信并投票，对某个决定达成一致性的认识。&lt;/p&gt;
&lt;h3 id=&quot;系统架构&quot;&gt;系统架构&lt;/h3&gt;
&lt;p&gt;一个数据中心一般部署一套Chubby单元，每套Chubby单元由5台服务器组成，通过Paxos产生1台主控服务器和4台备份服务器，备份服务器保存的数据和主控服务器完全相同，在主控服务器宕机的情况下，快速在备份服务器中选出一台作为主控服务器，以保证提供正常的服务，提高整个系统的可用性。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/zZI8rXQ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主控服务器在任期时间内（几秒），备份服务器不会投票给别的服务器来选举出新的主控服务器。任期到期后，如果在任期时间内没有发生故障，系统会任免原来的主控服务器继续担任该职务。如果备份服务器发生故障，系统会启动一台新机器替换出故障的机器，并更新DNS，而主控服务器会周期性地检测DNS，一旦发现DNS发生变化，就将消息告知集群中的其他备份服务器。&lt;/p&gt;
&lt;p&gt;客户端利用RPC通信和服务器进行交互，对Chubby的读写操作都由主控服务器完成，备份服务器只同步主控服务器中的数据，保证它们的数据和主控服务器的一致。若备份服务器收到来自客户端（分布式集群）的读写请求，它们会告知客户端主控服务器的地址，从而将请求转发给主服务器。&lt;/p&gt;
&lt;p&gt;Chubby中主要存储一些管理信息和基础数据，其目的不在于数据存储而是对资源的同步管理，不推荐在Chubby中存储大量数据。同时Chubby提供了订阅机制，即客户端可以订阅某些存储在Chubby上的数据，一旦该数据发生改变，Chubby就会通知客户端。如：将分布式集群的一份配置文件存在Chubby上，集群中所有的机器都订阅这份配置文件，一旦配置文件发生改变，所有的节点都会收到消息，根据配置文件作出改变。&lt;/p&gt;
&lt;h3 id=&quot;关于缓存&quot;&gt;关于缓存&lt;/h3&gt;
&lt;p&gt;Chubby允许客户端在本地缓存部分数据，大部分数据客户端能够在本地缓存中请求到，一方面降低了请求响应时间，另一方面减小了Chubby的压力。Chubby通过维护一个缓存表来负责维护缓存和主控服务器上数据的一致性。主控服务器在收到修改某一数据请求时会将请求暂时阻塞，并通知所有缓存了该数据的客户端，客户端收到该消息后，给Chubby发送确认收到的回执消息，主控服务器收到所有相关客户端的确认信息后，才会继续执行对数据的修改。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper&quot;&gt;Zookeeper&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2X7PeTH.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Zookeeper是一个开源的可扩展的高吞吐分布式协调系统，应用场景十分广泛。&lt;br/&gt;Zookeeper集群服务由多台服务器构成（最少3台），通过选举产生1台主服务器，和多台从服务器。客户端可从任何一台服务器读取到所需数据，但要写入或修改数据必须在主服务器上执行，若客户端连接从服务器执行写入或更新数据，从服务器会将请求转发给主服务器，由主服务器完成数据的写入或更新，并将相应的信息通知给所有从服务器，从服务器据此更新自己的数据，并向主服务发送确认信息，主服务器在接受到半数或以上从服务器的确认信息后，才通知客户端写入或更新操作成功。Zookeeper集群一般由2n+1（奇数）台服务器组成，其最大能容忍n台从服务器发生故障。Zookeeper通过定期保存的快照信息和日志信息来实现其容错能力。&lt;/p&gt;
&lt;h3 id=&quot;zookeeper数据一致性问题&quot;&gt;Zookeeper数据一致性问题&lt;/h3&gt;
&lt;p&gt;Zookeeper的任何一台从服务器也能为客户端提供读服务是其高吞吐量的主要原因，但另一方面也导致了一个问题：客户端可能会读到过期的数据。即客户端在从服务器上读数据时，主服务器已经修改了数据，还来不及将修改后的数据通知从服务器。对于此问题Zookeeper提供了同步操作来解决，客户端需要在从服务器上读取数据时调用同步方法，接收到同步命令的从服务器会向主服务器发起数据同步请求，以此来保证客户端在从服务器上读取的数据和主服务器是一致的。&lt;/p&gt;
&lt;h3 id=&quot;zookeeper数据模型&quot;&gt;Zookeeper数据模型&lt;/h3&gt;
&lt;p&gt;Zookeeper和Chubby的内存数据模型都类似于传统文件系统，由树形的层级目录结构构成，其中的节点称为Znode，其可以是文件或是目录。一般需要整体完成小数据的读写，其原因是避免被用于充当分布式存储系统使用存放大数据（Chubby也是如此）。&lt;/p&gt;
&lt;p&gt;Zookeeper和Chubby的节点类型也相同，分为持久型和临时型。临时型节点会在客户端结束请求或发生故障时被删除。持久性节点只有显示地执行删除才能将数据从Zookeeper服务器上删除。&lt;/p&gt;
&lt;p&gt;客户端可以在节点上设置观察标志，当节点发生变化时，zookeeper会通知客户端，这一性质对于zookeeper提供的诸多服务至关重要。&lt;/p&gt;
&lt;h3 id=&quot;zookeeper的典型应用场景&quot;&gt;Zookeeper的典型应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;选举领导者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper在选举领导时，会创建一个临时节点，该节点上存放领导服务器的相关信息。其他小弟会读取该节点的信息，使得整个集群知道谁是领导，并在临时节点上设置观察标志。若服务器没有读到该临时节点的数据，则表示此时集群中还没有领导，所有人都是平等的，则大家竞争领导，直到某一服务器信息写入临时节点，表示领导的产生。因为设置了观察标志，所有小弟都会收到新的领导是谁的信息。如果有新的服务器加入集群，其会读取临时节点的信息，马山就能知道谁是领导。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上层集群的配置文件等信息存储在Zookeeper集群的某个znode里，集群中的所有节点都读取该znode里的配置信息，并设置观察标志。以后如过配置信息发生变化，集群中所有节点都会收到消息，及时作出相应的改变。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集群成员管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上层集群中有新人到来或是有人要走，必须要及时知道才行。Zookeeper服务可设置某一临时节点作为一个集群，集群中的成员作为该临时节点下的临时节点。客户端对这些临时节点设置观察标志，一旦有新的机器加入，或是有机器发生故障退出，就会马上收到zookeeper发来的告知消息。以此来完成集群成员的动态管理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务分配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端在Zookeeper创建一个任务节点，并在该节点上设置观察标志，一旦有新任务到来就在该节点下创建一个子节点，并将信息告知上层集群。上层集群在Zookeeper集群中创建有一工作节点，该节点下有多个机器节点，并对这些机器节点设置观察标志。上层集群收到任务请求后，就根据工作机器的繁忙情况选出一台机器，并在该机器节点下创建一任务节点。工作机器发现这个任务后说明有新的任务分配给自己，就去执行该任务。任务执行完后，工作机器删除自己名下的任务节点。同时会删除任务节点下的相应子节点，代表任务执行完成，客户端一直在监听这一任务节点，会马上知道任务已完成。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper和chubby的异同点&quot;&gt;Zookeeper和Chubby的异同点&lt;/h2&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两者的数据模型相同，都是树形的层级目录结构，类似传统文件系统&lt;/li&gt;
&lt;li&gt;两者的节点相同，都分为临时节点和持久型节点&lt;/li&gt;
&lt;li&gt;Chubby的订阅和Zookeeper的观察标志类似&lt;/li&gt;
&lt;li&gt;写或更新数据操作都需要在主服务器上完成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Chubby强调系统的可靠性以及高可用性等，而不追求处理高吞吐量；Zookeeper能处理高吞吐量。&lt;/li&gt;
&lt;li&gt;Chubby只有主节点能提供读数据的服务，Zookeeper中从节点也能提供读数据服务。&lt;/li&gt;
&lt;li&gt;一致性协议上Chubby使用PAXOS和Zookeeper使用ZAB&lt;/li&gt;
&lt;li&gt;Chubby的主节点有租约，租约到期没问题继续续约，Zookeeper谁是主节点就一直是谁，除非人为改变或发生故障等，没有租约概念&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;作者：py小杰&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;http://www.cnblogs.com/52mm/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/52mm/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:11:00 +0000</pubDate>
<dc:creator>py小杰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52mm/p/p7.html</dc:identifier>
</item>
<item>
<title>一个使用 Web Components 的音乐播放器： MelodyPlayer - Rocket1184</title>
<link>http://www.cnblogs.com/rocket1184/p/announcing-melody-player.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rocket1184/p/announcing-melody-player.html</guid>
<description>&lt;p&gt;先上效果预览：&lt;/p&gt;

&lt;h2 id=&quot;web-components&quot;&gt;Web Components&lt;/h2&gt;
&lt;p&gt;首先，什么是 Web Components ？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components&quot;&gt;MDN&lt;/a&gt; 给出的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Web Components 是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的web应用中使用它们。&lt;br/&gt;... ...&lt;br/&gt;实现web component的基本方法通常如下所示：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 ECMAScript 2015 类语法创建一个类，来指定web组件的功能(参阅类获取更多信息)。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;CustomElementRegistry.define()&lt;/code&gt; 方法注册您的新自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类以及可选的，其所继承自的元素。&lt;/li&gt;
&lt;li&gt;如果需要的话，使用 &lt;code&gt;Element.attachShadow()&lt;/code&gt; 方法将一个 Shadow DOM 附加到自定义元素上。使用通常的 DOM 方法向 Shadow DOM 中添加子元素、事件监听器等等。&lt;/li&gt;
&lt;li&gt;如果需要的话，使用 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 方法定义一个 HTML 模板。再次使用常规 DOM 方法克隆模板并将其附加到您的 Shadow DOM 中。&lt;/li&gt;
&lt;li&gt;在页面任何您喜欢的位置使用自定义元素，就像使用常规 HTML 元素那样。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;说人话，就是先定义一个类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyCompo &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HTMLElement &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;constructor&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 一定要先调用 super&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 为所欲为&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在里面实现需要的功能，比如给自己添加子元素和事件监听器，设置样式等，就像在写平常的 JS 代码一样。&lt;/p&gt;
&lt;p&gt;然后，注册这个元素：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;customElements&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;define&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'my-compo'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; MyCompo)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据 CustomElements v1 标准，自定义元素的名称必须包含一个横线。&lt;/p&gt;
&lt;p&gt;最后，在 HTML 里面写入这个标签：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;my-compo&amp;gt;&amp;lt;/my-compo&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标签必须有结束标签与之对应，不能使用自闭合标签。&lt;/p&gt;
&lt;p&gt;然后就可以充分享受 CustomElements 带来的乐趣了，是不是很简单呢 &lt;del&gt;（误&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;通常，Custom Elements 会与 ShadowDOM 结合使用。那什么是 ShadowDOM 呢？&lt;/p&gt;
&lt;h2 id=&quot;shadowdom&quot;&gt;ShadowDOM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM&quot;&gt;MDN&lt;/a&gt; 给出的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;An important aspect of web components is encapsulation — being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. The Shadow DOM API is a key part of this, providing a way to attach a hidden separate DOM to an element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概翻译一下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;封装是 Web Components 中重要的一环，可以将元素的 DOM 树结构、样式以及行为逻辑与页面中的其他部分相隔离以避免冲突，并使你的代码保持整洁。 Shadow DOM API 是其中的关键部分，它提供了向元素中插入隐藏 DOM 子树的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简言之，Shadow DOM API 可以在任意元素内部插入一个隔离的 DOM 子树，其中的元素与样式与外部 DOM 保持隔离，不会影响到外部。所以无需担心 CSS 代码相互冲突。&lt;/p&gt;
&lt;p&gt;说了这么多，兼容性怎么样呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/877509/201804/877509-20180427230540572-1263608153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/877509/201804/877509-20180427230558215-1074877091.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;抱歉，打扰了（&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;但我们可以使用 Polyfill ，比如这个 &lt;a href=&quot;https://github.com/webcomponents/webcomponentsjs&quot;&gt;webcomponentsjs&lt;/a&gt; ，这里就不展开介绍了。&lt;/p&gt;
&lt;p&gt;我的博客园页面中已经加入了注入 Polyfill 的代码，如果你的浏览器不能正确加载，那真的改换浏览器了 ...&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; sd &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'attachShadow'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Element&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; ce &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'customElements'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; window&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;sd &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;ce) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;script src=&quot;https://files.cnblogs.com/files/rocket1184/webcomponents-sd-ce.js&quot;&amp;gt;&amp;lt;\/script&amp;gt;'&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;ce &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;script src=&quot;https://files.cnblogs.com/files/rocket1184/custom-elements.min.js&quot;&amp;gt;&amp;lt;\/script&amp;gt;'&lt;/span&gt;)
    &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;sd &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&amp;lt;script src=&quot;https://files.cnblogs.com/files/rocket1184/shadydom.min.js&quot;&amp;gt;&amp;lt;\/script&amp;gt;'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;melodyplayer&quot;&gt;MelodyPlayer&lt;/h2&gt;
&lt;p&gt;额，跑题了，今天发文章的目的其实是介绍播放器啊，播放器播放器～～～&lt;/p&gt;
&lt;p&gt;首先，播放器支持两种模式，一种是单曲模式，就像这样：&lt;/p&gt;

&lt;p&gt;默认播放一遍之后停止，也可以点击右边第二个按钮切换到单曲循环模式。&lt;/p&gt;
&lt;p&gt;然后是列表模式，就像文章一开始时展示的那样，多了 上一曲 和 下一曲 的按钮，默认播放列表一遍后停止。也可以选择列表循环、单曲循环或是随机模式。&lt;/p&gt;
&lt;p&gt;最右边的按钮可以展开/收起歌词面板。支持一或两个歌词同时显示，还有流畅的滚动动画。歌词加载失败后会有提示。&lt;/p&gt;
&lt;h2 id=&quot;技术栈与优化&quot;&gt;技术栈与优化&lt;/h2&gt;
&lt;p&gt;JS 部分使用了 ECMAScript 2015 各种语法，以及 JSX 。但并没有使用 React ，而是用 babel 自定义 JSX &lt;code&gt;@pragma&lt;/code&gt; ，并实现了一个自定义的 &lt;code&gt;createElement&lt;/code&gt; 。 Webpack 配置可以参见 &lt;a href=&quot;https://github.com/rocka/melody-player/blob/33ad1f2f7ebe7930c6c8ebdc67b34d29d69cfcff/script/webpack.conofig.js&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;CSS 部分使用了 Less ，但并没有生成独立的样式文件，也没有用 style-loader 。在 Webpack 的配置中，仅使用 less-loader 将 &lt;code&gt;*.less&lt;/code&gt; 转译为 &lt;code&gt;*.css&lt;/code&gt; ，然后使用 css-loader 解析 CSS 中的 &lt;code&gt;url()&lt;/code&gt; 部分，并在 JS 代码中将解析后的 CSS 字符串添加到 ShadowRoot 下。&lt;/p&gt;
&lt;p&gt;图标使用了 Google 的 Material Design Icons ，但并没有全量引入。我只将需要用到的 10 个图标提取出来，生成了字体的子集，只有不到 1KB 大小。然后使用 url-loader 将字体转为 Data URL 并内联在 CSS 中。关于压缩字体的方法及原理，请移步我的独立博客：&lt;a href=&quot;https://rocka.me/article/create-extreme-small-material-icon-subset&quot;&gt;制作极限压缩的 Material Icons 图标字体&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经过上述的优化，整个 &lt;code&gt;melody-player.min.js&lt;/code&gt; 只有不到 23KB 的大小。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后，附上 GitHub 链接，欢迎 Star ～&lt;/p&gt;
&lt;p&gt;GitHub 仓库： &lt;a href=&quot;https://github.com/rocka/melody-player&quot;&gt;rocka/melody-player&lt;/a&gt;&lt;br/&gt;GitHub Demo： &lt;a href=&quot;https://rocka.github.io/melody-player/&quot;&gt;MelodyPlayer Demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 15:05:00 +0000</pubDate>
<dc:creator>Rocket1184</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rocket1184/p/announcing-melody-player.html</dc:identifier>
</item>
<item>
<title>SpringBoot+Mybatis+ Druid+PageHelper 实现多数据源并分页 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8964927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8964927.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章主要讲述的是&lt;strong&gt;SpringBoot&lt;/strong&gt;整合&lt;strong&gt;Mybatis&lt;/strong&gt;、&lt;strong&gt;Druid&lt;/strong&gt;和&lt;strong&gt;PageHelper&lt;/strong&gt; 并实现多数据源和分页。其中SpringBoot整合Mybatis这块，在之前的的&lt;a href=&quot;http://www.cnblogs.com/xuwujing/p/8260935.html&quot;&gt;一篇文章&lt;/a&gt;中已经讲述了，这里就不过多说明了。重点是讲述在多数据源下的如何配置使用Druid和PageHelper 。&lt;/p&gt;
&lt;h2 id=&quot;druid介绍和使用&quot;&gt;Druid介绍和使用&lt;/h2&gt;
&lt;p&gt;在使用&lt;strong&gt;Druid&lt;/strong&gt;之前，先来简单的了解下Druid。&lt;/p&gt;
&lt;p&gt;Druid是一个数据库连接池。Druid可以说是目前最好的数据库连接池！因其优秀的功能、性能和扩展性方面，深受开发人员的青睐。&lt;br/&gt;Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid是阿里巴巴开发的号称为监控而生的数据库连接池！&lt;/p&gt;
&lt;p&gt;同时Druid不仅仅是一个数据库连接池，Druid 核心主要包括三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于Filter－Chain模式的插件体系。&lt;/li&gt;
&lt;li&gt;DruidDataSource 高效可管理的数据库连接池。&lt;/li&gt;
&lt;li&gt;SQLParser&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Druid的主要功能如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是一个高效、功能强大、可扩展性好的数据库连接池。&lt;/li&gt;
&lt;li&gt;可以监控数据库访问性能。&lt;/li&gt;
&lt;li&gt;数据库密码加密&lt;/li&gt;
&lt;li&gt;获得SQL执行日志&lt;/li&gt;
&lt;li&gt;扩展JDBC&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;介绍方面这块就不再多说，具体的可以看官方文档。&lt;br/&gt;那么开始介绍Druid如何使用。&lt;/p&gt;
&lt;p&gt;首先是Maven依赖，只需要添加druid这一个jar就行了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.1.8&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置方面，主要的只需要在&lt;strong&gt;application.properties&lt;/strong&gt;或&lt;strong&gt;application.yml&lt;/strong&gt;添加如下就可以了。&lt;br/&gt;&lt;strong&gt;说明：因为这里我是用来两个数据源，所以稍微有些不同而已。Druid 配置的说明在下面中已经说的很详细了，这里我就不在说明了。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 默认的数据源

master.datasource.url=jdbc:mysql://localhost:3306/springBoot?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;allowMultiQueries=true
master.datasource.username=root
master.datasource.password=123456
master.datasource.driverClassName=com.mysql.jdbc.Driver


## 另一个的数据源
cluster.datasource.url=jdbc:mysql://localhost:3306/springBoot_test?useUnicode=true&amp;amp;characterEncoding=utf8
cluster.datasource.username=root
cluster.datasource.password=123456
cluster.datasource.driverClassName=com.mysql.jdbc.Driver

# 连接池的配置信息  
# 初始化大小，最小，最大  
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
spring.datasource.initialSize=5  
spring.datasource.minIdle=5  
spring.datasource.maxActive=20  
# 配置获取连接等待超时的时间  
spring.datasource.maxWait=60000  
# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒  
spring.datasource.timeBetweenEvictionRunsMillis=60000  
# 配置一个连接在池中最小生存的时间，单位是毫秒  
spring.datasource.minEvictableIdleTimeMillis=300000  
spring.datasource.validationQuery=SELECT 1 FROM DUAL  
spring.datasource.testWhileIdle=true  
spring.datasource.testOnBorrow=false  
spring.datasource.testOnReturn=false  
# 打开PSCache，并且指定每个连接上PSCache的大小  
spring.datasource.poolPreparedStatements=true  
spring.datasource.maxPoolPreparedStatementPerConnectionSize=20  
# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙  
spring.datasource.filters=stat,wall,log4j  
# 通过connectProperties属性来打开mergeSql功能；慢SQL记录  
spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功添加了配置文件之后，我们再来编写Druid相关的类。&lt;br/&gt;首先是&lt;strong&gt;MasterDataSourceConfig.java&lt;/strong&gt;这个类，这个是默认的数据源配置类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = &quot;masterSqlSessionFactory&quot;)
public class MasterDataSourceConfig {

    static final String PACKAGE = &quot;com.pancm.dao.master&quot;;
    static final String MAPPER_LOCATION = &quot;classpath:mapper/master/*.xml&quot;;

    @Value(&quot;${master.datasource.url}&quot;)  
    private String url;  
      
    @Value(&quot;${master.datasource.username}&quot;)  
    private String username;  
      
    @Value(&quot;${master.datasource.password}&quot;)  
    private String password;  
      
    @Value(&quot;${master.datasource.driverClassName}&quot;)  
    private String driverClassName;  
      
    
    
    
    @Value(&quot;${spring.datasource.initialSize}&quot;)  
    private int initialSize;  
      
    @Value(&quot;${spring.datasource.minIdle}&quot;)  
    private int minIdle;  
      
    @Value(&quot;${spring.datasource.maxActive}&quot;)  
    private int maxActive;  
      
    @Value(&quot;${spring.datasource.maxWait}&quot;)  
    private int maxWait;  
      
    @Value(&quot;${spring.datasource.timeBetweenEvictionRunsMillis}&quot;)  
    private int timeBetweenEvictionRunsMillis;  
      
    @Value(&quot;${spring.datasource.minEvictableIdleTimeMillis}&quot;)  
    private int minEvictableIdleTimeMillis;  
      
    @Value(&quot;${spring.datasource.validationQuery}&quot;)  
    private String validationQuery;  
      
    @Value(&quot;${spring.datasource.testWhileIdle}&quot;)  
    private boolean testWhileIdle;  
      
    @Value(&quot;${spring.datasource.testOnBorrow}&quot;)  
    private boolean testOnBorrow;  
      
    @Value(&quot;${spring.datasource.testOnReturn}&quot;)  
    private boolean testOnReturn;  
      
    @Value(&quot;${spring.datasource.poolPreparedStatements}&quot;)  
    private boolean poolPreparedStatements;  
      
    @Value(&quot;${spring.datasource.maxPoolPreparedStatementPerConnectionSize}&quot;)  
    private int maxPoolPreparedStatementPerConnectionSize;  
      
    @Value(&quot;${spring.datasource.filters}&quot;)  
    private String filters;  
      
    @Value(&quot;{spring.datasource.connectionProperties}&quot;)  
    private String connectionProperties;  
    
    
    @Bean(name = &quot;masterDataSource&quot;)
    @Primary 
    public DataSource masterDataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUrl(url);  
        dataSource.setUsername(username);  
        dataSource.setPassword(password);  
        dataSource.setDriverClassName(driverClassName);  
          
        //具体配置 
        dataSource.setInitialSize(initialSize);  
        dataSource.setMinIdle(minIdle);  
        dataSource.setMaxActive(maxActive);  
        dataSource.setMaxWait(maxWait);  
        dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);  
        dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);  
        dataSource.setValidationQuery(validationQuery);  
        dataSource.setTestWhileIdle(testWhileIdle);  
        dataSource.setTestOnBorrow(testOnBorrow);  
        dataSource.setTestOnReturn(testOnReturn);  
        dataSource.setPoolPreparedStatements(poolPreparedStatements);  
        dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);  
        try {  
            dataSource.setFilters(filters);  
        } catch (SQLException e) { 
            e.printStackTrace();
        }  
        dataSource.setConnectionProperties(connectionProperties);  
        return dataSource;
    }

    @Bean(name = &quot;masterTransactionManager&quot;)
    @Primary
    public DataSourceTransactionManager masterTransactionManager() {
        return new DataSourceTransactionManager(masterDataSource());
    }

    @Bean(name = &quot;masterSqlSessionFactory&quot;)
    @Primary
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource)
            throws Exception {
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(masterDataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources(MasterDataSourceConfig.MAPPER_LOCATION));
        return sessionFactory.getObject();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中这两个注解说明下:&lt;/p&gt;
&lt;ul readability=&quot;-0.44941634241245&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;mailto:**@Primary*&quot;&gt;**@Primary*&lt;/a&gt;* ：标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean&lt;br/&gt;优先被考虑。多数据源配置的时候注意，必须要有一个主数据源，用 @Primary 标志该 Bean。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.73684210526316&quot;&gt;
&lt;p&gt;&lt;a href=&quot;mailto:**@MapperScan**&quot;&gt;**@MapperScan**&lt;/a&gt;： 扫描 Mapper 接口并容器管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是&lt;strong&gt;sqlSessionFactoryRef&lt;/strong&gt; 表示定义一个唯一 &lt;strong&gt;SqlSessionFactory&lt;/strong&gt; 实例。&lt;/p&gt;
&lt;p&gt;上面的配置完之后，就可以将Druid作为连接池使用了。但是Druid并不简简单单的是个连接池，它也可以说是一个监控应用，它自带了web监控界面，可以很清晰的看到SQL相关信息。&lt;br/&gt;在&lt;strong&gt;SpringBoot&lt;/strong&gt;中运用&lt;strong&gt;Druid&lt;/strong&gt;的监控作用，只需要编写&lt;strong&gt;StatViewServlet&lt;/strong&gt;和&lt;strong&gt;WebStatFilter&lt;/strong&gt;类，实现注册服务和过滤规则。这里我们可以将这两个写在一起，&lt;a href=&quot;mailto:使用**@Configuration**和**@Bean**&quot;&gt;使用**@Configuration**和**@Bean**&lt;/a&gt;。&lt;br/&gt;为了方便理解，相关的配置说明也写在代码中了，这里就不再过多赘述了。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class DruidConfiguration {

    @Bean
    public ServletRegistrationBean druidStatViewServle() {
        //注册服务
        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(
                new StatViewServlet(), &quot;/druid/*&quot;);
        // 白名单(为空表示,所有的都可以访问,多个IP的时候用逗号隔开)
        servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);
        // IP黑名单 (存在共同时，deny优先于allow) 
        servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;127.0.0.2&quot;);
        // 设置登录的用户名和密码
        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;pancm&quot;);
        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;);
        // 是否能够重置数据.
        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;);
        return servletRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean druidStatFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(
                new WebStatFilter());
        // 添加过滤规则
        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);
        // 添加不需要忽略的格式信息
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,
                &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);
        System.out.println(&quot;druid初始化成功!&quot;);
        return filterRegistrationBean;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写完之后，启动程序，在浏览器输入:&lt;a href=&quot;http://127.0.0.1:8084/druid/index.html&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:8084/druid/index.html&lt;/a&gt; ，然后输入设置的用户名和密码，便可以访问Web界面了。&lt;/p&gt;
&lt;h2 id=&quot;多数据源配置&quot;&gt;多数据源配置&lt;/h2&gt;
&lt;p&gt;在进行多数据源配置之前，先分别在&lt;strong&gt;springBoot&lt;/strong&gt;和&lt;strong&gt;springBoot_test&lt;/strong&gt;的&lt;strong&gt;mysql&lt;/strong&gt;数据库中执行如下脚本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- springBoot库的脚本

CREATE TABLE `t_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `name` varchar(10) DEFAULT NULL COMMENT '姓名',
  `age` int(2) DEFAULT NULL COMMENT '年龄',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8

-- springBoot_test库的脚本

CREATE TABLE `t_student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(16) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:为了偷懒，将两张表的结构弄成一样了！不过不影响测试!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;application.properties&lt;/strong&gt;中已经配置这两个数据源的信息，上面已经贴出了一次配置，这里就不再贴了。&lt;br/&gt;这里重点说下 第二个数据源的配置。和上面的&lt;strong&gt;MasterDataSourceConfig.java&lt;/strong&gt;差不多，&lt;a href=&quot;mailto:区别在与没有使用**@Primary*&quot;&gt;区别在与没有使用**@Primary*&lt;/a&gt;* 注解和名称不同而已。需要注意的是&lt;strong&gt;MasterDataSourceConfig.java&lt;/strong&gt;对package和mapper的扫描是精确到目录的，这里的第二个数据源也是如此。那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@MapperScan(basePackages = ClusterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = &quot;clusterSqlSessionFactory&quot;)
public class ClusterDataSourceConfig {

 static final String PACKAGE = &quot;com.pancm.dao.cluster&quot;;
 static final String MAPPER_LOCATION = &quot;classpath:mapper/cluster/*.xml&quot;;

 @Value(&quot;${cluster.datasource.url}&quot;)
 private String url;

 @Value(&quot;${cluster.datasource.username}&quot;)
 private String username;

 @Value(&quot;${cluster.datasource.password}&quot;)
 private String password;

 @Value(&quot;${cluster.datasource.driverClassName}&quot;)
 private String driverClass;

 // 和MasterDataSourceConfig一样，这里略

 @Bean(name = &quot;clusterDataSource&quot;)
 public DataSource clusterDataSource() {
     DruidDataSource dataSource = new DruidDataSource();
     dataSource.setUrl(url);  
     dataSource.setUsername(username);  
     dataSource.setPassword(password);  
     dataSource.setDriverClassName(driverClass);  
   
     // 和MasterDataSourceConfig一样，这里略 ...
     return dataSource;
 }

 @Bean(name = &quot;clusterTransactionManager&quot;)
 public DataSourceTransactionManager clusterTransactionManager() {
     return new DataSourceTransactionManager(clusterDataSource());
 }

 @Bean(name = &quot;clusterSqlSessionFactory&quot;)
 public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(&quot;clusterDataSource&quot;) DataSource clusterDataSource)
         throws Exception {
     final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
     sessionFactory.setDataSource(clusterDataSource);
     sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(ClusterDataSourceConfig.MAPPER_LOCATION));
     return sessionFactory.getObject();
 }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功写完配置之后，启动程序，进行测试。&lt;br/&gt;分别在&lt;strong&gt;springBoot&lt;/strong&gt;和&lt;strong&gt;springBoot_test&lt;/strong&gt;库中使用接口进行添加数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;t_user&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST http://localhost:8084/api/user
{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25}
{&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:25}
{&quot;name&quot;:&quot;王五&quot;,&quot;age&quot;:25}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;t_student&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST http://localhost:8084/api/student
{&quot;name&quot;:&quot;学生A&quot;,&quot;age&quot;:16}
{&quot;name&quot;:&quot;学生B&quot;,&quot;age&quot;:17}
{&quot;name&quot;:&quot;学生C&quot;,&quot;age&quot;:18}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功添加数据之后，然后进行调用不同的接口进行查询。&lt;/p&gt;
&lt;p&gt;请求:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET http://localhost:8084/api/user?name=李四&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;id&quot;: 2,
    &quot;name&quot;: &quot;李四&quot;,
    &quot;age&quot;: 25
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; GET http://localhost:8084/api/student?name=学生C
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;学生C&quot;,
    &quot;age&quot;: 16
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过数据可以看出，成功配置了多数据源了。&lt;/p&gt;
&lt;h2 id=&quot;pagehelper-分页实现&quot;&gt;PageHelper 分页实现&lt;/h2&gt;
&lt;p&gt;PageHelper是Mybatis的一个分页插件，非常的好用！这里强烈推荐！！！&lt;/p&gt;
&lt;p&gt;PageHelper的使用很简单，只需要在Maven中添加pagehelper这个依赖就可以了。&lt;br/&gt;Maven的依赖如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：这里我是用springBoot版的！也可以使用其它版本的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加依赖之后，只需要添加如下配置或代码就可以了。&lt;br/&gt;第一种，在&lt;strong&gt;application.properties&lt;/strong&gt;或&lt;strong&gt;application.yml&lt;/strong&gt;添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  pagehelper:
  helperDialect: mysql
  offsetAsPageNum: true
  rowBoundsWithCount: true
  reasonable: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种，在mybatis.xml配置中添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
    &amp;lt;!-- 扫描mapping.xml文件 --&amp;gt;
    &amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;!-- 配置分页插件 --&amp;gt;
     &amp;lt;property name=&quot;plugins&quot;&amp;gt;
        &amp;lt;array&amp;gt;
          &amp;lt;bean class=&quot;com.github.pagehelper.PageHelper&quot;&amp;gt;
            &amp;lt;property name=&quot;properties&quot;&amp;gt;
              &amp;lt;value&amp;gt;
                helperDialect=mysql
                offsetAsPageNum=true
                rowBoundsWithCount=true
                reasonable=false
              &amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
          &amp;lt;/bean&amp;gt;
        &amp;lt;/array&amp;gt;
      &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三种，在代码中添加，&lt;a href=&quot;mailto:使用**@Bean**注解在启动程序的时候初始化&quot;&gt;使用**@Bean**注解在启动程序的时候初始化&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @Bean
  public PageHelper pageHelper(){
    PageHelper pageHelper = new PageHelper();
   Properties properties = new Properties();
   //数据库
   properties.setProperty(&quot;helperDialect&quot;, &quot;mysql&quot;);
   //是否将参数offset作为PageNum使用
   properties.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;);
   //是否进行count查询
   properties.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;);
   //是否分页合理化
   properties.setProperty(&quot;reasonable&quot;, &quot;false&quot;);
   pageHelper.setProperties(properties);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这里我们使用的是多数据源，所以这里的配置稍微有些不同。我们需要在&lt;strong&gt;sessionFactory&lt;/strong&gt;这里配置。这里就对&lt;strong&gt;MasterDataSourceConfig.java&lt;/strong&gt;进行相应的修改。在&lt;strong&gt;masterSqlSessionFactory&lt;/strong&gt;方法中，添加如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Bean(name = &quot;masterSqlSessionFactory&quot;)
    @Primary
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource)
            throws Exception {
        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(masterDataSource);
        sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources(MasterDataSourceConfig.MAPPER_LOCATION));
        //分页插件
        Interceptor interceptor = new PageInterceptor();
        Properties properties = new Properties();
        //数据库
        properties.setProperty(&quot;helperDialect&quot;, &quot;mysql&quot;);
        //是否将参数offset作为PageNum使用
        properties.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;);
        //是否进行count查询
        properties.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;);
        //是否分页合理化
        properties.setProperty(&quot;reasonable&quot;, &quot;false&quot;);
        interceptor.setProperties(properties);
        sessionFactory.setPlugins(new Interceptor[] {interceptor});
        
    return sessionFactory.getObject();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：其它的数据源也想进行分页的时候，参照上面的代码即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是&lt;strong&gt;reasonable&lt;/strong&gt;参数，表示分页合理化，默认值为false。如果该参数设置为 true 时，pageNum&amp;lt;=0 时会查询第一页，pageNum&amp;gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。&lt;/p&gt;
&lt;p&gt;设置完PageHelper 之后，使用的话，只需要在查询的sql前面添加&lt;strong&gt;PageHelper.startPage(pageNum,pageSize);&lt;/strong&gt;，如果是想知道总数的话，在查询的sql语句后买呢添加 &lt;strong&gt;page.getTotal()&lt;/strong&gt;就可以了。&lt;br/&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;T&amp;gt; findByListEntity(T entity) {
        List&amp;lt;T&amp;gt; list = null;
        try {
            Page&amp;lt;?&amp;gt; page =PageHelper.startPage(1,2); 
            System.out.println(getClassName(entity)+&quot;设置第一页两条数据!&quot;);
            list = getMapper().findByListEntity(entity);
            System.out.println(&quot;总共有:&quot;+page.getTotal()+&quot;条数据,实际返回:&quot;+list.size()+&quot;两条数据!&quot;);
        } catch (Exception e) {
            logger.error(&quot;查询&quot;+getClassName(entity)+&quot;失败!原因是:&quot;,e);
        }
        return list;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码编写完毕之后，开始进行最后的测试。&lt;/p&gt;
&lt;p&gt;查询&lt;strong&gt;t_user&lt;/strong&gt;表的所有的数据，并进行分页。&lt;/p&gt;
&lt;p&gt;请求:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET http://localhost:8084/api/user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;张三&quot;,
        &quot;age&quot;: 25
    },
    {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;李四&quot;,
        &quot;age&quot;: 25
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开始查询...
User设置第一页两条数据!
2018-04-27 19:55:50.769 DEBUG 6152 --- [io-8084-exec-10] c.p.d.m.UserDao.findByListEntity_COUNT   : ==&amp;gt;  Preparing: SELECT count(0) FROM t_user WHERE 1 = 1 
2018-04-27 19:55:50.770 DEBUG 6152 --- [io-8084-exec-10] c.p.d.m.UserDao.findByListEntity_COUNT   : ==&amp;gt; Parameters: 
2018-04-27 19:55:50.771 DEBUG 6152 --- [io-8084-exec-10] c.p.d.m.UserDao.findByListEntity_COUNT   : &amp;lt;==      Total: 1
2018-04-27 19:55:50.772 DEBUG 6152 --- [io-8084-exec-10] c.p.dao.master.UserDao.findByListEntity  : ==&amp;gt;  Preparing: select id, name, age from t_user where 1=1 LIMIT ? 
2018-04-27 19:55:50.773 DEBUG 6152 --- [io-8084-exec-10] c.p.dao.master.UserDao.findByListEntity  : ==&amp;gt; Parameters: 2(Integer)
2018-04-27 19:55:50.774 DEBUG 6152 --- [io-8084-exec-10] c.p.dao.master.UserDao.findByListEntity  : &amp;lt;==      Total: 2
总共有:3条数据,实际返回:2两条数据!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询&lt;strong&gt;t_student&lt;/strong&gt;表的所有的数据，并进行分页。&lt;/p&gt;
&lt;p&gt;请求:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET  http://localhost:8084/api/student&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
    {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;学生A&quot;,
        &quot;age&quot;: 16
    },
    {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;学生B&quot;,
        &quot;age&quot;: 17
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台打印:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开始查询...
Studnet设置第一页两条数据!
2018-04-27 19:54:56.155 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.S.findByListEntity_COUNT         : ==&amp;gt;  Preparing: SELECT count(0) FROM t_student WHERE 1 = 1 
2018-04-27 19:54:56.155 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.S.findByListEntity_COUNT         : ==&amp;gt; Parameters: 
2018-04-27 19:54:56.156 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.S.findByListEntity_COUNT         : &amp;lt;==      Total: 1
2018-04-27 19:54:56.157 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.StudentDao.findByListEntity      : ==&amp;gt;  Preparing: select id, name, age from t_student where 1=1 LIMIT ? 
2018-04-27 19:54:56.157 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.StudentDao.findByListEntity      : ==&amp;gt; Parameters: 2(Integer)
2018-04-27 19:54:56.157 DEBUG 6152 --- [nio-8084-exec-8] c.p.d.c.StudentDao.findByListEntity      : &amp;lt;==      Total: 2
总共有:3条数据,实际返回:2两条数据!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询完毕之后，我们再来看Druid 的监控界面。在浏览器输入:&lt;a href=&quot;http://127.0.0.1:8084/druid/index.html&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:8084/druid/index.html&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138196/201804/1138196-20180427223043494-1384809575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以很清晰的看到操作记录!&lt;br/&gt;如果想知道更多的Druid相关知识，可以查看官方文档!&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;这篇终于写完了，在进行代码编写的时候，碰到过很多问题，然后慢慢的尝试和找资料解决了。本篇文章只是很浅的介绍了这些相关的使用，在实际的应用可能会更复杂。如果有有更好的想法和建议，欢迎留言进行讨论！&lt;/p&gt;
&lt;p&gt;参考文章:&lt;a href=&quot;https://www.bysocket.com/?p=1712&quot; class=&quot;uri&quot;&gt;https://www.bysocket.com/?p=1712&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Durid官方地址:&lt;a href=&quot;https://github.com/alibaba/druid&quot; class=&quot;uri&quot;&gt;https://github.com/alibaba/druid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PageHelper官方地址:&lt;a href=&quot;https://github.com/pagehelper/Mybatis-PageHelper&quot; class=&quot;uri&quot;&gt;https://github.com/pagehelper/Mybatis-PageHelper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目我放到github上面去了:&lt;br/&gt;&lt;a href=&quot;https://github.com/xuwujing/springBoot&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/springBoot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得不错，希望顺便给个star。&lt;br/&gt;到此，本文结束，谢谢阅读。&lt;/p&gt;
&lt;p&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;br/&gt;原创不易，转载请标明出处，谢谢！&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 14:32:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8964927.html</dc:identifier>
</item>
<item>
<title>图片人脸检测——Dlib版（四） - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/8964656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/8964656.html</guid>
<description>&lt;p&gt;上几篇给大家讲了OpenCV的图片人脸检测，而本文给大家带来的是比OpenCV更加精准的图片人脸检测Dlib库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击查看往期：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8884991.html&quot; target=&quot;_blank&quot;&gt;《图片人脸检测——OpenCV版（二）》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8933916.html&quot; target=&quot;_blank&quot;&gt;《视频人脸检测——OpenCV版（三）》&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;dlib与OpenCV对比&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;识别精准度：Dlib &amp;gt;= OpenCV&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dlib更多的人脸识别模型，可以检测脸部68甚至更多的特征点&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;效果展示&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://icdn.apigo.cn/dlib68.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://icdn.apigo.cn/dlib68.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人脸的68个特征点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://icdn.apigo.cn/68.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://icdn.apigo.cn/68.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;安装dlib&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a href=&quot;https://pypi.org/simple/dlib/&quot; rel=&quot;nofollow&quot;&gt;https://pypi.org/simple/dlib/&lt;/a&gt; 选择适合你的版本，本人配置：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;Window 10 + Python 3.6.4&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我现在的版本是：dlib-19.8.1-cp36-cp36m-win_amd64.whl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用命令安装：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;pip3 install D:\soft\py\dlib-19.8.1-cp36-cp36m-win_amd64.whl&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;显示结果： Processing d:\soft\py\dlib-19.8.1-cp36-cp36m-win_amd64.whl Installing collected packages: dlib Successfully installed dlib-19.8.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为安装成功。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;下载训练模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;训练模型用于是人脸识别的关键，用于查找图片的关键点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a href=&quot;http://dlib.net/files/&quot; rel=&quot;nofollow&quot;&gt;http://dlib.net/files/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载文件：shape_predictor_68_face_landmarks.dat.bz2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然你也可以训练自己的人脸关键点模型，这个功能会放在后面讲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载好的模型文件，我的存放地址是：C:\Python36\Lib\site-packages\dlib-data\shape_predictor_68_face_landmarks.dat.bz2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解压：shape_predictor_68_face_landmarks.dat.bz2得到文件：shape_predictor_68_face_landmarks.dat&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;代码实现&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;#coding=utf-8

import cv2
import dlib

path = &quot;img/meinv.png&quot;
img = cv2.imread(path)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

#人脸分类器
detector = dlib.get_frontal_face_detector()
# 获取人脸检测器
predictor = dlib.shape_predictor(
    &quot;C:\\Python36\\Lib\\site-packages\\dlib-data\\shape_predictor_68_face_landmarks.dat&quot;
)

dets = detector(gray, 1)
for face in dets:
    shape = predictor(img, face)  # 寻找人脸的68个标定点
    # 遍历所有点，打印出其坐标，并圈出来
    for pt in shape.parts():
        pt_pos = (pt.x, pt.y)
        cv2.circle(img, pt_pos, 2, (0, 255, 0), 1)
    cv2.imshow(&quot;image&quot;, img)

cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;连载目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8884956.html&quot; target=&quot;_blank&quot;&gt;《OpenCV环境搭建（一）》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8884991.html&quot; target=&quot;_blank&quot;&gt;《图片人脸检测——OpenCV版（二）》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8933916.html&quot; target=&quot;_blank&quot;&gt;《视频人脸检测——OpenCV版（三）》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/8964656.html%20&quot; target=&quot;_blank&quot;&gt;《图片人脸检测——Dlib版（四）》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;更多动态，请关注我的GitHub：&lt;a href=&quot;https://github.com/vipstone/faceai&quot; target=&quot;_blank&quot;&gt;https://github.com/vipstone/faceai&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 14:03:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/8964656.html</dc:identifier>
</item>
<item>
<title>React生命周期 - @疯狂的迈步</title>
<link>http://www.cnblogs.com/junhey/p/8964751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junhey/p/8964751.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在我们编程过程中对于React学习最重要的就是生命周期了，学习react生命周期对于自己的编程也会有很大的帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你基础够好的话建议直接看代码&lt;a href=&quot;https://github.com/facebook/react/blob/master/src/renderers/dom/__tests__/ReactDOMProduction-test.js#L89-L175&quot;&gt;https://github.com/facebook/react/blob/master/src/renderers/dom/&lt;strong&gt;tests&lt;/strong&gt;/ReactDOMProduction-test.js#L89-L175&lt;/a&gt;，从代码中可以看出ReactDOM的生成过程，下面详讲React的生命周期：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;getDefaultProps&lt;br/&gt;调用 React.createClass，然后触发getDefaultProps 方法，该方法返回一个对象，然后与父组件指定的props对象合并，最后赋值给 this.props 作为该组件的默认属性，该方法只调用一次&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;getInitialState&lt;br/&gt;初始化state 的值，返回值会赋给this.state，在这个方法里，你已经可以访问到this.props。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;componentWillMount&lt;br/&gt;操作state，不会触发再次渲染，建议用constructor代替&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;render&lt;br/&gt;根据 state 的值，生成页面需要的虚拟 DOM 结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;componentDidMount&lt;br/&gt;可以设置state，会触发再次渲染，组件内部可以通过 ReactDOM.findDOMNode(this)来获取当前组件的节点操作DOM&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;存在期&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;componentWillReceiveProps(nextProps)&lt;br/&gt;当组件接收到新的props时会触发该函数，通常可以调用this.setState方法来比较this.props和nextProps的执行状态，完成对state的修改&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;shouldComponentUpdate(nextProps, nextState&lt;br/&gt;该方法用来拦截新的props或state，然后判断是否更新组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;componentWillUpdate(nextProps, nextState)&lt;br/&gt;更新之前调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;rende&lt;br/&gt;根据diff算法，生成需要更新的虚拟DOM数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;componentDidUpdate(prevProps, prevState)&lt;br/&gt;render方法成功执行之后，会渲染出来真实的DOM，你可以在该方法中使用this.getDOMNode()方法访问原生DOM&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;销毁&amp;amp;清理期&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;componentWillUnmount&lt;br/&gt;会触发componentWillUnmount，通常是移除DOM，取消事件绑定，销毁定时器等工作&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;参考文献：&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006917448&quot;&gt;理解React 组件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/webbest/p/5862436.html&quot;&gt;React组件的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.jianshu.com/p/c36a0601b00c&quot;&gt;React生命周期解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章来自我的github：&lt;a href=&quot;https://github.com/junhey/studyNotes/issues/24&quot; class=&quot;uri&quot;&gt;https://github.com/junhey/studyNotes/issues/24&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Apr 2018 13:57:00 +0000</pubDate>
<dc:creator>@疯狂的迈步</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/junhey/p/8964751.html</dc:identifier>
</item>
</channel>
</rss>