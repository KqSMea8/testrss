<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python获取小程序手机号并绑定 - 如何好听</title>
<link>http://www.cnblogs.com/zzqit/p/9983407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzqit/p/9983407.html</guid>
<description>&lt;p&gt;最近在做小程序开发，在其中也遇到了很多的坑，获取小程序的手机号并绑定就遇到了一个很傻的坑。&lt;/p&gt;
&lt;h2&gt;流程介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408936/201811/1408936-20181119153142668-1524199893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1408936/201811/1408936-20181119153448946-1580712217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;小程序使用方法&lt;/h2&gt;
&lt;p&gt;需要将 &amp;lt;button&amp;gt; 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button open-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getPhoneNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; bindgetphonenumber=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getPhoneNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;返回参数说明&lt;/h2&gt;

&lt;p&gt;接受到这些参数以后小程序把code，encryptedData，iv发给后台，然后后台解密&lt;/p&gt;
&lt;h2&gt;后台解密&lt;/h2&gt;
&lt;p&gt;在解密以前需要session_key进行配合解密，所以首先通过code获取session_key&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取openid，session_key&lt;/span&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Appid为小程序id&lt;/span&gt;
    openid_url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/sns/jscode2session?appid=%s&amp;amp;secret=%s&amp;amp;js_code=%s&amp;amp;grant_type=authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (
        APP_ID, APP_KEY, code
    )
    req &lt;/span&gt;=&lt;span&gt; requests.get(openid_url)
    rep &lt;/span&gt;=&lt;span&gt; req.json()
    session_key &lt;/span&gt;= rep.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;session_key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在得到session_key，encryptedData，iv以后就可以进行解密了，python2实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Crypto.Cipher &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AES
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WXBizDataCrypt:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, appId, sessionKey):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.appId =&lt;span&gt; appId
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.sessionKey =&lt;span&gt; sessionKey
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decrypt(self, encryptedData, iv):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; base64 decode&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         sessionKey =&lt;span&gt; base64.b64decode(self.sessionKey)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         encryptedData =&lt;span&gt; base64.b64decode(encryptedData)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         iv =&lt;span&gt; base64.b64decode(iv)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         cipher =&lt;span&gt; AES.new(sessionKey, AES.MODE_CBC, iv)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         decrypted =&lt;span&gt; json.loads(self._unpad(cipher.decrypt(encryptedData)))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; decrypted[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;watermark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] !=&lt;span&gt; self.appId:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; Exception(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Invalid Buffer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; decrypted
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _unpad(self, s):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; s[:-ord(s[len(s)-1:])]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用传参&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; APP_ID为小程序id不是openid！！！&lt;/span&gt;
pc =&lt;span&gt; wx_jm(APP_ID, session_key)
res &lt;/span&gt;= pc.decrypt(encryptedData, iv)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数详情参照微信官方文档&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微信官方提供了多种编程语言的示例代码&lt;a href=&quot;http://www.cnblogs.com/zzqit/p/demo/aes-sample.zip&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;返回数据格式&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;phoneNumber&quot;: &quot;13580006666&quot;&lt;span&gt;,  
    &lt;/span&gt;&quot;purePhoneNumber&quot;: &quot;13580006666&quot;&lt;span&gt;, 
    &lt;/span&gt;&quot;countryCode&quot;: &quot;86&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;watermark&quot;&lt;span&gt;:
    {
        &lt;/span&gt;&quot;appid&quot;:&quot;APPID&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;timestamp&quot;&lt;span&gt;:TIMESTAMP
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 小程序开发系列教程&lt;/strong&gt;&lt;a href=&quot;https://blog.csdn.net/michael_ouyang/article/details/54700871&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/michael_ouyang/article/details/54700871&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 07:36:00 +0000</pubDate>
<dc:creator>如何好听</dc:creator>
<og:description>最近在做小程序开发，在其中也遇到了很多的坑，获取小程序的手机号并绑定就遇到了一个很傻的坑。 流程介绍 官方流程图 小程序使用方法 需要将 &lt;button&gt; 组件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzqit/p/9983407.html</dc:identifier>
</item>
<item>
<title>1-1， 一个简单的mysql 安装教程，基于mysql 5.7解压版本. - 何锦彬</title>
<link>http://www.cnblogs.com/springsource/p/9983389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/springsource/p/9983389.html</guid>
<description>&lt;p&gt;下载mysql. 略，去官网&lt;/p&gt;

&lt;p&gt;1. 配置my.cnf. 把mysql提供的配置模板 copy到/etc/my.cnf&lt;/p&gt;
&lt;p&gt;（先读取/etc/my.cnf，再去读/etc/mysql/my.cnf，第三个读/$base_dir$/my.cnf）&lt;/p&gt;
&lt;p&gt;cp /usr/local/mysql-5.7.14/support-files/my-default.cnf /etc/&lt;/p&gt;

&lt;p&gt;2, 配置my.cnf&lt;/p&gt;
&lt;p&gt;basedir=/usr/local/mysql&lt;br/&gt;datadir=/data/mysql/data&lt;br/&gt;pid-file=/data/mysql/data/db.pid&lt;br/&gt;port= 3306&lt;br/&gt;server_id=1015127&lt;br/&gt;socket=/tmp/mysql.sock&lt;/p&gt;

&lt;p&gt;3, 设置base_dir&lt;/p&gt;
&lt;p&gt;短链过去，避免修改：&lt;/p&gt;
&lt;p&gt;ln -s /usr/local/mysql-5.7.14 /usr/local/mysql&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;4， 创建好mysql用于存放data的文件夹&lt;/p&gt;
&lt;p&gt;如 ：&lt;/p&gt;
&lt;p&gt;data文件夹 /data/mysql/data&lt;/p&gt;
&lt;p&gt;（这一步很重要，先创建好，再分配权限，不如由mysql 初始化自己生成的。不指定用户容易造成权限问题）&lt;/p&gt;

&lt;p&gt;5，mysql默认是用mysql用户进行运行的， 故需要创建并授权mysql用户与组（运行用户可以在my.cnf上修改，一般不修改）&lt;/p&gt;
&lt;p&gt;groupadd mysql&lt;/p&gt;
&lt;p&gt;useradd -r -g mysql mysql&lt;/p&gt;
&lt;p&gt;授权相应目录&lt;/p&gt;
&lt;p&gt;chown -R mysql:mysql /data/mysql/data&lt;/p&gt;
&lt;p&gt;chown -R mysql:mysql /usr/local/mysql&lt;/p&gt;

&lt;p&gt;6, 初始化&lt;/p&gt;
&lt;p&gt;mysqld --initialize --user=mysql&lt;/p&gt;
&lt;p&gt;user要带上，不然容易引起后面权限问题&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;[Note] A temporary password is generated for root&lt;a href=&quot;https://my.oschina.net/u/570656&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;@localhost&lt;/a&gt;: W*U.%Izer3J8&lt;/p&gt;
&lt;p&gt;记录好当前初始化的密码，登录时用到&lt;/p&gt;

&lt;p&gt;7，配置service的命令支持，&lt;/p&gt;
&lt;p&gt;cp support-files/mysql.server /etc/init.d/mysql&lt;/p&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;p&gt;service mysql start&lt;/p&gt;
&lt;p&gt;启动时，出现问题，大概率是文件权限问题， 查看 base的目录与pid目录，还有data目录是否有权限（分给mysql的）。如如果用root去initialize之后自己创建的data是没mysql的权限的,重复执行授权命令&lt;/p&gt;
&lt;p&gt;没问题的话，会出现&lt;/p&gt;
&lt;p&gt;Starting MySQL. SUCCESS! &lt;/p&gt;

&lt;p&gt;8, 第一次登录需要修改密码&lt;/p&gt;
&lt;p&gt;SET PASSWORD = PASSWORD('123456');&lt;/p&gt;

&lt;p&gt;9.授权远程管理，一般不会只在本机使用&lt;/p&gt;
&lt;p&gt;USE mysql;&lt;/p&gt;
&lt;p&gt;CREATE USER 'hejb'@'%' IDENTIFIED BY '123456'; //创建用户hejb ,密码123456的账户&lt;/p&gt;
&lt;p&gt;grant ALL on *.* to hejb@'%'; //授权所有&lt;/p&gt;
&lt;p&gt;flush privileges;&lt;/p&gt;

&lt;p&gt;OK, 可以远程连接成功了，可以尝试用navicat连接试试&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 07:34:00 +0000</pubDate>
<dc:creator>何锦彬</dc:creator>
<og:description>下载mysql. 略，去官网 1. 配置my.cnf. 把mysql提供的配置模板 copy到/etc/my.cnf （先读取/etc/my.cnf，再去读/etc/mysql/my.cnf，第三个读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/springsource/p/9983389.html</dc:identifier>
</item>
<item>
<title>Elasticsearch date 类型详解 - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/9983251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/9983251.html</guid>
<description>&lt;p&gt;一直对 elasticsearch 中的 date 类型认识比较模糊，而且在使用中又比较常见,这次决定多花些时间，彻底弄懂它，希望能对用到的同学提供帮助。&lt;/p&gt;
&lt;p&gt;注意：本文测试使用是 elasticsearch 6.3 版本，其他版本规则可能有所变化，如遇到不兼容的情况，还请参考 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;elasticsearch 数据是以 JSON 格式存储的，而 &lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9967865.html#json-%E7%9A%84%E8%AF%AD%E6%B3%95&quot;&gt;JSON&lt;/a&gt;中是并没有 &lt;em&gt;date&lt;/em&gt; 数据类型，因此 Elasticsearch 中虽然有 &lt;em&gt;date&lt;/em&gt; 类型，但在展示时却要转化成另外的格式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;date&lt;/em&gt; 类型在 Elasticsearch 展示的格式有下面几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将日期时间格式化后的字符串，如 &quot;2015-01-01&quot; 或者 &quot;2015/01/01 12:10:30&quot;&lt;/li&gt;
&lt;li&gt;long 型的整数，意义是 &lt;em&gt;milliseconds-since-the-epoch&lt;/em&gt;，翻译一下就是自 &lt;em&gt;1970-01-01 00:00:00 UTC&lt;/em&gt; 以来经过的毫秒数。&lt;/li&gt;
&lt;li&gt;int 型的整数，意义是 &lt;em&gt;seconds-since-the-epoch&lt;/em&gt;, 是指自 &lt;em&gt;1970-01-01 00:00:00 UTC&lt;/em&gt; 以来经过的秒数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后两种的描述里都包含 UTC ，什么是 UTC 呢？&lt;/p&gt;
&lt;p&gt;UTC(Universal Time Coordinated) 叫做世界统一时间，中国大陆和 UTC 的时差是 + 8 ,也就是 UTC+8。&lt;/p&gt;
&lt;p&gt;不论 date 是什么展示格式，在 Elasticsearch 内部存储时都是转换成 UTC，并且把时区也会计算进去，从而得到 &lt;em&gt;milliseconds-since-the-epoch&lt;/em&gt; 并作为存储的格式。&lt;/p&gt;
&lt;p&gt;在查询日期时，会执行下面的过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;转换成 long 整形格式的范围(range) 查询&lt;/li&gt;
&lt;li&gt;得到聚合的结果&lt;/li&gt;
&lt;li&gt;将结果中的 date 类型（long 整型数据）根据 date format 字段转换回对应的展示格式&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;date-的默认格式&quot;&gt;Date 的默认格式&lt;/h2&gt;
&lt;p&gt;Date 的格式化类型是可以通过 &lt;em&gt;format&lt;/em&gt; 来指定的，如果没有指定，就会使用默认的格式：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;strict_date_optional_time||epoch_millis&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示什么意思呢？&lt;/p&gt;
&lt;p&gt;先来弄懂 &lt;em&gt;strict_date_optional_time&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A generic ISO datetime parser where the date is mandatory and the time is&lt;br/&gt;optional. &lt;a href=&quot;http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateOptionalTimeParser--&quot;&gt;Full details here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 elasticsearch 官网的解释，表示只要是 ISO datetime parser 可以正常解析的都是 &lt;em&gt;strict_date_optional_time&lt;/em&gt;。都有哪些语法呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; date-opt-time     = date-element ['T' [time-element] [offset]]
 date-element      = std-date-element | ord-date-element | week-date-element
 std-date-element  = yyyy ['-' MM ['-' dd]]
 ord-date-element  = yyyy ['-' DDD]
 week-date-element = xxxx '-W' ww ['-' e]
 time-element      = HH [minute-element] | [fraction]
 minute-element    = ':' mm [second-element] | [fraction]
 second-element    = ':' ss [fraction]
 fraction          = ('.' | ',') digit+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中中括号内的都是可选的，可填可不填。以 &lt;em&gt;std-date_element&lt;/em&gt; 举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018-11-19
2018
2018-11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面 3 种格式都满足要求。&lt;/p&gt;
&lt;p&gt;除了 &lt;em&gt;strict_date_optional_time&lt;/em&gt; ，还可以是 epoch_millis 格式，即 epoch 以来的毫秒数。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: {
      &quot;properties&quot;: {
        &quot;date&quot;: {
          &quot;type&quot;: &quot;date&quot; 
        }
      }
    }
  }
}

PUT my_index/_doc/1
{ &quot;date&quot;: &quot;2015-01-01&quot; } 

PUT my_index/_doc/2
{ &quot;date&quot;: &quot;2015-01-01T12:10:30Z&quot; } 

PUT my_index/_doc/3
{ &quot;date&quot;: 1420070400001 } 

GET my_index/_search
{
  &quot;sort&quot;: { &quot;date&quot;: &quot;asc&quot;} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的 PUT 请求中的 date 数据均满足默认的要求。&lt;/p&gt;

&lt;p&gt;同一个 date 字段可以指定多个 date 格式，只要使用 &lt;code&gt;||&lt;/code&gt; 分隔就可以了。在索引，都会对 date 格式挨个进行匹配，直到找到匹配的格式为止。&lt;/p&gt;
&lt;p&gt;如果存储时 date 格式为 &lt;em&gt;milliseconds-since-the-epoch&lt;/em&gt; ，在查询时会将其转换为指定的第一个 date 格式。&lt;/p&gt;
&lt;p&gt;举个例子,有兴趣的同学可在 sense 中动手实践下。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;doc&quot;: {
      &quot;properties&quot;: {
        &quot;date&quot;: {
          &quot;type&quot;:   &quot;date&quot;,
          &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;
        }
      }
    }
  }
}


PUT /my_index/doc/1
{ &quot;date&quot;: &quot;2018-09-24 19:23:45&quot; }


PUT /my_index/doc/2
{ &quot;date&quot;: &quot;2018-09-25&quot; }

GET my_index/_search
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文主要讲解了 elsaticserach 中的 date 类型格式，语法及转换过程。elasticsearch 中存储 date 类型统一使用 &lt;em&gt;milliseconds-since-the-epoch&lt;/em&gt; 格式，展示时根据不同格式而区分。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.3/date.html&quot;&gt;elasticsearch Date datatype&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 19 Nov 2018 07:16:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>一直对 elasticsearch 中的 date 类型认识比较模糊，而且在使用中又比较常见,这次决定多花些时间，彻底弄懂它，希望能对用到的同学提供帮助。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/9983251.html</dc:identifier>
</item>
<item>
<title>【Three.js】实现随心所欲的展示外部三维模型 - 馨语随风</title>
<link>http://www.cnblogs.com/tracyjfly/p/9983192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tracyjfly/p/9983192.html</guid>
<description>

&lt;p&gt;    最近学习Three.js，尝试加载一些3d max导出的obj、stl模型，在展示模型的时候遇到了一些问题，模型的尺寸、位置和旋转角度每次都靠手工调整，非常的不方便，就想着写一个方法来随心所欲的控制模型的尺寸、位置、角度。&lt;/p&gt;


&lt;p&gt;        先看看官方加载外部模型的标准代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mtlLoader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.MTLLoader();
mtlLoader.load(mtlPath, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (materials) {
materials.preload();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.OBJLoader();
loader.setMaterials(materials);
loader.load(modelPath, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (obj) {


obj.castShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
obj.receiveShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;场景加载&lt;/span&gt;
&lt;span&gt;scene.add(obj);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渲染&lt;/span&gt;
&lt;span&gt;renderer.render(scene, camera);

}});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    通过以上代码，可以实现obj模型和mtl纹理的加载。但是在实际使用中，模型的尺寸和方向不是完美合适的，比如博主我在使用过程中就遇到了以下三个问题。&lt;/p&gt;

&lt;p&gt;    外部模型往往是3d max导出，模型的大小尺寸和实际中往往不一样。three.js 官方有&lt;span&gt;scale &lt;/span&gt;属性可以更改模型的尺寸比例，代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
obj.scale.set(x,y,z);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    现在问题来了，我知道的参数其实是模型的长、宽、高，并不是比例。解决的方法如下，先计算出模型的实际长宽高，转换成比例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算模型尺寸&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; box = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Box3();
box.expandByObject(obj);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length = box.max.x -&lt;span&gt; box.min.x;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width = box.max.z -&lt;span&gt; box.min.z;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height = box.max.y -&lt;span&gt; box.min.y;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l w h对应模型的长宽高&lt;/span&gt;
obj.scale.set(l / length, h / height, w / width);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;    和模型尺寸一样，外部模型的朝向和实际中有时候不同，有时候一种模型会在场景中有多个朝向的分布，例如办公室的椅子。还是先看看官方的方法&lt;span&gt;position&lt;/span&gt;属性可以设置模型x、y、z的转向。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
obj.position.set(angleX, angleY, angleZ);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    现在看起来是没有问题了，不过当你遇到一个模型中心点坐标和场景中心点坐标相差几百万单位的时候，估计旋转后连模型影子都看不见了...例如博主我遇到的下图这种模型参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.88gis.cn/webapi/Upload/GetPicFile?name=f0afb49f-6e92-44ce-a50d-7b2d6e5ccf83%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181119112512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如上图，模型本身只有78.5单位长，但是中心x坐标却是2219638.25，导致博主我硬是找了一下午没有加载出模型来。&lt;/p&gt;
&lt;p&gt;    在此感谢 &lt;a href=&quot;https://blog.csdn.net/ruangong1203/article/details/60476782&quot; target=&quot;_self&quot;&gt;&lt;span&gt;https://blog.csdn.net/ruangong1203/article/details/60476782&lt;/span&gt;&lt;/a&gt; 这篇博客给了我思路。解决方法是&lt;span&gt;&lt;strong&gt;增加一个容器，将模型放入容器中，然后指定容器的中心点，然后旋转容器代替旋转模型&lt;/strong&gt;&lt;/span&gt;即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let wrapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Object3D();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模型在场景中的为准&lt;/span&gt;
&lt;span&gt;wrapper.position.set(x,y,z);
wrapper.add(obj);

wrapper.rotation.set(angleX, angleY, angleZ);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;    模型的位置是最头痛的，three.js默认的以模型的中心偏移来定位的，同样看看官方的方法，有个&lt;span&gt;position&lt;/span&gt;属性可以更改模型位置。如果遇到问题二里面那种偏移超级远的模型就尴尬了。&lt;/p&gt;
&lt;p&gt;    我的解决思路是先计算出模型的实际尺寸，然后再找到模型的中心点，根据x=0,y=0,z=0将模型移动到正常位置，然后通过问题二的容器解决方法来重新设置容器位置解决。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算模型尺寸&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; box = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Box3();
box.expandByObject(obj);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = (box.max.x + box.min.x) / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = (box.max.y + box.min.y) / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; z = (box.max.z + box.min.z) / 2&lt;span&gt;;

obj.position.set(&lt;/span&gt;0 - x, 0 - y, 0 -&lt;span&gt; z);

obj.castShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
obj.receiveShadow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

let wrapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Object3D();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模型在场景中实际位置&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; pt={x:0,y:0,z:0&lt;span&gt;};
wrapper.position.set(pt.x, pt.y, pt.z);
wrapper.add(obj);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;放张效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/298768/201811/298768-20181119150242799-1029521761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    在线体验地址：&lt;a href=&quot;http://www.88gis.cn/plugins/dgis3d/pages/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;http://www.88gis.cn/plugins/dgis3d/pages/index.html&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　详细代码请移步我的&lt;a href=&quot;http://www.88gis.cn&quot; target=&quot;_blank&quot;&gt;个人博客88gis.cn&lt;/a&gt;查看更多。&lt;/p&gt;
&lt;p&gt;　　代码下载地址：&lt;a href=&quot;http://www.88gis.cn/web/pages/blog/blogInfo.html?id=c09488bc-ba36-4de1-90a7-5be618883b6d&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Nov 2018 07:05:00 +0000</pubDate>
<dc:creator>馨语随风</dc:creator>
<og:description>1.概要 最近学习Three.js，尝试加载一些3d max导出的obj、stl模型，在展示模型的时候遇到了一些问题，模型的尺寸、位置和旋转角度每次都靠手工调整，非常的不方便，就想着写一个方法来随心所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tracyjfly/p/9983192.html</dc:identifier>
</item>
<item>
<title>.net core使用RPC的方式进行高效的HTTP服务访问 - smark</title>
<link>http://www.cnblogs.com/smark/p/9983181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/9983181.html</guid>
<description>&lt;p&gt;传统的HTTP接口调用是一件比较繁琐的事情，特别是在Post数据的时候；不仅要拼访问的URL还是把数据序列化成流的方式给Request进行提交，获取Respons后还要对流进行解码。在实际应用虽然可以对&lt;code&gt;HttpClient&lt;/code&gt;进行一个简单的封装，一旦到了上层大量的API调用还是不方便和不好维护。但如果在不改变HTTP接口服务的情况可以通过RPC的方式来调用HTTP服务那在使用和修改上都会变得更简单和便于维护了； 接下来讲解一下如何使用&lt;code&gt;FastHttpApi&lt;/code&gt;通过接口描述的方式来访问HTTP接口服务！&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;引用组件&lt;/h3&gt;
&lt;p&gt;在这里简单地介绍一下&lt;code&gt;FastHttpApi&lt;/code&gt;，它是一个轻量级高性的能的HTTP通讯组件，除了可以构建高性的HTTP服务外，还可以通过它来实现基于RPC的方式来访问第三方HTTP服务。可以到&lt;a href=&quot;https://github.com/IKende/FastHttpApi&quot;&gt;GitHub&lt;/a&gt;了解。如果需要通过接口的方式访问通第三方HTTP服务，首先要在项目用引用&lt;code&gt;FastHttpApi&lt;/code&gt;,可以在Nuget上找到它，命令安装如下 &lt;code&gt;Install-Package BeetleX.FastHttpApi -Version 1.0.2.6&lt;/code&gt;也可以直接在VS中添加Nuget引用。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;使用组件&lt;/h3&gt;
&lt;p&gt;在定义接口前了解第三方的HTTP服务结构是必须的（当然如果选择&lt;code&gt;FastHttpApi&lt;/code&gt;构建webapi会得到一下更高效的性能支持），下面主要讲解通过组件定议接口来访问asp.net mvc api的接口服务，先看一下服务的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DateTime GetTime()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DateTime.Now;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Hello(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;Order&amp;gt; ListOrders(&lt;span&gt;int&lt;/span&gt; employee, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; customer)
        {
            Func&lt;/span&gt;&amp;lt;Order, &lt;span&gt;bool&lt;/span&gt;&amp;gt; exp = o =&amp;gt; (employee == &lt;span&gt;0&lt;/span&gt; || o.EmployeeID ==&lt;span&gt; employee)
           &lt;/span&gt;&amp;amp;&amp;amp; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(customer) || o.CustomerID ==&lt;span&gt; customer);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; DataHelper.Orders.Where(exp);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Employee GetEmployee(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            Employee result &lt;/span&gt;= DataHelper.Employees.Find(e =&amp;gt; e.EmployeeID ==&lt;span&gt; id);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddEmployee([FromBody] List&amp;lt;Employee&amp;gt;&lt;span&gt; items)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (items == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; items.Count;
        }
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Employee EditEmployee(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, [FromBody]Employee employee)
        {
            employee.EmployeeID &lt;/span&gt;=&lt;span&gt; id;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; employee;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pwd)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; pwd == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是一个简单的asp.net mvc api的代码，接下来用接口来描述对应调用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [JsonFormater]
    [Controller(BaseUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDataService
    {
        [Get]
        DateTime GetTime();
        [Get]
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Hello(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);
        [Get]
        IList&lt;/span&gt;&amp;lt;Order&amp;gt;&lt;span&gt; ListOrders();
        [Get]
        IList&lt;/span&gt;&amp;lt;Order&amp;gt; ListOrders(&lt;span&gt;int&lt;/span&gt; employee, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; customer);
        [Get]
        Employee GetEmployee(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        [Post]
        Employee EditEmployee([CQuery]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, Employee employee);
        [Get]
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Login(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pwd);
        [Post]
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; AddEmployee(&lt;span&gt;params&lt;/span&gt;&lt;span&gt; Employee[] items);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是非常简单，简单地通过接口方法就可以描述对应HTTP请求，为了达到更好的应用性还可以重载不同版本来访问同一服务接口，这样在使用的时候就变得更方便灵活。再往下看代码了解一下是如何使用这接口的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            HttpApiClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpApiClient(Host);

            IDataService service &lt;/span&gt;= client.CreateWebapi&amp;lt;IDataService&amp;gt;&lt;span&gt;();

            DateTime dt &lt;/span&gt;=&lt;span&gt; service.GetTime();

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get time:{dt}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; hello = service.Hello(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;henry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello :{hello}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orders = service.ListOrders(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orders != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list orders: {orders.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            orders &lt;/span&gt;=&lt;span&gt; service.ListOrders();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orders != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list orders: {orders.Count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; emp = service.GetEmployee(&lt;span&gt;7&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get employee id 7:{emp?.FirstName} {emp?.LastName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            emp &lt;/span&gt;= service.EditEmployee(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Employee { FirstName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, LastName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;henry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit employee :{emp.EmployeeID} {emp?.FirstName} {emp?.LastName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = service.AddEmployee(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add employee :{count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            count &lt;/span&gt;= service.AddEmployee(&lt;span&gt;new&lt;/span&gt; Employee { EmployeeID = &lt;span&gt;3&lt;/span&gt; }, &lt;span&gt;new&lt;/span&gt; Employee { EmployeeID = &lt;span&gt;5&lt;/span&gt;&lt;span&gt; });
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add employee :{count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; login = service.Login(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login status:{login}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先是定义一个&lt;code&gt;HttpApiClient&lt;/code&gt;对象指向一个服务地址，在这个代码里的访问地址是&lt;code&gt;http://localhost:8080&lt;/code&gt;;接下来就可以通过&lt;code&gt;HttpApiClient&lt;/code&gt;创建指定接口的操作对象，创建对象后就可以进行方法调用。那在多线程下是怎样处理呢？其实&lt;code&gt;HttpApiClient&lt;/code&gt;是线程安全的，所以不用担心多线程下的操作，对于网络连接处理则内部通过连接池实现。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;组件的优势和缺点&lt;/h2&gt;
&lt;p&gt;其实dotnet core已经存在这样一个功能的组件&lt;code&gt;Refit&lt;/code&gt;,它的功能比较完善支持的版本也比较多，而&lt;code&gt;FastHttpApi&lt;/code&gt;则只支持.net core.其实&lt;code&gt;FastHttpApi&lt;/code&gt;的定义是针对服务与服务之间的通讯，由于它是基于自有实现的一个轻量化'HttpClient'所以在性能上要出色于'Refit',还有内部集成了基于Host的连接池所以在处理性能和连接管理上相对有着自己的优势；而这些的特点更适合内部服务之间的通讯需求。以下是组件和&lt;code&gt;Refit&lt;/code&gt;的性能测试对比，由于网络间的延时会抵销具休处理的效率，所以测试是基于localhost进行，这样&lt;code&gt;BenchmarkDotNet&lt;/code&gt;的结果好反映实际代码情况，测试结果如下：&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;测试代码&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Benchmark]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RefitAddEmployee()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gitHubApi = Refit.RestService.For&amp;lt;IRefitEmployeeApi&amp;gt;&lt;span&gt;(Host);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; octocat =&lt;span&gt; gitHubApi.AddEmployee(Employee.GetEmployee());
                octocat.Wait();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; octocat.Result.EmployeeID;
            }
        }
        [Benchmark]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FastApiAddEmployee()
        {
            BeetleX.FastHttpApi.HttpApiClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeetleX.FastHttpApi.HttpApiClient(Host);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; api = client.CreateWebapi&amp;lt;IFastHttpEmployeeApi&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items =&lt;span&gt; api.AddEmployee(Employee.GetEmployee());
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; items.EmployeeID;
            }
        }
        [Benchmark]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RefitGetEmployees()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gitHubApi = Refit.RestService.For&amp;lt;IRefitEmployeeApi&amp;gt;&lt;span&gt;(Host);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; octocat = gitHubApi.ListEmployees(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                octocat.Wait();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; octocat.Result.Count;
            }
        }
        [Benchmark]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FastApiGetEmployees()
        {
            BeetleX.FastHttpApi.HttpApiClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeetleX.FastHttpApi.HttpApiClient(Host);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; api = client.CreateWebapi&amp;lt;IFastHttpEmployeeApi&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items = api.ListEmployees(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; items.Count;
            }
            client.Dispose();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;-&quot;&gt;测试结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VpXEdDN.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;code&gt;Refit&lt;/code&gt;采用静态编译的方式来处理请求，最终测试下来的结构还是&lt;code&gt;FastHttpApi&lt;/code&gt;代理调用有着更出色的性能优势。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;实际并发测试&lt;/h2&gt;
&lt;p&gt;由于对&lt;code&gt;Refit&lt;/code&gt;了解不深入所以并没有把它引入进来做多线程并发测试，接下来进行一个多线程的并发测试，测试的硬件是一台4核发的开发机作为测试服务器。服务测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [BeetleX.FastHttpApi.Controller(BaseUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; HttpApiServer mApiServer;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            mApiServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpApiServer();
            mApiServer.ServerConfig.WriteLog &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            mApiServer.ServerConfig.LogToConsole &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            mApiServer.ServerConfig.Port &lt;/span&gt;= &lt;span&gt;8007&lt;/span&gt;&lt;span&gt;;
            mApiServer.ServerConfig.LogLevel &lt;/span&gt;=&lt;span&gt; BeetleX.EventArgs.LogType.Warring;
            mApiServer.ServerConfig.UrlIgnoreCase &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            mApiServer.Register(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Program).Assembly);
            mApiServer.Open();
            Console.Write(mApiServer.BaseServer);
            Console.WriteLine(Environment.ProcessorCount);
            Console.Read();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResult(Employee.GetEmployees(count));
        }
        [Post]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Add(Employee item)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResult(item);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetTime()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResult(DateTime.Now);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试的服务并没有使用asp.net core作为服务，而是使用&lt;code&gt;FastHttpApi&lt;/code&gt;作为测试服务，主要原因是有着更轻量级的性能优势。接下是看一下测试结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
***********************************************************************
* https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/IKende/ConcurrentTest.git&lt;/span&gt;
* Copyright ? ikende.com &lt;span&gt;2018&lt;/span&gt;&lt;span&gt; email:henryfan@msn.com
&lt;/span&gt;*&lt;span&gt; ServerGC:True
&lt;/span&gt;***********************************************************************
*&lt;span&gt; AddEmployee test prepping completed
&lt;/span&gt;-----------------------------------------------------------------------
*                 [&lt;span&gt;10000000&lt;/span&gt;/&lt;span&gt;10000000&lt;/span&gt;]|threads:[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       Success:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[    &lt;span&gt;10000000&lt;/span&gt;][min:&lt;span&gt;60087&lt;/span&gt;/s  max:&lt;span&gt;82394&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;*         Error:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[           &lt;span&gt;0&lt;/span&gt;][min:&lt;span&gt;0&lt;/span&gt;/s  max:&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;-----------------------------------------------------------------------
*       0ms-&lt;span&gt;0&lt;/span&gt;.1ms:[          &lt;span&gt;203&lt;/span&gt;]    &lt;span&gt;0&lt;/span&gt;.1ms-&lt;span&gt;0&lt;/span&gt;.5ms:[    &lt;span&gt;9&lt;/span&gt;,&lt;span&gt;956&lt;/span&gt;,&lt;span&gt;907&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       &lt;span&gt;0&lt;/span&gt;.5ms-1ms:[       &lt;span&gt;15&lt;/span&gt;,&lt;span&gt;796&lt;/span&gt;]        1ms-5ms:[       &lt;span&gt;26&lt;/span&gt;,&lt;span&gt;184&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*        5ms-10ms:[          &lt;span&gt;681&lt;/span&gt;]      10ms-50ms:[           &lt;span&gt;70&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*      50ms-100ms:[            &lt;span&gt;1&lt;/span&gt;]   100ms-1000ms:[          &lt;span&gt;158&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*   1000ms-5000ms:[             ] 5000ms-&lt;span&gt;10000ms:[             ]
&lt;/span&gt;***********************************************************************

***********************************************************************
*&lt;span&gt; ListEmployees test prepping completed
&lt;/span&gt;-----------------------------------------------------------------------
*                 [&lt;span&gt;10000000&lt;/span&gt;/&lt;span&gt;10000000&lt;/span&gt;]|threads:[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       Success:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[    &lt;span&gt;10000000&lt;/span&gt;][min:&lt;span&gt;57709&lt;/span&gt;/s  max:&lt;span&gt;83524&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;*         Error:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[           &lt;span&gt;0&lt;/span&gt;][min:&lt;span&gt;0&lt;/span&gt;/s  max:&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;-----------------------------------------------------------------------
*       0ms-&lt;span&gt;0&lt;/span&gt;.1ms:[          &lt;span&gt;504&lt;/span&gt;]    &lt;span&gt;0&lt;/span&gt;.1ms-&lt;span&gt;0&lt;/span&gt;.5ms:[    &lt;span&gt;9&lt;/span&gt;,&lt;span&gt;978&lt;/span&gt;,&lt;span&gt;394&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       &lt;span&gt;0&lt;/span&gt;.5ms-1ms:[        &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;114&lt;/span&gt;]        1ms-5ms:[       &lt;span&gt;16&lt;/span&gt;,&lt;span&gt;732&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*        5ms-10ms:[           &lt;span&gt;98&lt;/span&gt;]      10ms-50ms:[            &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*      50ms-100ms:[           &lt;span&gt;20&lt;/span&gt;]   100ms-1000ms:[          &lt;span&gt;135&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*   1000ms-5000ms:[             ] 5000ms-&lt;span&gt;10000ms:[             ]
&lt;/span&gt;***********************************************************************

***********************************************************************
*&lt;span&gt; GetTime test prepping completed
&lt;/span&gt;-----------------------------------------------------------------------
*                 [&lt;span&gt;10000000&lt;/span&gt;/&lt;span&gt;10000000&lt;/span&gt;]|threads:[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       Success:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[    &lt;span&gt;10000000&lt;/span&gt;][min:&lt;span&gt;65740&lt;/span&gt;/s  max:&lt;span&gt;95669&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;*         Error:[      &lt;span&gt;0&lt;/span&gt;/s]|total:[           &lt;span&gt;0&lt;/span&gt;][min:&lt;span&gt;0&lt;/span&gt;/s  max:&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;s]
&lt;/span&gt;-----------------------------------------------------------------------
*       0ms-&lt;span&gt;0&lt;/span&gt;.1ms:[       &lt;span&gt;77&lt;/span&gt;,&lt;span&gt;060&lt;/span&gt;]    &lt;span&gt;0&lt;/span&gt;.1ms-&lt;span&gt;0&lt;/span&gt;.5ms:[    &lt;span&gt;9&lt;/span&gt;,&lt;span&gt;904&lt;/span&gt;,&lt;span&gt;465&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*       &lt;span&gt;0&lt;/span&gt;.5ms-1ms:[        &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;612&lt;/span&gt;]        1ms-5ms:[       &lt;span&gt;13&lt;/span&gt;,&lt;span&gt;510&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*        5ms-10ms:[          &lt;span&gt;173&lt;/span&gt;]      10ms-50ms:[           &lt;span&gt;31&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*      50ms-100ms:[             ]   100ms-1000ms:[          &lt;span&gt;149&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;*   1000ms-5000ms:[             ] 5000ms-&lt;span&gt;10000ms:[             ]
&lt;/span&gt;***********************************************************************
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端开启了20个线程同步调用服务，得到的结果峰值大概在8万每秒的http请求响应，这样的性能指标相信完全能满足普通业务的需求，毕竟这台测试服务用的只是一台5－6年前的4核PC机。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 07:04:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>传统的HTTP接口调用是一件比较繁琐的事情，特别是在Post数据的时候；不仅要拼访问的URL还是把数据序列化成流的方式给Request进行提交，获取Respons后还要对流进行解码。在实际应用虽然可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/9983181.html</dc:identifier>
</item>
<item>
<title>在WebGL场景中建立游戏规则 - ljzc002</title>
<link>http://www.cnblogs.com/ljzc002/p/9968301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljzc002/p/9968301.html</guid>
<description>&lt;p&gt;　　在前三篇文章的基础上，为基于Babylon.js的WebGL场景添加了类似战棋游戏的基本操作流程，包括从手中选择单位放入棋盘、显示单位具有的技能、选择技能、不同单位通过技能进行交互、处理交互结果以及进入下一回合恢复棋子的移动力。因为时间有限，这一阶段的目的只是实现基本规则的贯通，没有关注场景的美观性和操作的便捷性，也没有进行充分的测试。&lt;/p&gt;
&lt;p&gt;　　一、显示效果：&lt;/p&gt;
&lt;p&gt;1、访问https://ljzc002.github.io/CardSimulate2/HTML/TEST4rule.html查看“规则测试页面”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116094745994-35886754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;天空盒内有一个随机生成的棋盘（未来计划编写更复杂棋盘的生成方法），棋盘上有两个预先放置的棋子，屏幕中央是一个蓝色边框的准星。&lt;/p&gt;
&lt;p&gt;2、按alt键展开手牌，拉近手牌中的某个单位后会在屏幕左侧显示“落子”按钮，点击落子按钮后，准星将变为橙色边框（再按alt返回手牌可以将准星变回蓝色），在橙色准星状态下点击地块则可将选定的手牌放入棋盘，放入棋盘后（未来计划一个单位在手牌中以卡牌方式显示，放入棋盘后改为3D模型）立即显示棋子的移动范围，并且在屏幕的左上角显示棋子的状态和技能列表（计划优化这个表格的布局）。&lt;/p&gt;
&lt;p&gt;选中手牌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116105705639-778586171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准星变为橙色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116105907022-1522224735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;落子后显示移动范围和状态技能列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116110039805-438389610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了能用鼠标选取技能，这里调整了单位选取规则，现在只要选中单位，场景浏览方式就会从first_lock（鼠标锁定在屏幕中心）切换为first_pick（鼠标可以在屏幕中自由移动选取）以释放光标，取消单位选中后，自动切换回first_lock。&lt;/p&gt;
&lt;p&gt;鼠标移入技能单元格，显示技能的说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116110739722-2025466311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种状态下，点击红色范围外的地块或者按alt键或者点击棋子本身，都可以解除棋子的选中状态，并隐藏移动范围和技能列表。&lt;/p&gt;
&lt;p&gt;3、在移动棋子之后，棋子会从wait状态变为moved状态，如果棋子具备nattack（普通攻击）技能，将自动显示棋子的普通攻击范围；按alt键，在手牌菜单里点击“下一回合”，将把所有棋子恢复为wait状态（这里还需要一个明确的回合结束生效效果），并且增加需要冷却的技能的装填计数并减少持续时间有限的技能的持续时间（尚未测试）。&lt;/p&gt;
&lt;p&gt;完成移动之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116111730604-1992649288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右侧的Octocat正处于moved状态，它周围是nattack技能的释放范围（可以看到skill_current项显示为“nattack”，表示移动完成后默认选取了nattack技能），此时的Octocat不能再移动，可以通过点击没有遮罩的地块取消对他的选取。&lt;/p&gt;
&lt;p&gt;点击下一回合按钮后，再选中Octocat单位：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116112159106-1488427914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现Octocat又可以再次移动，并且冷却时间为2的test2技能进行了一次装填。&lt;/p&gt;
&lt;p&gt;4、单位移动完毕之后会自动选择nattack作为当前技能，或者在技能列表里点选技能做为当前技能（目前只完成了nattack的编写），选择完毕后会在单位周围用红色遮罩标示技能的释放范围，点击红色遮罩，则以绿色遮罩显示技能的影响范围。再次点击绿色遮罩，则在这个位置释放当前技能，释放技能时技能释放者和释放目标按顺序执行相应的动画效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116133422054-213497495.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、当单位的血量耗尽时，会变成灰色返回手牌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116134137798-1264488310.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在手牌的末尾能够看到灰色的Octocat，它无法被再次放入棋盘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181116134327545-795203508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、AOE技能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181119104157501-1141808630.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，技能范围内的单位都受到AOE影响&lt;/p&gt;
&lt;p&gt;7、说明：&lt;/p&gt;
&lt;p&gt;　　事实上，上面的游戏规则代码已经被前人用各种方式实现很多遍，可以说每一个成熟的游戏开发团队都有其精雕细琢的规则代码，但绝大部分这类代码都是闭源或者存在获取障碍的，因此我自己用JavaScript实现了这一套规则代码并把它开源。其实，Babylon.js的开发团队也在做类似的事情——将各种商业3D引擎的成熟技术移植到WebGL平台并开源。&lt;/p&gt;
&lt;p&gt;　　有人会问，花费很多精力用低效的方式做一个别人做过多次的“轮子”有什么用？确实，和成熟的商业3D引擎相比，WebGL技术在性能和操作性上还存在明显的缺陷，但WebGL技术的两个独有特性是传统商业引擎所无法比拟的：一是网页端应用的强制开源性，因为所有JavaScript代码最终都以明文方式在浏览器中执行，所以任何人都能够获取WebGL程序的代码并直接使用浏览器进行调试，这使得WebGL中用到的技术和知识可以不受垄断的自由传播；其二，JavaScript语言的学习难度和传统的3D开发语言C++不在同一量级，浏览器也为开发者解决了适配各种运行环境时遇到的诸多难题，WebGL技术的出现使得3D编程的入门前所未有的简单。&lt;/p&gt;
&lt;p&gt;　　对于拥有大量高端人才、以盈利为目的商业性游戏公司，强制开源和低技术门槛并没有太大意义，所以WebGL技术注定难以成为商业游戏开发的主流，但是对于不以盈利为目的的人士和非职业编程者来说WebGL技术正预示着一种新的、不受现有条框束缚的表达方式，而准确且丰富的表达正是人们相互理解进而平等相待的基础之一。使用WebGL技术，学生、教师、传统信息系统操作员乃至无法忍受劣质商业化游戏的玩家都可能做出兼具外在表象和内在逻辑的3D程序。&lt;/p&gt;
&lt;p&gt;二、代码实现：&lt;/p&gt;
&lt;p&gt;1、整理前面的代码：&lt;/p&gt;
&lt;p&gt;在编写规则代码之前，首先对https://www.cnblogs.com/ljzc002/p/9660676.html和https://www.cnblogs.com/ljzc002/p/9778855.html中建立的工程进行整理，经过整理后的js文件结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181119111509210-1003656706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先把BallMan、CameraMesh、CardMesh三个类分离到三个单独的js文件里，置于Character文件夹中，用以实例化场景中比较复杂的几种物体；&lt;/p&gt;
&lt;p&gt;接着把所有和键盘鼠标响应有关的代码放到Control.js中；&lt;/p&gt;
&lt;p&gt;FullUI.js里包含所有与Babylon.js GUI和Att7.js Table相关的内容；&lt;/p&gt;
&lt;p&gt;Game.js改动不大，仍起到全局变量管理的作用；&lt;/p&gt;
&lt;p&gt;HandleCard2.js里是和手牌有关的规则代码；&lt;/p&gt;
&lt;p&gt;Move.js是CameraMesh的移动控制方法；&lt;/p&gt;
&lt;p&gt;rule.js是一部分和场景初始化和GUI操作有关的规则代码；&lt;/p&gt;
&lt;p&gt;tab_carddata.js里是卡牌定义；&lt;/p&gt;
&lt;p&gt;tab_skilldata.js里是技能定义，并且包含了和技能有关的规则代码；&lt;/p&gt;
&lt;p&gt;tab_somedata.js里是一些其他定义；&lt;/p&gt;
&lt;p&gt;Tiled.js是和棋盘有关的规则代码。&lt;/p&gt;
&lt;p&gt;整理之后的部分文件内容如下：（只总结了前两篇文章里的内容）&lt;/p&gt;
&lt;p&gt;图一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181119113618063-972183941.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201811/657116-20181119113935798-1176614476.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中列出了每个文件中的属性和方法，大部分可以在前两篇文章中找到对应的说明，如果哪里没有说清，请在评论区留言。因为时间有限，新增加的规则代码并没有画入，因为手机性能有限，有些文字略显模糊。&lt;/p&gt;
&lt;p&gt;2、手牌管理：https://www.cnblogs.com/ljzc002/p/9660676.html&lt;/p&gt;
&lt;p&gt;3、从手牌放入棋盘：&lt;/p&gt;
&lt;p&gt;a、在FullUI.js中添加“落子”按钮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 1 var UiPanel2 = new&lt;span&gt; BABYLON.GUI.StackPanel();
 2         UiPanel2.width = &quot;220px&quot;&lt;span&gt;;
 3         UiPanel2.fontSize = &quot;14px&quot;&lt;span&gt;;
 4         UiPanel2.horizontalAlignment =&lt;span&gt; BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
 5         UiPanel2.verticalAlignment =&lt;span&gt; BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
 6         UiPanel2.color = &quot;white&quot;&lt;span&gt;;
 7 &lt;span&gt;        advancedTexture.addControl(UiPanel2);
 8         var button3 = BABYLON.GUI.Button.CreateSimpleButton(&quot;button3&quot;, &quot;落子&quot;&lt;span&gt;);
 9         button3.paddingTop = &quot;10px&quot;&lt;span&gt;;
10         button3.width = &quot;100px&quot;&lt;span&gt;;
11         button3.height = &quot;50px&quot;&lt;span&gt;;
12         button3.background = &quot;green&quot;&lt;span&gt;;
13         button3.isVisible=false&lt;span&gt;;//这个按钮默认不可见，选中并放大一张手牌后可见
14         button3.onPointerDownObservable.add(function&lt;span&gt;(state,info,coordinates) {
15             if(MyGame.init_state==1&amp;amp;&amp;amp;card_Closed&amp;amp;&amp;amp;card_Closed.workstate!=&quot;dust&quot;)//如果完成了场景的虚拟化
16 &lt;span&gt;            {
17                 Card2Chess();//将当前选中的手牌和光标关联起来，换回first_lock，并改变光标的颜色，点击空白地块时落下棋子，
18 &lt;span&gt;            }
19         });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; b、按下按钮后将准星颜色改为橙色（考虑更改准星形状？），在rule.js文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; Card2Chess()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前选中的手牌设为手中棋子&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     MyGame.player.centercursor.color=&quot;orange&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     MyGame.player.changePointerLock2(&quot;first_lock&quot;&lt;span&gt;);//将浏览方式改为first_lock
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     HandCard(1&lt;span&gt;);//经过动画隐藏手牌
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换回first_lock状态&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c、在准星边缘为橙色时点击地块，则把手牌转化为棋子放入棋盘里：&lt;/p&gt;
&lt;p&gt;首先在Tiled.js文件的PickTiled方法里响应地块点击：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(MyGame.player.centercursor.color==&quot;orange&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前是落子状态&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {//mesh是棋盘中的一个地块
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(card_Closed&amp;amp;&amp;amp;!TiledHasCard(mesh))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在选定的手牌并且点击的格子没有其他棋子，则把棋子放到这个格子里&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             Card2Chess2(mesh);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体代码在rule.js里&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             MyGame.player.centercursor.color==&quot;blue&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点已经有棋子的地方，则取消落子&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在rule.js里正式将棋子放入棋盘：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; Card2Chess2(mesh)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将手中棋子放在棋盘上&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(card_Closed.num_group&amp;gt;-1&amp;amp;&amp;amp;card_Closed.num_group&amp;lt;5&lt;span&gt;)//如果卡片在手牌的某个分组中
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {//从小组里删除
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; arr_cardgroup[card_Closed.num_group][card_Closed.mesh.name];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;if(Object.getOwnPropertyNames(arr_cardgroup[card.num_group]).length==0)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         arr_mesh_groupicon[card.num_group].isVisible=false;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     card_Closed.mesh.parent=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;//card_Closed是手牌中选中的对象，
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     card_Closed.mesh.parent=&lt;span&gt;mesh_tiledCard;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     card_Closed.mesh.scaling=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0.1,0.1,0.1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     card_Closed.mesh.position=mesh.position.clone();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;棋子放在地块位置。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     card_Closed.mesh.position.y=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     card_Closed.workstate=&quot;wait&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    noPicked(card_Closed);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     card_Closed2=&lt;span&gt;card_Closed;//将它设为棋盘中的一个棋子
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    card_Closed2.display();//将棋子设为可见
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    PickCard2(card_Closed2);//将它设为选中的棋子
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     card_Closed=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;//取消手牌中的选中对象
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     MyGame.player.centercursor.color=&quot;blue&quot;&lt;span&gt;;//准星重新变蓝
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、棋子移动：https://www.cnblogs.com/ljzc002/p/9778855.html&lt;/p&gt;
&lt;p&gt;5、选中棋子：&lt;/p&gt;
&lt;p&gt;a、HandleCard2.js文件中PickCard2方法以棋子对象为参数，用来在棋盘上选中棋子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; PickCard2(card)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击一下选中，高亮边缘，再点击也不放大？-》再点击则拉近镜头后恢复first_lock！！&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时还要在卡片附近建立一层蓝色或红色的半透明遮罩网格，表示移动及影响范围&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果再次点击有已选中卡片，则把相机移到卡片面前&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(card.isPicked)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        GetCardClose2(card);//将相机拉近到选中卡牌面前，并取消卡牌的选定
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//规定点击蓝色遮罩时计算到达路径，点击空处时清空范围，点击其他卡牌时切换范围，切换成手牌时清空范围&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;else//如果这个棋子没有被选中&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(card.workstate==&quot;wait&quot;&lt;span&gt;)//如果棋子正等待移动，则显示棋子的移动范围
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             DisplayRange(card);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里面包含了清除已有遮罩并且保证棋子的选中&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(card.workstate==&quot;moved&quot;&lt;span&gt;)//如果棋子已经移动，但还未工作
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先要检查是否有已经显示的遮罩&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr_DisplayedMasks.length&amp;gt;0&lt;span&gt;)//清空所有遮罩和棋子选定以及技能列表
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 HideAllMask();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里也会清空card_Closed2&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             card_Closed2=&lt;span&gt;card;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            getPicked(card_Closed2);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             card.isPicked=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(card_Closed2.skills[&quot;nattack&quot;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            {//如果这个单位具有普通攻击技能，则显示普通攻击范围
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 skill_current=card_Closed2.skills[&quot;nattack&quot;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果单位具有nattack技能&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 document.getElementById(&quot;str_sc&quot;).innerHTML=&quot;nattack&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 canvas.style.cursor=&quot;crosshair&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 DisplayRange2(card_Closed2,card_Closed2.skills[&quot;nattack&quot;].range);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认显示nattack技能的范围&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是worked则什么也不做-&amp;gt;还是要显示信息的&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(card.workstate==&quot;worked&quot;&lt;span&gt;)//如果已经工作过
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr_DisplayedMasks.length&amp;gt;0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 HideAllMask();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里也会清空card_Closed2&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             card_Closed2=&lt;span&gt;card;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            getPicked(card_Closed2);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             card.isPicked=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             document.getElementById(&quot;str_sc&quot;).innerHTML=&quot;Worked&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         MyGame.player.changePointerLock2(&quot;first_pick&quot;&lt;span&gt;);//如果棋子没有被选中，则浏览方式改为first_pick
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         DisplayUnitUI();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时也要显示棋子操纵ui-&amp;gt;这里使用html dom table&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、DisplayUnitUI方法显示当前选中棋子的技能列表，其代码位于FullUI.js文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; DisplayUnitUI()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MyGame.SkillTable&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(card_Closed2)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这时已经有选中的单位，则显示单位的效果列表&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         document.getElementById(&quot;all_base&quot;).style.display=&quot;block&quot;&lt;span&gt;;//使技能列表元素可见
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data=&lt;span&gt;MyGame.SkillTable.data;//获取技能列表的数据
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         data.splice(4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空旧的技能列表&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; card=&lt;span&gt;card_Closed2;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         document.getElementById(&quot;str_chp&quot;).innerHTML=&lt;span&gt;card.chp;//当前hp
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         document.getElementById(&quot;str_thp&quot;).innerHTML=&lt;span&gt;card.hp;//总hp
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         document.getElementById(&quot;str_cmp&quot;).innerHTML=&lt;span&gt;card.cmp;//当前mp
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         document.getElementById(&quot;str_tmp&quot;).innerHTML=&lt;span&gt;card.mp;//总mp
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         document.getElementById(&quot;str_atk&quot;).innerHTML=&lt;span&gt;card.attack;//攻击
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         document.getElementById(&quot;str_speed&quot;).innerHTML=&lt;span&gt;card.speed;//移动力
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;document.getElementById(&quot;str_range&quot;).innerHTML=card.range;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; skills=&lt;span&gt;card.skills;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt; skills)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历显示单位所有的技能&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skill=skills[key];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位现在具有的技能&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skill2=arr_skilldata[key];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;技能列表里的技能描述&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; str1=key,str2=&quot;full&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.last!=&quot;forever&quot;&lt;span&gt;)//如果不是永久持续，要在括号里显示持续时间
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 str1+=(&quot;(&quot;+skill.last+&quot;)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.reload!=&quot;full&quot;&lt;span&gt;)//如果没有装填完成，要显示装填进度
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 str2=skill.reload+&quot;/&quot;+&lt;span&gt;skill2.reloadp;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            data.push([str1
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                ,str2]);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         MyGame.SkillTable.draw(data,0&lt;span&gt;);//绘制表格
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         requestAnimFrame(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){MyGame.SkillTable.AdjustWidth();});
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的，DisposeUnitUI方法用来隐藏技能列表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; DisposeUnitUI()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     skill_current=&lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空当前选中的技能&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     document.getElementById(&quot;str_sc&quot;).innerHTML=&quot;&quot;&lt;span&gt;;//当前技能
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     canvas.style.cursor=&quot;default&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     arr_cardTarget=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空当前选择的技能目标&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     fightDistance=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(document.getElementById(&quot;div_thmask&quot;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除锁定表头的遮罩层&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; div =document.getElementById(&quot;div_thmask&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            div.parentNode.removeChild(div);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(document.getElementById(MyGame.SkillTable.id))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除表体&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tab =&lt;span&gt;document.getElementById(MyGame.SkillTable.id);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            tab.parentNode.removeChild(tab);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     document.getElementById(&quot;all_base&quot;).style.display=&quot;none&quot;&lt;span&gt;;//隐藏表格
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c、FullUI.js文件中还设置了技能列表的单元格的鼠标响应：&lt;/p&gt;
&lt;p&gt;鼠标移入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; SkillTableOver()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在鼠标移入时先隐藏可能存在的旧的描述文字，然后显示悬浮显示描述文字&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;SkillTableOver&quot;);&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; evt=evt||window.event||arguments[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    cancelPropagation(evt);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; obj=evt.currentTarget?&lt;span&gt;evt.currentTarget:evt.srcElement;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     delete_div(&quot;div_bz&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Open_div(&quot;&quot;, &quot;div_bz&quot;, 240, 120, 0, 0, obj, &quot;div_tab&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     document.querySelectorAll(&quot;#div_bz&quot;)[0].innerHTML = MyGame.SkillTable.html_onmouseover;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向弹出项里写入结构&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     document.querySelectorAll(&quot;#div_bz .div_inmod_lim_content&quot;)[0].innerHTML = card_Closed2.skills[obj.innerHTML.split(&quot;(&quot;)[0&lt;span&gt;]].describe;//显示描述文字
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鼠标移出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; SkillTableOut()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标移出时隐藏所有描述文字&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;SkillTableOut&quot;);&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; evt=evt||window.event||arguments[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    cancelPropagation(evt);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     delete_div(&quot;div_bz&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击技能单元格：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; SkillTableClick()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击时触发技能的eval&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; evt=evt||window.event||arguments[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    cancelPropagation(evt);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; obj=evt.currentTarget?&lt;span&gt;evt.currentTarget:evt.srcElement;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     delete_div(&quot;div_bz&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(card_Closed2.workstate!=&quot;worked&quot;&lt;span&gt;)//如果单位还没有进行工作
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; skillName=obj.innerHTML.split(&quot;(&quot;)[0&lt;span&gt;];//从单元格中提取技能名
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(card_Closed2.cmp&amp;gt;=&lt;span&gt;card_Closed2.skills[skillName].cost)//如果有足够的mp
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             skill_current=&lt;span&gt;card_Closed2.skills[skillName];//skill_current表示当前技能对象
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             document.getElementById(&quot;str_sc&quot;).innerHTML=&lt;span&gt;skillName;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(&quot;SkillTableClick&quot;);&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要显示这个技能的释放范围&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_DisplayedMasks.length;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)//隐藏已有的遮罩
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 arr_DisplayedMasks[i].material=MyGame.materials.mat_alpha_null;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个数组里存的真的只是遮罩&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             arr_DisplayedMasks=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             canvas.style.cursor=&quot;crosshair&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            DisplayRange2(card_Closed2,skill_current.range);//在单位周围显示当前技能的释放范围
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、显示当前技能的影响范围，并查找范围内的可能目标：&lt;/p&gt;
&lt;p&gt;a、在Tiled.js中响应地块点击事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(skill_current!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)//如果当前技能不为空
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(mesh.mask.material.name == &quot;mat_alpha_red&quot;&lt;span&gt;)//如果点击的是红色遮罩
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有选择的单位和技能，点击红色遮罩,则先清空已选择目标，以点击位置为中心显示绿色遮罩群表示瞄准，如果瞄准范围内存在单位，则放入target&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     arr_cardTarget=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_DisplayedMasks.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)//隐藏所有遮罩
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         arr_DisplayedMasks[i].material=&lt;span&gt;MyGame.materials.mat_alpha_null;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     arr_DisplayedMasks=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     DisplayRange2(card_Closed2,skill_current.range);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新显示一次释放范围&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                     DisplayRange3(mesh);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据当前技能，在瞄准地块周围显示绿色遮罩群表示影响范围，要先调用一次DisplayRange2，&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(mesh.mask.material.name == &quot;mat_alpha_green&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {//如果点击的是绿色遮罩
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (card_Closed2.workstate == &quot;wait&quot;||card_Closed2.workstate == &quot;moved&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    {//如果单位还没有工作
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         card_Closed2.cmp-=&lt;span&gt;skill_current.cost;//消耗mp
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         document.getElementById(&quot;str_cmp&quot;).innerHTML=&lt;span&gt;card_Closed2.cmp;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        eval(skill_current.eval);//执行技能效果
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         fightDistance=arr_noderange3[mesh.name].cost;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fight双方的距离&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HideAllMask();&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MyGame.player.changePointerLock2(&quot;first_lock&quot;);&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击影响范围外的点&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    HideAllMask();//取消选中
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     MyGame.player.changePointerLock2(&quot;first_lock&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、DisplayRange3方法的参数是地块的网格，表示在这个地块释放当前选中技能时的影响范围：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; DisplayRange3(mesh)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var card=card_Closed2;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; range=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     range=&lt;span&gt;skill_current.range2;//range2是技能的影响范围，注意不要和释放范围range混淆
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　//算法和前两个名称类似的方法相似
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; node_start=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     arr_noderange3=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     arr_noderange3[node_start.name]={cost:0&lt;span&gt;,path:[node_start.name],node:node_start};
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; costg=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var range=card.range;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; list_noderange=&lt;span&gt;[node_start];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;list_noderange.length;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_node_neighbor=&lt;span&gt;FindNeighbor(list_noderange[i]);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_node_neighbor.length;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             costg=&lt;span&gt;arr_noderange3[list_noderange[i].name].cost;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             costg+=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(costg&amp;gt;&lt;span&gt;range)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为影响范围的cost都是相同的，所以只要有一个邻居超过限度，则所有邻居都不可用&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有超限&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; nextnode =&lt;span&gt; arr_node_neighbor[j];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; path2=&lt;span&gt;arr_noderange3[list_noderange[i].name].path.concat();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            path2.push(nextnode.name);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr_noderange3[nextnode.name])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果以前曾经到达这个节点&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(arr_noderange3[nextnode.name].cost&amp;gt;costg)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里还是否有必要计算路径？？&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     arr_noderange3[nextnode.name]=&lt;span&gt;{cost:costg,path:path2,node:nextnode};
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 arr_noderange3[nextnode.name]=&lt;span&gt;{cost:costg,path:path2,node:nextnode};
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                list_noderange.push(nextnode);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arr_noderange3)//对于每一个绿色遮罩的地块
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if(arr_noderange3[key].cost&amp;gt;0)&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             arr_noderange3[key].node.mask.material=&lt;span&gt;MyGame.materials.mat_alpha_green;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh_unit =&lt;span&gt; TiledHasCard(arr_noderange3[key].node);//如果这个绿色地块中存在单位
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(mesh_unit)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果瞄准范围内存在一个单位，从理论上说也可能是自己！！！！&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                arr_cardTarget.push(mesh_unit.card);//则把这个单位放入目标列表
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        arr_DisplayedMasks.push(arr_noderange3[key].node.mask);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、执行技能效果：&lt;/p&gt;
&lt;p&gt;a、在tab_skilldata.js文件中定义了技能的eval属性，它是以字符串形式存储的可执行代码，以普通攻击技能为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;nattack:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         name:&quot;nattack&quot;
&lt;span&gt; 4&lt;/span&gt;         ,ap:&quot;a&quot;
&lt;span&gt; 5&lt;/span&gt;         ,start:&quot;wait&quot;
&lt;span&gt; 6&lt;/span&gt;         ,end:&quot;worked&quot;
&lt;span&gt; 7&lt;/span&gt;         ,reloadp:0
&lt;span&gt; 8&lt;/span&gt;         ,range:1
&lt;span&gt; 9&lt;/span&gt;         ,range2:0
&lt;span&gt;10&lt;/span&gt;         ,cost:0
&lt;span&gt;11&lt;/span&gt;         ,eval:&quot;func_skills.nattack()&quot;
&lt;span&gt;12&lt;/span&gt;         ,describe:&quot;普通攻击，是默认的影响方式&quot;
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
其中，ap属性是“主被动标记”，取值范围如下：&lt;br/&gt;a主动、p被动，p_all在所有环节生效，p_param影响单位属性，p_work在工作环节生效，p_next在点击下一回合时生效，p_weak在下一回合开始时生效（与p_next等效？），p_sleep在工作结束后立即生效，p_destoryed在被破坏时生效，p_beattack被影响时生效
&lt;/pre&gt;
&lt;p&gt;b、nattack方法的代码在下面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; nattack:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()//一次普通攻击行为
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_cardTarget.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var count_ani=0&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(len&amp;gt;0&lt;span&gt;)//如果目标数大于零
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             MyGame.flag_view=&quot;first_ani&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             card_Closed2.count_ani=&lt;span&gt;len;//动画计数器，认为每一个目标都有一系列的技能流程，
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }//这一次行为中的所有技能流程都结束，这个行为才结束。
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)//对于每一个目标，认为普通攻击只会有一个目标！
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; target=&lt;span&gt;arr_cardTarget[i];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(target.mesh.id==card_Closed2.mesh.id)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;规定自己不能nattack自己？？&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                func_skills.ani_final();//什么也不做，结束这个技能流程
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skills=&lt;span&gt;card_Closed2.skills;//当前选中棋子的技能列表
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skillst=&lt;span&gt;target.skills;//目标的技能列表
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            func_skills.beforeFight(target,skills,skillst);//执行一些在fight开始前生效的被动技能
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;超多层function嵌套，有没有更先进的解决方法？开始进入回调地狱&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             card_Closed2.ani_beat(target,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){//撞击动画
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 target.chp-=&lt;span&gt;card_Closed2.attack;//技能目标的当前hp减少量等于选中棋子的攻击力
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 target.ani_floatstr(&quot;-&quot;+card_Closed2.attack,[],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){//文字上浮动画
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(target.chp&amp;gt;0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果目标还活着&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(skillst[&quot;nattack&quot;])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果target具备nattack能力则反击之&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                             target.ani_beat(card_Closed2,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                                 card_Closed2.chp-=&lt;span&gt;target.attack;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                                 card_Closed2.ani_floatstr(&quot;-&quot;+target.attack,[],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt;(card_Closed2.chp&amp;gt;0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                                         document.getElementById(&quot;str_chp&quot;).innerHTML=&lt;span&gt;card_Closed2.chp;//更新当前hp显示
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                         card_Closed2.workstate=&quot;worked&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                                        func_skills.ani_final(target,skills,skillst);//结束这个技能流程
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                                    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                                        func_skills.unitDestory(card_Closed2,skills,skillst);//抢救
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                                    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                });
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                            });
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         card_Closed2.workstate=&quot;worked&quot;&lt;span&gt;;//当前状态为工作完毕
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        func_skills.unitDestory(target,skills,skillst);//在target死前检查有没有可以自救的被动技能
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(target.range&amp;gt;=fightDistance)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在target的nattack范围内&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;card_Closed2.chp-=target.attack;&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为要等到一个动画环节（比如撞击）结束后才能进行下一个环节（比如上浮伤害数字），所以需要把后一个环节的调用放在前一个环节的回调函数里，有人认为这种连续回调环节很多时程序会非常难以阅读，故将这种情况称为“回调地狱”，但是我感觉还好。&lt;/p&gt;
&lt;p&gt;c、ani_final方法用来结束行为中的一个流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; ani_final:&lt;span&gt;function&lt;/span&gt;(target,skills,skillst)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在所有效果动画结束后恢复为first_lock&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         card_Closed2.count_ani--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(card_Closed2.count_ani&amp;lt;=0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设一个aoe有多个回调线路，要确保每个回调线路都结束，再判定动作结束&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             /*&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(target)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {//如果目标还活着
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                func_skills.afterFight(target,skills,skillst);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }*/
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            HideAllMask();//动作结束解除所有锁定
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             MyGame.player.changePointerLock2(&quot;first_lock&quot;&lt;span&gt;);//
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d、unitDestory方法会查看单位是否有自救技能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; unitDestory:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(target,skills,skillst)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; skillst)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skill=&lt;span&gt;skillst[key];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.ap==&quot;p_destoryed&quot;&amp;amp;&amp;amp;&lt;span&gt;skill.eval)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 eval(skill.eval);&lt;span&gt;//如果有自救能力则&lt;/span&gt;&lt;span&gt;跳到另一个效果方法里，nattack的效果则终结&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(target.chp&amp;lt;=0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没抢救过来&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             target.ani_destory(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){//执行死亡动画
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                func_skills.ani_final(target,skills,skillst);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8、为单位建立动画：&lt;/p&gt;
&lt;p&gt;在CardMesh.js文件里为卡牌型单位建立了几种简单的行为动画&lt;/p&gt;
&lt;p&gt;a、撞击目标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面计划要添加震动方法和被破坏方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; CardMesh.prototype.ani_beat=&lt;span&gt;function&lt;/span&gt;(target,callback)&lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     mesh.animations=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; animation=&lt;span&gt;new&lt;/span&gt; BABYLON.Animation(&quot;animation&quot;,&quot;position&quot;,30&lt;span&gt;,BABYLON.Animation.ANIMATIONTYPE_VECTOR3,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos1=&lt;span&gt;mesh.position.clone();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos2=&lt;span&gt;target.mesh.position.clone();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; keys=[{frame:0,value:pos1},{frame:15,value:pos2},{frame:30&lt;span&gt;,value:pos1}];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    animation.setKeys(keys);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    mesh.animations.push(animation);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     scene.beginAnimation(mesh, 0, 30, &lt;span&gt;false&lt;/span&gt;,1,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        callback();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、向目标发射一个“子弹”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; CardMesh.prototype.ani_fire=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(target,cursor,callback)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个精灵对象（或者是粒子对象？），让它飞向目标&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; sprite_bullet=&lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;sprite_bullet&quot;, cursor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cursor是MyGame.SpriteManager&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     sprite_bullet.parent=&lt;span&gt;mesh.parent;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     sprite_bullet.position =&lt;span&gt;mesh.position.clone();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     sprite_bullet.position.y+=2
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; animation=&lt;span&gt;new&lt;/span&gt; BABYLON.Animation(&quot;animation&quot;,&quot;position&quot;,30&lt;span&gt;,BABYLON.Animation.ANIMATIONTYPE_VECTOR3,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos1=&lt;span&gt;sprite_bullet.position.clone();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos2=&lt;span&gt;target.mesh.position.clone();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; keys=[{frame:0,value:pos1},{frame:30&lt;span&gt;,value:pos2}];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    animation.setKeys(keys);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    sprite_bullet.animations.push(animation);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     scene.beginAnimation(sprite_bullet, 0, 30, &lt;span&gt;false&lt;/span&gt;,1,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        sprite_bullet.dispose();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        callback();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c、一个从单位身上飘起的字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; CardMesh.prototype.ani_floatstr=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(str,styles,callback)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个基于canvas纹理的对象，让它飘起来然后消失&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     str+=&quot;&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面如果传来的是数字，则取不到length！！-》显示转换为字符串&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; size_x=str.length*30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh_str = &lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateGround(&lt;span&gt;this&lt;/span&gt;.name + &quot;mesh_str&quot;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         width: size_x/2.5,
&lt;span&gt; 8&lt;/span&gt;         height: 16
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }, scene);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     mesh_str.parent=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh_str.position =new BABYLON.Vector3(0,0,0);&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     mesh_str.renderingGroupId = 3;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这些文字是特别强调内容，使用最高级的渲染组&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mat_str = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&lt;span&gt;this&lt;/span&gt;.name + &quot;mat_str&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; texture_str = &lt;span&gt;new&lt;/span&gt; BABYLON.DynamicTexture(&lt;span&gt;this&lt;/span&gt;.name + &quot;texture_str&quot;&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        width: size_x,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         height: 40
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }, scene);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     mat_str.diffuseTexture =&lt;span&gt; texture_str;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     mesh_str.material =&lt;span&gt; mat_str;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     mesh_str.rotation.x = -Math.PI / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     mesh_str.isPickable = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     texture_str.hasAlpha=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     mat_str.useAlphaFromDiffuseTexture=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;经过测试发现，在Chrome中canvas的绘图是以图像的左上角定位的，而文字绘制则是以文字的左下角定位的！！！！&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; context_comment =&lt;span&gt; texture_str.getContext();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     context_comment.fillStyle = &quot;rgba(255,255,255,0)&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;transparent&quot;;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     context_comment.fillRect(0, 0, size_x, 40&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;context_comment.fillStyle = &quot;#ffffff&quot;;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     context_comment.fillStyle = &quot;#ff0000&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     context_comment.font = &quot;bold 30px monospace&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;styles.length;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         context_comment[styles[i][0]]=styles[i][1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;newland.canvasTextAutoLine(str, context_comment, 1, 30, 35, 34);&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     context_comment.fillText(str,0,30&lt;span&gt;);//y坐标偏离一个字高
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    texture_str.update();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; animation=&lt;span&gt;new&lt;/span&gt; BABYLON.Animation(&quot;animation&quot;,&quot;position&quot;,30&lt;span&gt;,BABYLON.Animation.ANIMATIONTYPE_VECTOR3,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var pos1=mesh_str.position.clone();&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var pos2=mesh_str.position.clone();&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pos2.y+=2;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; keys=[{frame:0,value:&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,0,0)},{frame:30,value:&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,20,0&lt;span&gt;)}];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    animation.setKeys(keys);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    mesh_str.animations.push(animation);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     scene.beginAnimation(mesh_str, 0, 30, &lt;span&gt;false&lt;/span&gt;,1,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        mesh_str.dispose();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        mat_str.dispose();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        texture_str.dispose();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        callback();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;d、单位变成黑白色，然后升天&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; CardMesh.prototype.ani_destory=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(callback)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先换成灰白色图片，然后上浮&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.workstate=&quot;dust&quot;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mat_dust = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&lt;span&gt;this&lt;/span&gt;.name + &quot;mat_dust&quot;, &lt;span&gt;this&lt;/span&gt;.scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试用卡片纹理&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     mat_dust.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&lt;span&gt;this&lt;/span&gt;.imagedust, &lt;span&gt;this&lt;/span&gt;.scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现已经准备好了黑白色的图片，可以用MakeDust.html工具生成&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     mat_dust.diffuseTexture.hasAlpha = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     mat_dust.backFaceCulling = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     mat_dust.useLogarithmicDepth = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//使用对数式深度缓存&lt;/span&gt;&lt;span&gt;避免“Z-fighting”&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    mat_dust.freeze();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.mesh_mainpic.material =&lt;span&gt; mat_dust;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; animation=&lt;span&gt;new&lt;/span&gt; BABYLON.Animation(&quot;animation&quot;,&quot;position&quot;,30&lt;span&gt;,BABYLON.Animation.ANIMATIONTYPE_VECTOR3,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos1=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh.position.clone();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos2=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh.position.clone();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     pos2.y+=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; keys=[{frame:0,value:pos1},{frame:30&lt;span&gt;,value:pos2}];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    animation.setKeys(keys);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     mesh.animations=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    mesh.animations.push(animation);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     scene.beginAnimation(mesh, 0, 30, &lt;span&gt;false&lt;/span&gt;,1,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把dust的card收回手牌&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        noPicked(mesh.card);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         mesh.parent=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         mesh.parent=&lt;span&gt;mesh_arr_cards;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         mesh.scaling=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0.1,0.1,0.1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         mesh.rotation.y=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         mesh.card.num_group==999&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        mesh.card.dispose();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        callback();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;e、单位跳动一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; CardMesh.prototype.ani_shake=&lt;span&gt;function&lt;/span&gt;(callback)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上下晃动一下&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mesh;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     mesh.animations=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; animation=&lt;span&gt;new&lt;/span&gt; BABYLON.Animation(&quot;animation&quot;,&quot;position&quot;,30&lt;span&gt;,BABYLON.Animation.ANIMATIONTYPE_VECTOR3,BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos1=&lt;span&gt;mesh.position.clone();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; pos2=&lt;span&gt;mesh.position.clone();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     pos2.y+=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; keys=[{frame:0,value:pos1},{frame:15,value:pos2},{frame:30&lt;span&gt;,value:pos1}];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    animation.setKeys(keys);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    mesh.animations.push(animation);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     scene.beginAnimation(mesh, 0, 30, &lt;span&gt;false&lt;/span&gt;,1,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        callback();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9、AOE&lt;/p&gt;
&lt;p&gt;同时攻击多个目标意味着要同时开启多个回调流程，修改一下上面的nattack方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; aoe:&lt;span&gt;function&lt;/span&gt;(range2,atk,isSafe,arr_state)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;造成aoe伤害，参数：影响距离、攻击力、是否会伤害本方、[[给目标添加的效果1、生效的概率、持续的时间],[],[]]&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_cardTarget.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(len&amp;gt;0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             MyGame.flag_view=&quot;first_ani&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             card_Closed2.count_ani=len;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有几个目标，就设置几个动画计数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         card_Closed2.ani_shake(&lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己先晃动一下表示发出aoe&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skills=&lt;span&gt;card_Closed2.skills;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             func_skills.beforeFight(&lt;span&gt;null&lt;/span&gt;,skills,{})&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果下面的target使用var类型变量，因为js的变量提升特性，前面的target也会被自动声明！！，但是let并不具备变量提升功能！！！！&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {//这里要使用let型变量，否则所有的target变量都会被设为最后定义的target导致程序出错
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 let target=&lt;span&gt;arr_cardTarget[i];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(isSafe&amp;amp;&amp;amp;target.belongto==card_Closed2.belongto)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是安全aoe则跳过本方单位&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    func_skills.ani_final();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; skillst=&lt;span&gt;target.skills;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;func_skills.beforeFight(target,{},skillst);&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 target.chp-=&lt;span&gt;atk;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 target.ani_floatstr(&quot;-&quot;+atk,[],&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(target.chp&amp;gt;0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还活着&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;arr_state.length;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len2;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; state=&lt;span&gt;arr_state[j]
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(newland.RandomBool(state[1]))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果通过概率判定&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;(skillst[state[0]])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经有这一效果，则延长持续时间&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                     skillst[state[0]].last+=state[2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                                 &lt;span&gt;else//否则添加这个效果&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                                     skillst[state[0]]={last:state[2],reload:&quot;full&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        func_skills.ani_final(target,skills,skillst);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                        func_skills.unitDestory(target,skills,skillst);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(card_Closed2.workstate!=&quot;dust&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 document.getElementById(&quot;str_chp&quot;).innerHTML=&lt;span&gt;card_Closed2.chp;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 card_Closed2.workstate=&quot;worked&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10、进入下一回合：&lt;/p&gt;
&lt;p&gt;a、在FullUI.js中添加“下一回合”按钮：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; button4 = BABYLON.GUI.Button.CreateSimpleButton(&quot;button4&quot;, &quot;下一回合&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         button4.paddingTop = &quot;10px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         button4.width = &quot;100px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         button4.height = &quot;50px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         button4.background = &quot;green&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         button4.isVisible=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         button4.onPointerDownObservable.add(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(state,info,coordinates) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(MyGame.init_state==1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果完成了场景的虚拟化&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 NextRound();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有棋子的状态变为wait，特殊状态的除外&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        UiPanel2.addControl(button4);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         UiPanel2.buttonnextr=button4;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、NextRound方法位于rule.js文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; NextRound()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将所有棋子的状态置为wait（后续添加对特殊状态的处理）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; units=&lt;span&gt;mesh_tiledCard._children;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;units.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)//对于棋盘上的每个棋子
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; unit=&lt;span&gt;units[i];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         card_Closed2=&lt;span&gt;unit;//选中这个单位
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; skills=unit.card.skills;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新每个reload和last的技能时间，还要令回合结束时的被动技能生效&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; skills)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skill=&lt;span&gt;skills[key];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; skill2=&lt;span&gt;arr_skilldata[key];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.ap==&quot;p_next&quot;&lt;span&gt;)//对于每一个在跨越回合时生效的被动技能
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(skill.eval)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    eval(skill.eval);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.reload!=&quot;full&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 skill.reload++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(skill.reload&amp;gt;=skill2.reloadp)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果装填完毕&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     skill.reload=&quot;full&quot;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(skill.last!=&quot;forever&quot;&amp;amp;&amp;amp;skill.ap!=&quot;p_wake&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 skill.last--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(skill.last&amp;lt;=0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果持续时间结束&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(skill.eval2)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                        eval(skill.eval2);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;delete&lt;/span&gt; skills[key];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除这个效果&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             unit.card.workstate=&quot;wait&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;for(var key in skills)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            if(skill.ap==&quot;p_wake&quot;)//p_wake的是触发式的状态，它的last由技能自身控制？
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                if(skill.eval)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                    eval(skill.eval);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                    skill.last--;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                    if(skill.last==0)//如果持续时间结束
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                        if(skill.eval2)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                            eval(skill.eval2);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                        delete skills[key];//删除这个效果
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     card_Closed2=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;//解除选定
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是现在的进入下一回合还缺少足够醒目的回合提示。&lt;/p&gt;
&lt;p&gt;这样就完成了一个最基础的类似战棋游戏的操作流程，因为时间有限只介绍了主干代码，更多的细节还需要通过调试获取。目前还没有声音、AI和网络的设定，未来应该会添加WebSocket多人联网功能和Babylon.js内置的3D音效功能，但AI很难说。&lt;/p&gt;











</description>
<pubDate>Mon, 19 Nov 2018 06:55:00 +0000</pubDate>
<dc:creator>ljzc002</dc:creator>
<og:description>在前三篇文章的基础上，为基于Babylon.js的WebGL场景添加了类似战棋游戏的基本操作流程，包括从手中选择单位放入棋盘、显示单位具有的技能、选择技能、不同单位通过技能进行交互、处理交互结果以及进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljzc002/p/9968301.html</dc:identifier>
</item>
<item>
<title>微信小程序-自定义下拉刷新 - 【艾伦】</title>
<link>http://www.cnblogs.com/aaronjs/p/9982708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaronjs/p/9982708.html</guid>
<description>&lt;p&gt;最近给别个公司做技术支持，要实现微信小程序上拉刷新与下拉加载更多&lt;/p&gt;
&lt;p&gt;微信给出的接口不怎么友好，最终想实现效果类似QQ手机版 ，一共3种下拉刷新状态变化，文字+图片+背景颜色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/329084/201811/329084-20181119134225480-398786091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/329084/201811/329084-20181119134241364-1811474403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最终实现后的效果(这里提示有个不同点就是，自定义了导航条，并且下拉的时候，自定义导航条必须固定）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/329084/201811/329084-20181119134532815-1451293037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;小程序实现下拉加载2种方式：&lt;/p&gt;
&lt;p&gt;1. 简单粗暴，直接开启enablePullDownRefresh，开启全局下拉刷新&lt;/p&gt;
&lt;p&gt;2.利用scroll-view组件&lt;/p&gt;

&lt;p&gt;简单分析下2种方式的利与弊&lt;/p&gt;
&lt;p&gt;enablePullDownRefresh方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：简单粗暴，兼容性没问题&lt;/li&gt;
&lt;li&gt;缺点1: 只能配置背景颜色，没有图片与状态提示的变化。&lt;/li&gt;
&lt;li&gt;缺点2: 最重要的一点，如果自定义了导航条即使采用fixed定位，整个导航条还是会随页面一起往下拉动，整个布局效果非常变扭。这才是我放弃的最终原因（参考最终效果图，自定义了导航条）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;scroll-view方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：可以自定义(参考最终效果图)&lt;/li&gt;
&lt;li&gt;缺点：安卓与微信存在不同的兼容问题，所以针对2套平台要有2套处理方式，比较麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;enablePullDownRefresh的方式没啥好说的，按照文档的来。&lt;/p&gt;

&lt;p&gt;scroll-view方式的就比较麻烦了，首先说下引起问题的2个因素点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义了导航条&lt;/li&gt;
&lt;li&gt;IOS上有橡皮筋效果，安卓没有&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自定义了导航条，那么页面的布局一定要减去这个导航条的占位，所以scroll-view包裹的区域，一定会有一个定位处理，top的定位距离就是导航条的高度。&lt;/p&gt;

&lt;p&gt;IOS上scroll-view的实现原理&lt;/p&gt;
&lt;p&gt;IOS默认存在橡皮筋效果那么意味着就会有反弹反馈，元素滚动一定会有scrollTop的变化，那么利用scrollTop的变化就能很好的实现&lt;/p&gt;
&lt;p&gt;为了滚动的性能最大优化，所以默认都是用系统自带滚动，并不会做控制页面内容本身的滑动&lt;/p&gt;
&lt;p&gt;布局的时候，原来的滚动内容部分用scroll-view包装，并且在之前加上下拉刷新的展示区域view，利用translateY把scroll-view的top设置为负值(展示区域的高度)，这样就把下拉的显示区域拼接到了scroll-view之前，并且还看不到&lt;/p&gt;
&lt;p&gt;在下拉scroll-view的时候，由于ios支持橡皮筋效果，所以scrollTop为负值的时候，展示区域自动会随着scrollTop的递减而出现。&lt;/p&gt;
&lt;p&gt;状态的与图片的变化，可以通过监听scroll事件，通过scrollTop值的变化，做出相应的改变。当然这里还会有scrolltolower与touchend事件，要知道什么时候松手后触发刷新，并且刷新之后还要设置还原&lt;/p&gt;

&lt;p&gt;安卓上scroll-view的实现原理&lt;/p&gt;
&lt;p&gt;安卓就这样，没有反弹效果，所以scrollTop也不会有负数。这时候只能靠手动移动页面模拟反弹了。&lt;/p&gt;
&lt;p&gt;安卓上需要对scroll-view绑定 start，move，end，scroll，upper事件，要监听用户的页面操作，当然如果是正常滚动内容的时候，不影响，也不做任何处理，一旦用户是下拉刷新操作，才介入&lt;/p&gt;
&lt;p&gt;页面的布局也是由下拉刷新的展示区域+包裹内容的scroll-view区域组成，不同于ios布局的就是，下拉刷新区域默认高度是0，scroll-view也不需要设置translateY负值了，需要下拉的时候调整展示区域的高度&lt;/p&gt;
&lt;p&gt;通过lower事件判断是边界，如果下拉越界，那么通过move控制scroll-view区域整体的往下滑动同时控制下拉刷新区域的高度变化，这样就实现了下拉的效果&lt;/p&gt;
&lt;p&gt;最后在end中，判断下移动的距离跟刷新的高度对比，从而更改下拉的状态与图片，并且触发刷新请求，最后可以动画复位&lt;/p&gt;

&lt;p&gt;封装&lt;/p&gt;
&lt;p&gt;一般这种功能直接做成组件就好了，ios与安卓可以独立2个组件，然后注册到一个中介的组件中，判断调用哪个，这样比较好维护。&lt;/p&gt;
&lt;p&gt;组件内部可以分成3部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;view 下拉刷新区域
slot 内容的slot区域
view 上拉加载更多区域&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过注意一点，slot一定要加高度，加高度。因为ios默认是反弹，滚动的，如果没有内容，或者内容高度不足，没撑开全部，那么就会触发默认滚动，页面的导航条会上下移动&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;view style=&quot;min-height:100%;&quot;&amp;gt;
  &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;结尾：&lt;/p&gt;
&lt;p&gt;由于自定义了导航条，引起了一堆的问题出来，说不上好与坏，反正遇到问题总是要想办法解决的。&lt;/p&gt;
&lt;p&gt;这里简单的记录下，给初入小程序的当个借鉴吧。可能我也有处理不对的，或者有更好的方法，可以给下建议。&lt;/p&gt;
&lt;p&gt;代码部分如果有需要，等有空了，我就分离出来发一份咯。&lt;/p&gt;

</description>
<pubDate>Mon, 19 Nov 2018 06:52:00 +0000</pubDate>
<dc:creator>【艾伦】</dc:creator>
<og:description>最近给别个公司做技术支持，要实现微信小程序上拉刷新与下拉加载更多 微信给出的接口不怎么友好，最终想实现效果类似QQ手机版 ，一共3种下拉刷新状态变化，文字+图片+背景颜色 最终实现后的效果(这里提示有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaronjs/p/9982708.html</dc:identifier>
</item>
<item>
<title>单例模式 创建型 设计模式（六） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9982869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9982869.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;单例模式 Singleton&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;单例就是单一实例， only you  只有一个&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;保证一个类仅有一个实例，并且提供一个访问他的全局访问点&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;单例模式的含义简单至极，复杂的是如何能够保障你真的只是创建了一个实例&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;怎样才能保证一个类只有一个实例，并且这个实例对象还易于被访问？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以借助于全局变量，但是类就在那里，你不能防止实例化多个对象，可能一不小心谁就创建了一个对象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以通常的做法是让类自身负责保存他的唯一实例，通过构造方法私有阻止外部实例对象，并且提供静态公共方法 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以常说的单例模式有下面三个特点&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单例模式的类，只能有一个实例对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单例模式的类，自身创建自己唯一的实例对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单例模式的类，必须提供获取这一唯一实例的方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181119141250952-293279001.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Singleton模式的结构简单，实现的步骤一般是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自身创建并且保存维护这个唯一实例，并且这个唯一实例singleton  是私有的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将构造方法设置为私有，防止创建实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置公共的getInstance（）方法获取实例，而且，这个方法&lt;span&gt;&lt;strong&gt;必然是静态的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;单例类自身负责创建维护唯一实例，按照实例对象创建的时机，分为两类 &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;饿汉式：实例在类加载时创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;懒汉式：实例在第一次使用时创建&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;饿汉式&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/11.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EagerSingleton {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EagerSingleton() {
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EagerSingleton singleton = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EagerSingleton();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; EagerSingleton getInstance() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当类加载时，静态成员singleton 会被初始化，对象在此时被创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;饿汉式的缺点很明显：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果初始化的太早，可能就会造成资源浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在虚拟机相关的文章中，有介绍过，&lt;span&gt;&lt;strong&gt;虚拟机的实现会保证：类加载会确保类和对象的初始化方法在多线程场景下能够正确的同步加锁&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，&lt;span&gt;&lt;strong&gt;饿汉式不必担心同步问题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果对于该对象的使用也是“饿汉式”的，也就是应用程序总是会高频使用，应该优先考虑这种模式 &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;懒汉式&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/11.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazySingleton {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazySingleton() {
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleton singleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance() {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个简单的懒汉式实现方式如上&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;静态singleton 初始为null &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次通过getInstance（）获取时，如果为null，那么创建一个实例，否则就直接返回已存在的实例singleton&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述代码在单线程下是没有问题的，但是在多线程场景下，需要同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如两个线程都执行到if (singleton == null) ，都判断为空&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么接下来两个线程都会创建对象，就无法保证唯一实例&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以可以给方法加上&lt;span&gt;&lt;strong&gt;synchronized&lt;/strong&gt;&lt;/span&gt;关键字，变为同步方法&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance() {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果内部逻辑不像上面这般简单，可以根据实际情况使用&lt;span&gt;&lt;strong&gt;同步代码块&lt;/strong&gt;&lt;/span&gt;的形式，比如&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance() {
&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LazySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
  }
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步的效率问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程并发场景，并不是必然出现的，只是在第一次创建实例对象时才会出现，概率非常小  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是使用同步方法或者同步代码块，则会百分百的进行同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步就意味着也就是如果多个线程执行到同一地方，其余线程将会等待 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样虽然可以防止创建多个实例，但是有明显的效率问题 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;既然同步问题是小概率的，那么就可以尝试降低同步的概率&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;54&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/11.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazySingleton {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazySingleton() {
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; LazySingleton singleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance() {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LazySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
}
}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的方式被称为 &lt;span&gt;&lt;strong&gt;双重检查&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如果singleton不为空，那么直接返回唯一实例，不会进行同步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如果singleton为空，那么涉及到对象的创建，此时，才会需要同步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只会有一个线程进入同步代码块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他会校验是否的确为null，然后进行实例对象的创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既解决了同步问题，又没有严重的效率问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原子操作问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机中不会因为线程调度被打断的操作，也就是不可分割的操作，被称作原子操作 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以理解为计算机对指令的执行的最小单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如 i=1；这就是一个原子操作，要么1被赋值给变量i，要么没有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果是int i = 1；这就不是一个原子操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他至少需要先创建变量i 然后在进行赋值运算&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们实例创建语句，就不是一个原子操作&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;singleton = new LazySingleton();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他可能需要下面三个步骤&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;分配对象需要的内存空间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将singleton指向分配的内存空间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用构造函数来初始化对象&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;计算机为了提高执行效率，会做的一些优化，在不影响最终结果的情况下，可能会对一些语句的执行顺序进行调整 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是上面三个步骤的顺序是不能够保证唯一的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果先分配对象需要的内存，然后将singleton指向分配的内存空间，最后调用构造方法初始化的话 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假如当singleton指向分配的内存空间后，此时被另外线程抢占（&lt;span&gt;由于不是原子操作所以可能被中间抢占）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程二此时执行到第一个if (singleton == null)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时不为空，那么不需要等待线程1结束，直接返回singleton了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，此时的singleton都还没有完全初始化，就被拿出去使用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根本问题就在于写操作未结束，就进行了读操作&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可以给 singleton 的声明加上volatile关键字，来解决这些问题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可以保障在完成写操作之前，不会调用读操作&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;

&lt;p&gt;&lt;span&gt;完整代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; singleton;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/11.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazySingleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazySingleton() {
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; LazySingleton singleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; LazySingleton getInstance() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (LazySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (singleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                singleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazySingleton();
                }
            }
        }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;内部类的懒汉式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面的这段代码，可以在实际项目中直接使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，双重检查不免看起来有些啰嗦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有其他的实现方式&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;内部类是延时加载的，也就是说只会在第一次使用时加载&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;内部类不使用就不加载的特性，非常适合做单例模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; singleton;
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/11.
* Description:
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;
&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton() {
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingletonHolder {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Singleton INSTANCE = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SingletonHolder.INSTANCE;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SingletonHolder作为静态内部类，内部持有一个Singleton实例，采用“饿汉式”创建加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过内部类在使用时才会被加载&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;私有的静态内部类，只有在getInstance被调用的时候，才会加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时才会创建实例，所以，从整体效果看是懒汉式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不使用不会加载，节省资源开销，也不需要复杂的代码逻辑 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;依靠类的初始化保障线程安全问题，依靠内部类特性实现懒加载&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;枚举单例&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;《Effective Java》中提到过枚举针对于单例的应用&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181119141322973-343628837.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;是否只是需要一个实例，是由业务逻辑决定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一些对象本质业务逻辑上就只是需要一个 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如线程池，windows的任务管理器，计算机的注册表管理器等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机中只需要一个任务管理器，不需要也没必要分开成多个，一个任务管理器管理所有任务简单方便高效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果qq一个任务管理器idea一个任务管理器，你受得了么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，是否需要单例模式，完全根据你的业务场景决定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，如果当你需要一个全局的实例变量时，单例模式或许就是一种很好的解决方案&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于单例模式在内存中只有一个实例，减少了内存开支和系统的性能开销&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;单例模式与单一职责模式有冲突&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;承担了实例的创建和逻辑功能提供两种职责&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例模式中没有抽象层，所以&lt;span&gt;&lt;strong&gt;单例类的扩展比较困难&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例模式的选用跟业务逻辑息息相关，比如系统只需要一个实例对象时，就可以考虑使用单例模式 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单例模式的重点在于单例的唯一性的保障实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以直接复制上面的代码使用&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;单例模式向多个实例的扩展&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;单例模式的意图是“保证一个类仅有一个实例，并且提供一个访问他的全局访问点” &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;单例模式的根本逻辑就是限制实例个数，并且个数限制为1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;所以，可以仍旧限制实例个数，并且将限制个数设置为大于等于1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种单例模式的扩展，又被称之为多例模式&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;多例模式下可以创建多个实例&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;多例模式自己创建、管理自己的实例，并向外界提供访问方式获取实例&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;多例模式其实就是单例模式的自然扩展，同单例模式一样，也肯定需要构造方法私有，多例类自己维护等，唯一不同就是实例个数扩展为多&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;自定义类加载器时的问题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在虚拟机相关的介绍中有详细介绍了类加载机制与命名空间以及类加载机制的安全性问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的类加载器维护了各自的命名空间，他们是相互隔离的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的类加载器可能会加载同一个类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果这种事情发生在单例模式上，系统中就可能存在不止一个实例对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管在不同的命名空间中是隔离的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是在整个应用中就是不止一个，所以如果你自定义了类加载器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你就需要小心，你可以指定同样的类加载器以避免这个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有自定义类加载器则不需要关心这个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义的类都会使用内置的  应用程序   类加载器进行加载&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 19 Nov 2018 06:29:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>单例模式是常用的创建型设计模式之一，单例模式的含义比较简单，重点在于实现保证。本文介绍了单例模式的意图，结构，以及java实现，介绍了内部类的单例模式与枚举单例模式，以及使用中常见的问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9982869.html</dc:identifier>
</item>
<item>
<title>mysql基础架构之查询语句执行流程 - 小佬頭</title>
<link>http://www.cnblogs.com/GeekHuman/p/9982940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GeekHuman/p/9982940.html</guid>
<description>&lt;p&gt;这篇笔记主要记录mysql的基础架构，一条查询语句是如何执行的。&lt;/p&gt;
&lt;p&gt;比如，在我们从student表中查询一个id=2的信息&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from student where id=2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在解释这条语句执行流程之前，我们看看mysql的基础架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1505284/201811/1505284-20181119142617939-836534168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图来自极客时间的mysql实践,该图是描述的是MySQL的逻辑架构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;server层包括连接器、查询缓存、分析器、优化器、执行器涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视等。&lt;/li&gt;
&lt;li&gt;存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory 等多个存储引擎，平常我们比较常用的是innoDB引擎&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1505284/201811/1505284-20181119142629048-411127160.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;连接器&quot;&gt;连接器&lt;/h2&gt;
&lt;p&gt;我们在使用数据库之前，需要连接到数据库，连接语句是&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;mysql -h $ip -u $username -p $password&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们的连接器就是处理这个过程的，连接器的主要功能是&lt;strong&gt;负责跟客户端建立连接、获取权限、维持和管理连接&lt;/strong&gt;，连接器在使用的过程中如果该用户的权限改变，是不会马上生效的，因为用户权限是在连接的时候读取的，只能重新连接才可以更新权限&lt;/p&gt;
&lt;p&gt;连接器与客户端通信的协议是&lt;code&gt;tcp&lt;/code&gt;协议的，连接以后可以使用&lt;code&gt;show processlist;&lt;/code&gt;看到执行的连接数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.averagejoe.wang/2018-11-18-15425515586291.jpg?imageMogr2/auto-orient/thumbnail/400x400%3E/blur/1x0/quality/75%7Cwatermark/2/text/5bCP5L2s6aCtOkdlZWtIdW1hbg==/font/5qW35L2T/fontsize/400/fill/IzEwQTUwQQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时在连接时间内超过8小时是sleep的状态会自动断开，这个是mysql默认设置，如果一直不断开，那么这个过程可以叫做一个&lt;strong&gt;长连接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与之对应的有&lt;strong&gt;短连接&lt;/strong&gt;，短连接是指在执行一条或几条的以后断开连接。&lt;/p&gt;
&lt;p&gt;当不断使用长连接的时候会占用很大的内存资源，在mysql5.7以后可以使用&lt;code&gt;mysql_reset_connection&lt;/code&gt;语句来重新初始化资源。&lt;/p&gt;
&lt;h2 id=&quot;查询缓存&quot;&gt;查询缓存&lt;/h2&gt;
&lt;p&gt;经过连接以后，就连接上数据库了，这个时候可以执行语句了。&lt;/p&gt;
&lt;p&gt;执行语句的时候，mysql首先是去查询缓存，之前有没有执行过这样的语句，mysql会将之前执行过的&lt;strong&gt;语句和结果&lt;/strong&gt;以&lt;code&gt;key-value&lt;/code&gt;的形式存储起来（当然有一定的存储和实效时间）。如果存在缓存，则直接返回缓存的结果。&lt;/p&gt;
&lt;p&gt;缓存的工作流程是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务器接收SQL，以SQL和一些其他条件为key查找缓存表&lt;/li&gt;
&lt;li&gt;如果找到了缓存，则直接返回缓存&lt;/li&gt;
&lt;li&gt;如果没有找到缓存，则执行SQL查询，包括原来的SQL解析，优化等。&lt;/li&gt;
&lt;li&gt;执行完SQL查询结果以后，将SQL查询结果缓存入缓存表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，如果这个表修改了，那么使用这个表中的所有缓存将不再有效，查询缓存值得相关条目将被清空。所以在一张被反复修改的表中进行语句缓存是不合适的，因为缓存随时都会实效，这样查询缓存的命中率就会降低很多，不是很划算。&lt;/p&gt;
&lt;p&gt;当这个表正在写入数据，则这个表的缓存（命中缓存，缓存写入等）将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交前都会处于失效状态，在这个事务提交前，这个表的相关查询都无法被缓存。&lt;/p&gt;
&lt;p&gt;一般来说，如果是一张静态表或者是很少变化的表就可以进行缓存，这样的命中率就很高。&lt;/p&gt;
&lt;p&gt;下面来说说缓存的使用时机，衡量打开缓存是否对系统有性能提升是一个很难的话题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过缓存命中率判断, 缓存命中率 = 缓存命中次数 (&lt;code&gt;Qcache_hits&lt;/code&gt;) / 查询次数 (&lt;code&gt;Com_select&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;通过缓存写入率, 写入率 = 缓存写入次数 (&lt;code&gt;Qcache_inserts&lt;/code&gt;) / 查询次数 (&lt;code&gt;Qcache_inserts&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;通过 命中-写入率 判断, 比率 = 命中次数 (&lt;code&gt;Qcache_hits&lt;/code&gt;) / 写入次数 (&lt;code&gt;Qcache_inserts&lt;/code&gt;), 高性能MySQL中称之为比较能反映性能提升的指数,一般来说达到3:1则算是查询缓存有效,而最好能够达到10:1&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;分析器&quot;&gt;分析器&lt;/h2&gt;
&lt;p&gt;在查询缓存实效或者是无缓存的时候，这个时候MySQL的server就会利用分析器来分析语句，分析器也叫解析器。&lt;/p&gt;
&lt;p&gt;MySQL分析器由两部分组成，第一部分是用来词法分析扫描字符流,根据构词规则识别单个单词，MySQL使用Flex来生成词法扫描程序在sql/lex.h中定义了MySQL关键字和函数关键字,用两个数组存储；第二部分的功能是语法分析在词法分析的基础上将单词序列组成语法短语,最后生成语法树,提交给优化器语法分析器使用&lt;code&gt;Bison,在sql/sql_yacc.yy&lt;/code&gt;中定义了语法规则。然后根据关系代数理论生成语法树。&lt;/p&gt;
&lt;p&gt;上面解释分析器太官方和复杂了，其实分析器主要是用来进行“词法分析”然后知道这个数据库语句是要干嘛，代表啥意思。&lt;/p&gt;
&lt;p&gt;这个时候如果分析器分析出这个语句有问题的时候会报错，比如&lt;code&gt;ERROR 1064 (42000): You have an error in your SQL syntax&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;优化器&quot;&gt;优化器&lt;/h2&gt;
&lt;p&gt;在分析器分析完了以后知道这个语句是干嘛的时候，接下来是专门用一个优化器进行语句优化，优化器的任务是发现执行SQL查询的最佳方案。大多数查询优化器，包括MySQL的查询优化器，总或多或少地在所有可能的查询评估方案中搜索最佳方案。&lt;/p&gt;
&lt;p&gt;优化器主要是选择一个最佳的执行方案，执行方案是为了减少开销，提高执行效率。&lt;/p&gt;
&lt;p&gt;MySQL的优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）&lt;/li&gt;
&lt;li&gt;优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）&lt;/li&gt;
&lt;li&gt;提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）&lt;/li&gt;
&lt;li&gt;优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略而已。&lt;/p&gt;
&lt;h2 id=&quot;执行器&quot;&gt;执行器&lt;/h2&gt;
&lt;p&gt;在分析器知道语句要干什么，优化器知道怎么做以后，下面就到了执行的阶段，执行是交给执行器的。&lt;/p&gt;
&lt;p&gt;执行器在执行的时候首先判断该用户对该表有没有执行权限，如果没有则会返回&lt;code&gt;denied&lt;/code&gt;之类的错误提示。&lt;/p&gt;
&lt;p&gt;如果有权限，则会打开表继续执行。打开表的时候，执行器会根据表定义的引擎，去使用该引擎的接口。&lt;/p&gt;
&lt;p&gt;最后执行语句得到数据返回给客户端。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;MySQL得到sql语句后，大概流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0.连接器负责和客户端进行通信&lt;/li&gt;
&lt;li&gt;1.查询缓存：首先查询缓存看是否存在k-v缓存&lt;/li&gt;
&lt;li&gt;2.解析器：负责解析和转发sql&lt;/li&gt;
&lt;li&gt;3.预处理器：对解析后的sql树进行验证&lt;/li&gt;
&lt;li&gt;4.优化器：得到一个执行计划&lt;/li&gt;
&lt;li&gt;5.查询执行引擎：执行器执行语句得到数据结果集&lt;/li&gt;
&lt;li&gt;6.将数据放回给调用端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1505284/201811/1505284-20181119142640605-377693995.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Nov 2018 06:25:00 +0000</pubDate>
<dc:creator>小佬頭</dc:creator>
<og:description>这篇笔记主要记录mysql的基础架构，一条查询语句是如何执行的。 比如，在我们从student表中查询一个id=2的信息 在解释这条语句执行流程之前，我们看看mysql的基础架构。 图来自极客时间的m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GeekHuman/p/9982940.html</dc:identifier>
</item>
<item>
<title>【SpringCloud】Zuul在何种情况下使用Hystrix - Trust_FreeDom</title>
<link>http://www.cnblogs.com/trust-freedom/p/9982680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/trust-freedom/p/9982680.html</guid>
<description>&lt;p&gt;首先，引入&lt;code&gt;spring-cloud-starter-zuul&lt;/code&gt;之后会间接引入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/677054/201811/677054-20181119133859754-1263932195.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;hystrix依赖已经引入，那么何种情况下使用hystrix呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Zuul的自动配置类&lt;code&gt;ZuulServerAutoConfiguration&lt;/code&gt;和&lt;code&gt;ZuulProxyAutoConfiguration&lt;/code&gt;中总共会向Spring容器注入3个Zuul的RouteFilter，分别是&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;SimpleHostRoutingFilter&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;简单路由，通过HttpClient向预定的URL发送请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生效条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RequestContext.getCurrentContext().getRouteHost() != null&lt;br/&gt;​ &amp;amp;&amp;amp; RequestContext.getCurrentContext().sendZuulResponse()&lt;/p&gt;
&lt;p&gt;1、RequestContext中的routeHost不为空，routeHost就是URL，即使用URL直连&lt;/p&gt;
&lt;p&gt;2、RequestContext中的sendZuulResponse为true，即是否将response发送给客户端，默认为true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;RibbonRoutingFilter&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;使用Ribbon、Hystrix和可插入的http客户端发送请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生效条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(RequestContext.getRouteHost() == null &amp;amp;&amp;amp; RequestContext.get(SERVICE_ID_KEY) != null&lt;br/&gt;​ &amp;amp;&amp;amp; RequestContext.sendZuulResponse())&lt;/p&gt;
&lt;p&gt;1、RequestContext中的routeHost为空，即URL为空&lt;/p&gt;
&lt;p&gt;2、RequestContext中的serviceId不为空&lt;/p&gt;
&lt;p&gt;3、RequestContext中的sendZuulResponse为true，即是否将response发送给客户端，默认为true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;SendForwardFilter&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;forward到本地URL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生效条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RequestContext.containsKey(FORWARD_TO_KEY)&lt;br/&gt;​ &amp;amp;&amp;amp; !RequestContext.getBoolean(SEND_FORWARD_FILTER_RAN, false)&lt;/p&gt;
&lt;p&gt;1、RequestContext中包含FORWARD_TO_KEY，即URL使用 &lt;em&gt;forward:&lt;/em&gt; 映射&lt;/p&gt;
&lt;p&gt;2、RequestContext中SEND_FORWARD_FILTER_RAN为false，SEND_FORWARD_FILTER_RAN意为“send forward是否运行过了”，在SendForwardFilter#run()时会&lt;code&gt;ctx.set(SEND_FORWARD_FILTER_RAN, true)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;综上所述，在使用serviceId映射的方法路由转发的时候，会使用Ribbon+Hystrix&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;而哪种路由配置方式是“URL映射”，哪种配置方式又是“serviceId映射”呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Zuul有一个前置过滤器&lt;code&gt;PreDecorationFilter&lt;/code&gt;用于通过&lt;code&gt;RouteLocator路由定位器&lt;/code&gt;决定在何时以何种方式路由转发&lt;/p&gt;
&lt;p&gt;RouteLocator是用于通过请求地址匹配到Route路由的，之后&lt;code&gt;PreDecorationFilter&lt;/code&gt;再通过Route信息设置RequestContext上下文，决定后续使用哪个RouteFilter做路由转发&lt;/p&gt;
&lt;p&gt;所以就引出以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;什么是Route&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RouteLocator路由定位器如何根据请求路径匹配路由&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匹配到路由后，PreDecorationFilter如何设置RequestContext请求上下文&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Route&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我总共见到两个和Route相关的类&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ZuulProperties.ZuulRoute&lt;/code&gt;，用于和zuul配置文件关联，保存相关信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.cloud.netflix.zuul.filters.Route&lt;/code&gt;， RouteLocator找到的路由信息就是这个类，用于路由转发&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class ZuulRoute {
    private String id;    //ZuulRoute的id
    private String path;  //路由的pattern，如 /foo/**
    private String serviceId;  //要映射到此路由的服务id
    private String url;   //要映射到路由的完整物理URL
    private boolean stripPrefix = true;  //用于确定在转发之前是否应剥离此路由前缀的标志位
    private Boolean retryable;  //此路由是否可以重试，通常重试需要serviceId和ribbon
    private Set&amp;lt;String&amp;gt; sensitiveHeaders = new LinkedHashSet(); //不会传递给下游请求的敏感标头列表
    private boolean customSensitiveHeaders = false; //是否自定义了敏感头列表
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Route {
    private String id;
    private String fullPath;
    private String path;
    private String location;  //可能是 url 或 serviceId
    private String prefix;
    private Boolean retryable;
    private Set&amp;lt;String&amp;gt; sensitiveHeaders = new LinkedHashSet&amp;lt;&amp;gt;();
    private boolean customSensitiveHeaders;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;org.springframework.cloud.netflix.zuul.filters.Route&lt;/code&gt;和&lt;code&gt;ZuulProperties.ZuulRoute&lt;/code&gt;基本一致，只是Route用于路由转发定位的属性location根据不同的情况，可能是一个具体的URL，可能是一个serviceId&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;RouteLocator路由定位器如何根据请求路径匹配路由&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Zuul在自动配置加载时注入了2个RouteLocator&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CompositeRouteLocator&lt;/strong&gt;： 组合的RouteLocator，在&lt;code&gt;getMatchingRoute()&lt;/code&gt;时会依次调用其它的RouteLocator，先找到先返回；CompositeRouteLocator的routeLocators集合中只有DiscoveryClientRouteLocator&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DiscoveryClientRouteLocator&lt;/strong&gt;： 可以将静态的、已配置的路由与来自DiscoveryClient服务发现的路由组合在一起，来自DiscoveryClient的路由优先；SimpleRouteLocator的子类（SimpleRouteLocator 基于加载到&lt;code&gt;ZuulProperties&lt;/code&gt;中的配置定位Route路由信息）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中CompositeRouteLocator是 @Primary 的，它是组合多个RouteLocator的Locator，其&lt;code&gt;getMatchingRoute()&lt;/code&gt;方法会分别调用其它所有RouteLocator的getMatchingRoute()方法，通过请求路径匹配路由信息，只要匹配到了就马上返回&lt;/p&gt;
&lt;p&gt;默认CompositeRouteLocator混合路由定位器的routeLocators只有一个DiscoveryClientRouteLocator，故只需分析&lt;code&gt;DiscoveryClientRouteLocator#getMatchingRoute(path)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//----------DiscoveryClientRouteLocator是SimpleRouteLocator子类，其实是调用的SimpleRouteLocator##getMatchingRoute(path)
@Override
public Route getMatchingRoute(final String path) {
    return getSimpleMatchingRoute(path);
}

protected Route getSimpleMatchingRoute(final String path) {
    if (log.isDebugEnabled()) {
        log.debug(&quot;Finding route for path: &quot; + path);
    }

    // routes是保存路由信息的map，如果此时还未加载，调用locateRoutes()
    if (this.routes.get() == null) {
        this.routes.set(locateRoutes());
    }

    if (log.isDebugEnabled()) {
        log.debug(&quot;servletPath=&quot; + this.dispatcherServletPath);
        log.debug(&quot;zuulServletPath=&quot; + this.zuulServletPath);
        log.debug(&quot;RequestUtils.isDispatcherServletRequest()=&quot;
                + RequestUtils.isDispatcherServletRequest());
        log.debug(&quot;RequestUtils.isZuulServletRequest()=&quot;
                + RequestUtils.isZuulServletRequest());
    }

    /**
     * 下面的方法主要是先对path做微调
     * 再根据path到routes中匹配到ZuulRoute
     * 最后根据 ZuulRoute 和 adjustedPath 生成 Route
     */
    String adjustedPath = adjustPath(path);

    ZuulRoute route = getZuulRoute(adjustedPath);

    return getRoute(route, adjustedPath);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们来看看&lt;code&gt;locateRoutes()&lt;/code&gt;是如何加载静态的、已配置的路由与来自DiscoveryClient服务发现的路由的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//----------DiscoveryClientRouteLocator#locateRoutes()  服务发现路由定位器的locateRoutes()
@Override
protected LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt; locateRoutes() {
    //保存ZuulRoute的LinkedHashMap
    LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt; routesMap = new LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt;();
    
    //调用父类SimpleRouteLocator#locateRoutes()
    //加载ZuulProperties中的所有配置文件中的路由信息
    routesMap.putAll(super.locateRoutes());
    
    //如果服务发现客户端discovery存在
    if (this.discovery != null) {
        //将routesMap已经存在的配置文件中的ZuulRoute放入staticServices&amp;lt;serviceId, ZuulRoute&amp;gt;
        Map&amp;lt;String, ZuulRoute&amp;gt; staticServices = new LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt;();
        for (ZuulRoute route : routesMap.values()) {
            String serviceId = route.getServiceId();
            
            //如果serviceId为null，以id作为serviceId，此情况适合 zuul.routes.xxxx=/xxxx/** 的情况
            if (serviceId == null) {
                serviceId = route.getId();
            }
            if (serviceId != null) {
                staticServices.put(serviceId, route);
            }
        }
        
        
        // Add routes for discovery services by default
        List&amp;lt;String&amp;gt; services = this.discovery.getServices(); //到注册中心找到所有service
        String[] ignored = this.properties.getIgnoredServices()
                .toArray(new String[0]);
        
        //遍历services
        for (String serviceId : services) {
            // Ignore specifically ignored services and those that were manually
            // configured
            String key = &quot;/&quot; + mapRouteToService(serviceId) + &quot;/**&quot;;
            
            //如果注册中心的serviceId在staticServices集合中，并且此路由没有配置URL
            //那么，更新路由的location为serviceId
            if (staticServices.containsKey(serviceId)
                    &amp;amp;&amp;amp; staticServices.get(serviceId).getUrl() == null) {
                // Explicitly configured with no URL, cannot be ignored
                // all static routes are already in routesMap
                // Update location using serviceId if location is null
                ZuulRoute staticRoute = staticServices.get(serviceId);
                if (!StringUtils.hasText(staticRoute.getLocation())) {
                    staticRoute.setLocation(serviceId);
                }
            }
            
            //如果注册中心的serviceId不在忽略范围内，且routesMap中还没有包含，添加到routesMap
            if (!PatternMatchUtils.simpleMatch(ignored, serviceId)
                    &amp;amp;&amp;amp; !routesMap.containsKey(key)) {
                // Not ignored
                routesMap.put(key, new ZuulRoute(key, serviceId));
            }
        }
    }
    
    // 如果routesMap中有 /** 的默认路由配置
    if (routesMap.get(DEFAULT_ROUTE) != null) {
        ZuulRoute defaultRoute = routesMap.get(DEFAULT_ROUTE);
        // Move the defaultServiceId to the end
        routesMap.remove(DEFAULT_ROUTE);
        routesMap.put(DEFAULT_ROUTE, defaultRoute);
    }
    
    //将routesMap中的数据微调后，放到values&amp;lt;String, ZuulRoute&amp;gt;，返回
    LinkedHashMap&amp;lt;String, ZuulRoute&amp;gt; values = new LinkedHashMap&amp;lt;&amp;gt;();
    for (Entry&amp;lt;String, ZuulRoute&amp;gt; entry : routesMap.entrySet()) {
        String path = entry.getKey();
        // Prepend with slash if not already present.
        if (!path.startsWith(&quot;/&quot;)) {
            path = &quot;/&quot; + path;
        }
        if (StringUtils.hasText(this.properties.getPrefix())) {
            path = this.properties.getPrefix() + path;
            if (!path.startsWith(&quot;/&quot;)) {
                path = &quot;/&quot; + path;
            }
        }
        values.put(path, entry.getValue());
    }
    
    return values;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法运行后就已经加载了配置文件中所有路由信息，以及注册中心中的服务路由信息，有的通过URL路由，有的通过serviceId路由&lt;/p&gt;
&lt;p&gt;只需根据本次请求的requestURI与 路由的pattern匹配找到对应的路由&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;匹配到路由后，PreDecorationFilter如何设置RequestContext请求上下文&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//----------PreDecorationFilter前置过滤器
@Override
public Object run() {
    RequestContext ctx = RequestContext.getCurrentContext();
    final String requestURI = this.urlPathHelper.getPathWithinApplication(ctx.getRequest());
    Route route = this.routeLocator.getMatchingRoute(requestURI); //找到匹配的路由
    //----------------到上面为止是已经分析过的，根据requestURI找到匹配的Route信息
    
    // ==== 匹配到路由信息
    if (route != null) {
        String location = route.getLocation();
        if (location != null) {
            ctx.put(REQUEST_URI_KEY, route.getPath());//RequestContext设置 requestURI：路由的pattern路径
            ctx.put(PROXY_KEY, route.getId());//RequestContext设置 proxy：路由id
            
            //设置需要忽略的敏感头信息，要么用全局默认的，要么用路由自定义的
            if (!route.isCustomSensitiveHeaders()) {
                this.proxyRequestHelper
                        .addIgnoredHeaders(this.properties.getSensitiveHeaders().toArray(new String[0]));
            }
            else {
                this.proxyRequestHelper.addIgnoredHeaders(route.getSensitiveHeaders().toArray(new String[0]));
            }

            //设置重试信息
            if (route.getRetryable() != null) {
                ctx.put(RETRYABLE_KEY, route.getRetryable());
            }

            //如果location是 http/https开头的，RequestContext设置 routeHost：URL
            //如果location是 forward:开头的，RequestContext设置 forward信息、routeHost：null
            //其它 RequestContext设置 serviceId、routeHost：null、X-Zuul-ServiceId
            if (location.startsWith(HTTP_SCHEME+&quot;:&quot;) || location.startsWith(HTTPS_SCHEME+&quot;:&quot;)) {
                ctx.setRouteHost(getUrl(location));
                ctx.addOriginResponseHeader(SERVICE_HEADER, location);
            }
            else if (location.startsWith(FORWARD_LOCATION_PREFIX)) {
                ctx.set(FORWARD_TO_KEY,
                        StringUtils.cleanPath(location.substring(FORWARD_LOCATION_PREFIX.length()) + route.getPath()));
                ctx.setRouteHost(null);
                return null;
            }
            else {
                // set serviceId for use in filters.route.RibbonRequest
                ctx.set(SERVICE_ID_KEY, location);
                ctx.setRouteHost(null);
                ctx.addOriginResponseHeader(SERVICE_ID_HEADER, location);
            }
            
            //是否添加代理头信息 X-Forwarded-For
            if (this.properties.isAddProxyHeaders()) {
                addProxyHeaders(ctx, route);
                String xforwardedfor = ctx.getRequest().getHeader(X_FORWARDED_FOR_HEADER);
                String remoteAddr = ctx.getRequest().getRemoteAddr();
                if (xforwardedfor == null) {
                    xforwardedfor = remoteAddr;
                }
                else if (!xforwardedfor.contains(remoteAddr)) { // Prevent duplicates
                    xforwardedfor += &quot;, &quot; + remoteAddr;
                }
                ctx.addZuulRequestHeader(X_FORWARDED_FOR_HEADER, xforwardedfor);
            }
            
            //是否添加Host头信息
            if (this.properties.isAddHostHeader()) {
                ctx.addZuulRequestHeader(HttpHeaders.HOST, toHostHeader(ctx.getRequest()));
            }
        }
    }
    // ==== 没有匹配到路由信息
    else {
        log.warn(&quot;No route found for uri: &quot; + requestURI);

        String fallBackUri = requestURI;
        String fallbackPrefix = this.dispatcherServletPath; // default fallback
                                                            // servlet is
                                                            // DispatcherServlet

        if (RequestUtils.isZuulServletRequest()) {
            // remove the Zuul servletPath from the requestUri
            log.debug(&quot;zuulServletPath=&quot; + this.properties.getServletPath());
            fallBackUri = fallBackUri.replaceFirst(this.properties.getServletPath(), &quot;&quot;);
            log.debug(&quot;Replaced Zuul servlet path:&quot; + fallBackUri);
        }
        else {
            // remove the DispatcherServlet servletPath from the requestUri
            log.debug(&quot;dispatcherServletPath=&quot; + this.dispatcherServletPath);
            fallBackUri = fallBackUri.replaceFirst(this.dispatcherServletPath, &quot;&quot;);
            log.debug(&quot;Replaced DispatcherServlet servlet path:&quot; + fallBackUri);
        }
        if (!fallBackUri.startsWith(&quot;/&quot;)) {
            fallBackUri = &quot;/&quot; + fallBackUri;
        }
        String forwardURI = fallbackPrefix + fallBackUri;
        forwardURI = forwardURI.replaceAll(&quot;//&quot;, &quot;/&quot;);
        ctx.set(FORWARD_TO_KEY, forwardURI);
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只要引入了spring-cloud-starter-zuul就会间接引入Ribbon、Hystrix&lt;/li&gt;
&lt;li&gt;路由信息可能是从配置文件中加载的，也可能是通过DiscoveryClient从注册中心加载的&lt;/li&gt;
&lt;li&gt;zuul是通过前置过滤器PreDecorationFilter找到与当前requestURI匹配的路由信息，并在RequestContext中设置相关属性的，后续的Route Filter会根据RequestContext中的这些属性判断如何路由转发&lt;/li&gt;
&lt;li&gt;Route Filter主要使用 SimpleHostRoutingFilter 和 RibbonRoutingFilter&lt;/li&gt;
&lt;li&gt;当RequestContext请求上下文中存在routeHost，即URL直连信息时，使用SimpleHostRoutingFilter简单Host路由&lt;/li&gt;
&lt;li&gt;当RequestContext请求上下文中存在serviceId，即服务id时（可能会与注册中心关联获取服务列表，或者读取配置文件中serviceId.ribbon.listOfServers的服务列表），使用RibbonRoutingFilter，会使用Ribbon、Hystrix&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Nov 2018 05:46:00 +0000</pubDate>
<dc:creator>Trust_FreeDom</dc:creator>
<og:description>首先，引入 之后会间接引入： hystrix依赖已经引入，那么何种情况下使用hystrix呢？ 在Zuul的自动配置类 和`ZuulProxyAutoConfiguration`中总共会向Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/trust-freedom/p/9982680.html</dc:identifier>
</item>
</channel>
</rss>