<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>谈谈CommonsChunkPlugin抽取公共模块 - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/8146139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/8146139.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;webpack插件&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;的主要作用是抽取webpack项目入口&lt;strong&gt;chunk&lt;/strong&gt;的公共部分，具体的用法就不做过多介绍，不太了解可以参考&lt;a href=&quot;https://webpack.js.org/plugins/commons-chunk-plugin/&quot;&gt;webpack官网&lt;/a&gt;介绍；&lt;/p&gt;
&lt;p&gt;该插件是webpack项目常用的一个优化功能，几乎在每个webpack项目中都会用到。使用该插件带来的好处：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;提升webpack打包速度和项目体积&lt;/strong&gt;：将webpack入口的chunk文件中所有公共的代码提取出来，减少代码体积；同时提升webpack打包速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;利用缓存机制&lt;/strong&gt;：依赖的公共模块文件一般很少更改或者不会更改，这样独立模块文件提取出可以长期缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是在项目中，若插件打开方式不正确的话，上面的第二点其实是无法实现，因为这种情况下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有被修改过的公有代码或库代码打包出的Entry Chunk，会随着其他业务代码的变化而变化，导致页面上的长缓存机制失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，下面就来开启&lt;code&gt;CommonsChunkPlugin&lt;/code&gt;正确的打开方式。&lt;/p&gt;
&lt;h2 id=&quot;commonschunkplugin不正确用法&quot;&gt;CommonsChunkPlugin不正确用法&lt;/h2&gt;
&lt;p&gt;假如将我们项目的公共库如react、react-dom、react-router与业务代码隔离，将其提取为vendor chunk，webpack配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; webpack &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;webpack&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; path &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'path'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;./app.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;vendor&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;react-dom&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redux&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-redux&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-router-redux&quot;&lt;/span&gt;]
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;path&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;(__dirname&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'output'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;[name].[chunkhash].js&quot;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;webpack&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;optimize&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;CommonsChunkPlugin&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;vendor&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  ]
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面将项目一些基础库打包成一个名为&lt;strong&gt;vendor&lt;/strong&gt;的chunk中，并将业务相关的代码打包到一个名为app的chunk中；&lt;/p&gt;
&lt;p&gt;webpack打包编译后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/408483/201712/408483-20171230210933304-1722624213.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对其中的业务代码app.js进行修改后，重新编译结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/408483/201712/408483-20171230211016585-1547540861.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，在CommonsChunkPlugin这种配置下，当业务代码app发生变化，而库代码也跟着变化，vender的chunkhash也跟着变化，这样vendor的引用的名称跟着变化，导致浏览器端的长缓存机制失效。&lt;/p&gt;
&lt;h2 id=&quot;引起问题的原因&quot;&gt;引起问题的原因&lt;/h2&gt;
&lt;p&gt;引起webpack每次打包编译时vendor跟着变化的原因：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;webpack每次build的时候都会生成一些运行时代码。当只有一个文件时，运行时代码直接塞到这个文件中。当有多个文件时，运行时代码会被提取到公共文件中，也就是上面CommonsChunkPlugin配置的vendor chunk中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;webpack每次编译时产生的运行时代码，包括全局&lt;strong&gt;webpackJsonp&lt;/strong&gt;方法的定义和维护模块依赖关系，具体可以参考&lt;a href=&quot;https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks#jscommonsjs&quot;&gt;这里的commons.js&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;所以，上面webpack的CommonsChunkPlugin配置中，每次编译时这些代码都会打包到vendor中，导致每次vendor的&lt;strong&gt;chunkhash&lt;/strong&gt;每次都会变化。&lt;/p&gt;
&lt;p&gt;那么，我们可以在对vendor chunk进行配置，抽取其中的公共代码，即webpack运行时代码，这样就可以将项目依赖的基础库模块与业务模块隔离开来，因为不会对这些文件进行修改，所以这些文件可达到长缓存的作用。具体配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;./app.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;vendor&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;react-dom&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;redux&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-redux&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-router-redux&quot;&lt;/span&gt;]
  &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
  ....
  &lt;span class=&quot;dt&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;webpack&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;optimize&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;CommonsChunkPlugin&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;vendor&quot;&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;webpack&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;optimize&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;CommonsChunkPlugin&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'manifest'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;chunks&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'vendor'&lt;/span&gt;]
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  ]
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，即使修改业务app代码，项目依赖的基础库vendor chunk也不会发生变化；只是抽取的manifest chunk每次还会变化，但是这个文件体积非常小，相比vendor来说这种方式的收益更大。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/408483/201712/408483-20171230215918695-1845153786.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改app代码后的打包编译结果如下，可以看到vendor的chunkhash没有变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/408483/201712/408483-20171230215943038-1111595157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在webpack中配置CommonsChunkPlugin时需要注意一点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.5333333333333&quot;&gt;
&lt;p&gt;配置webpack的output项时，其&lt;code&gt;filename&lt;/code&gt;和&lt;code&gt;chunkFilename&lt;/code&gt;必须使用&lt;strong&gt;chunkhash&lt;/strong&gt;。不要使用&lt;strong&gt;hash&lt;/strong&gt;，否则即使按照上面的配置也不能达到预期的效果。至于hash与chunkhash的区别，可参考&lt;a href=&quot;https://github.com/webpack-contrib/extract-text-webpack-plugin/issues/153#issuecomment-225017219&quot;&gt;github的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://cnodejs.org/topic/58396960c71e606e36aed1db&quot;&gt;webpack之CommonsChunkPlugin正确打开方式&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://segmentfault.com/a/1190000011920743&quot;&gt;webpack 填坑之路--提取独立文件(模块)&lt;/a&gt;&lt;br/&gt;3、&lt;a href=&quot;http://foio.github.io/wepack-code-spliting/&quot;&gt;webpack代码分割技巧&lt;/a&gt;&lt;br/&gt;4、&lt;a href=&quot;https://www.imooc.com/article/21538?block_id=tuijian_wz&quot;&gt;听说你用webpack处理文件名的hash？那么建议你看看你生成的hash对不对&lt;/a&gt;&lt;br/&gt;5、&lt;a href=&quot;https://github.com/webpack/webpack/tree/master/examples/chunkhash&quot;&gt;chunkhash&lt;/a&gt;&lt;br/&gt;6、&lt;a href=&quot;https://github.com/webpack/webpack/tree/master/examples/multiple-commons-chunks&quot;&gt;multiple-commons-chunks&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 16:35:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/8146139.html</dc:identifier>
</item>
<item>
<title>css:background-position &gt; 精灵技术 - await</title>
<link>http://www.cnblogs.com/doudoublog/p/8151665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doudoublog/p/8151665.html</guid>
<description>&lt;p&gt;background-position : length || length &lt;br/&gt;background-position : position || position &lt;br/&gt;&lt;strong&gt;取值：&lt;/strong&gt; &lt;br/&gt;length  : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅 长度单位  &lt;br/&gt;position  : top | center | bottom | left | center | right &lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;&quot;top left&quot;,&quot;left top&quot;和&quot;0% 0%&quot;,&quot;0,0&quot;代表元素的左上角；&lt;/p&gt;
&lt;p&gt;&quot;top&quot;,&quot;top center&quot;,&quot;center top&quot;和&quot;50% 0&quot;表示在元素顶边居中位置；&lt;/p&gt;
&lt;p&gt;&quot;right top&quot;,&quot;top right&quot;和&quot;100% 0&quot;代元素的是元素的右上角位置；&lt;/p&gt;
&lt;p&gt;&quot;left&quot;,&quot;left center&quot;,&quot;center left&quot;和&quot;0% 50%&quot;表示在元素左边中间位置；&lt;/p&gt;
&lt;p&gt;&quot;center&quot;,&quot;center center&quot;和&quot;50% 50%&quot;表示在元素中间位置；&lt;/p&gt;
&lt;p&gt;&quot;right&quot;,&quot;right center&quot;,&quot;center,right&quot;和&quot;100% 50%&quot;表示在元素右边中间位置；&lt;/p&gt;
&lt;p&gt;&quot;bottom left&quot;,&quot;left bottom&quot;和&quot;0% 100%&quot;表示在元素的左下角；&lt;/p&gt;
&lt;p&gt;&quot;bottom&quot;,&quot;bottom center&quot;,&quot;center bottom&quot;和&quot;50% 100%&quot;表示在元素的底下中间点位置；&lt;/p&gt;
&lt;p&gt;&quot;bottom right&quot;，&quot;right bottom&quot;和“100％ 100％”表示在元素右下角位置&lt;/p&gt;
&lt;p&gt;为什么要讲CSS精灵技术，网页开发者喜欢在一个图片文件夹里散落着许多小图片，客户端每显示一张图片都会向服务器发送一次请求，图片越多请求次数越多，这样有可能造成图片延迟加载，影响用户体验，随着互联网技术的发展，大家越来越重视网页加载的速度了，于是这些小图片被整合到了一起，CSS Sprites出现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/802822/201712/802822-20171231000453960-701398854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如上面的图片，我们第一次想要切割第一个桃子出来，第二想要切割第二个或随便一个，按照图片在网页中的坐标是从左到右，上到下，0 0 就是左上角&lt;/p&gt;
&lt;p&gt;-----------&amp;gt; x轴&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;y轴&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        width: 90px;
        height: 100px;
        display: block;
        background: url(images/peach.png) 0 0 no-repeat;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个就可以限制一个框框把第一个桃子显示出来，当你想要第二个桃子，直接改&lt;/p&gt;
&lt;pre&gt;
background-position: 0 -115px;&lt;br/&gt;因为这张图的上桃子间隔是115px。&lt;br/&gt;这边有个实例：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    *&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .container&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 631px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        min-width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 900px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(images/bg.jpg) 50% 50% no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    h1&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 55px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .all_peach&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 85px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 210px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 800px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将图片定位到左上角，用width和height限制显示的宽高，保证只能显示一个桃子&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .peach&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; absolute&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 90px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; url(images/peach.png) 0 0 no-repeat&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        animation-iteration-count&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; infinite&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        animation-name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; shake&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        animation-timing-function&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; ease-in-out&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第一个桃子对应的精灵图的一个桃子，background-position: 0 0; 表示左上角，第一个桃子比较大&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .peach1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 158px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 108px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;background-position: 0 -115; 表示精灵图的第二个桃子&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .peach2 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -115px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 97px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 278px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .peach3 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -115px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 129px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 488px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .peach4 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -115px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 214px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 297px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .peach5 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -115px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 314px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 448px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .peach6 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -115px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 305px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 613px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;动画执行时间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .shake1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2.5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .shake2, .shake3 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 3.5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .shake4, .shake5, .shake6&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义关键帧，从0% ～ 100%(可以自定义)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @keyframes shake&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        0% {
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(2deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        20% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(10deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        40% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(0deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        60% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(-2deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        80%&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(-10deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        100%&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotate(0deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50% 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;摇晃的桃子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;all_peach&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach1 shake1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach2 shake2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach3 shake3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach4 shake4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach5 shake5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spac &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;peach peach6 shake6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/802822/201712/802822-20171231002018320-237479591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细了解backrgound-position：&lt;a href=&quot;https://www.w3cplus.com/content/css3-background-size&quot; target=&quot;_blank&quot;&gt;https://www.w3cplus.com/content/css3-background-size&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 16:22:00 +0000</pubDate>
<dc:creator>await</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/doudoublog/p/8151665.html</dc:identifier>
</item>
<item>
<title>我的2017年的年终总结 - 小王子的博客</title>
<link>http://www.cnblogs.com/xiaowangzi1987/p/8151660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowangzi1987/p/8151660.html</guid>
<description>&lt;h2&gt;引言：&lt;/h2&gt;
&lt;p&gt;        这么快，2017年就结束了，感觉时间太快了，眨眼之间，就已步入沉重的中年。2016年未正式接触博客园，一直在CSDN上混，2017年接触了博客园，觉得博客园的文风和code是一种很舒服的感觉，才慢慢喜欢用起园子了，也算自己的一亩三分地了。&lt;/p&gt;
&lt;p&gt;        以前从来没有认认真真的以文案的形式做个年终总结，也许最近中兴跳楼员工的新闻让自己感觉心有同感，才感觉自己的压力是如此巨大。&lt;/p&gt;
&lt;h2&gt;工作：&lt;/h2&gt;
&lt;h3&gt;         跳槽：&lt;/h3&gt;
&lt;p&gt;         2016年做完郑州日产的工作流项目，因为神龙没有新的.net项目，外包公司就会想办法将人员派到别的项目。可是这些项目都是需要驻场开发，需要长时间的远距离出差。郑州日产的项目就已经体验到了。那段黑白无常的加班时光仍让自己心有余悸。&lt;/p&gt;
&lt;p&gt;         为了摆脱这种飘渺不定的状态，且自己已经有了自己的家庭，果断辞去了软通的工作，正式开始寻找新的工作。&lt;/p&gt;
&lt;p&gt;         可是武汉的工资水平真的太低廉了，中国人的劳动力真的太廉价了。为了寻找到自己满意的工作，我开始全武汉的奔跑。为了工作，面试的HR直接丢过来题目，什么类型都有，C#技术的,SQL的,智力的，甚至还有情商考试的题目。看在这家公司在51上挂的薪水还可以，只得硬着头皮做。&lt;/p&gt;
&lt;p&gt;         绝大多数公司跟技术聊的很投入，有很多共同点，可是往往在薪水谈论的时候，都被卡了壳，为什么？我也在不断反思，难道我的要求过分么。相对个人能力和经验来说，我的要求真的不过分，可是没办法，因为面试的几个人存在会接受比我更低价格的求职者，就像投标过程中，往往都有几个报价低的离谱的人。后来才知道，他们是培训班出来的，简历上的语言描述真的快超神了。&lt;/p&gt;
&lt;p&gt;         最终，我还是进了同行业的软件单位，给工厂做MES和WMS。虽然薪水勉强达到我的要求，可是......（小公司的后果是什么都做：需求、设计、开发、验收、运维）&lt;/p&gt;
&lt;p&gt;         做过MES的人都知道，这种软件是最累的。因为工厂是24小时不停线的。软件系统造成产线停止10分钟，即是重大生产事故，需要上报至公司BOSS级别。&lt;/p&gt;
&lt;h3&gt;        2017项目：&lt;/h3&gt;
&lt;p&gt;          4月25日进入现在这家公司，7月底才算正式接手项目。截止目前，实施了3个MES和1个WMS&amp;amp;SAP项目，开发了1个MES项目，运维2个项目，正在实施1个项目。几个项目之间没有任何喘息的机会，实施地点又在江夏金口，感觉十分疲惫。每天下班回家，想看一会书，都是奢侈。&lt;/p&gt;
&lt;p&gt;           8月的延峰项目基本还算可以，节奏不是很快。&lt;/p&gt;
&lt;p&gt;           7月低的成都项目就很紧张了，时间很短，只有高温假的几天时间，工厂的硬件条件不具备，实际现场调试时间只有2天，那几日几乎每天都是凌晨回酒店，突然让自己感觉又回到了郑州日产项目的感觉。&lt;/p&gt;
&lt;p&gt;           9月26日 胡领导突然告诉我，江夏的MES我来开发。当时我听到这个消息，真的郁闷之极。这个项目原定由一个刚毕业一两年的小伙做。可是，跟生娃的孕妇一样，8月初开始开发Code，到9月底还是一团糟。在这么下去，咱们的领导觉得会出大篓子。那能怎么办，只能我来顶。于是我国庆假日没有好好休息一天，在家里蒙头开发了四天，5日开始测试。&lt;/p&gt;
&lt;p&gt;           这个项目之前我们的经理还觉得不可能SAP上线成功，可是最终还是上线了，中间付出了多大的努力，没有人会去关心。心里觉得拔凉拔凉的，想起那一个月的每天五点半起来，晚上12点到家。想起为了SAP连干两个通宵。&lt;/p&gt;
&lt;h3&gt;          沟通：&lt;/h3&gt;
&lt;p&gt;            2017年遇到了很多人，有和蔼可亲的、有无情无义、有狡诈的人。其实有时候，遇到这些人，我并没有觉得有多悲哀。我只是觉得为什么这个社会会容忍这些不该存在的人存在，后来我才知道，我无法改变他人、改变社会。我只能改变自己，变着、变着，我也变得善于伪装和虚与委蛇。&lt;/p&gt;
&lt;h2&gt;家庭：&lt;/h2&gt;
&lt;p&gt;            工作虽然很累，但是我很感谢我的家庭，感谢我的老婆。因为我老婆对我的关爱，我才知道我的付出是值得的，我必须为了我的家庭，再大的风雨，我也能挺过去。&lt;/p&gt;
&lt;p&gt;            去年定的驾照目标，被延期了。哎，这个11月底才报名，需要抓住时机。&lt;/p&gt;
&lt;h2&gt;学习：&lt;/h2&gt;
&lt;p&gt;             2017年一共看了3本书：&lt;/p&gt;
&lt;p&gt;                    C#高级编程看了878页&lt;/p&gt;
&lt;p&gt;                    Ajax入门到精通看完了&lt;/p&gt;
&lt;p&gt;                    LINQ In Action看了250页&lt;/p&gt;
&lt;p&gt;             开通了博客园博客&lt;/p&gt;
&lt;p&gt;             通过网络学习了一系列的技术文档。&lt;/p&gt;
&lt;p&gt;             为项目开发了3套工具软件和1套开源软件。&lt;/p&gt;
&lt;h2&gt;2018：&lt;/h2&gt;
&lt;h3&gt;           工作：&lt;/h3&gt;
&lt;p&gt;             2018年的项目肯定不会少，毕竟公司要挣钱，你就是挣钱的机器，必须让你利益最大化。&lt;/p&gt;
&lt;p&gt;             2018年的项目工作达到以下要求：&lt;/p&gt;
&lt;p&gt;               1.建立自己一套符合标准的软件设计、开发和实施标准制度。并将其应用于实际项目之中。&lt;/p&gt;
&lt;p&gt;               2.加强项目进度的把控和项目风险的预估能力。&lt;/p&gt;
&lt;p&gt;               3.不要再出现直接顶撞用户的事情，学会借力打力，保持自己专业和中立的态度。&lt;/p&gt;
&lt;h3&gt;             学习：&lt;/h3&gt;
&lt;p&gt;                1.在春节前看完LINQ IN ACTION&lt;/p&gt;
&lt;p&gt;                2.通过信息系统项目管理师的考试&lt;/p&gt;
&lt;p&gt;                3.搭建自己的文档学习库，并将其开源。&lt;/p&gt;
&lt;p&gt;                4.看完你必须知道的.net&lt;/p&gt;
&lt;h3&gt;              家庭：&lt;/h3&gt;
&lt;p&gt;                双休的时间尽量用来陪伴家人，毕竟家人才是人生最大的寄托。明年又要生小宝宝，所以家人才是第一位的。&lt;/p&gt;
&lt;p&gt;                驾照明年必须通过，为后年买车做好准备。&lt;/p&gt;
&lt;h3&gt;              沟通：&lt;/h3&gt;
&lt;p&gt;                积极与一些销售人员进行多层面的沟通，去除Code农的说话方式。&lt;/p&gt;
&lt;p&gt;希望明年再来写总结的时候，有一些感悟就需要存在了，能够进入更高觉悟阶级。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 16:19:00 +0000</pubDate>
<dc:creator>小王子的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaowangzi1987/p/8151660.html</dc:identifier>
</item>
<item>
<title>瞎j8封装第二版之数据层的封装 - 早起的虫儿去吃鸟</title>
<link>http://www.cnblogs.com/yeyeck/p/8151637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyeck/p/8151637.html</guid>
<description>
&lt;p&gt;看了以前写的代码，对就是下面这个&lt;/p&gt;
&lt;p&gt;    &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_4&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yeyeck/p/7430265.html&quot;&gt;手把手封装数据层之DataUtil数据库操作的封装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;觉得以前写的代码好烂啊！！！，重新理了一下思路，写得更规范和简练，应该效率也会高很多，用了一下下午写的连接池（半废品。。。）&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/yeyeck/p/8151566.html&quot;&gt;瞎j8封装第二版之数据库连接池&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面直接上代码，代码很好理解，就是用了简单的反射，注解的部分我都写了注释&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; jdbc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; util.StringUtil;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.sql.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataUtil {


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; excuteUpdate(String sql, Object... objects) {
        Connection connection &lt;/span&gt;=&lt;span&gt; ConnectionPool.getInstance().getCurrentConnection();
        PreparedStatement preparedStatement &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preparedStatement &lt;/span&gt;=&lt;span&gt; getStateMent(connection, sql, objects);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; preparedStatement.executeUpdate(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql并返回结果&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preparedStatement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    preparedStatement.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
                    e.printStackTrace();
                }
            }

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询单挑记录
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql  查询语句
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 返回对象的class
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; objects 需要的参数，必须跟sql占位符的位置一一对应
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;   泛型返回
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      返回单个对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T queryForObject(String sql, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz, Object... objects) {
        Connection connection &lt;/span&gt;=&lt;span&gt; ConnectionPool.getInstance().getCurrentConnection();
        PreparedStatement preparedStatement &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ResultSet resultSet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        T object &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preparedStatement &lt;/span&gt;=&lt;span&gt; getStateMent(connection, sql, objects);
            resultSet &lt;/span&gt;=&lt;span&gt; getResultSet(preparedStatement);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resultSet.next()) {
                object &lt;/span&gt;=&lt;span&gt; invokeObject(resultSet, clazz);
            }

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchFieldException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            close(preparedStatement, resultSet); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记得关闭&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *查询多条记录
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sql  查询语句
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 返回对象的class
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; objects 需要的参数，必须跟sql占位符的位置一一对应
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;   泛型返回
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; list
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; queryForList(String sql, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz, Object... objects) {
        Connection connection &lt;/span&gt;=&lt;span&gt; ConnectionPool.getInstance().getCurrentConnection();
        PreparedStatement preparedStatement &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ResultSet resultSet &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;T&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;T&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            preparedStatement &lt;/span&gt;=&lt;span&gt; getStateMent(connection, sql, objects);
            resultSet &lt;/span&gt;=&lt;span&gt; getResultSet(preparedStatement);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (resultSet.next()) {
                list.add(invokeObject(resultSet, clazz));
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchFieldException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            close(preparedStatement, resultSet);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list.size() &amp;gt; 0 ? list : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close(PreparedStatement preparedStatement, ResultSet resultSet) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (preparedStatement != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                preparedStatement.close();
                resultSet.close();
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T invokeObject(ResultSet resultSet, Class&amp;lt;T&amp;gt; clazz) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalAccessException, InstantiationException,
            SQLException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException {
        T object &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
        ResultSetMetaData metaData &lt;/span&gt;=&lt;span&gt; resultSet.getMetaData();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, count = metaData.getColumnCount(); i &amp;lt; count; i++&lt;span&gt;) {
            String columnName &lt;/span&gt;= metaData.getColumnName(i + 1);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库返回结果的列名&lt;/span&gt;
            String fieldName = StringUtil.camelName(columnName); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉列名中的下划线“_”并转为驼峰命名&lt;/span&gt;
            Field field = clazz.getDeclaredField(fieldName);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据字段名获取field&lt;/span&gt;
            String methName = setMethodName(fieldName);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼set方法名&lt;/span&gt;
            Class type = field.getType();                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取字段类型&lt;/span&gt;
            Method setMethod =&lt;span&gt; clazz.getDeclaredMethod(methName, field.getType());
            Object value &lt;/span&gt;= resultSet.getObject(i + 1);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取字段值&lt;/span&gt;
            setMethod.invoke(object, type.cast(value));       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;强转并且赋值&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; PreparedStatement getStateMent(Connection connection, String sql, Object... objects) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        PreparedStatement preparedStatement &lt;/span&gt;=&lt;span&gt; connection.prepareStatement(sql);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, len = objects.length; i &amp;lt; len; i++&lt;span&gt;) {
            preparedStatement.setObject(i &lt;/span&gt;+ 1, objects[i]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给sql每个？占位符填上数据&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; preparedStatement;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ResultSet getResultSet(PreparedStatement statement) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (statement == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; statement.executeQuery();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String setMethodName(String str) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;set&quot; +&lt;span&gt; StringUtil.firstUpperCase(str);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用到了几个简单的字符串处理方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringUtil {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转为驼峰命名
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; string
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String camelName(String str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEmpty(str)) {
            StringBuilder stringBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, len = str.length(); i &amp;lt; len; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.charAt(i) == '_'&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (str.charAt(i + 1) == '_'&lt;span&gt;) {
                        i&lt;/span&gt;++&lt;span&gt;;
                    }
                    stringBuilder.append((&lt;/span&gt;&quot;&quot; + str.charAt(++&lt;span&gt;i)).toUpperCase());
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    stringBuilder.append(str.charAt(i));
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringBuilder.toString();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断是否为空串
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isBlank(String str) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; str.length() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, len = str.length(); i &amp;lt; len; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Character.isSpaceChar(str.charAt(i))) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断是否为空串 ？！！！ 我怎么又写了个一样的方法？！！！
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty(String str) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str == &lt;span&gt;null&lt;/span&gt; || str.length() == 0&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将第一个字母替换为大写
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String firstUpperCase(String str) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; str.substring(0, 1).toUpperCase() + str.substring(1&lt;span&gt;, str.length());
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面开始是测试了&lt;/p&gt;
&lt;p&gt;首先数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1213881/201712/1213881-20171230235806398-1719388063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后测试类，跟表结构对应的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; po;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double score;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date createTime;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date updateTime;

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set、get 方法均省略了，但是这个是必须的&lt;/span&gt;
｝
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String sql &lt;/span&gt;= &quot;select * from t_user&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;User&amp;gt; list = DataUtil.queryForList(sql,User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;查询多条记录：&quot; +&lt;span&gt; list);
        System.out.println(&lt;/span&gt;&quot;******************************************************************&quot;&lt;span&gt;);


        sql &lt;/span&gt;= &quot;select * from t_user where id = ?&quot;&lt;span&gt;;
        User user &lt;/span&gt;= DataUtil.queryForObject(sql,User.&lt;span&gt;class&lt;/span&gt;,1&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;查询单条记录：&quot; +&lt;span&gt; user);
        System.out.println(&lt;/span&gt;&quot;******************************************************************&quot;&lt;span&gt;);


        sql &lt;/span&gt;= &quot;insert into t_user(name,score,create_time,update_time) values(?,?,now(),now())&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = DataUtil.excuteUpdate(sql,&quot;大牛&quot;,66.66&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;执行插入操作结果：&quot;+&lt;span&gt;t);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1213881/201712/1213881-20171231000431788-547279970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1213881/201712/1213881-20171231000455726-1084787134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;太晚了，先到这了，有空把我的mybatis和ioc容器也瞎j8重写一下&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;/p&gt;


</description>
<pubDate>Sat, 30 Dec 2017 16:07:00 +0000</pubDate>
<dc:creator>早起的虫儿去吃鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyeck/p/8151637.html</dc:identifier>
</item>
<item>
<title>JAVA面试中问及HIBERNATE与 MYBATIS的对比，在这里做一下总结(转) - 流星~泪雨</title>
<link>http://www.cnblogs.com/liuxingleiyu/p/8151624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxingleiyu/p/8151624.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Sat, 30 Dec 2017 16:01:00 +0000</pubDate>
<dc:creator>流星~泪雨</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=http%3A%2F%2Fwww.cnblogs.com%2Fliuxingleiyu%2Fp%2F8151624.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>用keras作CNN卷积网络书本分类（书本、非书本） - McKay</title>
<link>http://www.cnblogs.com/aarond/p/CNN.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/CNN.html</guid>
<description>&lt;p&gt;本文介绍如何使用keras作图片分类（2分类与多分类，其实就一个参数的区别。。。呵呵） &lt;/p&gt;
&lt;p&gt;先来看看解决的问题：从一堆图片中分出是不是书本，也就是最终给图片标签上：“书本“、“非书本”，简单吧。&lt;/p&gt;
&lt;p&gt;先来看看网络模型，用到了卷积和全连接层，最后套上SOFTMAX算出各自概率，输出ONE-HOT码，主要部件就是这些，下面的nb_classes就是用来控制分类数的，本文是2分类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from keras.models import Sequential  
from keras.layers.core import Dense, Dropout, Activation, Flatten  
from keras.layers.convolutional import Convolution2D, MaxPooling2D  
from keras.optimizers import SGD  


def Net_model(nb_classes, lr=0.001,decay=1e-6,momentum=0.9):  
    model = Sequential()  
    model.add(Convolution2D(filters=10, kernel_size=(5,5),
                            padding='valid',  
                            &lt;span&gt;input_shape=(200, 200, 3)&lt;/span&gt;))  
    model.add(Activation('tanh'))  
    model.add(MaxPooling2D(pool_size=(2, 2)))  
  
    model.add(Convolution2D(filters=20, kernel_size=(10,10)))
    model.add(Activation('tanh'))  
    model.add(MaxPooling2D(pool_size=(2, 2)))  
    model.add(Dropout(0.25))  
  
    model.add(Flatten())  
    model.add(Dense(1000))
    model.add(Activation('tanh'))  
    model.add(Dropout(0.5))  
    model.add(Dense(nb_classes))  
    model.add(Activation('softmax'))  
  
    sgd = SGD(lr=lr, decay=decay, momentum=momentum, nesterov=True)  
    model.compile(loss='categorical_crossentropy', optimizer=sgd)  
      
    return model  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的input_shape=(200, 200, 3)代表图片像素大小为宽高为200，200，并且包含RGB 3通道的图片，不是灰度图片（只要1个通道）&lt;/p&gt;
&lt;p&gt;也就是说送入此网络的图片宽高必须200*200*3；如果不是这个shape就需要resize到这个shape&lt;/p&gt;

&lt;p&gt;下面来看看训练程序，首先肯定是要收集些照片，书本、非书本的照片，我是分别放在了0文件夹和1文件夹下了，再带个验证用途的文件夹validate：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/68230/201712/68230-20171230223410710-1684337433.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;训练程序涉及到几个地方：照片文件的读取、模型加载训练与保存、可视化训练过程中的损失函数value&lt;/p&gt;
&lt;p&gt;&lt;span&gt;照片文件的读取&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import cv2
import os
import numpy as np
import keras

def loadImages():
    imageList=[]
    labelList=[]

    rootdir=&quot;d:\\books\\0&quot;
    list =os.listdir(rootdir)
    for item in list:
        path=os.path.join(rootdir,item)
        if(os.path.isfile(path)):
            f=cv2.imread(path)
            &lt;span&gt;f=cv2.resize(f, (200, 200))#resize到网络input的shape&lt;/span&gt;
            imageList.append(f)
            labelList.append(0)#类别0

    rootdir=&quot;d:\\books\\1&quot;
    list =os.listdir(rootdir)
    for item in list:
        path=os.path.join(rootdir,item)
        if(os.path.isfile(path)):
            f=cv2.imread(path)
            &lt;span&gt;f=cv2.resize(f, (200, 200))#resize到网络input的shape&lt;/span&gt;
            imageList.append(f)
            labelList.append(1)#类别1

    return np.asarray(imageList), &lt;span&gt;keras.utils.to_categorical(labelList, 2)
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于（200，200）这个shape怎么得来的，只是几月前开始玩opencv时随便写了个数值，后来想利用那些图片，就适应到这个shape了&lt;/p&gt;
&lt;p&gt;keras.utils.to_categorical函数类似numpy.onehot、tf.one_hot这些，只是one hot的keras封装&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型加载训练与保存&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
nb_classes = 2  
nb_epoch = 30
nb_step = 6
batch_size = 3

x,y=loadImages()

from keras.preprocessing.image import &lt;span&gt;ImageDataGenerator&lt;/span&gt;
dataGenerator=ImageDataGenerator()
dataGenerator.fit(x)
data_generator=dataGenerator.flow(x, y, batch_size, True)&lt;span&gt;#generator函数，用来生成批处理数据（从loadImages中）&lt;/span&gt;

model=NetModule.Net_model(nb_classes=nb_classes, lr=0.0001) &lt;span&gt;#加载网络模型&lt;/span&gt;

history=model.fit_generator(data_generator, epochs=nb_epoch, steps_per_epoch=nb_step, shuffle=True)&lt;span&gt;#训练网络，并且返回每次epoch的损失value&lt;/span&gt;

model.save_weights('D:\\Documents\\Visual Studio 2017\\Projects\\ConsoleApp9\\PythonApplication1\\书本识别\\trained_model_weights.h5')&lt;span&gt;#保存权重&lt;/span&gt;
print(&quot;DONE, model saved in path--&amp;gt;D:\\Documents\\Visual Studio 2017\\Projects\\ConsoleApp9\\PythonApplication1\\书本识别\\trained_model_weights.h5&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ImageDataGenerator构造函数有很多参数，主要用来提升数据质量，比如要不要标准化数字&lt;/p&gt;
&lt;p&gt;lr=0.001这个参数要看经验，大了会导致不收敛，训练的时候经常由于这个参数的问题导致重复训练，这在没有GPU的情况下很是痛苦。。痛苦。。。痛苦。。。&lt;/p&gt;
&lt;p&gt;model.save_weights是保存权重，但是不保存网络模型 ，对应的是model.load_weights方法&lt;/p&gt;
&lt;p&gt;model.save是保存网络+权重，只是。。。。此例中用save_weights保存的h5文件是125M，但用save方法保存后，h5文件就增大为280M了。。。&lt;/p&gt;
&lt;p&gt;上面2个save方法都能finetune，只是灵活度不一样。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可视化训练过程中的损失函数value&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import matplotlib.pyplot as plt

plt.plot(history.history['loss'])
plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/68230/201712/68230-20171230225618617-1964971165.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;貌似没啥好补充的。。。&lt;/p&gt;

&lt;p&gt;AND。。。。看看预测部分吧，这部分加载图片、加载模型，似乎都和训练部分雷同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def loadImages():
    imageList=[]

    rootdir=&quot;&lt;span&gt;d:\\books\\validate&lt;/span&gt;&quot;
    list =os.listdir(rootdir)
    for item in list:
        path=os.path.join(rootdir,item)
        if(os.path.isfile(path)):
            f=cv2.imread(path)
            &lt;span&gt;f=cv2.resize(f, (200, 200))&lt;/span&gt;
            imageList.append(f)

    return np.asarray(imageList)

x=loadImages()


x=np.asarray(x)

model=NetModule.Net_model(nb_classes=2, lr=&lt;span&gt;0.0001&lt;/span&gt;)
model.&lt;span&gt;load_weights&lt;/span&gt;('D:\\Documents\\Visual Studio 2017\\Projects\\ConsoleApp9\\PythonApplication1\\书本识别\\trained_model_weights.h5')

print(model.&lt;span&gt;predict&lt;/span&gt;(x))
print(model.&lt;span&gt;predict_classes&lt;/span&gt;(x))
y=&lt;span&gt;convert2label&lt;/span&gt;(model.predict_classes(x))
print(y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;predict的返回其实是softmax层返回的概率数值，是&amp;lt;=1的float&lt;/p&gt;
&lt;p&gt;predict_classes返回的是经过one-hot处理后的数值，此时只有0、1两种数值（最大的value会被返回称为1，其他都为0）　　&lt;/p&gt;
&lt;p&gt;convert2label：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def convert2label(vector):
    string_array=[]
    for v in vector:
        if v==1:
            string_array.append('BOOK')
        else:
            string_array.append('NOT BOOK')
    return string_array
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数是用来把0、1转换成文本的，小插曲：&lt;/p&gt;
&lt;p&gt;本来这里是中文的“书本”、“非书本”，后来和女儿一起调试时发现都显示成了问号，应该是中文字符问题，就改成了英文显示，和女儿一起写代码是种乐趣啊！&lt;/p&gt;
&lt;p&gt;本来只是显示文本，感觉太无聊了，因此加上了opencv显示图片+分类文本的代码段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
for i in range(len(x)):
    cv2.putText(x[i], y[i], (50,50), cv2.FONT_HERSHEY_SIMPLEX, 1, 255, 2)
    cv2.imshow('image'+str(i), x[i])

cv2.waitKey(-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/68230/201712/68230-20171230230430382-234792403.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt; OK， 2018年继续学习，继续科学信仰。&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 15:09:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/CNN.html</dc:identifier>
</item>
<item>
<title>第四节：dingo/API 最新版 V2.0 之 Responses （连载） - 淡定的小孩</title>
<link>http://www.cnblogs.com/jingying/p/8041790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingying/p/8041790.html</guid>
<description>&lt;p&gt;&lt;strong&gt;因为某些某些原因，不能按时更新，唉。我会尽力，加快速度。（这句话不是翻译的哈）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原文地址——&amp;gt; &lt;a href=&quot;https://github.com/dingo/api/wiki/Responses&quot; target=&quot;_blank&quot;&gt;https://github.com/dingo/api/wiki/Responses&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A functioning API is built upon receiving requests and returning a consumable response to the client. An API will generally return responses in an easy to consume format such as JSON. There's a number of different ways to return responses and it will largely depend on how complex your API is or will become.&lt;/p&gt;
&lt;p&gt;一个运行的API 主要是获取请求并返回给客户端响应信息。一个API通常会以一种易于使用的格式返回响应，例如JSON。这是一个不同的方法去返回请求。这里有许多不同的方法可以返回响应，很大程度上取决于您的API的复杂程度或者API未来的方向。&lt;/p&gt;
&lt;p&gt;The easiest way to return a consumable response is to simply return an array or object directly from your controller. Not every object can be correctly formatted though so you should ensure that it implements either the &lt;code&gt;ArrayObject&lt;/code&gt; or the &lt;code&gt;Illuminate\Support\Contracts\ArrayableInterface&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;返回一个可使用的响应最简单的方式是直接从控制器返回数组或对象。不是每个对象都能够被返回正确的格式，但因此，你应该确定它继承了ArrayObject或者Illuminate\Support\Contracts\ArrayableInterface接口。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; index()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; User::&lt;span&gt;all();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个实例中，我们的User类继承了Illuminate\Database\Eloquent\Model，意味着它能作为一个格式化的数组返回，所以我们能通过调用User::all(),简单的返回一个users集合。&lt;/p&gt;
&lt;p&gt;同样的，你也能使用它返回一个单一的user。例：如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; User::findOrFail(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个包，将自动格式化响应信息之后作为JSON格式返回，并且为Content-Type 头设置为application/json。 &lt;/p&gt;

&lt;h3&gt;Response Builder  &lt;strong&gt;响应构建器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这个响应构建器，提供一个流畅的接口去简单的生成一个定制的响应信息。这个响应构建器通常与transformers结合使用。&lt;/p&gt;
&lt;p&gt;要想在你的控制器，使用这个响应返回。你应该引入（使用） Dingo\Api\Routing\Helpers。为了让你的全部控制器都可以用使用这个特性，你应该创建一个基类控制器，让你所有的控制器都去继承（extends）它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;use&lt;/span&gt;&lt;span&gt; Dingo\Api\Routing\Helpers;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; Illuminate\Routing\Controller;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; BaseController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Controller
{
    &lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; Helpers;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在，你的控制器能简单的继承基本控制器。在你的控制器中可以经由&lt;code&gt;$response&lt;/code&gt;属性来访问响应构建器。&lt;/p&gt;
&lt;p&gt;关于这，更详细的文档，你应该看Transformers那节。（接下来，我会慢慢翻译的，等。。）&lt;/p&gt;
&lt;h4&gt;Responding With An Array 作为一个数组返回&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; UserController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$user&lt;/span&gt; = User::findOrFail(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;&lt;span&gt;array&lt;/span&gt;(&lt;span&gt;$user&lt;/span&gt;-&amp;gt;&lt;span&gt;toArray());
    }
}   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; Responding With A Single Item 作为一个item返回&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; UserController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; show(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;$user&lt;/span&gt; = User::findOrFail(&lt;span&gt;$id&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;item(&lt;span&gt;$user&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserTransformer);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Responding With A Collection Of Items 作为一个元素集合返回&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
class UserController extends BaseController
{
        public function index()
        {
                $users = User::all();

                return $this-&amp;gt;response-&amp;gt;collection($users, new UserTransformer);
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Responding With Paginated Items    返回带分页的数组&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; UserController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; index()
    {
        &lt;/span&gt;&lt;span&gt;$users&lt;/span&gt; = User::paginate(25&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;paginator(&lt;span&gt;$users&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserTransformer);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Responding With No Content     无内容响应&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;noContent();
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Responding With Created Response    创建了资源的响应&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;created();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以，为这个created 随意的提供一个值，作为第一个参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
return $this-&amp;gt;response-&amp;gt;created($location);　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Responding With An Error 返回一个错误提示&lt;/h4&gt;
&lt;p&gt;这个包内有很多不同的响应错误的提示，你可以快速的形成一个错误提示。（这块文字理解，我感觉不太好，就把真实的返回值写出来了）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;error('This is an error.', 404);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
返回信息：{&quot;message&quot;:&quot;This is an error.&quot;,&quot;status_code&quot;:404}&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;errorNotFound();
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
返回信息：{&quot;message&quot;:&quot;Not Found&quot;,&quot;status_code&quot;:404} &lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;errorBadRequest();
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
返回信息：{&quot;message&quot;:&quot;Bad Request&quot;,&quot;status_code&quot;:400}&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;errorForbidden();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回信息：{&quot;message&quot;:&quot;Forbidden&quot;,&quot;status_code&quot;:403}&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;errorInternal();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回信息：{&quot;message&quot;:&quot;Internal Error&quot;,&quot;status_code&quot;:500}&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;errorUnauthorized();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回信息：{&quot;message&quot;:&quot;Unauthorized&quot;,&quot;status_code&quot;:401}&lt;/p&gt;

&lt;h4&gt;Adding Additional Headers      添加附加的表头&lt;/h4&gt;
&lt;p&gt;一旦您使用了上述方法中的一个，您就可以通过添加附加的表头来进一步定制响应。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;$this&lt;/span&gt;-&amp;gt;response-&amp;gt;item(&lt;span&gt;$user&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; UserTransformer)-&amp;gt;withHeader('X-Foo', 'Bar');
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Adding Meta Data   添加元数据&lt;/h4&gt;
&lt;p&gt;某些转化层可能会使用元数据（meta data）。当你需要提供与资源相关的额外数据时，这很有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
return $this-&amp;gt;response-&amp;gt;item($user, new UserTransformer)-&amp;gt;addMeta('foo', 'bar');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以设置一个 meta 数据的数组，省得多次调用 addMeta 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
return $this-&amp;gt;response-&amp;gt;item($user, new UserTransformer)-&amp;gt;setMeta($meta);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Setting Response Status Code    设置返回值状态&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
return $this-&amp;gt;response-&amp;gt;item($user, new UserTransformer)-&amp;gt;setStatusCode(200);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Custom Response Formats    自定义响应格式&lt;/h3&gt;
&lt;p&gt;在这个配置章节，我们简单的讲解了返回信息格式。通过这个dingo包，我们将自动的使用json格式，并设置一个恰当的Content-Type头。除了 JSON 格式化，还有一个 JSONP 格式化。这个 formatter 将会用一个回调包裹响应。更改格式只需要简单将配置文件（Laravel）或启动文件（Lumen）中的默认JSON格式替换成JSONP即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
'formats' =&amp;gt;&lt;span&gt; [
    &lt;/span&gt;'json' =&amp;gt; 'Dingo\Api\Http\Response\Format\Jsonp'&lt;span&gt;
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 或&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Dingo\Api\Http\Response::addFormatter('json', &lt;span&gt;new&lt;/span&gt; Dingo\Api\Http\Response\Format\Jsonp);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 你可以注册之后使用你自己需要的格式。你的格式应该继承 Dingo\Api\Http\Response\Format\Format。这有很多请求应该被定义：formatEloquentModel，formatEloquentCollection，formatArray和getContentType。&lt;/p&gt;
&lt;h3&gt;Morphing And Morphed Events   &lt;/h3&gt;
&lt;p&gt; 在发送一个响应之前，它会改变它，在发送。这个过程包括运行所有转换器（Transformer）以及通过配置的响应格式发送响应。如果你需要对响应的变化有更多的控制，你可以使用 &lt;code&gt;ResponseWasMorphed&lt;/code&gt; 和 &lt;code&gt;ResponseIsMorphing&lt;/code&gt; 这两个事件.&lt;/p&gt;
&lt;p&gt;在你的app/Listeners文件夹，创建一个监听器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
use Dingo\Api\Event\ResponseWasMorphed;

class AddPaginationLinksToResponse
{
        public function handle(ResponseWasMorphed $event)
        {
                if (isset($event-&amp;gt;content['meta']['pagination'])) {
                        $links = $event-&amp;gt;content['meta']['pagination']['links'];

                        $event-&amp;gt;response-&amp;gt;headers-&amp;gt;set(
                                'link',
                                sprintf('&amp;lt;%s&amp;gt;; rel=&quot;next&quot;, &amp;lt;%s&amp;gt;; rel=&quot;prev&quot;', $links['links']['next'], $links['links']['previous'])
                        );
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　然后通过在&lt;code&gt;EventServiceProvider&lt;/code&gt;中注册事件及其对应监听器来监听该事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;$listen&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'Dingo\Api\Event\ResponseWasMorphed' =&amp;gt;&lt;span&gt; [
        &lt;/span&gt;'App\Listeners\AddPaginationLinksToResponse'&lt;span&gt;
    ]
];                                                                                                                                                      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Now all responses that contain pagination links will also add these links to the &lt;code&gt;Link&lt;/code&gt; header.(这句话，留给你们翻译)&lt;/p&gt;
&lt;p&gt;这章结束了，马上要2018年了。新的一年，go go go !!!&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 14:56:00 +0000</pubDate>
<dc:creator>淡定的小孩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingying/p/8041790.html</dc:identifier>
</item>
<item>
<title>快速学习Bash - Vamei</title>
<link>http://www.cnblogs.com/vamei/p/8151169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vamei/p/8151169.html</guid>
<description>&lt;p&gt;&lt;span&gt;作者：Vamei 出处：http://www.cnblogs.com/vamei 严禁转载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;Shell是Linux下经典的文本互动方式，而Bash是现在最常用的一种Shell。我在这里总结了Bash的要点知识。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Shell综述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Linux图形化桌面算不上精美。幸好，Linux提供了更好的与树莓派互动的方式：Shell。打开终端（Terminal），桌面上就会出现一个黑色背景的窗口，里面就运行着一个Shell。如果你敲击键盘，会发现字符会显示在$提示符的后面，形成一串文本形式的命令。所谓的Shell，就是运行在终端中的文本互动程序。Shell分析你的文本输入，然后把文本转换成相应的计算机动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在后面的内容中，我将用$来表示Linux系统Shell的命令提示符。比如说输入date命令：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;date用于日期时间的相关功能。敲击回车键Enter后，Shell会显示出系统当前的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Shell看起来简陋，但实际上比图形化桌面强大得多。它是Unix体系下的文本交互界面。你只需要用键盘来输入文本，就可以和操作系统交互。但这还是不够具体。说到底，Shell其实是一个运行着的程序。这个程序接收到你按下回车键之间的输入，就会对输入的文本进行分析。比如下面这个命令：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;包括空格在内总共7个字符。Shell程序会通过空格，区分出命令的不同部分。第一个部分是命令名。剩下的部分是选项和参数。在这个例子中，Shell会进一步分析第二个部分，发现这一部分的开头是&quot;-&quot;字符，从而知道它是一个选项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了命令名，Shell下一步就要执行该命令名对应的动作。这听起来就像是在戏剧舞台上，演员按照脚本演戏。Shell命令可以分为如下三类：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Shell内建函数（built-in function）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可执行文件（executable file）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;别名（alias）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Shell的内建函数是Shell自带的功能，而可执行文件是保存在Shell之外的脚本，提供了额外的功能。Shell必须在系统中找到对应命令名的可执行文件，才能正确执行。我们可以用绝对路径来告诉Shell可执行文件所在的位置。如果用户只是给出了命令名，而没有给出准确的位置，那么Shell必须自行搜索一些特殊的位置，也就是所谓的默认路径。Shell会执行第一个名字和命令名相同的可执行文件。这就相当于，Shell帮我们自动补齐了可执行文件的位置信息。我们可以通过which命令，来确定命令名对应的是哪个可执行文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;which&lt;/span&gt; &lt;span&gt;date&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别名是给某个命令一个简称，以后在Shell中就可以通过这个简称来调用对应的命令。在Shell中，我们可以用alias来定义别名：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$alias freak=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;free -h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Shell会记住我们的别名定义。以后我在这个Shell中输入命令freak时，都将等价于输入free -h。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Shell中，我们可以通过type命令来了解命令的类型。如果一个命令是可执行文件，那么type将打印出文件的路径。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$type &lt;span&gt;date&lt;/span&gt;&lt;span&gt;
$type &lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;总的来说，Shell就是根据空格和其他特殊符号，来让电脑理解并执行用户要求的动作。到了后面，我们还将看到Shell中其他的特殊符号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Shell的选择&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Shell是文本解释器程序的统称，所以包括了不止一种Shell。常见的Shell有sh、bash、ksh、rsh、csh等。在树莓派中，就安装了sh和bash两个Shell解释器。sh的全名是Bourne Shell。名字中的玻恩就是这个Shell的作者。而bash的全名是Bourne Again Shell。最开始在Unix系统中流行的是sh，而bash作为sh的改进版本，提供了更加丰富的功能。一般来说，都推荐使用bash作为默认的Shell。树莓派，以及其他Linux系统中广泛安装sh，都是出于兼容历史程序的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过下面的命令来查看当前的Shell类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; $SHELL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;echo用于在终端打印出文本。而$是一个新的Shell特殊符号。它提示Shell，后面跟随的不是一般的文本，而是用于存储数据的变量。Shell会根据变量名找到真正的文本，替换到变量所在的位置。SHELL变量存储了当前使用的Shell的信息你可以在bash中用sh命令启动sh，并可以用exit命令从中退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;命令的选项和参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们已经看到，一行命令里还可以包含着选项和参数。总的来说，选项用于控制命令的行为，而参数说明了命令的作用对象。比如说：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的命令中，选项-m影响了命令uname的行为，导致uname输出了树莓派的CPU型号。如果不是该选项的影响，uname输出的将是&quot;Linux&quot;。我们不妨把每个命令看做多功能的瑞士军刀，而选项让命令在不同的功能间切换。由一个&quot;-&quot;引领一个英文字母，这成为短选项。多个短选项的字母可以合在一起，跟在同一个&quot;-&quot;后面。比如，下面的两个命令就等价：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;uname&lt;/span&gt; -m -&lt;span&gt;r
$&lt;/span&gt;&lt;span&gt;uname&lt;/span&gt; -mr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外还有一种长选项，是用&quot;--&quot;引领一整个英文单词，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;date&lt;/span&gt; --version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的命令将输出date程序的版本信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果说选项控制了瑞士军刀的行为，那么参数就提供了瑞士军刀发挥用场的原材料。就拿echo这个命令来说，它能把字符打印到终端。它选择打印的对象，正是它的参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的时候，选项也会携带变量，以便来说明选项行为的原材料。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;date&lt;/span&gt; --set=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1999-01-01 08:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选项&quot;--set&quot;用于设置时间，用等号连接的，就是它的参数。date会把日期设置成这一变量所代表的日期。如果用短选项，那么就要用空格取代等号了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;date&lt;/span&gt; -s &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1999-01-01 08:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;值得注意的是，Shell对空格敏感。当一整个参数信息中包含了空格时，我们需要用引号把参数包裹起来，以便Shell能识别出这是一个整体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓的选项和参数提供给命令的附加信息。因此，命令最终会拿这些字符串做什么，是由命令自己决定的。因此，有时会发现一些特异的选项或参数用法。这个时候，你就要从文档中寻找答案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们可以在Bash中输入一行的命令。Bash会把输入的命令转化为特定的动作。从这一节起，我们将看到Bash的可编程性。Bash提供了某些类似于C语言那样的编程语法，从而允许你用编程的方式，来组合使用Linux系统。我们首先看Bash用变量存储数据的能力。正如我们在C语言中看到的，变量是内存中的一块儿空间，可以用于存储数据。我们可以通过变量名来引用变量中保持的数据。借助变量，程序员可以复用出现过的数据。Bash中也有变量，但Bash的变量只能存储文本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）变量赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bash和C类似，同样用“=”来表示赋值。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$var=World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就是把文本World存入名为var的变量，即赋值。根据Bash的语法，赋值符号“=”的前后不留空格。赋值号右边的文本内容会存入赋值号左边的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果文本中包含空格，那么你可以用单引号或双引号来包裹文本。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$var=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc bcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;或者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$var=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc bcd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash中，我们可以把一个命令输出的文本直接赋予给一个变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$now=`&lt;span&gt;date&lt;/span&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;借助``符号，date命令的输出存入了变量now。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可以把一个变量中的数据赋值给另一个变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$another=$var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;** 读入变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（昕梓补充）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）引用变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以用$var的方式来引用变量。在Bash中，所谓的引用变量就是把变量翻译成变量中存储的文本。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$var=&lt;span&gt;World
$&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 就会打印出World，即变量中保存的文本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash中，你还可以在一段文本中嵌入变量。Bash也会把变量替换成变量中保存的文本。比如： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; Hello$var&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 文本将打印出HelloWorld。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了避免变量名和尾随的普通文本混淆，我们也可以换用${}的方式来标识变量。比如说：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; $varIsGood&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 由于Bash中并没有varIsGood这个变量，所以Bash将打印空白行。但如果将命令改为： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; ${var}IsGood&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; Bash通过${}识别出变量var，并把它替换成数据。最终echo命令打印出WorldIsGood。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash中，为了把一段包含空格的文本当做单一参数，就需要用到单引号或双引号。你可以在双引号中使用变量。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello $var&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 将打印Hello World。与此相对，Bash会忽视单引号中的变量引用，所以单引号中的变量名只会被当做普通文本，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello $var&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 将打印Hello $var。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;数学运算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Bash中，数字和运算符都被当做普通文本。所以你无法像C语言一样便捷地进行数学运算。比如执行下面的命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$result=&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Bash并不会进行任何运算。它只会打印文本“1+2”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash中，你还可以通过$(())语法来进行数值运算。在双括号中你可以放入整数的加减乘除表达式。Bash会对其中的内容进行数值运算。比如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;echo&lt;/span&gt; $((&lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;5&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 将打印运算结果12。此外，在$(())中，你也可以使用变量。比如： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$var=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $(($var + (&lt;span&gt;5&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 将打印运算结果11。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以用Bash实现多种整数运算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 加法：$(( 1 + 6 ))。结果为7。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 减法：$(( 5 – 3 ))。结果为2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 乘法：$(( 2*2 ))。结果为4。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 除法：$(( 9/3 ))。结果为3。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 求余：$(( 5%3 ))。结果为2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 乘方：$(( 2**3 ))。结果为8。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，你就可以把数学运算结果存入变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$result=$(( &lt;span&gt;1&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt; ))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;返回代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Linux中，每个可执行程序会有一个整数的返回代码。按照Linux惯例，当程序正常运行完毕并返回时，将返回整数0。因此，C程序中返回0的语句，都出现在C程序中main函数的最后一句。例如下面的foo.c程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;

  a &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;
  b &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
  c &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这段程序可以正常运行。因此，它将在最后一句执行return语句，程序的返回代码是0。在Shell中，我们运行了程序后，可以通过$?变量来获知返回码。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;$gcc foo.c
$.&lt;/span&gt;/a.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;
$echo $&lt;/span&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个程序运行异常，那么这个程序将返回非0的返回代码。比如删除一个不存在的文件： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;rm&lt;/span&gt; none_exist.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
$&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在Linux中，可以在一个行命令中执行多个程序。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;touch&lt;/span&gt; demo.&lt;span&gt;file&lt;/span&gt;; &lt;span&gt;ls&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在执行多个程序时，我们可以让后一个程序的运行参考前一个程序的返回代码。比如说，只有前一个程序返回成功代码0，才让后一个程序运行： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;rm&lt;/span&gt; demo.&lt;span&gt;file&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rm succeed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果rm命令顺利运行，那么第二个echo命令将执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一种情况，是等到前一个程序失败了，才运行后一个程序，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;rm&lt;/span&gt; demo.&lt;span&gt;file&lt;/span&gt; || &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rm fail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果rm命令失败，第二个echo命令才会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Bash脚本&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;你还可以把多行的Bash命令写入一个文件，成为所谓的Bash脚本。当Bash脚本执行时，Shell将逐行执行脚本中的命令。编写Bash脚本，是我们开始实现Bash代码复用的第一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）脚本的例子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用文本编辑器编写一个Bash脚本hello_world.bash： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; Hello
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脚本的第一行说明了该脚本使用的Shell，即/bin/bash路径的Bash程序。脚本正文是两行echo命令。运行脚本的方式和运行可执行程序的方式类似，都是： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$./hello_world.bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，如果用户不具有执行Bash脚本文件的权限，那么他将无法执行Bash脚本。此时，用户必须更换文件权限，或者以其他身份登录，才能执行脚本。当脚本运行时，两行命令将按照由上至下的顺序依次执行。Shell将打印两行文本：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;World&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bash脚本是一种复用代码的方式。我们可以用Bash脚本实现特定的功能。由于该功能记录在脚本中，因此我可以反复地运行同一个文件来实现相同的功能，而不是每次想用的时候都要重新敲一遍命令。我们看一个简单的Bash脚本hw_info.bash，它将计算机的信息存入到名为log的文件中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information of Vamei's computer:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&lt;span&gt; log
lscpu &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt; log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）脚本参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和可执行程序类似，Bash脚本运行时，也可以携带参数。这些参数可以在Bash脚本中以变量的形式使用。比如test_arg.bash:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; $&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash中，你可以用$0、$1、$2……的方式，来获得Bash脚本运行时的参数。我们用下面的方式运行Bash脚本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$./test_arg.bash hello world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;$0是命令的第一部分，也就是./test_arg.bash。$1代表了参数hello，而$2代表了参数world。因此，上面程序将打印：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;./test_arg.bash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;world&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果变更参数，同一段脚本将有不同的行为。这大大提高了Bash脚本的灵活性。上面的hw_info.bash脚本中，我们把输出文件名写死成log。我们也可以修改脚本，用参数作为输出文件的文件名：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information of Vamei's computer:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; $&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
lscpu &lt;/span&gt;&amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;借助参数，我们就可以自由地设置输出文件的名字：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$./hw_info.bash output.&lt;span&gt;file&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）脚本的返回代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和可执行程序类似，脚本也可以有返回代码。还是按照惯例，脚本正常退出时返回代码0。在脚本的末尾，我们可以用exit命令来设置脚本的返回代码。我们修改hello_world.bash：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; Hello
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; World
exit &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实在脚本的末尾加一句exit 0并不必要。一个脚本如果正常运行完最后一句，会自动的返回代码0。在脚本运行后，我们可以通过$?变量查询脚本的返回代码： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$./&lt;span&gt;hello_world.bash
$&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果在脚本中部出现exit命令，脚本会直接在这一行停止，并返回该exit命令给出的返回代码。比如下面的demo_exit.bash:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt; hello
exit &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; world&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你可以运行该脚本，检查其输出结果，并查看其返回代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Bash中，脚本和函数有很多相似的地方。脚本实现了一整个脚本文件的程序复用，而函数复用了脚本内部的部分程序。一个函数可以像脚本一个包含多个指令，用于说明该函数如果被调用会执行哪些活动。在定义函数时，我们需要花括号来标识函数包括的部分： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; my_info (){
lscpu &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt;&lt;span&gt; log
}

my_info&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脚本一开始定义了函数my_info，my_info是函数名。关键字function和花括号都提示了该部分是函数定义。因此，function关键字并不是必须的。上面的脚本等效于：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

my_info (){
lscpu &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt;&lt;span&gt; log
&lt;/span&gt;&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt;&lt;span&gt; log
}

my_info&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;花括号中的三行命令，就说明了函数执行时需要执行的命令。需要强调的是，函数定义只是食谱，并没有转化成具体的动作。脚本的最后一行是在调用函数。只有通过函数调用，函数内包含的命令才能真正执行。调用函数时，只需要一个函数名就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;像脚本一样，函数调用时还可以携带参数。在函数内部，我们同样可以用$1、$2这种形式的变量来使用参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; my_info (){
lscpu &lt;/span&gt;&amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}

my_info output.&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
my_info another_output.&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在上面的脚本中，进行了两次函数调用。函数调用时，分别携带了参数output.file和another_output.file。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;跨脚本调用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在Bash中使用source命令，可以实现函数的跨脚本调用。命令source的作用是在同一个进程中执行另一个文件中的Bash脚本。比如说，有两个脚本，my_info.bash和app.bash。脚本my_info.sh中的内容是： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; my_info (){
lscpu &lt;/span&gt;&amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;uname&lt;/span&gt; –a &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;free&lt;/span&gt; –h &amp;gt;&amp;gt; $&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;脚本app.bash中的内容是： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

source my_info.bash
my_info output.&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行app.bash时，执行到source命令那一行时，就会执行my_info.bash脚本。在app.bash的后续部分，就可以使用my_info.bash中的my_info函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;逻辑判断&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们已经介绍了函数和脚本两种组合命令的方式。这两种方式都可以把多行命令合并起来，组成一个功能单元。函数和脚本都实现了一定程度的代码复用。从这一节起，我们将看到选择和循环两种语法结构，这两种语法结构可以改变脚本的运行顺序，从而编写出更加灵活的程序。Bash除了可以进行数值运算，还可以进行逻辑判断。逻辑判断是决定某个说法的真假。我们在生活中很自然地进行各种各样的逻辑判断。比如“3大于2”这个说法，我们会说它是真的。逻辑判断就是对一个说法判断真假。在Bash中，我们可以用test命令来进行逻辑判断：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$test &lt;span&gt;3&lt;/span&gt; -gt &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;命令test后面跟有一个判断表达式，其中的-gt表示大于，即greater than。由于“3大于2”这一表达式为真，所以命令的返回代码将是0。如果表达式为1，那么命令的返回代码是1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$test &lt;span&gt;3&lt;/span&gt; -lt &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表达式中的-lt表示小于，即less than。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数值大小和相等关系的判断，是最常见的逻辑判断。除了上面的大于和小于判断，我们还可以进行以下的数值判断：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;等于： &lt;span class=&quot;cnblogs_code&quot;&gt;$test &lt;span&gt;3&lt;/span&gt; -eq &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不等于： &lt;span class=&quot;cnblogs_code&quot;&gt;$test &lt;span&gt;3&lt;/span&gt; -ne &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;大于等于： &lt;span class=&quot;cnblogs_code&quot;&gt;$test &lt;span&gt;5&lt;/span&gt; -ge &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;小于等于： &lt;span class=&quot;cnblogs_code&quot;&gt;$test &lt;span&gt;3&lt;/span&gt; -le &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bash中最常见的数据形式是文本，因此也提供了很多关于文本的判断：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;文本相同: &lt;span class=&quot;cnblogs_code&quot;&gt;$test abc = abx; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文本不同： &lt;span class=&quot;cnblogs_code&quot;&gt;$test abc != abx; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;按照词典顺序，一个文本在另一个文本之前： &lt;span class=&quot;cnblogs_code&quot;&gt;$test apple &amp;gt; tea; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;按照词典顺序，一个文本在另一个文本之后： &lt;span class=&quot;cnblogs_code&quot;&gt;$test apple &amp;lt; tea; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bash还可以对文件的状态进行逻辑判断：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;检查一个文件是否存在： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –e a.out; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否存在，而且是普通文件： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –f &lt;span&gt;file&lt;/span&gt;.txt; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否存在，而且是目录文件： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –d myfiles; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否存在，而且是软连接： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –L a.out; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否可读： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –r &lt;span&gt;file&lt;/span&gt;.txt; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否可写： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –&lt;span&gt;w&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;.txt; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;检查一个文件是否可执行： &lt;span class=&quot;cnblogs_code&quot;&gt;$test –x &lt;span&gt;file&lt;/span&gt;.txt; &lt;span&gt;echo&lt;/span&gt; $?&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在做逻辑判断时，可以把多个逻辑判断条件用“与、或、非”的关系组合起来，形成复合的逻辑判断。 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;!&lt;span&gt; expression
expression1 –a expression2
expression1 –o expression2&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;选择结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;逻辑判断可以获得计算机和进程的状态。进一步，Bash可以根据逻辑判断，让程序有条件地运行，这也就是所谓的选择结构。选择结构是一种语法结构，可以让程序根据条件决定执行哪一部分的指令。最早的程序都是按照指令顺序依次执行。选择结构打破了这一顺序，给程序带来更高的灵活性。最简单的，我们可以根据条件来决定是否执行某一部分程序，比如下面的demo_if.bash脚本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

var &lt;/span&gt;= `&lt;span&gt;whoami&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $var = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are my God.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个脚本中使用了最简单的if结构。关键字if后面跟着[]，里面是一个逻辑表达式。这个逻辑表达式就是if结构的条件。如果条件成立，那么if将执行then到fi之间包含的语句，我们称之为隶属于then的代码块。如果条件不成立，那么then的代码块不执行。这个例子的条件是判断用户是否为root。因此，如果是非root用户执行该脚本，那么Shell不会打印任何内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可以通过if...then...else...结构，让Bash脚本从两个代码块中选择一个执行。该选择结构同样有一个条件。如果条件成立，那么将执行then附属的代码块，否则执行else附属的代码块。下面的demo_if_else.bash脚本是一个小例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

filename&lt;/span&gt;=$&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; [ -&lt;span&gt;e $filename ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$filename exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$filename NOT exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The End&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if后面的“-e $filename”作为判断条件。如果条件成立，即文件存在，那么执行then部分的代码块。如果文件不存在，那么脚本将执行else语句中的echo命令。末尾的fi结束整个语法结构。脚本继续以顺序的方式执行剩余内容。运行脚本： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$./demo_if_else.bash a.out&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;脚本会根据a.out是否存在，打印出不同的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看到，在使用if...then...else...结构时，我们可以实现两部分代码块的选择执行。而在then代码块和else代码块内部，我们可以继续嵌套选择结构，从而实现更多个代码块的选择执行。比如脚本demo_nest.bash:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

var&lt;/span&gt;=`&lt;span&gt;whoami&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are $var&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [ $var = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are my God.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;  if&lt;/span&gt; [ $var = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vamei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;  then&lt;/span&gt;
&lt;span&gt;    echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are a happy user.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  else&lt;/span&gt;
&lt;span&gt;    echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are the Others.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  fi&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bash下，我们还可以用case语法来实现多程序块的选择执行。比如下面的脚本demo_case.bash： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

var&lt;/span&gt;=`&lt;span&gt;whoami&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are $var&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;case&lt;/span&gt; $var &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
root)
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are God.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
vamei)
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are a happy user.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
&lt;/span&gt;*&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You are the Others.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
;;
&lt;/span&gt;&lt;span&gt;esac&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个脚本和上面的demo_nest.bash功能完全相同。可以看到case结构与if结构的区别。关键字case后面不再是逻辑表达式，而是一个作为条件的文本。后面的代码块分为三个部分，都以文本标签)的形式开始，以;;结束。在case结构运行时，会逐个检查文本标签。当条件文本和文本标签可以对应上时，Bash就会执行隶属于该文本标签的代码块。如果是用户vamei执行该Bash脚本，那么条件文本和vamei标签对应上，脚本就会打印：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;You are a happy user.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文本标签除了是一串具体的文本，还可以包含文本通配符。结构case中常用的通配符包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通配符 含义 文本标签例子 通过的条件文本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;* 任意文本 *) Xyz, 123, …&lt;/span&gt;&lt;br/&gt;&lt;span&gt;? 任意一个字符 a?c) abc, axc, …&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[] 范围内一个字符 [1-5][b-d]) 2b, 3d, …&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的程序中最后一个文本标签是通配符*，即表示任意条件文本都可以触发此段代码块的运行。当然，前提是前面的几个文本标签都没有“截胡”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;循环结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;循环结构是编程语言中另一种常见的语法结构。循环结构的功能是重复执行某一段代码，直到计算机的状态符合某一条件。在while语法中，Bash会循环执行隶属于while的代码块，直到逻辑表达式不成立。比如下面的demo_while.bash：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

now&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
deadline&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; --&lt;span&gt;date&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; [ $now -&lt;span&gt;lt $deadline ]
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  date&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not yet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  sleep&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
  now&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now, deadline reached&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关键字do和done之间的代码是隶属于该循环结构的代码块。在while后面跟着条件，该条件决定了代码块是否重复执行下去。这个条件是用当前的时间与目标时间对比。如果当前时间小于目标时间，那么代码块就会重复执行下去。否则，Bash将跳出循环，继续执行后面的语句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果while的条件始终是真，那么循环会一直进行下去。下面的程序就是以无限循环的形式，不断播报时间： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; 
&lt;span&gt;do&lt;/span&gt;
  &lt;span&gt;date&lt;/span&gt;
  &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法while的终止条件是一个逻辑判断。如果在循环过程中改变逻辑判断的内容，那么我们很难在程序执行之前预判循环进行的次数。正如我们之前在demo_while.bash中看到的，我们在循环进行过程中改变着作为条件的逻辑表达式，不断地更新参与逻辑判断的当前时间。与while语法对应的是for循环。这种语法会在程序进行前确定好循环进行的次数，比如demo_for.bash： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; `&lt;span&gt;ls&lt;/span&gt; log*&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
  &lt;span&gt;rm&lt;/span&gt;&lt;span&gt; $var
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个例子中，命令ls log*将返回所有以log开头的文件名。这些文件名之间由空格分隔。循环进行时，Bash会依次取出一个文件名，赋值给变量var，并执行do和done之间隶属于for结构的程序块。由于ls命令返回的内容在是确定的，因此for循环进行的次数也会在一开始确定下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在for语法中，我们也可以使用自己构建一个由空格分隔的文本。由空格区分出来的每个子文本会在循环中赋值给变量。比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; user &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vamei anna yutian
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
&lt;span&gt;  echo&lt;/span&gt;&lt;span&gt; $user
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，for循环还可以和seq命令配合使用。命令seq用于生成一个等差的整数序列。命令后面可以跟3个参数，第一个参数表示整数序列的开始数字，第二个参数表示每次增加多少，最后一个参数表示序列的终点。因此，下面命令： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$&lt;span&gt;seq&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将返回：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;1 3 5 7 9&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;可以看到，seq返回的也是由空格分隔开的文本。因此，seq的返回结果也可用于for循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合for循环和seq命令，我们可以解一些有趣的数学问题。比如高斯求和，是要计算从1到100的所有整数的和。我们可以用Bash解决： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

total&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; `&lt;span&gt;seq&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
  total&lt;/span&gt;=$(( $total +&lt;span&gt; $number ))
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; $total&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这个问题还可以用do while循环来求解：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash

total&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
number&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; :
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; [ $number -gt &lt;span&gt;100&lt;/span&gt;&lt;span&gt; ]
  &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    break
  &lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

  total&lt;/span&gt;=$(( $total +&lt;span&gt; $number ))
  number&lt;/span&gt;=$(($number + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; $total&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里break语句的作用是在满足条件时跳出循环。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想计算1到100所有不被3整数的和，则可以使用continue语句，跳过所有被3整数的数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/&lt;span&gt;bash
total&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt; `&lt;span&gt;seq&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (( $number % &lt;span&gt;3&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )) 
  &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;&lt;span&gt;
    continue
  &lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
  total&lt;/span&gt;=$(( $total +&lt;span&gt; $number ))
&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; $total&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Bash与C语言&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;到了这里，我们已经介绍完Bash语言的基本语法。Bash语言和C语言都是Linux下的常用语言。它们都能通过特定的语法来编写程序，而程序运行后都能实现某些功能。尽管在语法细节上存在差异，但两种语言都有以下语法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;变量：在内存中储存数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;循环结构：重复执行代码块&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选择结构：根据条件执行代码块&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数：复用代码块&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;编程语言的作者在设计语言时，往往会借鉴已有编程语言的优点。这是编程语言之间相似性的一大原因。程序员往往要掌握不止一套编程语言。相似的语法特征，会让程序员在学习新语言时感到亲切，从而促进语言的推广。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bash和C的相似性，也来自于它们共同遵守的编程范式——面向过程编程。支持面向过程编程的语言，一般都会提供类似于函数的代码封装方式。函数把多行指令包装成一个功能。只要知道了函数名，程序可以通过调用函数来使用函数功能，最终实现代码复用。除了面向过程编程，还有面向对象和函数式的编程范式。每种编程范式都提供了特定的代码封装方式，并达到代码复用的目的。值得注意的是，近年来出现的新语言往往会支持不止一种编程范式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了相似性，我们还应该注意到Bash和C程序的区别。Bash的变量只能是文本类型，C的变量却可以有整数、浮点数、字符等类型。Bash的很多功能，如加减乘除运算，都是调用其他程序实现的。而C直接就可以进行加减乘除运算。可以说，C语言是一门真正的编程语言。C程序最终会编译成二进制的可执行文件。CPU可以直接理解这些文件中的指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一方面，Bash是一个Shell。它本质上是一个命令解释器程序，而不是编程语言。用户可以通过命令行的方式，来调用该程序的某些功能。所谓的Bash编程，只是命令解释器程序提供的一种互动方法。Bash脚本只能和Bash进程互动。它不能像C语言一样，直接调用CPU的功能。因此，Bash能实现的功能会受限，运行速度上也比不上可执行文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但另一反面，Bash脚本也有它的好处。 C语言能接触到很底层的东西，但使用起来也很复杂。有时候，即使你已经知道如何用C实现一个功能，写代码依然是一个很繁琐的过程。Bash正相反。由于Bash可以便捷地调用已有的程序，因此很多工作可以用数行的脚本解决。此外，Bash脚本不需要编辑，就可以由Bash进程理解并执行。因此，开发Bash脚本比写C程序要快很多。Linux的系统运维工作，如定期备份、文件系统管理等，就经常使用到Bash脚本。总之，Bash编程知识是晋级为资深Linux用户的必要条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Dec 2017 14:55:00 +0000</pubDate>
<dc:creator>Vamei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vamei/p/8151169.html</dc:identifier>
</item>
<item>
<title>小白的Python之路 day4 生成器 - 钱多多的妖孽人生</title>
<link>http://www.cnblogs.com/ManyQian/p/8151344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8151344.html</guid>
<description>&lt;p&gt;&lt;strong&gt; 看下面例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171230191932913-1109158216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表生成式的作用：&lt;span&gt;主要是让代码更简洁（还有装X的效果）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;通过列表生成式，我们可以直接创建一个列表。但是，&lt;span&gt;受到内存限制&lt;/span&gt;，列表容量肯定是有限的。而且，创建一个包含&lt;span&gt;100万个元素&lt;/span&gt;的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，&lt;span&gt;从而节省大量的空间&lt;/span&gt;。在Python中，这种&lt;span&gt;一边循环一边计算的机制&lt;/span&gt;，称为生成器：generator。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的&lt;code&gt;[]&lt;/code&gt;改成&lt;code&gt;()&lt;/code&gt;，就创建了一个generator：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171230201716835-1357252.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;特点：只有在调用时，才会生成相应的数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　只记录当前位置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　只有一个__next__()方法　#左右两边两个下划线组成的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，我们创建了一个generator后，基本上永远不会调用__&lt;code&gt;next__()&lt;/code&gt;，而是通过&lt;code&gt;for&lt;/code&gt;循环来迭代它，并且不需要关心&lt;code&gt;StopIteration&lt;/code&gt;的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;generator非常强大。如果推算的算法比较复杂，用类似列表生成式的&lt;code&gt;for&lt;/code&gt;循环无法实现的时候，还可以用函数来实现。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     n, a, b = 0, 0, 1
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         n = n + 1
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;return 'done'   暂时没用到&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; '''
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;注意，赋值语句：
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; a, b = b, a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;相当于：
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; t = (b, a + b) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; t是一个tuple&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; a =&lt;span&gt; t[0]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; b = t[1]&lt;br/&gt;15 '''
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;仔细观察，可以看出，&lt;code&gt;fib&lt;/code&gt;函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说，上面的函数和generator仅一步之遥。要把&lt;code&gt;fib&lt;/code&gt;函数变成generator，只需要把&lt;code&gt;print(b)&lt;/code&gt;改为&lt;code&gt;yield b&lt;/code&gt;就可以了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201712/1274477-20171230214709726-1700533658.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是用&lt;code&gt;for&lt;/code&gt;循环调用generator时，发现拿不到generator的&lt;code&gt;return&lt;/code&gt;语句的返回值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果想要拿到返回值，必须捕获&lt;code&gt;StopIteration&lt;/code&gt;错误，返回值包含在&lt;code&gt;StopIteration&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; f = fib(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         x = f.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,x)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt; StopIteration as e:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当try中的程序执行错误了，才会执行except下面的代码&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Generator return value:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e.value)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行结果&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; f: 1
&lt;span&gt;12&lt;/span&gt; f: 1
&lt;span&gt;13&lt;/span&gt; f: 2
&lt;span&gt;14&lt;/span&gt; f: 3
&lt;span&gt;15&lt;/span&gt; f: 5
&lt;span&gt;16&lt;/span&gt; Generator &lt;span&gt;return&lt;/span&gt; value: ----done---  #抓获&lt;code&gt;StopIteration&lt;/code&gt;错误，返回值包含在&lt;code&gt;StopIteration&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;中，就不会再报错f.__next__()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于这个异常处理，后续会继续发博客更新。。。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 30 Dec 2017 14:05:00 +0000</pubDate>
<dc:creator>钱多多的妖孽人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8151344.html</dc:identifier>
</item>
<item>
<title>Slf4j与其他日志系统兼容的使用 - mutouyihao</title>
<link>http://www.cnblogs.com/mutouyihao/p/8151325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mutouyihao/p/8151325.html</guid>
<description>&lt;p&gt;java生产的各种框架（如spring等）里各个框架会使用不同的日志体系，多个不同日志在一个jvm里混搭会出现一定问题 ，这里梳理一下java体系里常见的日志框架，以SFL4j为中心介绍下跟各个日志框架的关系，介绍下生产环境如何打理各种日志框架。&lt;/p&gt;

&lt;p&gt;在java的体系里，主要有slf4j和common-logging两种日志体系接口。实现的框架有很多，主流的诸如logback、log4j等。&lt;/p&gt;
&lt;p&gt; 当然，虽然都是接口，但两者也可以通过桥接包实现相互的日志代理输出。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/400451/201712/400451-20171230211200960-171386181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;common-logging挂载的日志实现常为log4j。在初始化的时候，如果没有特殊指定要挂载谁，会自动按上图顺序去实例化实现，log4jLogger封装了log4j的logger，打印日志的时候调用到log4j过去。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. SLF4j 的桥接和被桥接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;slf4j作为一个接口定义，底层可以有很多实现框架，同时也可以支持别的日志实现或者框架打到sfl4j上。它的实现是基于不同的桥接包。&lt;/p&gt;
&lt;h2&gt;2.1 slf4j的桥接&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/400451/201712/400451-20171230213908070-1738351272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;slf4j作为接口定义，下面有很多种实现。实现原理是获取ILoggerFactory时执行初始化，初始化过程绑定实现对象：load出所有实现StaticLoggerBinder的类，然后获取他的单例，后面执行getLogger的时候都是调用这个单例类的方法获取对应有具体实现日志功能的Logger对象。如果有多个实现，之后绑定其中的一个。这种情况需要排除掉不需要的日志实现类。&lt;/p&gt;
&lt;h2&gt;2.2 slf4j的被桥接&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/400451/201712/400451-20171230212219320-1241775945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了其他日志系统如何接入到slf4j日志体系，其中基本原理是针对各自日志体系做了代理 ，输出到了sfl4j接口中，具体实现可以去看桥接包的实现。基本都是对原日志体现做了重新实现，然后底层实际调用日志输出的方法是走到了slf4j上面 。&lt;/p&gt;
&lt;p&gt;只有jul是个例外，因为是java自带jdk实现，没法去重新那些类，这个地方根据jul的handler扩展机制实现了一个slf4j的handler然后把日志写到slf4j上面。同时要生效的话，还要修改jre/lib/logging.properties把新的handler配置到.handlers属性中。一般生产不会去这么搞。&lt;/p&gt;

&lt;p&gt;实际项目应用的时候要注意，桥接和被桥接的包不能同时出现，不然会出现死循环了，比如sfl4j既桥接了log4j又被log4j桥接，那log4j输出调用会指向slf4j，slf4j又指向log4j如此循环。一定要注意排除掉无用的包。&lt;/p&gt;
&lt;p&gt;生产建议：slf4j-api下挂载的实现只保留logback，上层的日志打印桥接可以存在都指向到slf4j。&lt;/p&gt;
&lt;p&gt;参考如下依赖，其他关于log的包统统排掉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38.5&quot;&gt;
&lt;pre readability=&quot;10&quot;&gt;
&amp;lt;dependencies&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.7.24&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.7.14&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;log4j-over-slf4j&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.7.24&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 测试代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestLoggers {

    /**
     * slf4j-api --&amp;gt;slf4j-log4j12 -&amp;gt; log4j
     */
    public void testSfl4jUpLog4j(){
        org.slf4j.Logger logger = LoggerFactory.getLogger(TestLoggers.class.getName());
        logger.info(&quot;Slf4j print use log4j&quot;);
    }

    /**
     * slf4j-api --&amp;gt; slf4j-jcl --&amp;gt; common-logging-api (自动向log4j)--&amp;gt; log4j
     */
    public void testSlf4j2CommonLogging(){
        org.slf4j.Logger logger = LoggerFactory.getLogger(TestLoggers.class.getName());
        logger.warn(&quot;Slf4j print to common logging&quot;);
    }

    /**
     * log4j-over-slf4j--&amp;gt; slf4j-api--&amp;gt; logback-classic
     */
    public void testLog4j2Slf4j(){
        org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(TestLoggers.class.getName());
        logger.info(&quot;Log4j print to slf4j&quot;);
    }

    /**
     * jcl-over-slf4j --&amp;gt; sfl4-api--&amp;gt;logback
     */
    public void testCommonLogging2Sl4j(){
        Log log = LogFactory.getLog(TestLoggers.class.getName());
        log.info(&quot;common log to slf4j&quot;);
    }

    /**
     * jul(console default)--&amp;gt;jul-to-slf4j--&amp;gt;slf4j--&amp;gt;logback
     * 要在jre/lib/logging.properties 中.handlers添加org.slf4j.bridge.SLF4JBridgeHandler
     */
    public void testJul2Slf4j(){
        java.util.logging.Logger logger = java.util.logging.Logger.getLogger(TestLoggers.class.getName());
        logger.info(&quot;jul print to slf4j&quot;);
    }

    public static void main(String[] args) {
        TestLoggers tester = new TestLoggers();
        tester.testSlf4j2CommonLogging();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试maven依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.24&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-logging-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--&amp;lt;dependency&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;artifactId&amp;gt;jcl-over-slf4j&amp;lt;/artifactId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;version&amp;gt;1.7.14&amp;lt;/version&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/dependency&amp;gt;--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j-over-slf4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.24&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--&amp;lt;dependency&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;artifactId&amp;gt;jul-to-slf4j&amp;lt;/artifactId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/dependency&amp;gt;--&amp;gt;


        &amp;lt;!--&amp;lt;dependency&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/dependency&amp;gt;--&amp;gt;


        &amp;lt;!--&amp;lt;dependency&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;--&amp;gt;
            &amp;lt;!--&amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;--&amp;gt;
        &amp;lt;!--&amp;lt;/dependency&amp;gt;--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-jcl&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.24&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 参考：&lt;/p&gt;
&lt;p&gt;https://www.slf4j.org/legacy.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/chenhongliang/p/5312517.html&lt;/p&gt;


</description>
<pubDate>Sat, 30 Dec 2017 13:56:00 +0000</pubDate>
<dc:creator>mutouyihao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mutouyihao/p/8151325.html</dc:identifier>
</item>
</channel>
</rss>