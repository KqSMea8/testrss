<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Docker 基础 : 镜像 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/8901728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/8901728.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;目录&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;镜像是 Docker 的三大核心概念之一。&lt;/strong&gt;Docker 运行容器前需要本地存在对应的镜像，如果本地没有对应的镜像，Docker 会尝试从默认的镜像仓库下载。当然用户也可以通过配置，使用自定义的镜像仓库。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;本文将介绍镜像的具体操作&lt;/strong&gt;，包括使用 pull 命令从 Docker Hub 的镜像仓库中拉取(下载)公共镜像；查看本地已有的镜像信息；使用 search 命令搜索镜像；删除镜像标签和镜像文件；创建用户自定义镜像并上传到 Docker Hub 镜像仓库。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;与镜像相关的操作都被定义在 &lt;strong&gt;docker image&lt;/strong&gt; 子命令中，虽然不带 image 的格式依然被兼容，但带上 image 后会让命令更容易理解，也会有更好的自动补全效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地镜像是运行容器的前提，所以在运行容器前我们需要使用 docker image pull 命令从网络上的镜像仓库把镜像拉取到本地。该命令的格式为：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;docker image pull [OPTIONS] NAME[:TAG|@DIGEST]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只指定了镜像的名称，默认会选择拉取 latest 标签标记的镜像。比如我们要拉取最新的 ubuntu 镜像：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image pull ubuntu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421152958729-1269563722.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该命令实际拉取的是 ubuntu:latest 镜像，当前的最新版本为 16.04。从上图中可以看到，docker 的镜像其实被分成了很多的层，每层保存一些特定的文件。&lt;/span&gt;&lt;span&gt;上面的命令实际相当于：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image pull registry.hub.docker.com/ubuntu:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;即从默认的数据仓库服务器 registry.hub.docker.com 中拉取 ubuntu 仓库中的最新镜像。如果我们感觉从 Docker Hub 上拉取镜像太慢，可选择从其它的数据仓库服务器上拉取，比如 Docker Hub 在国内部署的服务器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image pull registry.docker-cn.com/library/ubuntu:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;镜像下载到本地后就可运行容器了，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker run --&lt;span&gt;rm&lt;/span&gt; ubuntu &lt;span&gt;echo&lt;/span&gt; hello docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421153059503-1464283559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看镜像信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 &lt;strong&gt;docker image ls&lt;/strong&gt;(或 docker images) 命令可以列出本地存储的镜像：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ docker image &lt;span&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421153227642-294590689.png&quot; alt=&quot;&quot; width=&quot;773&quot; height=&quot;61&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出的信息中包含的内容有：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;REPOSITORY&lt;/strong&gt;：说明镜像来自哪个仓库，比如 ubuntu 或 registry.docker-cn.com/library/ubuntu。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;TAG&lt;/strong&gt;：镜像的标签信息，比如 14.04 或 latest。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;IMAGE ID&lt;/strong&gt;：标识镜像的 ID 号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;CREATED&lt;/strong&gt;：创建镜像的时间。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;SIZE&lt;/strong&gt;：镜像大小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中镜像的 ID 信息十分重要，它唯一的标识了镜像。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;TAG 信息用来标记来自同一个仓库(比如 ubuntu)的不同镜像。例如 ubuntu 仓库中有多个镜像，可以通过 TAG 信息来区分它们，TAG 13.04、14.04 和 16.04 都代表了不同的发行版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 &lt;strong&gt;docker image tag&lt;/strong&gt; 命令为本地的镜像添加新的标签还可以方便我们的使用，比如为 ubuntu:14.04 镜像添加下面的标签：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image tag ubuntu:&lt;span&gt;14.04&lt;/span&gt; oldubuntu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后就可以通过 oldubuntu 来引用 ubuntu:14.04 镜像了。其实从 docker image ls 的输出中我们可以看到，它们引用的是同一个镜像 ID：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421153409143-664844666.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们添加的新标签就像给镜像取了个别名一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 &lt;strong&gt;docker image inspect&lt;/strong&gt; 命令可以获取镜像的详细信息，比如查看 ubuntu:latest 镜像的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image inspect ubuntu:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421153451871-1802524830.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;362&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个命令的输出很长，上图只是截取了一小部分的信息。它输出的是一个 JSON 格式的信息，一般情况下我们会有的放矢的通过 -f 选项取其中的某一部分。比如只获取镜像的 Architecture 信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image inspect -f {{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Architecture&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}} ubuntu:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;搜索镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了直接在 Docker Hub 的官方网站上搜索镜像资源，还可以通 &lt;strong&gt;docker search&lt;/strong&gt; 命令以命令行的方式进行搜索，比如搜索 mysql 镜像：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ docker search mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421153619553-1539233963.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;119&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该图只截取了一部分结果。个人感觉这个命令的价值有限，因为我们在选择镜像时还是需要慎重的。往往要在 Docker Hub 的官方网站上查看镜像相关的详细信息，然后才会决定是否使用，而 docker search 命令提供的信息过于有限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于不再需要的镜像我们可以使用 &lt;strong&gt;docker image rm&lt;/strong&gt; 命令进行删除，以释放镜像占用的磁盘空间。我们可以为 docker image rm 命令传递镜像的标签或 ID，这两种方式略微有些区别，下面我们将分别介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用进行的标签删除镜像&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;比如删除标签为 mysql:5.6 的镜像：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image &lt;span&gt;rm&lt;/span&gt; mysql:&lt;span&gt;5.6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154022088-173583009.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;镜像的所有内容一下就被删除了(很多镜像层被删除掉)，再来删除 ubuntu:14.04 试试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image &lt;span&gt;rm&lt;/span&gt; ubuntu:&lt;span&gt;14.04&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154058595-1843745067.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么这次只删除了一点点东西？再去看看进行列表，oldubuntu 还在，并且引用着 ID 为 3b853789146f 的镜像：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154139602-1101903714.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原来，对于被多个标签引用的镜像 ID，删除标签时只是把那个标签删掉了，并会真正删除镜像文件。现在再删除一次 oldubuntu 试试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154212424-337866708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于 oldubuntu 是最后一个引用该镜像的标签，所以删除该标签会同时删除该镜像的所有文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用镜像 ID 删除镜像&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;对于镜像 ID 为 c9d990395902 的镜像来说，也有两个标签引用着它，分别是 ubuntu:latest 和 newubuntu：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154324358-929672504.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在让我们尝试通过镜像 ID 删除它：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image &lt;span&gt;rm&lt;/span&gt; c9d990395902
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154358724-717452113.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时 docker 检测到该镜像 ID 被引用了多次就机智的报错了，并且终止了删除操作。同样如果由其它的镜像引用了该 ID 的镜像， docker 同样会报错并终止删除操作。所以，只有当一个镜像不被多个标签引用，也没其它镜像引用它时，才可以被通过镜像 ID 删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过不同的方式创建镜像，比如基于已有容器进行创建和基于 Dockerfile 文件进行创建。笔者在《&lt;a href=&quot;http://www.cnblogs.com/sparkdev/p/6357614.html&quot; target=&quot;_blank&quot;&gt;Docker 基础 : Dockerfile&lt;/a&gt;》一文中介绍过通过 docker build 命令利用 Dockerfile 文件创建镜像，所以这里只介绍如何通过 &lt;strong&gt;docker container commit&lt;/strong&gt; 命令基于已有容器创建镜像。&lt;/span&gt;&lt;span&gt;我们先启动一个以 ubuntu:latest 为镜像的容器，然后在当前目录下创建一个名为 nickfile 的文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker run -it ubuntu:latest bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154727583-437868059.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在文件创建后退出容器，但要记住该容器的 ID 为：7e26732e14e6。然后执行下面的命令创建镜像：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker container commit -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;add file nickfile.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 7e26732e14e6 nickimage
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154755664-2056187958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;镜像创建成功后，你可以在镜像列表中看到名称为 nickimage 的镜像：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154825963-2130527954.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面运行一个基于 nickimage 的容器，看看 nickfile 是否存在：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker run --&lt;span&gt;rm&lt;/span&gt; nickimage &lt;span&gt;ls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421154856734-1328431057.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验明正身！我们在容器中创建的文件 nickfile 已经被成功的添加到 nickimage 镜像中了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导出和导入镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当碰到没有网络的环境时，如何获取镜像呢？答案是在能够获得镜像的环境中把镜像导出为文件，然后通过 U 盘等设备拷贝到目标环境中，再进行导入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;导出镜像&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;通过 &lt;strong&gt;docker image save&lt;/strong&gt; 命令可以把镜像导出为本地文件，比如导出 ubuntu:latest 镜像为 ubuntu1604.tar：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image save -o ubuntu1604.&lt;span&gt;tar&lt;/span&gt; ubuntu:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般我们还会再压缩一下，这样最终的文件会小不少：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;tar&lt;/span&gt; -czf ubuntu1604.&lt;span&gt;tar&lt;/span&gt;.gz ubuntu1604.&lt;span&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421155020782-705320650.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件大小从 112M 压缩到了 41M，效果还是很明显的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;导入镜像&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;把 ubuntu1604.tar.gz 文件拷贝到目标系统上后先要解压出 ubuntu1604.tar 文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;tar&lt;/span&gt; -xf ubuntu1604.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后通过 &lt;strong&gt;docker image load&lt;/strong&gt; 命令执行镜像的导入操作：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image load -i ubuntu1604.&lt;span&gt;tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样就 OK 了，用 docker image ls 命令看看，是不是已经可以看到 ubuntu:latest 镜像了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上传镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用 &lt;strong&gt;docker image push&lt;/strong&gt; 命令把镜像上传到镜像仓库服务器，默认是上传到 Docker Hub 的镜像仓库，此时事先需要注册用户并进行登录。上传镜像的命令格式为：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;docker image push NAME[:TAG]&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;比如笔者在 Docker Hub 注册了账号 ljfpower，并通过 docker login 命令完成了登录操作(需要输入用户名和密码进行验证)。接下来就可把本地的镜像上传到镜像仓库服务器了。在上传前需要给镜像打上合法的标签(用户账号/仓库名称:TAG)，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image tag azcli:&lt;span&gt;1.0&lt;/span&gt; ljfpower/azcli:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后上传这个标签就行了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker image push ljfpower/azcli:latest 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上传后你就可以在 Docker Hub 上看到这个镜像了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201804/952033-20180421155141950-1354295174.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;镜像是使用 docker 的前提，所以本文比较详细的介绍了 docker 镜像相关的操作，包括获取、查看、搜索、创建、删除、导出、导入等。希望对大家了解、学习 docker 有所帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;《Docker 技术入门与实战》&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 22:59:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/8901728.html</dc:identifier>
</item>
<item>
<title>EF 6.x、EF Core实现dynamic动态查询和EF Core实现多个上下文实例池你了解多少？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8921881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8921881.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;很长一段时间没有写博客了，今天补上一篇吧，偶尔发现不太愿意写博客了，太耗费时间，不过还是在坚持当中，毕竟或许写出来的东西能帮到一些童鞋吧，接下来我们直奔主题。无论是在在EF 6.x还是EF Core中对于原始查询的APi都比较鸡肋，比如我们只想查询单个值，它们是不支持的，比如我们只想有些列，它们也是不支持的，太多太多不支持，唯一支持的是只能返回表中所有列即类中所有字段。所以大部分情况下我都是写原生SQL，原始查询都没怎么用到过，最近有对热爱EF的同行问到怎么利用SqlQuery实现动态查询，我没有答案，压根没想过用这个方法，私下看了看，还是给出一点点思考吧。若对您有帮助就好，没有用就当是我补上了一篇博客吧。&lt;/p&gt;
&lt;h2&gt;EF 6.x和EF Core实现动态查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;dynamic&lt;/span&gt;&amp;gt; SqlQueryDynamic(&lt;span&gt;this&lt;/span&gt; DbContext db, &lt;span&gt;string&lt;/span&gt; Sql, &lt;span&gt;params&lt;/span&gt;&lt;span&gt; SqlParameter[] parameters)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cmd =&lt;span&gt; db.Database.Connection.CreateCommand())
            {
                cmd.CommandText &lt;/span&gt;=&lt;span&gt; Sql;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cmd.Connection.State !=&lt;span&gt; ConnectionState.Open)
                {
                    cmd.Connection.Open();
                }

                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; parameters)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbParameter =&lt;span&gt; cmd.CreateParameter();
                    dbParameter.DbType &lt;/span&gt;=&lt;span&gt; p.DbType;
                    dbParameter.ParameterName &lt;/span&gt;=&lt;span&gt; p.ParameterName;
                    dbParameter.Value &lt;/span&gt;=&lt;span&gt; p.Value;
                    cmd.Parameters.Add(dbParameter);
                }

                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; dataReader =&lt;span&gt; cmd.ExecuteReader())
                {
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (dataReader.Read())
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = &lt;span&gt;new&lt;/span&gt; ExpandoObject() &lt;span&gt;as&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fieldCount = &lt;span&gt;0&lt;/span&gt;; fieldCount &amp;lt; dataReader.FieldCount; fieldCount++&lt;span&gt;)
                        {
                            row.Add(dataReader.GetName(fieldCount), dataReader[fieldCount]);
                        }
                        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; row;
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么最终如上查询后返回动态集合，我们该如何转换为集合对象呢？我想都没想如下直接先序列化然后反序列化，若您有更好的解决方案，请自行实现即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dynamicOrders = ctx.SqlQueryDynamic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from dbo.Orders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ordersJson =&lt;span&gt; JsonConvert.SerializeObject(dynamicOrders);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orders = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;Order&amp;gt;&amp;gt;&lt;span&gt;(ordersJson);
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201804/589642-20180424000552729-456863440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然上述我只是简单查询了一个表，若您有多个表也是好使的，最后反序列化为不同的对象即可，未经测试，您可自行测试。&lt;/p&gt;
&lt;h2&gt;EF Core使用多个上下文实例池&lt;/h2&gt;
&lt;p&gt;有很多人无论是在EF 6.x还是在EF Core中一直以来都是使用一个上下文，但是不知我们是否有想过使用多个上下文呢？比如在电商项目中，对于产品相关操作我们可以使用产品上下文，对于加入购物车操作使用购物车上下文，对于订单操作使用订单上下文。这么做的好处是什么呢？我们可以将数据库表也就说将实体拆分成不同的业务。至今我还没看到有人这么做过，如果是我的话，至少我会这么做。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Add DbContext&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; dbConnetionString = Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DbConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            services.AddDbContextPool&lt;/span&gt;&amp;lt;ShopCartDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.UseSqlServer(dbConnetionString);
            }).AddDbContextPool&lt;/span&gt;&amp;lt;BookDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.UseSqlServer(dbConnetionString);
            }).AddDbContextPool&lt;/span&gt;&amp;lt;OrderDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.UseSqlServer(dbConnetionString);
            });    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在EF Core 2.0中有了上下文实例池，类似于ADO.NET中的连接池一样，但是这玩意你从表面理解那你就大错特错了，有关上下文实例池（从去年开始我着手写了一本关于EF 6.x和EF Core的书籍最近会出版）实现本质，只能说它和ADO.NET中的连接池不是一样的哦。那么如上述使用多个上下文实例池是否就一定好使呢？不好意思，这样配置是错误的。但运行程序你会发现抛出类似如下异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Exception message:
System.ArgumentException: Expression of type &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore.DbContextOptions`1[MultiContext.Contexts.BContext]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cannot be used &lt;span&gt;for&lt;/span&gt; constructor parameter of type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore.DbContextOptions`1[MultiContext.Contexts.AContext]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; Parameter name: arguments[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
Stack trace:
...........&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在此特性出来时大家都在欢呼能够提高性能，对不起上下文实例池虽然可能在一定程度上提高性能，但是我只能讲只能有可能的性能改进，如果你知道或者看过EF Core实现上下文实例池的原理，就明白了其实现的本质从而恍然大悟我所说的可能的性能上的改进是什么意思。至于为何不能注册多个上下文实例池，我也是私下写项目遇见的，具体请参看github：&lt;a title=&quot;https://github.com/aspnet/EntityFrameworkCore/issues/9433&quot; href=&quot;https://github.com/aspnet/EntityFrameworkCore/issues/9433&quot; target=&quot;_blank&quot;&gt;https://github.com/aspnet/EntityFrameworkCore/issues/9433&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;好了今天就到这里，没有过多的解释和叙述，上来就是直奔主题，最近思想放飞中，对写博客慢慢失去了很大的兴趣，偶尔感性中，待我满血复活调节好心情再来和大家继续分享技术，我一直在，一段时间没写博客可能是因为累了，又或者是私下在学习IdentityServer或者其他技术中，干咱这行的，除非转行那就老老实实积累经验和多学点技术吧，年轻不奋斗，那什么时候奋斗呢。今天说了啥，胡思乱想中，莫见怪。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 16:48:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8921881.html</dc:identifier>
</item>
<item>
<title>java的迭代器详解 - nianzhilian</title>
<link>http://www.cnblogs.com/nianzhilian/p/8923256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nianzhilian/p/8923256.html</guid>
<description>&lt;h3&gt;迭代器的引出&lt;/h3&gt;
&lt;p&gt;在jdk1.5版本之前是没有 foreach的，然而1.5版本就加上了foreach，而引入的新的foreach功能并不是在jvm上进行改进的因为代价太高，甲骨文工程师想到了一个比较好的办法就是在编译器中引入迭代器的概念从而实现foreach遍历。&lt;/p&gt;
&lt;p&gt;请看一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//         功能 使用HashSet存储、删除、遍历 几个学生的信息
                HashSet&amp;lt;Student&amp;gt; hash = new HashSet&amp;lt;Student&amp;gt;();
                hash.add(new Student(&quot;张三&quot;, 20));
                hash.add(new Student(&quot;李四&quot;, 21));
                hash.add(new Student(&quot;王二&quot;, 22));
                hash.add(new Student(&quot;麻子&quot;, 23));
                
                String st1 = &quot;hello&quot;;
                String st2 = &quot;hello&quot;;
                String st3 = st2;
                System.out.println(st1 == st3);
                
//              删除一个姓名为张三的学生
                String name1 = &quot;张三&quot;;
                boolean flag = true;
                for (Student student : hash) {
                        String name2 = student.getName();
                        
                        if(name1 == name2){
                                hash.remove(student);
                                flag = false;
                                break;
                        }
                }
                if(flag){
                        System.out.println(&quot;不存在&quot;);
                }
                
                for (Student s : hash) {
                        System.out.println(s);
                }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 而上面的代码在运行多次的时候会出现下列错误异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180423235640737-1626516506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个错误是在遍历集合的同时删除了集合中的数据,这种写法不保证线程安全&lt;/p&gt;
&lt;p&gt;怎么解决？上面的写法是不同的人做了不同的事   解决办法就是让一个人即遍历又删除   这就引出了 迭代器&lt;/p&gt;
&lt;p&gt;先看下迭代器的简单用法：&lt;/p&gt;
&lt;p&gt;我先把迭代器比作导游 集合里存的都是景点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180424000829403-1013930763.png&quot; alt=&quot;&quot; width=&quot;1040&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看上面的红色箭头是从最开始位置出现 然后通过迭代器的next（）一个个往下找  &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//         迭代器的用法
                
//              1、创建集合
                ArrayList&amp;lt;String&amp;gt; al = new ArrayList&amp;lt;String&amp;gt;();
                al.add(&quot;张三&quot;);
                al.add(&quot;李四&quot;);
                al.add(&quot;王二&quot;);
                
//              创建迭代器对象  注意这里创建迭代器不是用new  而是用集合的方法
                
                Iterator&amp;lt;String&amp;gt; it = al.iterator();
                
                while(it.hasNext()){
                        String s = it.next();
                        System.out.println(s);
                }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 改写异常之后的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//         功能 使用HashSet存储、删除、遍历 几个学生的信息
                HashSet&amp;lt;Student&amp;gt; hash = new HashSet&amp;lt;Student&amp;gt;();
                hash.add(new Student(&quot;张三&quot;, 20));
                hash.add(new Student(&quot;李四&quot;, 21));
                hash.add(new Student(&quot;王二&quot;, 22));
                hash.add(new Student(&quot;麻子&quot;, 23));
                
                String st1 = &quot;hello&quot;;
                String st2 = &quot;hello&quot;;
                String st3 = st2;
                System.out.println(st1 == st3);
                
//              删除一个姓名为张三的学生
                String name1 = &quot;张三&quot;;
                boolean flag = true;

                Iterator&amp;lt;Student&amp;gt; it = hash.iterator();
                while(it.hasNext()){
                        Student s = it.next();
                        if(name1.equals(s.getName())){
                                it.remove();
                                flag = false;
                                break;
                        }
                }
                if(flag){
                        System.out.println(&quot;不存在&quot;);
                }
                
                for (Student s : hash) {
                        System.out.println(s);
                }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 迭代器的底层原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/795484/201804/795484-20180424001120632-2131037289.png&quot; alt=&quot;&quot; width=&quot;1082&quot; height=&quot;532&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据图所示 为达到方法的统一性所有集合都是实现了Interable接口 通过实现接口的方法创建并返回一个Iterator对象&lt;/p&gt;
&lt;p&gt;然后通过创建内部类实现Iterator 里所有的方法最终目的是为了统一所有集合中的方法名称一样&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 16:17:00 +0000</pubDate>
<dc:creator>nianzhilian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nianzhilian/p/8923256.html</dc:identifier>
</item>
<item>
<title>Java8-理解Collector - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/java8-learn-collector.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/java8-learn-collector.html</guid>
<description>&lt;p&gt;上一节学习了Java8中比较常用的内置collector的用法。接下来就来理解下collector的组成。&lt;/p&gt;
&lt;h2 id=&quot;collector定义&quot;&gt;Collector定义&lt;/h2&gt;
&lt;p&gt;Collector接口包含了一系列方法，为实现具体的归约操作(即收集器)提供了范本。我们已经看过了Collector接口中实现的许多收集器，例如toList或groupingBy。这也意味着你可以为Collector接口提供自己的实现，从而自由创建自定义归约操作。&lt;/p&gt;
&lt;p&gt;要开始使用Collector接口，我们先来看看toList的实现方法，这个在日常中使用最频繁的东西其实也简单。&lt;/p&gt;
&lt;p&gt;Collector接口定义了5个函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Collector&amp;lt;T, A, R&amp;gt; {
    Supplier&amp;lt;A&amp;gt; &lt;span class=&quot;fu&quot;&gt;supplier&lt;/span&gt;();
    BiConsumer&amp;lt;A, T&amp;gt; &lt;span class=&quot;fu&quot;&gt;accumulator&lt;/span&gt;();
    BinaryOperator&amp;lt;A&amp;gt; &lt;span class=&quot;fu&quot;&gt;combiner&lt;/span&gt;();
    Function&amp;lt;A, R&amp;gt; &lt;span class=&quot;fu&quot;&gt;finisher&lt;/span&gt;();
    Set&amp;lt;Characteristics&amp;gt; &lt;span class=&quot;fu&quot;&gt;characteristics&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;T是流中要收集的对象的泛型&lt;/li&gt;
&lt;li&gt;A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。&lt;/li&gt;
&lt;li&gt;R是收集操作得到的对象(通常但不一定是集合)的类型。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于toList, 我们收集的对象是T, 累加器是List, 最终收集的结果也是一个List，于是创建ToListCollector如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ToListCollector&amp;lt;T&amp;gt; &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;理解collector几个函数&quot;&gt;理解Collector几个函数&lt;/h2&gt;
&lt;h3 id=&quot;建立新的结果容器-supplier方法&quot;&gt;建立新的结果容器 supplier方法&lt;/h3&gt;
&lt;p&gt;supplier方法必须返回一个结果为空的Supplier，也就是一个无参数函数，在调用时，它会创建一个空的累加器实例，供数据收集过程使用。就个人通俗的理解来说，这个方法定义你如何收集数据，之所以提炼出来就是为了让你可以传lambda表达式来指定收集器。对于toList, 我们直接返回一个空list就好。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;supplier&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ArrayList::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;累加器执行累加的具体实现-accumulator方法&quot;&gt;累加器执行累加的具体实现 accumulator方法&lt;/h3&gt;
&lt;p&gt;accumulator方法会返回执行归约操作的函数，该函数将返回void。当遍历到流中第n个元素时，这个函数就会执行。函数有两个参数，第一个参数是累计值，第二参数是第n个元素。累加值与元素n如何做运算就是accumulator做的事情了。比如toList, 累加值就是一个List，对于元素n，当然就是add。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BiConsumer&amp;lt;List&amp;lt;T&amp;gt;, T&amp;gt; &lt;span class=&quot;fu&quot;&gt;accumulator&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; List::add;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;对结果容器应用最终转换-finisher方法&quot;&gt;对结果容器应用最终转换 finisher方法&lt;/h3&gt;
&lt;p&gt;当遍历完流之后，我们需要对结果做一个处理，返回一个我们想要的结果。这就是finisher方法所定义的事情。finisher方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果， 这个返回的函数在执行时，会有个参数，该参数就是累积值，会有一个返回值，返回值就是我们最终要返回的东西。对于toList, 我最后就只要拿到那个收集的List就好，所以直接返回List。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Function&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;finisher&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (i) -&amp;gt; i;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于接收一个参数，返回一个value，我们可以想到Function函数，正如finisher()的返回值。对于这个返回参数本身的做法，Function有个静态方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Function&amp;lt;T, T&amp;gt; &lt;span class=&quot;fu&quot;&gt;identity&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; t -&amp;gt; t;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用&lt;code&gt;Function.identity()&lt;/code&gt;代替上述lambda表达式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/java8/collector-sequence.png&quot; alt=&quot;顺序归约&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;合并两个结果容器-combiner&quot;&gt;合并两个结果容器 combiner&lt;/h3&gt;
&lt;p&gt;上面看起来似乎已经可以工作了，这是针对顺序执行的情况。我们知道Stream天然支持并行，但并行却不是毫无代价的。想要并行首先就必然要把任务分段，然后才能并行执行，最后还要合并。虽然Stream底层对我们透明的执行了并行，但如何并行还是需要取决于我们自己。这就是combiner要做的事情。combiner方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分并行处理时，各个字部分归约所得的累加器要如何合并。对于toList而言，Stream会把流自动的分成几个并行的部分，每个部分都执行上述的归约，汇集成一个List。当全部完成后再合并成一个List。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BinaryOperator&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;combiner&lt;/span&gt;() {

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (list1, list2) -&amp;gt; {
        list1.&lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(list2);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list1;
    };
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就可以对流并行归约了。它会用到Java7引入的分支/合并框架和Spliterator抽象。大概如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/java8/collector-parallel.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原始流会以递归方式拆分为子流，直到定义流是否进一步拆分的一个条件为非(如果分布式工作单位太小，并行计算往往比顺序计算要慢，而且要是生成的并行任务比处理器内核数多很多的话就毫无意义了)。&lt;/li&gt;
&lt;li&gt;现在，所有的子流都可以并行处理，即对每个子流应用顺序归约算法。&lt;/li&gt;
&lt;li&gt;最后，使用收集器combiner方法返回的函数，将所有的部分结果两两合并。这时，会把原始流每次拆分得到的子流对应的结果合并起来。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;characteristics方法&quot;&gt;characteristics方法&lt;/h3&gt;
&lt;p&gt;最后一个方法characteristics会返回一个不可变的Characteristics集合，它定义了收集器的行为--尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。&lt;/p&gt;
&lt;p&gt;Characteristics是一个包含三个项目的枚举：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;UNORDERED--归约结果不受流中项目的遍历和累积顺序的影响&lt;/li&gt;
&lt;li&gt;CONCURRENT--accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED, 那它仅在用于无序数据源时才可以并行归约。&lt;/li&gt;
&lt;li&gt;IDENTITY_FINISH--这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用做归约过程的最终结果。这也意味着，将累加器A不加检查地转换为结果R是安全的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们迄今为止ToListCollector是IDENTITY_FINISH的，因为用来累积流中元素的List已经是我们要的最终结果，用不着进一步转换了，但它并不是UNORDERED，因为用在有序流上的时候，我们还是希望顺序能够保留在得到到List中。最后，他是CONCURRENT的，但我们刚才说过了，仅仅在背后的数据源无序时才会并行处理。&lt;/p&gt;
&lt;p&gt;上面这段话说的有点绕口，大概是说像Set生成的stream是无序的，这时候toList就可以并行。而ArrayList这种队列一样的数据结构则生成有序的stream，不能并行。&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;直接传给collect方法就好。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;List&amp;lt;Dish&amp;gt; rs = dishes
            .&lt;span class=&quot;fu&quot;&gt;stream&lt;/span&gt;()
            .&lt;span class=&quot;fu&quot;&gt;collect&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ToListCollector&amp;lt;&amp;gt;());&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们这样费尽心思去创建一个toListCollector，一个是为了熟悉Collector接口的用法，一个是方便重用。当再遇到这样的需求的时候就可以直接用这个自定义的函数了，所以才有toList()这个静态方法。否则，其实collect提供了重载函数可以直接定义这几个函数。比如，可以这样实现toList&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;List&amp;lt;Dish&amp;gt; dishes = dishes
                    .&lt;span class=&quot;fu&quot;&gt;stream&lt;/span&gt;()
                    .&lt;span class=&quot;fu&quot;&gt;collect&lt;/span&gt;(
                        ArrayList::&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;, &lt;span class=&quot;co&quot;&gt;//supplier&lt;/span&gt;
                        List::add, &lt;span class=&quot;co&quot;&gt;//accumulator&lt;/span&gt;
                        List::addAll &lt;span class=&quot;co&quot;&gt;//combiner&lt;/span&gt;
                    );&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法虽然简单，但可读性较差，而且当再次遇到这个需求时还要重写一遍，复用性差。&lt;/p&gt;
&lt;h3 id=&quot;关于性能&quot;&gt;关于性能&lt;/h3&gt;
&lt;p&gt;对于stream提供的几个收集器已经可以满足绝大部分开发需求了，reduce提供了各种自定义。但有时候还是需要自定义collector才能实现。文中举例还是质数枚举算法。之前我们通过遍历平方根之内的数字来求质数。这次提出要用得到的质数减少取模运算。然而，悲剧的是我本地测算的结果显示，这个而所谓的优化版反而比原来的慢100倍。不过，还是把这个自定义收集器列出来。值得铭记的是，这个收集器是有序的，所以不能并行，那个这个combiner方法可以不要的，最好返回UnsupportedOperationException来警示此收集器的非并行性。&lt;/p&gt;
&lt;p&gt;测试见 &lt;a href=&quot;https://github.com/Ryan-Miao/l4Java/blob/master/src/test/java/com/test/java/stream/collect/PrimeNumbersCollectorTest.java&quot; class=&quot;uri&quot;&gt;https://github.com/Ryan-Miao/l4Java/blob/master/src/test/java/com/test/java/stream/collect/PrimeNumbersCollectorTest.java&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PrimeNumbersCollector &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt;
    Collector&amp;lt;Integer, Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;, Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Supplier&amp;lt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;supplier&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; () -&amp;gt; {
            Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
            map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; map;
        };
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BiConsumer&amp;lt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;, Integer&amp;gt; &lt;span class=&quot;fu&quot;&gt;accumulator&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; acc, Integer candidate) -&amp;gt; {
            acc.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;isPrime&lt;/span&gt;(acc.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;), candidate)).&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(candidate);
        };
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 从质数列表里取出来，看看是不是candidate的约数.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param primes &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;质数列表&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param candidate &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;判断值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;true -&amp;gt; 质数； false-&amp;gt;非质数。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Boolean &lt;span class=&quot;fu&quot;&gt;isPrime&lt;/span&gt;(
        List&amp;lt;Integer&amp;gt; primes,
        Integer candidate) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; candidateRoot = (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) Math.&lt;span class=&quot;fu&quot;&gt;sqrt&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;) candidate);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; primes.&lt;span class=&quot;fu&quot;&gt;stream&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;(p -&amp;gt; p&amp;lt;=candidateRoot).&lt;span class=&quot;fu&quot;&gt;noneMatch&lt;/span&gt;(i -&amp;gt; candidate % i == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BinaryOperator&amp;lt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;combiner&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; map1, Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; map2) -&amp;gt; {
            map1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(map2.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
            map1.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(map2.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;));
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; map1;
        };
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Function&amp;lt;Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;, Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;finisher&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Function.&lt;span class=&quot;fu&quot;&gt;identity&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Set&amp;lt;Characteristics&amp;gt; &lt;span class=&quot;fu&quot;&gt;characteristics&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Collections.&lt;span class=&quot;fu&quot;&gt;unmodifiableSet&lt;/span&gt;(EnumSet.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(Characteristics.&lt;span class=&quot;fu&quot;&gt;IDENTITY_FINISH&lt;/span&gt;));
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java8 in Action&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 23 Apr 2018 16:08:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/java8-learn-collector.html</dc:identifier>
</item>
<item>
<title>curl_multi实现并发 - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/8908315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/8908315.html</guid>
<description>&lt;h2 id=&quot;普通请求&quot;&gt;普通请求&lt;/h2&gt;
&lt;p&gt;curl_normal.php&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;$srart_time&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;microtime&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;=&lt;span class=&quot;ot&quot;&gt;[];&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//创建多个cURL资源&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&amp;lt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;++&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;=&lt;span class=&quot;fu&quot;&gt;curl_init&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_URL&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.52fhy.com/test.json&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_RETURNTRANSFER&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_TIMEOUT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[]&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_exec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;running &quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;// print_r($result);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;$end_time&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;microtime&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;use time:%.3f s&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$end_time&lt;/span&gt; - &lt;span class=&quot;kw&quot;&gt;$srart_time&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use time:0.830 s&lt;/p&gt;
&lt;h2 id=&quot;curl_multi并发&quot;&gt;curl_multi并发&lt;/h2&gt;
&lt;p&gt;curl_multi.php&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;$srart_time&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;microtime&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;=&lt;span class=&quot;ot&quot;&gt;[];&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//创建多个cURL资源&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&amp;lt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;++&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;=&lt;span class=&quot;fu&quot;&gt;curl_init&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_URL&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.52fhy.com/test.json&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_RETURNTRANSFER&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_setopt&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;CURLOPT_TIMEOUT&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_init&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//1 创建批处理cURL句柄&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$k&lt;/span&gt; =&amp;gt; &lt;span class=&quot;kw&quot;&gt;$ch&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{      
    &lt;span class=&quot;fu&quot;&gt;curl_multi_add_handle&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$ch&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//2 增加句柄&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;co&quot;&gt;//待优化点：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//在$active &amp;gt; 0,执行curl_multi_exec($mh,$active)而整个批处理句柄没有全部执行完毕时，系统会不停地执行curl_multi_exec()函数。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;running &quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_multi_exec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//3 执行批处理句柄&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//4&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$chArr&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$k&lt;/span&gt; =&amp;gt; &lt;span class=&quot;kw&quot;&gt;$ch&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{ 
    &lt;span class=&quot;kw&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$k&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;= &lt;span class=&quot;fu&quot;&gt;curl_multi_getcontent&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$ch&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//5 获取句柄的返回值&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;curl_multi_remove_handle&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$ch&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//6 将$mh中的句柄移除&lt;/span&gt;
}

&lt;span class=&quot;fu&quot;&gt;curl_multi_close&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//7 关闭全部句柄 &lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// print_r($result);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;$end_time&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;microtime&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;use time:%.3f s&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$end_time&lt;/span&gt; - &lt;span class=&quot;kw&quot;&gt;$srart_time&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use time:0.259 s&lt;/p&gt;
&lt;h2 id=&quot;curl_multi并发优化curl_multi_select&quot;&gt;curl_multi并发优化：curl_multi_select&lt;/h2&gt;
&lt;p&gt;在上个示例里当&lt;code&gt;$active &amp;gt; 0&lt;/code&gt;时,执行&lt;code&gt;curl_multi_exec($mh,$active)&lt;/code&gt;而整个批处理句柄没有全部执行完毕时，系统会不停地执行&lt;code&gt;curl_multi_exec()&lt;/code&gt;函数。这样可能会轻易导致CPU占用很高。&lt;/p&gt;
&lt;p&gt;进行改动的方式是应用curl函数库中的curl_multi_select()函数，其函数原型如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;int &lt;span class=&quot;fu&quot;&gt;curl_multi_select&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; resource &lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[,&lt;/span&gt; float &lt;span class=&quot;kw&quot;&gt;$timeout&lt;/span&gt; = &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;阻塞直到cURL批处理连接中有活动连接。成功时返回描述符集合中描述符的数量。失败时，select失败时返回-1，否则返回超时(从底层的select系统调用)。&lt;br/&gt;我用们curl_multi_select()函数来达到没有需要读取的程序就阻塞住的目的。&lt;/p&gt;
&lt;p&gt;下面是优化部分的代码：&lt;/p&gt;
&lt;p&gt;curl_multi_select.php&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;running &quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_exec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//3 执行批处理句柄&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;CURLM_CALL_MULTI_PERFORM&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//4&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//本次循环第一次处理$mh批处理中的$ch句柄，并将$mh批处理的执行状态写入$active ,当状态值等于CURLM_CALL_MULTI_PERFORM时，表明数据还在写入或读取中，执行循环，当第一次$ch句柄的数据写入或读取成功后，状态值变为CURLM_OK，跳出本次循环，进入下面的大循环之中。&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//$active 为true，即$mh批处理之中还有$ch句柄正待处理，$mrc==CURLM_OK,即上一次$ch句柄的读取或写入已经执行完毕。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;CURLM_OK&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; { 
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;curl_multi_select&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {&lt;span class=&quot;co&quot;&gt;//$mh批处理中还有可执行的$ch句柄，curl_multi_select($mh) != -1程序退出阻塞状态。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_exec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//继续执行需要处理的$ch句柄。&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;CURLM_CALL_MULTI_PERFORM&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样执行的好处是&lt;code&gt;$mh&lt;/code&gt;批处理中的&lt;code&gt;$ch&lt;/code&gt;句柄会在读取或写入数据结束后(&lt;code&gt;$mrc==CURLM_OK&lt;/code&gt;),进入&lt;code&gt;curl_multi_select($mh)&lt;/code&gt;的阻塞阶段，而不会在整个&lt;code&gt;$mh&lt;/code&gt;批处理执行时不停地执行curl_multi_exec,白白浪费CPU资源。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;br/&gt;use time:0.325 s&lt;/p&gt;
&lt;p&gt;耗时并没有多少改变，只是性能提高了。&lt;/p&gt;
&lt;h2 id=&quot;curl_multi并发优化rolling&quot;&gt;curl_multi并发优化：rolling&lt;/h2&gt;
&lt;p&gt;上面的例子还存在优化的空间, 优化的方式时当某个URL请求完毕之后尽可能快的去处理它, 边处理边等待其他的URL返回, 而不是等待那个最慢的接口返回之后才开始处理等工作, 从而避免CPU的空闲和浪费。&lt;/p&gt;
&lt;p&gt;仅贴出修改部分：&lt;/p&gt;
&lt;p&gt;curl_multi_rolling.php&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_exec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;CURLM_CALL_MULTI_PERFORM&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mrc&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;CURLM_OK&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; { &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt; }

    &lt;span class=&quot;co&quot;&gt;// a request was just completed -- find out which one&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_info_read&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt; {

        &lt;span class=&quot;co&quot;&gt;// get the info and content returned on the request&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;$info&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_getinfo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'handle'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;$error&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_error&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'handle'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[]&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;curl_multi_getcontent&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'handle'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// $responses[$map[(string) $done['handle']]] = compact('info', 'error', 'results');&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// remove the curl handle that just completed&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;curl_multi_remove_handle&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'handle'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;curl_close&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$done&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'handle'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
    }

    &lt;span class=&quot;co&quot;&gt;// Block for data in / output; error handling is done by curl_multi_exec&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;curl_multi_select&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$mh&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    }

} &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$active&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;use time:0.267 s&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、PHP模拟发送POST请求之五curl基本使用和多线程优化&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/zhenbianshu/p/4935679.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhenbianshu/p/4935679.html&lt;/a&gt;&lt;br/&gt;2、Rolling cURL: PHP并发最佳实践&lt;br/&gt;&lt;a href=&quot;https://www.oschina.net/question/54100_58279&quot; class=&quot;uri&quot;&gt;https://www.oschina.net/question/54100_58279&lt;/a&gt;&lt;br/&gt;3、curl_multi_select解决curl_multi网页假死问题&lt;br/&gt;&lt;a href=&quot;http://www.webkaka.com/tutorial/php/2013/102844/&quot; class=&quot;uri&quot;&gt;http://www.webkaka.com/tutorial/php/2013/102844/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 16:07:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/8908315.html</dc:identifier>
</item>
<item>
<title>POJ-2299 Ultra-QuickSort---树状数组求逆序对+离散化 - _努力努力再努力x</title>
<link>http://www.cnblogs.com/fzl194/p/8922973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzl194/p/8922973.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目链接：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://vjudge.net/problem/POJ-2299&quot; target=&quot;_blank&quot;&gt;https://vjudge.net/problem/POJ-2299&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目大意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本题要求对于给定的无序数组，求出经过最少多少次相邻元素的交换之后，可以使数组从小到大有序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个数（a, b）的排列，若满足a &amp;gt; b，则称之为一个逆序对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n &amp;lt; 500,000   0 ≤ a[i] ≤ 999,999,999&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于数据范围大，可以考虑离散化。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要离散化？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;离散化的目的就在于将这么多的数字转化成1-500000以内，然后开一个tree树状数组，下标就对应着数值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何离散化？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从小到大离散化成1-n，比如数组9 1 0 5 4 离散化成5 2 1 4 3，然后就可以用树状数组做了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;开了树状数组，接下来怎么做？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从左往右依次往树状数组中加入元素，每次加入的时候，在对应下标的位置的数字加一，加入之后数一下在这个下标后面有多少个1，就是加入该数字的逆序对的数目&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面进行模拟 5 2 1 4 3，模拟之后你就懂了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最初的树状数组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233059457-1889614901.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、首先加入5，此时树状数组的第5个元素+1（红块表示加1），此时5的后面没有元素，所以加入5的逆序对为0，ans = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233621807-1868259181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、加入2，此时第2个元素加1，2的后面有一个红块（表示加一），所以加入2的逆序对为1， ans = 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233643473-96018110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、加入1，此时第1个元素加1，1的后面有两个红块（表示加一），所以加入1的逆序对为2， ans = 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233653020-1970162676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;4、加入4，此时第4个元素加1，4的后面有一个红块（表示加一），所以加入4的逆序对为1， ans =4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233751329-1864506096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;5、加入3，此时第3个元素加1，3的后面有两个红块（表示加一），所以加入3的逆序对为2， ans = 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1363579/201804/1363579-20180423233848081-1833288342.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用树状数组可以在o(log(n))的时间复杂度求出当前数字的前缀和，进而可以求出在当前数字后面数字的个数（i-sum(x)）(i表示已经加入的总数字的数目，sum(x)表示小于等于x的数字的数目，它们之差就是大于x的数字的数目)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就把逆序对问题和树状数组联系起来了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;还有需要注意的地方：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果，数据之中有数字相等的情况，离散化应该怎么处理呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子 2 2 2 2，如果离散化成1 2 3 4，那么每次加入的时候在树状数组中找比它大的元素个数，求出的逆序对为0，正确，这种处理不会产生冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果离散化成4 3 2 1，求出的解时6，答案错误，所以在离散化的时候，权值小的离散之后的值小，权值相同的，下标在前面的离散后的值小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小技巧：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用结构体存权值和id，排序之后根据id创建新的离散化后的数组&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;500000&lt;/span&gt; + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; typedef &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ll;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, id;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &amp;lt; (&lt;span&gt;const&lt;/span&gt; node&amp;amp; a)&lt;span&gt;const&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x &amp;lt; a.x || x == a.x &amp;amp;&amp;amp; id &amp;lt;&lt;span&gt; a.id;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从小到大排序,如果x相等，那么编号小的排在前面
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是因为这样的话之后离散化的时候，编号小的离散化的数字也是小的
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;之后求逆序对时需要按照原来ID顺序一个一个放离散化的数字
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相同的x最开始放入的值是小的，后面放入的值是大的，这样不会额外增加逆序对
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如一个数组2 2 2 2 按照上述方法离散化成1 2 3 4，逆序对为0。
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果离散化成4 3 2 1，则逆序对就会求错了&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}a[maxn];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b[maxn];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tree[maxn];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x &amp;amp; (-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; d)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x &amp;lt;=&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         tree[x] +=&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         x +=&lt;span&gt; lowbit(x);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; ll sum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     ll ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处等于0会导致无限循环&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         ret +=&lt;span&gt; tree[x];
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         x -=&lt;span&gt; lowbit(x);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin &amp;gt;&amp;gt; n &amp;amp;&amp;amp;&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         memset(tree, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tree));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         memset(a, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(a));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         memset(b, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(b));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i].x);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             a[i].id =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         sort(a + &lt;span&gt;1&lt;/span&gt;, a + n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             b[a[i].id] = i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;离散化操作，根据原来的id，进行大小的编号，从小到大编号1-n&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         ll ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             add(b[i], &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将b[i]加入树状数组中&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;             ans += i - sum(b[i]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;i-sum(b[i])表示目前加入了i个数，其中有sum(b[i])个数字比b[i]小，相减的结果就是目前比b[i]大的数字数目&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;离散化的另一种方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前是从小到大离散化，现在从大到小离散化，9 1 0 5 4 离散化成1 4 5 2 3，那进行树状数组求值的时候，每加入一个数，求前面比它小的数字即可，正好是树状数组的sum函数的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上述例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 4 5 2 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加入1时，没有比1小的，ans=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加入4时，有1个比4小，ans = 1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加入5是，有2个比5小，ans = 3；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，上述的有重复元素的时候2 2 2 2离散化成1 2 3 4的时候是错误的，因为这里是找比该数小的数字，所以1 2 3 4求出逆序对为6，是错误的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;离散化成4 3 2 1的话，就是正确的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上代码：（找不同，好好看看就懂了）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;100000&lt;/span&gt; + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; typedef &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ll;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x, id;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; &amp;lt; (&lt;span&gt;const&lt;/span&gt; node&amp;amp; a)&lt;span&gt;const&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x &amp;gt; a.x || x == a.x &amp;amp;&amp;amp; id &amp;gt; a.id;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里变啦！！！&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}a[maxn];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b[maxn];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tree[maxn];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x &amp;amp; (-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; d)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x &amp;lt;=&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         tree[x] +=&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         x +=&lt;span&gt; lowbit(x);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; ll sum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     ll ret = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(x &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处等于0会导致无限循环&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         ret +=&lt;span&gt; tree[x];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         x -=&lt;span&gt; lowbit(x);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(cin &amp;gt;&amp;gt;&lt;span&gt; n)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         memset(tree, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tree));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         memset(a, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(a));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         memset(b, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(b));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i].x);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             a[i].id =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         sort(a + &lt;span&gt;1&lt;/span&gt;, a + n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             b[a[i].id] = i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;离散化操作，根据原来的id，进行大小的编号，从大到小编号1-n&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         ll ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还有下面的两行&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             ans += sum(b[i]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标比b[i]小，但是实际的数字比b[i]大（因为离散化的时候就是数字大的编号小）&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;             add(b[i], &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要先调用sum，再调用add，因为先调用add的话，求sum的时候把自己也算进去了&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 23 Apr 2018 15:59:00 +0000</pubDate>
<dc:creator>_努力努力再努力x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzl194/p/8922973.html</dc:identifier>
</item>
<item>
<title>Spring中的InitializingBean接口的使用 - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/8922937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/8922937.html</guid>
<description>&lt;p&gt;InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。&lt;/p&gt;
&lt;p&gt;测试，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.InitializingBean;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestInitializingBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InitializingBean{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;ceshi InitializingBean&quot;&lt;span&gt;);        
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInit(){
        System.out.println(&lt;/span&gt;&quot;ceshi init-method&quot;&lt;span&gt;);        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;testInitializingBean&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.TestInitializingBean&quot; &amp;gt;&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main函数如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileSystemXmlApplicationContext(&quot;/src/main/java/com/beans.xml&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ceshi InitializingBean
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这说明在spring初始化bean的时候，如果bean实现了InitializingBean接口，会自动调用afterPropertiesSet方法。&lt;/p&gt;

&lt;p&gt;那么问题来了，在配置bean的时候使用init-method配置也可以为bean配置初始化方法，那这两个哪个会先执行呢，接下来测试一下，修改配置文件，加上init-method:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;testInitializingBean&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.TestInitializingBean&quot; init-method=&quot;testInit&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序，得出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ceshi InitializingBean
ceshi init&lt;/span&gt;-method
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从结果可以看出，在Spring初始化bean的时候，如果该bean实现了InitializingBean接口，并且同时在配置文件中指定了init-method，系统则是先调用afterPropertieSet()方法，然后再调用init-method中指定的方法。&lt;/p&gt;
&lt;p&gt;那么这种方式在spring中是怎么实现的呢，通过查看Spring加载bean的源码类AbstractAutowiredCapableBeanFactory可以看出其中的奥妙，AbstractAutowiredCapableBeanFactory类中的invokeInitMethods说的非常清楚，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; invokeInitMethods(String beanName, &lt;span&gt;final&lt;/span&gt; Object bean, RootBeanDefinition mbd) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断该bean是否实现了实现了InitializingBean接口，如果实现了InitializingBean接口，则只掉调用bean的afterPropertiesSet方法&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isInitializingBean = (bean &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InitializingBean);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isInitializingBean &amp;amp;&amp;amp; (mbd == &lt;span&gt;null&lt;/span&gt; || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;&lt;span&gt;))) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Invoking afterPropertiesSet() on bean with name '&quot; + beanName + &quot;'&quot;&lt;span&gt;);
        }
         
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (System.getSecurityManager() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                AccessController.doPrivileged(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;Object&amp;gt;&lt;span&gt;() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接调用afterPropertiesSet&lt;/span&gt;
&lt;span&gt;                        ((InitializingBean) bean).afterPropertiesSet();
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
                },getAccessControlContext());
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (PrivilegedActionException pae) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; pae.getException();
            }
        }                
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接调用afterPropertiesSet&lt;/span&gt;
&lt;span&gt;            ((InitializingBean) bean).afterPropertiesSet();
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mbd != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        String initMethodName &lt;/span&gt;=&lt;span&gt; mbd.getInitMethodName();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否指定了init-method方法，如果指定了init-method方法，则再调用制定的init-method&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (initMethodName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !(isInitializingBean &amp;amp;&amp;amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;amp;&amp;amp;
                !&lt;span&gt;mbd.isExternallyManagedInitMethod(initMethodName)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进一步查看该方法的源码，可以发现init-method方法中指定的方法是通过反射实现&lt;/span&gt;
&lt;span&gt;            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1、Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用。&lt;/p&gt;
&lt;p&gt;2、实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，但是init-method方式消除了对spring的依赖。&lt;/p&gt;
&lt;p&gt;3、如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。&lt;/p&gt;

</description>
<pubDate>Mon, 23 Apr 2018 15:55:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/8922937.html</dc:identifier>
</item>
<item>
<title>将 Hexo 个人博客同时部署到 GitHub 和 Coding 上 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8922624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8922624.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30d3ac024b42?w=6000&amp;amp;h=4000&amp;amp;f=jpeg&amp;amp;s=2757031&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一将个人博客托管到-github-上&quot;&gt;一、将个人博客托管到 GitHub 上&lt;/h3&gt;
&lt;p&gt;关于如何快速搭建自己的个人博客，如何完善自己的个人博客，什么是 GitHub ，如何将自己的博客代码托管到 GitHub 上面等等问题，我之前写过三篇文章已经做了详细的说明，三篇文章如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484100&amp;amp;idx=1&amp;amp;sn=5051ed4c889747259fa00765a1286f62&amp;amp;chksm=fe32210ac945a81c2ce6e8dbaefebc1f44fbde6de3642fe1d61e2e61d292ffa32277dae5528d#rd&quot;&gt;基于 Hexo + GitHub Pages 搭建个人博客（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=eee8bc1ab50d4a57292039079986d69d&amp;amp;chksm=fe322107c945a81147bf2eb62fcb270439059944c778154e1af42171d559f22bf99e0f6e8d6c#rd&quot;&gt;基于 Hexo + GitHub Pages 搭建个人博客（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://compassblog.github.io/2018/04/22/%E5%9F%BA%E4%BA%8E-Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/#more&quot;&gt;基于 Hexo + GitHub Pages 搭建个人博客（三）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二将个人博客托管到-coding-上&quot;&gt;二、将个人博客托管到 Coding 上&lt;/h3&gt;
&lt;p&gt;最近博客出了点问题，这几天都在紧急修复，不间断折腾自己的博客，然后弄的差不过，今天非常好奇，于是登录百度统计，发现一个问题，那就是百度无法抓取托管在 GitHub Pages 上的博客，或许是因为 GitHub 是国外的代码托管平台无法抓取吧，然后就有点郁闷了...如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce3f6580b7?w=1172&amp;amp;h=490&amp;amp;f=png&amp;amp;s=34913&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而后 Google 上查了下，发现国内有一个代码托管平台叫 Coding ，也可以将个人的 Hexo 博客托管到平台上，然后有点激动，说时迟那时快，立刻动手尝试将自己的个人博客托管到 Coding 上，中间遇到很多坑，折腾好久，最终成功，特此记录。&lt;/p&gt;
&lt;p&gt;据了解，之前很多人都是把博客托管到国内的 gitcafe上，后来 gitcafe 被 Coding 收购。当然，据我所知国内还有其他代码托管平台，例如有个代码托管平台叫码云，但是码云能不能托管个人博客代码，我就不清楚了，没怎么用码云，基本用的都是 GitHub ，有需要的可以自行了解下。&lt;/p&gt;
&lt;h4 id=&quot;注册-coding-帐号&quot;&gt;1、注册 Coding 帐号&lt;/h4&gt;
&lt;p&gt;注册网址：&lt;a href=&quot;https://coding.net/&quot;&gt;Coding 官网&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;将本电脑的-ssh-公钥配置到-coding-上&quot;&gt;2、将本电脑的 SSH 公钥配置到 Coding 上&lt;/h4&gt;
&lt;p&gt;（1）打开如下电脑 C 盘用户下的 .ssh 目录， 找到 id_rsa.pub 文件，即公钥文件，复制文件中的所有内容，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce3f7c3678?w=711&amp;amp;h=444&amp;amp;f=png&amp;amp;s=27456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在 已经登录的 Coding 网站上，打开个人设置，点击 SSH 公钥菜单下的新增公钥，而后把上面复制的内容全部粘贴到公钥内容框下，公钥名称自定义，没有特别的要求，然后点击添加即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce3fba9ea0?w=1365&amp;amp;h=644&amp;amp;f=png&amp;amp;s=77044&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）测试 SSH 公钥是否添加成功：本地打开 Git Bash 窗口，输入一下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh -T git@coding.net&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候会显示是否继续，选择 yes 继续，如果提示下列内容成功，即 SSH 公钥配置成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello compassblog You've connected to Coding.net by SSH successfully!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，compassblog 是我 Coding 帐户的名字，不同的帐户会不一样，如果显示如下错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh: connect to host coding.net port 22: Connection refused&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce3fca9a5b?w=821&amp;amp;h=142&amp;amp;f=png&amp;amp;s=11744&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明防火墙完全屏蔽了端口 22 ，这时候不要慌张，直接输入如下命令使用 Coding 提供的 443 端口 SSH 服务即可解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh -T -p 443 git@git-ssh.coding.net&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce3fbdd0a2?w=821&amp;amp;h=142&amp;amp;f=png&amp;amp;s=16451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在输入验证命令，显示 Coding 帐号与相关信息，即 SSH 公钥配置成功。&lt;/p&gt;
&lt;h3 id=&quot;新建项目存放需要托管的博客代码&quot;&gt;3、新建项目，存放需要托管的博客代码&lt;/h3&gt;
&lt;p&gt;（1）在 Coding 的个人主页上点击 + 号，选择项目选项，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce4c7f798e?w=526&amp;amp;h=300&amp;amp;f=png&amp;amp;s=14806&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）选择新建项目后，填写项目信息，项目名称与自己的 Coding 帐户名称项目，项目属性公开私有都可以，个人博客建议是公有，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce6f26cdac?w=1365&amp;amp;h=605&amp;amp;f=png&amp;amp;s=52124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）新建项目完毕后，打开项目的 Pages 服务选项，选择部署来源为 master 分支，并打开强制 HTTPS 访问按钮（ https 更加安全），不选择就是 HTTP 访问了，不选择也是可以的，自行决定，点击保存即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce6ee80dce?w=1366&amp;amp;h=649&amp;amp;f=png&amp;amp;s=56201&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置博客主文件同时部署-hexo-博客到-github-和-coding-上&quot;&gt;4、配置博客主文件，同时部署 Hexo 博客到 GitHub 和 Coding 上&lt;/h4&gt;
&lt;p&gt;（1）打开 Hexo 博客主配置文件 _config.yml，找到 deploy 属性，作如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deploy:
  type: git
  repository:
      github: git@github.com:compassblog/compassblog.github.io.git
      coding: git@git.coding.net:compassblog/compassblog.git
  branch: master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）打开 Hexo 主目录下的 source 文件，新建文件 Staticfile ，这个文件是 Coding 静态文件部署的标志，注意文件名字必须为 Staticfile，否则 Coding 上无法完成静态文件的部署，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce6d8dff58?w=794&amp;amp;h=525&amp;amp;f=png&amp;amp;s=40416&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试-hexo-博客是否成功部署到-github-和-coding-上&quot;&gt;5、测试 Hexo 博客是否成功部署到 GitHub 和 Coding 上&lt;/h4&gt;
&lt;p&gt;经过前面的步骤，配置基本就已经完成，直接在 Hexo 主目录下打开 Git Bash 窗口，输入如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30ce71004e76?w=911&amp;amp;h=520&amp;amp;f=png&amp;amp;s=44530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部署成功，到浏览器地址栏分别输入 GitHub 地址 和 Coding 地址，访问成功：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://compassblog.github.io/&quot; class=&quot;uri&quot;&gt;https://compassblog.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://compassblog.coding.me/&quot; class=&quot;uri&quot;&gt;https://compassblog.coding.me/&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;--------------------------------------------&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f30f56649378b?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27341&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 15:15:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8922624.html</dc:identifier>
</item>
<item>
<title>一种关于缓存数据何时更新的解决思路 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/8922441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/8922441.html</guid>
<description>&lt;p&gt;和大家一样，我有每天逛逛博客园的习惯，今天在博客园看到了“一只攻城狮”写的《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; title=&quot;初遇 Asp.net MVC 数据库依赖缓存那些事儿&quot; href=&quot;http://www.cnblogs.com/MaMaNongNong/p/8904022.html&quot; target=&quot;_blank&quot;&gt;初遇 Asp.net MVC 数据库依赖缓存那些事儿&lt;/a&gt;》。该朋友利用.Net的SqlCacheDependency缓存依赖，解决了缓存数据何时更新的问题。&lt;/p&gt;
&lt;p&gt;但是该思路具有一定的局限性，如：要利用数据库的存储过程，来通知客户端更新缓存，这就离不开微软的Sql Server那套体制，如果利用别的数据库，恐怕就没有那么好实现了。且存储过程需要在数据库中执行，不利于将业务向服务程序转移。&lt;/p&gt;

&lt;p&gt;程序员比较忌讳造轮子，相信程序员写博客也是如此，因此，我还是想站在巨人的肩膀上，借用“一只攻城狮”在《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; title=&quot;初遇 Asp.net MVC 数据库依赖缓存那些事儿&quot; href=&quot;http://www.cnblogs.com/MaMaNongNong/p/8904022.html&quot; target=&quot;_blank&quot;&gt;初遇 Asp.net MVC 数据库依赖缓存那些事儿&lt;/a&gt;》写的背景，来引出我想说的内容，如果“一只攻城狮”觉得有何不妥之处，请联系我做下架处理。&lt;/p&gt;


&lt;p&gt;--------------------------------------------------------------引用开始-----------------------------------------------&lt;/p&gt;
&lt;p&gt;最近做一个非常简单的功能，就是使用ajax请求的方式从服务端请求一段下拉表的数据。&lt;/p&gt;
&lt;p&gt;　　以前也有做过这个功能，只不过这次做这个功能的时候冒出了一个想法：&lt;/p&gt;
&lt;p&gt;　　我请求的这段数据它是一段相对比较固定的数据，也就是说它不怎么改变，也许几个月才会改变一次。由于这种数据的变化周期很长，所以以前做这种功能的时候，会使用缓存进行优化，可以直接从缓存中读取数据，避免每一次接收了ajax请求后都要向数据库要数据，减少服务器与数据库之间的交互，减轻数据库服务器的压力。但是问题来了，&lt;strong&gt;数据的变化周期再长终究是要变化的，当数据库中的数据变化的时候你就要对旧有的缓存内容进行移除（remove）操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                 .......................{中间省略XXX字，中间作者大致讲诉了设置了缓存定期过期}.................................&lt;/p&gt;
&lt;p&gt;　　缓存定期过期有一个坏处：在还没到达过期时间的这段时间里，请求的数据依然是原来的缓存中数据，如果数据库数据在这期间进行了更新，那么缓存数据和数据库中的数据并不一致。&lt;/p&gt;
&lt;p&gt;　　其中设置的绝对过期时间点要根据实际的数据刷新的可容忍度来进行设定，而恰好在我的这个应用场景中的可容忍度最不能把握，它要求的是 当数据库中的数据改变以后，缓存中对应的数据在&lt;strong&gt;下一次请求结束后&lt;/strong&gt;一定要马上跟着改变，当然你也可以把过期时间尽可能的调小，调到一秒。当然，这样的话还是要频繁的向数据库进行请求，那不是背离了我们原本使用缓存优化的目的了吗？&lt;/p&gt;

&lt;p&gt;　　所以现在的问题是：&lt;strong&gt;有没有一种方法能让数据库和服务器程序建立一种联系，这种联系好比是一种“心灵感应”，当数据库表中的数据发生变化的时候，马上就能让服务器中的对应的缓存项“感应”到这个变化，从而让原来的缓存项失效呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;--------------------------------------------------------------引用结束------------------------------------------&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　综上所述，客户端（或浏览器）缓存数据的痛点在于，数据何时更新？如何让客户端知道，服务端数据变了？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;分四步走。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第一步，初次请求数据时&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201804/1293736-20180423222859593-1714383265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端在初次请求数据时，会把客户端想要的数据连同数据的版本号（数据上次的更新时间）一起发送给客户端，数据版本号时存在Redis数据库中的，我们知道，Redis中的数据存储在内存中且读取数据比关系型数据库快的不是一点点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端收到数据后，会把收到的数据和数据版本号缓存下来。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;第二步，当数据库数据更新时&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201804/1293736-20180423223420231-346262883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当数据库数据更新时，服务端在更新关系型数据库的同时会把Redis的数据版本号更新为当前时间。&lt;/p&gt;
&lt;h2&gt;第三步，客户端用数据时：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201804/1293736-20180423223726495-21014758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端需要使用缓存数据时，会向服务端索要数据版本号（也就是数据上次的更新时间），如果该数据版本号与客户端缓存的数据版本号一致，那么，客户端缓存的数据时安全可用的，如果不一致，那么说明数据已经更新了，客户端把新的版本号缓存下来并重新获取。那么，执行第四步。&lt;/p&gt;
&lt;h2&gt;第四步，重新获取数据&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201804/1293736-20180423224107815-1458172786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新获取数据时，就不用携带版本号了，客户端在第三步时已经获取并缓存下来了。&lt;/p&gt;


&lt;p&gt;好处：&lt;/p&gt;
&lt;p&gt;1.当请求的数据量交大但是变动又不频繁时，客户端与服务端不必频繁地交换大型数据，只需交换数据版本号即可。&lt;/p&gt;
&lt;p&gt;2.数据版本号存储在Redis数据库中，不仅读取速度快，而且数据量小，所以响应快，交换成本低。&lt;/p&gt;
&lt;p&gt;3.该思路通用性强，适合任何类型的关系型数据库与Nosql数据库搭配使用。&lt;/p&gt;
&lt;p&gt;弊端：&lt;/p&gt;
&lt;p&gt;1.客户端在每次使用数据前，都要与服务端进行一次通讯进行校验数据版本号。&lt;/p&gt;

&lt;p&gt;好与坏不是绝对的，适合的才是最好的，以上是我的解决思路，大家有不同观点，欢迎留言讨论，也感谢“一只攻城狮”提供讨论背景！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 14:54:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/8922441.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(二) lightning 知识简单介绍----lightning事件驱动模型 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/8733056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/8733056.html</guid>
<description>&lt;p&gt;看此篇博客前或者后，看一下trailhead可以加深印象以及理解的更好：&lt;a href=&quot;https://trailhead.salesforce.com/modules/lex_dev_lc_basics&quot; target=&quot;_blank&quot;&gt;https://trailhead.salesforce.com/modules/lex_dev_lc_basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做过classic的朋友知道，前台和后台交互可以在页面上使用多种方式，比如在VF page中apex:commandButton等标签绑定action，使用actionFunction,使用ajax toolkit，使用VF Remoting或者使用action:support多种方式实现和后台的交互。如果你习惯性的使用了classic，那么你在lightning学习中可能有一点点的不适，最多的应该是没法在lightning component中使用js了，因为lightning封装了他的framework，这样的好处为后期更容易维护，不必要因为维护别人的项目各种读别人的rendered/reRender等恶心的事情，因为好多重新渲染元素的操作都在controller.js中处理了。当然，上面的都是泛泛而谈，下面细节的说一下lightning的事件驱动模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.Lightning模型介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lightning事件驱动模型如下图所示：&lt;/p&gt;
&lt;p&gt;1.用户在component标签上点击按钮或者触发某个自定义事件&lt;/p&gt;
&lt;p&gt;2.javascript controller中的action获取当前的事件源，处理业务逻辑，细节的对于后台的操作在helper中执行；&lt;/p&gt;
&lt;p&gt;3.javascript helper中执行和server端的交互，调用后台apex controller，并在apex controller执行结束后调用回调函数去处理后期的业务逻辑以及更新UI等操作；&lt;/p&gt;
&lt;p&gt;4.server-controller 使用apex代码处理业务逻辑以及和数据库的交互，写法和VF Remoting的后台写法类似，区别为需要在方法上添加标签@AuraEnabled。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180407131635711-20298498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一篇内容说过一个component bundle包含了很多内容，此篇通过上面的事件驱动模型主要说一下以下三个元素：Component(.cmp) / Controller js(.js) / Helper js(.js)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. Component介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在Apex中经常使用Visualforce Component做一些公用组件，但是lightning中的component和刚才说的不是一个内容。一个component是一个包含了定义着的资源信息，标签，也可以包含表达式或者是其他可选的资源，比如controller属性信息，stylesheet等信息。lightning component中头标签为&lt;span class=&quot;token operator&quot;&gt;&amp;lt;aura&lt;span class=&quot;token operator&quot;&gt;:component&lt;span class=&quot;token operator&quot;&gt;&amp;gt;，所有的内容均需要在此内容中编写。一个component中也可以嵌套其他的component，父子的component引用时，父的style sheet样式会影响到子，使用时需要注意此点。针对Component更重要的是这个东西用在哪里，怎么用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;em&gt;1.用在哪里：&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;Lightning Component可以用在很多的地方，如下图所示。头标签的属性实现不同的接口，则可以将此component用于不同地方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180414121822341-729106448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;implements=&quot;force:appHostable&quot; ： 创建一个componet用于自定义的lightning tab；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;implements=&quot;flexipage:availableForAllPageTypes&quot;and access=&quot;global&quot;    创建一个component用于lightning page或者用于lightning app builder；&lt;/li&gt;
&lt;li&gt;implements=&quot;flexipage:availableForRecordHome,force:hasRecordId&quot; and access=&quot;global&quot;    创建一个component用于lightning的记录home page，此种方式可以直接应用当前记录的ID；&lt;/li&gt;
&lt;li&gt;implements=&quot;forceCommunity:availableForAllPageTypes&quot; and access=&quot;global&quot;      创建一个component用于Community Builder；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;implements=&quot;force:lightningQuickAction&quot;     &lt;/em&gt; 创建一个component用于quick action。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;2.怎么用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;1) &lt;strong&gt;创建Lightning Component&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Lightning  Component可以有多种创建的方式，使用sublime创建，使用develop console或者idea，本人常用sublime创建。在File-&amp;gt;New-&amp;gt;Lightning Component便可以新建一个lightning component。在新建的lightning component名称处右键，便可以新建出来此lightning component bundle其他的组件，比如controller.js,helper.js等组件，如下图所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201804/910966-20180414115159248-719009163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) Lightning Component 基础知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和classic 中的visualforce component很相像，一个lightning component可以嵌套另外一个lightning component，如果嵌套的component含有命名空间，则引入的方式为&amp;lt;yourNamespace:yourComponent/&amp;gt;如果没有设置命名空间，则默认的命名空间为c,即&amp;lt;c:yourComponent/&amp;gt;&lt;/p&gt;
&lt;p&gt;一个Lightning Component文件中可以引入多种元素，常用的元素如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;aura:attribute&amp;gt;:此标签用于声明Component中需要引用的内容信息的变量。&lt;/li&gt;
&lt;li&gt;&amp;lt;aura:registerEvent&amp;gt;:此标签用于引入自定义的注册事件。&lt;/li&gt;
&lt;li&gt;&amp;lt;aura:handler&amp;gt;:此标签用于处理自定义的注册事件以及标准的事件，比如初始化（init）等handler。&lt;/li&gt;
&lt;li&gt;&amp;lt;ltng:require&amp;gt;: 此标签用于引入静态资源&lt;/li&gt;
&lt;li&gt;元素标签：lightning封装了很多元素标签，常用的可以归纳为容器(container)元素，按钮(button)元素，导航(navigation)元素，可视化(Visual)元素，字段(Field)元素以及格式化(format)元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&amp;lt;aura:attribute&amp;gt;:&lt;/strong&gt;做过classic的朋友都知道，一个页面，后台使用成员变量，前台VF page可以用它来渲染元素。在lightning中，Component attribute很像apex中的成员变量，他们可以使用表达式语句应用在组件元素标签中进行信息渲染。&lt;/p&gt;
&lt;p&gt;attribute必须有两个属性：name以及type， aura:attribute写法如下.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testAttribute&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
test for {!v.testAttribute}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的demo声明了一个类型为string的attribute，名称为testAttribute。组件如果引用相关的属性信息，引用方式为{!v. + attributeName}。lightning中，&lt;span&gt;使用&quot;v&quot;去访问attribute内容&lt;/span&gt;（v可以简单的理解成view）。如果想要在后面设置attribute的值，也可以通过&amp;lt;aura:set attribute=&quot;anotherTestAttribute&quot;&amp;gt;来更改attribute值，aura:set通常可以和&amp;lt;aura:if&amp;gt;标签一起使用，有兴趣的可以自行查看。&lt;/p&gt;
&lt;p&gt; attribute的type基本涵盖了所有的类型，type取值如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Boolean：定义一个布尔类型attribute。eg:&amp;lt;aura:attribute name=&quot;showDetail&quot; type=&quot;Boolean&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Date：定义一个日期类型，不含Time，默认格式：YYYY-MM-dd。 eg: &amp;lt;aura:attribute name=&quot;startDate&quot; type=&quot;Date&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Datetime：定义一个日期类型，含Time。eg:&amp;lt;aura:attribute name=&quot;lastModifiedDate&quot; type=&quot;DateTime&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Decimal：定义一个浮点型小数，比Double类型更容易接收currency类型的数据。eg:&amp;lt;aura:attributename=&quot;totalPrice&quot; type=&quot;Decimal&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Double&lt;/span&gt;： 定义一个double类型小数，通常可以被Decimal替代&lt;/li&gt;
&lt;li&gt;Integer：定义一个整数类型。eg:&amp;lt;aura:attribute name=&quot;numRecords&quot; type=&quot;Integer&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Long：定义一个长整型类型，如果Integer盛装不了，需要使用Long。eg:aura:attribute name=&quot;numRecords&quot; type=&quot;Long&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;String：定义一个字符串类型。eg:&amp;lt;aura:attribute name=&quot;message&quot; type=&quot;String&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(注：上述基本类型也可以使用数组类型，eg:&amp;lt;aura:attribute name=&quot;message&quot;  type=&quot;String[]&quot; /&amp;gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;函数类型：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;与javascript类型相一致的attribute 类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象类型：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;定义一个自定义的object或者sObject类型。eg:&amp;lt;aura:attribute name=&quot;acc&quot; type=&quot;Account&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;集合类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;type[](Array)：声明一个数组类型。eg:&lt;/span&gt;&lt;/span&gt;&amp;lt;aura:attribute  name=&quot;colorPalette&quot; type=&quot;String[]&quot; default=&quot;['red','green', 'blue']&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;List：声明一个有序列表(和type[]相似，个人认为此处可以替代type[])。eg: &amp;lt;aura:attribute name=&quot;colorPalette&quot; type=&quot;List&quot; default=&quot;['red', 'green', 'blue']&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Map：声明一个Map类型，包含键值对。eg:&amp;lt;aura:attribute name=&quot;testMap&quot; type=&quot;Map&quot; default=&quot;{a: 'label1', b:'label2' }&quot; /&amp;gt;&lt;/li&gt;
&lt;li&gt;Set：声明一个无序列表。eg:&amp;lt;aura:attriute name=&quot;colorSet&quot; type=&quot;Set&quot; default=&quot;{'red','green','blue'}&quot; /&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;自定义Java类型：&lt;/strong&gt;如果创建Java类型，这个类必须要实现JsonSerializable接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特定的Frame-work类型（Framework-Specific）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Aura.Action：传递一个action到lightning:component中。eg: &amp;lt;aura:attribute name=&quot;onclick&quot; type=&quot;Aura.Action&quot;/&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&amp;lt;aura:registerEvent&amp;gt;:&lt;/strong&gt; 通常用于创建完自定义event后，将event注册到component中，从而通过aura:handler将event进行装载。event包含系统自带的标准事件（init/change等）以及自定义事件，aura:registerEvent用于注册自定义事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;aura:handler&amp;gt;:&lt;/strong&gt; lightning中提供了一些标准和自定义事件，将事件装载到lightning component中需要使用aura:handler。标准的事件举例：init（lightning component初始化触发，相当于VF page中的构造函数或者action声明内容）,change（某个aura:attribute改变自动触发）。aura:handler写法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;childAttr&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:handler &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;change&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.childAttr}&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.onChildAttrChange}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的demo声明了一个针对childAttr的change事件，当childAttr更改以后，便会执行controller.js的onChildAttrChange方法。&lt;/p&gt;
&lt;p&gt;（点击可查看event的&lt;a href=&quot;https://developer.salesforce.com/docs/atlas.en-us.212.0.lightning.meta/lightning/events_best_practices.htm&quot; target=&quot;_blank&quot;&gt;Best Practice&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元素标签：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;aura framework提供了大量的可以直接使用的元素标签用来开发，用户也可以通过slds样式更改成需要的样式。官方提供了很多可以直接使用的标签，以ui: / lightning: aura: 开头。元素标签的样式使用slds进行渲染，如果想查看某个元素标签样式或者想要更改相关的样式，可以先查看&lt;a href=&quot;https://www.lightningdesignsystem.com/&quot; target=&quot;_blank&quot;&gt;lightning design system&lt;/a&gt;中元素的渲染方式。元素标签可以包含几大类来汇总：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/accordion/&quot; target=&quot;_blank&quot;&gt;lightning:accordion / lightning:accordionSection&lt;/a&gt; : 可折叠容器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/cards/&quot; target=&quot;_blank&quot;&gt;lightning:card&lt;/a&gt; ：卡牌装容器，用于展示一组信息&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/utilities/grid/&quot; target=&quot;_blank&quot;&gt;lightning:layout/lightning:layoutItem&lt;/a&gt; : Grid容器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/tabs/&quot; target=&quot;_blank&quot;&gt;lightning:tab/lightning:tabset&lt;/a&gt; : Tab标签&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/tiles/&quot; target=&quot;_blank&quot;&gt;lightning:tile&lt;/a&gt; : 瓷砖模型,用于展示一条记录的相关信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按钮组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/buttons/&quot; target=&quot;_blank&quot;&gt;lightning:button&lt;/a&gt;: 普通按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/button-icons/&quot; target=&quot;_blank&quot;&gt;lightning:buttonIcon&lt;/a&gt;:只有一个html icon的按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/button-groups/&quot; target=&quot;_blank&quot;&gt;lightning:buttonGroup&lt;/a&gt;：一组按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/menus/&quot; target=&quot;_blank&quot;&gt;lightning:buttonMenu/lightning:menuItem&lt;/a&gt;: 一个drop-down 列表展示action&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导航组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/breadcrumbs/&quot; target=&quot;_blank&quot;&gt;lightning:breadcrumb/lightning:breadcrumbs&lt;/a&gt;: 展示当前操作记录的层级导航&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/trees/&quot; target=&quot;_blank&quot;&gt;lightning:tree&lt;/a&gt;： 树形结构&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/vertical-navigation/&quot; target=&quot;_blank&quot;&gt;lightning:verticalNavigation&lt;/a&gt;： 垂直排列的链接列表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可视化组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/avatar/&quot; target=&quot;_blank&quot;&gt;lightning:avatar&lt;/a&gt;: 对象的可视化表示 （一个图像）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/badges/&quot; target=&quot;_blank&quot;&gt;lightning:badge&lt;/a&gt;：包含少量信息的文本块标签 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/data-tables/&quot; target=&quot;_blank&quot;&gt;lightning:datatable&lt;/a&gt;： 显示table布局 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/dynamic-icons/&quot; target=&quot;_blank&quot;&gt;lightning:dynamicIcon&lt;/a&gt;： 动画效果icon&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/tooltips/&quot; target=&quot;_blank&quot;&gt;lightning:helptext&lt;/a&gt;： hover后提示信息效果&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/icons/&quot; target=&quot;_blank&quot;&gt;lightning:icon&lt;/a&gt;： 显示一个图标&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/pills/&quot; target=&quot;_blank&quot;&gt;lightning:pill&lt;/a&gt;： 展示一个显示X号的内容，可以显示或者不显示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/progress-bar/&quot; target=&quot;_blank&quot;&gt;lightning:progressBar&lt;/a&gt;： 展示一项操作的进程条&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/progress-indicator/&quot; target=&quot;_blank&quot;&gt;lightning:progressIndicator&lt;/a&gt;：进程指示器，显示进程线&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/spinners/&quot; target=&quot;_blank&quot;&gt;lightning:spinner&lt;/a&gt;: 显示Loading图形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字段组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/checkbox/&quot; target=&quot;_blank&quot;&gt;lightning:checkboxGroup&lt;/a&gt; ：复选框 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/combobox/&quot; target=&quot;_blank&quot;&gt;lightning:combobox&lt;/a&gt; ：提供一个用户输入的并且可以autocomplete的控件 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/dueling-picklist/&quot; target=&quot;_blank&quot;&gt;lightning:dualListbox &lt;/a&gt;： 两个list间移动option。类似multi picklist效果 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/file-selector/&quot; target=&quot;_blank&quot;&gt;lightning:fileUpload&lt;/a&gt; ： 提供上传文件的框&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/files/&quot; target=&quot;_blank&quot;&gt;lightning:fileCard&lt;/a&gt; ： 展示一系列的上传的文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/input/&quot; target=&quot;_blank&quot;&gt;lightning:input &lt;/a&gt;： 默认展示输入框，根据type不同展示不同效果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/radio-group/&quot; target=&quot;_blank&quot;&gt;lightning:radioGroup&lt;/a&gt;：展示一组单选按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/select/&quot; target=&quot;_blank&quot;&gt;lightning:select&lt;/a&gt;：展示一个包含多个option的菜单&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/slider/&quot; target=&quot;_blank&quot;&gt;lightning:slider&lt;/a&gt; : 展示一个可以滑动效果指定范围的输入框 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/rich-text-editor/&quot; target=&quot;_blank&quot;&gt;lightning:inputRichText&lt;/a&gt;： 富文本编辑器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lightningdesignsystem.com/components/textarea/&quot; target=&quot;_blank&quot;&gt;lightning:textArea&lt;/a&gt;： textArea &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下标签都是只读的&lt;/p&gt;
&lt;p&gt;lightning:formattedDateTime ：格式化 data &amp;amp; time&lt;/p&gt;
&lt;p&gt;lightning:formattedEmail ：格式化 email&lt;/p&gt;
&lt;p&gt;lightning:formattedLocation  ：使用经纬度格式化Location&lt;/p&gt;
&lt;p&gt;lightning:formattedNumber ：格式化数字&lt;/p&gt;
&lt;p&gt;lightning:formattedPhone：格式化电话号码&lt;/p&gt;
&lt;p&gt;lightning:formattedRichText：格式化富文本区域&lt;/p&gt;
&lt;p&gt;lightning:formattedText：格式化字符串&lt;/p&gt;
&lt;p&gt;lightning:formattedUrl：格式化URL&lt;/p&gt;
&lt;p&gt;一个元素标签包含local ID,global ID。local id 作用域为当前的component，使用aura:id 属性来创建一个local id。aura:id不支持表达式，只支持普通的字符串值作为local id.&lt;/p&gt;
&lt;p&gt;local id 理论上是唯一的，但是不强制唯一，比如一组checkbox元素标签，可以设置他们的local id是相同的。local id可以用于在javascript中通过local id获取到元素本身或者元素列表。&lt;/p&gt;
&lt;p&gt;eg:&amp;lt;lightning:input type=&quot;string&quot; aura:id = &quot;name&quot; value=&quot;testValue&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;controller或者helper中可以通过cmp.find(&quot;name&quot;)即可获取到 aura:id为name的元素（或者元素列表），如果不存在所要搜索的aura:id，则返回undefined.controller.js/helper.js中针对一个元素获取它的local id，可以通过cmp.getLocalId()方法获得。&lt;/p&gt;
&lt;p&gt;Global id 很像classic中visualforce 元素组件中的id,运行时生成，并且是唯一的。&lt;br/&gt;eg:&amp;lt;lightning:input type=&quot;string&quot; id=&quot;name&quot; value=&quot;testValue&quot; /&amp;gt;&lt;br/&gt;global id可以用来区分不同元素的组件实例化或者用于debugging操作。针对一个组件元素获取它的global id,可以通过cmp.getGlobalId()获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三. Controller js介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为component不允许写任何的js，即使类似onclick=&quot;alert(xxx);&quot;这种js也是被禁止的，所以controller js部分作用是至关重要的。他管理着Component中所有的事件驱动操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里假设我们在'showMyInfo' componet中有一个按钮名字是'Button1'，绑定了一个'onclick'事件，onclick=&quot;{!c.handlerClick}&quot;.&lt;span&gt;上面我们说过，针对元素组件引用attribute的值，使用v（v代表了view）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当我们点击按钮或者触发了注册的事件后，会执行controller.js里面的方法，需要写{!c.functionName},其中c可以理解为 client-side controller，functionName为在controller.js中声明的方法名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们为一个component bundle新建一个Controller js时，我们会发现，每个Controller方法里面默认都有3个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cmp ： 代表当前操作的action所在的component，这里指的是showMyInfo&lt;/li&gt;
&lt;li&gt;event：代表当前action操作所触发的事件，通过事件可以获取到当前事件所对应的元素；&lt;/li&gt;
&lt;li&gt;helper：helper代表当前的componet对应的helper.js，当然这个参数不是必须的，helper文件可以写js内容用来和后台server controller交互。当然，如果你想把和server controller交互的代码写在当前的controller js中，也是可以的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;cmp：&lt;/strong&gt;我们通常用cmp可以获取和设置attribute值，通过cmp.get('v.attributeName')即可获取到lightning component中attribute名称为attributeName的值。&lt;em id=&quot;__mceDel&quot;&gt;通过cmp.set('v.attributeName','testAttributeValue')&lt;/em&gt;即可设置lightning componet中名称为attributeName的attribute的值为testAttributeValue.当然，cmp可不止获取设置attribute值这么简单，还可以通过cmp.getEvent('eventName')获取注册的事件等等。我们平时用的cmp比较多的功能就是这两个了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;event：&lt;/strong&gt;event代表当前操作的事件，比如当上面的用户点击了按钮，可以通过event.getSource()获取到事件源Button1以及获取到事件源自身的属性等信息；可以获取到事件源的事件操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; helper:&lt;/strong&gt;helper代表了helper.js的实例化变量，你可以通过helper.helperMethod用来处理具体的逻辑，包括和后台交互；处理结果集；功能性的方法重用等等。因为有了helper，你的代码有了更好的可读性，可维护性以及可重用性。&lt;/p&gt;

&lt;p&gt;下面通过几行简单的代码来了解cmp以及event的用法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;var btnClicked = event.getSource();此行代码可以理解为获取到点击的button的dom element&lt;/li&gt;
&lt;li&gt;var btnMessage = btnClicked.get(''v.label&quot;); 通过element的get方法可以获取到这个元素上面的属性值，获取属性值或者获取其他的组件中的元素信息，需要使用'v.'来获取；&lt;/li&gt;
&lt;li&gt;component.set(&quot;v.message&quot;, btnMessage); 更新component中名称为message的attribute值。&lt;/li&gt;
&lt;li&gt;controller中有可能有多个方法，每个方法之间使用‘，’分隔；最后一个方法不能有‘，’。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;({
    handleClick: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; btnClicked = event.getSource();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the button&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; btnMessage = btnClicked.get(&quot;v.label&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the button's label&lt;/span&gt;
        component.set(&quot;v.message&quot;, btnMessage);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; update our message&lt;/span&gt;
&lt;span&gt;    },&lt;br/&gt;　　 handleClick2: function(component,event,helper) {&lt;br/&gt;　　 }&lt;br/&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四 Helper js 介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果是controller.js负责了component中的所有业务逻辑，那么helper js就承包了所有的业务细节处理或者公用的方法（显示隐藏loading等）。helper一般需要component这个参数，其他参数可以根据实际需要自动从controller.js获取以及传递。这里举例一个调用后台并对返回数据进行处理的例子。想要连接后台，需要准备以下的工作：&lt;/p&gt;
&lt;p&gt;1.lightning component 的controller属性设置此component后台引用的controller,用法和classic用法相同；&lt;/p&gt;
&lt;p&gt;2.controller（后台）方法需要为静态方法，并且需要添加@AuraEnabled注解。如果有classic经验的可以想一下remote action的后台要求，把@RemoteAction改成@AuraEnabled就好。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
createItem: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, camping) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; action = component.get(&quot;c.saveItem&quot;&lt;span&gt;);
    action.setParams({
        &lt;/span&gt;&quot;camping&quot;&lt;span&gt;: camping
    });
    action.setCallback(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; response.getState();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state === &quot;SUCCESS&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items = component.get(&quot;v.items&quot;&lt;span&gt;);
            items.push(response.getReturnValue());
            component.set(&lt;/span&gt;&quot;v.items&quot;&lt;span&gt;, items);
        } else if(status == &quot;INCOMPLETE&quot;) {&lt;br/&gt;console.log('execute');&lt;br/&gt;} else if(status == &quot;ERROR&quot;) {&lt;br/&gt;　　　　　　　console.log('error');&lt;br/&gt;}
    });
    $A.enqueueAction(action);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述例子功能为后台调用saveItem方法，camping作为参数传递到后台，然后异步调用。调用成功后将这个item写入到前台的camping列表中。&lt;/p&gt;
&lt;p&gt;其中有几点需要注意：&lt;/p&gt;
&lt;p&gt;1.我们通常使用component.get('v.something')来调用前台的一些属性元素等，在这里使用component.get('c.backgroundMethod')可以调用到后台的方法；&lt;/p&gt;
&lt;p&gt;2.通过setParam可以对方法设置参数,通过setCallBack可以对这个方法进行异步处理，我们通常会将这种调用后台的方法进行异步结果处理；&lt;/p&gt;
&lt;p&gt;3.response的状态主要有三种：SUCCESS/INCOMPLETE/ERROR。建议方法中将三种情况都进行处理，比如INCOMPLETE展示遮罩，ERROR/SUCCESS进行相应的业务处理以及解除遮罩等；&lt;/p&gt;
&lt;p&gt;4.需要将action放在队列里面，让他排队进行执行。$A为lightning中封装的一个global变量，除了enqueueAction方法外还有很多常用的方法，后面会有涉及，有兴趣的自行查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇只是泛泛的对lightning componet常用的进行简单的介绍，并没有系统的介绍使用功能等，也没有demo进行整体的连接。有兴趣的可以自己查看文档或者trailhead等学习资料，后期将会写一些细节的使用。有错误的地方欢迎指出，有不懂的欢迎提问。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Apr 2018 14:47:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/8733056.html</dc:identifier>
</item>
</channel>
</rss>