<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程池定制初探 - Secondworld</title>
<link>http://www.cnblogs.com/Kidezyq/p/8362732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kidezyq/p/8362732.html</guid>
<description>&lt;p&gt;​ 我在的公司虽然是移动支付领域的公司。但是我做的业务类似于管理系统，所以一开始写代码的时候没有考虑到数据的量的问题。开始有一个统计页面，大概要统计的数据分为十多个维度，然后每个维度需要考虑十个左右的方面。也就是统计页面轻轻地点击一个查询按钮，要进行100次左右的数据库查询。开始数据量小的时候，查询还能够使用，页面不会超时。到后面数据量越来越大，最大的一张表数据量已经超过1亿。这时候悲催的事情发生了--- &lt;strong&gt;页面点击查询直接未响应&lt;/strong&gt;.....&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;​ 其实当时的方案我想了两种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;优化业务实现逻辑，其实在查询的时候一个表的多个维度的查询可以传一个维度列表进去。查出来结果之后，后台在进行分组计算。&lt;/li&gt;
&lt;li&gt;采用多线程，对每一个维度采用一个线程去执行。这样其实每个线程的查询次数在10次左右，总的时间差不多可以缩短10倍。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;​ 当然，当时我知道最好的方案是混合使用1和2。但当时1的实现存在以下问题，最终让我决定选择方案2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;因为每个维度涉及多张表, 不同的表归属于不同的模块。如果某张表的查询条件不支持维度列表，那么需要提需求给对应模块开发...... (何年何月能完)&lt;/li&gt;
&lt;li&gt;方案1的改动涉及代码变动较多，且不好封装每个线程任务，写出来的代码逻辑有点绕，后台存在大量的重新分维度统计的代码。简而言之就是&lt;strong&gt;不优雅&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;​ 既然最终选定方案2的话，那么自然考虑到选择线程池。那么选啥线程池呢？Single？Schedule肯定不用想直接PASS。Cached？其实当前来说是可行的，因为当前线上的维度也就十多个。以Cached线程池的特性，只要同时并发的线程数量不至于太大，也不至于给系统太大压力导致系统瘫痪。但是因为维度会随着业务的增长而越来越多，如果后续维度增加到20甚至30，那么对系统的压力就无法预估了。&lt;/p&gt;
&lt;p&gt;​ 思前想后，我最终决定选择Fix线程池，将线程池固化大小为10个。但这时候我又想，其实统计页面一天查询的次数并不多。可能就每天早上点击查询一次，后面可能就不再点查询。那么这时候又出现了两种蛋疼的选择:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;直接在查询的方法内部初始化线程池&lt;/li&gt;
&lt;li&gt;在类的属性中初始化线程池&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;​ 第1种方案的话，每次查询都要重新初始化线程池，造成很大的资源消耗。如果连续查询多次，并不会后面比前面快，反而可能由于不停的线程池销毁创建导致越来越慢。最终我选择了第2种方案，当然我并没有选择&lt;strong&gt;饿汉模式&lt;/strong&gt;直接初始化，而是选择了&lt;strong&gt;懒汉模式&lt;/strong&gt;在方法中进行线程池初始化，且通过锁保证只初始化一次。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;​ 到这里你如果觉得我的定制初探就完了，那你就too young too naive。我不追求可行，只追求完美~&lt;/p&gt;
&lt;p&gt;这时候我就在想，其实根据用户的操作习惯，统计页面的查询按钮，要么就隔着几个小时不按，要么就可能一时心血来潮，连续查询几天或者同一天分多个维度查询多次。而大家都知道Fix线程池固化了线程池的大小，即使后面连续几个小时没有任务来，仍然会一直保持着初始大小的线程数。那么能不能实现即能够控制线程数量Fix，又可以在空闲的时候销毁核心线程呢？答案当然是有的，关键点在于:&lt;strong&gt;ThreadPoolExecutor的allowCoreThreadTimeOut方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Sets the policy governing whether core threads may time out and&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * terminate if no tasks arrive within the keep-alive time, being&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * replaced if needed when new tasks arrive. When false, core&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * threads are never terminated due to lack of incoming&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * tasks. When true, the same keep-alive policy applying to&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * non-core threads applies also to core threads. To avoid&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * continual thread replacement, the keep-alive time must be&lt;/span&gt;
&lt;span class=&quot;er&quot;&gt;     * greater than zero when setting &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt;. This method&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * should in general be called before the pool is actively used.&lt;/span&gt;
&lt;span class=&quot;er&quot;&gt;     * @param value &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if should time out, else &amp;lt;tt&amp;gt;false&amp;lt;/tt&amp;gt;&lt;/span&gt;
&lt;span class=&quot;er&quot;&gt;     * @throws IllegalArgumentException if value is &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * and the current keep-alive time is not greater than zero.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@since &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;1.6&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;allowCoreThreadTimeOut&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; value) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (value &amp;amp;&amp;amp; keepAliveTime &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Core threads must have nonzero keep alive times&quot;&lt;/span&gt;);

        allowCoreThreadTimeOut = value;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​ 从源码的注释来看，该方法可以支持线程池的keep-alive time的设置同时对核心线程和非核心线程生效。具体为啥，后面我分析线程池源码的时候会讲到，现在我们只需要看看用到该处的源码(在&lt;strong&gt;ThreadPoolExecutor的getTask方法&lt;/strong&gt;中):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Gets the next task for a worker thread to run.  The general&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * approach is similar to execute() in that worker threads trying&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * to get a task to run do so on the basis of prevailing state&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * accessed outside of locks.  This may cause them to choose the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &quot;wrong&quot; action, such as trying to exit because no tasks&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * appear to be available, or entering a take when the pool is in&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * the process of being shut down.  These potential problems are&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * countered by (1) rechecking pool state (in workerCanExit)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * before giving up, and (2) interrupting other workers upon&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * shutdown, so they can recheck state. All other user-based state&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * changes (to allowCoreThreadTimeOut etc) are OK even when&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * performed asynchronously wrt getTask.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the task&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    Runnable &lt;span class=&quot;fu&quot;&gt;getTask&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; state = runState;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (state &amp;gt; SHUTDOWN)
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                Runnable r;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (state == SHUTDOWN)  &lt;span class=&quot;co&quot;&gt;// Help drain queue&lt;/span&gt;
                    r = workQueue.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (poolSize &amp;gt; corePoolSize || allowCoreThreadTimeOut)
                    r = workQueue.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(keepAliveTime, TimeUnit.&lt;span class=&quot;fu&quot;&gt;NANOSECONDS&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                    r = workQueue.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (r != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; r;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;workerCanExit&lt;/span&gt;()) {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (runState &amp;gt;= SHUTDOWN) &lt;span class=&quot;co&quot;&gt;// Wake up others&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;interruptIdleWorkers&lt;/span&gt;();
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                }
                &lt;span class=&quot;co&quot;&gt;// Else retry&lt;/span&gt;
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException ie) {
                &lt;span class=&quot;co&quot;&gt;// On interruption, re-check runState&lt;/span&gt;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​ 关键在于&lt;code&gt;workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)&lt;/code&gt;,该方法表示尝试从等待队列中获取任务，如果超过keepAlive time，则直接返回null。如果返回null的话，work线程就会被终止。&lt;/p&gt;
&lt;p&gt;​ 好了这些都是后话，在我看了线程池的源码之后才能够清楚地知道为啥这个参数有这个作用。那么在之前，我是怎么测试验证我的想法的呢？其实很简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我先参照线程池的默认的&lt;code&gt;DefaultThreadFactory&lt;/code&gt;定义自己的线程工厂，目的是为了获取线程工厂内的&lt;code&gt;ThreadGroup&lt;/code&gt;属性，因为&lt;code&gt;ThreadGroup&lt;/code&gt;类有一个&lt;code&gt;activeCount&lt;/code&gt;方法，该方法可以获取线程组内活跃的线程个数。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyThreadFactory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ThreadFactory {
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ThreadGroup group;
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String namePrefix;

        &lt;span class=&quot;fu&quot;&gt;MyThreadFactory&lt;/span&gt;() {
            SecurityManager s = System.&lt;span class=&quot;fu&quot;&gt;getSecurityManager&lt;/span&gt;();
            group = (s != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? s.&lt;span class=&quot;fu&quot;&gt;getThreadGroup&lt;/span&gt;() : Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getThreadGroup&lt;/span&gt;();
            namePrefix = &lt;span class=&quot;st&quot;&gt;&quot;pool-&quot;&lt;/span&gt; + poolNumber.&lt;span class=&quot;fu&quot;&gt;getAndIncrement&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;-thread-&quot;&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Thread &lt;span class=&quot;fu&quot;&gt;newThread&lt;/span&gt;(Runnable r) {
            Thread t = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(group, r, namePrefix + threadNumber.&lt;span class=&quot;fu&quot;&gt;getAndIncrement&lt;/span&gt;(), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t.&lt;span class=&quot;fu&quot;&gt;isDaemon&lt;/span&gt;())
                t.&lt;span class=&quot;fu&quot;&gt;setDaemon&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t.&lt;span class=&quot;fu&quot;&gt;getPriority&lt;/span&gt;() != Thread.&lt;span class=&quot;fu&quot;&gt;NORM_PRIORITY&lt;/span&gt;)
                t.&lt;span class=&quot;fu&quot;&gt;setPriority&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;NORM_PRIORITY&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; t;
        }
        
        &lt;span class=&quot;co&quot;&gt;// 我所增加的方法，为了获取线程组&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ThreadGroup &lt;span class=&quot;fu&quot;&gt;getThreadGroup&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;group&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;万事俱备，只欠东风了，我只需要构造两种不同的情况验证我的猜想即可！&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;MyThreadFactory myThreadFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyThreadFactory&lt;/span&gt;();
ThreadPoolExecutor executor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;,
                                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), myThreadFactory); 
&lt;span class=&quot;co&quot;&gt;// executor.allowCoreThreadTimeOut(true);&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;; i++) {
  executor.&lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyRunnable&lt;/span&gt;());
}
System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myThreadFactory.&lt;span class=&quot;fu&quot;&gt;getThreadGroup&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;activeCount&lt;/span&gt;());     &lt;span class=&quot;co&quot;&gt;// 6 &lt;/span&gt;
Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20000&lt;/span&gt;);
System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;After destroy, active thread count:&quot;&lt;/span&gt; + myThreadFactory.&lt;span class=&quot;fu&quot;&gt;getThreadGroup&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;activeCount&lt;/span&gt;());             &lt;span class=&quot;co&quot;&gt;// 6/1&lt;/span&gt;
executor.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​ 运行的结果:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;如果不执行&lt;code&gt;executor.allowCoreThreadTimeOut(true);&lt;/code&gt;两个activeCount的结果都是6&lt;/li&gt;
&lt;li&gt;如果执行&lt;code&gt;executor.allowCoreThreadTimeOut(true);&lt;/code&gt;第一个activeCount的结果为6，第二个activeCount的结果为1&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;​ 好了，终于到最终定制实现了。我的代码实现如下(类为Spring管理的类，最终线程池shutdown在PreDestroy的时候):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; ThreadPoolExecutor searchExecutors; 
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object lock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 初始化线程池，开始不进行初始化，免得浪费系统资源&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initExecutor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (searchExecutors != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }
        
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (searchExecutors == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                 &lt;span class=&quot;co&quot;&gt;// 设置一个固定大小为10，核心线程如果超过10分钟空闲也可销毁的线程池&lt;/span&gt;
                ThreadPoolExecutor tempExecutor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MINUTES&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), Executors.&lt;span class=&quot;fu&quot;&gt;defaultThreadFactory&lt;/span&gt;());
                tempExecutor.&lt;span class=&quot;fu&quot;&gt;allowCoreThreadTimeOut&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;searchExecutors&lt;/span&gt; = tempExecutor;
            }
        }
    }

    &lt;span class=&quot;fu&quot;&gt;@PreDestroy&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;destroy&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (searchExecutors != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            searchExecutors.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这里再说两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这个初始化方法采用了double-check-lock的方式，来保证多线程并发获取到的是同一个线程池实例&lt;/li&gt;
&lt;li&gt;注意到在设置属性searchExecutors之前借助了一个tempExecutor。这样也是为了防止ThreadPoolExecutor对象已经被初始化，但是allowCoreThreadTimeOut还未被执行的问题。（对象过早逃逸导致属性与预期不符）。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;​ 通过这次线程池定制初探，发现其实看起来再没有技术含量的工作，如果细细想下去还是会有很多可以深入研究的东西。而做软件其实也要像做艺术品一样，多考虑不同的实现可能，尽量选择最完美的解决方案。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 17:20:00 +0000</pubDate>
<dc:creator>Secondworld</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Kidezyq/p/8362732.html</dc:identifier>
</item>
<item>
<title>Binlog的三个业务应用场景 - kingszelda</title>
<link>http://www.cnblogs.com/kingszelda/p/8362612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingszelda/p/8362612.html</guid>
<description>&lt;p&gt;  binlog是mysql的一种二进制日志文件，用来记录数据的变化。mysql使用binlog进行主从复制，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1196330/201801/1196330-20180126234342865-81329095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端向master的mysql sever写入数据&lt;/li&gt;
&lt;li&gt;当数据发生变化时，master将变更的数据记录写入到二进制文件中，即binlog。&lt;/li&gt;
&lt;li&gt;slave订阅了master的binlog，所以会通过一个I/O THREAD与master的DUMP THREAD进行通信，同步binlog&lt;/li&gt;
&lt;li&gt;I/O THREAD读取到binlog后会吸入到relay log中，准备重放。&lt;/li&gt;
&lt;li&gt;slave会通过SQL THREAD读取relay log，重放数据的改动并执行相应的改动。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里有几点需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主从复制不是强一致性，只能保证最终一致&lt;/li&gt;
&lt;li&gt;master配合binlog复制会影响性能，所以尽量不要在master上挂太多的slave，如果对时间要求不高，可以在slave上挂slave&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  上面介绍了mysql中应用binlog的场景，而我们的业务可以伪装成master的slave节点，感知数据的变化，这就给了我们很多的业务运用空间。&lt;/p&gt;
&lt;h2&gt;2.1 数据异构&lt;/h2&gt;
&lt;p&gt;  经常有这样一个场景：&lt;/p&gt;
&lt;p&gt;  原来业务是一个很单一的系统，所以表也在一起。随着业务的发展，系统开始拆分，总有一些表是各个业务都关注的表，但是对相关的字段的运用场景不同，所以这样一份元数据怎样更好的为各个系统服务就成了问题。当然，多写或者读写分离可以从物理节点上减少对数据服务器的压力，但是对业务并没有做到足够的支持，因为这些表都是一样的。因此我们可以通过binlog进行数据异构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1196330/201801/1196330-20180127001323834-1717216490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，订单系统生成订单后，通过binlog可以解析生成用户维度的订单信息供用户中心查询、商户维度订单表供运营管理，以及搜索系统的搜索数据，提供全文搜索功能。&lt;/p&gt;
&lt;p&gt;这样，我们就通过原始的订单数据异构到三个系统中，提供了丰富的数据访问功能。不仅从节点上降低了数据服务器的压力，数据表现形式也更贴近自己的服务，减少不必要的字段冗余。&lt;/p&gt;
&lt;h2&gt;2.2 缓存数据的补充&lt;/h2&gt;
&lt;p&gt;对于高并发的系统，数据库往往是系统性能的瓶颈，毕竟IO响应速度是远远小于电子的运算速度的。因此，很多查询类服务都会在CPU与数据库之间加上一层缓存。即现从缓存获取，命中后直接返回，否则从DB中获取并存入缓存后返回。而如果原始数据变化了但缓存尚未超时，则缓存中的数据就是过时的数据了。当数据有变更的时候主动修改缓存数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1196330/201801/1196330-20180127004316631-1162452138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当客户端更改了数据之后，中间件系统通过binlog获得数据变更，并同步到缓存中。这样就保证了缓存中数据有效性，减少了对数据库的调用，从而提高整体性能。&lt;/p&gt;
&lt;h2&gt;2.3 基于数据的任务分发&lt;/h2&gt;
&lt;p&gt;有这样一个场景：&lt;/p&gt;
&lt;p&gt;  很多系统依赖同一块重要数据，当这些数据发生变化的时候，需要调用其他相关系统的通知接口同步数据变化，或者mq消息告知变化并等待其主动同步。这两种情况都对原始系统造成了侵入，原始系统改一块数据，并不想做这么多其他的事情。所以这时候可以通过binlog进行任务分发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1196330/201801/1196330-20180127010616631-1751665561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当原始业务系统修改数据后，不需要进行其他的业务关联。由调度系统读取binlog进行相应的任务分发、消息发送以及同步其他业务状态。这样可以将其他业务与原始业务系统解耦，并从数据的角度将所有管理功能放在了同一个调度系统中，责任清晰。&lt;/p&gt;

&lt;p&gt;  binlog是mysql提供的数据同步机制，很好的解决了主从分离、读写库分离等业务。而我们可以构建一个中间件系统，“伪造”成master的一个slave。当读取了binlog中的数据变化后，根据相应的业务场景做各种业务处理。而目前我接触到的最常见的就是第一个场景——数据异构，可以异构到其他表中，也可以异构到其他数据引擎中，比如Elastic Search。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 17:13:00 +0000</pubDate>
<dc:creator>kingszelda</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingszelda/p/8362612.html</dc:identifier>
</item>
<item>
<title>30分钟学玩转RabbitMQ - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8362289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8362289.html</guid>
<description>&lt;p&gt;最近在学习RabbitMQ，在网上找了不少资料发现都特高端。动辄集群部署，分布式架构什么的，对于一个初学者实在不够友好。心想求人不如求自己，为什么不自己整理一套资料呢？于是《30分钟学玩转RabbitMQ》诞生。&lt;/p&gt;
&lt;p&gt;一、准备工作&lt;/p&gt;
&lt;p&gt;据说RabbitMQ是可以部署到Windows环境的，不过作为一个专业级的开发人员怎么能够让这样的事情发生呢？自然我们的准备工作从Linux开始。首先在虚拟机中安装CentOS 7，选择英文，最小安装，默认开启网络以及创建一个root用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126215415147-616136809.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126215534787-2017835205.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126215704975-818299634.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成以后进入系统，由于最小安装有一些基本的命令无法使用，因此在进入一下步之前先将ifconfig、vim以及基本的编译环境准备好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 安装ifconfig &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
yum install net-tools

&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 安装vim &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
yum install yum

&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 准备基础编译环境 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来我们从官网下载安装包rabbitmq-server-3.7.2-1.el7.noarch.rpm和otp_src_19.3.tar.gz（&lt;span&gt;千万别问我Erlang是什么，我也是第一次知道这门语言&lt;/span&gt;）。上传到虚拟机后执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 解压包 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
[root@MiWiFi-R3-srv ~]# tar -xvf otp_src_19.3.tar.gz
[root@MiWiFi-R3-srv ~]# ll&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126230218240-970655391.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;268&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv ~]# mkdir /usr/local/erlang
[root@MiWiFi-R3-srv ~]# cd otp_src_19.3
[root@MiWiFi-R3-srv otp_src_19.3]# ./configure --prefix=/usr/local/erlang --without-javac
[root@MiWiFi-R3-srv otp_src_19.3]# make &amp;amp;&amp;amp; make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;编译&amp;amp;安装完成以后配置Erlang环境变量：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv otp_src_19.3]# vim /etc/profile

#追加环境变量到文件末尾
ERL_HOME=/usr/local/erlang
PATH=$ERL_HOME/bin:$PATH
export ERL_HOME PATH

[root@MiWiFi-R3-srv otp_src_19.3]# source /etc/profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来可以正式安装RabbitMQ：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv otp_src_19.3]# cd ..
[root@MiWiFi-R3-srv ~]# rpm -ivh --nodeps rabbitmq-server-3.7.2-1.el7.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行RabbitMQ需要首先开放15672和5672端口：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv ~]# firewall-cmd --zone=public --add-port=15672/tcp --permanent
[root@MiWiFi-R3-srv ~]# firewall-cmd --zone=public --add-port=5672/tcp --permanent
[root@MiWiFi-R3-srv ~]# firewall-cmd --reload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;正常情况下RabbitMQ已经安装完成，最后测试一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv ~]# rabbitmq-plugins enable rabbitmq_management
[root@MiWiFi-R3-srv ~]# rabbitmq-server&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126232942662-1490935331.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;268&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常启动以后，我们可以在本地使用浏览器中访问管理页面：http://&amp;lt;虚拟机IP&amp;gt;:15672/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126233425428-517890344.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;137&quot;/&gt;  大功告成...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;至此，我们的准备工作已经完成了80%。接下来我们需要为RabbitMQ创建用户并赋权。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@MiWiFi-R3-srv ~]# rabbitmqctl add_user root root
[root@MiWiFi-R3-srv ~]# rabbitmqctl set_user_tags root administrator
[root@MiWiFi-R3-srv ~]# rabbitmqctl  set_permissions -p / root '.*' '.*' '.*'
&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 后台启动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
[root@MiWiFi-R3-srv ~]# rabbitmq-server -detached&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;重新通过在本地浏览器访问管理页面，输入用户名和密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180126234722365-1587136573.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;247&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、简单开发指南&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深入的开发案例网上很多，我就不在这里重复的发明轮子了。作为一个指南，这里主要介绍两种开发方式，更加具体的用例我可能会在以后的文章中专门介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.单独使用——一个简单的消息生产者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过maven引入依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.rabbitmq&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;amqp-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建生产者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.learnhow.rabbitmq;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeoutException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.rabbitmq.client.ConnectionFactory;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列名称&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String QUEUE_NAME = &quot;Hello.rabbitMQ&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, TimeoutException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接工厂&lt;/span&gt;
        ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置连接属性&lt;/span&gt;
        factory.setHost(&quot;192.168.31.244&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虚拟机地址&lt;/span&gt;
        factory.setPort(5672); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 端口号&lt;/span&gt;
        factory.setUsername(&quot;root&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户名&lt;/span&gt;
        factory.setPassword(&quot;root&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密码
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到连接，创建通道&lt;/span&gt;
        Connection connection =&lt;span&gt; factory.newConnection();
        Channel channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明一个叫Hello.rabbitMQ的队列&lt;/span&gt;
        channel.queueDeclare(QUEUE_NAME, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        String message &lt;/span&gt;= &quot;Hello RabbitMQ&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息&lt;/span&gt;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, &lt;span&gt;null&lt;/span&gt;, message.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭通道和连接&lt;/span&gt;
&lt;span&gt;        channel.close();
        connection.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行完成以后切换到浏览器的管理页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180127000407006-967387756.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;195&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们发现刚才在main函数中声明的QUEUE NAME已经出现了。&lt;/p&gt;
&lt;p&gt;2.Spring AMQP——与Spring Boot集成&lt;/p&gt;
&lt;p&gt;Maven依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.9.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-amqp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Spring Boot启动项，声明测试队列：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dispatcher;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.Queue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;

@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DispatcherApplication {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Queue helloQueue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Queue(&quot;helloQueue&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SpringApplication.run(DispatcherApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;消息生产者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dispatcher.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.core.AmqpTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AmqpTemplate rabbitTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; send() {
        String sendMsg &lt;/span&gt;= &quot;Hi~ &quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rabbitTemplate.convertAndSend(&quot;helloQueue&quot;&lt;span&gt;, sendMsg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;消息接收者：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dispatcher.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.amqp.rabbit.annotation.RabbitListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
@RabbitListener(queues &lt;/span&gt;= &quot;helloQueue&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Receiver {
    @RabbitHandler
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(String msg) {
        System.out.println(&lt;/span&gt;&quot;Receiver: &quot; +&lt;span&gt; msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Restful接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dispatcher.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&lt;/span&gt;&quot;/rabbitmq&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RabbitMqController {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUCCESS = &quot;SUCCESS&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FAILURE = &quot;FAILURE&quot;&lt;span&gt;;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Producer producer;

    @GetMapping(&lt;/span&gt;&quot;/push&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String push() {
        producer.send();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;配置文件application.yml：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
server:
  port: 8081
spring:
  rabbitmq:
    host: 192.168.31.244
    port: 5672
    username: root
    password: root
    virtual-host: /
    publisher-confirms: true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;启动Spring Boot，访问：http://localhost:8081/rabbitmq/push，再切换到管理页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/871676/201801/871676-20180127002750912-221119420.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;262&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的QUEUE NAME证明Spring Boot与RabbitMQ整合成功。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 16:34:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8362289.html</dc:identifier>
</item>
<item>
<title>关于IDE与环境变量的一点说明 - Utb</title>
<link>http://www.cnblogs.com/zd540/p/8362255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zd540/p/8362255.html</guid>
<description>&lt;p&gt;环境变量就是当计算机要执行操作时，在环境变量所制定的范围内查找该操作。&lt;/p&gt;
&lt;p&gt;比如linux的ls命令，计算机就需要在$PATH规定的目录中寻找该ls的可执行文件。&lt;/p&gt;
&lt;p&gt;java的classpath,在该规定的目录中寻找class文件。&lt;/p&gt;
&lt;p&gt;JAVA_HOME,在该目录中寻找java命令。&lt;/p&gt;

&lt;p&gt;在Intellij idea中添加新的jar包，明明已经添加进去了，代码都可以编写，但是编译的时候提示了ClassNotFound&lt;/p&gt;

&lt;p&gt;尝试添加 libraries和jar还是无果后，将classpath指向了jar包目录，编译成功&lt;/p&gt;
&lt;p&gt;因为编译器需要环境变量的帮助才可以正常工作？？&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 16:29:00 +0000</pubDate>
<dc:creator>Utb</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zd540/p/8362255.html</dc:identifier>
</item>
<item>
<title>2017华为编程大赛总结 - 王若伊_恩赐解脱</title>
<link>http://www.cnblogs.com/jilodream/p/8362135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jilodream/p/8362135.html</guid>
<description>&lt;p&gt;&lt;span&gt;      华为研发部门，每年都会在部门内部举办一届编程大赛。旨在让开发人员在工作之余，通过游戏编程的切磋，提高技术和协作能力&lt;span&gt;。&lt;span&gt;&lt;span&gt;在入职华为的第四个年头，我终于如愿拿到了部门编程大赛的冠军。之前的每一年也都会参加，其中两次抱大腿拿到了亚军，一次因为太忙弃权了。这一届终于带队拿到了冠军，了却了一桩心事。在此，对之前的参赛经验和感悟总结一下，做一个纪念。至于下一届？应该不会再参加了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、比赛报名阶段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      首先说说自己的感受，由于报名时是要确认队友的。而这里的队友不要求技术多精湛，但是一定要有责任心，也就是把这个比赛当回事。你忙的时候，他能帮你分担事情。你不忙的时候，大家可以一起讨论比赛算法和思路，互相勉励。有时候即使忙到很晚，但是作为一个团队，大家都没什么怨言。所以个人认为挑选队友是最最重要的事情。根据这几年的比赛经验来看，一个队伍要想拿到好成绩，真的不是一个高手带着一堆酱油就可以完成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、参赛事宜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一般组织者会把比赛队伍的队长拉到一个群里。群里往往会第一时间发出框架bug，赛程变更，比赛规则安排等等事宜。所以在群里的队长一定要第一时间把群里获取到的消息，通知给组内的成员。先不说队友能做什么，至少做起事情来可以胸中有成竹。很多人只管问下自己想要知道的事情，对于其他人交流的话题往往不太关心，这是个很大的失误。。(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )比如比赛开发进度有人快，有人慢，往往可以通过群里的交流信息得到一些思路或者是提前知道比赛bug信息等。所以就算是在群里打酱油的人，也请把酱油打满。这或许就是所谓的情报工作吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、代码编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    其实代码的算法并不是需要使用多么高效多么复杂的算法。但是一定要对整个的算法过程，在心中有一个思路。知道第一步做什么，第二步算什么，第三步解决什么，后续还需要做什么。比赛给的信息有什么，什么东西我们不能直接拿到，需要自己进行数据的生成。（如比赛地图的信息）。很多人往往在这一步就畏难而止步，其实大可不必。只要你写下第一行代码，后续的代码就可以渐渐的隐现出来，你需要做的就是一层层的拂去尘埃，看到潜意识中的算法思路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、算法思路的补齐&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这个阶段主要是核心算法已经大概完成。但是细节处理起来往往不尽如人意。大部分时间，参赛选手的基本算法其实都差不多，真正分出排名高低的原因就是这一步。而这一步又是最考验人耐心的阶段。需要队员主要是反复的测试model，也就是比赛官方提供的默认AI，不断的进行比赛，翻出查看录像解决问题。如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）为什么会死，死之前有没有出现重大失误。如果有的话迅速找出问题原因并且修复。如果没有重大失误是不是最初的基本算法思路就是有问题的。该怎么避免这种问题。重写还是优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）为什么会死的这么早，虽然说已经进入死胡同了，能不能用贪心思路多坚持一下，或许再坚持一下，往前边走就是柳暗花明了呢？千万不要这么早就放弃。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）为什么没有死，但是却输了比赛。是不是对分数的获取不够敏感。如何调整权重，如何能使优势最大化，甚至动态的调整策略权重。这些都对实战有重大的影响。当时我们在小组赛的时候输了一场。赛后反思原因，其中的一个重要原因是在下半场分数领先的情况下（而且是必胜的情况下）没有考虑上半场的分数落后了多少，从而出现了，明明可以赢，却输了的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     其它的思路还有很多，比如如何使代码跑的更快一点，虚拟机能否再优化下，内存会不会溢出，jvm会不会挂，如果抛出异常怎么办，如果处理异常时又有异常怎么办。如果自己的“棋子”两败俱伤，如何止损，达到伤害最小化，利益最大化。如果必死，如何玉石俱焚，使对手的伤害最大化。（oh my god 越想越多，想想自己当初的思路也是够疯狂的）总之这一步是整个比赛阶段拉开排名的重要环节。也就是查漏补缺阶段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、关于参赛事宜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       自己的感觉是队伍内部最好有多次参加比赛经验的队友。往往某些忽略的比赛细节，以及赛前需要注意的事情，都可能最终会影响到比赛的走势。还有编程大赛中可能会有一些灰度的事情，这些该如何应对。所以不要完全忽略掉代码以外的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、比赛情况安排&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在这届比赛中，我被项目组安排为其他小组的比赛裁判。所以一边在主持比赛，一边还要观察自己队伍的比赛情况（时间、地点、赛况等）。这里其实也是有重大失误的。虽然我赛前已经安排了队友去跟着观看比赛，以免有任何环境脚本等意外事故，但是比赛当时事情太多，完全无暇顾及。而我又是队长，队友完全不知道比赛的实际情况，导致很晚了，队友才给我打电话咨询比赛情况。幸好当时我们队伍所在组的裁判因为工作上的事情，开始比赛较晚，影响并不大，但是无论怎么样，这个错误很严重。关于这件事请看下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、比赛临场工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们队伍所在的小组是H组，但是H组的环境有问题，应该是使用jre较老，导致虚拟机始终拉不起我们编的jar包。当时我已经主持完其他小组的比赛，急匆匆的赶来。我一方面让队友排查脚本问题，一方面跟H组的裁判解释，因为根据比赛规程，如果比赛时初选类似问题，只可以修改启动脚本，不可以再修复代码包括编包。最终在我们的要求下换了一台电脑，我们提交的jar包终于可以正常运行了。当时真的是十万火急，如果不是对赛制的了解，再加上之前的比赛经验，很可能直接就弃权了。因为当时的比赛已经只剩下和我们队伍相关的比赛了。其他队伍都在等比赛结果，而H组的裁判又在死命的催，这种时候来自外界的声音往往比平常会更大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、注意心态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在小组循环赛中，我们队伍的程序是最后运行起来的。而H组是公认的死亡之组，观看其他队伍的比赛，感觉他们的算法很完善，而我们的程序却死活不能启动。在和队友陆续尝试各种方法未果，猜测可能是环境问题，要求换电脑，最终看到程序正常启动时，真的是欲哭无泪。在和裁判的解释过程中，双发也发生了矛盾，我反复解释我们的要求是满足赛制规则的。这一点赛后我觉得非常重要，正是因为站在满足比赛规则的基础上，你的所作所为才能被称之为合理。。(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )弃权和冠军真的是一念之差，如果当时就放弃比赛了，觉得是生成的jar的问题，觉得是代码的问题，如果当时没派人跟队冷静的分析原因，可能结果完全不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     另外一个让人啼笑皆非的事情是，程序正常启动后，我们第一场比赛就输了。就是我在前文算法思路补齐阶段所说的问题。当时没有想到是分数计算的原因，只觉得自己的程序指令出现了“死循环”了。操作的“棋子”在绕一个很大的圈，一圈圈的走。当时心想这还比个毛线啊。还好后续的比赛地图不会再出现一些“特殊”的地形，导致我们的算法在临界点的判断上可能互相影响，综合起来造成一些很奇怪的现象。最终在16强中，我们队伍与H组的第一再次相遇，凭借对手算法一次重大失误（也有人说是算法超时）最终赢得了比赛，剑指总冠军。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比赛所能想到的事情就是这些了，谢谢你，2017；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;谢谢你，我的队友们；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也谢谢你，我的对手们。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 16:13:00 +0000</pubDate>
<dc:creator>王若伊_恩赐解脱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jilodream/p/8362135.html</dc:identifier>
</item>
<item>
<title>libevent--快速入门 - 风起_Wake</title>
<link>http://www.cnblogs.com/pz-Feng/p/8362020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pz-Feng/p/8362020.html</guid>
<description>&lt;h2 id=&quot;一简介&quot;&gt;一．简介&lt;/h2&gt;
&lt;p&gt;libevent是一个c语言写的事件驱动库，轻量级，专注于网络，跨平台特性好，支持多种 I/O 多路复用．支持I/O,定时器和信号等事件，允许设置注册事件优先级．&lt;/p&gt;
&lt;h2 id=&quot;二基本使用场景和事件流程&quot;&gt;二．基本使用场景和事件流程&lt;/h2&gt;
&lt;h3 id=&quot;初始化事件根基槽&quot;&gt;(1)初始化事件根基（槽）&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *event_base_new(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *event_init(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;event_base_new()函数分配并且返回一个新的具有默认设置的event_base.&lt;/li&gt;
&lt;li&gt;event_init() 会调用event_base_new()创建一个event_base,并以此初始化一个全局的变量current_base .&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *base = event_init();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;初始化事件event设置回调函数和关注的事件并关联对应的事件根基槽event_base&quot;&gt;(2)初始化事件event，设置回调函数和关注的事件，并关联对应的事件根基（槽）event_base&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; (*event_callback_fn)(evutil_socket_t, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*);

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *event_new(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *, evutil_socket_t, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;, 
                        event_callback_fn, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *);

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; event_assign(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *, evutil_socket_t, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt;, event_callback_fn, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *);

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; event_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *ev, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; events, 
               event_callback_fn, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; event_base_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *,&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event*);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;event_assign（）的作用就是把给定的event类型对象的每一个成员赋予一个指定的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;event_new（）的实现其实是间接的调用的event_assign（），首先调用mm_malloc分配一块内存，然后调用event_assign来给event类型的对象各个成员赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;event_set()　使用指定的句柄、关注的事件、事件发生时的回调函数、回调函数的额外参数，初始化设置struct event结构对象，绑定到全局current_base，设置此event结构对象的优先级，默认为current_base中总有限级数的一半&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;event_base_set() 将事件绑定到事件根基,即设置event从属的event_base,指明event注册到哪个event_base实例上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;//SIGINT 信号事件初始化&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//假定已创建事件根基struct event_base *base　&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//方式一：&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event sigint_ev;
event_assign(&amp;amp;sigint_ev,base,SIGINT, EV_SIGNAL | EV_PERSIST,sigint_cb,NULL);
&lt;span class=&quot;co&quot;&gt;//方式二：&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event sigint_ev ;
event_set(&amp;amp;sigint_ev, SIGINT, EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);
event_base_set(base, &amp;amp;sigint_ev);
&lt;span class=&quot;co&quot;&gt;//方式三：&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *sigint_ev;
sigint_ev = event_new(base,SIGINT,EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);
&lt;span class=&quot;co&quot;&gt;//方式四：&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event* sigint_ev = (&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event*)malloc(&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event));
&lt;span class=&quot;co&quot;&gt;//sigint_ev检测非空和置零后，用event_assign 或者event_set + event_base_set 初始化事件．&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;定时器事件&quot;&gt;定时器事件：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define evtimer_set(ev, cb, arg)    event_set(ev, -1, 0, cb, arg)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;信号事件&quot;&gt;信号事件：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define evsignal_new(base,signum,cb,arg) \&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    event_new(base,signum,EV_SIGNAL|EV_PERSIST,cb,arg)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;添加事件将事件变成未决态即将event加入到event_base中等待监听&quot;&gt;(3)添加事件，将事件变成未决态，即，将event加入到event_base中，等待监听&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; event_add(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event* ,&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; timeval *);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;程序进入无限循环事件根基event_base开始工作对注册的event进行监听若注册的事件的对应事件类型触发或者超时会自动触发event对应的回调函数执行&quot;&gt;(4)程序进入无限循环，事件根基event_base开始工作，对注册的event进行监听．若注册的事件的对应事件类型触发，或者超时，会自动触发event对应的回调函数执行&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; event_base_dispatch(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; event_base_loop(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; );&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;三入门例子&quot;&gt;三．入门例子：&lt;/h2&gt;
&lt;h4 id=&quot;文件test.c&quot;&gt;文件：test.c&lt;/h4&gt;
&lt;h4 id=&quot;编译&quot;&gt;编译：&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;gcc -o test test.c -levent&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码：&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;89&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;malloc.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;event.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define BUF_SIZE 1024&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *ev;
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *buf;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; timeval *tv;
}rw_st;

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; wr_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg);
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; rd_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg);

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event_base *base = NULL;
&lt;span class=&quot;co&quot;&gt;//定时事件&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; timeval tv;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event time_ev;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; time_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg)
{
    printf(&lt;span class=&quot;st&quot;&gt;&quot;time_cb : 5s timer wakeup&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    event_add(&amp;amp;time_ev,&amp;amp;tv);
}

&lt;span class=&quot;co&quot;&gt;//标准输入 读事件&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//输入一行，把读事件删掉,添加写事件&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; rd_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd,&lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(event &amp;amp; EV_TIMEOUT){
        printf(&lt;span class=&quot;st&quot;&gt;&quot;io read time out(2s)!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ;
    }
    rw_st* rd_st = (rw_st*)arg;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = read(fd, rd_st-&amp;gt;buf, BUF_SIZE);
    rd_st-&amp;gt;buf[len&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;] = '\&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;';
    printf(&lt;span class=&quot;st&quot;&gt;&quot;rd_cb (stdin): %s &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,rd_st-&amp;gt;buf);
    
    event_del(rd_st-&amp;gt;ev);
    event_set(rd_st-&amp;gt;ev, STDOUT_FILENO,  EV_WRITE | EV_PERSIST,
                    wr_cb,(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)rd_st);
    event_add(rd_st-&amp;gt;ev,NULL);
}

&lt;span class=&quot;co&quot;&gt;//标准输出 写事件&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//输出,把写事件删掉,添加读事件,边写边读&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; wr_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg)
{
    rw_st *wr_st = (rw_st*)arg;
    printf(&lt;span class=&quot;st&quot;&gt;&quot;wr_cb (stdout): %s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,wr_st-&amp;gt;buf);
    memset(wr_st-&amp;gt;buf,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,BUF_SIZE);
    event_del(wr_st-&amp;gt;ev);
    event_set(wr_st-&amp;gt;ev, STDIN_FILENO, EV_READ | EV_PERSIST,
                    rd_cb, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)wr_st);
    event_add(wr_st-&amp;gt;ev,wr_st-&amp;gt;tv);
}

&lt;span class=&quot;co&quot;&gt;//SIGINT 信号事件&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sigint_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg)
{
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; timeval tv_1s = {&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    printf(&lt;span class=&quot;st&quot;&gt;&quot;SIGINT : EXIT IN 1s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    event_base_loopexit(base,&amp;amp;tv_1s);
}

&lt;span class=&quot;co&quot;&gt;//SIGHUB 信号事件&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; sighup_cb(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fd, &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; event, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *arg)
{
    printf(&lt;span class=&quot;st&quot;&gt;&quot;SIGHUP: EXIT AT ONCE&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    event_base_loopbreak(base);
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
    printf(&lt;span class=&quot;st&quot;&gt;&quot;pid = %ld&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,getpid());
    base = event_init();
    &lt;span class=&quot;co&quot;&gt;//定时器&lt;/span&gt;
    tv.tv_sec = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
    tv.tv_usec = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    evtimer_set(&amp;amp;time_ev, time_cb, NULL);&lt;span class=&quot;co&quot;&gt;//一次性,默认全局的current_base&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//　event_set(&amp;amp;time_ev,-1,0,time_cb,NULL);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//  event_base_set(base, &amp;amp;time_ev);  //可省，在这里current_base等同base&lt;/span&gt;
    event_add(&amp;amp;time_ev,&amp;amp;tv);

    &lt;span class=&quot;co&quot;&gt;//io 读事件  指针 event_new&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; timeval io_tv = {&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    rw_st *rd_st = (rw_st*)malloc(&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(rw_st));
    memset(rd_st,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(rw_st));

    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *io_ev = (&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event*)malloc(&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event));
    memset(io_ev,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event));
    
    rd_st-&amp;gt;ev = io_ev;
    rd_st-&amp;gt;buf = buf;
    rd_st-&amp;gt;tv = &amp;amp;io_tv;
    event_assign(rd_st-&amp;gt;ev,base,STDIN_FILENO,
                    EV_TIMEOUT | EV_READ | EV_PERSIST,rd_cb,(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)rd_st);
    event_add(rd_st-&amp;gt;ev,rd_st-&amp;gt;tv);

    &lt;span class=&quot;co&quot;&gt;//SIGINT 信号事件&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event sigint_ev;

    event_assign(&amp;amp;sigint_ev,base,SIGINT, EV_SIGNAL | EV_PERSIST,sigint_cb,NULL);
&lt;span class=&quot;co&quot;&gt;//  event_set(&amp;amp;sigint_ev, SIGINT, EV_SIGNAL | EV_PERSIST, &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//                                          sigint_cb, NULL);&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//event_base_set(base, &amp;amp;sigint_ev);&lt;/span&gt;
    event_add(&amp;amp;sigint_ev,NULL);
  
&lt;span class=&quot;co&quot;&gt;//  struct event *sigint_ev = event_new(base,SIGINT,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//           EV_SIGNAL | EV_PERSIST, sigint_cb, NULL);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//  event_add(sigint_ev,NULL);&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;//SIGHUP 信号事件  &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//测试: $ kill -SIGHUP pid&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; event *sighup_ev;
    sighup_ev = evsignal_new(base, SIGHUP, sighup_cb, NULL);    
    event_add(sighup_ev,NULL);

    event_base_dispatch(base);
    &lt;span class=&quot;co&quot;&gt;//event_base_loop(base,0);&lt;/span&gt;
    
    event_free(sighup_ev);
    event_base_free(base);
    free(rd_st);

    printf(&lt;span class=&quot;st&quot;&gt;&quot;EXIT&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;原创所有转载注明原文出处若有错误欢迎指正共同学习谢谢&quot;&gt;原创所有，转载注明原文出处．若有错误，欢迎指正，共同学习，谢谢！&lt;/h3&gt;
</description>
<pubDate>Fri, 26 Jan 2018 15:56:00 +0000</pubDate>
<dc:creator>风起_Wake</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pz-Feng/p/8362020.html</dc:identifier>
</item>
<item>
<title>Rootkit 核心技术——利用 nt!_MDL（内存描述符链表）突破 SSDT（系统服务描述符表）的只读访问限制 Part I - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8361964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8361964.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在 rootkit 与恶意软件开发中有一项基本需求，那就是 hook Windows 内核的系统服务描述符表（下称 SSDT），把该表中的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;特定系统服务函数替换成我们自己实现的恶意例程；当然，&lt;span&gt;为了确保系统能够正常运作，我们需要事先用一个函数指针保存原始&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的系统服务，并且在我们恶意例程的逻辑中调用这个函数指针，此后才能进行 hook，否则损坏的内核代码与数据结构将导致&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个 BugCheck（俗称的蓝屏）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;尽管 64 位 Windows 引入了像是 PatchGuard 的技术，实时监控关键的内核数据，包括但不限于 SSDT，IDT，GDT。。。等等，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;保证其完整性，但在 32 系统上修改 SSDT 是经常会遇到的场景，所以本文还是对此做出了介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OS 一般在系统初始化阶段把 SSDT 设定成&lt;span&gt;只读&lt;/span&gt;访问，这也是为了避免驱动与其它内核组件无意间改动到它；所以我们的首要任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是设法绕过这个只读属性。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;在此之前，先复习一下与 SSDT 相关的几个数据结构，并解释定位 SSDT 的过程。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们知道，每个线程的 _KTHREAD 结构中，偏移 0xbc 字节处是一枚叫做 ServiceTable 的泛型指针（亦即 PVOID 或 void*），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该字段指向一个全局的数据结构，叫做 KeServiceDescriptorTable，它就是 SSDT，SSDT 中首个字段又是一枚指针，指向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局的数据结构 KiServiceTable，&lt;span&gt;而后者是一个数组，其内的每个成员都是一枚函数指针，持有相应的系统服务例程入口地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的时候，用言语来描述内核的一些概念过于抽象和词穷，还是来看看下图吧，它很形象地展示了上述关系：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126222926522-1739045614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;根据上图我们有了思路：首先设法获取当前运行线程的 _KTHREAD 结构，然后即可逐步定位到 KiServiceTable，它就是我们最终&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hook 的对象！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;鉴于 ServiceTable 是一枚指针，持有另一枚指针 KeServiceDescriptorTable 的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（亦即“指向指针的指针”，往后我会不加以区分“持有”与“指向”术语），而 KiServiceTable 则是一个函数指针数组；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Rootkit 源码中，它们可以分别用三个全局变量（在驱动的入口点 DriverEntry() &lt;span&gt;之外&lt;/span&gt;声明 ）表示，如下图，我使用了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“自注释”的变量名，很易于理解；而且我把星号紧接类型保留字后面，避免与“解引”操作混淆（所以星号是一个重载的运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;符）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224251303-1789262683.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于内核模式驱动程序开发人员来讲，自己实现一个例程来获取当前运行线程的 _KTHREAD 结构显然并不轻松，幸运的是，文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;化的 &lt;/span&gt;&lt;span&gt;PsGetCurrentThread() 例程能够完成这一任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（事实上，PsGetCurrentThread()的反汇编代码恰恰说明了这很简单，如下代码，&lt;span&gt;仅仅&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只是把 fs:[00000124h] 地址处的内容移动到 eax 寄存器作为返回值，而且 KeGetCurrentThread() 的逻辑与它如出一撤！&lt;/span&gt; ）&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;kd&amp;gt; u PsGetCurrentThread
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; nt!&lt;span&gt;PsGetCurrentThread:&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 83c6cd19 64a124010000    &lt;span&gt;mov&lt;/span&gt;     eax,dword ptr &lt;span&gt;fs:&lt;/span&gt;&lt;span&gt;[00000124h]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 83c6cd1f c3              &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 83c6cd20 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 83c6cd21 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 83c6cd22 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 83c6cd23 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 83c6cd24 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; nt!&lt;span&gt;KeReadStateMutant:&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 83c6cd25 8bff            &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;     edi,edi
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;kd&amp;gt; u KeGetCurrentThread
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; nt!&lt;span&gt;PsGetCurrentThread:&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 83c6cd19 64a124010000    &lt;span&gt;mov&lt;/span&gt;     eax,dword ptr &lt;span&gt;fs:&lt;/span&gt;&lt;span&gt;[00000124h]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 83c6cd1f c3              &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 83c6cd20 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 83c6cd21 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 83c6cd22 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 83c6cd23 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 83c6cd24 &lt;span&gt;90&lt;/span&gt;              &lt;span&gt;nop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;老生常谈，fs 寄存器通常用来存放“段选择符”，“段选择符”用来索引 GDT 中的一个“段描述符”，后者有一个“段基址”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;属性，也就是 KPCR（Kernel Processor Control Region，内核处理器控制区域）结构（nt!_KPCR）的起始地址；nt!_KPCR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏移 0x120 字节处是一个 nt!_KPRCB 结构，后者偏移 0x4 字节处的“CurrentThread”字段就是一个 _KTHREAD 结构，每次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程切换都会更新该字段，这就是 fs:[00000124h] 简洁的背后隐藏的强大设计思想！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;注意，PsGetCurrentThread() 返回一枚指向 _ETHREAD 结构的指针（亦即“PETHREAD”，如你所见，微软喜欢在指针这一概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上大玩&lt;/span&gt;&lt;span&gt;“&lt;span&gt;头文字 P&lt;/span&gt;”游戏），而 _ETHREAD 结构的首个字段 Tcb 就是一个 _KTHREAD 实例——这意味着，我们无需计算额外的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏移量，只要&lt;/span&gt;&lt;span&gt;考虑那个 ServiceTable 的偏移量 0xbc 即可，如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126223940850-2057569699.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;而我们需要在这枚指针上执行加法运算，移动它到 ServiceTable 字段处，所以不能声明一个 PETHREAD 变量来存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PsGetCurrentThread() &lt;/span&gt;&lt;span&gt;的返回值，因为“指针加上数值 n ”会把指针当前持有的地址加上（ n * 该指针所指的数据类型大小 ）个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节—— 表达式 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; PETHREAD ethread_ptr += &lt;span&gt;0xbc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;实际上把起始地址加上了 &lt;strong&gt;0xbc * sizeof(ETHREAD)&lt;/strong&gt; 个字节&lt;/span&gt;，远远超出了我们的预期。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么办呢？好办，声明一个&lt;strong&gt;字节型&lt;/strong&gt;指针来保存 PsGetCurrentThread() 的返回值，同时把返回值强制转型为一致的即可！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此一来，表达式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BYTE* byte_ptr += &lt;span&gt;0xbc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;就是把起始地址加上 &lt;strong&gt;0xbc * sizeof(BYTE)&lt;/strong&gt; 个字节&lt;/span&gt;，符合我们的预期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，这要求我们添加相关的类型定义，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224210365-1376951978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这表明 BYTE 与 无符号字符型等价（还等于微软自家的 UCHAR），大小都是单字节；DWORD 则与无符号长整型等价，大小都是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四字节——&lt;/span&gt;&lt;span&gt;我们用一个 DWORD 变量存储数组 KiServiceTable 的地址。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来就是通过一系列的&lt;span&gt;指针转型和解引操作&lt;/span&gt;，定位到 KiServiceTable 的过程，再次凸显了指针在 C 编程中的地位，无论是应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;还是内核。。。。。经过如下图的赋值运算，最终，全局变量 os_ki_service_table 持有了 KiServiceTable 的地址。注意，除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;了那&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;偏移量的宏定义外，所有的运算都在我们的驱动入口例程 DriverEntry() 中完成，而且为了支持动态卸载，我注册了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unload() 回&lt;/span&gt;&lt;span&gt;调，&lt;/span&gt;&lt;span&gt;稍后你会看到 Unload() 的内部实现——大致就是卸载时取消对 KiServiceTable 的写权限映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224520147-441321543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了验证定位 KiServiceTable 过程的准确性，我添加了下列打印输出语句，注意，DbgPrint() 的输出需要在被调试机器上以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DbgView.exe 查看；抑或直接输出到调试机器上的 windbg.exe/kd.exe 屏幕上：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224652569-885873950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合上图，在调试器中进行验证——“dd”命令可以按双字（四字节）显示给定虚拟内存地址处的内容；“dps”命令可以按照函&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数符号&lt;/span&gt;&lt;span&gt;显示从给定内存地址开始的例程地址——它就是专为函数指针数组（例如 KiServiceTable）设计的，如下图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224746647-153827286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，KiServiceTable 可以经由全局变量 os_ki_service_table 以只读形式访问，在我们 hook 它之前，需要设法更改为可写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看尝试向只读的 KiServiceTable 写入时会发生什么事情，如下图所示，我通过 RtlFillMemory() 试图向 KiServiceTable&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;持有的第一个四字节（亦即系统服务 &lt;span&gt;nt!NtAcceptConnectPort&lt;/span&gt; ）填充 4 个 ASCII 字符“A”：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126224907584-2118495130.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意，RtlFillMemory() 的第一个参数是一个指针，指向要被填充的内存块，后面二个参数分别是填充的长度与数据；由于我们的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量 os_ki_service_table 是 &lt;span&gt;DWORD 型&lt;/span&gt;，所以我把它强制转型为匹配的指针，再作为实参传入。。。。重新构建驱动，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放入以调试模式运行的虚拟机中加载，宿主机中发生的情况如下图所示，假设我们编译好的 rootkit 名称为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UseMdlMappingSSDT.sys ，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图中表明出现一个致命系统错误，代码为 0x000000BE，圆括号里边是携带错误信息的四个参数，在故障排查时会用到它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，这就是一个 BugCheck，当错误检查发生时，如果目标系统连接着宿主机上的调试器，就断入调试器，&lt;span&gt;否则目标系统&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上将执行 KeBugCheckEx() 例程，后者会屏蔽掉所有处理器核上的中断事件，然后将显示器切换到低分辩率的 VGA 图形模式下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绘制一个蓝色背景，然后向用户显示 “检查结果” 对应的停机代码。这就是“蓝屏”的由来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225214381-729772399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在此场景中，我们得到一个 0x000000BE 的停机代码，将其作为关键字串搜索 MSDN 文档，给出的描述如下图：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225240865-494102246.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;官方讲解的很清楚：0x000000BE（ATTEMPTED_WRITE_TO_READONLY_MEMORY）停机代码是由于驱动程序尝试向一个只读&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;的内存段写入导致的；第一个参数是试图写入的虚拟地址，第二个参数是描述该虚拟地址所在虚拟页-物理页的 PTE（页表项）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内容；后面两个参数为保留未来扩展使用，所以被我截断了。结合前面一张图我们知道，尝试写入的虚拟地址为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0x83CAFF7C，描述映射它的物理页的 PTE 内容是 0x03CAF121，后面两个参数就目前而言可以忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示，0x83CAFF7C 就是 KiServiceTable 的起始地址；&lt;span&gt;描述它的 PTE 经解码后的标志部分有一个“R”属性，表示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只读&lt;/span&gt;；BugCheck 时刻的栈回溯信息显示，内核中通用的异常处理程序 MmAccessFault() 负责处理与内存访问相关的错误，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是一个前端解析例程，如果异常或错误能够处理，它就分发至实际的处理函数，否则，它调用 KeBugCheck*() 系列函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该家族函数会根据调试器的存在与否作出决定——要么调用 KiBugCheckDebugBreak() 断入调试器；要么执行如前文所述的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程来绘制蓝屏：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225407303-1474115984.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;————————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此确定了 BugCheck 是由于在驱动中调用 RtlFillMemory() 写入只读的内核内存引发的。另一个更强大的调试器扩展命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“!analyze -v”可以输出详细的信息，包括 BugCheck “现场”的指令地址和寄存器状态，如下图所示，导致 BugCheck 的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指令地址为 0x9ff990b4，&lt;span&gt;该指令把 eax 寄存器的当前值（0x41414141，亦即我们调用 RtlFillMemory() 传入的 4 个 ASCII 字&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;符“A”）&lt;/span&gt;&lt;span&gt;&lt;span&gt;写入 ecx 寄存器持有的内存地址处，试图把 nt!NtAcceptConnectPort() 的入口点地址替换成 0x41414141&lt;/span&gt; ；另外它会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给出&lt;/span&gt;&lt;span&gt;驱动源码中对应的行号——也就是第 137 行的 RtlFillMemory() 调用：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201801/1318637-20180126225539022-1351949022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如你所见，微软 C/C++ 编译器（cl.exe）把 RtlFillMemory() 内联在它的调用者内部，换言之，尽管有公开的文档描述它的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值，参数。。。。具体的实现还是由编译器说了算——&lt;strong&gt;为了性能优化，RtlFillMemory() 直接实现为一条简洁的数据移动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;指令，相关的参数由寄存器传递，没有因函数调用创建与销毁栈帧带来的额外开销！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到目前为止，尽管我们通过一系列步骤从 _KTHREAD 定位到了系统服务指针表，但以常规手段却无法 hook 其中的系统服务函&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数，因为&lt;/span&gt;&lt;span&gt;它是只读的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下一篇文章我将讨论如何使用 MDL（Memory Descriptor List，内存描述符链表）来绕过这种限制，随心所欲地读写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KiServiceTable！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jan 2018 15:11:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8361964.html</dc:identifier>
</item>
<item>
<title>Java数据结构和算法（十三）——哈希表 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8032656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8032656.html</guid>
<description>&lt;p&gt;　　Hash表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。&lt;/p&gt;
&lt;p&gt;　　注意，这里有个重要的问题就是如何把关键字转换为数组的下标，这个转换的函数称为哈希函数（也称散列函数），转换的过程称为哈希化。&lt;/p&gt;
&lt;h3&gt;1、哈希函数的引入&lt;/h3&gt;
&lt;p&gt;　　大家都用过字典，字典的优点是我们可以通过前面的目录快速定位到所要查找的单词。如果我们想把一本英文字典的每个单词，从 a 到 zyzzyva(这是牛津字典的最后一个单词)，都写入计算机内存，以便快速读写，那么哈希表是个不错的选择。&lt;/p&gt;
&lt;p&gt;　　这里我们将范围缩小点，比如想在内存中存储5000个英文单词。我们可能想到每个单词会占用一个数组单元，那么数组的大小是5000，同时可以用数组下标存取单词，这样设想很完美，但是数组下标和单词怎么建立联系呢？&lt;/p&gt;
&lt;p&gt;　　首先我们要建立单词和数字（数组下标）的关系：&lt;/p&gt;
&lt;p&gt;　　我们知道 ASCII 是一种编码，其中 a 表示97，b表示98，以此类推，一直到122表示z，而每个单词都是由这26个字母组成，我们可以不用 ASCII 编码那么大的数字，自己设计一套类似 ASCII的编码，比如a表示1，b表示2，依次类推，z表示26，那么表示方法我们就知道了。&lt;/p&gt;
&lt;p&gt;　　接下来如何把单个字母的数字组合成代表整个单词的数字呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、把数字相加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先第一种简单的方法就是把单词的每个字母表示的数字相加，得到的和便是数组的下标。&lt;/p&gt;
&lt;p&gt;　　比如单词 cats 转换成数字：&lt;/p&gt;
&lt;p&gt;　　cats = 3 + 1 + 20 + 19 = 43&lt;/p&gt;
&lt;p&gt;　　那么单词 cats 存储在数组中的下标为43，所有的英文单词都可以用这个办法转换成数组下标。但是这个办法真的可行吗？&lt;/p&gt;
&lt;p&gt;　　假设我们约定一个单词最多有 10 个字母，那么字典的最后一个单词为 zzzzzzzzzz ，其转换为数字：&lt;/p&gt;
&lt;p&gt;　　zzzzzzzzzz = 26*10 = 260&lt;/p&gt;
&lt;p&gt;　　那么我们可以得到单词编码的范围是从1-260。很显然，这个范围是不够存储5000个单词的，那么肯定有一个位置存储了多个单词，每个数组的数据项平均要存储192个单词（5000除以260）。&lt;/p&gt;
&lt;p&gt;　　对于上面的问题，我们如何解决呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第一种方法：&lt;/strong&gt;考虑每个数组项包含一个子数组或者一个子链表，这个办法存数据项确实很快，但是如果我们想要从192个单词中查找到其中一个，那么还是很慢。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第二种方法：&lt;/strong&gt;为啥要让那么多单词占据同一个数据项呢？也就是说我们没有把单词分的足够开，数组能表示的元素太少，我们需要扩展数组的下标，使其每个位置都只存放一个单词。&lt;/p&gt;
&lt;p&gt;　　对于上面的第二种方法，问题产生了，我们如何扩展数组的下标呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、幂的连乘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们将单词表示的数拆成数列，用适当的 27 的幂乘以这些位数（因为有26个可能的字符，以及空格，一共27个），然后把乘积相加，这样就得出了每个单词独一无二的数字。&lt;/p&gt;
&lt;p&gt;　　比如把单词cats 转换为数字：&lt;/p&gt;
&lt;p&gt;　　cats = 3*27&lt;sup&gt;3&lt;/sup&gt; + 1*27&lt;sup&gt;2&lt;/sup&gt; + 20*27&lt;sup&gt;1&lt;/sup&gt; + 19*27&lt;sup&gt;0&lt;/sup&gt; = 59049 + 729 + 540 + 19 = 60337&lt;/p&gt;
&lt;p&gt;　　这个过程会为每个单词创建一个独一无二的数，但是注意的是我们这里只是计算了 4 个字母组成的单词，如果单词很长，比如最长的10个字母的单词 zzzzzzzzzz，仅仅是27&lt;sup&gt;9&lt;/sup&gt; 结果就超出了7000000000000，这个结果是很巨大的，在实际内存中，根本不可能为一个数组分配这么大的空间。&lt;/p&gt;
&lt;p&gt;　　所以这个方案的问题就是虽然为每个单词都分配了独一无二的下标，但是只有一小部分存放了单词，很大一部分都是空着的。那么现在就需要一种方法，把数位幂的连乘系统中得到的巨大的整数范围压缩到可接受的数组范围中。&lt;/p&gt;
&lt;p&gt;　　对于英语字典，假设只有5000个单词，这里我们选定容量为10000 的数组空间来存放（后面会介绍为啥需要多出一倍的空间）。那么我们就需要将从 0 到超过 7000000000000 的范围，压缩到从0到10000的范围。&lt;/p&gt;
&lt;p&gt;　　第一种方法：取余，得到一个数被另一个整数除后的余数。首先我们假设要把从0-199的数字（用largeNumber表示），压缩为从0-9的数字（用smallNumber表示），后者有10个数，所以变量smallRange 的值为10，这个转换的表达式为：&lt;/p&gt;
&lt;p&gt;　　smallNumber = largeNumber % smallRange&lt;/p&gt;
&lt;p&gt;　　当一个数被 10 整除时，余数一定在0-9之间，这样，我们就把从0-199的数压缩为从0-9的数，压缩率为 20 :1。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180106221144471-1865375569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们也可以用类似的方法把表示单词唯一的数压缩成数组的下标：&lt;/p&gt;
&lt;p&gt;　　arrayIndex = largerNumber % smallRange&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这也就是哈希函数。它把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2、冲突&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;把巨大的数字范围压缩到较小的数字范围，那么肯定会有几个不同的单词哈希化到同一个数组下标，即产生了&lt;strong&gt;冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　冲突可能会导致哈希化方案无法实施，前面我们说指定的数组范围大小是实际存储数据的两倍，因此可能有一半的空间是空着的，所以，当冲突产生时，一个方法是通过系统的方法找到数组的一个空位，并把这个单词填入，而不再用哈希函数得到数组的下标，这种方法称为开放地址法。比如加入单词 cats 哈希化的结果为5421，但是它的位置已经被单词parsnip占用了，那么我们会考虑将单词 cats 存放在parsnip后面的一个位置 5422 上。&lt;/p&gt;
&lt;p&gt;　　另一种方法，前面我们也提到过，就是数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中，这种方法称为链地址法。&lt;/p&gt;
&lt;h3&gt;3、开放地址法&lt;/h3&gt;
&lt;p&gt;　　开发地址法中，若数据项不能直接存放在由哈希函数所计算出来的数组下标时，就要寻找其他的位置。分别有三种方法：线性探测、二次探测以及再哈希法。&lt;/p&gt;
&lt;h4&gt;　　①、线性探测&lt;/h4&gt;
&lt;p&gt;　　在线性探测中，它会线性的查找空白单元。比如如果 5421 是要插入数据的位置，但是它已经被占用了，那么就使用5422，如果5422也被占用了，那么使用5423，以此类推，数组下标依次递增，直到找到空白的位置。这就叫做线性探测，因为它沿着数组下标一步一步顺序的查找空白单元。&lt;/p&gt;
&lt;p&gt;　　完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class MyHashTable {
        private DataItem[] hashArray;   //DataItem类，表示每个数据项信息
        private int arraySize;//数组的初始大小
        private int itemNum;//数组实际存储了多少项数据
        private DataItem nonItem;//用于删除数据项
        
        public MyHashTable(int arraySize){
                this.arraySize = arraySize;
                hashArray = new DataItem[arraySize];
                nonItem = new DataItem(-1);//删除的数据项下标为-1
        }
        //判断数组是否存储满了
        public boolean isFull(){
                return (itemNum == arraySize);
        }
        
        //判断数组是否为空
        public boolean isEmpty(){
                return (itemNum == 0);
        }
        
        //打印数组内容
        public void display(){
                System.out.println(&quot;Table:&quot;);
                for(int j = 0 ; j &amp;lt; arraySize ; j++){
                        if(hashArray[j] != null){
                                System.out.print(hashArray[j].getKey() + &quot; &quot;);
                        }else{
                                System.out.print(&quot;** &quot;);
                        }
                }
        }
        //通过哈希函数转换得到数组下标
        public int hashFunction(int key){
                return key%arraySize;
        }
        
        //插入数据项
        public void insert(DataItem item){
                if(isFull()){
                        //扩展哈希表
                        System.out.println(&quot;哈希表已满，重新哈希化...&quot;);
                        extendHashTable();
                }
                int key = item.getKey();
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null &amp;amp;&amp;amp; hashArray[hashVal].getKey() != -1){
                        ++hashVal;
                        hashVal %= arraySize;
                }
                hashArray[hashVal] = item;
                itemNum++;
        }
        /**
         * 数组有固定的大小，而且不能扩展，所以扩展哈希表只能另外创建一个更大的数组，然后把旧数组中的数据插到新的数组中。
         * 但是哈希表是根据数组大小计算给定数据的位置的，所以这些数据项不能再放在新数组中和老数组相同的位置上。
         * 因此不能直接拷贝，需要按顺序遍历老数组，并使用insert方法向新数组中插入每个数据项。
         * 这个过程叫做重新哈希化。这是一个耗时的过程，但如果数组要进行扩展，这个过程是必须的。
         */
        public void extendHashTable(){
                int num = arraySize;
                itemNum = 0;//重新计数，因为下面要把原来的数据转移到新的扩张的数组中
                arraySize *= 2;//数组大小翻倍
                DataItem[] oldHashArray = hashArray;
                hashArray = new DataItem[arraySize];
                for(int i = 0 ; i &amp;lt; num ; i++){
                        insert(oldHashArray[i]);
                }
        }
        
        //删除数据项
        public DataItem delete(int key){
                if(isEmpty()){
                        System.out.println(&quot;Hash Table is Empty!&quot;);
                        return null;
                }
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                DataItem temp = hashArray[hashVal];
                                hashArray[hashVal] = nonItem;//nonItem表示空Item,其key为-1
                                itemNum--;
                                return temp;
                        }
                        ++hashVal;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        //查找数据项
        public DataItem find(int key){
                int hashVal = hashFunction(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                return hashArray[hashVal];
                        }
                        ++hashVal;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        public static class DataItem{
                private int iData;
                public DataItem(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的是，当哈希表变得太满时，我们需要扩展数组，但是需要注意的是，数据项不能放到新数组中和老数组相同的位置，而是要根据数组大小重新计算插入位置。这是一个比较耗时的过程，所以一般我们要确定数据的范围，给定好数组的大小，而不再扩容。&lt;/p&gt;
&lt;p&gt;　　另外，当哈希表变得比较满时，我们每插入一个新的数据，都要频繁的探测插入位置，因为可能很多位置都被前面插入的数据所占用了，这称为聚集。数组填的越满，聚集越可能发生。&lt;/p&gt;
&lt;p&gt;　　这就像人群，当某个人在商场晕倒时，人群就会慢慢聚集。最初的人群聚过来是因为看到了那个倒下的人，而后面聚过来的人是因为它们想知道这些人聚在一起看什么。人群聚集的越大，吸引的人就会越多。&lt;/p&gt;
&lt;h4&gt;　　②、装填因子&lt;/h4&gt;
&lt;p&gt;　　已填入哈希表的数据项和表长的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 2/3。当装填因子不太大时，聚集分布的比较连贯，而装填因子比较大时，则聚集发生的很大了。&lt;/p&gt;
&lt;p&gt;　　我们知道线性探测是一步一步的往后面探测，当装填因子比较大时，会频繁的产生聚集，那么如果我们探测比较大的单元，而不是一步一步的探测呢，这就是下面要讲的二次探测。&lt;/p&gt;
&lt;h4&gt;　　③、二次探测&lt;/h4&gt;
&lt;p&gt; 　　二测探测是防止聚集产生的一种方式，思想是探测相距较远的单元，而不是和原始位置相邻的单元。&lt;/p&gt;
&lt;p&gt;　　线性探测中，如果哈希函数计算的原始下标是x, 线性探测就是x+1, x+2, x+3, 以此类推；而在二次探测中，探测的过程是x+1, x+4, x+9, x+16，以此类推，到原始位置的距离是步数的平方。二次探测虽然消除了原始的聚集问题，但是产生了另一种更细的聚集问题，叫二次聚集：比如讲184，302，420和544依次插入表中，它们的映射都是7，那么302需要以1为步长探测，420需要以4为步长探测， 544需要以9为步长探测。只要有一项其关键字映射到7，就需要更长步长的探测，这个现象叫做二次聚集。二次聚集不是一个严重的问题，但是二次探测不会经常使用，因为还有好的解决方法，比如再哈希法。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180107104018674-1008018949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;　　④、再哈希法&lt;/h4&gt;
&lt;p&gt;　　为了消除原始聚集和二次聚集，我们使用另外一种方法：再哈希法。&lt;/p&gt;
&lt;p&gt;　　我们知道二次聚集的原因是，二测探测的算法产生的探测序列步长总是固定的：1,4，9,16以此类推。那么我们想到的是需要产生一种依赖关键字的探测序列，而不是每个关键字都一样，那么，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。&lt;/p&gt;
&lt;p&gt;　　方法是把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长。对于指定的关键字，步长在整个探测中是不变的，不过不同的关键字使用不同的步长。&lt;/p&gt;
&lt;p&gt;　　第二个哈希函数必须具备如下特点：&lt;/p&gt;
&lt;p&gt;　　一、和第一个哈希函数不同&lt;/p&gt;
&lt;p&gt;　　二、不能输出0（否则，将没有步长，每次探测都是原地踏步，算法将陷入死循环）。&lt;/p&gt;
&lt;p&gt;　　专家们已经发现下面形式的哈希函数工作的非常好：stepSize = constant - key % constant; 其中constant是质数，且小于数组容量。&lt;br/&gt;　　再哈希法要求表的容量是一个质数，假如表长度为15(0-14)，非质数，有一个特定关键字映射到0，步长为5，则探测序列是0,5,10,0,5,10,以此类推一直循环下去。算法只尝试这三个单元，所以不可能找到某些空白单元，最终算法导致崩溃。如果数组容量为13, 质数，探测序列最终会访问所有单元。即0,5,10,2,7,12,4,9,1,6,11,3,一直下去，只要表中有一个空位，就可以探测到它。&lt;/p&gt;
&lt;p&gt;　　完整再哈希法代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class HashDouble {
        private DataItem[] hashArray;   //DataItem类，表示每个数据项信息
        private int arraySize;//数组的初始大小
        private int itemNum;//数组实际存储了多少项数据
        private DataItem nonItem;//用于删除数据项
        
        public HashDouble(){
                this.arraySize = 13;
                hashArray = new DataItem[arraySize];
                nonItem = new DataItem(-1);//删除的数据项下标为-1
        }
        //判断数组是否存储满了
        public boolean isFull(){
                return (itemNum == arraySize);
        }
        
        //判断数组是否为空
        public boolean isEmpty(){
                return (itemNum == 0);
        }
        
        //打印数组内容
        public void display(){
                System.out.println(&quot;Table:&quot;);
                for(int j = 0 ; j &amp;lt; arraySize ; j++){
                        if(hashArray[j] != null){
                                System.out.print(hashArray[j].getKey() + &quot; &quot;);
                        }else{
                                System.out.print(&quot;** &quot;);
                        }
                }
        }
        //通过哈希函数转换得到数组下标
        public int hashFunction1(int key){
                return key%arraySize;
        }
        
        public int hashFunction2(int key){
                return 5 - key%5;
        }
        
        //插入数据项
        public void insert(DataItem item){
                if(isFull()){
                        //扩展哈希表
                        System.out.println(&quot;哈希表已满，重新哈希化...&quot;);
                        extendHashTable();
                }
                int key = item.getKey();
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);//用第二个哈希函数计算探测步数
                while(hashArray[hashVal] != null &amp;amp;&amp;amp; hashArray[hashVal].getKey() != -1){
                        hashVal += stepSize;
                        hashVal %= arraySize;//以指定的步数向后探测
                }
                hashArray[hashVal] = item;
                itemNum++;
        }

        /**
         * 数组有固定的大小，而且不能扩展，所以扩展哈希表只能另外创建一个更大的数组，然后把旧数组中的数据插到新的数组中。
         * 但是哈希表是根据数组大小计算给定数据的位置的，所以这些数据项不能再放在新数组中和老数组相同的位置上。
         * 因此不能直接拷贝，需要按顺序遍历老数组，并使用insert方法向新数组中插入每个数据项。
         * 这个过程叫做重新哈希化。这是一个耗时的过程，但如果数组要进行扩展，这个过程是必须的。
         */
        public void extendHashTable(){
                int num = arraySize;
                itemNum = 0;//重新计数，因为下面要把原来的数据转移到新的扩张的数组中
                arraySize *= 2;//数组大小翻倍
                DataItem[] oldHashArray = hashArray;
                hashArray = new DataItem[arraySize];
                for(int i = 0 ; i &amp;lt; num ; i++){
                        insert(oldHashArray[i]);
                }
        }
        
        //删除数据项
        public DataItem delete(int key){
                if(isEmpty()){
                        System.out.println(&quot;Hash Table is Empty!&quot;);
                        return null;
                }
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                DataItem temp = hashArray[hashVal];
                                hashArray[hashVal] = nonItem;//nonItem表示空Item,其key为-1
                                itemNum--;
                                return temp;
                        }
                        hashVal += stepSize;
                        hashVal %= arraySize;
                }
                return null;
        }
        
        //查找数据项
        public DataItem find(int key){
                int hashVal = hashFunction1(key);
                int stepSize = hashFunction2(key);
                while(hashArray[hashVal] != null){
                        if(hashArray[hashVal].getKey() == key){
                                return hashArray[hashVal];
                        }
                        hashVal += stepSize;
                        hashVal %= arraySize;
                }
                return null;
        }
        public static class DataItem{
                private int iData;
                public DataItem(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、链地址法&lt;/h3&gt;
&lt;p&gt;　　在开放地址法中，通过再哈希法寻找一个空位解决冲突问题，另一个方法是在哈希表每个单元中设置链表（即链地址法），某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这个位置的数据项只需要加到链表中，不需要在原始的数组中寻找空位。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180107112426424-1731209796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有序链表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

public class SortLink {
        private LinkNode first;
        public SortLink(){
                first = null;
        }
        public boolean isEmpty(){
                return (first == null);
        }
        public void insert(LinkNode node){
                int key = node.getKey();
                LinkNode previous = null;
                LinkNode current = first;
                while(current != null &amp;amp;&amp;amp; current.getKey() &amp;lt; key){
                        previous = current;
                        current = current.next;
                }
                if(previous == null){
                        first = node;
                }else{
                        node.next = current;
                        previous.next = node;
                }
        }
        public void delete(int key){
                LinkNode previous = null;
                LinkNode current = first;
                if(isEmpty()){
                        System.out.println(&quot;Linked is Empty!!!&quot;);
                        return;
                }
                while(current != null &amp;amp;&amp;amp; current.getKey() != key){
                        previous = current;
                        current = current.next;
                }
                if(previous == null){
                        first = first.next;
                }else{
                        previous.next = current.next;
                }
        }
        
        public LinkNode find(int key){
                LinkNode current = first;
                while(current != null &amp;amp;&amp;amp; current.getKey() &amp;lt;= key){
                        if(current.getKey() == key){
                                return current;
                        }
                }
                return null;
        }
        
        public void displayLink(){
                System.out.println(&quot;Link(First-&amp;gt;Last)&quot;);
                LinkNode current = first;
                while(current != null){
                        current.displayLink();
                        current = current.next;
                }
                System.out.println(&quot;&quot;);
        }
        class LinkNode{
                private int iData;
                public LinkNode next;
                public LinkNode(int iData){
                        this.iData = iData;
                }
                public int getKey(){
                        return iData;
                }
                public void displayLink(){
                        System.out.println(iData + &quot; &quot;);
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　链地址法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
package com.ys.hash;

import com.ys.hash.SortLink.LinkNode;

public class HashChain {
        private SortLink[] hashArray;//数组中存放链表
        private int arraySize;
        public HashChain(int size){
                arraySize = size;
                hashArray = new SortLink[arraySize];
                //new 出每个空链表初始化数组
                for(int i = 0 ; i &amp;lt; arraySize ; i++){
                        hashArray[i] = new SortLink();
                }
        }
        
        public void displayTable(){
                for(int i = 0 ; i &amp;lt; arraySize ; i++){
                        System.out.print(i + &quot;：&quot;);
                        hashArray[i].displayLink();
                }
        }
        
        public int hashFunction(int key){
                return key%arraySize;
        }
        
        public void insert(LinkNode node){
                int key = node.getKey();
                int hashVal = hashFunction(key);
                hashArray[hashVal].insert(node);//直接往链表中添加即可
        }
        
        public LinkNode delete(int key){
                int hashVal = hashFunction(key);
                LinkNode temp = find(key);
                hashArray[hashVal].delete(key);//从链表中找到要删除的数据项，直接删除
                return temp;
        }
        
        public LinkNode find(int key){
                int hashVal = hashFunction(key);
                LinkNode node = hashArray[hashVal].find(key);
                return node;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　链地址法中，装填因子（数据项数和哈希表容量的比值）与开放地址法不同，在链地址法中，需要有N个单元的数组中转入N个或更多的数据项，因此装填因子一般为1，或比1大（有可能某些位置包含的链表中包含两个或两个以上的数据项）。&lt;/p&gt;
&lt;p&gt;　　找到初始单元需要O(1)的时间级别，而搜索链表的时间与M成正比，M为链表包含的平均项数，即O(M)的时间级别。&lt;/p&gt;
&lt;h3&gt;5、桶&lt;/h3&gt;
&lt;p&gt;　　另外一种方法类似于链地址法，它是在每个数据项中使用子数组，而不是链表。这样的数组称为桶。&lt;/p&gt;
&lt;p&gt;　　这个方法显然不如链表有效，因为桶的容量不好选择，如果容量太小，可能回溢出，如果太大，又造成性能浪费，而链表是动态分配的，不存在此问题。所以一般不使用桶。&lt;/p&gt;
&lt;h3&gt;6、总结 &lt;/h3&gt;
&lt;p&gt;　　哈希表基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。用来解决冲突的有两种方法：开放地址法和链地址法。在开发地址法中，把冲突的数据项放在数组的其它位置；在链地址法中，每个单元都包含一个链表，把所有映射到同一数组下标的数据项都插入到这个链表中。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 14:56:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8032656.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——26. 不要使用原始类型 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8361867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8361867.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自Java 5以来，泛型已经成为该语言的一部分。 在泛型之前，你必须转换从集合中读取的每个对象。 如果有人不小心插入了错误类型的对象，则在运行时可能会失败。 使用泛型，你告诉编译器在每个集合中允许哪些类型的对象。 编译器会自动插入强制转换，并在编译时告诉你是否尝试插入错误类型的对象。 这样做的结果是既安全又清晰的程序，但这些益处，不限于集合，是有代价的。 本章告诉你如何最大限度地提高益处，并将并发症降至最低。&lt;/p&gt;

&lt;p&gt;首先，有几个术语。一个类或接口，它的声明有一个或多个类型参数（ type parameters ），被称之为泛型类或泛型接口[JLS，8.1.2,9.1.2]。 例如，List接口具有单个类型参数E，表示其元素类型。 接口的全名是&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;（读作“E”的列表），但是人们经常称它为List。 泛型类和接口统称为泛型类型（generic types）。&lt;/p&gt;
&lt;p&gt;每个泛型定义了一组参数化类型（parameterized types），它们由类或接口名称组成，后跟一个与泛型类型的形式类型参数[JLS，4.4,4.5]相对应的实际类型参数的尖括号“&amp;lt;&amp;gt;”列表。 例如，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;（读作“字符串列表”）是一个参数化类型，表示其元素类型为String的列表。 （String是与形式类型参数E相对应的实际类型参数）。&lt;/p&gt;
&lt;p&gt;最后，每个泛型定义了一个原始类型（ raw type），它是没有任何类型参数的泛型类型的名称[JLS，4.8]。 例如，对应于&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;的原始类型是List。 原始类型的行为就像所有的泛型类型信息都从类型声明中被清除一样。 它们的存在主要是为了与没有泛型之前的代码相兼容。&lt;/p&gt;
&lt;p&gt;在泛型被添加到Java之前，这是一个典型的集合声明。 从Java 9开始，它仍然是合法的，但并不是典型的声明方式了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Raw collection type - don't do this!

// My stamp collection. Contains only Stamp instances.
private final Collection stamps = ... ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你今天使用这个声明，然后不小心把coin实例放入你的stamp集合中，错误的插入编译和运行没有错误（尽管编译器发出一个模糊的警告）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Erroneous insertion of coin into stamp collection
stamps.add(new Coin( ... )); // Emits &quot;unchecked call&quot; warning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直到您尝试从stamp集合中检索coin实例时才会发生错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Raw iterator type - don't do this!
for (Iterator i = stamps.iterator(); i.hasNext(); )
    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException
        stamp.cancel();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如本书所提到的，在编译完成之后尽快发现错误是值得的，理想情况是在编译时。 在这种情况下，直到运行时才发现错误，在错误发生后的很长一段时间，以及可能远离包含错误的代码的代码中。 一旦看到ClassCastException，就必须搜索代码类库，查找将coin实例放入stamp集合的方法调用。 编译器不能帮助你，因为它不能理解那个说“仅包含stamp实例”的注释。&lt;/p&gt;
&lt;p&gt;对于泛型，类型声明包含的信息，而不是注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Parameterized collection type - typesafe
private final Collection&amp;lt;Stamp&amp;gt; stamps = ... ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个声明中，编译器知道stamps集合应该只包含Stamp实例，并保证它是true，假设你的整个代码类库编译时不发出（或者抑制;参见条目27）任何警告。 当使用参数化类型声明声明stamps时，错误的插入会生成一个编译时错误消息，告诉你到底发生了什么错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:9: error: incompatible types: Coin cannot be converted
to Stamp
    c.add(new Coin());
              ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当从集合中检索元素时，编译器会为你插入不可见的强制转换，并保证它们不会失败（再假设你的所有代码都不会生成或禁止任何编译器警告）。 虽然意外地将coin实例插入stamp集合的预期可能看起来很牵强，但这个问题是真实的。 例如，很容易想象将&lt;code&gt;BigInteger&lt;/code&gt;放入一个只包含&lt;code&gt;BigDecimal&lt;/code&gt;实例的集合中。&lt;/p&gt;
&lt;p&gt;如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你不应该这样做。 &lt;strong&gt;如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势&lt;/strong&gt;。 鉴于你不应该使用它们，为什么语言设计者首先允许原始类型呢？ 答案是为了兼容性。 泛型被添加时，Java即将进入第二个十年，并且有大量的代码没有使用泛型。 所有这些代码都是合法的，并且与使用泛型的新代码进行交互操作被认为是至关重要的。 将参数化类型的实例传递给为原始类型设计的方法必须是合法的，反之亦然。 这个需求，被称为迁移兼容性，驱使决策支持原始类型，并使用擦除来实现泛型（条目 28）。&lt;/p&gt;
&lt;p&gt;虽然不应使用诸如List之类的原始类型，但可以使用参数化类型来允许插入任意对象（如&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;）。 原始类型List和参数化类型&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;之间有什么区别？ 松散地说，前者已经选择了泛型类型系统，而后者明确地告诉编译器，它能够保存任何类型的对象。 虽然可以将&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;传递给List类型的参数，但不能将其传递给&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;类型的参数。 泛型有子类型的规则，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;是原始类型List的子类型，但不是参数化类型&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;的子类型（条目 28）。 因此，如果使用诸如List之类的原始类型，则会丢失类型安全性，但是如果使用参数化类型（例如&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;）则不会。&lt;/p&gt;
&lt;p&gt;为了具体说明，请考虑以下程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Fails at runtime - unsafeAdd method uses a raw type (List)!
public static void main(String[] args) {
    List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;();
    unsafeAdd(strings, Integer.valueOf(42));
    String s = strings.get(0); // Has compiler-generated cast
}

private static void unsafeAdd(List list, Object o) {
    list.add(o);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此程序可以编译，它使用原始类型列表，但会收到警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:10: warning: [unchecked] unchecked call to add(E) as a
member of the raw type List
    list.add(o);
            ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，如果运行该程序，则当程序尝试调用&lt;code&gt;strings.get(0)&lt;/code&gt;的结果（一个Integer）转换为一个String时，会得到ClassCastException异常。 这是一个编译器生成的强制转换，因此通常会保证成功，但在这种情况下，我们忽略了编译器警告并付出了代价。&lt;/p&gt;
&lt;p&gt;如果用unsafeAdd声明中的参数化类型&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;替换原始类型List，并尝试重新编译该程序，则会发现它不再编译，而是发出错误消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Test.java:5: error: incompatible types: List&amp;lt;String&amp;gt; cannot be
converted to List&amp;lt;Object&amp;gt;
    unsafeAdd(strings, Integer.valueOf(42));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会试图使用原始类型来处理元素类型未知且无关紧要的集合。 例如，假设你想编写一个方法，它需要两个集合并返回它们共同拥有的元素的数量。 如果是泛型新手，那么您可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Use of raw type for unknown element type - don't do this!
static int numElementsInCommon(Set s1, Set s2) {
    int result = 0;
    for (Object o1 : s1)
        if (s2.contains(o1))
            result++;
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可以工作，但它使用原始类型，这是危险的。 安全替代方式是使用无限制通配符类型（unbounded wildcard types）。 如果要使用泛型类型，但不知道或关心实际类型参数是什么，则可以使用问号来代替。 例如，泛型类型&lt;code&gt;Set&amp;lt;E&amp;gt;&lt;/code&gt;的无限制通配符类型是&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;（读取“某种类型的集合”）。 它是最通用的参数化的Set类型，能够保持任何集合。 下面是&lt;code&gt;numElementsInCommon&lt;/code&gt;方法使用无限制通配符类型声明的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Uses unbounded wildcard type - typesafe and flexible
static int numElementsInCommon(Set&amp;lt;?&amp;gt; s1, Set&amp;lt;?&amp;gt; s2) { ... }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无限制通配符&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;与原始类型Set之间有什么区别？ 问号真的给你放任何东西吗？ 这不是要点，但通配符类型是安全的，原始类型不是。 你可以将任何元素放入具有原始类型的集合中，轻易破坏集合的类型不变性（如第119页上的unsafeAdd方法所示）; 你不能把任何元素（除null之外）放入一个&lt;code&gt;Collection &amp;lt;?&amp;gt;&lt;/code&gt;中。 试图这样做会产生一个像这样的编译时错误消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WildCard.java:13: error: incompatible types: String cannot be
converted to CAP#1
    c.add(&quot;verboten&quot;);
          ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不可否认的是，这个错误信息留下了一些需要的东西，但是编译器已经完成了它的工作，不管它的元素类型是什么，都不会破坏集合的类型不变性。 你不仅可以将任何元素（除null以外）放入一个&lt;code&gt;Collection &amp;lt;?&amp;gt;&lt;/code&gt;中，但是不能保证你所得到的对象的类型。 如果这些限制是不可接受的，可以使用泛型方法（条目 30）或有限制配符类型（条目 31）。&lt;/p&gt;
&lt;p&gt;对于不应该使用原始类型的规则，有一些小例外。 &lt;strong&gt;你必须在类字面值（class literals）中使用原始类型&lt;/strong&gt;。 规范中不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS，15.8.2]。 换句话说，&lt;code&gt;List.class&lt;/code&gt;，&lt;code&gt;String [] .class&lt;/code&gt;和&lt;code&gt;int.class&lt;/code&gt;都是合法的，但&lt;code&gt;List &amp;lt;String&amp;gt; .class&lt;/code&gt;和&lt;code&gt;List &amp;lt;?&amp;gt;.class&lt;/code&gt;不是合法的。&lt;/p&gt;
&lt;p&gt;规则的第二个例外涉及&lt;code&gt;instanceof&lt;/code&gt;操作符。 因为泛型类型信息在运行时被删除，所以在无限制通配符类型以外的参数化类型上使用instanceof运算符是非法的。 使用无限制通配符类型代替原始类型不会以任何方式影响instanceof运算符的行为。 在这种情况下，尖括号和问号就显得多余。 以下是使用泛型类型的instanceof运算符的首选方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Legitimate use of raw type - instanceof operator
if (o instanceof Set) {       // Raw type
    Set&amp;lt;?&amp;gt; s = (Set&amp;lt;?&amp;gt;) o;    // Wildcard type
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，一旦确定&lt;code&gt;o&lt;/code&gt;对象是一个Set，则必须将其转换为通配符&lt;code&gt;Set &amp;lt;?&amp;gt;&lt;/code&gt;，而不是原始类型Set。 这是一个强制转换，所以不会导致编译器警告。&lt;/p&gt;
&lt;p&gt;总之，使用原始类型可能导致运行时异常，所以不要使用它们。 它们仅用于与泛型引入之前的传统代码的兼容性和互操作性。 作为一个快速回顾，&lt;code&gt;Set&amp;lt;Object&amp;gt;&lt;/code&gt;是一个参数化类型，表示一个可以包含任何类型对象的集合，&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;是一个通配符类型，表示一个只能包含某些未知类型对象的集合，Set是一个原始类型，它不在泛型类型系统之列。 前两个类型是安全的，最后一个不是。&lt;/p&gt;
&lt;p&gt;为了快速参考，下表中总结了本条目（以及本章稍后介绍的一些）中介绍的术语：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Parameterized type&lt;/td&gt;
&lt;td&gt;参数化类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Actual type parameter&lt;/td&gt;
&lt;td&gt;实际类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Generic type&lt;/td&gt;
&lt;td&gt;泛型类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Formal type parameter&lt;/td&gt;
&lt;td&gt;形式类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Unbounded wildcard type&lt;/td&gt;
&lt;td&gt;无限制通配符类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Raw type&lt;/td&gt;
&lt;td&gt;原始类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Bounded type parameter&lt;/td&gt;
&lt;td&gt;限制类型参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 29&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Recursive type bound&lt;/td&gt;
&lt;td&gt;递归类型限制&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Bounded wildcard type&lt;/td&gt;
&lt;td&gt;限制通配符类型&lt;/td&gt;
&lt;td&gt;&lt;code&gt;List&amp;lt;? extends Number&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 31&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Generic method&lt;/td&gt;
&lt;td&gt;泛型方法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; asList(E[] a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Type token&lt;/td&gt;
&lt;td&gt;类型令牌&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String.class&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条目 33&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Fri, 26 Jan 2018 14:28:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8361867.html</dc:identifier>
</item>
<item>
<title>豹哥嵌入式讲堂：ARM Cortex-M开发之文件详解（8）- 镜像文件(.bin/.hex/.s19) - Jay豹哥</title>
<link>http://www.cnblogs.com/henjay724/p/8361693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/8361693.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是豹哥，猎豹的豹，犀利哥的哥。今天豹哥给大家讲的是&lt;strong&gt;嵌入式开发里的image文件(.bin, .hex, .s19)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　今天这节课是豹哥《ARM Cortex-M开发之文件详解》主题系列的最后一节课（突然有点不舍，要告别的感觉，咳咳，让豹哥整理下情绪先）。今天豹哥主要讲的是工程开发最终的output文件，即image文件。image文件也叫镜像文件，这个文件主要包含的是只有芯片能够解释执行的二进制机器码数据，这些数据其实在前面介绍的relocatable、list、executable文件中出现过，在那些文件里我们还可以根据其他辅助信息来分析机器码数据的实际意义，但在image文件里，我们已经完全无法看懂这些机器码了。所以image文件主要是用来做大规模量产的。既要做大规模量产，由于各芯片厂家制定的标准不一，所以实际上image文件有很多种格式，今天我们主要讲的是其中最具有代表性也应用最广泛的3种image文件格式。&lt;/p&gt;
&lt;h3 id=&quot;一通用镜像文件bin&quot;&gt;一、通用镜像文件bin&lt;/h3&gt;
&lt;p&gt;　　第一种格式叫binary，以.bin为文件后缀，这种格式是一种通用image格式，其完全是机器码裸数据的集合，没有其他任何多余信息，这个数据可以直接被编程器/下载器下载到芯片内部非易失性存储器里，不需要任何额外的数据转换，所见即所得。由于是纯二进制编码的文件，所以普通text编辑器无法正确查看这个文件，需要用专用的十六进制编辑器（比如Hex Editor HxD）才能正常打开。以本系列创建的demo工程的demo.bin文件为例，用HxD打开可见如下数据（仅截取前后部分显示，demo.bin共6780 bytes）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;offset(h)
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; DB &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; CB &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000010&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000020&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;07&lt;/span&gt; 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000030&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1D 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1F 1A &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000040&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;72&lt;/span&gt; B6 0E &lt;span class=&quot;dv&quot;&gt;48&lt;/span&gt; 0E &lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
...
00001A30: &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;23&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt; E0 0A &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;09&lt;/span&gt; 1D 1A &lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt; D0 4D &lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;
00001A40: 6D 1E &lt;span class=&quot;dv&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; 1D &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 1F &lt;span class=&quot;dv&quot;&gt;04&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; FA D2 &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;
00001A50: &lt;span class=&quot;dv&quot;&gt;86&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;07&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt; D5 &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt; AD 1C &lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; D0 2C &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt;
00001A60: &lt;span class=&quot;dv&quot;&gt;09&lt;/span&gt; 1D &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;28&lt;/span&gt; E7 D1 &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; BC &lt;span class=&quot;dv&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;47&lt;/span&gt; C1 FF FF FF
00001A70: &lt;span class=&quot;dv&quot;&gt;08&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; -- -- -- --&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有细心的朋友可能会疑问，打开bin文件看数据都是按连续地址排列的，如果在应用设计中，我们在linker文件里给各个段分配的地址不是连续的，这在bin文件里是怎么处理的？为了解决这个问题，bin文件会在非有效地址区域插入无效字节以保证有效地址处都是正确的数据，这在IDE里或相关转换工具里都会有相应option，可以让用户设置填充字节pattern（比如0x00，0xFF等）。&lt;br/&gt;　　好，现在让我们尝试分析一下这个bin文件，我们都知道ARM Cortex-M架构里，image bin文件前8个字节应该是初始SP和PC的值，从前面map文件里我们知道SP=0x10002000，PC=0x00000041，来检查一下bin文件里是不是这样，前4个字节分别是 00 20 00 10、看起来好像跟0x10002000数据是吻合的，但是这个数据排列方式看起来好像有点别扭，怎么回事？嵌入式老司机这时应该要莞尔一笑，是的，ARM Coretx-M默认采用的Little-Endian（小端）模式，即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。数据查看地址显示都是从低到高的（从左到右），所以SP的最低字节应该显示在最左边（最低地址），而不是像查看0x10002000那样最低字节在最右边，这跟人的阅读习惯是有点不吻合。&lt;br/&gt;　　PS: 既有小端模式，那么与其对应的也有大端模式（Big-Endian）-高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。注意大端小端仅是针对以32bit为单元的数据排列方式差异，对于n个32bit数据，其都是统一的排列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;offset(h)
&lt;span class=&quot;co&quot;&gt;// 小端&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; 
&lt;span class=&quot;co&quot;&gt;// 大端&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;00000000&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上面对bin文件的分析，我们知道bin文件是不含地址信息的，也就是说bin文件数据应该被放在什么地址处，我们仅从bin文件本身是无法得知的。所以在使用编程器/下载器下载bin文件时，用户必须指定起始下载地址。由于bin文件的这种局限性，下面两种带地址信息的image格式应运而生。&lt;/p&gt;
&lt;h3 id=&quot;二intel镜像文件标准hex&quot;&gt;二、Intel镜像文件标准hex&lt;/h3&gt;
&lt;p&gt;　　第二种格式叫Intel hex，以.hex为文件后缀，这种格式是Intel公司推行的一种image格式标准，其不仅含有机器码裸数据还含有地址信息等额外信息，与bin文件不同的是，hex文件可以直接通用普通text编辑器打开查看，hex文件采用的ASCII编码，hex文件内的机器码数据不可以直接被下载进芯片内部，需要在帧数据解析的过程中进行转换。&lt;br/&gt;　　由于hex文件并不是纯机器码文件，还含有其他额外信息，那么hex文件就需要按某种约定格式进行数据组织，数据组织方式叫帧格式，hex文件是由n帧数据组成的。&lt;/p&gt;
&lt;h4 id=&quot;hex帧格式&quot;&gt;2.1 hex帧格式&lt;/h4&gt;
&lt;p&gt;　　要想解析hex文件，必须要先了解其帧格式，hex每帧都由下表列出的6部分组成：&lt;/p&gt;
&lt;table readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;帧段名&lt;/th&gt;
&lt;td&gt;Start code&lt;/td&gt;
&lt;td&gt;Byte count&lt;/td&gt;
&lt;td&gt;Address&lt;/td&gt;
&lt;td&gt;Record type&lt;/td&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;th&gt;帧段内容&lt;/th&gt;
&lt;td&gt;固定前导码':'，十六进制0x3A&lt;/td&gt;
&lt;td&gt;机器码数据长度&lt;/td&gt;
&lt;td&gt;机器码数据存储地址&lt;/td&gt;
&lt;td&gt;帧类型&quot;00&quot;-&quot;05&quot;，有6种帧&lt;/td&gt;
&lt;td&gt;机器码数据&lt;/td&gt;
&lt;td&gt;校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;帧段长度(bytes)&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;2*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;(0-255)*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;　　编程器/下载器在解析hex文件时，先找到帧前导码，然后找到帧类型，如果该帧为数据帧，再根据帧机器码长度，将该帧机器码数据全部读出放到缓存里，在做完帧和校验后，如果没有错误，最后根据帧机器码存储地址将帧机器码数据下载到芯片指定存储器地址处，至此一帧处理结束，进入下一帧，直到所有帧全部处理完。需要注意的是由于hex文件是ASCII编码，所以相比bin文件长度至少大2倍以上，demo.hex文件大小有19,106 bytes，后面我们会截取部分hex文件进行分析。&lt;br/&gt;　　关于checksum的计算方法，其是将Byte count、Address、Record type、Data四个段内所有byte全部相加得到sum，截取sum的LSB（最低字节），再对该LSB取其补码（默认该LSB为负数的低8bit数据位(注意8bit中没有符号位)，其反码为原码各bit取反，其补码为反码+1）得到checksum。比如LSB是0xA5，其反码为0x5A，补码为0x5B，则checksum为0x5B。&lt;/p&gt;
&lt;h4 id=&quot;hex帧类型&quot;&gt;2.2 hex帧类型&lt;/h4&gt;
&lt;p&gt;　　前面说到一共有6种类型的帧，其中最重要也是数量最多的帧是数据帧，除了数据帧之外还有其他5种帧，下面来统一介绍：&lt;/p&gt;
&lt;table readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;th&gt;帧类型码&lt;/th&gt;
&lt;th&gt;帧类型&lt;/th&gt;
&lt;th&gt;帧描述&lt;/th&gt;
&lt;th&gt;帧举例&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&quot;00&quot;&lt;/td&gt;
&lt;td&gt;数据帧&lt;/td&gt;
&lt;td&gt;以16bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含11bytes机器码从0x0010地址处开始的数据帧:0B0010006164647265737320676170A7&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&quot;01&quot;&lt;/td&gt;
&lt;td&gt;文件结尾帧&lt;/td&gt;
&lt;td&gt;用于表明hex文件的结尾&lt;/td&gt;
&lt;td&gt;统一的文件结尾帧:00000001FF&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&quot;02&quot;&lt;/td&gt;
&lt;td&gt;拓展段地址帧&lt;/td&gt;
&lt;td&gt;多用于80x86架构芯片，ARM Cortex-M架构不用&lt;/td&gt;
&lt;td&gt;:020000021200EA&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&quot;03&quot;&lt;/td&gt;
&lt;td&gt;起始段地址帧&lt;/td&gt;
&lt;td&gt;多用于80x86架构芯片，ARM Cortex-M架构不用&lt;/td&gt;
&lt;td&gt;:0400000300003800C1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&quot;04&quot;&lt;/td&gt;
&lt;td&gt;拓展线性地址帧&lt;/td&gt;
&lt;td&gt;用于32bit地址存储空间芯片，与数据帧配合使用，指引编程器将数据下载到正确地址&lt;/td&gt;
&lt;td&gt;标明拓展地址为0xFFFF的帧:02000004FFFFFC&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&quot;05&quot;&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧&lt;/td&gt;
&lt;td&gt;指示调试器，程序初始PC地址，方便在线调试&lt;/td&gt;
&lt;td&gt;标明起始PC为0x000000CD的帧:04000005000000CD2A&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h4 id=&quot;解析hex文件&quot;&gt;2.3 解析hex文件&lt;/h4&gt;
&lt;p&gt;　　在了解hex文件帧数据格式之后，让我们开始尝试解析demo.hex文件(仅截取前后部分，与前面截取的bin文件内容对应着一起分析)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;:100000000020001041000000DB180000CB190000A8
:&lt;span class=&quot;fl&quot;&gt;1000100000000000000000000000000000000000E0&lt;/span&gt;
:10002000000000000000000000000000071A0000AF
:1000300000000000000000001D1A00001F1A000050
:1000400072B60E480E498860002200230024002565
....
:101A30000123002413E00A68091D1A4202D04D4612
:101A40006D1E52191460121D001F0428FAD21500D1
:101A5000860701D51480AD1C184000D02C70086892
:101A6000091D0028E7D1080070BC7047C1FFFFFFC7
:0C1A70000802000014200010000000001C
:0400000500000041B6
:00000001FF&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　hex文件前5帧均为数据帧，每帧包含16bytes机器码数据，帧数据地址分别为0x0000, 0x0010, 0x0020, 0x0030, 0x0040，可见帧数据是连续的，并且5帧机器码数据共80bytes与bin文件前80bytes是一致的。&lt;br/&gt;　　再来看最后7帧数据里的前5个数据帧，除最后一帧数据只包含12bytes数据外，其余数据帧均含有16bytes数据，5帧数据一共76bytes，帧数据地址从0x1A30 - 0x1A70。显然这与bin文件最后76bytes也是吻合的。&lt;br/&gt;　　倒数第二帧是起始程序地址帧，其标明的程序起始PC是0x00000041，这与bin文件里第二个32bit数据（起始PC）是一致的。&lt;br/&gt;　　倒数第一帧显然是标准文件结尾帧。&lt;/p&gt;
&lt;h3 id=&quot;三motorola镜像文件标准s-record&quot;&gt;三、Motorola镜像文件标准S-Record&lt;/h3&gt;
&lt;p&gt;　　第三种格式叫Motorola S-Record，以.s19或.srec为文件后缀，这种格式是Motorola公司推行的一种image格式标准，其与Intel hex文件比较类似，都是ASCII编码的文件，可以通过普通text编辑器打开查看，其也由帧数据组成，只是帧格式与Intel hex有差别，还是按照介绍Intel hex文件那样先来看S-Record文件的帧格式。&lt;/p&gt;
&lt;h4 id=&quot;s-record帧格式&quot;&gt;3.1 S-Record帧格式&lt;/h4&gt;
&lt;p&gt;　　S-Record每帧由下表列出的6部分组成：&lt;/p&gt;
&lt;table readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;th&gt;帧段名&lt;/th&gt;
&lt;td&gt;Start code&lt;/td&gt;
&lt;td&gt;Record type&lt;/td&gt;
&lt;td&gt;Byte count&lt;/td&gt;
&lt;td&gt;Address&lt;/td&gt;
&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;Checksum&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;th&gt;帧段内容&lt;/th&gt;
&lt;td&gt;固定前导码'S'，十六进制0x53&lt;/td&gt;
&lt;td&gt;帧类型'0'-'9'，有10种帧&lt;/td&gt;
&lt;td&gt;帧数据长度（包含后续段地址、数据、校验和）&lt;/td&gt;
&lt;td&gt;机器码数据存储地址&lt;/td&gt;
&lt;td&gt;机器码数据&lt;/td&gt;
&lt;td&gt;校验和&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;帧段长度(bytes)&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;td&gt;(2-4)*2&lt;/td&gt;
&lt;td&gt;(0-255)*2&lt;/td&gt;
&lt;td&gt;1*2&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;　　编程器/下载器在解析S-Record文件时，先找到帧前导码，然后找到帧类型，如果该帧为数据帧，再根据帧长度，将该帧机器码数据全部读出放到缓存里，在做完帧和校验后，如果没有错误，最后根据帧机器码存储地址将帧机器码数据下载到芯片指定存储器地址处，至此一帧处理结束，进入下一帧，直到所有帧全部处理完。&lt;br/&gt;　　关于checksum的计算方法，其是将Byte count、Address、Data三个段内所有byte全部相加得到sum，截取sum的LSB（最低字节），再对该LSB取其反码（默认该LSB为负数的低8bit数据位(注意8bit中没有符号位)，其反码为原码各bit取反）得到checksum。比如LSB是0xA5，其反码为0x5A，则checksum为0x5A。&lt;/p&gt;
&lt;h4 id=&quot;s-record帧类型&quot;&gt;3.2 S-Record帧类型&lt;/h4&gt;
&lt;p&gt;　　前面说到一共有10种类型的帧，其中最重要也是数量最多的帧是数据帧，数据帧按地址长度可分为16bit、24bit、32bit地址长度数据帧，除了数据帧，还有其他种类帧，下面来统一介绍：&lt;/p&gt;
&lt;table readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;th&gt;帧类型码&lt;/th&gt;
&lt;th&gt;帧类型&lt;/th&gt;
&lt;th&gt;帧描述&lt;/th&gt;
&lt;th&gt;帧举例&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'0'&lt;/td&gt;
&lt;td&gt;文件起始帧&lt;/td&gt;
&lt;td&gt;用于表明S-Record文件的开始&lt;/td&gt;
&lt;td&gt;标明文件名为HDR的文件起始帧S00600004844521B&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'1'&lt;/td&gt;
&lt;td&gt;数据帧x16地址&lt;/td&gt;
&lt;td&gt;以16bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含14bytes机器码从0x0038地址处开始的数据帧S111003848656C6C6F20776F726C642E0A0042&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'2'&lt;/td&gt;
&lt;td&gt;数据帧x24地址&lt;/td&gt;
&lt;td&gt;以24bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含4bytes机器码从0x100000地址处开始的数据帧S2081000000400FA05E5&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'3'&lt;/td&gt;
&lt;td&gt;数据帧x32地址&lt;/td&gt;
&lt;td&gt;以32bit地址描述开始的最大255个字节有效机器码的数据帧&lt;/td&gt;
&lt;td&gt;含4bytes机器码从0x13000160地址处开始的数据帧S309130001600400FA057F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'4'&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'5'&lt;/td&gt;
&lt;td&gt;数据帧总数帧x16&lt;/td&gt;
&lt;td&gt;用16bit count记录数据帧总帧数的总数帧&lt;/td&gt;
&lt;td&gt;标明总数据帧为4帧的总数帧S5030004F8&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'6'&lt;/td&gt;
&lt;td&gt;数据帧总数帧x16&lt;/td&gt;
&lt;td&gt;用24bit count记录数据帧总帧数的总数帧&lt;/td&gt;
&lt;td&gt;标明总数据帧为80000帧的总数帧S604080000F3&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'7'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x32&lt;/td&gt;
&lt;td&gt;含32bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x10000000的帧S70510000000EA&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'8'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x24&lt;/td&gt;
&lt;td&gt;含24bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x100000的帧S804100000EB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;'9'&lt;/td&gt;
&lt;td&gt;起始程序地址（PC）帧x16&lt;/td&gt;
&lt;td&gt;含16bit起始PC的帧&lt;/td&gt;
&lt;td&gt;标明起始PC为0x0000的帧S9030000FC&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h4 id=&quot;解析s-record文件&quot;&gt;3.3 解析S-Record文件&lt;/h4&gt;
&lt;p&gt;　　在了解S-Record文件帧数据格式之后，让我们开始尝试解析demo.s19文件(仅截取前后部分，与前面截取的bin文件内容对应着一起分析)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;S00B000064656D6F2E73313944
S11300000020001041000000DB180000CB190000A4
S113001000000000000000000000000000000000DC
S1130020000000000000000000000000071A0000AB
S113003000000000000000001D1A00001F1A00004C
S113004072B60E480E498860002200230024002561
....
S1131A300123002413E00A68091D1A4202D04D460E
S1131A406D1E52191460121D001F0428FAD21500CD
S1131A50860701D51480AD1C184000D02C7008688E
S1131A60091D0028E7D1080070BC7047C1FFFFFFC3
S10F1A7008020000142000100000000018
S9030041BB&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　S-Record文件第一帧是文件起始帧，帧数据64656D6F2E733139对应ASCII为demo.s19，即该文件名。&lt;br/&gt;　　第2-6帧均为16bit地址的数据帧，每帧包含16bytes机器码数据，帧数据地址分别为0x0000, 0x0010, 0x0020, 0x0030, 0x0040，可见帧数据是连续的，并且5帧机器码数据共80bytes与bin文件前80bytes是一致的。&lt;br/&gt;　　再来看最后6帧数据里的前5个数据帧，除最后一帧数据只包含12bytes数据外，其余数据帧均含有16bytes数据，5帧数据一共76bytes，帧数据地址从0x1A30 - 0x1A70。显然这与bin文件最后76bytes也是吻合的。&lt;br/&gt;　　倒数第一帧是起始程序地址帧，其标明的程序起始PC是0x0041，这与bin文件里第二个32bit数据（起始PC）是一致的。&lt;/p&gt;
&lt;h3 id=&quot;番外一一些image文件辅助小工具&quot;&gt;番外一、一些image文件辅助小工具&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;SRecordizer：专用S19文件编辑器，可根据修改自动更新checksum，详见网页https:&lt;span class=&quot;co&quot;&gt;//srecordizer.codeplex.com/&lt;/span&gt;
SRecord项目：各种image文件格式互转的小工具合集，详见网页http:&lt;span class=&quot;co&quot;&gt;//srecord.sourceforge.net/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，嵌入式开发里的image文件(.bin, .hex, .s19)文件豹哥便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jan 2018 13:34:00 +0000</pubDate>
<dc:creator>Jay豹哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henjay724/p/8361693.html</dc:identifier>
</item>
</channel>
</rss>