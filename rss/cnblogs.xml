<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【项目记录】-路灯光照分析系统 gmap.net - -知心不知情</title>
<link>http://www.cnblogs.com/july4/p/8478884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/july4/p/8478884.html</guid>
<description>&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;2016年5月，客户要求在地图上显示路灯及数据，分析数据生成报表，以便查看分析路灯情况。&lt;/p&gt;
&lt;h3 id=&quot;选型&quot;&gt;选型&lt;/h3&gt;
&lt;p&gt;国外项目就不考虑国内的地图了，开始想使用google的web地图，考虑到地图上标记物过多影响性能及使用体验，对gmap测试后，选用gamp.net。&lt;/p&gt;
&lt;h3 id=&quot;开发&quot;&gt;开发&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/187982/201802/187982-20180227105144521-143975463.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;功能&quot;&gt;功能：&lt;/h3&gt;
&lt;p&gt;1.导入路灯及数据，在地图上添加、编辑、删除路灯，路灯数据软件修正、移除错误数据&lt;br/&gt;2.地图上线时路灯及数据，数据以标记、曲线、表格方式显示&lt;br/&gt;3.导出整个系统数据，下次可以将系统导出的文件导入进行查看；导出生成excel报表&lt;br/&gt;4.多点测距；多边形方式进行选择查看，选择多边形内路灯情况&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;h4 id=&quot;计算2个坐标点距离&quot;&gt;计算2个坐标点距离&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    private static double EARTH_RADIUS = 6378137;//赤道半径(单位m)  
    /** 
     * 转化为弧度(rad) 
     * */
    private static double rad(double d)
    {
        return d * Math.PI / 180.0;
    }

    /** 
     * 基于余弦定理求两经纬度距离 
     * @param lon1 第一点的精度 
     * @param lat1 第一点的纬度 
     * @param lon2 第二点的精度 
     * @param lat3 第二点的纬度 
     * @return 返回的距离，单位m 
     * */
    public static double GetDistance(double lng1, double lat1, double lng2, double lat2)
    {
        double radLat1 = rad(lat1);
        double radLat2 = rad(lat2);

        double radLng1 = rad(lng1);
        double radLng2 = rad(lng2);

        if (radLat1 &amp;lt; 0)
            radLat1 = Math.PI / 2 + Math.Abs(radLat1);// south  
        if (radLat1 &amp;gt; 0)
            radLat1 = Math.PI / 2 - Math.Abs(radLat1);// north  
        if (radLng1 &amp;lt; 0)
            radLng1 = Math.PI * 2 - Math.Abs(radLng1);// west  
        if (radLat2 &amp;lt; 0)
            radLat2 = Math.PI / 2 + Math.Abs(radLat2);// south  
        if (radLat2 &amp;gt; 0)
            radLat2 = Math.PI / 2 - Math.Abs(radLat2);// north  
        if (radLng2 &amp;lt; 0)
            radLng2 = Math.PI * 2 - Math.Abs(radLng2);// west  
        double x1 = EARTH_RADIUS * Math.Cos(radLng1) * Math.Sin(radLat1);
        double y1 = EARTH_RADIUS * Math.Sin(radLng1) * Math.Sin(radLat1);
        double z1 = EARTH_RADIUS * Math.Cos(radLat1);

        double x2 = EARTH_RADIUS * Math.Cos(radLng2) * Math.Sin(radLat2);
        double y2 = EARTH_RADIUS * Math.Sin(radLng2) * Math.Sin(radLat2);
        double z2 = EARTH_RADIUS * Math.Cos(radLat2);

        double d = Math.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
        //余弦定理求夹角  
        double theta = Math.Acos((EARTH_RADIUS * EARTH_RADIUS + EARTH_RADIUS * EARTH_RADIUS - d * d) / (2 * EARTH_RADIUS * EARTH_RADIUS));
        double dist = theta * EARTH_RADIUS;
        return dist;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取方向角度&quot;&gt;获取方向角度&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 获取方向角度
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;lon1&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;lat1&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;lon2&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;lat2&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static double GetDirection(double lon1, double lat1, double lon2, double lat2)
    {
        double x1 = lon1;
        double y1 = lat1;
        double x2 = lon2;
        double y2 = lat2;
        double pi = Math.PI;
        double w1 = y1 / 180 * pi;
        double j1 = x1 / 180 * pi;
        double w2 = y2 / 180 * pi;
        double j2 = x2 / 180 * pi;
        double ret;
        if (j1 == j2)
        {
            if (w1 &amp;gt; w2) ret = 270; //北半球的情况，南半球忽略
            else if (w1 &amp;lt; w2) ret = 90;
            else ret =-1;//位置完全相同
        }
        ret = 4 * Math.Pow(Math.Sin((w1 - w2) / 2), 2) - Math.Pow(Math.Sin((j1 - j2) / 2) * (Math.Cos(w1) - Math.Cos(w2)), 2);
        ret = Math.Sqrt(ret);
        double temp = (Math.Sin(Math.Abs(j1 - j2) / 2) * (Math.Cos(w1) + Math.Cos(w2)));
        ret = ret / temp;
        ret = Math.Atan(ret) / pi * 180;
        if (j1 &amp;gt; j2) // 1为参考点坐标
        {
            if (w1 &amp;gt; w2) ret += 180;
            else ret = 180 - ret;
        }
        else if (w1 &amp;gt; w2) ret = 360 - ret;

        return ret;
        //result.Text = Convert.ToString(ret);

        //if ((ret &amp;lt;= 10) || (ret &amp;gt; 350)) angle.Text = &quot;东&quot;;
        //if ((ret &amp;gt; 10) &amp;amp;&amp;amp; (ret &amp;lt;= 80)) angle.Text = &quot;东北&quot;;
        //if ((ret &amp;gt; 80) &amp;amp;&amp;amp; (ret &amp;lt;= 100)) angle.Text = &quot;北&quot;;
        //if ((ret &amp;gt; 100) &amp;amp;&amp;amp; (ret &amp;lt;= 170)) angle.Text = &quot;西北&quot;;
        //if ((ret &amp;gt; 170) &amp;amp;&amp;amp; (ret &amp;lt;= 190)) angle.Text = &quot;西&quot;;
        //if ((ret &amp;gt; 190) &amp;amp;&amp;amp; (ret &amp;lt;= 260)) angle.Text = &quot;西南&quot;;
        //if ((ret &amp;gt; 260) &amp;amp;&amp;amp; (ret &amp;lt;= 280)) angle.Text = &quot;南&quot;;
        //if ((ret &amp;gt; 280) &amp;amp;&amp;amp; (ret &amp;lt;= 350)) angle.Text = &quot;东南&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;判断坐标是否在多边形内&quot;&gt;判断坐标是否在多边形内&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 判断点是否在多边形内.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;checkPoint&quot;&amp;gt;要判断的点&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;polygonPoints&quot;&amp;gt;多边形的顶点&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public static bool IsInPolygon(PointLatLng checkPoint, List&amp;lt;PointLatLng&amp;gt; polygonPoints)
    {
        int counter = 0;
        int i;
        double xinters;
        PointLatLng p1, p2;
        int pointCount = polygonPoints.Count;
        p1 = polygonPoints[0];
        for (i = 1; i &amp;lt;= pointCount; i++)
        {
            p2 = polygonPoints[i % pointCount];
            if (checkPoint.Lat &amp;gt; Math.Min(p1.Lat, p2.Lat)//校验点的Y大于线段端点的最小Y
                &amp;amp;&amp;amp; checkPoint.Lat &amp;lt;= Math.Max(p1.Lat, p2.Lat))//校验点的Y小于线段端点的最大Y
            {
                if (checkPoint.Lng &amp;lt;= Math.Max(p1.Lng, p2.Lng))//校验点的X小于等线段端点的最大X(使用校验点的左射线判断).
                {
                    if (p1.Lat != p2.Lat)//线段不平行于X轴
                    {
                        xinters = (checkPoint.Lat - p1.Lat) * (p2.Lng - p1.Lng) / (p2.Lat - p1.Lat) + p1.Lng;
                        if (p1.Lng == p2.Lng || checkPoint.Lng &amp;lt;= xinters)
                        {
                            counter++;
                        }
                    }
                }

            }
            p1 = p2;
        }

        if (counter % 2 == 0)
        {
            return false;
        }
        else
        {
            return true;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多点测距&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/187982/201802/187982-20180227110334227-211957614.png&quot;/&gt;&lt;br/&gt;多边形选择&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/187982/201802/187982-20180227110441211-713521495.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于测距&quot;&gt;关于测距&lt;/h3&gt;
&lt;p&gt;测距尝试过使用gmap提供的根据道路测距，发现还是不太准，所以还是选择了手动选择坐标点连线测距。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;该项目2018年初还增加了一些功能，开发过程中有不少次沟通和修改，主要就是一些gps和数据拆分、补全上的处理和报表算法上有些繁琐，项目目前暂时告一段落。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 06:51:00 +0000</pubDate>
<dc:creator>-知心不知情</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/july4/p/8478884.html</dc:identifier>
</item>
<item>
<title>基于蚁群算法的机械臂打孔路径规划 - DHUtoBUAA</title>
<link>http://www.cnblogs.com/DHUtoBUAA/p/8478671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DHUtoBUAA/p/8478671.html</guid>
<description>&lt;p&gt;  该问题来源于参加某知名外企的校招面试。根据面试官描述，一块木板有数百个小孔（坐标已知），现在需要通过机械臂在木板上钻孔，要求对打孔路径进行规划，力求使&lt;span&gt;打孔总路径最短&lt;/span&gt;，这对于提高机械臂打孔的生产效能、降低生产成本具有重要的意义。&lt;/p&gt;

&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;  机械臂打孔生产效能主要取决于以下三个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单个孔的钻孔作业时间，这是由生产工艺所决定的，不在优化范围内，本文假定对于同一孔型钻孔的作业时间是相同的。&lt;/li&gt;
&lt;li&gt;打孔机在加工作业时，钻头的行进时间。&lt;/li&gt;
&lt;li&gt;针对不同孔型加工作业时间，刀具的转换时间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  在机械臂打孔生产效能的三个重要因素中，单孔作业时间因生产工艺无法优化，刀具切换时间因生产流程无法优化，所以可优化的主要是机械臂行进时间，这直接受到打孔路径规划的影响，并与路径长度正相关，所以设计出合理的较短的打孔路径，对于提高机械臂打孔的生成效能具有重要意义。&lt;br/&gt;  打孔的路径规划问题，可以转换为旅行商问题TSP（一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后回到原来出发的城市）来分析求解。&lt;br/&gt;  在实际应用中，因为机械臂连续作业，那么一块木板打孔完毕后，机械臂是否回到起始点需要对TSP进行改造。&lt;/p&gt;
&lt;h2 id=&quot;最佳规划路径&quot;&gt;最佳规划路径&lt;/h2&gt;
&lt;p&gt;  采用0-1变量来确定规划路径上两点的情况，即&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/n7ib0baefm.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;  那么刀具行进时间为&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/0ettd5qhmz.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;  其中，&lt;em&gt;n&lt;/em&gt;为所有的打孔数目，(x&lt;sub&gt;i&lt;/sub&gt;,x&lt;sub&gt;j&lt;/sub&gt;)和(y&lt;sub&gt;i&lt;/sub&gt;,y&lt;sub&gt;j&lt;/sub&gt;) 为任意两孔，&lt;em&gt;v&lt;/em&gt;为刀具行进的速度,假设两点距离采用欧氏距离公式。&lt;/p&gt;

&lt;p&gt;  TSP问题是非常典型的NP（Nondeterministic Polynomial）难问题，对于大规模的TSP问题，目前没有完美的解法，所有的智能算法只能在一定程度上近似逼近最优结果。其中常用的算法有遗传算法、模拟退火算法、蚁群算法等。&lt;br/&gt;  由文献可以得到，==蚁群算法适用于缓慢地精确的求解场合；模拟退火算法适用于快速较精确地求解；遗传算法适用于快速地求解，但是准确度不高==。所以，本文在保证精确度的要求下，以蚁群算法为基础，探讨打孔路径规划的问题。&lt;br/&gt;  蚁群算法（Ant Colony Algorithm，ACA），最初是由意大利学者Dorigo M.博士于1991年首次提出，其本质是一个复杂的智能系统，且具有较强的鲁棒性，优良的分布式计算机制等优点。该算法经过十多年的发展，已被广大的科学研究人员应用于各种问题的研究，如旅行商问题，二次规划问题，生产调度问题等。&lt;br/&gt;  针对多孔的全局路径规划问题，改进的蚁群算法可以描述为：&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/wrb5sfyglo.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/f1v1wjfm9i.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/mganqdovp7.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  信息素更新：为了避免残留信息素过多引起残留信息淹没启发信息，在每只蚂蚁走完一步或者完成对所有 &lt;em&gt;n&lt;/em&gt;个任务点的遍历后，要对残留信息进行更新处理。&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/mb70d8850b.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/avieovlmdz.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  结合实际应用场景，本文主要在蚁群算法的基础上，考虑传统旅行商问题，不回起始点的遍历路径，融入高度信息的三维情形等三种情形考虑。&lt;/p&gt;
&lt;h2 id=&quot;二维路径计算&quot;&gt;二维路径计算&lt;/h2&gt;
&lt;p&gt;  考虑到机械臂的运动状态，如机械臂可能任意角度的斜线，或者只可以走固定角度的路线（比如3D打印机），所以本文定义两种计算两点之间距离的方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;曼哈顿距离：即两点在南北方向上的距离加上在东西方向上的距离。&lt;br/&gt;H(n) = D * (abs(n.x – goal.x ) + abs(n.y – goal.y ) )&lt;/li&gt;
&lt;li&gt;欧几里得距离：&lt;br/&gt;H(n) = D * sqrt((n.x-goal.x)^2 + (n.y-goal.y)^2)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  补充知识：&lt;a href=&quot;http://blog.csdn.net/jerry81333/article/details/52632687&quot;&gt;曼哈顿距离，欧式距离，明式距离，切比雪夫距离区别&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三维路径计算&quot;&gt;三维路径计算&lt;/h2&gt;
&lt;p&gt;  为适应应用场景的复杂性，本文简单讨论在凹凸不平的木板上打孔的路径规划问题，木板网格化后每一个网格的高度已知且不同，那么设计可以不碰撞模板的安全路径。&lt;br/&gt;  针对多个3D任务孔，首先设计启发函数，利用A*算法得到单孔与单孔之间的无碰撞最短路径作为两点之间的路径，然后应用蚁群算法，得到遍历所有孔的最短无碰撞路径。&lt;br/&gt;  三维多任务孔的路径规划可以抽象为网络最短路径问题，从抽象的数学观点来看，网络实质上是一个有权值的有向图，它由节点和连接这些节点的弧及其方向组成。如下图所示，在复杂任务应用场景下，节点是指起始点、目标点和任务点，节点之间的弧是指节点之间的路径，两点之间的路径长度可以作为弧的权值，因为节点与节点之间可以互相抵达，方向是双向的，所以求多任务孔间的最短路径就是在网络图中寻求航行代价和最小的路径。&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/5cr2v5huw8.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;求遍历所有节点的最短路径&quot;&gt;求遍历所有节点的最短路径&lt;/h2&gt;
&lt;p&gt;  根据应用场景，假设对多个木板执行一样的打孔操作，那么当对一块模板完成任务后不需要再返回起始点，可以逆着规划航路直接打孔，回到起始点后可以再完成下一木板的打孔操作，提高应用效率。这种应用情形和TSP问题不一样的地方是路径不闭环，最后不需要直接回到起始点。&lt;br/&gt;  基本蚁群算法最早是用来求网络中的最短回路的，因此可以通过增加一个连接网络输入节点与输出节点的虚边，在搜索过程中规定必须经过虚边，变遍历所有节点的最短路径问题为最短回路问题。根据蚁群算法的搜索原理，设虚边的权小于或等于网络所有边权的最小值即可符合上述要求。&lt;br/&gt;  本文引入出发点和目标点间的虚边，在搜索过程中要求必须经过虚边，变遍历所有节点的最短路径问题为最短回路问题，设虚边的权小于或等于网络所有边权的最小值。&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/mns5gchjw2.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/r2ob85up6l.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/oteiiwpxk9.jpeg?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  为客观地验证多任务孔的路径规划系统的有效性，评价路径规划系统中算法的性能和优缺点，本文针对路径规划系统的环境模型、两孔之间的路径规划和多任务孔间的路径规划算法进行验证。&lt;br/&gt;  本文主要使用Python语言对算法进行快速实现，Python语言开发效率优于C++语言，可以快速实现和验证算法的优缺点，但是Python是解释型语言，运行效率慢。C++语言一般是Python运行效率的5~10倍，所以Python语言的运行时间除以5，一般不小于C++语言的实现时间。&lt;/p&gt;
&lt;h3 id=&quot;传统旅行商问题仿真结果&quot;&gt;传统旅行商问题仿真结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/nt998zou91.png?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/td4uu6dzor.png?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;遍历所有节点的最短路径仿真结果&quot;&gt;遍历所有节点的最短路径仿真结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/1r5cj3sf6h.png?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/83mz2919eh.png?imageView2/0/w/1620&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;维的最短路径仿真结果&quot;&gt;3维的最短路径仿真结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/6k2je0kabt.png?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1255441/vnpquecbil.png?imageView2/0/w/1620&quot;/&gt;&lt;br/&gt;  本文&lt;strong&gt;提供上述仿真的源代码&lt;/strong&gt;，因为目前实现的代码是一种比较理想的场景，和实际应用场景仍有比较大的差距，希望提出建议，共同完善！&lt;a href=&quot;https://github.com/wylloong/TinyPrograms/tree/master/ACO&quot;&gt;附github上的源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  在路径规划问题抽象模型基础上，本文利用蚁群算法求解遍历所有任务孔的最短路径。基本蚁群算法在处理该类问题时会出现收敛速度慢且容易陷入局部最优解的缺陷,下一步可以对信息素和信息素挥发系数进行了改进,采用一种动态自适应调整信息素和挥发因子的蚁群算法,以求在路径规划方面获得更好的效果。&lt;br/&gt;  在“改进的智能蚁群算法在TSP问题中的应用”文献中，动态自适应调整信息素和挥发因子的策略可以描述为：传统蚁群算法中，往往会出现信息素分布过度集中在某一条路径，使得大多数蚂蚁仅通过此一条路径，导致早熟的现象;或者是信息素分布过度分散到各个路径中，使得蚂蚁搜索最优路径耗时相对较长而减缓收敛速度。本文采用自适应的信息素调节机制，使得信息素分布相对均匀，从而使算法跳离局部最优解。另外，信息素挥发系数直接关系到蚁群算法的全局搜索能力及其收敛速度，动态调整信息素挥发系数具有很明显优势，不仅可以加快收敛速度，而且能够提高搜索质量。&lt;br/&gt;  在三维路径规划中，点与点之间的最短路径实现效率相对较低，可以优化启发式函数，采用C++语言实现，提高运算速度。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 06:44:00 +0000</pubDate>
<dc:creator>DHUtoBUAA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DHUtoBUAA/p/8478671.html</dc:identifier>
</item>
<item>
<title>HashMap源码分析 - Pickle</title>
<link>http://www.cnblogs.com/wxisme/p/8474672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxisme/p/8474672.html</guid>
<description>&lt;h3&gt;Overview&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　HashMap是Java编程中最常用的数据结构之一，本文基于JDK1.8从源码角度来分析HashMap的存储结构和常用操作。HashMap实现了Map接口，Map接口的实现类还有Hashtable、LinkedListHashMap和TreeMap。具体的继承结构请参考JDK Document。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学过数据结构的同学都知道Hash表的实现方式，其实HashMap就是Hash表的一个实现。HashMap是key-value结构的，根据key的hashCode可以快速访问到key对应的value，访问操作的时间复杂度为O(1)。但HashMap在多线程的场景下并不能保证数据的一致性，如果要在多线程的场景下使用Map结构，可以考虑使用Collections工具类的synchronizedMap方法使HashMap变为线程安全的，同时也可以考虑使用ConcurrentHashMap。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那HashMap和其他几个Map接口的实现类有什么区别呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和Hashtable的区别：Hashtable是线程安全的，是JDK的遗留类，内部实现使用synchronized关键字对方法加锁，效率和并发性不好。在线程安全的场景下可以使用ConcurrentHashMap替代，ConcurrentHashMap内部实现使用了分段锁，效率和并发性都要比Hashtable好。另一个区别是HashMap可以有有个null键和多个null值，Hashtable是不可以的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和LinkedHashMap的区别：LinkedHashMap是Map的实现类同时也是HashMap子类，与HashMap不同的地方在于LinkedHashMap底层使用链表实现，因此LinkedHashMap能够维护记录插入顺序，能够按次序访问，而HashMap的key是无序的，这一点和HashSet一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和TreeMap的区别：TreeMap实现了Map的同时也实现了SortedMap接口，底层基于RB-Tree（红黑树）实现，TreeMap能够根据自然序或者给定的比较器维护记录的存储顺序。需要注意的是，在使用TreeMap的时候key对象需要实现Comparable接口或者在构造TreeMap时传入自定义Comparator，否则会在运行时抛出java.lang.ClassCastException异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在使用Map时，需要确保key对象是不可变的，也就是说key的hash是不会改变的，如果key的hash发生变化，就会出现key访问不到value的情况。需要保证equals()方法和hashCode()方法所描述的对象是一致的，即两个对象的equals()方法返回true那么这两个对象的hashCode()方法也要返回相同的值。这也是重写equals()方法通常也要重写hashCode()方法的原因。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;存储结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　HashMap的结构是数组、链表和RB-Tree的组合，总体来说是数组用来进行hash寻址，用链表存储hash冲突的Entry，在冲突多时用RB-Tree来提高存取效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/735119/201802/735119-20180226183059598-2041272010.png&quot; alt=&quot;&quot;/&gt;　　在HashMap的结构中存储的是key-value实体Entry&amp;lt;K,V&amp;gt;，更准确的说是存储的Node&amp;lt;K,V&amp;gt;，Node&amp;lt;K,V&amp;gt;是HashMap的一个静态内部类，实现了Map.Entry接口。是key-value的包装类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {...&lt;/span&gt;&lt;span&gt;}

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; K getKey()        { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V getValue()      { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String toString() { &lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; +&lt;span&gt; value; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Objects.hashCode(key) ^&lt;span&gt; Objects.hashCode(value);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V setValue(V newValue) {...&lt;/span&gt;&lt;span&gt;}

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry) {
                Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;)o;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp;&lt;span&gt;
                    Objects.equals(value, e.getValue()))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;HashMap中有一个Node[]类型的字段，用来当做hash桶，Node中hash字段用来快速定位hash桶的索引。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] table; //（transient关键字作用是在序列化时过滤掉此字段）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;除此之外，HashMap还有几个比较重要的字段。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HashMap中所有key-value实体的集合&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前HashMap的大小（k-v实体个数）&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个HashMap结构变化的次数&lt;/span&gt;
&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在下次扩容之前能容纳k-v实体的最大值，threshold=(capacity * load factor)。&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载因子&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; loadFactor;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;初始化和扩容&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;HashMap的初始化时把HashMap所需要的数据结构和字段构造出来，并给定初始字段值。比如构造Node数组，设定初始化容量和负载因子等。这些可以通过HashMap的构造方法来实现。如果构造HashMap时不指定initialCapacity和loadFactor就会使用默认值，initialCapacity的默认值是16，HashMap的最大容量是2^30；默认的loadFactor值为0.75，含义是在存储数量达到当前Node[]数组长度的75%时进行下一次扩容。默认0.75也是hash冲突和空间利用率之间的权衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注意，loadFactor的值是可以大于1的，因为threshold=capacity * load factor，这里的capacity是Node[]数组的长度，除Node[]数组外使用链表和红黑树来存储冲突的记录，所以理论上整个HashMap对象存储的记录数可以大于capacity，也就是说size并不被capacity所限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当HashMap存储的记录数达到threshold=capacity * load factor后就要进行一次扩容，把容量扩大到之前的2倍，具体方法使创建一个新的长度为原来2倍的Node[]数组替换掉之前的Node[]数组。替换数组并不是简单的拷贝而是要把记录分散在新的数组中。在JDK1.8以前是采用rehash的方法，JDK1.8对此做了优化，避免了重新计算hash而且能将记录均匀的分散在新的Node[]数组中。具体做法是，在Node[]数组扩容到原来的2倍时，key的hash长度在原来的基础上多出一位，那么这一位可以是0也可以是1，当是0时索引不变，1时索引变为原索引+原容量。因为0和1是可以认为是随机的所以均匀分布的效果和rehash理论上是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　来欣赏一下JDK1.8优化后的resize代码，简直是艺术品。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超过2^30就不能再扩容了，把threshold设置为int最大值，就不会再扩容。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
                threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有超过最大值就扩容到原先的2倍&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;span&gt;
                     oldCap &lt;/span&gt;&amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
                newThr &lt;/span&gt;= oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次初始化并指定了容量&lt;/span&gt;
            newCap =&lt;span&gt; oldThr;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次初始化没有指定容量，使用默认容量16&lt;/span&gt;
            newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
            newThr &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算新的threshold&lt;/span&gt;
            &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
            newThr &lt;/span&gt;= (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;span&gt;
                      (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
        }
        threshold &lt;/span&gt;=&lt;span&gt; newThr;
        @SuppressWarnings({&lt;/span&gt;&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node[newCap];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的大桶&lt;/span&gt;
        table =&lt;span&gt; newTab;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把记录移动到新的桶中，并释放原有记录的引用。&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
                Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    oldTab[j] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有冲突直接赋值&lt;/span&gt;
                        newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; TreeNode)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是红黑树节点，拆分&lt;/span&gt;
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是链表节点，保留链表顺序&lt;/span&gt;
                        Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
                        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                            next &lt;/span&gt;=&lt;span&gt; e.next;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增高位为0，索引位置不变&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    loHead &lt;/span&gt;=&lt;span&gt; e;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    loTail.next &lt;/span&gt;=&lt;span&gt; e;
                                loTail &lt;/span&gt;=&lt;span&gt; e;
                            }
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果新增高位为1，索引位置变为原索引+oldCap&lt;/span&gt;
                            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    hiHead &lt;/span&gt;=&lt;span&gt; e;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    hiTail.next &lt;/span&gt;=&lt;span&gt; e;
                                hiTail &lt;/span&gt;=&lt;span&gt; e;
                            }
                        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放置原索引位置&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            loTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            newTab[j] &lt;/span&gt;=&lt;span&gt; loHead;
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放置原索引+oldCap位置&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            hiTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            newTab[j &lt;/span&gt;+ oldCap] =&lt;span&gt; hiHead;
                        }
                    }
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;put()方法分析&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;弄清楚了HashMap的结构和扩容机制，put()和get()操作直接按照步骤来分析就可以了。put()操作的主要是如下几个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先判断Node[]数组table是否为空或null，如果是空那么进行一次resize，这次resize只是起到了一次初始化的作用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根据key的值计算hash得到在table中的索引i，如果table[i]==null则添加新节点到table[i]，然后判断size是否超过了容量限制threshold，如果超过进行扩容。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果在上一步table[i]不为null时，判断table[i]节点是否和当前添加节点相同（这里使用hash和equals判断，因此需要保证hashCode()方法和equals()方法描述的一致性），如果相同则覆盖该节点的value。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果上一步判断table[i]和当前节点不同，那么判断table[i]是否为红黑树节点，如果是红黑树节点则在红黑树中添加此key-value。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果上一步判断table[i]不是红黑树节点则遍历table[i]链表，判断链表长度是否超过8，如果超过则转为红黑树存储，如果没有超过则在链表中插入此key-value。（jdk1.8以前使用头插法插入）。在遍历过程中，如果发现有相同的节点（比较hash和equals）就覆盖value。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;维护modCount和size等其他字段。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入key的hash值，对hashCode值做位运算&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果tab为null，则通过resize初始化&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
            n &lt;/span&gt;= (tab =&lt;span&gt; resize()).length;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算key的索引，如果为当前位置为null，直接赋值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tab[i] &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前位置不为null&lt;/span&gt;
            Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果相同直接覆盖&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                e &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是红黑树节点，添加节点到红黑树，如果过程中发现相同节点则覆盖&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                e &lt;/span&gt;= ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是链表节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        p.next &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;                            treeifyBin(tab, hash);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到相同节点则覆盖&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    p &lt;/span&gt;=&lt;span&gt; e;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆盖&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
                V oldValue =&lt;span&gt; e.value;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    e.value &lt;/span&gt;=&lt;span&gt; value;
                afterNodeAccess(e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构变化次数+1&lt;/span&gt;
        ++&lt;span&gt;modCount;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果size超过最大限制，扩容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
            resize();
        afterNodeInsertion(evict);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;get()方法分析&lt;/h3&gt;
&lt;p&gt;　　明确了put()方法，get()方法的分析就变得非常容易了，首先看一下如何通过hash确定key在桶中的索引位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hash(Object key) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdk1.8 &amp;amp; jdk1.7&lt;/span&gt;
     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h = key.hashCode() 为第一步 取hashCode值
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h ^ (h &amp;gt;&amp;gt;&amp;gt; 16)  为第二步 高位参与运算&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdk1.8已经把这个方法省略了，但是在访问时直接使用这个计算策略。&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; indexFor(&lt;span&gt;int&lt;/span&gt; h, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; h &amp;amp; (length-1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三步 取模运算&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下就是get()方法的具体分析：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入key的hash&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; K k;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里访问(n - 1) &amp;amp; hash其实就是jdk1.7中indexFor方法的作用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
            (first &lt;/span&gt;= tab[(n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断桶索引位置的节点是不是相同（通过hash和equals判断），如果相同返回此节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always check first node&lt;/span&gt;
                ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否是红黑树节点，如果是查找红黑树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (first &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是链表，遍历链表&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不存在返回null&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;补充&lt;/h3&gt;
&lt;p&gt; 　　除以上的分析以外，HashMap还有许多其他方法，包括判空、删除、清空、替换、遍历以及JDK1.8新增的函数式语法和Lambda表达式的内容。代码总行数多达两千多行，如果感兴趣或遇到相应问题可以具体分析。已经了解了HashMap的存储结构和关键操作的步骤，再去分析其他方法就比较容易了。&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;　　从以上的对HashMap源码的分析，可以得出一些使用上的技巧和有用的结论。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HashMap不是线程安全的，多线程的场景推荐使用ConcurrentHashMap。&lt;/li&gt;
&lt;li&gt;JDK1.8对HashMap做了大量优化，值得尝试。&lt;/li&gt;
&lt;li&gt;在初始化时最好能够给出估算的容量大小，避免频繁扩容影响使用效率。&lt;/li&gt;
&lt;li&gt;负载因子是可以修改的，但是0.75是容量和冲突之间的权衡，如果不是目的特别明确不要轻易修改。&lt;/li&gt;
&lt;li&gt;重写equals()方法的同时也要重写hashCode()方法。&lt;/li&gt;
&lt;li&gt;HashMap源码写的真棒:）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　参考资料：&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;Java 8系列之重新认识HashMap&quot; href=&quot;https://tech.meituan.com/java-hashmap.html&quot; target=&quot;_blank&quot;&gt;Java 8系列之重新认识HashMap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;Java Platform, Standard Edition 8 API Specification&quot; href=&quot;https://docs.oracle.com/javase/8/docs/api/index.html&quot; target=&quot;_blank&quot;&gt;Java™ Platform, Standard Edition 8 API Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　java.util.HashMap源码&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Feb 2018 06:25:00 +0000</pubDate>
<dc:creator>Pickle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wxisme/p/8474672.html</dc:identifier>
</item>
<item>
<title>Taurus.MVC 2.2.3.4 ：WebAPI 实现权限控制认证（及功能增强说明） - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/8476427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/8476427.html</guid>
<description>&lt;p&gt;前两天，当我还在老家收拾行旅，准备回广州，为IT连的创业再战365天时，&lt;/p&gt;
&lt;p&gt;有网友扣上问：Taurus.MVC中如何实现认证和权限控制，最好能做个小例子。&lt;/p&gt;
&lt;p&gt;我一不小心回了句：等回广州我再写篇文章......&lt;/p&gt;
&lt;p&gt;然后，今天就来补文章了〜〜〜〜&lt;/p&gt;

&lt;p&gt;写文之前，又提前花了点时间，把Nuget的Package升级了一下，和源码版本做了下同步。&lt;/p&gt;
&lt;p&gt;通常源码的版本都会比Nuget包的靠前一个小版本：&lt;/p&gt;
&lt;p&gt;目前：&lt;a href=&quot;https://www.nuget.org/packages/Taurus.MVC/&quot; target=&quot;_blank&quot;&gt;Taurus.MVC&lt;/a&gt; 升级到：V2.2.3.4 （&lt;a href=&quot;https://www.nuget.org/packages/cyqdata/&quot; target=&quot;_blank&quot;&gt;CYQ.Data&lt;/a&gt; 同步升级到：V5.7.8.3）&lt;/p&gt;
&lt;p&gt;最近版本的更新内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
V2.&lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;(&lt;span&gt;2017&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;15&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：增加CheckFormat方法【支持参数为空或正则验证】

V2.&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;(&lt;span&gt;2017&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：增加方法参数的支持(兼容常规webapi的使用方法)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;：CYQ.Data同时升级到V5.&lt;span&gt;7.7&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

V2.&lt;/span&gt;&lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;(&lt;span&gt;2017&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;,&lt;span&gt;2017&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; :增强跨域支持
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;：修正Query&amp;lt;T&amp;gt;&lt;span&gt;(aaa,defaultValue)的默认取的取值顺序问题。
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：增加EndInvode事件和BenginInvode的事件执行顺序调整。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;：CYQ.Data同时升级到V5.&lt;span&gt;7.8&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比如对于以下请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
itlinks.cn/user?uid=&lt;span&gt;666&lt;/span&gt;&lt;span&gt; 
itlinks.cn&lt;/span&gt;/user/uid/&lt;span&gt;666&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常规获取参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; uid = Query&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;兼容性写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid)
        {
 
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时，兼容参数还可以很复杂，比如这种：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetData(List&amp;lt;AB&amp;gt; unList,&lt;span&gt;string&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;?&lt;span&gt; b,AB ab)
        {
            Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your data A:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + unList[&lt;span&gt;0&lt;/span&gt;].A+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; your data B:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + unList[&lt;span&gt;0&lt;/span&gt;].B, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传递&lt;span&gt;对应的Post的Json可能是这样的(手打的，就省了双引号了)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{ uiList:[{a:&lt;span&gt;1&lt;/span&gt;,b:&lt;span&gt;1&lt;/span&gt;} , {a:&lt;span&gt;2&lt;/span&gt;,b:&lt;span&gt;2&lt;/span&gt;}]  ,a:&lt;span&gt;1 &lt;/span&gt;,b:&lt;span&gt;2 &lt;/span&gt;,ab:{a:&lt;span&gt;3&lt;/span&gt;,b:&lt;span&gt;3&lt;/span&gt;}}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先看：IT连的后端WebApi解决方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201802/17408-20180226232540464-779301042.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再说：解决方案的创建步骤：&lt;/p&gt;
&lt;h2&gt;1：新建空Web应用程序。&lt;/h2&gt;
&lt;p&gt;即上图的：ITLinks.API ，WebAPI不需要界面，该应用程序用于存放各种Controller即可。&lt;/p&gt;
&lt;h2&gt;2：在项目的引用中用Nuget包管理引入Taurus.MVC。&lt;/h2&gt;
&lt;p&gt;Nuget包管理会自动在Web.Config中加入以下相关配置。&lt;/p&gt;
&lt;p&gt;需要把：key=“Taurus.Controllers” 项的值：改成控制器存放的项目名称（一般名称和最终生成的dll同名）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201802/17408-20180226234143770-1058711577.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Taurus.MVC被引用后，仅包含两个dll，Taurus.Core和CYQ.Data。&lt;/p&gt;
&lt;p&gt;IT连的解决方案中，对这两个dll使用了源码项目（方便于作者本人做调试或扩展功能）。&lt;/p&gt;
&lt;h2&gt;3：项目中新建各种Controller（创建请求规则）。&lt;/h2&gt;
&lt;p&gt;以IT连中的黑名单功能为例，控制器应继承自Taurus.Core.Controller：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（这里要注意一下构造函数，将自身this传递给逻辑类的构造函数）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ITLinks.API
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlacklistController : Taurus.Core.Controller
    {
        BlacklistLogic blacklist;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BlacklistController()
        {
            blacklist &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BlacklistLogic(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取黑名单
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [Token]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetList()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; blacklist.GetList();
            Write(result);
        }
        [Token]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Set()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; blacklist.Set();
            Write(result);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因Web.Config中的路由类型配置为1，即路由方式为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/控制器名称/方法名/参数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即创建了以下两个路径请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/blacklist/&lt;span&gt;getlist
&lt;/span&gt;/blacklist/&lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;理论上来说，在可以方法里写业务代码，并调用Write方法输出json格式的字符串即完成了。&lt;/p&gt;
&lt;p&gt;不过，实际项目中，需要清晰一些的规划：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IT连的项目中，控制器被规划用来定义路由及权限等简单设定（不包括具体的业务代码）。

把业务代码分离到ITLinks.Logic项目中处理了：

业务逻辑类继承自：Taurus.Core.LogicBase（继承后可复用Taurus.Core.Controller中的常用方法，如Query&lt;/span&gt;&amp;lt;T&amp;gt;(xxx)获取参数）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如：IT连黑名单列表中的黑名单逻辑源码示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（这里要注意一下构造函数，定义继承父类接收控制器参数的构造函数方法）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201802/17408-20180227000051750-2139275782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于IT连的的业务逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;一部分：独立到解决方案ITLinks.CommonLogic中。

用于功能的复用（在ASP.NET Aries的管理后台和此处的WebApi中复用同一份代码）

一部分：独立到解决方案ITlinks.Aop中。

用于一些第三方的消息处理。&lt;p&gt;这些，就不细讲了~~~直接飘过！&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，接下来，我们将重点聚焦在权限安全认证这一块：&lt;/p&gt;

&lt;p&gt;写此之前，又扫看了一下之前写的关于Taurus.MVC的文章，发现一共才五篇，其中：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1&quot; class=&quot;entrylistItemTitle&quot; href=&quot;http://www.cnblogs.com/cyq1162/p/6069020.html&quot;&gt;Taurus.MVC 2.0 开源发布：WebAPI开发教程&lt;/a&gt; ，步骤五：有简单提到对于权限控制这一块的处理，只是不够详尽。&lt;/p&gt;
&lt;p&gt;本文，就以 &lt;a href=&quot;http://www.itlinks.cn/&quot; target=&quot;_blank&quot;&gt;IT连&lt;/a&gt; App的后端 WebAPI 的逻辑来给大伙做进一步细致说明：&lt;/p&gt;
&lt;p&gt;首先：对于继承自Taurus.Core.Controller的控制器，都拥有以下几个可重写的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController : Taurus.Core.Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CheckToken() {&lt;/span&gt;&lt;span&gt; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BeforeInvoke(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; methodName) {&lt;/span&gt;&lt;span&gt; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EndInvoke(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; methodName) { }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及三个权限相关的特性[Token]、[HttpGet]、[HttpPost]：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Token]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController : Taurus.Core.Controller
    {
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Get()
        { }
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Post()
        { }
    ｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特性若放在类上，即对所有方法都生效！&lt;/p&gt;
&lt;p&gt;整个的调用顺序为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：调用CheckToken（如果方法标识[Token]属性）【&lt;span&gt;&lt;strong&gt;如果返回false则中止以下执行，可人工干预&lt;/strong&gt;&lt;/span&gt;】
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：检测Get或Post（如果方法标识[HttpGet]或[HttpPost]属性）【&lt;span&gt;&lt;strong&gt;如果返回false则中止以下执行，系统自动控制&lt;/strong&gt;&lt;/span&gt;】
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;：调用BeforeInvoke方法【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;如果返回false则中止以下执行，可人工干预&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;：调用我们定义的方法，如Get或Post方法。
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;5&lt;/span&gt;：调用EndInvoke方法。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，再以IT连中的请求为例讲述流程：&lt;/p&gt;
&lt;h3&gt;1：用户首次打开IT连App时，获取App的版本更新及配置信息：&lt;/h3&gt;
&lt;p&gt;此时不需权限，一切正常定义，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SysController : Controller
    {&lt;/span&gt;&lt;span&gt;
        SysLogic sysLogic &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SysController()
        {
            sysLogic &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SysLogic(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取配置信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetConfig()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg =&lt;span&gt; sysLogic.GetConfig();
            Write(msg);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; App版本升级
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg =&lt;span&gt; sysLogic.CheckAppVersion();
            Write(msg);
        }
    ｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2：用户登陆或注册App：&lt;/h3&gt;
&lt;p&gt;登陆注册也不需要权限验证，方法依旧如常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : Controller
    {
        UserLogic user;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserController()
        {
            user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UserLogic(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; user.Register();
            Write(result);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Login()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; user.Login();
            Write(result);
        }&lt;/span&gt;&lt;span&gt;
    ｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过，在登陆或注册成功后，需要创建一个Token返回给App客端存档：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.12&quot;&gt;
&lt;pre readability=&quot;4.6&quot;&gt;
&lt;span&gt;如何创建Token：

可以把用户的基本固定又不重要的信息串在一起，然后加下密就可以了；

比如：（用户ID&lt;/span&gt;+注册时间+用户名+有效日期）=》加密成：abfabcbcdxxabfabccdc&lt;p&gt;具体代码可参考 &lt;a href=&quot;https://github.com/cyq1162/Aries&quot; target=&quot;_blank&quot;&gt;ASP.NET Aries&lt;/a&gt; 框架中的 &lt;a href=&quot;https://github.com/cyq1162/Aries/blob/master/Aries.DevFramework/Aries.Core/Auth/UserAuth.cs&quot; target=&quot;_blank&quot;&gt;UserAuth.cs&lt;/a&gt; 中的 GetAuthToken 方法
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3：用户进入主界面，或再次打开App时：&lt;/h3&gt;
&lt;p&gt;由于用户在注册或登陆时，已经存档了Token在客户端，只要之后的请求，都带上这个Token即可。&lt;/p&gt;
&lt;p&gt;比如用户获取自身的完整信息，或提交用户反馈是需要权限的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeedbackController : Controller
    {
        FeedbackLogic feedbackLogic &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FeedbackController()
        {
            feedbackLogic &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FeedbackLogic(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CheckToken()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; userid = UserAuth.UserID;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从用户传来的Token中解密获取数据&lt;/span&gt;
            &lt;span&gt;bool&lt;/span&gt; result = !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(userid) &amp;amp;&amp;amp; UserAuth.UserID.Length == &lt;span&gt;36&lt;/span&gt; &amp;amp;&amp;amp; UserAuth.RegTime.Length == &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result)
            {
                Write(LangConst.EC_10000, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回Token验证失败&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户反馈建议
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [Token]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Set()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; feedbackLogic.Set();
            Write(result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Set方法，需要基本的身份认证，加上了[Token]特性；&lt;/p&gt;
&lt;p&gt;同时：需要在CheckToken方法写代码来检测用户带过来的Token是否合法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.76404494382&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：从请求数据或&lt;strong&gt;请求头&lt;/strong&gt;中获取（Token字符串）

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：解密，较验格式及是否过期。

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;：根据解密的结果，来返回true或false。
&lt;/pre&gt;
&lt;pre&gt;
具体代码仍可参考 &lt;a href=&quot;https://github.com/cyq1162/Aries&quot; target=&quot;_blank&quot;&gt;ASP.NET Aries&lt;/a&gt; 框架中的 &lt;a href=&quot;https://github.com/cyq1162/Aries/blob/master/Aries.DevFramework/Aries.Core/Auth/UserAuth.cs&quot; target=&quot;_blank&quot;&gt;UserAuth.cs&lt;/a&gt; 中UserID属性是怎么被反解出来的。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就完成了基本的权限认证。&lt;/p&gt;

&lt;p&gt;鉴于检测Token合法性的代码是一样的，业务控制器可能不少，因此需要有统一的地方：&lt;/p&gt;
&lt;p&gt;Taurus.MVC定义了三个全局的方法，位于DefaultController中，当然这个控制器文件默认是不存在的，需要自己新建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultController : Controller
    {
       
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CheckToken(IController controller, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; methodName)
        {
            //将Token验证合法性的代码写在这全局的地方，对所有的Controller都生效。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;             string userid = UserAuth.UserID;&lt;br/&gt;             bool result = !string.IsNullOrEmpty(userid) &amp;amp;&amp;amp; UserAuth.UserID.Length == 36 &amp;amp;&amp;amp; UserAuth.RegTime.Length == 8;&lt;br/&gt;             if (!result)&lt;br/&gt;             {&lt;br/&gt;                    controller.Write(LangConst.EC_10000, false);&lt;br/&gt;             }&lt;br/&gt;             return result;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BeforeInvoke(IController controller, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; methodName)
        {
            
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; EndInvoke(IController controller, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; methodName)
        {

        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DefaultController的全局方法的优先级：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;这三个static方法的优先级，低于Controller自身同名的实例方法；

即如果某个Controller已经重写了CheckToken实例方法，则全局的CheckToken不会被调 用，其它两个方法亦同。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DefaultController是Taurus.MVC的特殊的控制器，其特殊在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：当寻找的控制器不存在时，都会定位到DefaultController中寻找，如果DefaultController也没有，则抛出异常。

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;：如果方法在DefaultController中找不到时，则会调用Default方法（Taurus.Core.Controller有默认Default方法，可被重写）。&lt;p&gt;3：三个全局的统一方法，被命运安排在这里。
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你值的拥有！&lt;/p&gt;
&lt;p&gt;接下来又得把线程切回去继续写IT连创业系列、以及IOS的Sagit.Framework开发框架系列了！ &lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 06:13:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/8476427.html</dc:identifier>
</item>
<item>
<title>《InsideUE4》UObject（六）类型系统代码生成重构-UE4CodeGen_Private - fjz13</title>
<link>http://www.cnblogs.com/fjz13/p/8478532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fjz13/p/8478532.html</guid>
<description>&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;读的不如写的快&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在之前的&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25098685&quot;&gt;《InsideUE4》UObject（四）类型系统代码生成&lt;/a&gt;和&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26019216&quot;&gt;《InsideUE4》UObject（五）类型系统收集&lt;/a&gt;章节里，我们介绍了UE4是如何根据我们的代码和元标记生成反射代码，并在Main函数调用之前，利用静态变量的初始化来收集类型的元数据信息。经过了我这么长时间的拖更……也经过了Epic这么长时间的版本更替，把UE从4.15.1进化到了4.18.3，自然的，CoreUObject模块也进行了一些改进。本文就先补上一个关于代码生成的改进：在UE4.17（20170722）的时候进行的UObjectGlobals.h.cpp重构，优化了代码生成的内容和组织形式。&lt;/p&gt;
&lt;h2 id=&quot;旧版本代码生成&quot;&gt;旧版本代码生成&lt;/h2&gt;
&lt;p&gt;首先来看一下之前的版本的代码元数据生成：&lt;/p&gt;
&lt;h3 id=&quot;uenum的生成&quot;&gt;UEnum的生成：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//测试代码&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma once&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;UObject/NoExportTypes.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;MyEnum.generated.h&quot;&lt;/span&gt;
UENUM(BlueprintType)
&lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; EMyEnum : uint8
{
    MY_Dance    UMETA(DisplayName = &lt;span class=&quot;st&quot;&gt;&quot;Dance&quot;&lt;/span&gt;),
    MY_Rain     UMETA(DisplayName = &lt;span class=&quot;st&quot;&gt;&quot;Rain&quot;&lt;/span&gt;),
    MY_Song     UMETA(DisplayName = &lt;span class=&quot;st&quot;&gt;&quot;Song&quot;&lt;/span&gt;)
};

&lt;span class=&quot;co&quot;&gt;//生成代码节选(Hello.genrated.cpp)：&lt;/span&gt;
ReturnEnum = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;(EC_InternalUseOnlyConstructor, Outer, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum&quot;&lt;/span&gt;), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());&lt;span class=&quot;co&quot;&gt;//直接创建该UEnum对象&lt;/span&gt;
TArray&amp;lt;TPair&amp;lt;FName, uint8&amp;gt;&amp;gt; EnumNames;&lt;span class=&quot;co&quot;&gt;//设置枚举里的名字和值&lt;/span&gt;
EnumNames.Add(TPairInitializer&amp;lt;FName, uint8&amp;gt;(FName(TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum::MY_Dance&quot;&lt;/span&gt;)), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;));
EnumNames.Add(TPairInitializer&amp;lt;FName, uint8&amp;gt;(FName(TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum::MY_Rain&quot;&lt;/span&gt;)), &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
EnumNames.Add(TPairInitializer&amp;lt;FName, uint8&amp;gt;(FName(TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum::MY_Song&quot;&lt;/span&gt;)), &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
EnumNames.Add(TPairInitializer&amp;lt;FName, uint8&amp;gt;(FName(TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum::MY_MAX&quot;&lt;/span&gt;)), &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;));   &lt;span class=&quot;co&quot;&gt;//添加一个默认的MAX字段&lt;/span&gt;
ReturnEnum-&amp;gt;SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
ReturnEnum-&amp;gt;CppType = TEXT(&lt;span class=&quot;st&quot;&gt;&quot;EMyEnum&quot;&lt;/span&gt;);
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA   &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//设置元数据&lt;/span&gt;
UMetaData* MetaData = ReturnEnum-&amp;gt;GetOutermost()-&amp;gt;GetMetaData();
MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;BlueprintType&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyEnum.h&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MY_Dance.DisplayName&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Dance&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MY_Rain.DisplayName&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Rain&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MY_Song.DisplayName&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Song&quot;&lt;/span&gt;));
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;ustruct的生成&quot;&gt;UStruct的生成：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//测试代码：&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma once&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;UObject/NoExportTypes.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;MyStruct.generated.h&quot;&lt;/span&gt;
USTRUCT(BlueprintType)
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; HELLO_API FMyStruct
{
    GENERATED_USTRUCT_BODY()
    UPROPERTY(BlueprintReadWrite)
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Score;
};
&lt;span class=&quot;co&quot;&gt;//生成代码节选(Hello.genrated.cpp)：&lt;/span&gt;
ReturnStruct = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;(EC_InternalUseOnlyConstructor, Outer, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyStruct&quot;&lt;/span&gt;), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UScriptStruct::TCppStructOps&amp;lt;FMyStruct&amp;gt;, EStructFlags(&lt;span class=&quot;bn&quot;&gt;0x00000201&lt;/span&gt;));&lt;span class=&quot;co&quot;&gt;//直接创建UScriptStruct对象&lt;/span&gt;
UProperty* NewProp_Score = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Score&quot;&lt;/span&gt;), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Score, FMyStruct), &lt;span class=&quot;bn&quot;&gt;0x0010000000000004&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//直接关联相应的Property信息&lt;/span&gt;
ReturnStruct-&amp;gt;StaticLink(); &lt;span class=&quot;co&quot;&gt;//链接&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA   &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//元数据&lt;/span&gt;
UMetaData* MetaData = ReturnStruct-&amp;gt;GetOutermost()-&amp;gt;GetMetaData();
MetaData-&amp;gt;SetValue(ReturnStruct, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;BlueprintType&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(ReturnStruct, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyStruct.h&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(NewProp_Score, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Category&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyStruct&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(NewProp_Score, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyStruct.h&quot;&lt;/span&gt;));
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;uclass的生成&quot;&gt;UClass的生成：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//测试代码：&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#pragma once&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;UObject/NoExportTypes.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;MyClass.generated.h&quot;&lt;/span&gt;
UCLASS(BlueprintType)
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HELLO_API UMyClass : &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; UObject
{
    GENERATED_BODY()
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    UPROPERTY(BlueprintReadWrite)
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Score;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    UFUNCTION(BlueprintCallable, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CallableFunc();    &lt;span class=&quot;co&quot;&gt;//C++实现，蓝图调用&lt;/span&gt;
    UFUNCTION(BlueprintNativeEvent, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; NativeFunc();  &lt;span class=&quot;co&quot;&gt;//C++实现默认版本，蓝图可重载实现&lt;/span&gt;
    UFUNCTION(BlueprintImplementableEvent, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ImplementableFunc();   &lt;span class=&quot;co&quot;&gt;//C++不实现，蓝图实现&lt;/span&gt;
};
&lt;span class=&quot;co&quot;&gt;//生成代码节选(Hello.genrated.cpp)：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//添加子字段&lt;/span&gt;
OuterClass-&amp;gt;LinkChild(Z_Construct_UFunction_UMyClass_CallableFunc());
OuterClass-&amp;gt;LinkChild(Z_Construct_UFunction_UMyClass_ImplementableFunc());
OuterClass-&amp;gt;LinkChild(Z_Construct_UFunction_UMyClass_NativeFunc());
PRAGMA_DISABLE_DEPRECATION_WARNINGS
UProperty* NewProp_Score = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt;(EC_InternalUseOnlyConstructor, OuterClass, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Score&quot;&lt;/span&gt;), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Score, UMyClass), &lt;span class=&quot;bn&quot;&gt;0x0010000000000004&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//添加属性&lt;/span&gt;
PRAGMA_ENABLE_DEPRECATION_WARNINGS
&lt;span class=&quot;co&quot;&gt;//添加函数名字映射&lt;/span&gt;
OuterClass-&amp;gt;AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UMyClass_CallableFunc(), &lt;span class=&quot;st&quot;&gt;&quot;CallableFunc&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 774395847&lt;/span&gt;
OuterClass-&amp;gt;AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UMyClass_ImplementableFunc(), &lt;span class=&quot;st&quot;&gt;&quot;ImplementableFunc&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 615168156&lt;/span&gt;
OuterClass-&amp;gt;AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UMyClass_NativeFunc(), &lt;span class=&quot;st&quot;&gt;&quot;NativeFunc&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 3085959641&lt;/span&gt;
OuterClass-&amp;gt;StaticLink();
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA   &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//元数据&lt;/span&gt;
UMetaData* MetaData = OuterClass-&amp;gt;GetOutermost()-&amp;gt;GetMetaData();
MetaData-&amp;gt;SetValue(OuterClass, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;BlueprintType&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(OuterClass, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;IncludePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(OuterClass, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(NewProp_Score, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;Category&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyClass&quot;&lt;/span&gt;));
MetaData-&amp;gt;SetValue(NewProp_Score, TEXT(&lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;), TEXT(&lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt;));
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以见到，以往的方式在生成的代码里有很多的“套路化”的SetValue、Add段落，都是用来添加字段属性、函数和元数据的信息。虽然这些代码也是UHT程序化生成的，不用人手工操作，看起来也只能说是略有瑕疵，但要是从精益求精的角度上来说，缺点有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本着DRY(Don't Repeat Yourself)原则，这些模式化的代码在每一个反射文件里也都会重复N次，增大了代码的体积。&lt;/li&gt;
&lt;li&gt;代码文件的膨胀，自然会增加编译的时间消耗。&lt;/li&gt;
&lt;li&gt;即使是程序生成的代码，有时也难免要阅读Debug，大量的模式代码噪音显然降低了关键代码的可读性和课调试性。&lt;/li&gt;
&lt;li&gt;UHT的编写维护，更多的代码量生成，自然会带来UHT工具代码的编写量增长，增大了编写维护的成本；代码越多，Bug越多；UHT要输出更多的代码，自然效率会降低，从而导致总编译时间的消耗增长。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;ue4codegen_private&quot;&gt;UE4CodeGen_Private&lt;/h2&gt;
&lt;p&gt;改善方式是显然易得的，同一件事不要做两遍。既然到处都是这些胶水代码，那就把这些代码封装成函数；既然到处都散布着这些元数据信息数据，那就把这些数据封装成结构作为函数的参数。&lt;br/&gt;所以，UE在4.17的时候，在UObjectGlobals.h.cpp里增加了一个UE4CodeGen_Private的命名空间，里面添加了一些生成函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.h&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
    COREUOBJECT_API &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUFunction(UFunction*&amp;amp; OutFunction, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FFunctionParams&amp;amp; Params);
    COREUOBJECT_API &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUEnum(UEnum*&amp;amp; OutEnum, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FEnumParams&amp;amp; Params);
    COREUOBJECT_API &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUScriptStruct(UScriptStruct*&amp;amp; OutStruct, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FStructParams&amp;amp; Params);
    COREUOBJECT_API &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUPackage(UPackage*&amp;amp; OutPackage, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FPackageParams&amp;amp; Params);
    COREUOBJECT_API &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUClass(UClass*&amp;amp; OutClass, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FClassParams&amp;amp; Params);
}

&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.cpp&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConstructUProperty(UObject* Outer, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;*&amp;amp; PropertyArray, int32&amp;amp; NumProperties);
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; AddMetaData(UObject* Object, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam* MetaDataArray, int32 NumMetaData);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数的名字含义显而易见，都是用来构造一些元数据结构：UEnum、UFunction、UProperty、UScriptStruct、UClass、UPackage和添加一些元数据（这些结构后续会详解）。第一个参数都是指针的引用，所以是用来向外构造一个对象用指针返回的；关键的是在第二个参数：都是一个个XXXParams参数，用来传进去信息的。&lt;br/&gt;所以我们继续查看这些参数信息：&lt;/p&gt;
&lt;h3 id=&quot;uenum的params和生成&quot;&gt;UEnum的Params和生成：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.h&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA   &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//只有在编辑器模式下，才保留元数据信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FMetaDataPairParam   &lt;span class=&quot;co&quot;&gt;//元数据对&lt;/span&gt;
    {
        &lt;span class=&quot;co&quot;&gt;//例：MetaData-&amp;gt;SetValue(ReturnEnum, TEXT(&quot;MY_Song.DisplayName&quot;), TEXT(&quot;Song&quot;));&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* NameUTF8;   &lt;span class=&quot;co&quot;&gt;//元数据的键值对信息&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* ValueUTF8;
    };
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FEnumeratorParam     &lt;span class=&quot;co&quot;&gt;//枚举项&lt;/span&gt;
    {
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*               NameUTF8; &lt;span class=&quot;co&quot;&gt;//枚举项的名字&lt;/span&gt;
        int64                     Value;    &lt;span class=&quot;co&quot;&gt;//枚举项的值&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam* MetaDataArray;    &lt;span class=&quot;co&quot;&gt;//一个枚举项依然可以包含多个元数据键值对&lt;/span&gt;
        int32                     NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
    
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FEnumParams  &lt;span class=&quot;co&quot;&gt;//枚举参数&lt;/span&gt;
    {
        UObject*                  (*OuterFunc)();   &lt;span class=&quot;co&quot;&gt;//获取Outer对象的函数指针回调，用于获取所属于的Package&lt;/span&gt;
        EDynamicType                DynamicType;    &lt;span class=&quot;co&quot;&gt;//是否动态，一般是非动态的&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                 NameUTF8;   &lt;span class=&quot;co&quot;&gt;//枚举的名字&lt;/span&gt;
        EObjectFlags                ObjectFlags;    &lt;span class=&quot;co&quot;&gt;//UEnum对象的标志&lt;/span&gt;
        FText                     (*DisplayNameFunc)(int32);    &lt;span class=&quot;co&quot;&gt;//获取自定义显示名字的回调，一般是nullptr，就是默认规则生成的名字&lt;/span&gt;
        uint8                       CppForm; 
        &lt;span class=&quot;co&quot;&gt;/*CppForm指定这个枚举是怎么定义的，用来在之后做更细的处理。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        enum class ECppForm&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            Regular,    //常规的enum MyEnum{}这样定义&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            Namespaced, //MyEnum之外套一层namespace的定义&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;            EnumClass   //enum class定义的&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        };&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                 CppTypeUTF8;    &lt;span class=&quot;co&quot;&gt;//C++里的类型名字，一般是等同于NameUTF8的，但有时定义名字和反射的名字可以不一样&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FEnumeratorParam*     EnumeratorParams;   &lt;span class=&quot;co&quot;&gt;//枚举项数组&lt;/span&gt;
        int32                       NumEnumerators;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*   MetaDataArray;  &lt;span class=&quot;co&quot;&gt;//元数据数组&lt;/span&gt;
        int32                       NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
}

&lt;span class=&quot;co&quot;&gt;//MyEnum.gen.cpp生成代码：&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FEnumeratorParam Enumerators[] = { &lt;span class=&quot;co&quot;&gt;//所有的枚举项&lt;/span&gt;
            { &lt;span class=&quot;st&quot;&gt;&quot;MyEnum::MY_Dance&quot;&lt;/span&gt;, (int64)MyEnum::MY_Dance },
            { &lt;span class=&quot;st&quot;&gt;&quot;MyEnum::MY_Rain&quot;&lt;/span&gt;, (int64)MyEnum::MY_Rain },
            { &lt;span class=&quot;st&quot;&gt;&quot;MyEnum::MY_Song&quot;&lt;/span&gt;, (int64)MyEnum::MY_Song },
        };
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam Enum_MetaDataParams[] = {   &lt;span class=&quot;co&quot;&gt;//枚举的元数据&lt;/span&gt;
    { &lt;span class=&quot;st&quot;&gt;&quot;BlueprintType&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;IsBlueprintBase&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyEnum.h&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;MY_Dance.DisplayName&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Dance&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;MY_Rain.DisplayName&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Rain&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;MY_Song.DisplayName&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Song&quot;&lt;/span&gt; },
};
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FEnumParams EnumParams = { &lt;span class=&quot;co&quot;&gt;//枚举的元数据参数信息&lt;/span&gt;
    (UObject*(*)())Z_Construct_UPackage__Script_Hello,
    UE4CodeGen_Private::EDynamicType::NotDynamic,
    &lt;span class=&quot;st&quot;&gt;&quot;MyEnum&quot;&lt;/span&gt;,
    RF_Public|RF_Transient|RF_MarkAsNative,
    &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;,
    (uint8)UEnum::ECppForm::EnumClass,
    &lt;span class=&quot;st&quot;&gt;&quot;MyEnum&quot;&lt;/span&gt;,
    Enumerators, &lt;span class=&quot;co&quot;&gt;//枚举项数组&lt;/span&gt;
    ARRAY_COUNT(Enumerators),  
    METADATA_PARAMS(Enum_MetaDataParams, ARRAY_COUNT(Enum_MetaDataParams))&lt;span class=&quot;co&quot;&gt;//枚举元数据数组&lt;/span&gt;
};
UE4CodeGen_Private::ConstructUEnum(ReturnEnum, EnumParams); &lt;span class=&quot;co&quot;&gt;//利用枚举参数构造UEnum*对象到ReturnEnum&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先挑最软的椰子开始捏，枚举的构造比较简单，就只是包含枚举项（字符串-整形)，所以只要依次添加进去就可以。元数据对指的就是那些UMETA等宏标记里面那些的内容，可以在很多地方上使用来添加额外的信息。&lt;/p&gt;
&lt;h3 id=&quot;ustruct的params和生成&quot;&gt;UStruct的Params和生成：&lt;/h3&gt;
&lt;p&gt;因为UStruct里只能包含属性，所以我们在这里着重关注属性信息是怎么生成的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;70&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.h&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//PS:为了阅读方便，与源码有一定的代码位置微调，但不影响功能正确性&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
    &lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; EPropertyClass   &lt;span class=&quot;co&quot;&gt;//属性的类型&lt;/span&gt;
    {
        Byte,
        Int8,
        Int16,
        Int,
        Int64,
        UInt16,
        UInt32,
        UInt64,
        UnsizedInt,
        UnsizedUInt,
        Float,
        Double,
        Bool,
        SoftClass,
        WeakObject,
        LazyObject,
        SoftObject,
        Class,
        Object,
        Interface,
        Name,
        Str,
        Array,
        Map,
        Set,
        Struct,
        Delegate,
        MulticastDelegate,
        Text,
        Enum,
    };
    
    &lt;span class=&quot;co&quot;&gt;// This is not a base class but is just a common initial sequence of all of the F*PropertyParams types below.&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// We don't want to use actual inheritance because we want to construct aggregated compile-time tables of these things.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FPropertyParamsBase  &lt;span class=&quot;co&quot;&gt;//属性参数基类&lt;/span&gt;
    {
        EPropertyClass Type;    &lt;span class=&quot;co&quot;&gt;//属性的类型&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*    NameUTF8;     &lt;span class=&quot;co&quot;&gt;//属性的名字&lt;/span&gt;
        EObjectFlags   ObjectFlags;  &lt;span class=&quot;co&quot;&gt;//属性生成的UProperty对象标志，标识这个UProperty对象的特征，RF_XXX那些宏&lt;/span&gt;
        uint64         PropertyFlags;    &lt;span class=&quot;co&quot;&gt;//属性生成的UProperty属性标志，标识这个属性的特征，CPF_XXX那些宏&lt;/span&gt;
        int32          ArrayDim;        &lt;span class=&quot;co&quot;&gt;//属性有可能是个数组，数组的长度，默认是1&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*    RepNotifyFuncUTF8;   &lt;span class=&quot;co&quot;&gt;//属性的网络复制通知函数名字&lt;/span&gt;
    };
    
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FPropertyParamsBaseWithOffset &lt;span class=&quot;co&quot;&gt;// : FPropertyParamsBase&lt;/span&gt;
    {
        EPropertyClass Type;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*    NameUTF8;
        EObjectFlags   ObjectFlags;
        uint64         PropertyFlags;
        int32          ArrayDim;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*    RepNotifyFuncUTF8;
        int32          Offset;  &lt;span class=&quot;co&quot;&gt;//在结构或类中的内存偏移，可以理解为成员变量指针（成员变量指针其实本质上就是从对象内存起始位置的偏移）&lt;/span&gt;
    };
    &lt;span class=&quot;co&quot;&gt;//通用的属性参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FGenericPropertyParams &lt;span class=&quot;co&quot;&gt;// : FPropertyParamsBaseWithOffset&lt;/span&gt;
    {
        EPropertyClass   Type;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      NameUTF8;
        EObjectFlags     ObjectFlags;
        uint64           PropertyFlags;
        int32            ArrayDim;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      RepNotifyFuncUTF8;
        int32            Offset;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*           MetaDataArray;
        int32                               NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
    
    &lt;span class=&quot;co&quot;&gt;//一些普通常用的数值类型就通过这个类型定义别名了&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// These property types don't add new any construction parameters to their base property&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; FGenericPropertyParams FInt8PropertyParams;
    &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; FGenericPropertyParams FInt16PropertyParams;
    
    &lt;span class=&quot;co&quot;&gt;//枚举类型属性参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FBytePropertyParams &lt;span class=&quot;co&quot;&gt;// : FPropertyParamsBaseWithOffset&lt;/span&gt;
    {
        EPropertyClass   Type;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      NameUTF8;
        EObjectFlags     ObjectFlags;
        uint64           PropertyFlags;
        int32            ArrayDim;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      RepNotifyFuncUTF8;
        int32            Offset;
        UEnum*         (*EnumFunc)();   &lt;span class=&quot;co&quot;&gt;//定义的枚举对象回调&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*           MetaDataArray;
        int32                               NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
    &lt;span class=&quot;co&quot;&gt;//...省略一些定义，可自行去UObjectGlobals.h查看&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//对象引用类型属性参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FObjectPropertyParams &lt;span class=&quot;co&quot;&gt;// : FPropertyParamsBaseWithOffset&lt;/span&gt;
    {
        EPropertyClass   Type;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      NameUTF8;
        EObjectFlags     ObjectFlags;
        uint64           PropertyFlags;
        int32            ArrayDim;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*      RepNotifyFuncUTF8;
        int32            Offset;
        UClass*        (*ClassFunc)();  &lt;span class=&quot;co&quot;&gt;//用于获取该属性定义类型的函数指针回调&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*           MetaDataArray;
        int32                               NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
    
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FStructParams    &lt;span class=&quot;co&quot;&gt;//结构参数&lt;/span&gt;
    {
        UObject*                          (*OuterFunc)();   &lt;span class=&quot;co&quot;&gt;//所属于的Package&lt;/span&gt;
        UScriptStruct*                    (*SuperFunc)();   &lt;span class=&quot;co&quot;&gt;//该结构的基类，没有的话为nullptr&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*                             (*StructOpsFunc)(); &lt;span class=&quot;co&quot;&gt;// really returns UScriptStruct::ICppStructOps*，结构的构造分配的辅助操作类&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                         NameUTF8;   &lt;span class=&quot;co&quot;&gt;//结构名字&lt;/span&gt;
        EObjectFlags                        ObjectFlags;    &lt;span class=&quot;co&quot;&gt;//结构UScriptStruct*的对象特征&lt;/span&gt;
        uint32                              StructFlags; &lt;span class=&quot;co&quot;&gt;// EStructFlags该结构的本来特征&lt;/span&gt;
        SIZE_T                              SizeOf;     &lt;span class=&quot;co&quot;&gt;//结构的大小，就是sizeof(FMyStruct)，用以后续分配内存时候用&lt;/span&gt;
        SIZE_T                              AlignOf;&lt;span class=&quot;co&quot;&gt;//结构的内存对齐，就是alignof(FMyStruct)，用以后续分配内存时候用&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;*   PropertyArray;  &lt;span class=&quot;co&quot;&gt;//包含的属性数组&lt;/span&gt;
        int32                               NumProperties;
    &lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*           MetaDataArray;  &lt;span class=&quot;co&quot;&gt;//元数据数组&lt;/span&gt;
        int32                               NumMetaData;
    &lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
}

&lt;span class=&quot;co&quot;&gt;//MyStruct.gen.cpp生成代码：&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam Struct_MetaDataParams[] = { &lt;span class=&quot;co&quot;&gt;//结构的元数据&lt;/span&gt;
    { &lt;span class=&quot;st&quot;&gt;&quot;BlueprintType&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyStruct.h&quot;&lt;/span&gt; },
};
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;auto&lt;/span&gt; NewStructOpsLambda = []() -&amp;gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;* { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (UScriptStruct::ICppStructOps*)&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UScriptStruct::TCppStructOps&amp;lt;FMyStruct&amp;gt;(); };   &lt;span class=&quot;co&quot;&gt;//一个获取操作类的回调&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//属性的元数据&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam NewProp_Score_MetaData[] = {
    { &lt;span class=&quot;st&quot;&gt;&quot;Category&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyStruct&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyStruct.h&quot;&lt;/span&gt; },
};
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFloatPropertyParams NewProp_Score = { UE4CodeGen_Private::EPropertyClass::Float, &lt;span class=&quot;st&quot;&gt;&quot;Score&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;bn&quot;&gt;0x0010000000000004&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, STRUCT_OFFSET(FMyStruct, Score), METADATA_PARAMS(NewProp_Score_MetaData, ARRAY_COUNT(NewProp_Score_MetaData)) };&lt;span class=&quot;co&quot;&gt;//Score属性的信息&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//属性的数组&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; PropPointers[] = {
    (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase*)&amp;amp;NewProp_Score,
};
&lt;span class=&quot;co&quot;&gt;//结构的参数信息&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FStructParams ReturnStructParams = {
    (UObject* (*)())Z_Construct_UPackage__Script_Hello,
    &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;,
    &amp;amp;UE4CodeGen_Private::TNewCppStructOpsWrapper&amp;lt;&lt;span class=&quot;kw&quot;&gt;decltype&lt;/span&gt;(NewStructOpsLambda)&amp;gt;::NewCppStructOps,
    &lt;span class=&quot;st&quot;&gt;&quot;MyStruct&quot;&lt;/span&gt;,
    RF_Public|RF_Transient|RF_MarkAsNative,
    EStructFlags(&lt;span class=&quot;bn&quot;&gt;0x00000201&lt;/span&gt;),
    &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(FMyStruct),
    &lt;span class=&quot;kw&quot;&gt;alignof&lt;/span&gt;(FMyStruct),
    PropPointers, ARRAY_COUNT(PropPointers),
    METADATA_PARAMS(Struct_MetaDataParams, ARRAY_COUNT(Struct_MetaDataParams))
};
UE4CodeGen_Private::ConstructUScriptStruct(ReturnStruct, ReturnStructParams);&lt;span class=&quot;co&quot;&gt;//构造UScriptStruct*到ReturnStruct里去&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码比较简单，上下对照和看看注释就能大概明白。就是收集一个个属性的信息整合成数组，然后合并到结构参数里去，最后传给ConstructUScriptStruct来构造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考：FPropertyParamsBaseWithOffset以及后续为何不继承于FPropertyParamsBase？&lt;/strong&gt;&lt;br/&gt;我们在FPropertyParamsBase和FPropertyParamsBaseWithOffset等后续的注释后面以及属性成员的相似性上来看，很容易就看到这些F*PropertyParams其实是用了继承语义的，那为何不直接继承而是费劲的再写一遍呢？&lt;br/&gt;虽然官方在FPropertyParamsBase上已经写了注释，但是有些朋友可能还是依然比较懵懂。其实这里涉及到一个C++的Aggregate类型的&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;规则。具体的C++语法规则请自行去补充学习。简单来说，&lt;strong&gt;一个Aggregate是一个数组或者一个没有用户声明构造函数，没有私有或保护类型的非静态数据成员，没有父类和虚函数的类型。&lt;/strong&gt; Aggregatel类型就可以用形如 &lt;em&gt;T object = {arg1, arg2, ...}&lt;/em&gt; 的初始化列表来初始化。我们在上文中见到的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFloatPropertyParams NewProp_Score = { UE4CodeGen_Private::EPropertyClass::Float, &lt;span class=&quot;st&quot;&gt;&quot;Score&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;bn&quot;&gt;0x0010000000000004&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, STRUCT_OFFSET(FMyStruct, Score), METADATA_PARAMS(NewProp_Score_MetaData, ARRAY_COUNT(NewProp_Score_MetaData)) };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的={}就是初始化列表。这么写当然是为了简洁的目的，否则一个个参数的字段设置过去，那也太麻烦了。&lt;br/&gt;那如果用继承会怎么样呢？我们可以来做个测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point2
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; X;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Y;
};

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point3 :&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Point2    &lt;span class=&quot;co&quot;&gt;//这不是个Aggregate类型，因为有父类&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Z;
};

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point3_Aggregate &lt;span class=&quot;co&quot;&gt;//这是个Aggregate类型&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; X;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Y;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Z;
};
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Point3 pos{ &lt;span class=&quot;fl&quot;&gt;1.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;2.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;3.f&lt;/span&gt; }; &lt;span class=&quot;co&quot;&gt;// error C2440:'initializing': cannot convert from 'initializer list' to 'Point3'&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Point3_Aggregate pos2{ &lt;span class=&quot;fl&quot;&gt;1.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;2.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;3.f&lt;/span&gt; };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此UE选择不继承，宁愿每个重复写一遍字段声明，就是为了可以简单用{}初始化列表来构造对象。但是我们也观察到，在PropPointers数组里，也依然把一个个元素都转为FPropertyParamsBase*。因为根据C/C++的对象内存模型，继承的时候，基类成员排在派生类成员之前的内存地址上。又因为F*PropertyParams是如此的POD，所以只要保证内存地址和属性成员顺序一致，就可以保证转为另一个结构指针后依然可以正确的使用。&lt;/p&gt;
&lt;p&gt;虽然看起来这么解释的通，但还是感觉很麻烦，本来应该用继承的语义却偏偏为了初始化列表妥协了。对完美主义者来说还是不能忍，那么有没有一种既可以用继承又可以用初始化列表的解决方案呢？&lt;br/&gt;其实加上构造函数就可以了。不用Aggregate类型，放宽限制，改用POD类型（&lt;strong&gt;POD类型就是没有非静态类型的non-POD类型 （或者这些类型的数组）和引用类型的数据成员，也没有用户定义的赋值操作符和析构函数的类型。&lt;/strong&gt;）。如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point2
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; X;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Y;
    Point2(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; y) :X(x), Y(y) {} &lt;span class=&quot;co&quot;&gt;//构造函数&lt;/span&gt;
};

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point3_POD :&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Point2
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Z;
    Point3_POD(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; x, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; y, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; z) :Point2(x, y), Z(z) {}&lt;span class=&quot;co&quot;&gt;//构造函数&lt;/span&gt;
};

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; Point3_Aggregate
{
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; X;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Y;
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Z;
};
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Point3_POD pos{ &lt;span class=&quot;fl&quot;&gt;1.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;2.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;3.f&lt;/span&gt; };     &lt;span class=&quot;co&quot;&gt;//works happy ^_^&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Point3_Aggregate pos2{ &lt;span class=&quot;fl&quot;&gt;1.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;2.f&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;3.f&lt;/span&gt; };  &lt;span class=&quot;co&quot;&gt;//works happy ^_^&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以只要把F*PropertyParams加上构造函数就可以了。至于为啥UE不这么做？问Epic的人去，摊手~&lt;/p&gt;
&lt;h3 id=&quot;ufunction和uclass的params和生成&quot;&gt;UFunction和UClass的Params和生成：&lt;/h3&gt;
&lt;p&gt;为了测试UClass里的函数输入输出参数，所以增加一个AddHP函数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;91&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//测试文件：&lt;/span&gt;
UCLASS()
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HELLO_API UMyClass :&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; UObject
{
    GENERATED_BODY()
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    UPROPERTY(BlueprintReadWrite)
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; Score;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt;:
    UFUNCTION(BlueprintCallable, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; AddHP(&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; HP);

    UFUNCTION(BlueprintCallable, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; CallableFunc();    &lt;span class=&quot;co&quot;&gt;//C++实现，蓝图调用&lt;/span&gt;

    UFUNCTION(BlueprintNativeEvent, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; NativeFunc();  &lt;span class=&quot;co&quot;&gt;//C++实现默认版本，蓝图可重载实现&lt;/span&gt;

    UFUNCTION(BlueprintImplementableEvent, Category = &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ImplementableFunc();   &lt;span class=&quot;co&quot;&gt;//C++不实现，蓝图实现&lt;/span&gt;
};

&lt;span class=&quot;co&quot;&gt;//Class.h&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//类里的函数链接信息，一个函数名字对应一个UFunction对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FClassFunctionLinkInfo 
{
    UFunction* (*CreateFuncPtr)();  &lt;span class=&quot;co&quot;&gt;//获得UFunction对象的函数指针回调&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* FuncNameUTF8;       &lt;span class=&quot;co&quot;&gt;//函数的名字&lt;/span&gt;
};
&lt;span class=&quot;co&quot;&gt;//类在Cpp里的类型信息，用一个结构是为了将来也许还会添加别的字段&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FCppClassTypeInfoStatic
{
    &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt; bIsAbstract;   &lt;span class=&quot;co&quot;&gt;//是否抽象类&lt;/span&gt;
};

&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.h&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
    &lt;span class=&quot;co&quot;&gt;//函数参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FFunctionParams
    {
        UObject*                          (*OuterFunc)();   &lt;span class=&quot;co&quot;&gt;//所属于的外部对象，一般是外部的UClass*对象&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                         NameUTF8;   &lt;span class=&quot;co&quot;&gt;//函数的名字&lt;/span&gt;
        EObjectFlags                        ObjectFlags;    &lt;span class=&quot;co&quot;&gt;//UFunction对象的特征&lt;/span&gt;
        UFunction*                        (*SuperFunc)();   &lt;span class=&quot;co&quot;&gt;//UFunction的基类，一般为nullptr&lt;/span&gt;
        EFunctionFlags                      FunctionFlags;  &lt;span class=&quot;co&quot;&gt;//函数本身的特征&lt;/span&gt;
        SIZE_T                              StructureSize;  &lt;span class=&quot;co&quot;&gt;//函数的参数返回值包结构的大小&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;*   PropertyArray;  &lt;span class=&quot;co&quot;&gt;//函数的参数和返回值字段数组&lt;/span&gt;
        int32                               NumProperties;  &lt;span class=&quot;co&quot;&gt;//函数的参数和返回值字段数组大小&lt;/span&gt;
        uint16                              RPCId;          &lt;span class=&quot;co&quot;&gt;//网络间的RPC Id&lt;/span&gt;
        uint16                              RPCResponseId;  &lt;span class=&quot;co&quot;&gt;//网络间的RPC Response Id&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*           MetaDataArray;  &lt;span class=&quot;co&quot;&gt;//元数据数组&lt;/span&gt;
        int32                               NumMetaData;
    &lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
    
    &lt;span class=&quot;co&quot;&gt;//实现的接口参数，篇幅所限，接口的内容可以自行分析&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FImplementedInterfaceParams
    {
        UClass* (*ClassFunc)();     &lt;span class=&quot;co&quot;&gt;//外部所属于的UInterface对象&lt;/span&gt;
        int32     Offset;           &lt;span class=&quot;co&quot;&gt;//在UMyClass里的实现的IMyInterface的虚函数表地址偏移&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;bool&lt;/span&gt;      bImplementedByK2; &lt;span class=&quot;co&quot;&gt;//是否在蓝图中实现&lt;/span&gt;
    };
    
    &lt;span class=&quot;co&quot;&gt;//类参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FClassParams
    {
        UClass*                                   (*ClassNoRegisterFunc)(); &lt;span class=&quot;co&quot;&gt;//获得UClass*对象的函数指针&lt;/span&gt;
        UObject*                           (*&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; *DependencySingletonFuncArray)();    &lt;span class=&quot;co&quot;&gt;//获取依赖对象的函数指针数组，一般是需要前提构造的基类，模块UPackage对象&lt;/span&gt;
        int32                                       NumDependencySingletons;
        uint32                                      ClassFlags; &lt;span class=&quot;co&quot;&gt;// EClassFlags，类特征&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FClassFunctionLinkInfo*               FunctionLinkArray;  &lt;span class=&quot;co&quot;&gt;//链接的函数数组&lt;/span&gt;
        int32                                       NumFunctions;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt;*           PropertyArray;  &lt;span class=&quot;co&quot;&gt;//类里定义的成员变量数组&lt;/span&gt;
        int32                                       NumProperties;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                                 ClassConfigNameUTF8;    &lt;span class=&quot;co&quot;&gt;//配置文件名字，有些类可以从配置文件从加载数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FCppClassTypeInfoStatic*              CppClassInfo;   &lt;span class=&quot;co&quot;&gt;//Cpp里定义的信息&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FImplementedInterfaceParams*          ImplementedInterfaceArray;  &lt;span class=&quot;co&quot;&gt;//实现的接口信息数组&lt;/span&gt;
        int32                                       NumImplementedInterfaces;
    &lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA           &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//类的元数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*                   MetaDataArray;
        int32                                       NumMetaData;
    &lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
}

&lt;span class=&quot;co&quot;&gt;//MyClass.gen.cpp&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//构造AddHp函数的UFunction对象&lt;/span&gt;
UFunction* Z_Construct_UFunction_UMyClass_AddHP()
{
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; MyClass_eventAddHP_Parms     &lt;span class=&quot;co&quot;&gt;//函数的参数和返回值包&lt;/span&gt;
    {
        &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; HP;
        &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; ReturnValue;
    };
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; UFunction* ReturnFunction = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!ReturnFunction)
    {
        &lt;span class=&quot;co&quot;&gt;//定义两个属性用来传递信息&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFloatPropertyParams NewProp_ReturnValue = { UE4CodeGen_Private::EPropertyClass::Float, &lt;span class=&quot;st&quot;&gt;&quot;ReturnValue&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;bn&quot;&gt;0x0010000000000580&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, STRUCT_OFFSET(MyClass_eventAddHP_Parms, ReturnValue), METADATA_PARAMS(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) };
        
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFloatPropertyParams NewProp_HP = { UE4CodeGen_Private::EPropertyClass::Float, &lt;span class=&quot;st&quot;&gt;&quot;HP&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;bn&quot;&gt;0x0010000000000080&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, STRUCT_OFFSET(MyClass_eventAddHP_Parms, HP), METADATA_PARAMS(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) };
        
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; PropPointers[] = {
            (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase*)&amp;amp;NewProp_ReturnValue,
            (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase*)&amp;amp;NewProp_HP,
        };
        
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam Function_MetaDataParams[] = {
            { &lt;span class=&quot;st&quot;&gt;&quot;Category&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Hello&quot;&lt;/span&gt; },
            { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt; },
        };
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFunctionParams FuncParams = { (UObject*(*)())Z_Construct_UClass_UMyClass, &lt;span class=&quot;st&quot;&gt;&quot;AddHP&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, (EFunctionFlags)&lt;span class=&quot;bn&quot;&gt;0x04020401&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(MyClass_eventAddHP_Parms), PropPointers, ARRAY_COUNT(PropPointers), &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, METADATA_PARAMS(Function_MetaDataParams, ARRAY_COUNT(Function_MetaDataParams)) };
        
        UE4CodeGen_Private::ConstructUFunction(ReturnFunction, FuncParams); &lt;span class=&quot;co&quot;&gt;//构造函数&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ReturnFunction;
}
&lt;span class=&quot;co&quot;&gt;//...构造其他的函数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//该类依赖的对象列表，用函数指针来获取。&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; UObject* (*&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; DependentSingletons[])() = {
                (UObject* (*)())Z_Construct_UClass_UObject,
                (UObject* (*)())Z_Construct_UPackage__Script_Hello,
            };
&lt;span class=&quot;co&quot;&gt;//函数链接信息&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FClassFunctionLinkInfo FuncInfo[] = {
    { &amp;amp;Z_Construct_UFunction_UMyClass_CallableFunc, &lt;span class=&quot;st&quot;&gt;&quot;CallableFunc&quot;&lt;/span&gt; }, &lt;span class=&quot;co&quot;&gt;// 1841300010&lt;/span&gt;
    { &amp;amp;Z_Construct_UFunction_UMyClass_ImplementableFunc, &lt;span class=&quot;st&quot;&gt;&quot;ImplementableFunc&quot;&lt;/span&gt; }, &lt;span class=&quot;co&quot;&gt;// 2010696670&lt;/span&gt;
    { &amp;amp;Z_Construct_UFunction_UMyClass_NativeFunc, &lt;span class=&quot;st&quot;&gt;&quot;NativeFunc&quot;&lt;/span&gt; }, &lt;span class=&quot;co&quot;&gt;// 2593520329&lt;/span&gt;
};
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[] = {
    { &lt;span class=&quot;st&quot;&gt;&quot;IncludePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt; },
};
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FMetaDataPairParam NewProp_Score_MetaData[] = {
    { &lt;span class=&quot;st&quot;&gt;&quot;Category&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyClass&quot;&lt;/span&gt; },
    { &lt;span class=&quot;st&quot;&gt;&quot;ModuleRelativePath&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;MyClass.h&quot;&lt;/span&gt; },
};
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FFloatPropertyParams NewProp_Score = { UE4CodeGen_Private::EPropertyClass::Float, &lt;span class=&quot;st&quot;&gt;&quot;Score&quot;&lt;/span&gt;, RF_Public|RF_Transient|RF_MarkAsNative, &lt;span class=&quot;bn&quot;&gt;0x0010000000000004&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, STRUCT_OFFSET(UMyClass, Score), METADATA_PARAMS(NewProp_Score_MetaData, ARRAY_COUNT(NewProp_Score_MetaData)) };

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase* &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; PropPointers[] = {
    (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPropertyParamsBase*)&amp;amp;NewProp_Score,
};
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FCppClassTypeInfoStatic StaticCppClassTypeInfo = {
    TCppClassTypeTraits&amp;lt;UMyClass&amp;gt;::IsAbstract,
};
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FClassParams ClassParams = {
    &amp;amp;UMyClass::StaticClass,
    DependentSingletons, ARRAY_COUNT(DependentSingletons),
    &lt;span class=&quot;bn&quot;&gt;0x00100080u&lt;/span&gt;,
    FuncInfo, ARRAY_COUNT(FuncInfo),
    PropPointers, ARRAY_COUNT(PropPointers),
    &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;,
    &amp;amp;StaticCppClassTypeInfo,
    &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,
    METADATA_PARAMS(Class_MetaDataParams, ARRAY_COUNT(Class_MetaDataParams))
};
UE4CodeGen_Private::ConstructUClass(OuterClass, ClassParams);   &lt;span class=&quot;co&quot;&gt;//构造UClass对象&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，对于一个函数来说，参数和返回值都可以算是函数内部定义的属性，只不过其有不同的特征和用途。类里包含属性和函数，而函数又包含属性。属性的构造和Struct里的规则一样，就不赘述了。不同的是，因为Class里可以包含Function，所以构造UClass之前必须先构造出所有的UFunction。所以整理下，其实上述的那些构造就是结构套结构，加上一些数组整合出来的信息集合而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考：为什么生成的代码里大量用了函数指针来返回对象？&lt;/strong&gt;&lt;br/&gt;如UClass* (*ClassNoRegisterFunc)()或UFunction* (*CreateFuncPtr)()都用函数指针来获取定义的UClass*对象和前提依赖的UFunction*对象。为什么不直接用个UClass*或UFunction*指针呢？&lt;br/&gt;答案很简单，因为构造顺序的不确定。&lt;br/&gt;在一个类型系统中，类型的依赖管理是项很麻烦但又非常重要的事，你必须保证当前类型的所有前置类型都已经定义完毕，才能开始本类型的构造。针对此问题，当然你可以小心翼翼的理清定义顺序，确保所有的顺序都是由底向上的。可是理想很美好，现实很骨感，这一步骤很难实现，是人都会犯错，更何况面对UE4当前的1572个UClass、1039个UStruct、588个Enum……你真的相信有人能管理好这些？所以在类型系统里想人工整理好类型的依赖定义顺序基本不现实，你几乎很难在构造本类型的时候，恰好的取得前置类型的对象。&lt;br/&gt;那怎么办？也简单，就如同C++里处理static单件对象的依赖顺序一样，既然处理不了，那就不处理！采用懒惰求值的思想，在需要前置类型的时候，先判断有没有构造出来，如果有就立即返回，如果没有就构造后再返回——一个简易版的单件模式。因为这个套路是如此的普遍，所以这一些判断加上构造的逻辑封装一下就成了一个个函数，为了获得那些对象，就变成了先获得那些函数指针了。生成的代码里都是大概这种套路：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;UClass* Z_Construct_UClass_UMyClass()   &lt;span class=&quot;co&quot;&gt;//用以获取UMyClass所对应的UClass的函数&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; UClass* OuterClass = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;    &lt;span class=&quot;co&quot;&gt;//一个函数局部静态指针&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!OuterClass)    &lt;span class=&quot;co&quot;&gt;//反正都是单线程执行，所以不需要线程安全的保护&lt;/span&gt;
    {
        &lt;span class=&quot;co&quot;&gt;//...一些构造代码&lt;/span&gt;
        UE4CodeGen_Private::ConstructUClass(OuterClass, ClassParams);
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; OuterClass;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用此法，就在代码中形成了一个可自动上溯的前置对象获取链条。任何时候，想得到某一个类的UClass*对象，我们不需要去操心是否已经构造完成，也不需要担心它的依赖项是否已经全部构造了，因为代码的机制保证了前置项的按需构造。&lt;/p&gt;
&lt;h3 id=&quot;upackage的params和生成&quot;&gt;UPackage的Params和生成：&lt;/h3&gt;
&lt;p&gt;对于Hello模块而言，按照UE4的Module规则，我们需要定义一个Hello UPackage来存放该模块里定义的类型。&lt;br/&gt;之前的4.15的代码形式为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;UPackage* Z_Construct_UPackage__Script_Hello()
{
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; UPackage* ReturnPackage = NULL;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!ReturnPackage)
    {
        ReturnPackage = CastChecked&amp;lt;UPackage&amp;gt;(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT(&lt;span class=&quot;st&quot;&gt;&quot;/Script/Hello&quot;&lt;/span&gt;)), &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;));
        ReturnPackage-&amp;gt;SetPackageFlags(PKG_CompiledIn | &lt;span class=&quot;bn&quot;&gt;0x00000000&lt;/span&gt;);
        FGuid Guid;
        Guid.A = &lt;span class=&quot;bn&quot;&gt;0x79A097CD&lt;/span&gt;;
        Guid.B = &lt;span class=&quot;bn&quot;&gt;0xB58D8B48&lt;/span&gt;;
        Guid.C = &lt;span class=&quot;bn&quot;&gt;0x00000000&lt;/span&gt;;
        Guid.D = &lt;span class=&quot;bn&quot;&gt;0x00000000&lt;/span&gt;;
        ReturnPackage-&amp;gt;SetGuid(Guid);
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ReturnPackage;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在4.17之后改为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;co&quot;&gt;//UObjectGlobals.h&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; UE4CodeGen_Private
{
    &lt;span class=&quot;co&quot;&gt;//包参数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; FPackageParams
    {
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;*                        NameUTF8;    &lt;span class=&quot;co&quot;&gt;//名字&lt;/span&gt;
        uint32                             PackageFlags; &lt;span class=&quot;co&quot;&gt;// EPackageFlags包的特征&lt;/span&gt;
        uint32                             BodyCRC; &lt;span class=&quot;co&quot;&gt;//内容的CRC,CRC的部分后续介绍&lt;/span&gt;
        uint32                             DeclarationsCRC; &lt;span class=&quot;co&quot;&gt;//声明部分的CRC&lt;/span&gt;
        UObject*                  (*&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; *SingletonFuncArray)();   &lt;span class=&quot;co&quot;&gt;//依赖的对象列表&lt;/span&gt;
        int32                              NumSingletons;
&lt;span class=&quot;ot&quot;&gt;#if WITH_METADATA&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; FMetaDataPairParam*          MetaDataArray;&lt;span class=&quot;co&quot;&gt;//元数据数组&lt;/span&gt;
        int32                              NumMetaData;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;
    };
}
&lt;span class=&quot;co&quot;&gt;//Hello.init.gen.cpp&lt;/span&gt;
UPackage* Z_Construct_UPackage__Script_Hello()
{
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; UPackage* ReturnPackage = &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!ReturnPackage)
    {
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; UE4CodeGen_Private::FPackageParams PackageParams = {
            &lt;span class=&quot;st&quot;&gt;&quot;/Script/Hello&quot;&lt;/span&gt;,    &lt;span class=&quot;co&quot;&gt;//包名字&lt;/span&gt;
            PKG_CompiledIn | &lt;span class=&quot;bn&quot;&gt;0x00000000&lt;/span&gt;,
            &lt;span class=&quot;bn&quot;&gt;0xA1EAFF6A&lt;/span&gt;,
            &lt;span class=&quot;bn&quot;&gt;0x41CF0543&lt;/span&gt;,
            &lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,
            METADATA_PARAMS(&lt;span class=&quot;kw&quot;&gt;nullptr&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        };
        UE4CodeGen_Private::ConstructUPackage(ReturnPackage, PackageParams);
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ReturnPackage;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本块内容比较简单，能坚持看到此处的朋友，对上文的代码应该是一目了然的。有一点需要知道的是，在Hello模块里的定义的类型数据，都是放在&quot;/Script/Hello&quot;Package里的，所以Hello Package是第一个首先构造出来的，因为它被后续的其他类型都依赖着。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对比了前后两版本的代码，我们不难看出重构了之后，生成的代码更加的紧致，语法的噪音减少了很多，代码的信息量密度大大提高了。但要注意，本文关注的类型系统阶段是对之前&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25098685&quot;&gt;《InsideUE4》UObject（四）类型系统代码生成&lt;/a&gt;的补充，后续依然是接着&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26019216&quot;&gt;《InsideUE4》UObject（五）类型系统收集&lt;/a&gt;章节的内容进行开始收集，所以前文的那些static静态收集机制并没有改变。&lt;br/&gt;至于UE4CodeGen_Private::ConstructXXX构造的具体实现，我们在后续章节讲到类型系统的结构组织时候再详细讲解，我保证，那天不会太久远。当前阶段你可以简单的理解为都是通过一个个参数构造出一个个类型对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考：生成的代码能否做得更加的清晰高效？&lt;/strong&gt;&lt;br/&gt;虽然通过此次重构，代码的可读性上升了许多。但平心而论，现在的代码生成依然远远算不上优雅。那么在程序化代码生成的时候一般有哪些手段可以继续提升呢？&lt;br/&gt;追其本质，让代码变得简洁的手段其实都是在提升信息密度。把代码比作文件的话，重构就像压缩软件一样，把代码的信息量压缩到无所压就算是到了极致了。但是当然这中间当然也要权衡平台移植性（否则直接存一个二进制文件好了）、可读性、编译效率等问题。提升信息密度的手段就只有一个：同样的信息不要书写两遍。因此带来的方式就是封装！而封装，在代码生成的时候，我们其实可以用到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;宏，UE4里其实已经用了一些宏来缩减代码，比如ARRAY_COUNT、VTABLE_OFFSET、IMPLEMENT_CLASS等。但目前的生成代码里依然有大量的长名字，套路化数组拼接，可以用宏来拼接。过度用宏当然也会降低可读性可调试性，但恰当的地方使用可以如同开挂一般优化掉巨量的代码。宏一直是代码拼接的最强大利器。&lt;/li&gt;
&lt;li&gt;函数，把相似的逻辑封装成函数可以优化掉大量的操作，只对外提供最简洁的信息输入接口。本文介绍的UE4优化方式就是用了函数来优化。我个人的倾向是宁愿在核心层多定义一些方便的辅助函数来接收多种输入，而不是在代码生成的时候去一个个拼函数的实体，这样可以大大减小生成代码的体积。函数的实现上巧用不定参数、数组和循环，可以使你的函数吞吐能力惊人。&lt;/li&gt;
&lt;li&gt;模板，更深层次的挖掘编译器提供的信息，压榨每个字段提供的信息量，利用它，从而自动推导出你所需要的其他信息。比如属性的类型就可以用模板根据字段的c++类型自动推导出来，而不需要手动分析注入了。UE4的生成代码里模板用的不多，是因为模板也有其很大的缺点：编译慢和难理解。在已经有了UHT分析代码的基础上，再用模板推导一遍，好像意义就不是那么大了，所以编译消耗还是能省一点是一点吧。至于模板的难理解，一款开源面向大众的引擎，在技术的选型实现上不应该过分的炫技，因为从业人员的技术水平，初中级的才是占绝大多数。考虑到受众问题和推广，有时候还是应该用一些朴实无华的实现比较能广为接受，同时也能有更大概率争取到重构维护者。否则，你写的代码，是很厉害，但是只有你自己能改得动改得明白，那叫社区里的人怎么为你贡献维护升级。&lt;/li&gt;
&lt;li&gt;扩展性，同时建议尽量把类型系统的构造逻辑放到Runtime里去，而不是在生成代码里（之前UE4就是在生成代码里直接new出一个个UXXX类型对象。放到Runtime，对外提供函数API接口，这样的好处是可测试性大大增长，不需要依赖UHT就可以手动构造出想要的类型进行测试。另外对于一些有在运行时动态Emit创建类型的需求来说，脱离UHT，保持自身功能的完备性也是必需的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述的讨论不限于UE4引擎，只是对于有兴趣实现一个类型系统的人来说，在每个阶段其实都有很多技术选择，但设计就是权衡的艺术，清楚了解你的受众，清晰你的设计目的愿景，对可用的各种手段信手拈来，最后才能组合出优雅的设计。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;在我们阅读UE4源码的过程中，也要时刻认识到UE4的源码不是完美的。有很多时候，在阅读一段具体代码时，我们可能会去使劲猜测这段代码的用意，琢磨当初是怎么的设计理念却不可得。其实，现实的情况是这些代码往往只是一时的修复，且不是所有代码的编写者技术都是那么高超。他会出错，另一个他会修复，然后再犯错修复，周而复始。如同生物的进化一样，一次次重构优化，最终得到的往往并不是最优解，就像人眼睛的盲点和人的智齿都不是最正确的设计，而是会留下进化的痕迹。但是尽管如此，我们也并不需要感到沮丧，因为接受不完美，接受最后的这个可接受解，适当的懂得妥协和接受缺陷，也许也是一个技术人成熟的标志之一吧。&lt;/p&gt;
&lt;p&gt;有一个有趣的现象，对于大工程量的项目（如UE4)来说，越是底层的模块越是缺乏推动力去重构，越底层的代码其改动的阻力也越大。牵一发而动全身，在一些时候，重构底层模块其实也是最能产生巨量效益的时候，因为其影响会层层放大到最上层上去。但是代码毕竟是人在写，在一个公司里，一个团队里，形成的开发氛围往往是只要底层代码能工作，就不会有人去改，也不会有人敢改。拿UE4的CoreUObject模块来说，是UE4的对象系统模块，可以说是最底层核心的模块了，但是根据我这么一大段时间的研读来说，代码里充斥着各种历史痕迹和小修小补，一些代码结构也是让人无可奈何，but it works，所以这块代码从UE3过来，到UE4里，相信有生之年也是会继续追随到UE5的。CoreUObject代码模块目前能工作，虽然有时也会有点BUG，但是到时小修补就好了，那些代码的优雅追求和结构的设计，改的好了效益不太明显；改过之后出了Bug是不是都算你的？所以正是因为这种效益和责任的担负，导致往往最需要重视的模块，最得不到升级改造。但历史的规律也表明了，代码的小缺陷积累多了，开发者的怨气积攒足够了，再适逢一个不动底层不能开工的功能需求的刺激，到时候才能下得了决心大改，或者干脆另起炉灶重新设计了。说这些，是希望同读UE4源码的朋友，在遇到代码里莫名其妙的设计，抓耳挠腮苦思冥想的时候，可以放宽心态，稍安勿躁，休息一下，我们继续前行。&lt;/p&gt;
&lt;h2 id=&quot;作者的话&quot;&gt;作者的话&lt;/h2&gt;
&lt;p&gt;我拖更，我可耻，请大家不要向我学习！&lt;/p&gt;
&lt;p&gt;实在无颜面对自己曾经写下的目录……只能化羞愤为动力，知耻而后勇，之后我会尽量把精力分配过来，争取把脑袋里的东西都早点掏出来写出来。但也实在不敢再保证更新周期了，只能说尽我最大努力，不定期更新吧。&lt;br/&gt;但还是稍微解释一下吧，2017年一整年，我在某机构担任UE4的技术培训高级讲师，在熟悉了之后担任整个UE4教学的负责，主导UE4的教学大纲设计和课程研发等内容。因个人的怪趣味使然，想试试从研发的岗位转到教学岗位上是种什么体验，哪成想教学竟然比研发还要占用人的精力。自己会和教会别人会真不是一个量级的难度，以前一些理所当然的常识性知识和结构，都需要深入浅出的去给初学者讲解明白，对知识的全面性、技术深度的洞察力，本质逻辑都是很大的挑战。可是想到讲台下嗷嗷待哺饱含对知识渴望眼神的学生们，从职业和师德上就不敢有一丝怠慢，于是2017年里时常备课到深夜两三点。不过所幸的是，收获也很多，除了一帮成材可爱的学生之外，也是让我在讲解一个技术原理给别人的时候功力+0.1。在外出给别的合作公司做技术培训和技术支持的时候，从另一个角度了解了很多别人的常见关心的问题，切入一些自己以往并不涉及的业务领域，对整个行业的了解+0.1。&lt;/p&gt;
&lt;h2 id=&quot;打个广告&quot;&gt;打个广告&lt;/h2&gt;
&lt;p&gt;2018年，目前也还是在从事UE4技术培训领域，也仍在继续接公司的UE4技术培训业务，可以根据需求定制化课程大纲，有UE4技术培训需求的公司或个人，欢迎私信咨询进一步沟通。&lt;/p&gt;
&lt;p&gt;上篇：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26019216&quot;&gt;《InsideUE4》UObject（五）类型系统收集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;UE4.18.3&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/insideue4&quot;&gt;InsideUE4&lt;/a&gt;&lt;br/&gt;UE4深入学习QQ群：&lt;strong&gt;456247757&lt;/strong&gt;(非新手入门群，请先学习完官方文档和视频教程，回答正确验证问题才能进入)&lt;br/&gt;&lt;strong&gt;个人原创，未经授权，谢绝转载！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 06:02:00 +0000</pubDate>
<dc:creator>fjz13</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fjz13/p/8478532.html</dc:identifier>
</item>
<item>
<title>【Unity3D技术文档翻译】第1.8篇 AssetBundles 问题及解决方法 - 何三思</title>
<link>http://www.cnblogs.com/hearthstone/p/8478513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hearthstone/p/8478513.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2464776-03bfd04e6425e1f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Unity3D技术文档翻译&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/1a057a0b47ec&quot;&gt;上一章：【Unity3D技术文档翻译】第1.7篇 AssetBundles 补丁更新&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本章原文所在章节：【Unity Manual】→【Working in Unity】→【Advanced Development】→【AssetBundles】→【Troubleshooting】&lt;/p&gt;

&lt;p&gt;本章节涉及一些使用 AssetBundles 的项目的常见问题。&lt;/p&gt;
&lt;h2 id=&quot;资源重复asset-duplication&quot;&gt;资源重复（Asset Duplication）&lt;/h2&gt;
&lt;p&gt;从 Unity5 开始的 AssetBundle 系统会在 Object 被打包进 AssetBundle 的时候，查找所有它的依赖。这是基于资源数据库（Asset Database）实现的。依赖信息用于确定将要被包含进 AssetBundle 的 Objects 集合。&lt;/p&gt;
&lt;p&gt;被明确指派了 AssetBundle 的 Objects 将只被打包进该 AssetBundle。一个 Object “被明确指派”的意思是：Object 的 assetBundleName 不为空。&lt;/p&gt;
&lt;p&gt;如果 Object 没有被明确指派给一个 AssetBundle，那么该 Object 将会被包含进所有引用了该 Object 的 AssetBundles 中，无论 AssetBundle 中有一个还是多个 Objects 引用了它。&lt;/p&gt;
&lt;p&gt;如果有两个不同的 Objects 被分别指派给两个不同的 AssetBundles，并且这两个 Objects 都对另一个 Object 有引用，那么该 Object 将被拷贝进两个 AssetBundles。重复的依赖同样会被实例化，这意味着被依赖的 Object 的两份拷贝会被认为是两个不同的 Objects，且拥有各自的 id。这将增加应用 AssetBundles 的大小。如果应用加载了这两个 AssetBundles，那么就会导致内存中加载了两份 Object 的拷贝。&lt;/p&gt;
&lt;p&gt;这里有些方法可以解决这样的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确保被打包进不同 AssetBundles 的 Objects 没有共同的依赖。把任何有共同依赖的 Objects 打包进同一个 AssetBundle ，避免重复依赖。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;这个方法通常不适用于那些有很多共同依赖的项目。并且这个方法会导致作为整体的 AssetBundles 被频繁地重新构建和重新下载，造成不方便和不高效。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;分割 AssetBundles，使得拥有共同依赖的 AssetBundles 不会同时被加载。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;这个方法对于特定类型的项目可能有效，比如以关卡为基础的游戏。然而，这会增加项目的 AssetBundles 大小，并且增加构建的次数和加载的次数。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;确保所有被依赖的资源被打包进它们自己的 AssetBundles。这就完全排除了重复资源的风险，但是同样的这会使情况变的复杂。应用必须追踪 AssetBundles 间的依赖关系，并且确保在调用任何 &lt;strong&gt;&lt;em&gt;AssetBundle.LoadAsset&lt;/em&gt;&lt;/strong&gt; 方法之前，正确的 AssetBundle 已经被加载好。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 Unity5 中是通过 UnityEditor 命名空间下的 &lt;strong&gt;&lt;em&gt;AssetDatabase&lt;/em&gt;&lt;/strong&gt; 方法来追踪 Object 的依赖。正如命名空间表明的，这个方法只能在 Unity 编辑器中使用，而不是在运行时。&lt;strong&gt;&lt;em&gt;AssetDatabase.GetDependencies&lt;/em&gt;&lt;/strong&gt; 方法可被用于定位一个 Object 或者资源的所有直接依赖。注意，这些依赖可能各自也有依赖。此外，&lt;strong&gt;&lt;em&gt;AssetImporter&lt;/em&gt;&lt;/strong&gt; 方法可用于查询某个 AssetBundle 中包含的 Object。&lt;/p&gt;
&lt;p&gt;组合使用 &lt;strong&gt;&lt;em&gt;AssetDatabase&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;AssetImporter&lt;/em&gt;&lt;/strong&gt; 的方法，就可以编写编辑器脚本，确保一个 AssetBundle 所有的直接或者间接依赖都被打包进一个或者各自的 AssetBundle 中；或者任意两个有共同依赖的 AssetBundles，被打包进同一个 AssetBundle。考虑到重复资源造成的内存开销，建议所有项目都有一个这样的脚本。&lt;/p&gt;
&lt;h2 id=&quot;sprite-图集重复sprite-atlas-duplication&quot;&gt;Sprite 图集重复（Sprite Atlas Duplication）&lt;/h2&gt;
&lt;p&gt;当 Unity5 中资源依赖的计算代码，和自动生成 Sprite Atlas 结合使用的时候，会出一点奇异的问题，下面的部分将描述这一点。&lt;/p&gt;
&lt;p&gt;任何自动生成的 Sprite 图集，都会和图集生成的 Sprite Objects 一起打包到 AssetBundle 中。如果 Sprite Objects 被分配给多个 AssetBundles，那么 Sprite Atlas 就不会被打包为一个 AssetBundle，并且出现资源重复；如果 Sprite Objects 没有指明 AssetBundle，Sprite Atlas 同样不会被打包为一个 AssetBundle。&lt;/p&gt;
&lt;p&gt;想要确保 Sprite Atlas 不重复，需要检查划分到同一个 Sprite Atlas 的 sprites (Tag 相同)要被指明为相同的 AssetBundle。&lt;/p&gt;
&lt;p&gt;（Unity 5.2.2p3 会有额外的图集问题，在 Unity 5.2.2p4 已修复，建议用尽可能新的版本，这里不再赘述）&lt;/p&gt;
&lt;h2 id=&quot;android-纹理相关问题&quot;&gt;Android 纹理相关问题&lt;/h2&gt;
&lt;p&gt;由于 Android 生态系统严重的设备碎片化，经常需要将纹理压缩为不同的格式。所有 Android 设备都支持 ETC1 格式图片，然而 ETC1 格式不支持透明通道。如果应用不需要 OpenGL ES 2 的支持，解决问题最简洁的方法就是使用 ETC2 格式，该格式需要 OpenGL ES 3 的支持。&lt;/p&gt;
&lt;p&gt;然而大多数应用都需要适配老旧设备，因此 ETC2 格式可能无法使用。解决这个问题的一个办法是使用 Unity5 的 AssetBundle 版本变量。（你还可以查看 Unity 安卓优化指南，来了解更多其他解决方案的细节）&lt;/p&gt;
&lt;p&gt;使用 AssetBundle 版本变量，所有不使用 ETC1 格式压缩的纹理必须分配到只包含纹理（texture-only）的 AssetBundles 中。接着，为不支持 ETC2 格式的安卓生态系统创建合适的版本变量，使用特定的纹理压缩格式，比如：DXT5、PVRTC、ATITC。针对每一个版本变量，改变纹理的 TextureImporter 设置，使其与版本变量一致。&lt;/p&gt;
&lt;p&gt;在运行时，使用 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://docs.unity3d.com/ScriptReference/SystemInfo.SupportsTextureFormat.html?_ga=1.141687282.1751468213.1479139860&quot;&gt;SystemInfo.SupportsTextureFormat&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 方法可以检测支持的纹理压缩格式。你可以使用这个信息，根据所支持的格式纹理，选择和加载相应的 AssetBundle 版本变量。&lt;/p&gt;
&lt;p&gt;更多关于 Android 纹理压缩格式的信息，可以点击&lt;a href=&quot;http://developer.android.com/guide/topics/graphics/opengl.html#textures&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;h2 id=&quot;ios-文件句柄溢出&quot;&gt;iOS 文件句柄溢出&lt;/h2&gt;
&lt;p&gt;这个问题在 Unity 5.3.2p2 就已经解决了。&lt;/p&gt;
&lt;p&gt;（这个问题简言之就是：iOS 在加载一个 AssetBundle 时会产生一个文件句柄，iOS 的句柄数上限是255个，超过这个上限就会加载失败并报错。这里不再赘述。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有帮助的话，点个赞或者评论一下吧！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/882d2c77e4bd&quot;&gt;下一章：【Unity3D技术文档翻译】第1.9篇 Unity AssetBundle 浏览管理工具 (终章)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 05:58:00 +0000</pubDate>
<dc:creator>何三思</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hearthstone/p/8478513.html</dc:identifier>
</item>
<item>
<title>深入理解区块链 - Pizzerias</title>
<link>http://www.cnblogs.com/dev-liu/p/blockchainbasic.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dev-liu/p/blockchainbasic.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132229791-1932119728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      一提到比特币、区块链，能让我们最先想到的就是去中心化，分布式数据库&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;账本，但是什么是去中心化，或者什么是区块链，却未必都能说得清。很多人对于区块链的认识就止步于此。网上查一查什么是区块链，各种专业词汇扑面而来，什么点对点网络，什么工作量证明机制&lt;/span&gt;&lt;span&gt;(PoW)&lt;/span&gt;&lt;span&gt;，什么数字签名、共识算法，把人看得云里雾里，也未必真能搞得懂。实际上，区块链就是这样的一种技术，它并非是从零开始，而是基于已有的这些技术，经过巧妙的结合生成的。如果要搞懂区块链，就要搞明白这些东西是怎么结合在一起的。所以这篇文章主要在宏观的基础上，在技术层面做更进一步的深入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何理解区块链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot; readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      首先，引入区块链的理念：将一个基于节点的去中心化共识协议与工作量证明&lt;/span&gt;&lt;span&gt;(PoW)&lt;/span&gt;&lt;span&gt;机制结合在一起。节点通过&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;机制获得参与到系统的权利，每隔一段时间将交易打包到区块中，从而创建出不断增长的区块链。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      这里主要有两个概念：去中心化和工作量证明机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      如何去中心化：区块链系统中的每一个区块，负责记录交易信息，每个用户的收支情况都被永久的存储在区块中供他人查询。每个节点都会保存一份完整的交易数据，所有这些节点组成了区块链的分布式数据库系统，任何一个节点的数据出现问题，都不会影响整个系统的运转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      工作量证明机制：工作量证明&lt;/span&gt;&lt;span&gt;(Proof Of Work&lt;/span&gt;&lt;span&gt;，简称&lt;/span&gt;&lt;span&gt;PoW)&lt;/span&gt;&lt;span&gt;，简单理解就是一份证明，用来确认你在系统中做过一定量的工作。相较于低效的监测工作的整个过程，通过对工作结果进行认证来证明完成了相应的工作量，则是一种非常高效的方式。例如我们通过完成工作中的各项任务来证明我们为公司创造了价值，从而得到公司的认可。而这种&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;工作证明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一般都会花费一定的时间才能得到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作量证明机制&lt;/span&gt;&lt;span&gt;(PoW)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      工作量证明机制，是一种应对拒绝服务攻击&lt;/span&gt;&lt;span&gt;(DoS)&lt;/span&gt;&lt;span&gt;和其他服务滥用的经济对策。它要求发起者进行一定量的运算作为代价，也就意味着需要消耗计算机一定的时间。例如现在网站登录时都需要输入的验证码&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;滑块或者拼图&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，都采用的是这种&lt;/span&gt;&lt;span&gt;CAPTCHA&lt;/span&gt;&lt;span&gt;模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      类似于&lt;/span&gt;&lt;span&gt;CAPTCHA&lt;/span&gt;&lt;span&gt;，哈希现金&lt;/span&gt;&lt;span&gt;(HashCash)&lt;/span&gt;&lt;span&gt;的原理是在邮件的消息头中增加一个包含收件人地址、发送时间和&lt;/span&gt;&lt;span&gt;salt&lt;/span&gt;&lt;span&gt;随机数的&lt;/span&gt;&lt;span&gt;hashcash stamp&lt;/span&gt;&lt;span&gt;的散列值，但是满足前&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;位都是&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的散列值才是合法的。这就需要发送者在正式发送前需要通过调整&lt;/span&gt;&lt;span&gt;salt&lt;/span&gt;&lt;span&gt;的值进行多次计算，在满足该条件后才能成功发送。但是我们不希望发送者在算出这个&lt;/span&gt;&lt;span&gt;stamp&lt;/span&gt;&lt;span&gt;后继续复用，所以&lt;/span&gt;&lt;span&gt;HashCash&lt;/span&gt;&lt;span&gt;规定了过期的&lt;/span&gt;&lt;span&gt;stamp&lt;/span&gt;&lt;span&gt;是非法的&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;即发送时间&lt;/span&gt; &lt;span&gt;&amp;gt; stamp&lt;/span&gt;&lt;span&gt;时间&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      区块链也是采用了类似&lt;/span&gt;&lt;span&gt;hashcash&lt;/span&gt;&lt;span&gt;的工作量证明方法，对区块头中的数据做双重&lt;/span&gt;&lt;span&gt;SHA256&lt;/span&gt;&lt;span&gt;运算&lt;/span&gt;&lt;span&gt;(&lt;/span&gt; &lt;span&gt;即&lt;/span&gt;&lt;span&gt;SHA256(SHA256(HEADER)) )&lt;/span&gt;&lt;span&gt;，与当前网络的目标值做对比，如果小于目标值，则完成工作量证明。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      这里对&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;做了较多的解释，是为了便于理解&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;是如何应用在区块链上的。挖矿也是通过&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;进行的。在比特币系统中，节点完成工作量证明后，就代表获得这个区块的交易记账权。系统会通过&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;机制让矿工们竞争记账权，谁在单位时间内执行的运算更多&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;拥有更高的算力&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，谁就有更高的概率获得区块的记账权。获得记账权的矿工将把该区块广播到网络中，全网其他节点在验证区块满足特定的条件后，其区块会被链接在主链上，从而在全网范围内形成对当前网络状态的一次共识，该矿工也会得到系统奖励的一定数量的代币。所有的区块通过这种形式链接在一起，形成了区块链的主链，从创世区块到当前生成的最新区块，所有历史交易数据都是公开透明的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      上面提到了区块是用于记录交易信息的，区块头中的数据参与了&lt;/span&gt;&lt;span&gt;PoW&lt;/span&gt;&lt;span&gt;的过程。那么接下来有必要进一步分析区块的内容了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;区块的组成&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132352296-510409923.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      每个区块由区块头和区块体两部分组成。区块头中主要包含前一个区块的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;(Prevhash)&lt;/span&gt;&lt;span&gt;、时间戳&lt;/span&gt;&lt;span&gt;(Timestamp)&lt;/span&gt;&lt;span&gt;、随机数&lt;/span&gt;&lt;span&gt;(Nonce)&lt;/span&gt;&lt;span&gt;、当前区块的目标&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;(CurrentTarget)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的根值&lt;/span&gt;&lt;span&gt;(Merkle Root)&lt;/span&gt;&lt;span&gt;等信息；区块体中则包含了具体的交易数量&lt;/span&gt;&lt;span&gt;(TX NUM)&lt;/span&gt;&lt;span&gt;和自上一个区块生成以来发生的所有交易的列表。这个交易列表就是记账本，每一笔交易都会被永久地记入区块中，任何人都可以查询。而且交易都会伴随数字签名，确保交易不可篡改及真实有效性，所有交易都将通过&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算产生一个唯一的&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;根值记录到区块头中&lt;/span&gt;&lt;span&gt;(Merkle&lt;/span&gt;&lt;span&gt;树是一种数据结构，后面将做介绍&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;状态转移与UTXO交易模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      从技术的角度出发，比特币记账本可以看做是一个状态转移的系统。持有人对现存的所有比特币的持有情况，可以理解为系统当前的一种状态。例如：小明有&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;个比特币，表示在当前的状态下，小明持有&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;个比特币。当小明想进行交易时，比如给小王转&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个比特币，就需要以当前的状态&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;拥有&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;个比特币&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;和发起的交易&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;给小王转&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个比特币&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，通过状态转移，生成新的状态&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;小明有&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;个比特币，小王有&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;个比特币&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。这个状态转移可以看做是一个函数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APPLY(STATE, TRANSACTION) =&amp;gt; NEW_STATE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示小明给小王转账的交易：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APPLY({XiaoMing: 100, XiaoWang: 0}, &quot;send 20 from XiaoMing to XiaoWang&quot;) =&amp;gt; {XiaoMing: 80, XiaoWang: 20 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      可以发现，交易的过程就是一个从输入到输出的过程，一个资金流转的过程，并且创世区块和后来挖矿产生的奖励区块不适用于这个公式&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;创世区块是整个链上的第一个区块；挖矿的奖励区块是凭空产生的，是发行代币的方式&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。除此之外，其他的交易都必须要依据现有的输入来产生新的输出。而现有的输入是从何而来的，必然是从这个持有人在上一笔交易中的输出得到的。稍微有点绕，按照上面的例子，假如小王要给小李再转&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;个比特币，这笔交易的输入&lt;/span&gt;&lt;span&gt;(5&lt;/span&gt;&lt;span&gt;个币&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;必须是上一笔交易&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;小明给小王转账&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;中未被使用的输出&lt;/span&gt;&lt;span&gt;(20&lt;/span&gt;&lt;span&gt;个币&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。这个未被使用的交易输出也叫做&lt;/span&gt;&lt;span&gt;UTXO(Unspent TX Output)&lt;/span&gt;&lt;span&gt;，是比特币交易的基本单位。也可以简单理解为空闲的、未被占用的金额，就像已经花出去的钱&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;你上一笔交易的&lt;/span&gt;&lt;span&gt;UTXO)&lt;/span&gt;&lt;span&gt;是不可能再花一遍的&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;已成为别人的&lt;/span&gt;&lt;span&gt;UTXO)&lt;/span&gt;&lt;span&gt;。一笔交易可以包括一个或多个输入和一个或多个输出，每个输入包含一个对现有&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;的引用和与持有者私钥创建的密码学签名；每个输出包含一个新的加入到状态中的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132415506-1545251215.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于交易中的每个输入和状态，有如下的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;如果引用的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;不在当前的状态中，则会返回错误；如果签名与引用的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;的持有者签名不一致，也会返回错误。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;如果所有输入的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;总额与所有输出的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;总额不等，会返回错误。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;返回的新状态&lt;/span&gt;&lt;span&gt;NEW_STATE&lt;/span&gt;&lt;span&gt;中，移除了所有输入的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;，增加了所有输出的&lt;/span&gt;&lt;span&gt;UTXO&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Merkle树&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      Merkle&lt;/span&gt;&lt;span&gt;树是数据结构中的一种树结构，可以是二叉树，也可以是多叉树，具有树的所有特点。由于&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树中会进行&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算，所以也被称为&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;树。在了解&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树之前，先来看看&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;算法及&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      Hash&lt;/span&gt;&lt;span&gt;算法是一种可以将任意长度的数据转换成固定长度字符串的算法。是一种安全散列算法。最显著的特点是几乎不可逆、无冲突。&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;算法最常见的应用就是对数据完整性的校验。例如我们在下载一些文件时，资源提供方会给出一个&lt;/span&gt;&lt;span&gt;MD5&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;SHA&lt;/span&gt;&lt;span&gt;的值，这个值实际上就是资源在经过&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算后的值，用户下载数据后，可以对数据进行&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，然后跟这个值比对，如果相同，就说明数据在传输过程中无损坏或篡改。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132437666-538176808.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      缺点：当下载较大的文件时，如果出现&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值不匹配的情况，那么就要重新下载整个文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      这种通过对整个文件进行&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算来判断数据是否损坏的方法，效率很低下。如果将文件分割成一个个小的数据块，分别对其做&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，就得到了&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;。在点对点网络中传输数据时，会从多个节点同时下载数据。假设某些节点网络不稳定或者数据不可信，那么为了验证数据的准确性，就会采用&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;，如果某些数据块损坏了，只需要重新下载这些小的数据块即可，无需重新下载整个文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      通常在下载数据前，会先从可信数据源那里获取一个&lt;/span&gt;&lt;span&gt;Root Hash&lt;/span&gt;&lt;span&gt;值。&lt;/span&gt;&lt;span&gt;Root Hash&lt;/span&gt;&lt;span&gt;是将&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;中每个数据块的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值拼接到一起，再做一次&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算所得到的值。这个值用来校验&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;是否正确。得到&lt;/span&gt;&lt;span&gt;Root Hash&lt;/span&gt;&lt;span&gt;后，会再下载该数据的&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;。判断&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;正确后，才开始文件数据的下载。最后将下载的数据块做&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;后与&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;做比对，如果出现不一致，则说明数据被损坏，需要重新下载该数据块。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;729&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132529132-1346532573.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;350&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      然后回过头来再看&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树，它的底层与&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;一样，都是将数据分成小数据块，然后分别计算其&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值。但是再往上一层就不同了，它不是把所有的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值合并到一起做&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，而是将两个相邻的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值拼接在一起进行&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;运算，产生一个新的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;。例如&lt;/span&gt;&lt;span&gt;Block1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;201w&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Block2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;span&gt;0mzc&lt;/span&gt;&lt;span&gt;合并&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;后产生新的&lt;/span&gt;&lt;span&gt;3ali Hash&lt;/span&gt;&lt;span&gt;值。而如果两两匹配后出现孤立的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值，则直接将其做&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，例如&lt;/span&gt;&lt;span&gt;Block5&lt;/span&gt;&lt;span&gt;。最终产生一个&lt;/span&gt;&lt;span&gt;Root Hash&lt;/span&gt;&lt;span&gt;值，通常称为&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;同样，在下载前，会先从可信数据源中获取正确的&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;，然后再从其他节点下载&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树，通过&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;来辨别&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的真伪。如果发现不匹配，则从其他节点继续下载该&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树，直到获得一个与可信&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;相匹配的&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树是逐级分支的，所以它可以从任意一个分支开始下载并验证。考虑&lt;/span&gt;&lt;span&gt;Root-&amp;gt;d063-&amp;gt;09yk-&amp;gt;a8b5-&amp;gt;Block3&lt;/span&gt;&lt;span&gt;这个分支，如果对这个分支的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值验证通过后，就可以下载&lt;/span&gt;&lt;span&gt;Block3&lt;/span&gt;&lt;span&gt;的数据了。而在&lt;/span&gt;&lt;span&gt;HashList&lt;/span&gt;&lt;span&gt;中需要先得到整个&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值列表后才能使用&lt;/span&gt;&lt;span&gt;Root Hash&lt;/span&gt;&lt;span&gt;验证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;649&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132604976-1429493735.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;450&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      在区块链系统中，最下层的叶节点中存放的是交易数据，每个中间层的节点都是它的两个子节点的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，根节点也是它的两个子节点的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;，代表&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的顶部。如果有攻击者恶意篡改交易数据，或者篡改&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的某一部分，必然导致上层节点的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值变动，最终导致验证不通过。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;432&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      了解了&lt;/span&gt;&lt;span&gt;Merkle&lt;/span&gt;&lt;span&gt;树的结构后，如果我们要查找某一笔交易，那么顺序是怎样的呢？首先，可以根据区块头中的时间戳确认交易存在的具体区块。而&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;也是放在区块头中的，如果我们从&lt;/span&gt;&lt;span&gt;Merkle Root&lt;/span&gt;&lt;span&gt;开始向下查找，假设底层有&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;笔交易数据，那么找到所需的步骤为&lt;/span&gt;&lt;span&gt;log2(n)&lt;/span&gt;&lt;span&gt;，其实就是算法中的二分查找。简化支付验证&lt;/span&gt;&lt;span&gt;(Simplified Payment Verification)&lt;/span&gt;&lt;span&gt;就是利用这种方案，实现了轻量级的钱包客户端，只需下载区块头及相关交易的分支，即可对交易进行确认。但是它也存在一些缺点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;容易遭到全节点的拒绝服务，所以要保证较多的与全节点的连接，而且要保证这些节点是可信的；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.spv&lt;/span&gt;&lt;span&gt;客户端向全节点请求的交易必须与它的密钥一致，这样全节点会看到该客户端的相应用户的公钥，造成隐私泄露。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P2P网络&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132626142-2132219804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      P2P&lt;/span&gt;&lt;span&gt;网络即对等网络，是一种去中心化的分布式应用架构。这种网络结构与目前传统的&lt;/span&gt;&lt;span&gt;CS(Client/Server)&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;BS(Browse Server)&lt;/span&gt;&lt;span&gt;结构的本质区别是，网络中不存在中心节点&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;服务器。在&lt;/span&gt;&lt;span&gt;P2P&lt;/span&gt;&lt;span&gt;架构中，每个节点的地位都是对等的，都具有相同的功能，无主从之分。节点通过将硬件资源以服务的形式共享到网络中，这些共享的资源可以被其他节点直接访问。一个节点既可充当服务器的角色，又是服务请求方，故节点越多，网络中可提供的资源就越多。而&lt;/span&gt;&lt;span&gt;CS&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;BS&lt;/span&gt;&lt;span&gt;这些模式都是以中心应用服务器为核心的，由用户向中心服务器发起请求，中心服务器处理请求后再将结果返回给用户。用户之间的通信也需要通过中心服务器转发来完成。所以&lt;/span&gt;&lt;span&gt;P2P&lt;/span&gt;&lt;span&gt;网络中的核心思想也是去中心化。除了这个特点，&lt;/span&gt;&lt;span&gt;P2P&lt;/span&gt;&lt;span&gt;网络还具有扩展性强、健壮性、高性价比、负载均衡、隐私保护等特点。我们日常使用的&lt;/span&gt;&lt;span&gt;BT&lt;/span&gt;&lt;span&gt;下载就是采用&lt;/span&gt;&lt;span&gt;P2P&lt;/span&gt;&lt;span&gt;让客户端之间进行数据传输。&lt;/span&gt;&lt;span&gt;BT&lt;/span&gt;&lt;span&gt;下载是通过&lt;/span&gt;&lt;span&gt;BitTorrent&lt;/span&gt;&lt;span&gt;协议&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;一种中心索引式的&lt;/span&gt;&lt;span&gt;P2P&lt;/span&gt;&lt;span&gt;文件分分析通信协议&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，让你在下载其他用户资源的同时，也为其他用户提供上传。所以下载的人越多，可连接到的节点就越多，下载速度就越快。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132634624-918408562.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      在&lt;/span&gt;&lt;span&gt;BT&lt;/span&gt;&lt;span&gt;架构中，我们发现还是存在一个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中心服务器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，该服务器的作用并非提供下载服务，而是对发布的&lt;/span&gt;&lt;span&gt;torrent&lt;/span&gt;&lt;span&gt;文件进行统一管理。&lt;/span&gt;&lt;span&gt;torrent&lt;/span&gt;&lt;span&gt;文件本质上是一个索引文件，包含了&lt;/span&gt;&lt;span&gt;Tracker&lt;/span&gt;&lt;span&gt;信息&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;发布资源的服务器的位置&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;和文件信息&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;文件名、大小、&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;值等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，这些信息根据&lt;/span&gt;&lt;span&gt;BitTorrent&lt;/span&gt;&lt;span&gt;协议内的&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;编码规则进行编码。&lt;/span&gt;&lt;span&gt;torrent&lt;/span&gt;&lt;span&gt;文件中的&lt;/span&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span&gt;信息是对每一块要下载的文件内容的加密结果。使用文本工具打开&lt;/span&gt;&lt;span&gt;.torrent&lt;/span&gt;&lt;span&gt;文件，就可以看个大概&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;乱码是&lt;/span&gt;&lt;span&gt;SHA1&lt;/span&gt;&lt;span&gt;校验码&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201802/1295539-20180227132642194-1855834450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      通过以上的内容可以发现，组成区块链的这些技术实际上早已有着广泛的应用，只是我们之前并未那么密切的关注过，而区块链只是将这些技术巧妙的结合到了一起。理解了这些技术的原理后，我们就可以揭开区块链神秘的面纱，去进一步窥探其中的奥秘。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《区块链技术指南》&lt;/span&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;邹均&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;张海宁著&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;Ethereum white paper&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 05:32:00 +0000</pubDate>
<dc:creator>Pizzerias</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dev-liu/p/blockchainbasic.html</dc:identifier>
</item>
<item>
<title>Halcon一日一练：图像拼接技术2:步骤与例程 - 超帆越浪</title>
<link>http://www.cnblogs.com/amosyang/p/8478213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amosyang/p/8478213.html</guid>
<description>&lt;p&gt; 上一篇主要介绍了图像拼接的一些原理和方法，这一篇将主要介绍步骤和例程： &lt;/p&gt;&lt;p&gt;1、特征检测：从图像中检测出显著且独特的图像特征，诸如：闭合区域，直线段，边缘，轮廓，点等。&lt;/p&gt;&lt;p&gt;2、特征匹配：从相似度确定图像之间特征的对应关系，又分为如下几类：&lt;/p&gt;&lt;p&gt;4、图像变换和重采样：可以通过前向或后向的方式来实现，插值的方法有最近邻插值、双线性插值、双三次函数插值、二次样条插值、三次B样条插值、高阶B样条插值。&lt;/p&gt;&lt;p&gt;基于特征的方法普遍适用于局部结构信息更显著的情况，能够处理图像之间复杂变形的情况，不足之处是特征检测困难且不稳定，最关键的一点是需要有一种判断力很强的、鲁棒性能好的且对图像之间变化保持不变的特征匹配算法。&lt;/p&gt;&lt;div readability=&quot;320&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; **&lt;span&gt;此例程讲解了如何将几张局部的PCB图像拼接居一张大的马赛克PCB图像。
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; **&lt;span&gt;此例程使用算子proj_match_points_ransac和算子 gen_projective_masaic完成上述工作。
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; **&lt;span&gt;请注意：这个PCB图像有一几处看起来像拼接逢合线的破损点，为了更好的区分真正的缝合线，例程呈现逢合线。
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;dev_update_off ()
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;dev_close_window ()
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; dev_open_window (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;480&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, WindowHandle)
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; set_display_font (WindowHandle, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mono&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; **&lt;span&gt;一张一张的读取图像。
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;gen_empty_obj (Images)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; J := &lt;span&gt;1&lt;/span&gt; to &lt;span&gt;6&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     read_image (Image, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mosaic/pcb_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + J$&lt;span&gt;'&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    concat_obj (Images, Image, Images)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    dev_display (Image)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + J$&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     wait_seconds (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;endfor
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; disp_continue_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;stop ()
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; *&lt;span&gt; To show the point matches that are used to compute the projective
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; * transformation between the images, we will show all images &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a large
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; *&lt;span&gt; tiled image with some space between the images so that the extents
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; *&lt;span&gt; of the images are easily visible.
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; dev_set_window_extents (-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;640&lt;/span&gt; / &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;2980&lt;/span&gt; / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; tile_images_offset (Images, TiledImage, [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;500&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;,&lt;span&gt;1500&lt;/span&gt;,&lt;span&gt;2000&lt;/span&gt;,&lt;span&gt;2500&lt;/span&gt;], [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;2980&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;dev_clear_window ()
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;dev_display (TiledImage)
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;All 6 images&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Click \'Run\'\nto continue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2980&lt;/span&gt; / &lt;span&gt;4&lt;/span&gt; - &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;stop ()
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; * Now we compute point matches between the five pairs of images and with &lt;span&gt;this&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; *&lt;span&gt; the projective transformation between the image pairs.  Note that the code
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; * below calls the point &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; each image pair.  Since the images form
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; *&lt;span&gt; a strip, with a little book keeping we could make the process a little more
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; * efficient by saving the points &lt;span&gt;from&lt;/span&gt; the last iteration (ImageT &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pair J will
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; * be identical to ImageF &lt;span&gt;in&lt;/span&gt; pair J+&lt;span&gt;1&lt;/span&gt;).  This &lt;span&gt;is&lt;/span&gt;&lt;span&gt; not done here because such an
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; * optimization would be quite cumbersome &lt;span&gt;in&lt;/span&gt; the general &lt;span&gt;case&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; the images
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; * can lie &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a general configuration that cannot be represented by a strip.
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;dev_clear_window ()
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;dev_display (TiledImage)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Point matches&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; *&lt;span&gt; We define the image pairs, i.e., which image should be mapped to which image.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; From := [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; To := [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; Num := |From|
&lt;span&gt; 46&lt;/span&gt; *&lt;span&gt; We need a variable to accumulate the projective transformation matrices.
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; ProjMatrices :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; *&lt;span&gt; Furthermore, since we want to create a rigid mosaic below we need to
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; *&lt;span&gt; accumulate all the point correspondences and the number of matches per
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; *&lt;span&gt; image pair.
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; Rows1 :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; Cols1 :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; Rows2 :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; Cols2 :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; NumMatches :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; *&lt;span&gt; Now we can determine the transformations between the five image pairs.
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; J := &lt;span&gt;0&lt;/span&gt; to Num - &lt;span&gt;1&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;     F :=&lt;span&gt; From[J]
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     T :=&lt;span&gt; To[J]
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    select_obj (Images, ImageF, F)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    select_obj (Images, ImageT, T)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     * Extract the points &lt;span&gt;in&lt;/span&gt;&lt;span&gt; both images.
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     points_foerstner (ImageF, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;0.3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gauss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, RowJunctionsF, ColJunctionsF, CoRRJunctionsF, CoRCJunctionsF, CoCCJunctionsF, RowAreaF, ColAreaF, CoRRAreaF, CoRCAreaF, CoCCAreaF)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     points_foerstner (ImageT, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;0.3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gauss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, RowJunctionsT, ColJunctionsT, CoRRJunctionsT, CoRCJunctionsT, CoCCJunctionsT, RowAreaT, ColAreaT, CoRRAreaT, CoRCAreaT, CoCCAreaT)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     * Determine the point matches and the transformation &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the current
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     *&lt;span&gt; image pair.
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     proj_match_points_ransac (ImageF, ImageT, RowJunctionsF, ColJunctionsF, RowJunctionsT, ColJunctionsT, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ncc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;480&lt;/span&gt;, &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gold_standard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4364537&lt;/span&gt;&lt;span&gt;, ProjMatrix, Points1, Points2)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     *&lt;span&gt; Accumulate the transformation matrix.
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     ProjMatrices :=&lt;span&gt; [ProjMatrices,ProjMatrix]
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     *&lt;span&gt; Accumulate the point matches and number of point matches.
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     Rows1 :=&lt;span&gt; [Rows1,subset(RowJunctionsF,Points1)]
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     Cols1 :=&lt;span&gt; [Cols1,subset(ColJunctionsF,Points1)]
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     Rows2 :=&lt;span&gt; [Rows2,subset(RowJunctionsT,Points2)]
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     Cols2 :=&lt;span&gt; [Cols2,subset(ColJunctionsT,Points2)]
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     NumMatches := [NumMatches,|Points1|&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     * Generate crosses that represent the extracted points &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the tiled image.
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     * Note that we have to take the row offsets of the images &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the tiled image
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     *&lt;span&gt; into account.
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     gen_cross_contour_xld (PointsF, RowJunctionsF + (F - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;500&lt;/span&gt;, ColJunctionsF, &lt;span&gt;6&lt;/span&gt;, rad(&lt;span&gt;45&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     gen_cross_contour_xld (PointsT, RowJunctionsT + (T - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;500&lt;/span&gt;, ColJunctionsT, &lt;span&gt;6&lt;/span&gt;, rad(&lt;span&gt;45&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     * Generate a representation of the matched point pairs &lt;span&gt;as&lt;/span&gt;&lt;span&gt; lines.  We create
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     * XLD contours &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the lines so that we can zoom into the graphics window
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     *&lt;span&gt; to take a closer look at the matches.
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     RowF := subset(RowJunctionsF,Points1) + (F - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;500&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;     ColF :=&lt;span&gt; subset(ColJunctionsF,Points1)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     RowT := subset(RowJunctionsT,Points2) + (T - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;500&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;     ColT :=&lt;span&gt; subset(ColJunctionsT,Points2)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    gen_empty_obj (Matches)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; K := &lt;span&gt;0&lt;/span&gt; to |RowF| - &lt;span&gt;1&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        gen_contour_polygon_xld (Match, [RowF[K],RowT[K]], [ColF[K],ColT[K]])
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        concat_obj (Matches, Match, Matches)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    endfor
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     *&lt;span&gt; Now display the extracted data.
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    dev_display (Matches)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    dev_display (PointsF)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    dev_display (PointsT)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;endfor
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Click \'Run\'\nto continue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2980&lt;/span&gt; / &lt;span&gt;4&lt;/span&gt; - &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;stop ()
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; * Finally, we can generate the mosaic image &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the projective transformations.
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; gen_projective_mosaic (Images, MosaicImage, &lt;span&gt;2&lt;/span&gt;, From, To, ProjMatrices, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, MosaicMatrices2D)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;get_image_size (MosaicImage, Width, Height)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; dev_set_window_extents (-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, Width / &lt;span&gt;3&lt;/span&gt;, Height / &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;dev_clear_window ()
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;dev_display (MosaicImage)
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Projective mosaic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Click \'Run\'\nto continue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, Height / &lt;span&gt;3&lt;/span&gt; - &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;stop ()
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; * To show more clearly that the folds visible &lt;span&gt;in&lt;/span&gt; the image &lt;span&gt;do&lt;/span&gt; not result &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; * mosaicking, we display the seams between the images &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the mosaic image.
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; *&lt;span&gt; This can be done most easily by creating an image that contains the border
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; * of the images, generating a mosaic &lt;span&gt;from&lt;/span&gt;&lt;span&gt; it, and segmenting the resulting
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; *&lt;span&gt; mosaic image.
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;get_image_size (Image, Width, Height)
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; gen_image_const (ImageBlank, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, Width, Height)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; gen_rectangle1 (Rectangle, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, Height - &lt;span&gt;1&lt;/span&gt;, Width - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; paint_region (Rectangle, ImageBlank, ImageBorder, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;margin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;gen_empty_obj (ImagesBorder)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; J := &lt;span&gt;1&lt;/span&gt; to &lt;span&gt;6&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    concat_obj (ImagesBorder, ImageBorder, ImagesBorder)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;endfor
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; gen_projective_mosaic (ImagesBorder, MosaicImageBorder, &lt;span&gt;2&lt;/span&gt;, From, To, ProjMatrices, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, MosaicMatrices2D)
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; threshold (MosaicImageBorder, Seams, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;dev_clear_window ()
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;dev_display (MosaicImage)
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seams between the\nimages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yellow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;dev_display (Seams)
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Click \'Run\'\nto continue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;stop ()
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; *&lt;span&gt; If you look very closely at the projective mosaic above, you may note that
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; * there &lt;span&gt;is&lt;/span&gt; a very slight projective distortion &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the mosaic.  This happens
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; *&lt;span&gt; because the transformations cannot be determined with perfect accuracy
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; * because of very small errors &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the point coordinates due to noise.  Because
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; *&lt;span&gt; of the strip configuration, essentially the overlapping area between the image
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; * pairs can act like a hinge around which the images may rotate &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of the image
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; * plane.  In &lt;span&gt;this&lt;/span&gt;&lt;span&gt; example, we know that the mapping between the images must
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; *&lt;span&gt; be a rigid transformation.  If we want to force the transformation to be rigid
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; *&lt;span&gt; we can simply use bundle_adjust_mosaic.
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; bundle_adjust_mosaic (&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, From, To, ProjMatrices, Rows1, Cols1, Rows2, Cols2, NumMatches, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rigid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, MosaicMatrices2D, Rows, Cols, Error)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; * Now, we can generate the mosaic image &lt;span&gt;from&lt;/span&gt;&lt;span&gt; the rigid transformations.
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; gen_bundle_adjusted_mosaic (Images, MosaicImageRigid, MosaicMatrices2D, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, TransMatrix2D)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;get_image_size (MosaicImageRigid, Width, Height)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; dev_set_window_extents (-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, Width / &lt;span&gt;3&lt;/span&gt;, Height / &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;dev_clear_window ()
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;dev_display (MosaicImageRigid)
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; disp_message (WindowHandle, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Rigid mosaic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主要介绍如何使用金字塔算法快速获取两个图像的特征点进行拼接。&lt;/p&gt;&lt;div readability=&quot;181&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; *&lt;span&gt; This example program shows how images can be combined
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; * into a mosaic image &lt;span&gt;using&lt;/span&gt;&lt;span&gt; proj_match_points_ransac_guided
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; *&lt;span&gt; and gen_projective_mosaic.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; * It &lt;span&gt;is&lt;/span&gt;&lt;span&gt; shown how the calculation of the projection between two
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; * images can be accelerated &lt;span&gt;using&lt;/span&gt;&lt;span&gt; an image pyramid.
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; * 
&lt;span&gt;  7&lt;/span&gt; *&lt;span&gt; Initializations
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; ImgPath := &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3d_machine_vision/mosaic/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; ImgName := &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bga_r_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; Times :=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; Colors := [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;coral&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yellow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lime green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; read_image (Images, ImgPath + ImgName + [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;06&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;dev_update_off ()
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;dev_close_window ()
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; dev_open_window_fit_size (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;980&lt;/span&gt;, &lt;span&gt;320&lt;/span&gt;, &lt;span&gt;490&lt;/span&gt;&lt;span&gt;, WindowHandle)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; dev_open_window_fit_size (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;330&lt;/span&gt;, &lt;span&gt;490&lt;/span&gt;, &lt;span&gt;490&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;490&lt;/span&gt;&lt;span&gt;, WindowHandle1)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; set_display_font (WindowHandle, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mono&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; set_display_font (WindowHandle1, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mono&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; * The &lt;span&gt;internal&lt;/span&gt;&lt;span&gt; camera parameters of the used camera
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; *&lt;span&gt; (necessary to eliminate radial distortions)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; CamParam := [&lt;span&gt;0.0121693&lt;/span&gt;,-&lt;span&gt;2675.63&lt;/span&gt;,&lt;span&gt;7.40046e-006&lt;/span&gt;,&lt;span&gt;7.4e-006&lt;/span&gt;,&lt;span&gt;290.491&lt;/span&gt;,&lt;span&gt;258.887&lt;/span&gt;,&lt;span&gt;640&lt;/span&gt;,&lt;span&gt;480&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; change_radial_distortion_cam_par (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adaptive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, CamParam, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, CamParOut)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;change_radial_distortion_image (Images, Images, Images, CamParam, CamParOut)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; *&lt;span&gt; To show the point matches that are used to compute the
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; * transformation between the images, we will show both images &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; *&lt;span&gt; tiled image with some space between the images so that the extents
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; *&lt;span&gt; of the images are easily visible.
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; tile_images_offset (Images, TiledImage, [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;500&lt;/span&gt;], [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], [-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;640&lt;/span&gt;, &lt;span&gt;980&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; * 
&lt;span&gt; 30&lt;/span&gt; *&lt;span&gt; Now we can determine the transformations between the image pairs.
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; From := &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; To := &lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;select_obj (Images, ImageF, From)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;select_obj (Images, ImageT, To)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; * 
&lt;span&gt; 36&lt;/span&gt; * Repeat the calculation &lt;span&gt;4&lt;/span&gt;&lt;span&gt; times with a different number of pyramid levels
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; NumLevels := &lt;span&gt;1&lt;/span&gt; to &lt;span&gt;4&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;     * 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    dev_clear_window ()
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    dev_set_window (WindowHandle)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    dev_clear_window ()
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    dev_display (TiledImage)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     disp_message (WindowHandle, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Calculate point matches&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;with &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + NumLevels + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; pyramid levels&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please wait ...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     * 
&lt;span&gt; 45&lt;/span&gt;     *&lt;span&gt; Calculate the projection between the two images
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     * Check the procedure&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s comments for details&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    count_seconds (S1)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    proj_match_points_ransac_pyramid (ImageF, ImageT, NumLevels, RowFAll, ColFAll, RowTAll, ColTAll, ProjMatrix, Points1, Points2)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    count_seconds (S2)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     Times := [Times,S2 -&lt;span&gt; S1]
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     * 
&lt;span&gt; 52&lt;/span&gt;     *&lt;span&gt; Display point correspondences
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     gen_cross_contour_xld (PointsF, RowFAll, ColFAll, &lt;span&gt;6&lt;/span&gt;, rad(&lt;span&gt;45&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     gen_cross_contour_xld (PointsT, RowTAll + &lt;span&gt;500&lt;/span&gt;, ColTAll, &lt;span&gt;6&lt;/span&gt;, rad(&lt;span&gt;45&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     RowF :=&lt;span&gt; subset(RowFAll,Points1)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     ColF :=&lt;span&gt; subset(ColFAll,Points1)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     RowT := subset(RowTAll,Points2) + &lt;span&gt;500&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;     ColT :=&lt;span&gt; subset(ColTAll,Points2)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    gen_empty_obj (Matches)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; K := &lt;span&gt;0&lt;/span&gt; to |RowF| - &lt;span&gt;1&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        gen_contour_polygon_xld (Match, [RowF[K],RowT[K]], [ColF[K],ColT[K]])
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        concat_obj (Matches, Match, Matches)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    endfor
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    dev_display (TiledImage)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    dev_display (Matches)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     dev_set_color (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;green&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    dev_display (PointsF)
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    dev_display (PointsT)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     disp_message (WindowHandle, [|RowF| + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; point matches&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time used: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + (S2 - S1)$&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     * 
&lt;span&gt; 72&lt;/span&gt;     *&lt;span&gt; Generate the mosaic image
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     gen_projective_mosaic (Images, MosaicImage, &lt;span&gt;1&lt;/span&gt;, From, To, ProjMatrix, [&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, MosaicMatrices2D)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     * 
&lt;span&gt; 75&lt;/span&gt;     *&lt;span&gt; Display mosaic image
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    get_image_size (MosaicImage, Width, Height)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    dev_set_window (WindowHandle1)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     dev_resize_window_fit_image (MosaicImage, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;330&lt;/span&gt;, [&lt;span&gt;400&lt;/span&gt;,&lt;span&gt;700&lt;/span&gt;], &lt;span&gt;700&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    dev_clear_window ()
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;    dev_display (MosaicImage)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     disp_message (WindowHandle1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Projective mosaic (used &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + NumLevels + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; pyramid levels)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     disp_continue_message (WindowHandle1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    stop ()
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;endfor
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; * 
&lt;span&gt; 86&lt;/span&gt; *&lt;span&gt; Display execution times
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;dev_set_window (WindowHandle)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;dev_close_window ()
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; MaxTime :=&lt;span&gt; max(Times)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; BaseRow := &lt;span&gt;380&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; RectHeight := &lt;span&gt;300&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; disp_message (WindowHandle1, [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time in s:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(#levels used)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, BaseRow + &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; Index := &lt;span&gt;0&lt;/span&gt; to |Times| - &lt;span&gt;1&lt;/span&gt; by &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     gen_rectangle1 (Rectangle, BaseRow - RectHeight * Times[Index] / MaxTime, &lt;span&gt;200&lt;/span&gt; + Index * &lt;span&gt;100&lt;/span&gt;, BaseRow, &lt;span&gt;280&lt;/span&gt; + Index * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     disp_message (WindowHandle1, [Times[Index]$&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + (Index + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, BaseRow + &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt; + &lt;span&gt;100&lt;/span&gt; * Index, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    dev_set_color (Colors[Index])
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     dev_set_draw (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    dev_display (Rectangle)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;endfor
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; disp_finished_message (WindowHandle1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Tue, 27 Feb 2018 05:15:00 +0000</pubDate>
<dc:creator>超帆越浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amosyang/p/8478213.html</dc:identifier>
</item>
<item>
<title>华为云照片的爬虫程序更新(python3.6) - 黯然销魂掌2015</title>
<link>http://www.cnblogs.com/zhongtang/p/8478307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongtang/p/8478307.html</guid>
<description>&lt;p&gt;每年终都有一个习惯，就是整理资料进行归档，结果发现手机照片全备份在华为云里，在官网上找了一圈，没找到官方的pc工具用来同步照片。&lt;/p&gt;
&lt;p&gt;于是找出上次写的程序，看看能不能爬到数据，然而……果然不好用。因为华为在登录上又增加了一些验证机制，譬如：账号保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/415474/201802/415474-20180227112510298-368530588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抓了一下报文，发现逻辑变复杂了很多，部分逻辑还封装在js里。&lt;/p&gt;
&lt;p&gt;算了，懒得琢磨了，直接用selenium吧。&lt;/p&gt;

&lt;p&gt;1、用Python + selenium +浏览器 ，人工登录，保存cookie及签名信息。&lt;/p&gt;
&lt;p&gt;2、再调用requests加第一步保存的cookie和前面，直接向后台发post请求，获取数据。&lt;/p&gt;
&lt;p&gt;思路确定，开干。&lt;/p&gt;

&lt;p&gt;1、python3.6，在最近的一个项目中由于多次遇到中文问题，实在是烦不胜烦，所以就把开发工具升级到了py3，确实方便多了。&lt;/p&gt;
&lt;p&gt;说到py2升到py3，虽然还是有些写法调整，有些包在py3下不支持，但总体来说，迁移很平稳，写法问题，百度一下基本就可以解决。&lt;/p&gt;
&lt;p&gt;我用的Anaconda的python包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
3.6.3 |Anaconda custom (64-bit)| (default, Oct 15 2017, 03:27:45) [MSC v.1900 64 bit (AMD64)&lt;span&gt;]
Python &lt;/span&gt;&lt;span&gt;Type&lt;/span&gt; &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; &lt;span&gt;for&lt;/span&gt; more information.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、selenium 3.9.0，用conda现安装的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
conda install selenium 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、浏览器，试用了firefox，edge，chrome，phantomjs，分别版本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
firefox： 58.0.2 (64&lt;span&gt; 位）
edge： Microsoft Edge &lt;/span&gt;41.16299.248.0 ，Microsoft Edge 41.16299.248.0&lt;span&gt;
chrome： 版本 &lt;/span&gt;63.0.3239.132（正式版本） （32&lt;span&gt; 位）
phantomjs： &lt;/span&gt;2.1.1&lt;span&gt; 

另外，操作系统：Microsoft Windows [版本 &lt;/span&gt;10.0.16299.248]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、浏览器驱动：&lt;/p&gt;
&lt;p&gt;firefox驱动，https://github.com/mozilla/geckodriver/releases/，支持 Firefox 55及以上版本。&lt;/p&gt;
&lt;p&gt;edge驱动，https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/#downloads，最新版本 Release 16299，Version: 5.16299，支持 Edge version supported: 16.16299 。&lt;span&gt;注意edge驱动只有在edge浏览器未启动的情况下才能正常运行，否则会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;chrome驱动，https://sites.google.com/a/chromium.org/chromedriver/downloads，&lt;span&gt;这里需要注意的是：最新版本是2.35（不是2.9），2.35才支持chrome 61-63版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;phantomjs，http://phantomjs.org/download.html，phantomjs可以理解成没有界面的浏览器，所以驱动跟浏览器是一体的。&lt;/p&gt;
&lt;p&gt;驱动版本一定要选对，否则会有奇奇怪怪的问题。&lt;/p&gt;


&lt;p&gt;huaweiphoto_sele.py，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*-coding=utf-8-*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;Create by : Joshua zou &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;Create Date : 2018.2.28&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.desired_capabilities &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DesiredCapabilities
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.proxy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ProxyType
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json,re,os,time,requests,socket

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;下载函数&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt;  huaweiphoto_py3_new &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HuaWei


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; hwSele:
    SeleBrowser&lt;/span&gt;=&lt;span&gt;None
    TimeOUT&lt;/span&gt;=30&lt;span&gt;
    Headers&lt;/span&gt;=&lt;span&gt;None
    Username&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    Passwd&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    DriverType&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.lower()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,ip=None,port=None,SeleDriver=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,SeleHeader=&lt;span&gt;None):        
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxy %s %s...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(ip,port))
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; SeleHeader :
            self.Headers &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            self.Headers &lt;/span&gt;=&lt;span&gt; SeleHeader
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; SeleDriver: 
            self.DriverType&lt;/span&gt;=&lt;span&gt; SeleDriver.lower()
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加代理的目的是为了更便于抓报文。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; :
            chromeOptions &lt;/span&gt;=&lt;span&gt; webdriver.ChromeOptions()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ip:
                chromeOptions.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--proxy-server=http://%s:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(ip,port))  
                self.SeleBrowser &lt;/span&gt;= webdriver.Chrome(chrome_options=&lt;span&gt;chromeOptions)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                self.SeleBrowser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;DriverType='Edge'&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phantomjs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置userAgent&lt;/span&gt;
            dcap =&lt;span&gt; dict(DesiredCapabilities.PHANTOMJS)
            dcap[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phantomjs.page.settings.userAgent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; (self.Headers)    
            self.SeleBrowser &lt;/span&gt;= webdriver.PhantomJS(executable_path=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\python\toupiao\phantomjs\bin\phantomjs.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,desired_capabilities=&lt;span&gt;dcap)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ip:
                proxy&lt;/span&gt;=&lt;span&gt;webdriver.Proxy()
                proxy.proxy_type&lt;/span&gt;=&lt;span&gt;ProxyType.MANUAL
                proxy.http_proxy&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(ip,port)            
                proxy.add_to_capabilities(webdriver.DesiredCapabilities.PHANTOMJS)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                self.SeleBrowser.start_session(webdriver.DesiredCapabilities.PHANTOMJS)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;edge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            self.KillSeleProc() #edge，默认先kill掉已启动的浏览器。
            self.SeleBrowser &lt;/span&gt;=&lt;span&gt; webdriver.Edge()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firefox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            webdriver.DesiredCapabilities.FIREFOX[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firefox.page.settings.userAgent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.Headers
            profile &lt;/span&gt;=&lt;span&gt; webdriver.FirefoxProfile()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ip: 
                profile.set_preference(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.proxy.type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认值0，就是直接连接；1就是手工配置代理。  &lt;/span&gt;
                profile.set_preference(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.proxy.http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, ip)  
                profile.set_preference(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.proxy.http_port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, port)  
                profile.set_preference(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.proxy.ssl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, ip)  
                profile.set_preference(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.proxy.ssl_port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, port)
                profile.update_preferences()  
                self.SeleBrowser &lt;/span&gt;=&lt;span&gt; webdriver.Firefox(profile)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                self.SeleBrowser &lt;/span&gt;=&lt;span&gt; webdriver.Firefox()        
        socket.setdefaulttimeout(self.TimeOUT) 
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项  &lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。  &lt;/span&gt;
&lt;span&gt;        self.SeleBrowser.set_page_load_timeout(self.TimeOUT)  
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置10秒脚本超时时间&lt;/span&gt;
&lt;span&gt;        self.SeleBrowser.set_script_timeout(self.TimeOUT)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 隐式等待30秒，可以自己调节 &lt;/span&gt;
&lt;span&gt;        self.SeleBrowser.implicitly_wait(self.TimeOUT)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; KillSeleProc(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;edge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            command &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;taskkill /F /IM MicrosoftWebDriver.exe &amp;amp; taskkill /F /IM MicrosoftEdge.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;比如这里关闭edge进程&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chrome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            command &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;taskkill /F /IM chromedriver.exe &amp;amp; taskkill /F /IM chrome.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firefox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            command &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;taskkill /F /IM geckodriver.exe &amp;amp; taskkill /F /IM firefox.exe&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; self.DriverType==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phantomjs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            command &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;taskkill /F /IM phantomjs.exe &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; command: os.system(command)
        
            
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; QuitSele(self,e,mess=None,iRet= -1&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (mess,e)        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.SeleBrowser: 
            self.SeleBrowser.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            self.SeleBrowser.close()
        self.KillSeleProc()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; iRet
        
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; LoginHW(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        try:
            element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, &quot;loadedButton&quot;)))
        finally:
            print(driver.find_element_by_id(&quot;content&quot;).text)
            driver.close()
            
        #等待页面加载完毕1，显示等待
        try:            
            auth_img = WebDriverWait(self.SeleBrowser, 5).until(EC.presence_of_element_located((By.ID, &quot;randomCodeImg&quot;)))      
        except Exception as e: 
            print (u'加载验证码超时...',e)
            SeleBrowser.save_screenshot(r'd:\python\toupiao\error.jpg')
            self.SeleBrowser.close()
            return -1 
            
            
        #等待页面加载完毕2，隐式等待
        dr=WebDriverWait(self.SeleBrowser,20,0.5)
        dr.until(lambda the_driver:the_driver.find_element_by_xpath(&quot;//img[@id='randomCodeImg']&quot;).is_displayed())       
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.SeleBrowser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://cloud.huawei.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.QuitSele(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开主页出错！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载完毕&lt;/span&gt;
            dr=WebDriverWait(self.SeleBrowser,self.TimeOUT,0.5&lt;span&gt;)
            dr.until(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; the_driver:the_driver.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;randomCodeImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).is_displayed())        
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.QuitSele(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;加载验证码超时！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        elem_user &lt;/span&gt;= self.SeleBrowser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login_userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        elem_user.clear()
        elem_user.send_keys(self.Username)
        
        elem_pwd &lt;/span&gt;=  self.SeleBrowser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login_password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        elem_pwd.clear()
        elem_pwd.send_keys(self.Passwd)        

        auth_img &lt;/span&gt;= self.SeleBrowser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;randomCodeImg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; auth_img.is_displayed() :
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; auth_img.is_displayed():
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.QuitSele(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码未正常显示！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.DriverType==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;firefox&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;firefox驱动支持直接 元素另存图片&lt;/span&gt;
            auth_img.screenshot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            im &lt;/span&gt;= Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;chrome ,edge 都不支持,phantomjs存的还是整个窗口&lt;/span&gt;
            self.SeleBrowser.save_screenshot(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
            im &lt;/span&gt;= Image.open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;captcha.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            x&lt;/span&gt;= eval(auth_img.get_attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            y&lt;/span&gt;= eval(auth_img.get_attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            width&lt;/span&gt;= eval(auth_img.get_attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            height&lt;/span&gt;= eval(auth_img.get_attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            im &lt;/span&gt;= im.crop((x, y, x+width, y+&lt;span&gt;height))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里采用最原始、最准确的方法：显示图片，人工识别^_^，智能输入验证码。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当然也可以调用三方的图像识别api进行识别，譬如pytesseract或者鹅厂的图像识别api，不复杂，但懒得写了。&lt;/span&gt;
&lt;span&gt;        im.show()
        authCode&lt;/span&gt;= input(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入验证码:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先获取焦点，再赋值，再点击登录&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        js= '$(&quot;#randomCode&quot;).attr(&quot;value&quot;,&quot;%s&quot;);$(&quot;#randomCode&quot;).trigger(&quot;onchange&quot;);' %authCode
        self.SeleBrowser.execute_script(js)
        
        js= '$(&quot;#btnLogin&quot;).trigger(&quot;click&quot;);' 
        self.SeleBrowser.execute_script(js)  
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        randomCode &lt;/span&gt;= self.SeleBrowser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;randomCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        randomCode.clear()
        randomCode.send_keys(authCode)
        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;休息五秒，等待完成后台预验证交互&lt;/span&gt;
        time.sleep(5&lt;span&gt;)
        
        btnLogin &lt;/span&gt;= self.SeleBrowser.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnLogin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        btnLogin.click()
            
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;账号保护有时候会提示&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        &amp;lt;div class=&quot;global_dialog_confirm_main&quot; style=&quot;display: block; margin-top: -163.5px;&quot;&amp;gt;
        &amp;lt;div class=&quot;global_dialog_confirm_title&quot;&amp;gt; 
        &amp;lt;h3 class=&quot;ellipsis&quot; title=&quot;帐号保护&quot;&amp;gt;帐号保护&amp;lt;/h3&amp;gt;    &amp;lt;/div&amp;gt;    
        &amp;lt;div class=&quot;global_dialog_confirm_content&quot; style=&quot;padding-bottom: 0px;&quot;&amp;gt;&amp;lt;div&amp;gt;
        &amp;lt;div id=&quot;authenDialog&quot;&amp;gt;&amp;lt;p class=&quot;inptips2&quot;&amp;gt;您已开启帐号保护，请输入验证码以完成登录。&amp;lt;/p&amp;gt;
        &amp;lt;div class=&quot;margin10-EMUI5&quot;&amp;gt;&amp;lt;div id=&quot;accountDiv&quot; class=&quot;fixAccountDrt ddrop-EMU5&quot;&amp;gt;        
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; :
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;loginConfirm = self.SeleBrowser.find_element_by_class_name(&quot;global_dialog_confirm_main&quot;)&lt;/span&gt;
            loginConfirm =WebDriverWait(self.SeleBrowser, 5, 0.5).until(EC.presence_of_element_located((By.CLASS_NAME, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;global_dialog_confirm_main&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) ))                  
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要验证，这块懒得实现了，休眠60秒，手动操作吧。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; loginConfirm.is_displayed():
                time.sleep(self.TimeOUT&lt;/span&gt;*2&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;不需要验证，直接下一步&lt;/span&gt;
            &lt;span&gt;pass&lt;/span&gt;
                
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待页面加载完毕&lt;/span&gt;
        &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        &amp;lt;span class=&quot;index-span&quot; data-bind=&quot;lang.common.album&quot;&amp;gt;图库&amp;lt;/span&amp;gt;
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; :
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;loginConfirm = self.SeleBrowser.find_element_by_class_name(&quot;global_dialog_confirm_main&quot;)&lt;/span&gt;
            success =WebDriverWait(self.SeleBrowser, 20, 0.5).until(EC.presence_of_element_located((By.XPATH, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;//span[@data-bind=&quot;lang.common.album&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) ))                  
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;#登录失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; self.QuitSele(e,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,iRet=-999&lt;span&gt;)
        
        &lt;/span&gt;&lt;span&gt;#判断登录结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; success.is_displayed(): &lt;span&gt;return&lt;/span&gt; self.QuitSele(None,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,iRet=-999&lt;span&gt;)
     
        #再次判断，增加一次意外处理
        source_code &lt;/span&gt;=&lt;span&gt;self.SeleBrowser.page_source
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;联系人&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; source_code &lt;span&gt;or&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;图库&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source_code : 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.QuitSele(None,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,iRet = -9999&lt;span&gt; )

        cookie &lt;/span&gt;= [item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.SeleBrowser.get_cookies()]  
        cookiestr &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(item &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cookie)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存CSRFToken&lt;/span&gt;
        pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CSRFToken = &quot;(.*?)&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,re.S)        
        content &lt;/span&gt;=&lt;span&gt; re.search(pattern,source_code)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; content :
            CSRFToken &lt;/span&gt;= content.group(1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取CSRFToken出错！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.Headers&lt;/span&gt;=&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.Headers,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CSRFToken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;CSRFToken,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;cookiestr
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1 
            
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    photohw&lt;/span&gt;=&lt;span&gt; HuaWei()
    count &lt;/span&gt;=&lt;span&gt;0 
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count &amp;lt;100&lt;span&gt;):
        count &lt;/span&gt;+= 1&lt;span&gt;
        selehw&lt;/span&gt;= hwSele(SeleDriver=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;edge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        iRet &lt;/span&gt;=&lt;span&gt; selehw.LoginHW()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; iRet !=1&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;登录华为失败！！！\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;        
        photohw.loginHeaders &lt;/span&gt;=&lt;span&gt; selehw.Headers 
        page &lt;/span&gt;=&lt;span&gt; photohw.getAlbumList()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; page==&lt;span&gt;''&lt;/span&gt;&lt;span&gt; :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取到相册列表失败！！！\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存相册列表&lt;/span&gt;
        iRet = photohw.getFileList(page,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;albumList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;albumId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; iRet &amp;lt;=&lt;span&gt;0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;保存相册出错，重新登录&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存公共相册列表&lt;/span&gt;
        iRet = photohw.getFileList(page,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ownShareList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shareId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; iRet ==&lt;span&gt;0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;运行结束，可以用迅雷打开相册文件进行批量下载到本地！！！\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行结束&lt;/span&gt;
&lt;span&gt;            selehw.QuitSele(None)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;huwweiphoto_py3.py如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding=utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Create by : Joshua zou &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Create date : 2018.2.28&lt;/span&gt;
&lt;span&gt;__author__&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;joshua zou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.adapters &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPAdapter
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; html

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuaWei:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;华为云服务登录&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.getalbumsUrl&lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.hicloud.com/album/getCloudAlbums.action&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.getalbumfileUrl &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.hicloud.com/album/getCloudFiles.action&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.loginHeaders &lt;/span&gt;=&lt;span&gt; { }
        self.SReq&lt;/span&gt;=&lt;span&gt;requests.session()
        self.SReq.mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, HTTPAdapter(max_retries=3&lt;span&gt;))
        self.SReq.mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, HTTPAdapter(max_retries=3&lt;span&gt;))
        self.OnceMaxFile&lt;/span&gt;=100 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;单次最大获取文件数量&lt;/span&gt;
        self.FileNum=&lt;span&gt;0
        self.AlbumList&lt;/span&gt;=&lt;span&gt;{}
    

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存相册照片地址到文件 ,不同相册保存到不同的文件&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; saveFileList2Txt(self,filename,hjsondata,flag):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(hjsondata)&amp;lt;= 0 : &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;
        hjson2 &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            hjson2 &lt;/span&gt;=&lt;span&gt; json.loads(hjsondata)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取相册明细出错\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;
        
        lfilename &lt;/span&gt;= filename+u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; flag == 0 : &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新建文件&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;( u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建相册文件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+lfilename+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;新建文件，代表新的相册重新开始计数&lt;/span&gt;
            self.FileNum =&lt;span&gt; 0
            f &lt;/span&gt;= open(lfilename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;追加文件&lt;/span&gt;
            f = open(lfilename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        i &lt;/span&gt;=&lt;span&gt; 0             
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hjson2.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each &lt;span&gt;in&lt;/span&gt; hjson2[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
                fileurl&lt;/span&gt;= html.unescape(hjson2[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][i][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
                f.write(fileurl&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每一千行分页&lt;/span&gt;
                self.FileNum += 1
                &lt;span&gt;if&lt;/span&gt; self.FileNum%1000 ==0 :f.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n\n\n\n\n\n--------------------page %s ------------------\n\n\n\n\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(int(self.FileNum/1000&lt;span&gt;)))
                i &lt;/span&gt;+= 1&lt;span&gt;
        f.close()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环读取相册文件&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getFileList(self,hjsondata,parentkey,childkey):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;step 3 getCoverFiles.action,循环取相册文件列表，单次最多取100条记录。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次count都是最大数量49，不管实际数量是否够，每次currentnum递增，直到返回空列表。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;albumIds[]=default-album-2&amp;amp;ownerId=220086000029851117&amp;amp;height=300&amp;amp;width=300&amp;amp;count=49&amp;amp;currentNum=0&amp;amp;thumbType=imgcropa&amp;amp;fileType=0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;albumIds[]=default-album-1&amp;amp;ownerId=220086000029851117&amp;amp;height=300&amp;amp;width=300&amp;amp;count=49&amp;amp;currentNum=49&amp;amp;thumbType=imgcropa&amp;amp;fileType=0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;albumIds[]=default-album-1&amp;amp;ownerId=220086000029851117&amp;amp;height=300&amp;amp;width=300&amp;amp;count=49&amp;amp;currentNum=98&amp;amp;thumbType=imgcropa&amp;amp;fileType=0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;albumIds[]=default-album-2&amp;amp;ownerId=220086000029851117&amp;amp;height=300&amp;amp;width=300&amp;amp;count=49&amp;amp;currentNum=101&amp;amp;thumbType=imgcropa&amp;amp;fileType=0&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最后一次返回 空列表&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;{&quot;albumSortFlag&quot;:true,&quot;code&quot;:0,&quot;info&quot;:&quot;success!&quot;,&quot;fileList&quot;:[]}&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一次取文件时，例如文件总数量只有2个，count也是放最大值49。&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;albumIds[]=default-album-102-220086000029851117&amp;amp;ownerId=220086000029851117&amp;amp;height=300&amp;amp;width=300&amp;amp;count=49&amp;amp;currentNum=0&amp;amp;thumbType=imgcropa&amp;amp;fileType=0        &lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;[{u'photoNum': 2518, u'albumName': u'default-album-1', u'iversion': -1, u'albumId': u'default-album-1', u'flversion': -1, u'createTime': 1448065264550L, u'size': 0},&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;{u'photoNum': 100, u'albumName': u'default-album-2', u'iversion': -1, u'albumId': u'default-album-2', u'flversion': -1, u'createTime': 1453090781646L, u'size': 0}]        &lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            hjson &lt;/span&gt;=&lt;span&gt; json.loads(hjsondata)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;加载json出错!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字典获取出错&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; hjson.get(parentkey):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;加载json根节点[%s]出错!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;parentkey)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化全局 albumlist&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.AlbumList :
            self.AlbumList&lt;/span&gt;=&lt;span&gt;hjson
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; idx,album &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(self.AlbumList[parentkey]):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.AlbumList[parentkey][idx].keys():
                self.AlbumList[parentkey][idx][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;0
                
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环保存相册&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; each &lt;span&gt;in&lt;/span&gt;&lt;span&gt; hjson[parentkey]:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;该相册已经进入记录                &lt;/span&gt;
            paraAlbum=&lt;span&gt;{}
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;albumIds[]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; each[childkey]
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ownerId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = hjson[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ownerId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.OnceMaxFile
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thumbType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;imgcropa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;            
            itotal&lt;/span&gt;= each[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;photoNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取当前节点的当前记录&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; idx,album &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(self.AlbumList[parentkey]):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; each[childkey]==&lt;span&gt;album[childkey]:
                    icurrentnum &lt;/span&gt;= self.AlbumList[parentkey][idx][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存相册中所有文件&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; icurrentnum&amp;lt;&lt;span&gt;itotal:                
                paraAlbum[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; icurrentnum
                response&lt;/span&gt;=self.SReq.post(self.getalbumfileUrl,headers=self.loginHeaders,data=paraAlbum,verify=&lt;span&gt;False)
                page &lt;/span&gt;=&lt;span&gt; response.text
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存下载地址到文本文件中，但不下载文件&lt;/span&gt;
                iret  =&lt;span&gt; self.saveFileList2Txt(each[childkey],page,icurrentnum)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; iret &amp;gt;&lt;span&gt;0 :
                    self.AlbumList[parentkey][idx][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  +=&lt;span&gt; iret 
                    icurrentnum &lt;/span&gt;= self.AlbumList[parentkey][idx][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;currentNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;出错！！！&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; -1           
        &lt;span&gt;return&lt;/span&gt; 1

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;step 1 getCloudAlbums,取相册列表&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getAlbumList(self):
        response&lt;/span&gt;=self.SReq.post(self.getalbumsUrl,headers=self.loginHeaders,verify=&lt;span&gt;False)
        page&lt;/span&gt;=&lt;span&gt;response.text
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;#返回报文
        {&quot;ownerId&quot;:&quot;220086000029851117&quot;,&quot;code&quot;:0,
        &quot;albumList&quot;:[{&quot;albumId&quot;:&quot;default-album-1&quot;,&quot;albumName&quot;:&quot;default-album-1&quot;,&quot;createTime&quot;:1448065264550,&quot;photoNum&quot;:2521,&quot;flversion&quot;:-1,&quot;iversion&quot;:-1,&quot;size&quot;:0},
                     {&quot;albumId&quot;:&quot;default-album-2&quot;,&quot;albumName&quot;:&quot;default-album-2&quot;,&quot;createTime&quot;:1453090781646,&quot;photoNum&quot;:101,&quot;flversion&quot;:-1,&quot;iversion&quot;:-1,&quot;size&quot;:0}],
        &quot;ownShareList&quot;:[{&quot;ownerId&quot;:&quot;220086000029851117&quot;,&quot;resource&quot;:&quot;album&quot;,&quot;shareId&quot;:&quot;default-album-102-220086000029851117&quot;,&quot;shareName&quot;:&quot;微信&quot;,&quot;photoNum&quot;:2,&quot;flversion&quot;:-1,&quot;iversion&quot;:-1,&quot;createTime&quot;:1448070407055,&quot;source&quot;:&quot;HUAWEI MT7-TL00&quot;,&quot;size&quot;:0,&quot;ownerAcc&quot;:&quot;****&quot;,&quot;receiverList&quot;:[]}],
        &quot;recShareList&quot;:[]}'
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; len(page)&amp;lt;=&lt;span&gt;0 :
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;取相册列表出错，无返回报文!!!\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; page
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上，-- End -- &lt;/p&gt;
</description>
<pubDate>Tue, 27 Feb 2018 05:12:00 +0000</pubDate>
<dc:creator>黯然销魂掌2015</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhongtang/p/8478307.html</dc:identifier>
</item>
<item>
<title>教我徒弟Android开发入门（二） - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8475519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8475519.html</guid>
<description>&lt;h3&gt;前言：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上一期实现了简单的QQ登录效果，这一期继续对上一期进行扩展&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;本期的知识点：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Toast弹窗，三种方法实现按钮的点击事件监听&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;正文：&lt;/h3&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;Toast弹窗其实很简单，在Android Studio中打上toast，之后按下tab键就能快捷生成一个Toast&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;Toast.&lt;span&gt;makeText(&lt;span&gt;CurrentActivity.&lt;span&gt;this, &lt;span&gt;&quot;内容&quot;, &lt;span&gt;Toast.&lt;span&gt;LENGTH_SHORT).&lt;span&gt;show();&lt;br/&gt;&lt;span&gt;括号中的三个参数，第一个是context（上下文，在哪里显示Toast），第二个是一个String字符串，也就是Toast显示的内容，第三个是Toast显示的时间，short是短的意思&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;这样就能实现弹出Toast，我将之前弹出对话框的代码修改成了下列的代码，this就是指当前的activity，这样可以省略的写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201802/1210268-20180226200650306-1194951398.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201802/1210268-20180226200903430-1595543303.gif&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;796&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; 关于监听事件，可能我没有讲解得太清楚，拿上面的那个例子来说&lt;span&gt;，我们是让当前的那个activity实现了一个监听接口，之后复写它的onClick方法，通过findviewbyid找到button的实例，调用setOnClickListener为其绑定监听器&lt;/span&gt;，之后，当用户点击button按钮，就会进入到onClick方法之中，由v.getid获得当前用户点击的view的id，之后进入到一个switch分支语句之中，id与R.id.button相同，就执行该分支，也就是弹出一个Toast，&lt;span&gt;不只是button，其他的textview，linearlayout等等控件或者是根布局也是可以设置监听器的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201802/1210268-20180227115834736-178623938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201802/1210268-20180227115943531-1769756973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201802/1210268-20180227120006299-241970829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 我总结了五种实现时间监听器的方法，可能说法不是正确，不过，知道方法就行了，不必纠结细节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现事件监听器的方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内部类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;外部类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Activity本身作为事件监听器类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名内部类形式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直接绑定到标签&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;内部类形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将事件监听器类定义在当前类的内部&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        MyButtonlistener listener = &lt;span&gt;new&lt;span&gt; MyButtonlistener();
        button.setOnClickListener(listener);
    }
    &lt;span&gt;class MyButtonlistener &lt;span&gt;implements&lt;span&gt; View.OnClickListener{
        @Override
        &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
            &lt;span&gt;//&lt;span&gt;相关事件处理
&lt;span&gt;        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;






&lt;h2&gt;&lt;span&gt;外类类形式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Test类&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        MyButtonlistener listener = &lt;span&gt;new&lt;span&gt; MyButtonlistener();
        button.setOnClickListener(listener);
    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;MyButtonlistener类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class MyButtonlistener &lt;span&gt;implements&lt;span&gt; View.OnClickListener {
    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
        &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;Activity本身作为事件监听器类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　将Activity本身作为事件监听器类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends Activity &lt;span&gt;implements&lt;span&gt; View.OnClickListener{
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        button.setOnClickListener(&lt;span&gt;this&lt;span&gt;);

    }

    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
        &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;匿名内部类形式&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;class Test &lt;span&gt;extends&lt;span&gt; Activity {
    @Override
    &lt;span&gt;protected &lt;span&gt;void&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;span&gt;super&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button =&lt;span&gt; (Button)findViewById(R.id.about);
        button.setOnClickListener(&lt;span&gt;new&lt;span&gt; View.OnClickListener() {
            @Override
            &lt;span&gt;public &lt;span&gt;void&lt;span&gt; onClick(View v) {
                &lt;span&gt;//&lt;span&gt;事件处理
&lt;span&gt;            }
        });
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;直接绑定到标签&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在xml的布局文件中加入onClick属性，设置相关的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201709/1210268-20170930215059434-1405388576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个方法，&lt;span&gt;记得参数是View&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201709/1210268-20170930215011575-911361216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/kexing/p/7616285.html&quot;&gt;想深入了解的还可以看一下这一篇：Android开发之基于监听的事件处理&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Feb 2018 04:10:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8475519.html</dc:identifier>
</item>
</channel>
</rss>