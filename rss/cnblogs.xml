<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ParisGabriel：Python全栈工程师（0基础到精通）教程 第十五课（函数嵌套、变量作用域） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9307963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9307963.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;感谢 大家的支持  &lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;div align=&quot;left&quot; readability=&quot;7&quot;&gt;                                                        　&lt;img id=&quot;aimg_Gc8tb&quot; class=&quot;zoom&quot; src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180708123626547-869442520.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;136&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　&lt;span&gt;每天坚持 一天一篇 点个订阅吧  灰常感谢    当个死粉也阔以&lt;img src=&quot;https://static.52pojie.cn/static/image/smiley/default/mad.gif&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;img src=&quot;https://static.52pojie.cn/static/image/smiley/default/mad.gif&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;globals（）/locals（）函数&lt;/strong&gt;：&lt;br/&gt;　　　　&lt;strong&gt;globals&lt;/strong&gt;（）返回当前全局作用域内变量的字典&lt;br/&gt;　　　　&lt;strong&gt;locals&lt;/strong&gt;（） 返回当前局部作用域内变量的字典&lt;br/&gt;函数变量：&lt;br/&gt;　　函数名是变量，它在def 语句创建时绑定函数&lt;br/&gt;　　fa1 = fa 没有括号 绑定函数 fa1 = fa（） 返回结果&lt;br/&gt;　　　　函数的变量名可以序列交换算法&lt;br/&gt;&lt;strong&gt;一个函数可以作为另一个函数的实参传递：&lt;/strong&gt;&lt;br/&gt; 例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myinput(fn):
    L &lt;/span&gt;= [5, 3, 1, 9, 7&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fn(L)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myinput(max))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myinput(min))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(myinput(sum))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myinput(len))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;函数可以作为另一个函数的返回值：&lt;/strong&gt;&lt;br/&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_op():
　　s &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qing shu ru cao zuo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; s == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zui da&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max
　　&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; s == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zui xiao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min
　　&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; s == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;he&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum
L &lt;/span&gt;= [2, 3, 4, 6,5, 6, 9, 1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L)
f &lt;/span&gt;=&lt;span&gt; get_op()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f(L))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;函数的嵌套：&lt;/strong&gt;&lt;br/&gt;　　函数嵌套定义是指一个函数里用def语句来创建其他的函数&lt;/p&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fn_outter():
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fn_outter被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fn_inner():
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fn_inner被调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　fn_inner()
　　fn_inner()
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fn_outter调用结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

fn_outter()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Python的作用域：&lt;/strong&gt;&lt;br/&gt;　　　　作用域也叫名字空间，是访问变量时查找变量的范围空间&lt;br/&gt;　　python的4个作用域：&lt;br/&gt;　　作用域： 　　　　 　　 　　 　　　　　　 英文解释 　　　　　　 缩写&lt;br/&gt;　　局部作用域（函数内） 　　 　　　　　　 Local（function） 　　     L&lt;br/&gt;　　外部嵌套函数作用域 　　 　　　　　　　 Enclosing functio loc 　　 E&lt;br/&gt;　　函数定义所在模块（文件）作用域　　　　 Global（module）           G&lt;br/&gt;　　python内建模块作用域 　　　　　　　　   Builtin（python） 　　　  B &lt;br/&gt;包含关系（内建&amp;gt;模块&amp;gt;外部嵌套函数&amp;gt;函数内）&lt;br/&gt;&lt;strong&gt;变量名查找规则：&lt;/strong&gt;&lt;br/&gt;　　　　访问变量时，先查找本地变量，然后是包裹此函数外的函数内部的变量&lt;br/&gt;　　　　，之后是全局变量，最后是内建变量&lt;br/&gt;　　　　　　　　　　L ---&amp;gt; E ---&amp;gt; G ---&amp;gt; B&lt;br/&gt;　　　　在默认情况下，变量名赋值会创建或者改变当前作用域的变量&lt;br/&gt;global语句：&lt;br/&gt;　　告诉解释执行器global语句声明一个或多个变量，&lt;br/&gt;　　这些变量的作用域为模块级别的作用域，也称为全局变量&lt;br/&gt;&lt;strong&gt;全局声明&lt;/strong&gt;（&lt;strong&gt;global&lt;/strong&gt;）&lt;br/&gt;　　将赋值语句操作的变量映射到模块文件内部的作用域&lt;br/&gt;　　&lt;strong&gt;语法&lt;/strong&gt;：&lt;br/&gt;　　　　global 变量1， 变量2， ....&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1. 全局变量如果要在函数内部被赋值，则必须经过全局声明（否则会被认为是创建局部变量)&lt;br/&gt;　　　　2. 全局变量在函数内部不经过声明就可以直接访问(变量已经存在并关联一个对象)&lt;br/&gt;　　　　3. 不能先声明局部变量，再用global声明为全局变量，此做法不附合规则&lt;br/&gt;　　　　4. global变量列表里的变量名不能出现在此作用域的形参列表里&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nonlocal&lt;/strong&gt;语句：&lt;br/&gt;　　告诉解释执行器，nonlocal声明变量不是局部变量，也不是全局变量&lt;br/&gt;　　它是外部嵌套函数变量&lt;br/&gt;　　语法：&lt;br/&gt;　　　　nonlocal 变量名1，变量名2，...&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1. nonlocal 语句只能在被嵌套的函数内部进行使用&lt;br/&gt;　　　　2. 访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作&lt;br/&gt;　　　　3. 当有两层或两层以上函数嵌套时，访问nonlocal变量只对最近的一层变量进行操作&lt;br/&gt;　　　　4. nonlocal语句的变量列表里的变量名，不能出现在此函数的参数列表中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lambda表达式&lt;/strong&gt;（又称匿名函数）（希腊字母：入）&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　创建一个匿名函数对象&lt;br/&gt;　　　　同def类似 但是不提供函数名&lt;br/&gt;　　&lt;strong&gt;格式：&lt;/strong&gt;&lt;br/&gt;　　　　lambda[ 参数1， 参数...]： 表达式&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　1. lambda 只是一个表达式，它用来创建一个函数对象&lt;br/&gt;　　　　2. 当lambda表达式调用时，先执行冒号(:)后的表达式，并返回表达式的结果的引用关系&lt;br/&gt;　　　　3. lambda 表达式创建的函数只能包含一条表达式&lt;br/&gt;　　　　4. lambda 比函数简单且可以随时创建和销毁，有利于减少程序的偶合度&lt;/p&gt;&lt;p&gt;　&lt;strong&gt;　函数：&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　　　eval （） / exec（） 函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　eval(source, globals=None, local=None) 把一个字符串 srouce 当成一个表达式来执行，返回表达式执行的结果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　exec(source, globals=None, locals=None) 把一个字符串source 当成程序来执行&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;练习:&lt;br/&gt;写一个函数叫hello(name),部分代码如下:&lt;br/&gt;count = 0&lt;br/&gt;def hello(name):&lt;br/&gt;print('你好', name)&lt;br/&gt;... 此处代码省略,需要同学们自己填写&lt;br/&gt;... 此处代码需要改变全局变量来记录此函数曾经被调用过多少次.&lt;/p&gt;&lt;p&gt;hello('小张')&lt;br/&gt;hello('小李')&lt;br/&gt;print('hello 函数被调用', count, '次') # 2次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello(name):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; count
    count &lt;/span&gt;+= 1
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name)
hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoli&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoliu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaowei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaozhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713230358505-779671620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;1. 写一个lambda 表达式，判断这个数的2次方+1是否能被5整除，如果能被整除返回True, 否则返回False&lt;br/&gt;例:&lt;br/&gt;fa = lambda x: .....&lt;br/&gt;print(fa(2)) # True&lt;br/&gt;print(fa(4)) # False&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
fa = &lt;span&gt;lambda&lt;/span&gt; x: (x ** 2 + 1) % 5 ==&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(fa(2)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(fa(4)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713230736823-1264597355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 写一个lambda表达式，求两个变量的最大值&lt;br/&gt;例如:&lt;br/&gt;def mymax(x, y):&lt;br/&gt;...&lt;br/&gt;mymax = lambda ...&lt;br/&gt;print(mymax(100, 200)) # 200&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mymax(x, y):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;gt;&lt;span&gt; y:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(mymax(100, 200)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;
&lt;span&gt;
mymax &lt;/span&gt;= &lt;span&gt;lambda&lt;/span&gt; x, y: x &lt;span&gt;if&lt;/span&gt; x &amp;gt; y &lt;span&gt;else&lt;/span&gt;&lt;span&gt; y 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(mymax(100, 200)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713231005392-412005683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;1. 给出一个整数n,写一个函数myfac来计算n!(n的阶乘)&lt;br/&gt;n! = 1 * 2 * 3 * 4 * ..... * n&lt;br/&gt;如:&lt;br/&gt;print(myfac(5)) # 120&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myfac(n):
    x &lt;/span&gt;= 1
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, n + 1&lt;span&gt;):
        x &lt;/span&gt;= x *&lt;span&gt; i
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myfac(5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713231156137-1295343724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 给出一个整数n,写一个函数计算myfn(n):&lt;br/&gt;1 + 2**2 + 3**3 + .... + n**n的和&lt;br/&gt;如:&lt;br/&gt;print(myfn(10)) # ???&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myfu(n):
    s &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(2, n + 1&lt;span&gt;):
        s &lt;/span&gt;+= x **&lt;span&gt; x
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myfu(10))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713231234552-2026824512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 完全数:&lt;br/&gt;1 + 2 + 3 = 6 (6为完全数)&lt;br/&gt;1,2,3都为6的因数(因数是能被一个数x整除的整数为y,则y为x的因数)&lt;br/&gt;1 x 6 = 6&lt;br/&gt;2 x 3 = 6&lt;br/&gt;完全数是指除自身以外的所有因数相加之和等于自身的数&lt;br/&gt;求 4~5个完全数并打印出来&lt;br/&gt;答案:&lt;br/&gt;6&lt;br/&gt;28&lt;br/&gt;496&lt;br/&gt;......&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mywqs(x):
    s &lt;/span&gt;=&lt;span&gt; 0
    L &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, x):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x % i ==&lt;span&gt; 0:
            L.append(i)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L:
        s &lt;/span&gt;+=&lt;span&gt; i
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; s ==&lt;span&gt; x:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
i &lt;/span&gt;=&lt;span&gt; 0
wqs &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; wqs &amp;lt; 5&lt;span&gt;:
    i &lt;/span&gt;+= 1
    &lt;span&gt;if&lt;/span&gt; mywqs(i) ==&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
        wqs &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713231412576-1305010072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    咳咳 又到了吹NB环节&lt;/span&gt;&lt;br/&gt;&lt;span&gt;locals（）、globals（）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　就是一个查询函数 以字典形式返回信息而已&lt;/span&gt;&lt;br/&gt;&lt;span&gt;函数变量？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　你就就把它看做一个全局变量 变量绑定数据 而它绑定语句块 就这么简单&lt;/span&gt;&lt;br/&gt;&lt;span&gt;什么是作用域？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　作用域就是变量的所属范围 超过范围就失效&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　在别的地方一般是3个作用域 而python有4个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　内建变量 局部变量 模块全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　特殊那个就是两个函数嵌套之间的范围（外部嵌套）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　分别都是包含关系（内建&amp;gt;模块&amp;gt;外部嵌套函数&amp;gt;函数内）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　内建函数 不可删除或修改 其他作用域 不能与内建函数重名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　否则内建函数失效 只作用于当前空间自定义函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　各作用域各不相干 同空间不可重名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;global 　　 不管在任何空间使用global都直接声明全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;nonlocal 　 只能在被嵌套函数内部使用 多层嵌套 只会跳一层&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lambda 　  用表达式创建一个函数 和if一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180713234825746-1814133854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Jul 2018 15:40:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9307963.html</dc:identifier>
</item>
<item>
<title>case class 和class的区别以及构造器参数辨析 - PerKins.Zhu</title>
<link>http://www.cnblogs.com/PerkinsZhu/p/9307460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PerkinsZhu/p/9307460.html</guid>
<description>&lt;p&gt;工作中偶然发现Scala构造方法中的参数，无论是否有val/var修饰都可以顺利编译运行，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AA(name: String)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; BB(&lt;strong&gt;&lt;span&gt;val&lt;/span&gt;&lt;/strong&gt; name: String)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么两者的区别在哪里呢？对于case class呢？其区别又在哪里？其应用场景又在哪里呢？下面就辨析一下如下几个类的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AA(name: String)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BB(val name: String)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CC(var name: String)&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; DD(&lt;span&gt;private&lt;/span&gt;&lt;span&gt; val name: String)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; EE(&lt;span&gt;private&lt;/span&gt;[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;] val name: String)&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FF(name: String)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GG(val name: String)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HH(var name: String)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; II(&lt;span&gt;private&lt;/span&gt;&lt;span&gt; val name: String)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JJ(&lt;span&gt;private&lt;/span&gt;[&lt;span&gt;this&lt;/span&gt;] val name: String)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 单纯的从代码中来看，发现不了什么区别，只是简单的多了一个val的修饰符。为了一探究竟，先对源码进行编译，然后通过javap对其class文件进行反编译，查看其与源码的区别。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、普通类构造器中val/var 存在和不存在的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AA(name: String)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BB(&lt;span&gt;val&lt;/span&gt; name: String)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; CC(&lt;span&gt;var&lt;/span&gt; name: String)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 反编译结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Compiled from &quot;Test.scala&quot;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AA {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AA(java.lang.String);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; Compiled from &quot;Test.scala&quot;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BB {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;em&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;&lt;span&gt;final&lt;/span&gt;&lt;/span&gt;&lt;span&gt; java.lang.String name;
&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;em&gt;&lt;strong&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String name();
&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BB(java.lang.String);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; Compiled from &quot;Test.scala&quot;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CC {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  &lt;em&gt;&lt;strong&gt;&lt;span&gt; private&lt;/span&gt;&lt;span&gt; java.lang.String name;
&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;16&lt;/span&gt;   &lt;em&gt;&lt;strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String name();
&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;17&lt;/span&gt;  &lt;em&gt;&lt;strong&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; name_$eq(java.lang.String);
&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CC(java.lang.String);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：构造器中val修饰的参数，编译之后会在该类中添加一个&lt;span&gt;private final&lt;/span&gt;的&lt;span&gt;全局&lt;/span&gt;&lt;strong&gt;常量&lt;/strong&gt;，同时提供一个用于获取该常量的public方法，无设置方法。&lt;/p&gt;
&lt;p&gt;　　　构造器中var修饰的参数，编译之后会在该类中添加一个&lt;span&gt;private&lt;/span&gt;的&lt;span&gt;全局&lt;/span&gt;&lt;span&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/span&gt;，同时提供两个&lt;strong&gt;&lt;span&gt;获取和设置&lt;/span&gt;&lt;/strong&gt;该变量值的public方法。&lt;/p&gt;
&lt;p&gt; 　　　构造器中无修饰符的参数，则该参数属于构造函数内的&lt;span&gt;局部参数&lt;/span&gt;，仅仅在该&lt;span&gt;构造函数内部访问&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、普通类构造器中private和private[this] 修饰参数的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; DD(&lt;span&gt;private&lt;/span&gt;&lt;span&gt; val name: String)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt; EE(&lt;span&gt;private&lt;/span&gt;[&lt;span&gt;this&lt;/span&gt;] val name: String)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 反编译结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Compiled from &quot;Test.scala&quot;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DD {
  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; java.lang.String name;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.String name();
  &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DD(java.lang.String);
}

Compiled from &lt;/span&gt;&quot;Test.scala&quot;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EE {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EE(java.lang.String);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：private 修饰的构造器参数，编译之后会在该类中添加一个private final的&lt;span&gt;全局&lt;/span&gt;常量，同时提供一个&lt;span&gt;private&lt;/span&gt;的访问该参数的方法。即该参数&lt;span&gt;可在该类范围内访问&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　private[this]修饰的构造器参数，&lt;span&gt;不存在全局变量&lt;/span&gt;，只能在该构造方法中访问，在该类中无法访问。&lt;span&gt;同 &lt;/span&gt;class AA(name: String)&lt;/p&gt;
&lt;p&gt;注意：Scala整个类体就是其构造函数，所以，站在Scala角度看，private[this]修饰的构造器参数能够在整个类中访问，而站在Java角度看，该参数仅仅能够在构造函数中访问，在类中无法访问。而站在Scala角度看，private[this]和 private的主要区别在于，&lt;span&gt;private[this]修饰的参数无法通过e.name的方式访问，即使在该类的内部&lt;/span&gt;。注意下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/837242/201807/837242-20180713222548692-203706246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中，在EE#show中是无法访问that.name的，即使that的类型本身就是EE也不行的。这才是private[this]和private在Scala中的主要区别。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 三、普通class和case class的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FF(name: String)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 编译之后会发现在文件夹下面多出两个class文件，一个为FF.class，另一个为FF$.class文件。对两个文件进行反编译&lt;/p&gt;
&lt;p&gt;反编译结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Compiled from &quot;Test.scala&quot;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;strong&gt;&lt;span&gt;FF&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; scala.&lt;span&gt;Product&lt;/span&gt;,scala.&lt;span&gt;Serializable&lt;/span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;private final 修饰的name常量&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;    &lt;strong&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; java.lang.String name;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public修饰获取name的方法,可用于外部访问&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;    &lt;strong&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String name();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public修饰的构造函数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FF(java.lang.String);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; scala.Option&amp;lt;java.lang.String&amp;gt;&lt;span&gt; unapply(FF);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; FF apply(java.lang.String);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;A&amp;gt; scala.Function1&amp;lt;java.lang.String, A&amp;gt; andThen(scala.Function1&amp;lt;FF, A&amp;gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;A&amp;gt; scala.Function1&amp;lt;A, FF&amp;gt; compose(scala.Function1&amp;lt;A, java.lang.String&amp;gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FF copy(java.lang.String);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; java.lang.String copy$&lt;span&gt;default&lt;/span&gt;$1&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String productPrefix();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; productArity();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; java.lang.Object productElement(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; scala.collection.Iterator&amp;lt;java.lang.Object&amp;gt;&lt;span&gt; productIterator();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; canEqual(java.lang.Object);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.String toString();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(java.lang.Object);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; Compiled from &quot;Test.scala&quot;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;strong&gt;&lt;span&gt;FF$&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;extends&lt;/span&gt; scala.runtime.&lt;span&gt;AbstractFunction1&lt;/span&gt;&amp;lt;java.lang.String, FF&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; scala.&lt;span&gt;Serializable&lt;/span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态的FF$对象&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;strong&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; FF$ MODULE$;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数为private&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;    &lt;strong&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; FF$();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回FF对象的 apply方法&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FF apply(java.lang.String);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; java.lang.String toString();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; scala.Option&amp;lt;java.lang.String&amp;gt;&lt;span&gt; unapply(FF);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; java.lang.Object readResolve();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; java.lang.Object apply(java.lang.Object);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  分析：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;先看FF.class&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　1、对比class AA(name: String)的结果来看，case class 自动实现了scala.&lt;strong&gt;Product&lt;/strong&gt;,scala.&lt;strong&gt;Serializable&lt;/strong&gt;两个特质(接口)，因此，case class类中自然也会实现这两个特质中的抽象方法/&lt;span&gt;覆写&lt;/span&gt;一些方法（11~22行）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AA
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FF &lt;span&gt;implements&lt;/span&gt; scala.&lt;strong&gt;Product&lt;/strong&gt;,scala.&lt;strong&gt;Serializable &lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　2、对比 public class BB，在类内部都具有一个全局常量name和一个获取该常量的public方法，同时&lt;span&gt;两者都具&lt;/span&gt;有一个public的构造函数。&lt;/p&gt;
&lt;p&gt;　　　3、实现了一些特质中的一些方法，覆写了Java Object中的一些方法。例如:andThen() toString() hashCode()等&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;再看FF$&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、有一个&lt;strong&gt;&lt;span&gt;public &lt;/span&gt;&lt;/strong&gt; &lt;em&gt;&lt;strong&gt;static&lt;/strong&gt;&lt;/em&gt;修饰名为&lt;span&gt; &lt;/span&gt;MODULE$ 的 &lt;strong&gt;&lt;span&gt;FF$对象&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　　　2、构造器被私有化，用private修饰。&lt;/p&gt;
&lt;p&gt;　　　　3、组合1、 2、两点可知，FF$是一个&lt;strong&gt;&lt;span&gt;单例类&lt;/span&gt;&lt;/strong&gt;。其矢志不渝就是Scala中&lt;strong&gt;&lt;span&gt;FF类的伴生对象&lt;/span&gt;&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　Scala编译器在对case class进行编译的时候做了特殊处理，&lt;span&gt;扩展了其方法和功能&lt;/span&gt;，加入了scala.&lt;strong&gt;Product&lt;/strong&gt;,scala.&lt;strong&gt;Serializable&lt;/strong&gt;的特性，同时为其&lt;strong&gt;&lt;span&gt;提供了该类的伴生对象&lt;/span&gt;&lt;/strong&gt;。另外，对于case class 构造器参数，其默认&lt;span&gt;以public修饰&lt;/span&gt;，可&lt;span&gt;允许外部调用&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 四、其他&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 上面几个对比理解了，下面这几个类之间的区别也就可以举一反三了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GG(val name: String)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HH(var name: String)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; II(&lt;span&gt;private&lt;/span&gt;&lt;span&gt; val name: String)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JJ(&lt;span&gt;private&lt;/span&gt;[&lt;span&gt;this&lt;/span&gt;] val name: String)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;=========================================&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;https://www.cnblogs.com/PerkinsZhu/p/9307460.html&quot;&gt;case class 和class的区别以及构造器参数辨析&lt;/a&gt; &lt;span&gt;&lt;strong&gt;转载请注明出处！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;=========================================&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-----end&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 15:34:00 +0000</pubDate>
<dc:creator>PerKins.Zhu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PerkinsZhu/p/9307460.html</dc:identifier>
</item>
<item>
<title>浅析基础数据结构-二叉堆 - henry_y</title>
<link>http://www.cnblogs.com/henry-1202/p/9307927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henry-1202/p/9307927.html</guid>
<description>&lt;p&gt;如题，二叉堆是一种基础数据结构&lt;/p&gt;
&lt;p&gt;事实上支持的操作也是挺有限的（相对于其他数据结构而言），也就插入，查询，删除这一类&lt;/p&gt;
&lt;p&gt;对了这篇文章中讲到的堆都是二叉堆，而不是斜堆，左偏树，斐波那契堆什么的 &lt;span&gt;我都不会啊&lt;/span&gt;&lt;strong&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.堆是一颗完全二叉树&lt;/p&gt;
&lt;p&gt;2.堆的顶端一定是“最大”，最小”的，但是要注意一个点，这里的大和小并不是传统意义下的大和小，它是相对于优先级而言的，当然你也可以把优先级定为传统意义下的大小，但一定要牢记这一点，初学者容易把堆的“大小”直接定义为传统意义下的大小，某些题就不是按数字的大小为优先级来进行堆的操作的&lt;/p&gt;
&lt;p&gt;（但是为了讲解方便，下文直接把堆的优先级定为传统意义下的大小，&lt;span&gt;所以上面跟没讲有什么区别？&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;3.堆一般有两种样子，小根堆和大根堆，分别对应第二个性质中的“堆顶最大”“堆顶最小”，对于大根堆而言，任何一个非根节点，它的优先级都小于堆顶，对于小根堆而言，任何一个非根节点，它的优先级都大于堆顶（这里的根就是堆顶啦qwq）&lt;/p&gt;
&lt;p&gt;来一张图了解一下堆（这里是小根堆）（原谅我丑陋无比的图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bcc426d83.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不难看出，对于堆的每个子树，它同样也是一个堆（因为是完全二叉树嘛）&lt;/p&gt;

&lt;h2&gt;1.插入&lt;/h2&gt;
&lt;p&gt;假设你已经有一个堆了，就是上面那个&lt;/p&gt;
&lt;p&gt;这个时候你如果想要给它加入一个节点怎么办，比如说0？&lt;/p&gt;
&lt;p&gt;先插到堆底（严格意义上来说其实0是在5的左儿子的，图没画好放不下去，不过也不影响）&lt;/p&gt;
&lt;p&gt;然后你会发现它比它的父亲小啊，那怎么办？不符合小根堆的性质了啊，那就交换一下他们的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd1106211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;交换之后还是发现不符合小根堆的性质，那么再换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd7c385b4.png&quot; alt=&quot;上浮2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是不行，再换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd5579ff1.png&quot; alt=&quot;上浮3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，这下就符合小根堆的性质了，是不是顺眼很多了？&lt;span&gt;（假的，图越来越丑，原谅我不想再画）&lt;/span&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bdc07f3bc.png&quot; alt=&quot;上浮4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上堆的插入就是把新的元素放到堆底，然后检查它是否符合堆的性质，如果符合就丢在那里了，如果不符合，那就和它的父亲交换一下，一直交换交换交换，直到符合堆的性质，那么就插入完成了&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; &amp;amp;x,&lt;span&gt;int&lt;/span&gt; &amp;amp;y){&lt;span&gt;int&lt;/span&gt; t=x;x=y;y=t;}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换函数 &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; heap[N];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个数组来存堆&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; siz;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆的大小 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; push(&lt;span&gt;int&lt;/span&gt; x){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要插入的数 &lt;/span&gt;
    heap[++siz]=&lt;span&gt;x;
    now&lt;/span&gt;=&lt;span&gt;siz;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入到堆底 &lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(now){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还没到根节点，还能交换 &lt;/span&gt;
        ll nxt=now&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到它的父亲 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(heap[nxt]&amp;gt;heap[now])swap(heap[nxt],heap[now]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父亲比它大，那就交换 &lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果比它父亲小，那就代表着插入完成了 &lt;/span&gt;
        now=nxt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换 &lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.删除&lt;/h2&gt;
&lt;p&gt;把0插入完以后，忽然你看这个0不爽了，本来都是正整数，怎么就混进来你这个0？&lt;/p&gt;
&lt;p&gt;于是这时候你就想把它删除掉&lt;/p&gt;
&lt;p&gt;怎么删除？在删除的过程中还是要维护小根堆的性质&lt;/p&gt;
&lt;p&gt;如果你直接删掉了，那就没有堆顶了，这个堆就直接乱了，所以我们要保证删除后这一整个堆还是个完好的小根堆&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bdc07f3bc.png&quot; alt=&quot;上浮4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先在它的两个儿子里面，找一个比较小的，和它交换一下，但是还是没法删除，因为下方还有节点，那就继续交换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd5579ff1.png&quot; alt=&quot;上浮3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是不行，再换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd7c385b4.png&quot; alt=&quot;上浮2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bd1106211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，这个碍眼的东西终于的下面终于没有节点了，这时候直接把它扔掉就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/07/13/5b48bcc426d83.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就完成了删除操作，但是在实际的代码操作中，并不是这样进行删除操作的，有一定的微调，代码中是直接把堆顶和堆底交换一下，然后把交换后的堆顶不断与它的子节点交换，直到这个堆重新符合堆性质&lt;span&gt;（但是上面的方式好理解啊）&lt;/span&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;手写堆的删除支持任意一个节点的删除，不过STL只支持堆顶删除，STL的我们后面再讲&lt;/p&gt;
&lt;p&gt;Code：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; pop(){
    swap(heap[siz],heap[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]);siz--;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换堆顶和堆底，然后直接弹掉堆底 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; now=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((now&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;=siz){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对该节点进行向下交换的操作 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; nxt=now&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出当前节点的左儿子 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(nxt+&lt;span&gt;1&lt;/span&gt;&amp;lt;=siz&amp;amp;&amp;amp;heap[nxt+&lt;span&gt;1&lt;/span&gt;]&amp;lt;heap[nxt])nxt++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看看是要左儿子还是右儿子跟它换 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(heap[nxt]&amp;lt;heap[now])swap(heap[now],heap[nxt]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不符合堆性质就换 &lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则就完成了 &lt;/span&gt;
        now=nxt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往下一层继续向下交换 &lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.查询&lt;/h2&gt;
&lt;p&gt;因为我们一直维护着这个堆使它满足堆性质，而堆最简单的查询就是查询优先级最低/最高的元素，对于我们维护的这个堆heap，它的优先级最低/最高的元素就是堆顶，所以查询之后输出heap[1]就好了&lt;/p&gt;
&lt;p&gt;一般的题目里面查询操作是和删除操作捆绑的，查询完后顺便就删掉了，这个主要因题而异&lt;/p&gt;

&lt;p&gt;这年头真的没几个人写手写堆&lt;span&gt;（可能有情怀党？）&lt;/span&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;一是手写堆容易写错代码又多，二是STL 直接给我们提供了一个实现堆的简单方式：优先队列&lt;/p&gt;
&lt;p&gt;手写堆和STL的优先队列有什么 区别？&lt;span&gt;没有区别&lt;/span&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;速度方面，手写堆会偏快一点，但是如果开了O2优化优先队列可能会更快；&lt;/p&gt;
&lt;p&gt;代码实现难度方面：优先队列完爆手写堆&lt;/p&gt;
&lt;p&gt;这两方面综合起来，一般都是用STL的优先队列来实现堆，&lt;span&gt;省选开O2啊&lt;/span&gt;&lt;del&gt;&lt;br/&gt;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;至于为什么前面讲堆的操作时用手写堆，好理解嘛，最好先根据上面的代码和图理解一下堆是怎么实现那些操作的，再来看一下下面的STL的操作&lt;/p&gt;
&lt;p&gt;定义一个优先队列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
首先你需要一个头文件：#include&amp;lt;queue&amp;gt;&lt;span&gt;
priority_queue&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; q;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个大根堆q&lt;/span&gt;
priority_queue&amp;lt;&lt;span&gt;int&lt;/span&gt;,vector&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;,greater&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; &amp;gt;q;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是一个小根堆q
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意某些编译器在定义一个小根堆的时候greater&amp;lt;int&amp;gt;和后面的&amp;gt;要隔一个空格，不然会被编译器识别成位运算符号&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优先队列的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
q.top()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得堆顶元素，并不会弹出&lt;/span&gt;
q.pop()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出堆顶元素&lt;/span&gt;
q.push()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往堆里面插入一个元素&lt;/span&gt;
q.empty()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询堆是否为空，为空则返回1否则返回0&lt;/span&gt;
q.size()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询堆内元素数量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用也就这些，貌似还有其他，不过基本也用不到，知道上面那几个也就可以了&lt;/p&gt;
&lt;p&gt;不过有个小问题就是STL只支持删除堆顶，而不支持删除其他元素&lt;/p&gt;
&lt;p&gt;但是问题不大，开一个数组del，在要删除其他元素的时候直接就标记一下del[i]=1，这里的下标是元素的值，然后在查询的时候碰到这个元素被标记了直接弹出然后继续查询就可以了 （前两天刚从学长处get这个姿势）&lt;/p&gt;
&lt;p&gt;另外因为STL好写，下面堆的应用全部都会采用STL的代码实现&lt;span&gt;（懒啊，如果有放代码的话）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;因为堆是一棵完全二叉树，所以对于一个节点数为n的堆，它的高度不会超过log2n&lt;/p&gt;
&lt;p&gt;所以对于插入，删除操作复杂度为O(log2n)&lt;/p&gt;
&lt;p&gt;查询堆顶操作的复杂度为O(1)&lt;/p&gt;

&lt;h2&gt;1.堆排序&lt;/h2&gt;
&lt;p&gt;其实就是用要排序的元素建一个堆（视情况而定是大根堆还是小根堆），然后依次弹出堆顶元素，最后得到的就是排序后的结果了&lt;/p&gt;
&lt;p&gt;但是裸的并没有什么用，我们有sort而且sort还比堆排快，所以堆排一般都没有这种模板题，一般是利用堆排的思想，然后来搞一些奇奇怪怪的操作，第2个应用就有涉及到一点堆排的思想&lt;/p&gt;
&lt;h2&gt;2.用两个堆来维护一些查询第k小/大的操作&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1801&quot;&gt;洛谷P1801 黑匣子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用一个大根堆一个小根堆来维护第k小，并没有强制在线&lt;/p&gt;
&lt;p&gt;不强制在线，所以我们直接读入所有元素，枚举询问，因为要询问第k小，所以把前面的第k个元素都放进大根堆里面，然后如果元素数量大于k，就把堆顶弹掉放到小根堆里面，使大根堆的元素严格等于k，这样这次询问的结果就是小根堆的堆顶了（前面k-1小的元素都在大根堆里面了）&lt;/p&gt;
&lt;p&gt;记得在完成这次询问后重新把小根堆的堆顶放到大根堆里面就好&lt;/p&gt;
&lt;p&gt;为了不占太多篇幅就不粘Code了&lt;/p&gt;
&lt;p&gt;其他应用之后再补&lt;/p&gt;

</description>
<pubDate>Fri, 13 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>henry_y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henry-1202/p/9307927.html</dc:identifier>
</item>
<item>
<title>haproxy+keepalived主备与双主模式配置 - 孤岛鱼夫</title>
<link>http://www.cnblogs.com/anay/p/9307908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anay/p/9307908.html</guid>
<description>&lt;h3 id=&quot;haproxykeepalived主备模式&quot;&gt;Haproxy+Keepalived主备模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://gudaoyufu.com/wp-content/uploads/2018/07/haproxykeepalived%E4%B8%BB%E5%A4%87.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;主备节点设置&quot;&gt;主备节点设置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;主备节点上各安装配置haproxy，配置内容且要相同&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;global

log         127.0.0.1 local2

    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon

    defaults      #defaults段默认值对frontend和backend和listen段生效
    mode                    http          #运行模式为http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8  #添加客户端真实ip地址
    option                  redispatch  # #如果后端有服务器宕机，强制切换到正常服务器
    retries                 3   #三次连接失败，则判断服务不可用
    timeout http-request    10s     #请求超时时间
    timeout connect         10s  #连接超时
    timeout client          1m      #客户端超时
    timeout server          1m    #服务端超时
    timeout http-keep-alive 10s  #长连接超时时间
    timeout check           10s   检查超时时间
    maxconn                 3000  每个进程最大连接数

    frontend web :80      #自定义一个web静态页面匹配前端
    acl url_html path_beg -i /
    acl url_html path_end -i .html

    use_backend website if url_html   #如果符合匹配就使用website的后端主机
    
    frontend imgs :80       #自定义一个图片匹配前端
    acl url_img path_beg -i /
    acl url_img path_end -i .jpg .png .jpeg .gif

    use_backend img if url_img   #如果符合匹配就使用img后端主机

    backend img    #定义后端主机组 img
    server img1 192.168.214.135:80 check

    backend website   #定义后端主机组website
    server      html1 192.168.214.133:80 check
    server      html2 192.168.214.135:80 check&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;haproxy开启日志记录&quot;&gt;haproxy开启日志记录&lt;/h4&gt;
&lt;p&gt;日志定义在haproxy的配置文件中已经说明了，haproxy使用rsyslog服务记录日志，需要在rsyslog日志服务中定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vim /etc/rsyslog.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;$ModLoad imudp                       #取消注释 ，使用udp传输日志
$UDPServerRun 514                    #取消注释 ，使用udp传输日志
local2.*                            /var/log/haproxy.log #按照配置文件里提示写即可
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：上面必须要选择使用tcp或udp方式传输日志，如果不选择光定义日志路径是不生效的&lt;/p&gt;
&lt;h4 id=&quot;定义master节点的keepalived配置&quot;&gt;定义master节点的keepalived配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.214.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
   vrrp_iptables #禁止keepalived启动生成默认的iptables规则
   vrrp_mcast_group4 224.17.17.17  #定义主备节点通过组播地址进行通告状态
}

vrrp_script chk_down {  
        script &quot;/bin/bash  -c '[[ -f /etc/keepalived/down ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;  
        interval 1 
        weight -10  
}

vrrp_script chk_haproxy {  #调用外部的辅助脚本进行资源监控,并根据监控的结果状态能实现优先动态调整
        script &quot;/usr/bin/killall -0 haproxy &amp;amp;&amp;amp; exit 0 || exit 1&quot;
        #script指令：先定义一个执行脚本，如果脚本执行结果状态为0则不操作后续步奏，如果状态为非0，则执行相应的操作
        interval 1     #每秒检查执行一次
        weight -10    #如果脚本执行结果为非0 ，则keepalived的优先级减去10
        fall 2    #如果连续两次检测为错误状态则认为服务部可用
        rise 1    #检测一次成功就认为服务正常
    }

vrrp_instance VI_1 {   #配置虚拟路由实例
    state MASTER      #定义该节点为MASTER节点
    interface ens33   #定义VIP绑定的物理网卡
    virtual_router_id 55   #设置虚路由拟路由id，同一集群的节点群必须相同
    priority 100           #设定优先级
    advert_int 1        #设定master与backup之间vrrp通告的时间间隔，单位是秒
#    nopreempt   #设定keepalived的切换模式，默认是抢占failover，这里是非抢占，没有启用
    authentication {  #定义验证方式与密码
        auth_type PASS
        auth_pass 12345678  #密码最长8位
    }
    virtual_ipaddress {    #定义虚拟路由IP,也是对外接收请求的ip
        192.168.214.100
    }

track_script {  #用于追踪脚本执行状态，定义在vrrp_instance段中
        chk_down
        chk_haproxy

   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义backup节点keepalived配置&quot;&gt;定义BACKUP节点Keepalived配置&lt;/h4&gt;
&lt;p&gt;BACKUP节点与MASTER节点定义大致相同，只有BACKUP节点的角色，优先级需要修改，其他都不需要改动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.214.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
   vrrp_iptables
   vrrp_mcast_group4 224.17.17.17
}



vrrp_script chk_down {
        script &quot;/bin/bash -c '[[ -f /etc/keepalived/down ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}

vrrp_script chk_haproxy {
        script &quot;/usr/bin/killall -0 haproxy &amp;amp;&amp;amp; exit 0 || exit 1&quot;
        interval 1
        weight -10
        fall 2
        rise 1
    }


vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 55
    priority 95
    advert_int 1
#    nopreempt
    authentication {
        auth_type PASS
        auth_pass 12345678
    }
    virtual_ipaddress {
        192.168.214.100
    }

track_script {
        chk_down
        chk_haproxy

   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;双主模式配置&quot;&gt;双主模式配置&lt;/h3&gt;
&lt;p&gt;在上面配置的基础上，只要在各节点新建一个&lt;strong&gt;vrrp_instance VI_2&lt;/strong&gt; 实例即可，在原来的MASTER节点定义第二个实例的为BACKUP角色，在原来的BACKUP节点再添加一个新的实例为MASTER，设置另一个虚拟路由实例的VIP为：192.168.214.200&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://gudaoyufu.com/wp-content/uploads/2018/07/%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vrrp_instance-vi_2配置&quot;&gt;vrrp_instance VI_2配置&lt;/h3&gt;
&lt;p&gt;最终在上面原来的MASTER节点配置如下（添加了最后一段vrrp_instance VI_2的定义）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node-1 ~]# vim /etc/keepalived/keepalived.conf

! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.214.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
   vrrp_iptables
   vrrp_mcast_group4 224.17.17.17
}


vrrp_script chk_down {  #定义vrrp_instance VI_1实例的检测文件
        script &quot;/bin/bash  -c '[[ -f /etc/keepalived/down ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}



vrrp_script chk_node2 { #定义vrrp_instance VI_2实例的检测文件
        script &quot;/bin/bash  -c '[[ -f /etc/keepalived/nodedown ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}


vrrp_script chk_haproxy {
        script &quot;/usr/bin/killall -0 haproxy &amp;amp;&amp;amp; exit 0 || exit 1&quot;
        interval 1
        weight -10
        fall 2
        rise 1
    }


#高可用组1

vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 55
    priority 100
    advert_int 1
#    nopreempt
    authentication {
        auth_type PASS
        auth_pass 12345678
    }
    virtual_ipaddress {
        192.168.214.100
    }

track_script {
        chk_down
        chk_haproxy

   }
}




#高可用组2

vrrp_instance VI_2 {
    state BACKUP
    interface ens33
    virtual_router_id 33
    priority 95
    advert_int 1
#    nopreempt
    authentication {
        auth_type PASS
        auth_pass 87654321
    }
    virtual_ipaddress {
        192.168.214.200
    }

track_script {
        chk_node2
        chk_haproxy

   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终在上面原来的BACKUP节点配置如下（添加了最后一段vrrp_instance VI_2的定义）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node-2 ~]# vim /etc/keepalived/keepalived.conf

! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.214.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
   vrrp_iptables
   vrrp_mcast_group4 224.17.17.17
}



vrrp_script chk_down {
        script &quot;/bin/bash -c '[[ -f /etc/keepalived/down ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}

vrrp_script chk_node2 {
        script &quot;/bin/bash  -c '[[ -f /etc/keepalived/nodedown ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}



vrrp_script chk_haproxy {
        script &quot;/usr/bin/killall -0 haproxy &amp;amp;&amp;amp; exit 0 || exit 1&quot;
        interval 1
        weight -10
        fall 2
        rise 1
    }


vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 55
    priority 95
    advert_int 1
#    nopreempt
    authentication {
        auth_type PASS
        auth_pass 12345678
    }
    virtual_ipaddress {
        192.168.214.100
    }

track_script {
        chk_down
        chk_haproxy

   }
}


vrrp_instance VI_2 {
    state MASTER
    interface ens33
    virtual_router_id 33
    priority 100
    advert_int 1
#    nopreempt
    authentication {
        auth_type PASS
        auth_pass 87654321
    }
    virtual_ipaddress {
        192.168.214.200
    }

track_script {
        chk_node2
        chk_haproxy

   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;双主节点配置时要注意的地方&quot;&gt;双主节点配置时要注意的地方&lt;/h4&gt;
&lt;p&gt;配置配置文件中有如下两段检测内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vrrp_script chk_down {
        script &quot;/bin/bash -c '[[ -f /etc/keepalived/down ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}

vrrp_script chk_node2 {
        script &quot;/bin/bash  -c '[[ -f /etc/keepalived/nodedown ]]' &amp;amp;&amp;amp; exit 1 || exit 0&quot;
        interval 1
        weight -10
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两段配置的作用是通过判断指定的路径下有无指定的文件来进行调整keepalived的优先级，从而可以实现不关闭服务就可以随时调整高可用的负载节点主备状态切换，这样可以方便服务的配置修改等操作。&lt;/p&gt;
&lt;p&gt;上面的两段配置分别是针对两个 vrrp_instance 实例的配置，让两个不同的节点分别去检测不同的文件名，如果同时去检测同一个文件，会造成混乱。&lt;/p&gt;
&lt;p&gt;另外一个就是，在主备节点设置优先级的时候，要确保当MASTER节点降级后的优先级要比BACKUP的优先级低，否则，VIP是无法进行漂移的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上面的配置实验都正常，包括图片与页面的分离负载，主备节点的切换，和双主模式下的各主备节点切换&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 15:11:00 +0000</pubDate>
<dc:creator>孤岛鱼夫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anay/p/9307908.html</dc:identifier>
</item>
<item>
<title>JVM类加载机制 - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/9300759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/9300759.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;类加载的时机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先, 我们来看一下类的生命周期, 如下图所示。其中验证、准备、解析3个阶段统称为连接。加载、验证、准备、初始化、卸载这5个阶段的顺序是确定的, 而解析阶段则不一定, 它在某些情况下可在初始化阶段之后运行, 这是为了支持Java语言的&lt;a href=&quot;https://www.cnblogs.com/ShaneZhang/p/4972550.html&quot; target=&quot;_blank&quot;&gt;运行时绑定&lt;/a&gt;(也叫后期绑定或动态绑定)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180712174004641-304483486.png&quot; alt=&quot;&quot; width=&quot;850&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于初始化阶段, 虚拟机规范严格规定了&lt;strong&gt;有且只有&lt;/strong&gt;以下5种情况, 必须&lt;strong&gt;立即&lt;/strong&gt;对类进行初始化:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;遇到new、getstatic、putstatic、invokestatic这4条字节码指令时, 如果类没有进行过初始化, 则需要先触发其初始化。生成这4条指令的常见场景是: 使用new关键字实例化对象时, 读取或设置一个类的静态字段(被final修饰、已在编译期将结果放入常量池的静态字段除外)时, 调用一个类的静态方法时。&lt;/li&gt;
&lt;li&gt;使用java.lang.reflect包的方法对类进行反射调用时, 如果类没有进行过初始化, 则需要先触发其初始化。&lt;/li&gt;
&lt;li&gt;当初始化一个类时, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化。&lt;/li&gt;
&lt;li&gt;当虚拟机启动时, 用户需要指定一个要执行的主类, 虚拟机会先初始化这个主类。&lt;/li&gt;
&lt;li&gt;当使用 JDK 1.7 的动态语言支持时, 如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄, 并且该方法句柄所对应的类没有进行过初始化, 则需要先触发其初始化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述5种会触发类进行初始化的场景行为, 称为对一个类进行&lt;strong&gt;主动引用&lt;/strong&gt;。除此之外, 所有引用类的方式都不会触发初始化, 称为&lt;strong&gt;被动引用&lt;/strong&gt;。所谓的&lt;strong&gt;被动引用&lt;/strong&gt;, 例如通过子类引用父类的静态字段, 不会导致子类初始化; 通过数组定义来引用类, 不会触发此类的初始化; 读取一个类的被final修饰的静态字段, 不会触发此类的初始化。下面我们通过代码来演示下第三种情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 被动使用类字段演示：
 * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConstClass {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;ConstClass init!&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String HELLO_WORLD = &quot;hello world&quot;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 非主动使用类字段演示
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(ConstClass.HELLO_WORLD);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180712224107631-518474072.jpg&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显, 读取ConstClass类中的常量时并没有触发该类的初始化, 这是因为常量在编译阶段会通过常量传播优化, 存入到调用类的常量池中, 以后调用类对常量的引用实际都被转化为对自身常量池的引用了。而且我们也能从编译后的字节码文件中看出, Demo类在编译成Class后并没有看到对ConstClass类的符号引用, 下面是Demo类的字节码的反编译结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180712225744414-1645389069.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述的类中, 都是用静态代码块来输出初始化信息的, 而接口则不能, 编译器会为接口生成&quot;&amp;lt;clinit&amp;gt;()&quot;类构造器, 用于初始化接口中定义的成员变量。另外接口与类在初始化阶段也有一个很大的区别, 当初始化一个类时, 要求其父类全部都已经初始化过了; 但是当初始化一个接口时, 并不要求其父接口全部都完成了初始化, 只有在真正使用到父接口时(如引用接口中的常量)才会初始化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类加载的过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;加载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;加载阶段的过程如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的java.lang.Class对象(对于 HotSpot 虚拟机, Class对象比较特殊, 它虽然是对象, 但是存放在方法区中), 作为方法区这个类的各种数据的访问入口。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于&lt;strong&gt;非数组类&lt;/strong&gt;, 加载阶段既可以用系统提供的引导类加载器来完成, 也可以由用户自定义的类加载器去完成, 即继承ClassLoader类 覆写findClass()方法。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;数组类&lt;/strong&gt;, 它不通过类加载器来创建, 而由Java虚拟机直接创建。但数组类的元素类型是要靠类加载器去创建的, 一个数组类的创建过程遵循以下规则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果数组的组件类型是引用类型, 那就采用上述加载阶段的3个过程去加载这个组件类型, 数组类将在加载该组件类型的类加载器的类名称空间上被标识。&lt;/li&gt;
&lt;li&gt;如果数组的组件类型是非引用类型, Java虚拟机将会把数组类标记为与引导类加载器关联。&lt;/li&gt;
&lt;li&gt;数组类的可见性与它的组件类型的可见性一致, 如组件类型不是引用类型, 则默认数组类的可见性为public。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;加载阶段与连接阶段的部分内容是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始, 但这两个阶段的开始时间仍保持着固定的先后顺序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&amp;lt;&amp;lt;Java虚拟机规范 (Java SE 7版)&amp;gt;&amp;gt;中, 验证阶段又被分为了4个小阶段: 文件格式验证、元数据验证、字节码验证、符号引用验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件格式验证&lt;/strong&gt;的主要目的是保证输入的字节流能被正确的解析并存储于方法区中,  并在格式上符合描述一个Java类型信息的要求。通过这个小阶段的验证后, 字节流就会存储到方法区中, 所以后面的3个小阶段验证都是基于方法区的存储结构进行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元数据验证&lt;/strong&gt;的主要目的是对类的元数据信息进行语义校验, 保证不存在不符合Java语言规范的元数据信息。例如, 这个类是否有父类(除了Object类), 这个类的父类是否继承了不允许被继承的类等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节码验证&lt;/strong&gt;的主要目的是通过数据流和控制流分析, 确定程序语义是合法的、符合逻辑的。这个小阶段会对类的方法体进行校验分析, 确保方法在运行时不会做出危害虚拟机安全的事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号引用验证&lt;/strong&gt;在虚拟机将符号引用转化为直接引用时(即&lt;strong&gt;解析阶段&lt;/strong&gt;)发生, 它将对类自身以外(常量池中的各种符号引用)信息进行匹配性校验, 以确保解析动作能正确执行。例如, 符号引用中通过字符串描述的全限定名是否能找到对应的类, 符号引用中的类、字段、方法的访问性是否可被当前类访问等等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;准备阶段将正式在方法区中为类变量分配内存, 并设置类变量初始值。这里的初始值又分为以下两种情况。&lt;/p&gt;
&lt;p&gt;假设一个类变量的定义为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 123;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;则变量value在准备阶段后的初始值为0, 而把value赋值为123的动作将在&lt;strong&gt;初始化阶段&lt;/strong&gt;才会执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设一个类变量的定义为:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value = 123;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;则变量value在准备阶段后的初始值为123。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解析阶段是虚拟机将常量池内的&lt;a href=&quot;https://www.cnblogs.com/shinubi/articles/6116993.html&quot; target=&quot;_blank&quot;&gt;符号引用替换为直接引用&lt;/a&gt;的过程, 它主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符等7种符号引用进行解析。&lt;/p&gt;
&lt;p&gt;受篇幅所限, 这里我们就简单的拿&lt;strong&gt;字段符号引用&lt;/strong&gt;来举个栗子, 看下它的解析过程:&lt;/p&gt;
&lt;p&gt;在解析字段符号引用之前, 先要将字段所属的类或接口的符号引用进行解析, 如果解析类或接口的符号引用成功了, 才会对该类或接口(这里假定用C表示)进行后续的字段搜索:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束。&lt;/li&gt;
&lt;li&gt;否则, 如果在C中实现了接口, 将会按照继承关系从下往上递归搜索各个接口和它的父接口, 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回该字段的直接引用, 查找结束。&lt;/li&gt;
&lt;li&gt;否则, 如果C不是java.lang.Object, 将会按照继承关系从下往上递归搜索其父类, 如果父类中包含了简单名称和字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束。&lt;/li&gt;
&lt;li&gt;否则, 查找失败, 抛出java.lang.NoSuchFieldError异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果查找过程成功返回引用, 还需要对这个字段进行权限验证, 如不具备对该字段的访问权限, 会抛出java.lang.IllegalAccessError异常。读者如对其他几种引用的解析过程想深入了解, 可自行参阅&amp;lt;&amp;lt;深入理解Java虚拟机&amp;gt;&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;初始化阶段是执行类构造器&amp;lt;clinit&amp;gt;()方法的过程, 关于&amp;lt;clinit&amp;gt;()方法执行过程中的一些特点如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;clinit&amp;gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的, 编译器收集的顺序由语句在源文件中出现的顺序所决定。&lt;/li&gt;
&lt;li&gt;&amp;lt;clinit&amp;gt;()方法与实例构造器&amp;lt;init&amp;gt;()方法不同, 它不需要显式的调用父类构造器, 虚拟机会保证在子类的&amp;lt;clinit&amp;gt;()方法执行前, 父类的&amp;lt;clinit&amp;gt;()方法已经执行完毕。&lt;/li&gt;
&lt;li&gt;因为父类的&amp;lt;clinit&amp;gt;()方法先执行, 所以父类中定义的静态代码块要优先于子类的变量赋值操作。&lt;/li&gt;
&lt;li&gt;如果一个类中没有静态代码块, 且没有对变量的赋值操作, 那么编译器可以不为这个类生成&amp;lt;clinit&amp;gt;()方法。&lt;/li&gt;
&lt;li&gt;执行接口或实现类的&amp;lt;clinit&amp;gt;()方法, 不需要先执行父接口的&amp;lt;clinit&amp;gt;()方法。只有当父接口中定义的变量被使用时, 父接口才会初始化。&lt;/li&gt;
&lt;li&gt;虚拟机会保证一个类的&amp;lt;clinit&amp;gt;()方法在多线程环境下被正确的加锁和同步, 这样就保证了只会有一个线程去执行这个类的&amp;lt;clinit&amp;gt;()方法来进行初始化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类加载器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类与类加载器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于任意一个类, 都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性, 每一个类加载器, 都拥有一个独立的类名称空间。通俗点说, 就是两个类来源于同一个Class文件, 被同一个虚拟机加载, 但只要加载它们的类加载器不同, 则这两个类就是不相等的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;全盘负责委托机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虚拟机在运行时会产生3种ClassLoader: &lt;strong&gt;启动类加载器&lt;/strong&gt;、&lt;strong&gt;扩展类加载器&lt;/strong&gt;、&lt;strong&gt;应用程序类加载器&lt;/strong&gt;, 其中&lt;strong&gt;启动类加载器&lt;/strong&gt;由C++语言实现, 负责装载JRE的核心类库, 如&lt;span&gt;%JAVA_HOME%\jre\lib&lt;/span&gt;目录下的rt.jar。&lt;strong&gt;扩展类加载器&lt;/strong&gt;和&lt;strong&gt;应用程序类加载器&lt;/strong&gt;都是ClassLoader的子类, &lt;strong&gt;扩展类加载器&lt;/strong&gt;负责装载&lt;span&gt;%JAVA_HOME%\jre\lib\ext&lt;/span&gt;目录下的jar包, &lt;strong&gt;应用程序类加载器&lt;/strong&gt;负责装载&lt;span&gt;classpath&lt;span&gt;路径&lt;/span&gt;&lt;/span&gt;下的类库。应用程序一般都是由这3个类加载器进行装载的, 另外, 我们也可以自定义类加载器。这些类加载器之间又存在父子层级关系, 即类加载器的&lt;strong&gt;双亲委派模型&lt;/strong&gt;, 它要求除了顶层的&lt;strong&gt;启动类加载器&lt;/strong&gt;外, 其余的类加载器都应当有自己的父类加载器, 这种父子关系不是用继承而是用组合的关系来实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201807/1278884-20180713180431758-1021412864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;双亲委派模型&lt;/span&gt;&lt;/strong&gt;对于保证Java程序的安全运作很重要, 它的源代码实现主要都集中在java.lang.ClassLoader的&lt;span&gt;loadClass()&lt;/span&gt;方法中, 该方法的源代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (getClassLoadingLock(name)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, check if the class has already been loaded&lt;/span&gt;
            Class c =&lt;span&gt;&lt;span&gt; findLoadedClass&lt;/span&gt;(name);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; t0 =&lt;span&gt; System.nanoTime();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        c &lt;/span&gt;= &lt;span&gt;parent.loadClass&lt;/span&gt;(name, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        c &lt;/span&gt;=&lt;span&gt;&lt;span&gt; findBootstrapClassOrNull&lt;/span&gt;(name);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ClassNotFoundException thrown if class not found
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; from the non-null parent class loader&lt;/span&gt;
&lt;span&gt;                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If still not found, then invoke findClass in order
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to find the class.&lt;/span&gt;
                    &lt;span&gt;long&lt;/span&gt; t1 =&lt;span&gt; System.nanoTime();
                    c &lt;/span&gt;=&lt;span&gt;&lt;span&gt; findClass&lt;/span&gt;(name);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this is the defining class loader; record the stats&lt;/span&gt;
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 -&lt;span&gt; t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resolve) {
                resolveClass(c);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; c;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JVM使用&lt;strong&gt;全盘负责委托机制&lt;/strong&gt;来装载类, &lt;strong&gt;全盘负责&lt;/strong&gt;是指当一个ClassLoader装载一个类时, 除非显式的指定另外一个ClassLoader, 否则该类所依赖及引用的类也将由这个ClassLoader来装载; &lt;strong&gt;委托机制&lt;/strong&gt;是指子类加载器先委托父类加载器寻找目标类, 只有在父类加载器找不到的情况下, 子类加载器才会尝试自己去寻找并装载目标类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类加载的过程分为&lt;strong&gt;加载&lt;/strong&gt;、&lt;strong&gt;验证&lt;/strong&gt;、&lt;strong&gt;准备&lt;/strong&gt;、&lt;strong&gt;解析&lt;/strong&gt;、&lt;strong&gt;初始化&lt;/strong&gt;5个阶段。虚拟机使用&lt;strong&gt;全盘负责委托机制&lt;/strong&gt;来装载类, 它在运行时会产生多种类加载器, 这些类加载器之间有一种称为&lt;strong&gt;双亲委派模型&lt;/strong&gt;的父子层级关系。自定义类加载器时, 需要覆写&lt;span&gt;ClassLoader&lt;/span&gt;类的&lt;span&gt;findClass()&lt;/span&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot;&gt;《深入理解Java虚拟机》&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/201&quot;&gt;Java类的加载、链接和初始化&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;http://www.hollischuang.com/archives/199&quot;&gt;深度分析Java的ClassLoader机制（源码级别）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/24036.html&quot; target=&quot;_blank&quot;&gt;双亲委派模型与自定义类加载器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yangcheng33/article/details/52631940&quot; target=&quot;_blank&quot;&gt;真正理解线程上下文类加载器(多案例分析)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 14:50:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingshanli/p/9300759.html</dc:identifier>
</item>
<item>
<title>Spark（三）Spark之RDD - FrankDeng</title>
<link>http://www.cnblogs.com/frankdeng/p/9301653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frankdeng/p/9301653.html</guid>
<description>&lt;h2&gt;一、RDD的概述&lt;/h2&gt;
&lt;h3&gt;1.1　什么是RDD？&lt;/h3&gt;
&lt;p&gt;RDD（Resilient Distributed Dataset）叫做&lt;strong&gt;弹性分布式数据集&lt;/strong&gt;，&lt;strong&gt;是Spark中最基本的数据抽象&lt;/strong&gt;，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。&lt;/p&gt;
&lt;h3&gt;1.2　RDD的属性&lt;/h3&gt;
&lt;p&gt;（1）一组分片（Partition），即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。&lt;/p&gt;
&lt;p&gt;（2）一个计算每个分区的函数。Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。&lt;/p&gt;
&lt;p&gt;（3）RDD之间的依赖关系。RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。&lt;/p&gt;
&lt;p&gt;（4）一个Partitioner，即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。&lt;/p&gt;
&lt;p&gt;（5）一个列表，存储存取每个Partition的优先位置（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。&lt;/p&gt;
&lt;h3&gt;1.3　WordCount粗图解RDD&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421133911520-1150689001.png&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中hello.txt&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421134031551-1670646166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、RDD的创建方式&lt;/h2&gt;
&lt;h3&gt;2.1　通过读取文件生成的&lt;/h3&gt;
&lt;p&gt;可以从Hadoop支持的任何存储源创建分布式数据集，包括本地文件系统，HDFS，Cassandra，HBase等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
scala&amp;gt; val file = sc.textFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/spark/hello.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421134515478-653027491.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2　通过并行化的方式创建&lt;span lang=&quot;EN-US&quot;&gt;RDD&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;由一个已经存在的Scala集合创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
scala&amp;gt; val array = Array(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
array: Array[Int] &lt;/span&gt;= Array(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)

scala&lt;/span&gt;&amp;gt; val rdd =&lt;span&gt; sc.parallelize(array)
rdd: org.apache.spark.rdd.RDD[Int] &lt;/span&gt;= ParallelCollectionRDD[&lt;span&gt;27&lt;/span&gt;] at parallelize at &amp;lt;console&amp;gt;:&lt;span&gt;26&lt;/span&gt;&lt;span&gt;

scala&lt;/span&gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421134820158-111255712.png&quot; alt=&quot;&quot; width=&quot;1024&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3　其他方式&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;读取数据库等等其他的操作。也可以生成&lt;span lang=&quot;EN-US&quot;&gt;RDD。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;RDD可以通过其他的&lt;span lang=&quot;EN-US&quot;&gt;RDD转换而来的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、RDD编程API&lt;/h2&gt;
&lt;p&gt;Spark支持两个类型（算子）操作：Transformation和Action&lt;/p&gt;
&lt;h3&gt;3.1　Transformation&lt;/h3&gt;
&lt;p&gt;主要做的是就是将一个已有的RDD生成另外一个RDD。Transformation具有&lt;strong&gt;lazy&lt;/strong&gt;&lt;strong&gt;特性(延迟加载)&lt;/strong&gt;。Transformation算子的代码不会真正被执行。只有当我们的程序里面遇到一个action算子的时候，代码才会真正的被执行。这种设计让Spark更加有效率地运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用的Transformation&lt;/strong&gt;：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;66.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;转换&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;(func)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;filter&lt;/strong&gt;(func)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;flatMap&lt;/strong&gt;(func)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;mapPartitions&lt;/strong&gt;(func)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] =&amp;gt; Iterator[U]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;mapPartitionsWithIndex&lt;/strong&gt;(func)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是&lt;/p&gt;
&lt;p&gt;(Int, Interator[T]) =&amp;gt; Iterator[U]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;sample&lt;/strong&gt;(withReplacement, fraction, seed)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;union&lt;/strong&gt;(otherDataset)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对源RDD和参数RDD求并集后返回一个新的RDD&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;intersection&lt;/strong&gt;(otherDataset)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对源RDD和参数RDD求交集后返回一个新的RDD（交集）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;distinct&lt;/strong&gt;([numTasks]))&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对源RDD进行去重后返回一个新的RDD&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;groupByKey&lt;/strong&gt;([numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;reduceByKey&lt;/strong&gt;(func, [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，与groupByKey类似，reduce任务的个数可以通过第二个可选的参数来设置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;aggregateByKey&lt;/strong&gt;(zeroValue)(seqOp, combOp, [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;先按分区聚合 再总的聚合   每次要跟初始值交流 例如：aggregateByKey(0)(_+_,_+_) 对k/y的RDD进行操作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;sortByKey&lt;/strong&gt;([ascending], [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;sortBy&lt;/strong&gt;(func,[ascending], [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;与sortByKey类似，但是更灵活 第一个参数是根据什么排序  第二个是怎么排序 false倒序   第三个排序后分区数  默认与原RDD一样&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;join&lt;/strong&gt;(otherDataset, [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD  相当于内连接（求交集）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;cogroup&lt;/strong&gt;(otherDataset, [numTasks])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable&amp;lt;V&amp;gt;,Iterable&amp;lt;W&amp;gt;))类型的RDD&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;cartesian&lt;/strong&gt;(otherDataset)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;两个RDD的笛卡尔积  的成很多个K/V&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;pipe&lt;/strong&gt;(command, [envVars])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot;&gt;
&lt;p&gt;调用外部程序&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;coalesce&lt;/strong&gt;(numPartitions&lt;strong&gt;)   &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;重新分区 第一个参数是要分多少区，第二个参数是否shuffle 默认false  少分区变多分区 true   多分区变少分区 false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;repartition&lt;/strong&gt;(numPartitions)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;重新分区 必须shuffle  参数是要分多少区  少变多&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;repartitionAndSortWithinPartitions&lt;/strong&gt;(partitioner)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;重新分区+排序  比先分区再排序效率高  对K/V的RDD进行操作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;foldByKey&lt;/strong&gt;(zeroValue)(seqOp)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;该函数用于K/V做折叠，合并处理 ，与aggregate类似   第一个括号的参数应用于每个V值  第二括号函数是聚合例如：_+_&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;combineByKey&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;合并相同的key的值 rdd1.combineByKey(x =&amp;gt; x, (a: Int, b: Int) =&amp;gt; a + b, (m: Int, n: Int) =&amp;gt; m + n)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;partitionBy&lt;/strong&gt;&lt;strong&gt;（partitioner）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对RDD进行分区  partitioner是分区器 例如new HashPartition(2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;cache&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td rowspan=&quot;2&quot; valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;RDD缓存，可以避免重复计算从而减少时间，区别：cache内部调用了persist算子，cache默认就一个缓存级别MEMORY-ONLY ，而persist则可以选择缓存级别&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;persist&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;Subtract&lt;/strong&gt;&lt;strong&gt;（rdd）&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回前rdd元素不在后rdd的rdd（差集）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;leftOuterJoin&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;leftOuterJoin类似于SQL中的左外关联left outer join，返回结果以前面的RDD为主，关联不上的记录为空。只能用于两个RDD之间的关联，如果要多个RDD关联，多关联几次即可。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;rightOuterJoin&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;rightOuterJoin类似于SQL中的有外关联right outer join，返回结果以参数中的RDD为主，关联不上的记录为空。只能用于两个RDD之间的关联，如果要多个RDD关联，多关联几次即可&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;261&quot;&gt;
&lt;p&gt;&lt;strong&gt;subtractByKey&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;307&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;substractByKey和基本转换操作中的subtract类似只不过这里是针对K的，返回在主RDD中出现，并且不在otherRDD中出现的元素&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;3.2　Action&lt;/h3&gt;
&lt;p&gt;触发代码的运行，我们一段spark代码里面至少需要有一个action操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用的Action&lt;/strong&gt;:&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;动作&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;reduce&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;通过func函数聚集RDD中的所有元素，这个功能必须是课交换且可并联的&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;collect&lt;/strong&gt;()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;在驱动程序中，以数组的形式返回数据集的所有元素&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;count&lt;/strong&gt;()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;
&lt;p&gt;返回RDD的元素个数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;first&lt;/strong&gt;()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回RDD的第一个元素（类似于take(1)）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;take&lt;/strong&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个由数据集的前n个元素组成的数组&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;takeSample&lt;/strong&gt;(&lt;em&gt;withReplacement&lt;/em&gt;,&lt;em&gt;num&lt;/em&gt;, [&lt;em&gt;seed&lt;/em&gt;])&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;takeOrdered&lt;/strong&gt;(&lt;em&gt;n&lt;/em&gt;, &lt;em&gt;[ordering]&lt;/em&gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用自然顺序或自定义比较器&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;&lt;span&gt;RDD &lt;/span&gt;&lt;span&gt;的前&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;n个&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;元素。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;saveAsTextFile&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;saveAsSequenceFile&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;) &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;saveAsObjectFile&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;) &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用Java序列化以简单格式编写数据集的元素，然后可以使用Java序列化加载&lt;/span&gt;&lt;/span&gt;&lt;code&gt;SparkContext.objectFile()&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;countByKey&lt;/strong&gt;()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;foreach&lt;/strong&gt;(&lt;em&gt;func&lt;/em&gt;)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;在数据集的每一个元素上，运行函数func进行更新。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;aggregate&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;先对分区进行操作，在总体操作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;reduceByKeyLocally&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;lookup&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;top&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;fold&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;260&quot;&gt;
&lt;p&gt;&lt;strong&gt;foreachPartition&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;308&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;3.3　Spark WordCount代码编写&lt;/h3&gt;
&lt;p&gt;使用maven进行项目构建&lt;/p&gt;
&lt;h4&gt; （1）使用scala进行编写&lt;/h4&gt;
&lt;p&gt;查看官方网站，需要导入2个依赖包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421144526496-1152731884.png&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细代码&lt;/p&gt;
&lt;p&gt;SparkWordCountWithScala.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}

object SparkWordCountWithScala {
  def main(args: Array[String]): Unit = {

    val conf = new SparkConf()
    /**
      * 如果这个参数不设置，默认认为你运行的是集群模式
      * 如果设置成local代表运行的是local模式
      */
    conf.setMaster(&quot;local&quot;)
    //设置任务名
    conf.setAppName(&quot;WordCount&quot;)
    //创建SparkCore的程序入口
    val sc = new SparkContext(conf)
    //读取文件 生成RDD
    val file: RDD[String] = sc.textFile(&quot;E:\\hello.txt&quot;)
    //把每一行数据按照，分割
    val word: RDD[String] = file.flatMap(_.split(&quot;,&quot;))
    //让每一个单词都出现一次
    val wordOne: RDD[(String, Int)] = word.map((_,1))
    //单词计数
    val wordCount: RDD[(String, Int)] = wordOne.reduceByKey(_+_)
    //按照单词出现的次数 降序排序
    val sortRdd: RDD[(String, Int)] = wordCount.sortBy(tuple =&amp;gt; tuple._2,false)
    //将最终的结果进行保存
    sortRdd.saveAsTextFile(&quot;E:\\result&quot;)
    sc.stop()
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180421151823241-1753369845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;（2）使用java jdk7进行编写&lt;/h4&gt;
&lt;p&gt;SparkWordCountWithJava7.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;
import scala.Tuple2;
import java.util.Arrays;
import java.util.Iterator;

public class SparkWordCountWithJava7 {
    public static void main(String[] args) {&lt;br/&gt;SparkConf conf = new SparkConf();
        conf.setMaster(&quot;local&quot;);
        conf.setAppName(&quot;WordCount&quot;);
        JavaSparkContext sc = new JavaSparkContext(conf);
        JavaRDD&amp;lt;String&amp;gt; fileRdd = sc.textFile(&quot;E:\\hello.txt&quot;);

        JavaRDD&amp;lt;String&amp;gt; wordRDD = fileRdd.flatMap(new FlatMapFunction&amp;lt;String, String&amp;gt;() {
            @Override
            public Iterator&amp;lt;String&amp;gt; call(String line) throws Exception {
                return Arrays.asList(line.split(&quot;,&quot;)).iterator();
            }
        });

        JavaPairRDD&amp;lt;String, Integer&amp;gt; wordOneRDD = wordRDD.mapToPair(new PairFunction&amp;lt;String, String, Integer&amp;gt;() {
            @Override
            public Tuple2&amp;lt;String, Integer&amp;gt; call(String word) throws Exception {
                return new Tuple2&amp;lt;&amp;gt;(word, 1);
            }
        });

        JavaPairRDD&amp;lt;String, Integer&amp;gt; wordCountRDD = wordOneRDD.reduceByKey(new Function2&amp;lt;Integer, Integer, Integer&amp;gt;() {
            @Override
            public Integer call(Integer i1, Integer i2) throws Exception {
                return i1 + i2;
            }
        });

        JavaPairRDD&amp;lt;Integer, String&amp;gt; count2WordRDD = wordCountRDD.mapToPair(new PairFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Integer, String&amp;gt;() {
            @Override
            public Tuple2&amp;lt;Integer, String&amp;gt; call(Tuple2&amp;lt;String, Integer&amp;gt; tuple) throws Exception {
                return new Tuple2&amp;lt;&amp;gt;(tuple._2, tuple._1);
            }
        });

        JavaPairRDD&amp;lt;Integer, String&amp;gt; sortRDD = count2WordRDD.sortByKey(false);

        JavaPairRDD&amp;lt;String, Integer&amp;gt; resultRDD = sortRDD.mapToPair(new PairFunction&amp;lt;Tuple2&amp;lt;Integer, String&amp;gt;, String, Integer&amp;gt;() {
            @Override
            public Tuple2&amp;lt;String, Integer&amp;gt; call(Tuple2&amp;lt;Integer, String&amp;gt; tuple) throws Exception {
                return new Tuple2&amp;lt;&amp;gt;(tuple._2, tuple._1);
            }
        });

        resultRDD.saveAsTextFile(&quot;E:\\result7&quot;);

    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; （3）使用java jdk8进行编写&lt;/h4&gt;
&lt;p&gt;lambda表达式&lt;/p&gt;
&lt;p&gt;SparkWordCountWithJava8.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import scala.Tuple2;
import java.util.Arrays;

public class SparkWordCountWithJava8 {
    public static void main(String[] args) {&lt;br/&gt;SparkConf conf = new SparkConf();
        conf.setAppName(&quot;WortCount&quot;);
        conf.setMaster(&quot;local&quot;);
        JavaSparkContext sc = new JavaSparkContext(conf);

        JavaRDD&amp;lt;String&amp;gt; fileRDD = sc.textFile(&quot;E:\\hello.txt&quot;);
        JavaRDD&amp;lt;String&amp;gt; wordRdd = fileRDD.flatMap(line -&amp;gt; Arrays.asList(line.split(&quot;,&quot;)).iterator());
        JavaPairRDD&amp;lt;String, Integer&amp;gt; wordOneRDD = wordRdd.mapToPair(word -&amp;gt; new Tuple2&amp;lt;&amp;gt;(word, 1));
        JavaPairRDD&amp;lt;String, Integer&amp;gt; wordCountRDD = wordOneRDD.reduceByKey((x, y) -&amp;gt; x + y);
        JavaPairRDD&amp;lt;Integer, String&amp;gt; count2WordRDD = wordCountRDD.mapToPair(tuple -&amp;gt; new Tuple2&amp;lt;&amp;gt;(tuple._2, tuple._1));
        JavaPairRDD&amp;lt;Integer, String&amp;gt; sortRDD = count2WordRDD.sortByKey(false);
        JavaPairRDD&amp;lt;String, Integer&amp;gt; resultRDD = sortRDD.mapToPair(tuple -&amp;gt; new Tuple2&amp;lt;&amp;gt;(tuple._2, tuple._1));
        resultRDD.saveAsTextFile(&quot;E:\\result8&quot;);

    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4　WordCount执行过程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180425153140543-8294264.png&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180425153515149-1269337605.png&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180425153556469-238789142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、RDD的宽依赖和窄依赖&lt;/h2&gt;
&lt;h3&gt;4.1　&lt;strong&gt;RDD依赖关系的本质内幕&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于RDD是粗粒度的操作数据集，每个Transformation操作都会生成一个新的RDD，所以RDD之间就会形成类似流水线的前后依赖关系；RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。如图所示显示了RDD之间的依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180425151022105-1121308065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从图中可知：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;窄依赖：&lt;/strong&gt;是指每个父RDD的一个Partition最多被子RDD的一个Partition所使用，例如map、filter、union等操作都会产生窄依赖；（独生子女）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;宽依赖：&lt;/strong&gt;是指一个父RDD的Partition会被多个子RDD的Partition所使用，例如groupByKey、reduceByKey、sortByKey等操作都会产生宽依赖；（超生）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;需要特别说明的是对join操作有两种情况：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（1）图中左半部分join：如果两个RDD在进行join操作时，一个RDD的partition仅仅和另一个RDD中已知个数的Partition进行join，那么这种类型的join操作就是窄依赖，例如图1中左半部分的join操作(join with inputs co-partitioned)；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;（2）图中右半部分join：其它情况的join操作就是宽依赖,例如图1中右半部分的join操作(join with inputs not co-partitioned)，由于是需要父RDD的所有partition进行join的转换，这就涉及到了shuffle，因此这种类型的join操作也是宽依赖。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;总结：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p align=&quot;left&quot;&gt;在这里我们是从父RDD的partition被使用的个数来定义窄依赖和宽依赖，因此可以用一句话概括下：如果父RDD的一个Partition被子RDD的一个Partition所使用就是窄依赖，否则的话就是宽依赖。因为是确定的partition数量的依赖关系，所以RDD之间的依赖关系就是窄依赖；由此我们可以得出一个推论：即窄依赖不仅包含一对一的窄依赖，还包含一对固定个数的窄依赖。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一对固定个数的窄依赖的理解：即子RDD的partition对父RDD依赖的Partition的数量不会随着RDD数据规模的改变而改变；换句话说，无论是有100T的数据量还是1P的数据量，在窄依赖中，子RDD所依赖的父RDD的partition的个数是确定的，而宽依赖是shuffle级别的，数据量越大，那么子RDD所依赖的父RDD的个数就越多，从而子RDD所依赖的父RDD的partition的个数也会变得越来越多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2　&lt;strong&gt;依赖关系下的数据流视图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1228818/201804/1228818-20180425151747136-185909749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在spark中，会根据RDD之间的依赖关系将DAG图（有向无环图）划分为不同的阶段，对于窄依赖，由于partition依赖关系的确定性，partition的转换处理就可以在同一个线程里完成，窄依赖就被spark划分到同一个stage中，而对于宽依赖，只能等父RDD shuffle处理完成后，下一个stage才能开始接下来的计算。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;因此spark划分stage的整体思路是&lt;/strong&gt;：从后往前推，遇到宽依赖就断开，划分为一个stage；遇到窄依赖就将这个RDD加入该stage中。因此在图2中RDD C,RDD D,RDD E,RDDF被构建在一个stage中,RDD A被构建在一个单独的Stage中,而RDD B和RDD G又被构建在同一个stage中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在spark中，Task的类型分为2种：&lt;strong&gt;ShuffleMapTask&lt;/strong&gt;和&lt;strong&gt;ResultTask&lt;/strong&gt;；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;简单来说，DAG的最后一个阶段会为每个结果的partition生成一个ResultTask，即每个Stage里面的Task的数量是由该Stage中最后一个RDD的Partition的数量所决定的！而其余所有阶段都会生成ShuffleMapTask；之所以称之为ShuffleMapTask是因为它需要将自己的计算结果通过shuffle到下一个stage中；也就是说上图中的stage1和stage2相当于mapreduce中的Mapper,而ResultTask所代表的stage3就相当于mapreduce中的reducer。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在之前动手操作了一个wordcount程序，因此可知，Hadoop中MapReduce操作中的Mapper和Reducer在spark中的基本等量算子是map和reduceByKey;不过区别在于：Hadoop中的MapReduce天生就是排序的；而reduceByKey只是根据Key进行reduce，但spark除了这两个算子还有其他的算子；因此从这个意义上来说，Spark比Hadoop的计算算子更为丰富。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 14:37:00 +0000</pubDate>
<dc:creator>FrankDeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/frankdeng/p/9301653.html</dc:identifier>
</item>
<item>
<title>[phvia/dkc] 用 docker-compose 快速构建(PHP)开发环境 - farwish</title>
<link>http://www.cnblogs.com/farwish/p/9307671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/farwish/p/9307671.html</guid>
<description>[unable to retrieve full-text content]dkc 用 docker-compose 快速构建(PHP)开发环境. dkc 在此作为 docker-compose 的缩写，你可以理解为 alias dkc=docker-compose 项目地址 https://github.com/phvia/dkc 安装 docker 从 reposito</description>
<pubDate>Fri, 13 Jul 2018 14:17:00 +0000</pubDate>
<dc:creator>farwish</dc:creator>
<dc:identifier>http://www.cnblogs.com/farwish/p/9307671.html</dc:identifier>
</item>
<item>
<title>Webflux快速入门 - 洛阳融科聂晨</title>
<link>http://www.cnblogs.com/niechen/p/9303451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niechen/p/9303451.html</guid>
<description>&lt;p&gt;　　SpringWebflux是SpringFramework5.0添加的新功能，WebFlux本身追随当下最火的Reactive Programming而诞生的框架，那么本篇就来简述一下这个框架到底是做什么的&lt;/p&gt;

&lt;p&gt;　　我们知道传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的，在Servlet3.1之后才有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上，因此它的运行环境的可选择行要比传统web框架多的多。&lt;/p&gt;
&lt;p&gt;　　根据官方的说法，webflux主要在如下两方面体现出独有的优势：&lt;/p&gt;
&lt;p&gt;　　1）非阻塞式&lt;/p&gt;
&lt;p&gt;　　　　其实在servlet3.1提供了非阻塞的API，WebFlux提供了一种比其更完美的解决方案。使用非阻塞的方式可以利用较小的线程或硬件资源来处理并发进而提高其可伸缩性&lt;/p&gt;
&lt;p&gt;　　2) 函数式编程端点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;老生常谈的编程方式了，Spring5必须让你使用java8，那么函数式编程就是java8重要的特点之一，而WebFlux支持函数式编程来定义路由端点处理请求。&lt;/p&gt;


&lt;p&gt;我们先来看官网的一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158242/201807/1158242-20180713114621450-1330576417.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它们都可以用注解式编程模型，都可以运行在tomcat，jetty，undertow等servlet容器当中。但是SpringMVC采用命令式编程方式，代码一句一句的执行，这样更有利于理解与调试，而WebFlux则是基于异步响应式编程，对于初次接触的码农们来说会不习惯。对于这两种框架官方给出的建议是：&lt;/p&gt;
&lt;p&gt;　　1）如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。&lt;/p&gt;
&lt;p&gt;　　2）如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小&lt;/p&gt;
&lt;p&gt;　　3）在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大&lt;/p&gt;
&lt;p&gt;　　我个人意见是：官网明确指出，SpringWebFlux并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC吧&lt;/p&gt;


&lt;p&gt;　　在这里定义了最基本的服务端接口：HttpHandler和WebHandler&lt;/p&gt;
&lt;h2&gt;　　HttpHandler&lt;/h2&gt;
&lt;p&gt;　　HttpHandler定义了最基本的处理Http请求行为，这个接口主要作用是处理Http请求并将结果做出响应，下面这个表格是说明了Server API的使用方式及何种方式进行响应式流支持的：&lt;/p&gt;
&lt;table class=&quot;tableblock frame-all grid-all spread&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Server name&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Server API used&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;Reactive Streams support&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.8246628131021&quot;&gt;&lt;tr&gt;&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Netty&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Netty API&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;&lt;a href=&quot;https://github.com/reactor/reactor-netty&quot;&gt;Reactor Netty&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Undertow&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Undertow API&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;spring-web: Undertow to Reactive Streams bridge&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Tomcat&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Jetty&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Servlet 3.1 container&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;Servlet 3.1 non-blocking I/O&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;tableblock&quot;&gt;spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;　　WebHandler&lt;/h2&gt;
&lt;p&gt;　　WebHandler定义了Web请求必要一些处理行为，大家不妨想想看：WebFlux已经脱离了Servlet API，那么使用WebFlux时遇到会话机制怎么办，想要对请求过滤处理怎么办或者想要处理静态资源怎么办等等，那么WebHandler就是做这个事情的。其实在HttpHandler的基本实现类通过适配器模式及装饰模式也间接的实现了WebHandler接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158242/201807/1158242-20180713152711154-1202662397.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　WebHandler常见的实现类，我在这里列举一下：&lt;/p&gt;
&lt;p&gt;　　 WebHandlerDecorator：WebHandler的装饰器，利用装饰模式实现相关功能的扩展&lt;/p&gt;
&lt;p&gt;　　 HttpWebHandlerAdapter: 进行Http请求处理，同时也是HttpHandler的实现类&lt;/p&gt;
&lt;p&gt;　　 FilteringWebHandler：通过WebFilter进行过滤处理的类，类似于Servlet中的Filter&lt;/p&gt;
&lt;p&gt;　　 ExceptionHandlingWebHandler: 针对于异常的处理类&lt;/p&gt;
&lt;p&gt;　　 ResourceWebHandler：用于静态资源请求的处理类&lt;/p&gt;
&lt;p&gt;　　 DispatcherHandler：请求的总控制器，类似于WebMVC中的DispatcherServlet&lt;/p&gt;



&lt;p&gt;建立SpringBoot项目，注意SpringBoot版本必须为2.0.0+，在build.gradle配置文件里写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 compile('org.springframework.boot:spring-boot-starter-webflux')
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;基于Annotated Controller方式实现&lt;/h2&gt;
&lt;h3&gt;WebFluxConfig配置：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.DispatcherHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.config.EnableWebFlux;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.config.WebFluxConfigurer;

@Configuration
@ComponentScan
@EnableWebFlux
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebFluxConfig &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebFluxConfigurer {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebHandler webHandler(ApplicationContext applicationContext) {
        DispatcherHandler dispatcherHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DispatcherHandler(applicationContext);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dispatcherHandler;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们创建一个WebHandler并使用@EnableWebFlux打开相关功能。我们可以发现与SpringMVC的WebConfig配置真的好像&lt;/p&gt;

&lt;h3&gt;Controller:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {

    @GetMapping(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这里与SpringMVC定义的Controller无异&lt;/p&gt;
&lt;h3&gt;Main方法：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.reactive.HttpHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.server.adapter.WebHttpHandlerBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; reactor.ipc.netty.http.server.HttpServer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 基于Reactor Netty实现WebFlux服务
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; chen.nie
* @date 2018/7/13
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringWebfluxApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        AnnotationConfigApplicationContext applicationContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(WebFluxConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过ApplicationContext创建HttpHandler&lt;/span&gt;
        HttpHandler httpHandler =&lt;span&gt; WebHttpHandlerBuilder.applicationContext(applicationContext).build();
        ReactorHttpHandlerAdapter httpHandlerAdapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReactorHttpHandlerAdapter(httpHandler);
        HttpServer.create(&lt;/span&gt;&quot;localhost&quot;,8080&lt;span&gt;).newHandler(httpHandlerAdapter).block();
        System.in.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　程序启动成功后即可通过http://localhost:8080/index拿到对应结果&lt;/p&gt;
&lt;h2&gt;函数式编程方式&lt;/h2&gt;
&lt;p&gt;　　使用这种方式请先了解Java8提供的函数式编程特性。那么我们先编写一个简单的Handler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive.handler;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeanUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.server.ServerRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.server.ServerResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; reactor.core.publisher.Mono;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; org.springframework.http.MediaType.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.BodyInserters.fromObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.server.ServerResponse.ok;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 类似于Controller，处理用户请求的真实逻辑
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentHandler {


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt;&lt;span&gt; selectStudent(ServerRequest request) {
        Student studentBody &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
        request.bodyToMono(Student.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;).subscribe(student -&amp;gt;&lt;span&gt; BeanUtils.copyProperties(student, studentBody));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ok().contentType(APPLICATION_JSON_UTF8).body(fromObject(studentBody));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt;&lt;span&gt; insertStudent(ServerRequest request){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ok().contentType(TEXT_PLAIN).body(fromObject(&quot;success&quot;&lt;span&gt;));

    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个Handler类似于Controller的作用，在这里的返回值均为Mono类型，其中ServerRequest和ServerResponse，大家可以先理解为WebFlux替代ServletRequest与ServletResponse对象的，而且这些类能够支持异步。&lt;/p&gt;
&lt;p&gt;　　Main方法里我们创建的HttpHandler的方式需要进行改变一下，同样用函数式方式进行编写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.hzgj.framework.study.springwebflux.web.reactive.handler.StudentHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.MediaType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.reactive.HttpHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.server.reactive.ReactorHttpHandlerAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; reactor.ipc.netty.http.server.HttpServer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; org.springframework.web.reactive.function.server.RequestPredicates.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.server.RouterFunctions.route;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.springframework.web.reactive.function.server.RouterFunctions.toHttpHandler;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FunctionRouteApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

        HttpHandler httpHandler &lt;/span&gt;=&lt;span&gt; toHttpHandler(
                route(POST(&lt;/span&gt;&quot;/selectStudent&quot;&lt;span&gt;).and(accept(MediaType.APPLICATION_JSON_UTF8)), StudentHandler::selectStudent).
                        and(route(GET(&lt;/span&gt;&quot;/saveStudent&quot;&lt;span&gt;), StudentHandler::insertStudent)));
        ReactorHttpHandlerAdapter httpHandlerAdapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReactorHttpHandlerAdapter(httpHandler);
        HttpServer.create(&lt;/span&gt;&quot;localhost&quot;, 8080&lt;span&gt;).newHandler(httpHandlerAdapter).block();
        System.in.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动成功后，我们用postman测试一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158242/201807/1158242-20180713215758153-1705120468.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以看到使用函数式编程创建路由端点，也可以实现同样的功能。&lt;/p&gt;

</description>
<pubDate>Fri, 13 Jul 2018 14:06:00 +0000</pubDate>
<dc:creator>洛阳融科聂晨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niechen/p/9303451.html</dc:identifier>
</item>
<item>
<title>简单的互斥同步方式——synchronized关键字详解 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9307572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9307572.html</guid>
<description>&lt;h2 id=&quot;关于synchronized关键字&quot;&gt;1. 关于synchronized关键字&lt;/h2&gt;
&lt;p&gt;java中要实现多线程的互斥同步访问，最简单的方式就是使用synchronized关键字。被其修饰的代码，相当于加了独占锁,线程只能互斥的访问，即同一时间只有一个线程能够访问这部分代码，其他线程只能在外等待。那么synchronized是如何做到这一点的？使用它还有哪些值得关注的细节？&lt;/p&gt;
&lt;h2 id=&quot;synchronized的原理和实现细节&quot;&gt;2. synchronized的原理和实现细节&lt;/h2&gt;
&lt;h4 id=&quot;synchronized可以用在那些地方&quot;&gt;2.1 synchronized可以用在那些地方&lt;/h4&gt;
&lt;h4 id=&quot;synchronized是如何实现线程互斥访问的&quot;&gt;2.2 synchronized是如何实现线程互斥访问的&lt;/h4&gt;
&lt;p&gt;虽然对于同步方法和同步代码块的底层细节略有不同，但都可以这么理解：对于被synchronized关键字修饰的代码区域,java虚拟机会在开始的位置插入monitorenter指令，而在结束和异常处插入monitorexit指令,每一个monitorenter指令必定有一个monitorexit指令与其配对。线程在执行到monitorenter指令时，将会尝试获取锁对象的monitor(监视器),该线程将进入同步方法或同步代码块中，同时monitor被锁定，防止被多个线程同时获取。获取monitor失败的线程将被阻塞在同步块或同步方法的入口处，整个过程如下图所示。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180713215058641-1269489062.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;对象锁的monitor信息存储在哪&quot;&gt;2.3 对象锁的monitor信息存储在哪&lt;/h4&gt;
&lt;p&gt;正如上面介绍的那样,任何对象都可以作为synchronized代码块的锁,而每个对象锁都有个monitor与之关联,线程通过获取该monitor的所有权来实现对被同步代码的互斥访问。这个monitor信息存储对象的对象头重。&lt;/p&gt;
&lt;h4 id=&quot;monitor信息在对象头中的实现细节&quot;&gt;2.4 monitor信息在对象头中的实现细节&lt;/h4&gt;
&lt;p&gt;对象锁的monitor信息是存储在该对象的对象头中。对象头的基本信息主要包括&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180713215115398-795491189.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于锁信息是在Mark Word中,我们继续看看Mark Word到底包括哪些信息&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180713215126616-684602876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容比较多,不用强行记忆，只要知道大概有些东西就行了。&lt;/p&gt;
&lt;h2 id=&quot;synchronized的内存语义&quot;&gt;3. synchronized的内存语义&lt;/h2&gt;
&lt;h4 id=&quot;synchronized的可见性分析&quot;&gt;3.1 synchronized的可见性分析&lt;/h4&gt;
&lt;p&gt;由JMM的happens-before规则可知,对同步锁的释放happens-before于对同步锁的获取,因此在A线程释放锁之前对同步区域内共享变量作的修改，另一个线程B获取锁后将能够马上看到这种变化。它实现的原理和volatile类似&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A线程释放锁时,JMM会把该线程对应的工作内存中的共享变量刷新到主存中&lt;/li&gt;
&lt;li&gt;B线程获取锁后,JMM会把该线程对应的工作内存中的共享变量置为无效,同步代码块中的共享变量必须从主存中获取。&lt;br/&gt;因此,如果共享变量只在同步代码块或者同步方法中被用到,那它是没必要用volatile修饰的！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;synchronized禁止指令重排吗&quot;&gt;3.2 synchronized禁止指令重排吗&lt;/h4&gt;
&lt;p&gt;那同步代码块会禁止指令重排吗？答案是不会。但只要同步块中的共享变量对其他线程不可见，那么我们就不必担心它引起的副作用。下面就是一个典型的例子&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态内部类的懒汉式实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private Singleton() {

    }

    static class SingletonHolder {
        public static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是线程安全的实现方式,尽管INSTANCE变量没有用volatile修饰，但我们不用担心指令重排序带来的线程不安全问题。因为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTANCE = new Singleton();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是在类初始化的过程中执行的.JVM在Class文件被加载后,被线程使用前会执行类的初始化。这个过程会通过一个初始化锁进行同步(对于每一个类或接口,都有唯一的初始化锁)，也就是说只有一个线程能获取该锁并执行这段代码,其他无法线程无法访问到INSTANCE变量，故重排序对其他线程不可见,整个过程是线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;锁的优化&quot;&gt;4.锁的优化&lt;/h2&gt;
&lt;p&gt;为了减少频繁获得和释放锁的性能开销,JVM做了一系列优化。锁一共分为4种状态,级别从低到高依次为:无锁状态,偏向锁状态,轻量级锁状态,重量级锁状态。锁的状态会随着竞争的加剧逐渐升级,获得和释放锁的性能开销也逐渐加大,且锁只能升级而不能降级。为什么需要这么设置,它们各自又有什么特点,什么时候会出发锁的升级？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;偏向锁: 当线程第一次访问同步块时,锁为偏向锁,该线程将一直持有偏向锁,直到有其他线程竞争该锁,该线程才释放锁,偏向锁也升级为轻量级锁。持有偏向锁的线程只在第一次获取时会进行CAS同步,接下来的访问和释放锁将不需要进行任何同步操作。&lt;/li&gt;
&lt;li&gt;轻量级锁:轻量级锁在获取锁的时候会使用CAS操作将锁对象头的mark word替换到线程的栈帧中，释放锁则使用CAS替换回来。竞争线程不会阻塞,而是使用自旋的方式等待,同时轻量级锁将升级为重量级锁。&lt;/li&gt;
&lt;li&gt;重量级锁:获取和释放锁更消耗性能，且竞争锁失败的线程将被阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是锁升级时的状态图&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180713215145844-1735417129.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;synchronized可以起到独占锁的作用,使多线程互斥的访问被其修饰的代码。虽然这种串行化会极大影响执行速度,但是能很好的保证线程安全,是开发中最经常使用的多线程技术之一。synchronized和volatile一样保证了多线程之间的可见性,又由于线程访问时的独占性对其他线程屏蔽了指令重排的细节，故而可以说是比volatile更重量级也更可靠的同步工具。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 13:59:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9307572.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——.Net Core集成测试与数据驱动测试 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9306221.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9306221.html</guid>
<description>&lt;p&gt;　　软件的单元测试关注是的软件最小可执行单元是否能够正常执行，但是软件是由一个个最小执行单元组成的集合体，单元与单元之间存在着种种依赖或联系，所以在软件开发时仅仅确保最小单元的正确往往是不够的，为了保证软件能够正确运行，单元与单元之间的集成测试是非常必要。&lt;br/&gt;　　另外上一篇文章只是介绍了如何使用xUnit.net对.Net Core程序进行简单(无参)的单元测试以及计算代码的覆盖率，但是在实际的测试工作中，往往会通过语句覆盖、条件/分支覆盖(白盒)方式以及等价类、边界值等(黑盒)方式来设计测试用例，这些用例的测试的关键点在于传入测试方法的参数是不同的，如果使用无参测试方法那么针对不同的测试用例就需要编写大量的测试方法，这是不现实的。&lt;br/&gt;　　本文将从以下几个方面，在单元测试的基础上介绍如何完成数据驱动测试以及代码依赖的集成测试：&lt;/p&gt;
&lt;h2&gt;集成测试简介&lt;/h2&gt;
&lt;p&gt;　　集成测试简单的理解就是在单元测试的基础上，将各个单元根据其依赖关系集成起来，检查代码是否能够正确运行，集成测试根据软件开发方式的不同或者软件架构不同也有不同的集成方式，比如面向过程的设计方式和面向对象设计方式、单体架构以及微服务分布式架构等等。&lt;br/&gt;　　本文涉及到的仅仅是面向对象编程中类与类之间依赖的集成测试。&lt;/p&gt;
&lt;h2&gt;使用xUnit.Net实现简单的数据库集成测试&lt;/h2&gt;
&lt;p&gt;　　数据库是大部分软件系统不可缺少的组件，所以在集成测试时与数据库集成是一种常见的测试场景，下面就开始介绍如何通过xUnit.Net来测试。&lt;br/&gt;　　1. 编写被测试代码：&lt;br/&gt;　　在被测试项目中引入EFCore以及相关组件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170443866-792630810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加DBContext以及相应的数据操作代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170504831-78255748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：此处使用LocalDB作为数据库完成测试，如果使用SQL Server修改连接字符串即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170744498-32120091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户仓储中实现了用户添加以及根据姓名查询的方法。&lt;br/&gt;　　&lt;span&gt;注：完成代码编写后，需要将实体代码迁移到数据库，先通过Add-Migration添加迁移代码，然后通过update-database命令将数据更新到数据库，迁移方法可参考：&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/get-started/full-dotnet/new-db&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/ef/core/get-started/full-dotnet/new-db&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;　　2.编写测试代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170810471-818715534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试代码也非常简单，就是创建一个SQLServer的用户仓储实例，然后通过构造的方式将其注入到UserManager类型中使用，后续UserManager的创建、查询用户的方法将通过该仓储实现。&lt;br/&gt;　　3.测试运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170833997-1138162205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;可回归的数据库集成测试&lt;/h2&gt;
&lt;p&gt;　　这里的回归指的是回归测试，&lt;strong&gt;&lt;span&gt;回归测试是指当修改了旧的代码后需要重新对旧代码进行测试确认此次修改没有影响到已有代码&lt;/span&gt;&lt;/strong&gt;。一般来说使用xUnit.Net实现的测试均是可回归的，因为测试代码不变，且测试代码可以重复执行，另外测试代码也被代码版本管理工具管理，当修改代码后重新执行所有测试方法即可。&lt;br/&gt;　　但是与数据库相关的测试又有所区别，数据库是数据持久化工具，对数据的每一次操作都会被持久化，假设有两个测试用例，第一是添加一条数据，第二是查询这条数据的数量是否为1，那么这两个测试在第一次运行的时候是没有问题的，但是再次运行时第一个用例可能主键冲突无法被添加，或者添加成功后第二个用例查询结果为2，导致测试失败，这样的测试视为不可回归。&lt;br/&gt;　　下面就介绍如何使用xUnit.Net实现数据库集成的回归测试：&lt;/p&gt;
&lt;h3&gt;使用构造方法初始化数据库&lt;/h3&gt;
&lt;p&gt;　　要实现数据库集成测试的可回归性，其实最主要的问题在于每次执行完单元测试后数据库的状态都是不同的，那么解决这个问题在每次执行测试前将数据库初始化是否就可以解决了呢？&lt;br/&gt;　　看下面代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170912974-233165359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先为测试类添加构造方法，在构造方法中初始化数据库。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713170946085-564774909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在测试方法中添加用户数量测试断言，当添加完成用户后，应该一共存在1个用户。&lt;br/&gt;　　执行测试方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171026211-146929050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　无论执行多少次测试都是通过的，这意味着每次添加用户后用户数量均为1，这样就达到了测试的可回归性。&lt;br/&gt;　　但是真实的开发过程中，不可能只有一个测试类型，而且如果为每一个测试类型都添加初始化数据库的代码，那么这些单元测试将会执行的非常慢(数据库的初始化非常耗时)，那么要如何解决这个问题？&lt;/p&gt;
&lt;h3&gt;使用Fixture共享测试上下文&lt;/h3&gt;
&lt;p&gt;　　Fixture是xUnit.Net中的一项特性，它可以用来共享测试上下文，Fixture可以译为固定装置，换句话说就是把一个内容固定住，使该内容可以在被指定的范围内使用。xUnit.Net中Fixture有两种类型，分别是ClassFixture和CollectionFixture，它们对应的是在一个测试类型里面共享和一个测试类型集合中共享上下文，Fixture的作用有很多，下面将介绍如何使用Fixture来共享数据库被初始化这一状态(不需要重复初始化)：&lt;br/&gt;　　1. 创建一个Fixture类型：&lt;br/&gt;　　Fixture实际上是一个普通的C#类型，唯一需要注意的是它使用构造方法初始化数据、使用Dispose来释放或者清理数据，简单的一个Fixture类型如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171141816-2102077935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 为单个类型使用ClassFixture：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171205049-1036049196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从代码中可以看到通过构造方法初始化的代码已经被注释了，实现IClassFixture接口后，再次执行测试方法，可以看到测试仍然是可回归的。&lt;br/&gt;　　3. 为多个类型使用ICollectionFixture：&lt;br/&gt;　　首先需要在DatabaseFixture的基础上添加一个实现ICollectionFixture的类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171231576-426929897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　两个要点分别是需要使用CollectionDefinition特性，然后类型需要实现ICollectionFixture&amp;lt;T&amp;gt;接口。&lt;br/&gt;　　在测试类型上通过Collection特性，指定之前定义的Collection名称来应用该CollectionFixture：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171256462-808728433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后多次执行测试方法，可以发现测试仍然是可回归的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171314164-809414337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：在共享测试上下数据时(包括共享数据库数据)，可能&lt;strong&gt;会因为测试方法执行顺序导致测试失败&lt;/strong&gt;，但是xUnit.Net中没有提供按顺序执行实现方式，默认是按照方法命名，如果需要按照一定顺序执行测试，可参考官方的例子：&lt;a href=&quot;https://github.com/xunit/samples.xunit/tree/master/TestOrderExamples&quot; target=&quot;_blank&quot;&gt;https://github.com/xunit/samples.xunit/tree/master/TestOrderExamples&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;测试数据的管理与初始化&lt;/h2&gt;
&lt;p&gt;　　涉及到数据库的测试，很可能在测试之前数据库就会存在一些已有的测试数据，使用xUnit.Net来编写测试代码时，可以将测试数据的初始化放到Fixture类型中，但是要如何对这些数据进行管理呢？一般来说使用SQL脚本来管理数据库的测试数据是一种不错的方式，因为这样测试数据与代码解耦，维护数据时仅需要维护SQL脚本文件即可。&lt;br/&gt;　　下面就介绍一下如何在xUnit.Net中使用SQL脚本文件管理以及初始化数据：&lt;br/&gt;　　1.创建一个SQL脚本：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171358303-1338354588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：需要将文件的“复制到输出目录”设置为“总是复制”或者“有更新复制”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171420969-493413566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.在Fixture类型初始化数据库时，执行SQL脚本初始化数据：&lt;br/&gt;　　下面代码首先去Data目录下查找.sql的所有文件，然后依次执行这些SQL脚本。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171447004-684469920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.修改测试代码(因为脚本添加了2条数据，所以期望值应该是3条)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171535997-658525168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.执行测试：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171638982-2120585745.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　测试成功。&lt;/p&gt;
&lt;h2&gt;数据驱动测试简介&lt;/h2&gt;
&lt;p&gt;　　文章最开始提到过，不管是白盒的覆盖测试还是黑盒的边界/等价测试，它们最直接的体现就是“参数”，传入被测试方法的参数。而这些参数实际上就是“测试用例”，为每一个测试用例编写一个测试方法是不合理的，所以需要一种方法通过变换参数来完成测试，并且尽可能的重用测试代码。这就是数据驱动测试。&lt;/p&gt;
&lt;h2&gt;基于xUnit.Net的数据驱动测试&lt;/h2&gt;
&lt;h3&gt;Theory&amp;amp;InlineData&lt;/h3&gt;
&lt;p&gt;　　Theory和InlineData是xUnit.Net中提供的数据驱动(参数化)测试的功能特性，下面是一个theory以及InlineData的应用示例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713171727259-655275955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172136065-1836346376.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　通过InlineData就可以轻易的将测试用例的数据应用到测试方法上，并完成期望的测试。但是当添加新的测试用例时就需要对代码文件进行修改，测试用例放置在代码中管理也不是非常方便，有没有一种可以独立管理测试用例数据的方法呢？&lt;/p&gt;
&lt;h3&gt;基于excel的数据驱动测试&lt;/h3&gt;
&lt;p&gt;　　xUnit.Net没有提供内置的Excel数据加载功能，但是它的拓展性很好，可以通过实现DataAttribute实现一个Theory的数据源提供器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172212384-419025755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1. 实现DataAttribute抽象类，实现Excel的Theory数据提供器：&lt;br/&gt;　　下面是实现Excel数据加载的核心方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172242248-906228329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172300137-714120775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172313396-1934513271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上方法需要注意以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;两个主体：Excel文件名称和测试的方法的MethodInfo，前者用于读取Excel文件，后者用来获取参数信息。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;通过MethodInfo获取测试方法的参数列表包括参数类型。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;读取Excel数据并于测试方法的参数列表匹配，简单来说就是Excel中每一行的数据就是对应测试方法的参数，有多少行数据测试方法就会被执行多少次。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;当Excel中数据读取为double或者float但是测试方法需要int时，需要进行转换。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;注：此处使用的Excel文件读取组件为：&lt;a href=&quot;https://github.com/ExcelDataReader/ExcelDataReader&quot; target=&quot;_blank&quot;&gt;https://github.com/ExcelDataReader/ExcelDataReader&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;DataAttribute完整代码见：&lt;a href=&quot;https://github.com/yqszt/xUnitTestDemo/blob/master/XUnitTestProject/ExcelDataAttribute.cs&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/yqszt/xUnitTestDemo/blob/master/XUnitTestProject/ExcelDataAttribute.cs&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2.使用ExcelDataAttribute:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172407695-1853921600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 在AdditionTestCase.xls中添加测试用例数据：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172444782-2050427249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：需要将AdditionTestCase.xls的复制到输出目录属性设置为“总是复制”或“复制新文件”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　4.执行测试方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201807/640251-20180713172519599-1543115264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试成功。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文主要介绍了.Net Core使用xUnit.Net实现了与数据的集成测试并通过Fixture的方式实现了数据库的初始化，保证了测试的可回归性。另外还介绍了如何使用xUnit.Net来实现数据驱动测试，数据驱动测试可以简单地通过添加用例数据的方式来提高测试质量，还可以便捷的对测试用例进行管理。&lt;/p&gt;
&lt;p&gt;本文示例代码：&lt;a href=&quot;https://github.com/yqszt/xUnitTestDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/yqszt/xUnitTestDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Integration_testing&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Integration_testing&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Data-driven_testing&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Data-driven_testing&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://xunit.github.io/docs/getting-started-dotnet-core#write-first-theory&quot; target=&quot;_blank&quot;&gt;https://xunit.github.io/docs/getting-started-dotnet-core#write-first-theory&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://dotnetliberty.com/index.php/2015/12/31/fast-asp-net-5-integration-testing-with-xunit/&quot; target=&quot;_blank&quot;&gt;http://dotnetliberty.com/index.php/2015/12/31/fast-asp-net-5-integration-testing-with-xunit/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://github.com/MisterJames/GenFu&quot; target=&quot;_blank&quot;&gt;https://github.com/MisterJames/GenFu&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://ikeptwalking.com/writing-data-driven-tests-using-xunit/&quot; target=&quot;_blank&quot;&gt;http://ikeptwalking.com/writing-data-driven-tests-using-xunit/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://wandering.life/data-driven-testing-xunit-vs2017/&quot; target=&quot;_blank&quot;&gt;https://wandering.life/data-driven-testing-xunit-vs2017/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://github.com/ExcelDataReader/ExcelDataReader&quot; target=&quot;_blank&quot;&gt;https://github.com/ExcelDataReader/ExcelDataReader&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://xunitpatterns.com/Testing%20With%20Databases.html&quot; target=&quot;_blank&quot;&gt;http://xunitpatterns.com/Testing%20With%20Databases.html&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://xunit.github.io/docs/shared-context&quot; target=&quot;_blank&quot;&gt;https://xunit.github.io/docs/shared-context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——.Net Core集成测试与数据驱动测试&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9306221.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9306221.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8675028&quot; href=&quot;https://www.cnblogs.com/selimsong/p/8675028.html&quot;&gt;好代码是管出来的——浅谈.Net Core的代码管理方法与落地（更新中...）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Jul 2018 13:51:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9306221.html</dc:identifier>
</item>
</channel>
</rss>